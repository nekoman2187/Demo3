   1                             		.file	"dsa.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.section	.text.ForceZero,"ax",@progbits
   6                             	_ForceZero:
   7                             	.LFB13:
   8                             		.file 1 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfcrypt/src/misc.c"
   1:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* misc.c
   2:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   3:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   5:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * This file is part of wolfSSL.
   6:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   7:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * it under the terms of the GNU General Public License as published by
   9:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * (at your option) any later version.
  11:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  12:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * GNU General Public License for more details.
  16:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  17:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * You should have received a copy of the GNU General Public License
  18:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * along with this program; if not, write to the Free Software
  19:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  21:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /*
  22:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  23:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** DESCRIPTION
  24:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** This module implements the arithmetic-shift right, left, byte swapping, XOR,
  25:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** masking and clearing memory logic.
  26:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  27:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** */
  28:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef HAVE_CONFIG_H
  29:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <config.h>
  30:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  31:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  32:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/settings.h>
  33:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  34:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLF_CRYPT_MISC_C
  35:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #define WOLF_CRYPT_MISC_C
  36:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  37:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/misc.h>
  38:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  39:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* inlining these functions is a huge speed increase and a small size decrease,
  40:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    because the functions are smaller than function call setup/cleanup, e.g.,
  41:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    md5 benchmark is twice as fast with inline.  If you don't want it, then
  42:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    define NO_INLINE and compile this file into wolfssl, otherwise it's used as
  43:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    a source header
  44:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  45:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  46:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef NO_INLINE
  47:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC
  48:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  49:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC static
  50:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  51:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  52:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Check for if compiling misc.c when not needed. */
  53:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if !defined(WOLFSSL_MISC_INCLUDED) && !defined(NO_INLINE)
  54:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_IGNORE_FILE_WARN
  55:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #warning misc.c does not need to be compiled when using inline (NO_INLINE not defined)
  56:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
  57:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  58:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  59:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  60:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  61:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__ICCARM__)
  62:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <intrinsics.h>
  63:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  64:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  65:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  66:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef INTEL_INTRINSICS
  67:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  68:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <stdlib.h>      /* get intrinsic definitions */
  69:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  70:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* for non visual studio probably need no long version, 32 bit only
  71:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****      * i.e., _rotl and _rotr */
  72:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #pragma intrinsic(_lrotl, _lrotr)
  73:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  74:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  75:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  76:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotl(x, y) : x;
  77:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  78:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  79:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
  80:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  81:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotr(x, y) : x;
  82:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  83:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  84:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
  85:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  86:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <builtin.h>      /* get intrinsic definitions */
  87:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  88:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if !defined(NO_INLINE)
  89:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  90:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotlFixed(x, y) _builtin_rotl(x, y)
  91:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  92:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotrFixed(x, y) _builtin_rotr(x, y)
  93:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  94:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #else /* create real function */
  95:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  96:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  97:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  98:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotl(x, y);
  99:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 100:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 101:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 102:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 103:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotr(x, y);
 104:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 105:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 106:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 107:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 108:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else /* generic */
 109:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value. */
 110:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 111:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
 112:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 113:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x << y) | (x >> (sizeof(y) * 8 - y));
 114:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 115:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 116:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value. */
 117:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 118:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 119:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x >> y) | (x << (sizeof(y) * 8 - y));
 120:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 121:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 122:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 123:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 124:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef WC_RC2
 125:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 126:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value */
 127:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotlFixed16(word16 x, word16 y)
 128:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 129:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 130:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 131:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 132:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 133:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value */
 134:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotrFixed16(word16 x, word16 y)
 135:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 136:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 137:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 138:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 139:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WC_RC2 */
 140:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 141:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of 32-bit word value. */
 142:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__CCRX__) && !defined(NO_INLINE) /* shortest version for CC-RX */
 143:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define ByteReverseWord32(value) _builtin_revl(value)
 144:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 145:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word32 ByteReverseWord32(word32 value)
 146:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 147:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef PPC_INTRINSICS
 148:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* PPC: load reverse indexed instruction */
 149:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__lwbrx(&value,0);
 150:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__ICCARM__)
 151:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__REV(value);
 152:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(KEIL_INTRINSICS)
 153:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__rev(value);
 154:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
 155:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)_builtin_revl(value);
 156:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLF_ALLOW_BUILTIN) && \
 157:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 158:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__builtin_bswap32(value);
 159:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 160:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       defined(__aarch64__)
 161:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 162:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV32 %0, %0  \n"
 163:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 164:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 165:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 166:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 167:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 168:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       (defined(__thumb__) || defined(__arm__))
 169:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 170:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV %0, %0  \n"
 171:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 172:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 173:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 174:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 175:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(FAST_ROTATE)
 176:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 5 instructions with rotate instruction, 9 without */
 177:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (rotrFixed(value, 8U) & 0xff00ff00) |
 178:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****            (rotlFixed(value, 8U) & 0x00ff00ff);
 179:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 180:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 6 instructions with rotate instruction, 8 without */
 181:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 182:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed(value, 16U);
 183:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 184:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 185:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* __CCRX__ */
 186:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of words array of a given count. */
 187:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords(word32* out, const word32* in,
 188:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                     word32 byteCount)
 189:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 190:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word32), i;
 191:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 192:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 193:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord32(in[i]);
 194:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 195:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 196:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 197:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WORD64_AVAILABLE) && !defined(WOLFSSL_NO_WORD64_OPS)
 198:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 199:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 200:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotlFixed64(word64 x, word64 y)
 201:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 202:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 203:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 204:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 205:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 206:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotrFixed64(word64 x, word64 y)
 207:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 208:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 209:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 210:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 211:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 212:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 ByteReverseWord64(word64 value)
 213:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 214:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WOLF_ALLOW_BUILTIN) && defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 215:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)__builtin_bswap64(value);
 216:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFCRYPT_SLOW_WORD64)
 217:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)((word64)ByteReverseWord32((word32) value)) << 32 |
 218:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         (word64)ByteReverseWord32((word32)(value   >> 32));
 219:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 220:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) |
 221:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
 222:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) |
 223:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
 224:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed64(value, 32U);
 225:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 226:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 227:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 228:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 229:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords64(word64* out, const word64* in,
 230:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                       word32 byteCount)
 231:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 232:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word64), i;
 233:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 234:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 235:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord64(in[i]);
 236:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 237:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 238:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 239:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WORD64_AVAILABLE && !WOLFSSL_NO_WORD64_OPS */
 240:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 241:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_XOR_OPS
 242:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 243:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 244:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWordsOut(wolfssl_word* r, const wolfssl_word* a,
 245:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                      const wolfssl_word* b, word32 n)
 246:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 247:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 248:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 249:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] = a[i] ^ b[i];
 250:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 251:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 252:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 253:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 254:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 255:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbufout(void*out, const void* buf, const void* mask,
 256:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                    word32 count)
 257:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 258:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)out | (wc_ptr_t)buf | (wc_ptr_t)mask | count) %
 259:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                          WOLFSSL_WORD_SIZE == 0)
 260:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWordsOut( (wolfssl_word*)out, (wolfssl_word*)buf,
 261:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                      (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 262:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 263:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 264:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       o = (byte*)out;
 265:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 266:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 267:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 268:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) o[i] = b[i] ^ m[i];
 269:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 270:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 271:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 272:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 273:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 274:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWords(wolfssl_word* r, const wolfssl_word* a, word32 n)
 275:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 276:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 277:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 278:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] ^= a[i];
 279:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 280:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 281:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 282:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 283:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 284:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbuf(void* buf, const void* mask, word32 count)
 285:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 286:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)buf | (wc_ptr_t)mask | count) % WOLFSSL_WORD_SIZE == 0)
 287:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWords( (wolfssl_word*)buf,
 288:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                   (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 289:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 290:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 291:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 292:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 293:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 294:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) b[i] ^= m[i];
 295:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 296:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 297:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 298:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 299:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_FORCE_ZERO
 300:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine fills the first len bytes of the memory area pointed by mem
 301:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    with zeros. It ensures compiler optimizations doesn't skip it  */
 302:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
 303:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
   9                             		.loc 1 303 1
  10 0000 7E AA                   		push.l	r10
  11                             	.LCFI0:
  12 0002 71 0A F4                		add	#-12, r0, r10
  13                             	.LCFI1:
  14 0005 EF A0                   		mov.L	r10, r0
  15 0007 E7 A1 01                		mov.L	r1, 4[r10]
  16 000a E7 A2 02                		mov.L	r2, 8[r10]
 304:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile byte* z = (volatile byte*)mem;
  17                             		.loc 1 304 20
  18 000d ED A5 01                		mov.L	4[r10], r5
  19 0010 E3 A5                   		mov.L	r5, [r10]
 305:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 306:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if (defined(WOLFSSL_X86_64_BUILD) || defined(WOLFSSL_AARCH64_BUILD)) \
 307:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****             && defined(WORD64_AVAILABLE)
 308:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile word64* w;
 309:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_UNALIGNED_64BIT_ACCESS
 310:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 l = (sizeof(word64) - ((size_t)z & (sizeof(word64)-1))) &
 311:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                              (sizeof(word64)-1);
 312:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 313:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         if (len < l) l = len;
 314:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         len -= l;
 315:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         while (l--) *z++ = 0;
 316:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 317:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
 318:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         *w++ = 0;
 319:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     z = (volatile byte*)w;
 320:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 321:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 322:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     while (len--) *z++ = 0;
  20                             		.loc 1 322 11
  21 0012 2E 0C                   		bra	.L2
  22                             	.L3:
  23                             		.loc 1 322 21 discriminator 2
  24 0014 EC A5                   		mov.L	[r10], r5
  25 0016 71 54 01                		add	#1, r5, r4
  26 0019 E3 A4                   		mov.L	r4, [r10]
  27                             		.loc 1 322 24 discriminator 2
  28 001b F8 54 00                		mov.B	#0, [r5]
  29                             	.L2:
  30                             		.loc 1 322 15 discriminator 1
  31 001e ED A5 02                		mov.L	8[r10], r5
  32 0021 71 54 FF                		add	#-1, r5, r4
  33 0024 E7 A4 02                		mov.L	r4, 8[r10]
  34                             		.loc 1 322 11 discriminator 1
  35 0027 61 05                   		cmp	#0, r5
  36 0029 21 EB                   		bne	.L3
 323:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
  37                             		.loc 1 323 1
  38 002b 03                      		nop
  39 002c 3F AA 04                		rtsd	#16, r10-r10
  40                             	.LFE13:
  42                             		.section	.text.min,"ax",@progbits
  44                             	_min:
  45                             	.LFB15:
 324:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 325:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 326:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 327:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_CONST_CMP
 328:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* check all length bytes for equality, return 0 on success */
 329:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ConstantCompare(const byte* a, const byte* b, int length)
 330:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 331:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int i;
 332:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int compareSum = 0;
 333:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 334:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < length; i++) {
 335:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         compareSum |= a[i] ^ b[i];
 336:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 337:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 338:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return compareSum;
 339:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 340:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 341:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 342:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 343:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_HAVE_MIN
 344:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WOLFSSL_HAVE_MIN
 345:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
 346:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #define min min
 347:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 348:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* returns the smaller of a and b */
 349:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 min(word32 a, word32 b)
 350:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  46                             		.loc 1 350 5
  47 0000 7E AA                   		push.l	r10
  48                             	.LCFI2:
  49 0002 71 0A F8                		add	#-8, r0, r10
  50                             	.LCFI3:
  51 0005 EF A0                   		mov.L	r10, r0
  52 0007 E3 A1                   		mov.L	r1, [r10]
  53 0009 E7 A2 01                		mov.L	r2, 4[r10]
 351:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return a > b ? b : a;
  54                             		.loc 1 351 26
  55 000c ED A5 01                		mov.L	4[r10], r5
  56 000f EC A3                   		mov.L	[r10], r3
  57 0011 EC A4                   		mov.L	[r10], r4
  58 0013 47 53                   		cmp	r5, r3
  59 0015 24 04                   		bgtu 1f
  60 0017 EF 45                   		mov r4, r5
  61                             	1:
 352:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  62                             		.loc 1 352 5
  63 0019 EF 51                   		mov.L	r5, r1
  64 001b 3F AA 03                		rtsd	#12, r10-r10
  65                             	.LFE15:
  67                             		.section	.text.wc_InitDsaKey,"ax",@progbits
  68                             		.global	_wc_InitDsaKey
  70                             	_wc_InitDsaKey:
  71                             	.LFB43:
  72                             		.file 2 "../src/wolfcrypt/src/dsa.c"
   1:../src/wolfcrypt/src/dsa.c **** /* dsa.c
   2:../src/wolfcrypt/src/dsa.c ****  *
   3:../src/wolfcrypt/src/dsa.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:../src/wolfcrypt/src/dsa.c ****  *
   5:../src/wolfcrypt/src/dsa.c ****  * This file is part of wolfSSL.
   6:../src/wolfcrypt/src/dsa.c ****  *
   7:../src/wolfcrypt/src/dsa.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:../src/wolfcrypt/src/dsa.c ****  * it under the terms of the GNU General Public License as published by
   9:../src/wolfcrypt/src/dsa.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:../src/wolfcrypt/src/dsa.c ****  * (at your option) any later version.
  11:../src/wolfcrypt/src/dsa.c ****  *
  12:../src/wolfcrypt/src/dsa.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:../src/wolfcrypt/src/dsa.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../src/wolfcrypt/src/dsa.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../src/wolfcrypt/src/dsa.c ****  * GNU General Public License for more details.
  16:../src/wolfcrypt/src/dsa.c ****  *
  17:../src/wolfcrypt/src/dsa.c ****  * You should have received a copy of the GNU General Public License
  18:../src/wolfcrypt/src/dsa.c ****  * along with this program; if not, write to the Free Software
  19:../src/wolfcrypt/src/dsa.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:../src/wolfcrypt/src/dsa.c ****  */
  21:../src/wolfcrypt/src/dsa.c **** 
  22:../src/wolfcrypt/src/dsa.c **** 
  23:../src/wolfcrypt/src/dsa.c **** #ifdef HAVE_CONFIG_H
  24:../src/wolfcrypt/src/dsa.c ****     #include <config.h>
  25:../src/wolfcrypt/src/dsa.c **** #endif
  26:../src/wolfcrypt/src/dsa.c **** 
  27:../src/wolfcrypt/src/dsa.c **** #include <wolfssl/wolfcrypt/settings.h>
  28:../src/wolfcrypt/src/dsa.c **** 
  29:../src/wolfcrypt/src/dsa.c **** #ifndef NO_DSA
  30:../src/wolfcrypt/src/dsa.c **** 
  31:../src/wolfcrypt/src/dsa.c **** #include <wolfssl/wolfcrypt/random.h>
  32:../src/wolfcrypt/src/dsa.c **** #include <wolfssl/wolfcrypt/integer.h>
  33:../src/wolfcrypt/src/dsa.c **** #include <wolfssl/wolfcrypt/error-crypt.h>
  34:../src/wolfcrypt/src/dsa.c **** #include <wolfssl/wolfcrypt/logging.h>
  35:../src/wolfcrypt/src/dsa.c **** #include <wolfssl/wolfcrypt/sha.h>
  36:../src/wolfcrypt/src/dsa.c **** #include <wolfssl/wolfcrypt/dsa.h>
  37:../src/wolfcrypt/src/dsa.c **** 
  38:../src/wolfcrypt/src/dsa.c **** #ifdef NO_INLINE
  39:../src/wolfcrypt/src/dsa.c ****     #include <wolfssl/wolfcrypt/misc.h>
  40:../src/wolfcrypt/src/dsa.c **** #else
  41:../src/wolfcrypt/src/dsa.c ****     #define WOLFSSL_MISC_INCLUDED
  42:../src/wolfcrypt/src/dsa.c ****     #include <wolfcrypt/src/misc.c>
  43:../src/wolfcrypt/src/dsa.c **** #endif
  44:../src/wolfcrypt/src/dsa.c **** 
  45:../src/wolfcrypt/src/dsa.c **** #ifdef _MSC_VER
  46:../src/wolfcrypt/src/dsa.c ****     /* disable for while(0) cases (MSVC bug) */
  47:../src/wolfcrypt/src/dsa.c ****     #pragma warning(disable:4127)
  48:../src/wolfcrypt/src/dsa.c **** #endif
  49:../src/wolfcrypt/src/dsa.c **** 
  50:../src/wolfcrypt/src/dsa.c **** int wc_InitDsaKey(DsaKey* key)
  51:../src/wolfcrypt/src/dsa.c **** {
  73                             		.loc 2 51 1
  74 0000 7E AA                   		push.l	r10
  75                             	.LCFI4:
  76 0002 71 0A FC                		add	#-4, r0, r10
  77                             	.LCFI5:
  78 0005 71 A0 F8                		add	#-8, r10, r0
  79                             	.LCFI6:
  80 0008 E3 A1                   		mov.L	r1, [r10]
  52:../src/wolfcrypt/src/dsa.c ****     if (key == NULL)
  81                             		.loc 2 52 8
  82 000a EC A5                   		mov.L	[r10], r5
  83 000c 61 05                   		cmp	#0, r5
  84 000e 1F                      		bne	.L7
  53:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
  85                             		.loc 2 53 16
  86 000f FB 5A 53 FF             		mov.L	#-173, r5
  87 0013 2E 35                   		bra	.L8
  88                             	.L7:
  54:../src/wolfcrypt/src/dsa.c **** 
  55:../src/wolfcrypt/src/dsa.c ****     key->type = -1;  /* haven't decided yet */
  89                             		.loc 2 55 15
  90 0015 EC A5                   		mov.L	[r10], r5
  91 0017 FA 56 D4 03 FF          		mov.L	#-1, 3920[r5]
  56:../src/wolfcrypt/src/dsa.c ****     key->heap = NULL;
  92                             		.loc 2 56 15
  93 001c EC A5                   		mov.L	[r10], r5
  94 001e FA 56 D5 03 00          		mov.L	#0, 3924[r5]
  57:../src/wolfcrypt/src/dsa.c **** 
  58:../src/wolfcrypt/src/dsa.c ****     return mp_init_multi(
  59:../src/wolfcrypt/src/dsa.c ****         /* public  alloc parts */
  60:../src/wolfcrypt/src/dsa.c ****         &key->p,
  95                             		.loc 2 60 9
  96 0023 EC A1                   		mov.L	[r10], r1
  61:../src/wolfcrypt/src/dsa.c ****         &key->q,
  97                             		.loc 2 61 9
  98 0025 EC A5                   		mov.L	[r10], r5
  99 0027 72 52 10 03             		add	#0x310, r5, r2
  62:../src/wolfcrypt/src/dsa.c ****         &key->g,
 100                             		.loc 2 62 9
 101 002b EC A5                   		mov.L	[r10], r5
 102 002d 72 53 20 06             		add	#0x620, r5, r3
  63:../src/wolfcrypt/src/dsa.c ****         &key->y,
 103                             		.loc 2 63 9
 104 0031 EC A5                   		mov.L	[r10], r5
 105 0033 72 54 30 09             		add	#0x930, r5, r4
  64:../src/wolfcrypt/src/dsa.c **** 
  65:../src/wolfcrypt/src/dsa.c ****         /* private alloc parts */
  66:../src/wolfcrypt/src/dsa.c ****         &key->x,
 106                             		.loc 2 66 9
 107 0037 EC A5                   		mov.L	[r10], r5
 108 0039 72 55 40 0C             		add	#0xc40, r5
  58:../src/wolfcrypt/src/dsa.c ****         /* public  alloc parts */
 109                             		.loc 2 58 12
 110 003d 3E 01 00                		mov.L	#0, 4[r0]
 111 0040 E3 05                   		mov.L	r5, [r0]
 112 0042 05 00 00 00             		bsr	_sp_init_multi
 113 0046 EF 15                   		mov.L	r1, r5
 114                             	.L8:
  67:../src/wolfcrypt/src/dsa.c ****         NULL
  68:../src/wolfcrypt/src/dsa.c ****     );
  69:../src/wolfcrypt/src/dsa.c **** }
 115                             		.loc 2 69 1
 116 0048 EF 51                   		mov.L	r5, r1
 117 004a 3F AA 04                		rtsd	#16, r10-r10
 118                             	.LFE43:
 120                             		.section	.text.wc_InitDsaKey_h,"ax",@progbits
 121                             		.global	_wc_InitDsaKey_h
 123                             	_wc_InitDsaKey_h:
 124                             	.LFB44:
  70:../src/wolfcrypt/src/dsa.c **** 
  71:../src/wolfcrypt/src/dsa.c **** 
  72:../src/wolfcrypt/src/dsa.c **** int wc_InitDsaKey_h(DsaKey* key, void* h)
  73:../src/wolfcrypt/src/dsa.c **** {
 125                             		.loc 2 73 1
 126 0000 7E AA                   		push.l	r10
 127                             	.LCFI7:
 128 0002 71 0A F4                		add	#-12, r0, r10
 129                             	.LCFI8:
 130 0005 EF A0                   		mov.L	r10, r0
 131 0007 E7 A1 01                		mov.L	r1, 4[r10]
 132 000a E7 A2 02                		mov.L	r2, 8[r10]
  74:../src/wolfcrypt/src/dsa.c ****     int ret = wc_InitDsaKey(key);
 133                             		.loc 2 74 15
 134 000d ED A1 01                		mov.L	4[r10], r1
 135 0010 05 00 00 00             		bsr	_wc_InitDsaKey
 136 0014 E3 A1                   		mov.L	r1, [r10]
  75:../src/wolfcrypt/src/dsa.c ****     if (ret == 0)
 137                             		.loc 2 75 8
 138 0016 EC A5                   		mov.L	[r10], r5
 139 0018 61 05                   		cmp	#0, r5
 140 001a 21 0C                   		bne	.L10
  76:../src/wolfcrypt/src/dsa.c ****         key->heap = h;
 141                             		.loc 2 76 19
 142 001c ED A5 01                		mov.L	4[r10], r5
 143 001f ED A4 02                		mov.L	8[r10], r4
 144 0022 EB 54 D5 03             		mov.L	r4, 3924[r5]
 145                             	.L10:
  77:../src/wolfcrypt/src/dsa.c **** 
  78:../src/wolfcrypt/src/dsa.c ****     return ret;
 146                             		.loc 2 78 12
 147 0026 EC A5                   		mov.L	[r10], r5
  79:../src/wolfcrypt/src/dsa.c **** }
 148                             		.loc 2 79 1
 149 0028 EF 51                   		mov.L	r5, r1
 150 002a 3F AA 04                		rtsd	#16, r10-r10
 151                             	.LFE44:
 153                             		.section	.text.wc_FreeDsaKey,"ax",@progbits
 154                             		.global	_wc_FreeDsaKey
 156                             	_wc_FreeDsaKey:
 157                             	.LFB45:
  80:../src/wolfcrypt/src/dsa.c **** 
  81:../src/wolfcrypt/src/dsa.c **** 
  82:../src/wolfcrypt/src/dsa.c **** void wc_FreeDsaKey(DsaKey* key)
  83:../src/wolfcrypt/src/dsa.c **** {
 158                             		.loc 2 83 1
 159 0000 7E AA                   		push.l	r10
 160                             	.LCFI9:
 161 0002 71 0A FC                		add	#-4, r0, r10
 162                             	.LCFI10:
 163 0005 EF A0                   		mov.L	r10, r0
 164 0007 E3 A1                   		mov.L	r1, [r10]
  84:../src/wolfcrypt/src/dsa.c ****     if (key == NULL)
 165                             		.loc 2 84 8
 166 0009 EC A5                   		mov.L	[r10], r5
 167 000b 61 05                   		cmp	#0, r5
 168 000d 20 52                   		beq	.L16
  85:../src/wolfcrypt/src/dsa.c ****         return;
  86:../src/wolfcrypt/src/dsa.c **** 
  87:../src/wolfcrypt/src/dsa.c ****     if (key->type == DSA_PRIVATE)
 169                             		.loc 2 87 12
 170 000f EC A5                   		mov.L	[r10], r5
 171 0011 EE 55 D4 03             		mov.L	3920[r5], r5
 172                             		.loc 2 87 8
 173 0015 61 15                   		cmp	#1, r5
 174 0017 21 0E                   		bne	.L15
  88:../src/wolfcrypt/src/dsa.c ****         mp_forcezero(&key->x);
 175                             		.loc 2 88 22
 176 0019 EC A5                   		mov.L	[r10], r5
 177 001b 72 55 40 0C             		add	#0xc40, r5
 178                             		.loc 2 88 9
 179 001f EF 51                   		mov.L	r5, r1
 180 0021 05 00 00 00             		bsr	_sp_forcezero
 181                             	.L15:
  89:../src/wolfcrypt/src/dsa.c **** 
  90:../src/wolfcrypt/src/dsa.c ****     mp_clear(&key->x);
 182                             		.loc 2 90 14
 183 0025 EC A5                   		mov.L	[r10], r5
 184 0027 72 55 40 0C             		add	#0xc40, r5
 185                             		.loc 2 90 5
 186 002b EF 51                   		mov.L	r5, r1
 187 002d 05 00 00 00             		bsr	_sp_clear
  91:../src/wolfcrypt/src/dsa.c ****     mp_clear(&key->y);
 188                             		.loc 2 91 14
 189 0031 EC A5                   		mov.L	[r10], r5
 190 0033 72 55 30 09             		add	#0x930, r5
 191                             		.loc 2 91 5
 192 0037 EF 51                   		mov.L	r5, r1
 193 0039 05 00 00 00             		bsr	_sp_clear
  92:../src/wolfcrypt/src/dsa.c ****     mp_clear(&key->g);
 194                             		.loc 2 92 14
 195 003d EC A5                   		mov.L	[r10], r5
 196 003f 72 55 20 06             		add	#0x620, r5
 197                             		.loc 2 92 5
 198 0043 EF 51                   		mov.L	r5, r1
 199 0045 05 00 00 00             		bsr	_sp_clear
  93:../src/wolfcrypt/src/dsa.c ****     mp_clear(&key->q);
 200                             		.loc 2 93 14
 201 0049 EC A5                   		mov.L	[r10], r5
 202 004b 72 55 10 03             		add	#0x310, r5
 203                             		.loc 2 93 5
 204 004f EF 51                   		mov.L	r5, r1
 205 0051 05 00 00 00             		bsr	_sp_clear
  94:../src/wolfcrypt/src/dsa.c ****     mp_clear(&key->p);
 206                             		.loc 2 94 14
 207 0055 EC A5                   		mov.L	[r10], r5
 208                             		.loc 2 94 5
 209 0057 EF 51                   		mov.L	r5, r1
 210 0059 05 00 00 00             		bsr	_sp_clear
 211 005d 2E 03                   		bra	.L12
 212                             	.L16:
  85:../src/wolfcrypt/src/dsa.c **** 
 213                             		.loc 2 85 9
 214 005f 03                      		nop
 215                             	.L12:
  95:../src/wolfcrypt/src/dsa.c **** }
 216                             		.loc 2 95 1
 217 0060 3F AA 02                		rtsd	#8, r10-r10
 218                             	.LFE45:
 220                             		.section	.text.CheckDsaLN,"ax",@progbits
 222                             	_CheckDsaLN:
 223                             	.LFB46:
  96:../src/wolfcrypt/src/dsa.c **** 
  97:../src/wolfcrypt/src/dsa.c **** 
  98:../src/wolfcrypt/src/dsa.c **** /* validate that (L,N) match allowed sizes from FIPS 186-4, Section 4.2.
  99:../src/wolfcrypt/src/dsa.c ****  * modLen - represents L, the size of p (prime modulus) in bits
 100:../src/wolfcrypt/src/dsa.c ****  * divLen - represents N, the size of q (prime divisor) in bits
 101:../src/wolfcrypt/src/dsa.c ****  * return 0 on success, -1 on error */
 102:../src/wolfcrypt/src/dsa.c **** static int CheckDsaLN(int modLen, int divLen)
 103:../src/wolfcrypt/src/dsa.c **** {
 224                             		.loc 2 103 1
 225 0000 7E AA                   		push.l	r10
 226                             	.LCFI11:
 227 0002 71 0A F4                		add	#-12, r0, r10
 228                             	.LCFI12:
 229 0005 EF A0                   		mov.L	r10, r0
 230 0007 E7 A1 01                		mov.L	r1, 4[r10]
 231 000a E7 A2 02                		mov.L	r2, 8[r10]
 104:../src/wolfcrypt/src/dsa.c ****     int ret = -1;
 232                             		.loc 2 104 9
 233 000d F8 A6 FF                		mov.L	#-1, [r10]
 105:../src/wolfcrypt/src/dsa.c **** 
 106:../src/wolfcrypt/src/dsa.c ****     switch (modLen) {
 234                             		.loc 2 106 5
 235 0010 ED A5 01                		mov.L	4[r10], r5
 236 0013 76 05 00 08             		cmp	#0x800, r5
 237 0017 20 21                   		beq	.L18
 238 0019 ED A5 01                		mov.L	4[r10], r5
 239 001c 76 05 00 0C             		cmp	#0xc00, r5
 240 0020 20 2D                   		beq	.L19
 241 0022 ED A5 01                		mov.L	4[r10], r5
 242 0025 76 05 00 04             		cmp	#0x400, r5
 243 0029 21 31                   		bne	.L27
 107:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_DSA_768_MODULUS
 108:../src/wolfcrypt/src/dsa.c ****         case 768:
 109:../src/wolfcrypt/src/dsa.c **** #endif
 110:../src/wolfcrypt/src/dsa.c ****         case 1024:
 111:../src/wolfcrypt/src/dsa.c ****             if (divLen == 160)
 244                             		.loc 2 111 16
 245 002b ED A5 02                		mov.L	8[r10], r5
 246 002e 75 55 A0                		cmp	#0xa0, r5
 247 0031 21 2B                   		bne	.L28
 112:../src/wolfcrypt/src/dsa.c ****                 ret = 0;
 248                             		.loc 2 112 21
 249 0033 F8 A6 00                		mov.L	#0, [r10]
 113:../src/wolfcrypt/src/dsa.c ****             break;
 250                             		.loc 2 113 13
 251 0036 2E 26                   		bra	.L28
 252                             	.L18:
 114:../src/wolfcrypt/src/dsa.c ****         case 2048:
 115:../src/wolfcrypt/src/dsa.c ****             if (divLen == 224 || divLen == 256)
 253                             		.loc 2 115 16
 254 0038 ED A5 02                		mov.L	8[r10], r5
 255 003b 75 55 E0                		cmp	#0xe0, r5
 256 003e 12                      		beq	.L23
 257                             		.loc 2 115 31 discriminator 1
 258 003f ED A5 02                		mov.L	8[r10], r5
 259 0042 76 05 00 01             		cmp	#0x100, r5
 260 0046 21 18                   		bne	.L29
 261                             	.L23:
 116:../src/wolfcrypt/src/dsa.c ****                 ret = 0;
 262                             		.loc 2 116 21
 263 0048 F8 A6 00                		mov.L	#0, [r10]
 117:../src/wolfcrypt/src/dsa.c ****             break;
 264                             		.loc 2 117 13
 265 004b 2E 13                   		bra	.L29
 266                             	.L19:
 118:../src/wolfcrypt/src/dsa.c ****         case 3072:
 119:../src/wolfcrypt/src/dsa.c ****             if (divLen == 256)
 267                             		.loc 2 119 16
 268 004d ED A5 02                		mov.L	8[r10], r5
 269 0050 76 05 00 01             		cmp	#0x100, r5
 270 0054 21 0D                   		bne	.L30
 120:../src/wolfcrypt/src/dsa.c ****                 ret = 0;
 271                             		.loc 2 120 21
 272 0056 F8 A6 00                		mov.L	#0, [r10]
 121:../src/wolfcrypt/src/dsa.c ****             break;
 273                             		.loc 2 121 13
 274 0059 08                      		bra	.L30
 275                             	.L27:
 122:../src/wolfcrypt/src/dsa.c ****         default:
 123:../src/wolfcrypt/src/dsa.c ****             break;
 276                             		.loc 2 123 13
 277 005a 03                      		nop
 278 005b 0F                      		bra	.L22
 279                             	.L28:
 113:../src/wolfcrypt/src/dsa.c ****         case 2048:
 280                             		.loc 2 113 13
 281 005c 03                      		nop
 282 005d 0D                      		bra	.L22
 283                             	.L29:
 117:../src/wolfcrypt/src/dsa.c ****         case 3072:
 284                             		.loc 2 117 13
 285 005e 03                      		nop
 286 005f 2E 03                   		bra	.L22
 287                             	.L30:
 121:../src/wolfcrypt/src/dsa.c ****         default:
 288                             		.loc 2 121 13
 289 0061 03                      		nop
 290                             		.balign 8,3,1
 291                             	.L22:
 124:../src/wolfcrypt/src/dsa.c ****     }
 125:../src/wolfcrypt/src/dsa.c **** 
 126:../src/wolfcrypt/src/dsa.c ****     return ret;
 292                             		.loc 2 126 12
 293 0062 EC A5                   		mov.L	[r10], r5
 127:../src/wolfcrypt/src/dsa.c **** }
 294                             		.loc 2 127 1
 295 0064 EF 51                   		mov.L	r5, r1
 296 0066 3F AA 04                		rtsd	#16, r10-r10
 297                             	.LFE46:
 299 0069 FD 70 40 00 00 00 80    		.section C,"a",@progbits
 300                             		.p2align 2
 301                             	.LC0:
 302 0000 49 6E 76 61 6C 69 64 20 		.string	"Invalid DSA p or q parameter size"
 302      44 53 41 20 70 20 6F 72 
 302      20 71 20 70 61 72 61 6D 
 302      65 74 65 72 20 73 69 7A 
 302      65 00 
 303                             		.section	.text._DsaImportParamsRaw,"ax",@progbits
 305                             	__DsaImportParamsRaw:
 306                             	.LFB47:
 128:../src/wolfcrypt/src/dsa.c **** 
 129:../src/wolfcrypt/src/dsa.c **** 
 130:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_KEY_GEN
 131:../src/wolfcrypt/src/dsa.c **** 
 132:../src/wolfcrypt/src/dsa.c **** /* Create DSA key pair (&dsa->x, &dsa->y)
 133:../src/wolfcrypt/src/dsa.c ****  *
 134:../src/wolfcrypt/src/dsa.c ****  * Based on NIST FIPS 186-4,
 135:../src/wolfcrypt/src/dsa.c ****  * "B.1.1 Key Pair Generation Using Extra Random Bits"
 136:../src/wolfcrypt/src/dsa.c ****  *
 137:../src/wolfcrypt/src/dsa.c ****  * rng - pointer to initialized WC_RNG structure
 138:../src/wolfcrypt/src/dsa.c ****  * dsa - pointer to initialized DsaKey structure, will hold generated key
 139:../src/wolfcrypt/src/dsa.c ****  *
 140:../src/wolfcrypt/src/dsa.c ****  * return 0 on success, negative on error */
 141:../src/wolfcrypt/src/dsa.c **** int wc_MakeDsaKey(WC_RNG *rng, DsaKey *dsa)
 142:../src/wolfcrypt/src/dsa.c **** {
 143:../src/wolfcrypt/src/dsa.c ****     byte* cBuf;
 144:../src/wolfcrypt/src/dsa.c ****     int qSz, pSz, cSz, err;
 145:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 146:../src/wolfcrypt/src/dsa.c ****     mp_int *tmpQ = NULL;
 147:../src/wolfcrypt/src/dsa.c **** #else
 148:../src/wolfcrypt/src/dsa.c ****     mp_int tmpQ[1];
 149:../src/wolfcrypt/src/dsa.c **** #endif
 150:../src/wolfcrypt/src/dsa.c **** 
 151:../src/wolfcrypt/src/dsa.c ****     if (rng == NULL || dsa == NULL)
 152:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 153:../src/wolfcrypt/src/dsa.c **** 
 154:../src/wolfcrypt/src/dsa.c ****     qSz = mp_unsigned_bin_size(&dsa->q);
 155:../src/wolfcrypt/src/dsa.c ****     pSz = mp_unsigned_bin_size(&dsa->p);
 156:../src/wolfcrypt/src/dsa.c **** 
 157:../src/wolfcrypt/src/dsa.c ****     /* verify (L,N) pair bit lengths */
 158:../src/wolfcrypt/src/dsa.c ****     if (CheckDsaLN(pSz * WOLFSSL_BIT_SIZE, qSz * WOLFSSL_BIT_SIZE) != 0)
 159:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 160:../src/wolfcrypt/src/dsa.c **** 
 161:../src/wolfcrypt/src/dsa.c ****     /* generate extra 64 bits so that bias from mod function is negligible */
 162:../src/wolfcrypt/src/dsa.c ****     cSz = qSz + (64 / WOLFSSL_BIT_SIZE);
 163:../src/wolfcrypt/src/dsa.c ****     cBuf = (byte*)XMALLOC(cSz, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);
 164:../src/wolfcrypt/src/dsa.c ****     if (cBuf == NULL) {
 165:../src/wolfcrypt/src/dsa.c ****         return MEMORY_E;
 166:../src/wolfcrypt/src/dsa.c ****     }
 167:../src/wolfcrypt/src/dsa.c **** 
 168:../src/wolfcrypt/src/dsa.c ****     SAVE_VECTOR_REGISTERS();
 169:../src/wolfcrypt/src/dsa.c **** 
 170:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 171:../src/wolfcrypt/src/dsa.c ****     if ((tmpQ = (mp_int *)XMALLOC(sizeof(*tmpQ), NULL, DYNAMIC_TYPE_WOLF_BIGINT)) == NULL)
 172:../src/wolfcrypt/src/dsa.c ****         err = MEMORY_E;
 173:../src/wolfcrypt/src/dsa.c ****     else
 174:../src/wolfcrypt/src/dsa.c ****         err = MP_OKAY;
 175:../src/wolfcrypt/src/dsa.c **** 
 176:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 177:../src/wolfcrypt/src/dsa.c **** #endif
 178:../src/wolfcrypt/src/dsa.c ****         err = mp_init_multi(&dsa->x, &dsa->y, tmpQ, NULL, NULL, NULL);
 179:../src/wolfcrypt/src/dsa.c **** 
 180:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY) {
 181:../src/wolfcrypt/src/dsa.c ****         do {
 182:../src/wolfcrypt/src/dsa.c ****             /* Generate N+64 bits (c) from RNG into &dsa->x, making sure
 183:../src/wolfcrypt/src/dsa.c ****              * result is positive.
 184:../src/wolfcrypt/src/dsa.c ****              * Hash_DRBG uses SHA-256 which matches maximum
 185:../src/wolfcrypt/src/dsa.c ****              * requested_security_strength of (L,N).
 186:../src/wolfcrypt/src/dsa.c ****              */
 187:../src/wolfcrypt/src/dsa.c ****             err = wc_RNG_GenerateBlock(rng, cBuf, cSz);
 188:../src/wolfcrypt/src/dsa.c ****             if (err != MP_OKAY)
 189:../src/wolfcrypt/src/dsa.c ****                 break;
 190:../src/wolfcrypt/src/dsa.c ****             err = mp_read_unsigned_bin(&dsa->x, cBuf, cSz);
 191:../src/wolfcrypt/src/dsa.c ****             if (err != MP_OKAY)
 192:../src/wolfcrypt/src/dsa.c ****                 break;
 193:../src/wolfcrypt/src/dsa.c ****         } while (mp_cmp_d(&dsa->x, 1) != MP_GT);
 194:../src/wolfcrypt/src/dsa.c ****     }
 195:../src/wolfcrypt/src/dsa.c **** 
 196:../src/wolfcrypt/src/dsa.c ****     /* tmpQ = q - 1 */
 197:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 198:../src/wolfcrypt/src/dsa.c ****         err = mp_copy(&dsa->q, tmpQ);
 199:../src/wolfcrypt/src/dsa.c **** 
 200:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 201:../src/wolfcrypt/src/dsa.c ****         err = mp_sub_d(tmpQ, 1, tmpQ);
 202:../src/wolfcrypt/src/dsa.c **** 
 203:../src/wolfcrypt/src/dsa.c ****     /* x = c mod (q-1), &dsa->x holds c */
 204:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 205:../src/wolfcrypt/src/dsa.c ****         err = mp_mod(&dsa->x, tmpQ, &dsa->x);
 206:../src/wolfcrypt/src/dsa.c **** 
 207:../src/wolfcrypt/src/dsa.c ****     /* x = c mod (q-1) + 1 */
 208:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 209:../src/wolfcrypt/src/dsa.c ****         err = mp_add_d(&dsa->x, 1, &dsa->x);
 210:../src/wolfcrypt/src/dsa.c **** 
 211:../src/wolfcrypt/src/dsa.c ****     /* public key : y = g^x mod p */
 212:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 213:../src/wolfcrypt/src/dsa.c ****         err = mp_exptmod_ex(&dsa->g, &dsa->x, dsa->q.used, &dsa->p, &dsa->y);
 214:../src/wolfcrypt/src/dsa.c **** 
 215:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 216:../src/wolfcrypt/src/dsa.c ****         dsa->type = DSA_PRIVATE;
 217:../src/wolfcrypt/src/dsa.c **** 
 218:../src/wolfcrypt/src/dsa.c ****     if (err != MP_OKAY) {
 219:../src/wolfcrypt/src/dsa.c ****         mp_clear(&dsa->x);
 220:../src/wolfcrypt/src/dsa.c ****         mp_clear(&dsa->y);
 221:../src/wolfcrypt/src/dsa.c ****     }
 222:../src/wolfcrypt/src/dsa.c **** 
 223:../src/wolfcrypt/src/dsa.c ****     XFREE(cBuf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);
 224:../src/wolfcrypt/src/dsa.c **** 
 225:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 226:../src/wolfcrypt/src/dsa.c ****     if (tmpQ != NULL) {
 227:../src/wolfcrypt/src/dsa.c ****         mp_clear(tmpQ);
 228:../src/wolfcrypt/src/dsa.c ****         XFREE(tmpQ, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);
 229:../src/wolfcrypt/src/dsa.c ****     }
 230:../src/wolfcrypt/src/dsa.c **** #else
 231:../src/wolfcrypt/src/dsa.c ****     mp_clear(tmpQ);
 232:../src/wolfcrypt/src/dsa.c **** #endif
 233:../src/wolfcrypt/src/dsa.c **** 
 234:../src/wolfcrypt/src/dsa.c ****     RESTORE_VECTOR_REGISTERS();
 235:../src/wolfcrypt/src/dsa.c **** 
 236:../src/wolfcrypt/src/dsa.c ****     return err;
 237:../src/wolfcrypt/src/dsa.c **** }
 238:../src/wolfcrypt/src/dsa.c **** 
 239:../src/wolfcrypt/src/dsa.c **** 
 240:../src/wolfcrypt/src/dsa.c **** /* modulus_size in bits */
 241:../src/wolfcrypt/src/dsa.c **** int wc_MakeDsaParameters(WC_RNG *rng, int modulus_size, DsaKey *dsa)
 242:../src/wolfcrypt/src/dsa.c **** {
 243:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 244:../src/wolfcrypt/src/dsa.c ****     mp_int *tmp = NULL, *tmp2 = NULL;
 245:../src/wolfcrypt/src/dsa.c **** #else
 246:../src/wolfcrypt/src/dsa.c ****     mp_int tmp[1], tmp2[1];
 247:../src/wolfcrypt/src/dsa.c **** #endif
 248:../src/wolfcrypt/src/dsa.c ****     int     err, msize, qsize,
 249:../src/wolfcrypt/src/dsa.c ****             loop_check_prime = 0,
 250:../src/wolfcrypt/src/dsa.c ****             check_prime = MP_NO;
 251:../src/wolfcrypt/src/dsa.c ****     unsigned char   *buf;
 252:../src/wolfcrypt/src/dsa.c **** 
 253:../src/wolfcrypt/src/dsa.c ****     if (rng == NULL || dsa == NULL)
 254:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 255:../src/wolfcrypt/src/dsa.c **** 
 256:../src/wolfcrypt/src/dsa.c ****     /* set group size in bytes from modulus size
 257:../src/wolfcrypt/src/dsa.c ****      * FIPS 186-4 defines valid values (1024, 160) (2048, 256) (3072, 256)
 258:../src/wolfcrypt/src/dsa.c ****      */
 259:../src/wolfcrypt/src/dsa.c ****     switch (modulus_size) {
 260:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_DSA_768_MODULUS
 261:../src/wolfcrypt/src/dsa.c ****     /* This key length is unsecure and only included for bind 9 testing */
 262:../src/wolfcrypt/src/dsa.c ****         case 768:
 263:../src/wolfcrypt/src/dsa.c **** #endif
 264:../src/wolfcrypt/src/dsa.c ****         case 1024:
 265:../src/wolfcrypt/src/dsa.c ****             qsize = 20;
 266:../src/wolfcrypt/src/dsa.c ****             break;
 267:../src/wolfcrypt/src/dsa.c ****         case 2048:
 268:../src/wolfcrypt/src/dsa.c ****         case 3072:
 269:../src/wolfcrypt/src/dsa.c ****             qsize = 32;
 270:../src/wolfcrypt/src/dsa.c ****             break;
 271:../src/wolfcrypt/src/dsa.c ****         default:
 272:../src/wolfcrypt/src/dsa.c ****             return BAD_FUNC_ARG;
 273:../src/wolfcrypt/src/dsa.c ****     }
 274:../src/wolfcrypt/src/dsa.c **** 
 275:../src/wolfcrypt/src/dsa.c ****     /* modulus size in bytes */
 276:../src/wolfcrypt/src/dsa.c ****     msize = modulus_size / WOLFSSL_BIT_SIZE;
 277:../src/wolfcrypt/src/dsa.c **** 
 278:../src/wolfcrypt/src/dsa.c ****     /* allocate ram */
 279:../src/wolfcrypt/src/dsa.c ****     buf = (unsigned char *)XMALLOC(msize - qsize,
 280:../src/wolfcrypt/src/dsa.c ****                                    dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);
 281:../src/wolfcrypt/src/dsa.c ****     if (buf == NULL) {
 282:../src/wolfcrypt/src/dsa.c ****         return MEMORY_E;
 283:../src/wolfcrypt/src/dsa.c ****     }
 284:../src/wolfcrypt/src/dsa.c **** 
 285:../src/wolfcrypt/src/dsa.c ****     /* make a random string that will be multiplied against q */
 286:../src/wolfcrypt/src/dsa.c ****     err = wc_RNG_GenerateBlock(rng, buf, msize - qsize);
 287:../src/wolfcrypt/src/dsa.c ****     if (err != MP_OKAY) {
 288:../src/wolfcrypt/src/dsa.c ****         XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);
 289:../src/wolfcrypt/src/dsa.c ****         return err;
 290:../src/wolfcrypt/src/dsa.c ****     }
 291:../src/wolfcrypt/src/dsa.c **** 
 292:../src/wolfcrypt/src/dsa.c ****     /* force magnitude */
 293:../src/wolfcrypt/src/dsa.c ****     buf[0] |= 0xC0;
 294:../src/wolfcrypt/src/dsa.c **** 
 295:../src/wolfcrypt/src/dsa.c ****     /* force even */
 296:../src/wolfcrypt/src/dsa.c ****     buf[msize - qsize - 1] &= ~1;
 297:../src/wolfcrypt/src/dsa.c **** 
 298:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 299:../src/wolfcrypt/src/dsa.c ****     if (((tmp = (mp_int *)XMALLOC(sizeof(*tmp), NULL, DYNAMIC_TYPE_WOLF_BIGINT)) == NULL) ||
 300:../src/wolfcrypt/src/dsa.c ****         ((tmp2 = (mp_int *)XMALLOC(sizeof(*tmp2), NULL, DYNAMIC_TYPE_WOLF_BIGINT)) == NULL))
 301:../src/wolfcrypt/src/dsa.c ****         err = MEMORY_E;
 302:../src/wolfcrypt/src/dsa.c ****     else
 303:../src/wolfcrypt/src/dsa.c ****         err = MP_OKAY;
 304:../src/wolfcrypt/src/dsa.c **** 
 305:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 306:../src/wolfcrypt/src/dsa.c **** #endif
 307:../src/wolfcrypt/src/dsa.c ****         err = mp_init_multi(tmp2, &dsa->p, &dsa->q, 0, 0, 0);
 308:../src/wolfcrypt/src/dsa.c **** 
 309:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 310:../src/wolfcrypt/src/dsa.c ****         err = mp_read_unsigned_bin(tmp2, buf, msize - qsize);
 311:../src/wolfcrypt/src/dsa.c **** 
 312:../src/wolfcrypt/src/dsa.c ****     /* make our prime q */
 313:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 314:../src/wolfcrypt/src/dsa.c ****         err = mp_rand_prime(&dsa->q, qsize, rng, NULL);
 315:../src/wolfcrypt/src/dsa.c **** 
 316:../src/wolfcrypt/src/dsa.c ****     /* p = random * q */
 317:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 318:../src/wolfcrypt/src/dsa.c ****         err = mp_mul(&dsa->q, tmp2, &dsa->p);
 319:../src/wolfcrypt/src/dsa.c **** 
 320:../src/wolfcrypt/src/dsa.c ****     /* p = random * q + 1, so q is a prime divisor of p-1 */
 321:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 322:../src/wolfcrypt/src/dsa.c ****         err = mp_add_d(&dsa->p, 1, &dsa->p);
 323:../src/wolfcrypt/src/dsa.c **** 
 324:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 325:../src/wolfcrypt/src/dsa.c ****         err = mp_init(tmp);
 326:../src/wolfcrypt/src/dsa.c **** 
 327:../src/wolfcrypt/src/dsa.c ****     /* tmp = 2q  */
 328:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 329:../src/wolfcrypt/src/dsa.c ****         err = mp_add(&dsa->q, &dsa->q, tmp);
 330:../src/wolfcrypt/src/dsa.c **** 
 331:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY) {
 332:../src/wolfcrypt/src/dsa.c ****         /* loop until p is prime */
 333:../src/wolfcrypt/src/dsa.c ****         while (check_prime == MP_NO) {
 334:../src/wolfcrypt/src/dsa.c ****             err = mp_prime_is_prime_ex(&dsa->p, 8, &check_prime, rng);
 335:../src/wolfcrypt/src/dsa.c ****             if (err != MP_OKAY)
 336:../src/wolfcrypt/src/dsa.c ****                 break;
 337:../src/wolfcrypt/src/dsa.c ****             if (check_prime != MP_YES) {
 338:../src/wolfcrypt/src/dsa.c ****                 /* p += 2q */
 339:../src/wolfcrypt/src/dsa.c ****                 err = mp_add(tmp, &dsa->p, &dsa->p);
 340:../src/wolfcrypt/src/dsa.c ****                 if (err != MP_OKAY)
 341:../src/wolfcrypt/src/dsa.c ****                     break;
 342:../src/wolfcrypt/src/dsa.c ****                 loop_check_prime++;
 343:../src/wolfcrypt/src/dsa.c ****             }
 344:../src/wolfcrypt/src/dsa.c ****         }
 345:../src/wolfcrypt/src/dsa.c ****     }
 346:../src/wolfcrypt/src/dsa.c **** 
 347:../src/wolfcrypt/src/dsa.c ****     /* tmp2 += (2*loop_check_prime)
 348:../src/wolfcrypt/src/dsa.c ****      * to have p = (q * tmp2) + 1 prime
 349:../src/wolfcrypt/src/dsa.c ****      */
 350:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY) {
 351:../src/wolfcrypt/src/dsa.c ****         if (loop_check_prime)
 352:../src/wolfcrypt/src/dsa.c ****             err = mp_add_d(tmp2, 2*loop_check_prime, tmp2);
 353:../src/wolfcrypt/src/dsa.c ****     }
 354:../src/wolfcrypt/src/dsa.c **** 
 355:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 356:../src/wolfcrypt/src/dsa.c ****         err = mp_init(&dsa->g);
 357:../src/wolfcrypt/src/dsa.c **** 
 358:../src/wolfcrypt/src/dsa.c ****     /* find a value g for which g^tmp2 != 1 */
 359:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 360:../src/wolfcrypt/src/dsa.c ****         err = mp_set(&dsa->g, 1);
 361:../src/wolfcrypt/src/dsa.c **** 
 362:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY) {
 363:../src/wolfcrypt/src/dsa.c ****         do {
 364:../src/wolfcrypt/src/dsa.c ****             err = mp_add_d(&dsa->g, 1, &dsa->g);
 365:../src/wolfcrypt/src/dsa.c ****             if (err != MP_OKAY)
 366:../src/wolfcrypt/src/dsa.c ****                 break;
 367:../src/wolfcrypt/src/dsa.c ****             err = mp_exptmod(&dsa->g, tmp2, &dsa->p, tmp);
 368:../src/wolfcrypt/src/dsa.c ****             if (err != MP_OKAY)
 369:../src/wolfcrypt/src/dsa.c ****                 break;
 370:../src/wolfcrypt/src/dsa.c ****         } while (mp_cmp_d(tmp, 1) == MP_EQ);
 371:../src/wolfcrypt/src/dsa.c ****     }
 372:../src/wolfcrypt/src/dsa.c **** 
 373:../src/wolfcrypt/src/dsa.c ****     /* at this point tmp generates a group of order q mod p */
 374:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY) {
 375:../src/wolfcrypt/src/dsa.c **** #ifndef USE_FAST_MATH
 376:../src/wolfcrypt/src/dsa.c ****         /* Exchanging is quick when the data pointer can be copied. */
 377:../src/wolfcrypt/src/dsa.c ****         err = mp_exch(tmp, &dsa->g);
 378:../src/wolfcrypt/src/dsa.c **** #else
 379:../src/wolfcrypt/src/dsa.c ****         err = mp_copy(tmp, &dsa->g);
 380:../src/wolfcrypt/src/dsa.c **** #endif
 381:../src/wolfcrypt/src/dsa.c ****     }
 382:../src/wolfcrypt/src/dsa.c **** 
 383:../src/wolfcrypt/src/dsa.c ****     XFREE(buf, dsa->heap, DYNAMIC_TYPE_TMP_BUFFER);
 384:../src/wolfcrypt/src/dsa.c **** 
 385:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 386:../src/wolfcrypt/src/dsa.c ****     if (tmp != NULL) {
 387:../src/wolfcrypt/src/dsa.c ****         mp_clear(tmp);
 388:../src/wolfcrypt/src/dsa.c ****         XFREE(tmp, NULL, DYNAMIC_TYPE_WOLF_BIGINT);
 389:../src/wolfcrypt/src/dsa.c ****     }
 390:../src/wolfcrypt/src/dsa.c ****     if (tmp2 != NULL) {
 391:../src/wolfcrypt/src/dsa.c ****         mp_clear(tmp2);
 392:../src/wolfcrypt/src/dsa.c ****         XFREE(tmp2, NULL, DYNAMIC_TYPE_WOLF_BIGINT);
 393:../src/wolfcrypt/src/dsa.c ****     }
 394:../src/wolfcrypt/src/dsa.c **** #else
 395:../src/wolfcrypt/src/dsa.c ****     mp_clear(tmp);
 396:../src/wolfcrypt/src/dsa.c ****     mp_clear(tmp2);
 397:../src/wolfcrypt/src/dsa.c **** #endif
 398:../src/wolfcrypt/src/dsa.c ****     if (err != MP_OKAY) {
 399:../src/wolfcrypt/src/dsa.c ****         mp_clear(&dsa->q);
 400:../src/wolfcrypt/src/dsa.c ****         mp_clear(&dsa->p);
 401:../src/wolfcrypt/src/dsa.c ****         mp_clear(&dsa->g);
 402:../src/wolfcrypt/src/dsa.c ****     }
 403:../src/wolfcrypt/src/dsa.c **** 
 404:../src/wolfcrypt/src/dsa.c ****     return err;
 405:../src/wolfcrypt/src/dsa.c **** }
 406:../src/wolfcrypt/src/dsa.c **** #endif /* WOLFSSL_KEY_GEN */
 407:../src/wolfcrypt/src/dsa.c **** 
 408:../src/wolfcrypt/src/dsa.c **** 
 409:../src/wolfcrypt/src/dsa.c **** static int _DsaImportParamsRaw(DsaKey* dsa, const char* p, const char* q,
 410:../src/wolfcrypt/src/dsa.c ****                           const char* g, int trusted, WC_RNG* rng)
 411:../src/wolfcrypt/src/dsa.c **** {
 307                             		.loc 2 411 1
 308 0000 7E AA                   		push.l	r10
 309                             	.LCFI13:
 310 0002 7E A6                   		push.l	r6
 311                             	.LCFI14:
 312 0004 71 0A D8                		add	#-40, r0, r10
 313                             	.LCFI15:
 314 0007 EF A0                   		mov.L	r10, r0
 315 0009 75 46 34                		mov.L	#52, r6
 316 000c 4B A6                   		add	r10, r6
 317 000e E7 A1 04                		mov.L	r1, 16[r10]
 318 0011 E7 A2 05                		mov.L	r2, 20[r10]
 319 0014 E7 A3 06                		mov.L	r3, 24[r10]
 320 0017 E7 A4 07                		mov.L	r4, 28[r10]
 412:../src/wolfcrypt/src/dsa.c ****     int err;
 413:../src/wolfcrypt/src/dsa.c ****     word32 pSz, qSz;
 414:../src/wolfcrypt/src/dsa.c **** 
 415:../src/wolfcrypt/src/dsa.c ****     if (dsa == NULL || p == NULL || q == NULL || g == NULL)
 321                             		.loc 2 415 8
 322 001a ED A5 04                		mov.L	16[r10], r5
 323 001d 61 05                   		cmp	#0, r5
 324 001f 20 15                   		beq	.L32
 325                             		.loc 2 415 21 discriminator 1
 326 0021 ED A5 05                		mov.L	20[r10], r5
 327 0024 61 05                   		cmp	#0, r5
 328 0026 20 0E                   		beq	.L32
 329                             		.loc 2 415 34 discriminator 2
 330 0028 ED A5 06                		mov.L	24[r10], r5
 331 002b 61 05                   		cmp	#0, r5
 332 002d 17                      		beq	.L32
 333                             		.loc 2 415 47 discriminator 3
 334 002e ED A5 07                		mov.L	28[r10], r5
 335 0031 61 05                   		cmp	#0, r5
 336 0033 18                      		bne	.L33
 337                             		.balign 8,3,2
 338                             	.L32:
 416:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 339                             		.loc 2 416 16
 340 0034 FB 5A 53 FF             		mov.L	#-173, r5
 341 0038 38 09 01                		bra	.L34
 342                             	.L33:
 417:../src/wolfcrypt/src/dsa.c **** 
 418:../src/wolfcrypt/src/dsa.c ****     /* read p */
 419:../src/wolfcrypt/src/dsa.c ****     err = mp_read_radix(&dsa->p, p, MP_RADIX_HEX);
 343                             		.loc 2 419 25
 344 003b ED A5 04                		mov.L	16[r10], r5
 345                             		.loc 2 419 11
 346 003e 75 43 10                		mov.L	#16, r3
 347 0041 ED A2 05                		mov.L	20[r10], r2
 348 0044 EF 51                   		mov.L	r5, r1
 349 0046 05 00 00 00             		bsr	_sp_read_radix
 350 004a E3 A1                   		mov.L	r1, [r10]
 420:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY && !trusted) {
 351                             		.loc 2 420 8
 352 004c EC A5                   		mov.L	[r10], r5
 353 004e 61 05                   		cmp	#0, r5
 354 0050 21 48                   		bne	.L35
 355                             		.loc 2 420 24 discriminator 1
 356 0052 EC 65                   		mov.L	[r6], r5
 357 0054 61 05                   		cmp	#0, r5
 358 0056 21 42                   		bne	.L35
 359                             	.LBB2:
 421:../src/wolfcrypt/src/dsa.c ****         int isPrime = 1;
 360                             		.loc 2 421 13
 361 0058 F9 A6 03 01             		mov.L	#1, 12[r10]
 422:../src/wolfcrypt/src/dsa.c ****         if (rng == NULL)
 362                             		.loc 2 422 12
 363 005c A8 6D                   		mov.L	4[r6], r5
 364 005e 61 05                   		cmp	#0, r5
 365 0060 21 16                   		bne	.L36
 423:../src/wolfcrypt/src/dsa.c ****             err = mp_prime_is_prime(&dsa->p, 8, &isPrime);
 366                             		.loc 2 423 19
 367 0062 ED A4 04                		mov.L	16[r10], r4
 368 0065 71 A5 0C                		add	#12, r10, r5
 369 0068 EF 53                   		mov.L	r5, r3
 370 006a 66 82                   		mov.L	#8, r2
 371 006c EF 41                   		mov.L	r4, r1
 372 006e 05 00 00 00             		bsr	_sp_prime_is_prime
 373 0072 E3 A1                   		mov.L	r1, [r10]
 374 0074 2E 14                   		bra	.L37
 375                             	.L36:
 424:../src/wolfcrypt/src/dsa.c ****         else
 425:../src/wolfcrypt/src/dsa.c ****             err = mp_prime_is_prime_ex(&dsa->p, 8, &isPrime, rng);
 376                             		.loc 2 425 19
 377 0076 ED A1 04                		mov.L	16[r10], r1
 378 0079 71 A5 0C                		add	#12, r10, r5
 379 007c A8 6C                   		mov.L	4[r6], r4
 380 007e EF 53                   		mov.L	r5, r3
 381 0080 66 82                   		mov.L	#8, r2
 382 0082 05 00 00 00             		bsr	_sp_prime_is_prime_ex
 383 0086 E3 A1                   		mov.L	r1, [r10]
 384                             	.L37:
 426:../src/wolfcrypt/src/dsa.c **** 
 427:../src/wolfcrypt/src/dsa.c ****         if (err == MP_OKAY) {
 385                             		.loc 2 427 12
 386 0088 EC A5                   		mov.L	[r10], r5
 387 008a 61 05                   		cmp	#0, r5
 388 008c 21 0C                   		bne	.L35
 428:../src/wolfcrypt/src/dsa.c ****             if (!isPrime)
 389                             		.loc 2 428 17
 390 008e ED A5 03                		mov.L	12[r10], r5
 391                             		.loc 2 428 16
 392 0091 61 05                   		cmp	#0, r5
 393 0093 1D                      		bne	.L35
 429:../src/wolfcrypt/src/dsa.c ****                 err = DH_CHECK_PUB_E;
 394                             		.loc 2 429 21
 395 0094 F8 AA 0D FF             		mov.L	#-243, [r10]
 396                             		.balign 8,3,1
 397                             	.L35:
 398                             	.LBE2:
 430:../src/wolfcrypt/src/dsa.c ****         }
 431:../src/wolfcrypt/src/dsa.c ****     }
 432:../src/wolfcrypt/src/dsa.c **** 
 433:../src/wolfcrypt/src/dsa.c ****     /* read q */
 434:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 399                             		.loc 2 434 8
 400 0098 EC A5                   		mov.L	[r10], r5
 401 009a 61 05                   		cmp	#0, r5
 402 009c 21 17                   		bne	.L39
 435:../src/wolfcrypt/src/dsa.c ****         err = mp_read_radix(&dsa->q, q, MP_RADIX_HEX);
 403                             		.loc 2 435 29
 404 009e ED A5 04                		mov.L	16[r10], r5
 405 00a1 72 55 10 03             		add	#0x310, r5
 406                             		.loc 2 435 15
 407 00a5 75 43 10                		mov.L	#16, r3
 408 00a8 ED A2 06                		mov.L	24[r10], r2
 409 00ab EF 51                   		mov.L	r5, r1
 410 00ad 05 00 00 00             		bsr	_sp_read_radix
 411 00b1 E3 A1                   		mov.L	r1, [r10]
 412                             	.L39:
 436:../src/wolfcrypt/src/dsa.c **** 
 437:../src/wolfcrypt/src/dsa.c ****     /* read g */
 438:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY)
 413                             		.loc 2 438 8
 414 00b3 EC A5                   		mov.L	[r10], r5
 415 00b5 61 05                   		cmp	#0, r5
 416 00b7 21 17                   		bne	.L40
 439:../src/wolfcrypt/src/dsa.c ****         err = mp_read_radix(&dsa->g, g, MP_RADIX_HEX);
 417                             		.loc 2 439 29
 418 00b9 ED A5 04                		mov.L	16[r10], r5
 419 00bc 72 55 20 06             		add	#0x620, r5
 420                             		.loc 2 439 15
 421 00c0 75 43 10                		mov.L	#16, r3
 422 00c3 ED A2 07                		mov.L	28[r10], r2
 423 00c6 EF 51                   		mov.L	r5, r1
 424 00c8 05 00 00 00             		bsr	_sp_read_radix
 425 00cc E3 A1                   		mov.L	r1, [r10]
 426                             	.L40:
 440:../src/wolfcrypt/src/dsa.c **** 
 441:../src/wolfcrypt/src/dsa.c ****     /* verify (L,N) pair bit lengths */
 442:../src/wolfcrypt/src/dsa.c ****     pSz = mp_unsigned_bin_size(&dsa->p);
 427                             		.loc 2 442 32
 428 00ce ED A5 04                		mov.L	16[r10], r5
 429                             		.loc 2 442 11
 430 00d1 EF 51                   		mov.L	r5, r1
 431 00d3 05 00 00 00             		bsr	_sp_unsigned_bin_size
 432 00d7 EF 15                   		mov.L	r1, r5
 433                             		.loc 2 442 9
 434 00d9 E7 A5 01                		mov.L	r5, 4[r10]
 443:../src/wolfcrypt/src/dsa.c ****     qSz = mp_unsigned_bin_size(&dsa->q);
 435                             		.loc 2 443 32
 436 00dc ED A5 04                		mov.L	16[r10], r5
 437 00df 72 55 10 03             		add	#0x310, r5
 438                             		.loc 2 443 11
 439 00e3 EF 51                   		mov.L	r5, r1
 440 00e5 05 00 00 00             		bsr	_sp_unsigned_bin_size
 441 00e9 EF 15                   		mov.L	r1, r5
 442                             		.loc 2 443 9
 443 00eb E7 A5 02                		mov.L	r5, 8[r10]
 444:../src/wolfcrypt/src/dsa.c **** 
 445:../src/wolfcrypt/src/dsa.c ****     if (CheckDsaLN(pSz * WOLFSSL_BIT_SIZE, qSz * WOLFSSL_BIT_SIZE) != 0) {
 444                             		.loc 2 445 24
 445 00ee ED A5 01                		mov.L	4[r10], r5
 446 00f1 6C 35                   		shll	#3, r5
 447                             		.loc 2 445 9
 448 00f3 EF 54                   		mov.L	r5, r4
 449                             		.loc 2 445 48
 450 00f5 ED A5 02                		mov.L	8[r10], r5
 451 00f8 6C 35                   		shll	#3, r5
 452                             		.loc 2 445 9
 453 00fa EF 52                   		mov.L	r5, r2
 454 00fc EF 41                   		mov.L	r4, r1
 455 00fe 05 00 00 00             		bsr	_CheckDsaLN
 456 0102 EF 15                   		mov.L	r1, r5
 457                             		.loc 2 445 8
 458 0104 61 05                   		cmp	#0, r5
 459 0106 20 10                   		beq	.L41
 446:../src/wolfcrypt/src/dsa.c ****         WOLFSSL_MSG("Invalid DSA p or q parameter size");
 460                             		.loc 2 446 9
 461 0108 FB 12 00 00 00 00       		mov.L	#.LC0, r1
 462 010e 05 00 00 00             		bsr	_WOLFSSL_MSG
 447:../src/wolfcrypt/src/dsa.c ****         err = BAD_FUNC_ARG;
 463                             		.loc 2 447 13
 464 0112 F8 AA 53 FF             		mov.L	#-173, [r10]
 465                             	.L41:
 448:../src/wolfcrypt/src/dsa.c ****     }
 449:../src/wolfcrypt/src/dsa.c **** 
 450:../src/wolfcrypt/src/dsa.c ****     if (err != MP_OKAY) {
 466                             		.loc 2 450 8
 467 0116 EC A5                   		mov.L	[r10], r5
 468 0118 61 05                   		cmp	#0, r5
 469 011a 20 25                   		beq	.L42
 451:../src/wolfcrypt/src/dsa.c ****         mp_clear(&dsa->p);
 470                             		.loc 2 451 18
 471 011c ED A5 04                		mov.L	16[r10], r5
 472                             		.loc 2 451 9
 473 011f EF 51                   		mov.L	r5, r1
 474 0121 05 00 00 00             		bsr	_sp_clear
 452:../src/wolfcrypt/src/dsa.c ****         mp_clear(&dsa->q);
 475                             		.loc 2 452 18
 476 0125 ED A5 04                		mov.L	16[r10], r5
 477 0128 72 55 10 03             		add	#0x310, r5
 478                             		.loc 2 452 9
 479 012c EF 51                   		mov.L	r5, r1
 480 012e 05 00 00 00             		bsr	_sp_clear
 453:../src/wolfcrypt/src/dsa.c ****         mp_clear(&dsa->g);
 481                             		.loc 2 453 18
 482 0132 ED A5 04                		mov.L	16[r10], r5
 483 0135 72 55 20 06             		add	#0x620, r5
 484                             		.loc 2 453 9
 485 0139 EF 51                   		mov.L	r5, r1
 486 013b 05 00 00 00             		bsr	_sp_clear
 487                             	.L42:
 454:../src/wolfcrypt/src/dsa.c ****     }
 455:../src/wolfcrypt/src/dsa.c **** 
 456:../src/wolfcrypt/src/dsa.c ****     return err;
 488                             		.loc 2 456 12
 489 013f EC A5                   		mov.L	[r10], r5
 490                             	.L34:
 457:../src/wolfcrypt/src/dsa.c **** }
 491                             		.loc 2 457 1
 492 0141 EF 51                   		mov.L	r5, r1
 493 0143 71 00 28                		add	#40, r0
 494 0146 7E B6                   		pop	r6
 495 0148 7E BA                   		pop	r10
 496 014a 02                      		rts
 497                             	.LFE47:
 499 014b 77 10 01 00 00          		.section	.text.wc_DsaImportParamsRaw,"ax",@progbits
 500                             		.global	_wc_DsaImportParamsRaw
 502                             	_wc_DsaImportParamsRaw:
 503                             	.LFB48:
 458:../src/wolfcrypt/src/dsa.c **** 
 459:../src/wolfcrypt/src/dsa.c **** 
 460:../src/wolfcrypt/src/dsa.c **** /* Import raw DSA parameters into DsaKey structure for use with wc_MakeDsaKey(),
 461:../src/wolfcrypt/src/dsa.c ****  * input parameters (p,q,g) should be represented as ASCII hex values.
 462:../src/wolfcrypt/src/dsa.c ****  *
 463:../src/wolfcrypt/src/dsa.c ****  * dsa  - pointer to initialized DsaKey structure
 464:../src/wolfcrypt/src/dsa.c ****  * p    - DSA (p) parameter, ASCII hex string
 465:../src/wolfcrypt/src/dsa.c ****  * pSz  - length of p
 466:../src/wolfcrypt/src/dsa.c ****  * q    - DSA (q) parameter, ASCII hex string
 467:../src/wolfcrypt/src/dsa.c ****  * qSz  - length of q
 468:../src/wolfcrypt/src/dsa.c ****  * g    - DSA (g) parameter, ASCII hex string
 469:../src/wolfcrypt/src/dsa.c ****  * gSz  - length of g
 470:../src/wolfcrypt/src/dsa.c ****  *
 471:../src/wolfcrypt/src/dsa.c ****  * returns 0 on success, negative upon failure
 472:../src/wolfcrypt/src/dsa.c ****  */
 473:../src/wolfcrypt/src/dsa.c **** int wc_DsaImportParamsRaw(DsaKey* dsa, const char* p, const char* q,
 474:../src/wolfcrypt/src/dsa.c ****                           const char* g)
 475:../src/wolfcrypt/src/dsa.c **** {
 504                             		.loc 2 475 1
 505 0000 7E AA                   		push.l	r10
 506                             	.LCFI16:
 507 0002 71 0A F0                		add	#-16, r0, r10
 508                             	.LCFI17:
 509 0005 71 A0 F8                		add	#-8, r10, r0
 510                             	.LCFI18:
 511 0008 E3 A1                   		mov.L	r1, [r10]
 512 000a E7 A2 01                		mov.L	r2, 4[r10]
 513 000d E7 A3 02                		mov.L	r3, 8[r10]
 514 0010 E7 A4 03                		mov.L	r4, 12[r10]
 476:../src/wolfcrypt/src/dsa.c ****     return _DsaImportParamsRaw(dsa, p, q, g, 1, NULL);
 515                             		.loc 2 476 12
 516 0013 3E 01 00                		mov.L	#0, 4[r0]
 517 0016 F8 06 01                		mov.L	#1, [r0]
 518 0019 ED A4 03                		mov.L	12[r10], r4
 519 001c ED A3 02                		mov.L	8[r10], r3
 520 001f ED A2 01                		mov.L	4[r10], r2
 521 0022 EC A1                   		mov.L	[r10], r1
 522 0024 05 00 00 00             		bsr	__DsaImportParamsRaw
 523 0028 EF 15                   		mov.L	r1, r5
 477:../src/wolfcrypt/src/dsa.c **** }
 524                             		.loc 2 477 1
 525 002a EF 51                   		mov.L	r5, r1
 526 002c 3F AA 07                		rtsd	#28, r10-r10
 527                             	.LFE48:
 529                             		.section	.text.wc_DsaImportParamsRawCheck,"ax",@progbits
 530                             		.global	_wc_DsaImportParamsRawCheck
 532                             	_wc_DsaImportParamsRawCheck:
 533                             	.LFB49:
 478:../src/wolfcrypt/src/dsa.c **** 
 479:../src/wolfcrypt/src/dsa.c **** 
 480:../src/wolfcrypt/src/dsa.c **** /* Import raw DSA parameters into DsaKey structure for use with wc_MakeDsaKey(),
 481:../src/wolfcrypt/src/dsa.c ****  * input parameters (p,q,g) should be represented as ASCII hex values. Check
 482:../src/wolfcrypt/src/dsa.c ****  * that the p value is probably prime.
 483:../src/wolfcrypt/src/dsa.c ****  *
 484:../src/wolfcrypt/src/dsa.c ****  * dsa  - pointer to initialized DsaKey structure
 485:../src/wolfcrypt/src/dsa.c ****  * p    - DSA (p) parameter, ASCII hex string
 486:../src/wolfcrypt/src/dsa.c ****  * pSz  - length of p
 487:../src/wolfcrypt/src/dsa.c ****  * q    - DSA (q) parameter, ASCII hex string
 488:../src/wolfcrypt/src/dsa.c ****  * qSz  - length of q
 489:../src/wolfcrypt/src/dsa.c ****  * g    - DSA (g) parameter, ASCII hex string
 490:../src/wolfcrypt/src/dsa.c ****  * gSz  - length of g
 491:../src/wolfcrypt/src/dsa.c ****  * trusted - trust that p is OK
 492:../src/wolfcrypt/src/dsa.c ****  * rng  - random number generator for the prime test
 493:../src/wolfcrypt/src/dsa.c ****  *
 494:../src/wolfcrypt/src/dsa.c ****  * returns 0 on success, negative upon failure
 495:../src/wolfcrypt/src/dsa.c ****  */
 496:../src/wolfcrypt/src/dsa.c **** int wc_DsaImportParamsRawCheck(DsaKey* dsa, const char* p, const char* q,
 497:../src/wolfcrypt/src/dsa.c ****                           const char* g, int trusted, WC_RNG* rng)
 498:../src/wolfcrypt/src/dsa.c **** {
 534                             		.loc 2 498 1
 535 0000 7E AA                   		push.l	r10
 536                             	.LCFI19:
 537 0002 71 0A E8                		add	#-24, r0, r10
 538                             	.LCFI20:
 539 0005 71 A0 F8                		add	#-8, r10, r0
 540                             	.LCFI21:
 541 0008 75 45 20                		mov.L	#32, r5
 542 000b 4B A5                   		add	r10, r5
 543 000d E3 A1                   		mov.L	r1, [r10]
 544 000f E7 A2 01                		mov.L	r2, 4[r10]
 545 0012 E7 A3 02                		mov.L	r3, 8[r10]
 546 0015 E7 A4 03                		mov.L	r4, 12[r10]
 499:../src/wolfcrypt/src/dsa.c ****     return _DsaImportParamsRaw(dsa, p, q, g, trusted, rng);
 547                             		.loc 2 499 12
 548 0018 A8 5C                   		mov.L	4[r5], r4
 549 001a A0 0C                   		mov.L	r4, 4[r0]
 550 001c EC 55                   		mov.L	[r5], r5
 551 001e E3 05                   		mov.L	r5, [r0]
 552 0020 ED A4 03                		mov.L	12[r10], r4
 553 0023 ED A3 02                		mov.L	8[r10], r3
 554 0026 ED A2 01                		mov.L	4[r10], r2
 555 0029 EC A1                   		mov.L	[r10], r1
 556 002b 05 00 00 00             		bsr	__DsaImportParamsRaw
 557 002f EF 15                   		mov.L	r1, r5
 500:../src/wolfcrypt/src/dsa.c **** }
 558                             		.loc 2 500 1
 559 0031 EF 51                   		mov.L	r5, r1
 560 0033 3F AA 09                		rtsd	#36, r10-r10
 561                             	.LFE49:
 563                             		.section C,"a",@progbits
 564 0022 00 00                   		.p2align 2
 565                             	.LC1:
 566 0024 4F 75 74 70 75 74 20 62 		.string	"Output buffer for DSA p parameter too small, required size placed into pSz"
 566      75 66 66 65 72 20 66 6F 
 566      72 20 44 53 41 20 70 20 
 566      70 61 72 61 6D 65 74 65 
 566      72 20 74 6F 6F 20 73 6D 
 567                             	.LC2:
 568 006f 4F 75 74 70 75 74 20 62 		.string	"Output buffer for DSA q parameter too small, required size placed into qSz"
 568      75 66 66 65 72 20 66 6F 
 568      72 20 44 53 41 20 71 20 
 568      70 61 72 61 6D 65 74 65 
 568      72 20 74 6F 6F 20 73 6D 
 569                             	.LC3:
 570 00ba 4F 75 74 70 75 74 20 62 		.string	"Output buffer for DSA g parameter too small, required size placed into gSz"
 570      75 66 66 65 72 20 66 6F 
 570      72 20 44 53 41 20 67 20 
 570      70 61 72 61 6D 65 74 65 
 570      72 20 74 6F 6F 20 73 6D 
 571                             		.section	.text.wc_DsaExportParamsRaw,"ax",@progbits
 572                             		.global	_wc_DsaExportParamsRaw
 574                             	_wc_DsaExportParamsRaw:
 575                             	.LFB50:
 501:../src/wolfcrypt/src/dsa.c **** 
 502:../src/wolfcrypt/src/dsa.c **** 
 503:../src/wolfcrypt/src/dsa.c **** /* Export raw DSA parameters from DsaKey structure
 504:../src/wolfcrypt/src/dsa.c ****  *
 505:../src/wolfcrypt/src/dsa.c ****  * dsa  - pointer to initialized DsaKey structure
 506:../src/wolfcrypt/src/dsa.c ****  * p    - output location for DSA (p) parameter
 507:../src/wolfcrypt/src/dsa.c ****  * pSz  - [IN/OUT] size of output buffer for p, size of p
 508:../src/wolfcrypt/src/dsa.c ****  * q    - output location for DSA (q) parameter
 509:../src/wolfcrypt/src/dsa.c ****  * qSz  - [IN/OUT] size of output buffer for q, size of q
 510:../src/wolfcrypt/src/dsa.c ****  * g    - output location for DSA (g) parameter
 511:../src/wolfcrypt/src/dsa.c ****  * gSz  - [IN/OUT] size of output buffer for g, size of g
 512:../src/wolfcrypt/src/dsa.c ****  *
 513:../src/wolfcrypt/src/dsa.c ****  * If p, q, and g pointers are all passed in as NULL, the function
 514:../src/wolfcrypt/src/dsa.c ****  * will set pSz, qSz, and gSz to the required output buffer sizes for p,
 515:../src/wolfcrypt/src/dsa.c ****  * q, and g. In this case, the function will return LENGTH_ONLY_E.
 516:../src/wolfcrypt/src/dsa.c ****  *
 517:../src/wolfcrypt/src/dsa.c ****  * returns 0 on success, negative upon failure
 518:../src/wolfcrypt/src/dsa.c ****  */
 519:../src/wolfcrypt/src/dsa.c **** int wc_DsaExportParamsRaw(DsaKey* dsa, byte* p, word32* pSz,
 520:../src/wolfcrypt/src/dsa.c ****                           byte* q, word32* qSz, byte* g, word32* gSz)
 521:../src/wolfcrypt/src/dsa.c **** {
 576                             		.loc 2 521 1
 577 0000 7E AA                   		push.l	r10
 578                             	.LCFI22:
 579 0002 7E A6                   		push.l	r6
 580                             	.LCFI23:
 581 0004 71 0A D4                		add	#-44, r0, r10
 582                             	.LCFI24:
 583 0007 EF A0                   		mov.L	r10, r0
 584 0009 75 46 38                		mov.L	#56, r6
 585 000c 4B A6                   		add	r10, r6
 586 000e E7 A1 04                		mov.L	r1, 16[r10]
 587 0011 E7 A2 05                		mov.L	r2, 20[r10]
 588 0014 E7 A3 06                		mov.L	r3, 24[r10]
 589 0017 E7 A4 07                		mov.L	r4, 28[r10]
 522:../src/wolfcrypt/src/dsa.c ****     int err;
 523:../src/wolfcrypt/src/dsa.c ****     word32 pLen, qLen, gLen;
 524:../src/wolfcrypt/src/dsa.c **** 
 525:../src/wolfcrypt/src/dsa.c ****     if (dsa == NULL || pSz == NULL || qSz == NULL || gSz == NULL)
 590                             		.loc 2 525 8
 591 001a ED A5 04                		mov.L	16[r10], r5
 592 001d 61 05                   		cmp	#0, r5
 593 001f 20 13                   		beq	.L48
 594                             		.loc 2 525 21 discriminator 1
 595 0021 ED A5 06                		mov.L	24[r10], r5
 596 0024 61 05                   		cmp	#0, r5
 597 0026 20 0C                   		beq	.L48
 598                             		.loc 2 525 36 discriminator 2
 599 0028 EC 65                   		mov.L	[r6], r5
 600 002a 61 05                   		cmp	#0, r5
 601 002c 16                      		beq	.L48
 602                             		.loc 2 525 51 discriminator 3
 603 002d A8 E5                   		mov.L	8[r6], r5
 604 002f 61 05                   		cmp	#0, r5
 605 0031 18                      		bne	.L49
 606                             		.balign 8,3,2
 607                             	.L48:
 526:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 608                             		.loc 2 526 16
 609 0032 FB 5A 53 FF             		mov.L	#-173, r5
 610 0036 38 3D 01                		bra	.L50
 611                             	.L49:
 527:../src/wolfcrypt/src/dsa.c **** 
 528:../src/wolfcrypt/src/dsa.c ****     /* get required output buffer sizes */
 529:../src/wolfcrypt/src/dsa.c ****     pLen = mp_unsigned_bin_size(&dsa->p);
 612                             		.loc 2 529 33
 613 0039 ED A5 04                		mov.L	16[r10], r5
 614                             		.loc 2 529 12
 615 003c EF 51                   		mov.L	r5, r1
 616 003e 05 00 00 00             		bsr	_sp_unsigned_bin_size
 617 0042 EF 15                   		mov.L	r1, r5
 618                             		.loc 2 529 10
 619 0044 E7 A5 01                		mov.L	r5, 4[r10]
 530:../src/wolfcrypt/src/dsa.c ****     qLen = mp_unsigned_bin_size(&dsa->q);
 620                             		.loc 2 530 33
 621 0047 ED A5 04                		mov.L	16[r10], r5
 622 004a 72 55 10 03             		add	#0x310, r5
 623                             		.loc 2 530 12
 624 004e EF 51                   		mov.L	r5, r1
 625 0050 05 00 00 00             		bsr	_sp_unsigned_bin_size
 626 0054 EF 15                   		mov.L	r1, r5
 627                             		.loc 2 530 10
 628 0056 E7 A5 02                		mov.L	r5, 8[r10]
 531:../src/wolfcrypt/src/dsa.c ****     gLen = mp_unsigned_bin_size(&dsa->g);
 629                             		.loc 2 531 33
 630 0059 ED A5 04                		mov.L	16[r10], r5
 631 005c 72 55 20 06             		add	#0x620, r5
 632                             		.loc 2 531 12
 633 0060 EF 51                   		mov.L	r5, r1
 634 0062 05 00 00 00             		bsr	_sp_unsigned_bin_size
 635 0066 EF 15                   		mov.L	r1, r5
 636                             		.loc 2 531 10
 637 0068 E7 A5 03                		mov.L	r5, 12[r10]
 532:../src/wolfcrypt/src/dsa.c **** 
 533:../src/wolfcrypt/src/dsa.c ****     /* return buffer sizes and LENGTH_ONLY_E if buffers are NULL */
 534:../src/wolfcrypt/src/dsa.c ****     if (p == NULL && q == NULL && g == NULL) {
 638                             		.loc 2 534 8
 639 006b ED A5 05                		mov.L	20[r10], r5
 640 006e 61 05                   		cmp	#0, r5
 641 0070 21 2C                   		bne	.L51
 642                             		.loc 2 534 19 discriminator 1
 643 0072 ED A5 07                		mov.L	28[r10], r5
 644 0075 61 05                   		cmp	#0, r5
 645 0077 21 25                   		bne	.L51
 646                             		.loc 2 534 32 discriminator 2
 647 0079 A8 6D                   		mov.L	4[r6], r5
 648 007b 61 05                   		cmp	#0, r5
 649 007d 21 1F                   		bne	.L51
 535:../src/wolfcrypt/src/dsa.c ****         *pSz = pLen;
 650                             		.loc 2 535 14
 651 007f ED A5 06                		mov.L	24[r10], r5
 652 0082 ED A4 01                		mov.L	4[r10], r4
 653 0085 E3 54                   		mov.L	r4, [r5]
 536:../src/wolfcrypt/src/dsa.c ****         *qSz = qLen;
 654                             		.loc 2 536 14
 655 0087 EC 65                   		mov.L	[r6], r5
 656 0089 ED A4 02                		mov.L	8[r10], r4
 657 008c E3 54                   		mov.L	r4, [r5]
 537:../src/wolfcrypt/src/dsa.c ****         *gSz = gLen;
 658                             		.loc 2 537 14
 659 008e A8 E5                   		mov.L	8[r6], r5
 660 0090 ED A4 03                		mov.L	12[r10], r4
 661 0093 E3 54                   		mov.L	r4, [r5]
 538:../src/wolfcrypt/src/dsa.c ****         return LENGTH_ONLY_E;
 662                             		.loc 2 538 16
 663 0095 FB 5A 36 FF             		mov.L	#-202, r5
 664 0099 38 DA 00                		bra	.L50
 665                             	.L51:
 539:../src/wolfcrypt/src/dsa.c ****     }
 540:../src/wolfcrypt/src/dsa.c **** 
 541:../src/wolfcrypt/src/dsa.c ****     if (p == NULL || q == NULL || g == NULL)
 666                             		.loc 2 541 8
 667 009c ED A5 05                		mov.L	20[r10], r5
 668 009f 61 05                   		cmp	#0, r5
 669 00a1 20 0D                   		beq	.L52
 670                             		.loc 2 541 19 discriminator 1
 671 00a3 ED A5 07                		mov.L	28[r10], r5
 672 00a6 61 05                   		cmp	#0, r5
 673 00a8 16                      		beq	.L52
 674                             		.loc 2 541 32 discriminator 2
 675 00a9 A8 6D                   		mov.L	4[r6], r5
 676 00ab 61 05                   		cmp	#0, r5
 677 00ad 18                      		bne	.L53
 678                             	.L52:
 542:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 679                             		.loc 2 542 16
 680 00ae FB 5A 53 FF             		mov.L	#-173, r5
 681 00b2 38 C1 00                		bra	.L50
 682                             	.L53:
 543:../src/wolfcrypt/src/dsa.c **** 
 544:../src/wolfcrypt/src/dsa.c ****     /* export p */
 545:../src/wolfcrypt/src/dsa.c ****     if (*pSz < pLen) {
 683                             		.loc 2 545 9
 684 00b5 ED A5 06                		mov.L	24[r10], r5
 685 00b8 EC 55                   		mov.L	[r5], r5
 686                             		.loc 2 545 8
 687 00ba ED A4 01                		mov.L	4[r10], r4
 688 00bd 47 54                   		cmp	r5, r4
 689 00bf 25 1B                   		bleu	.L54
 546:../src/wolfcrypt/src/dsa.c ****         WOLFSSL_MSG("Output buffer for DSA p parameter too small, "
 690                             		.loc 2 546 9
 691 00c1 FB 12 24 00 00 00       		mov.L	#.LC1, r1
 692 00c7 05 00 00 00             		bsr	_WOLFSSL_MSG
 547:../src/wolfcrypt/src/dsa.c ****                     "required size placed into pSz");
 548:../src/wolfcrypt/src/dsa.c ****         *pSz = pLen;
 693                             		.loc 2 548 14
 694 00cb ED A5 06                		mov.L	24[r10], r5
 695 00ce ED A4 01                		mov.L	4[r10], r4
 696 00d1 E3 54                   		mov.L	r4, [r5]
 549:../src/wolfcrypt/src/dsa.c ****         return BUFFER_E;
 697                             		.loc 2 549 16
 698 00d3 FB 5A 7C FF             		mov.L	#-132, r5
 699 00d7 38 9C 00                		bra	.L50
 700                             	.L54:
 550:../src/wolfcrypt/src/dsa.c ****     }
 551:../src/wolfcrypt/src/dsa.c ****     *pSz = pLen;
 701                             		.loc 2 551 10
 702 00da ED A5 06                		mov.L	24[r10], r5
 703 00dd ED A4 01                		mov.L	4[r10], r4
 704 00e0 E3 54                   		mov.L	r4, [r5]
 552:../src/wolfcrypt/src/dsa.c ****     err = mp_to_unsigned_bin(&dsa->p, p);
 705                             		.loc 2 552 30
 706 00e2 ED A5 04                		mov.L	16[r10], r5
 707                             		.loc 2 552 11
 708 00e5 ED A2 05                		mov.L	20[r10], r2
 709 00e8 EF 51                   		mov.L	r5, r1
 710 00ea 05 00 00 00             		bsr	_sp_to_unsigned_bin
 711 00ee E3 A1                   		mov.L	r1, [r10]
 553:../src/wolfcrypt/src/dsa.c **** 
 554:../src/wolfcrypt/src/dsa.c ****     /* export q */
 555:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY) {
 712                             		.loc 2 555 8
 713 00f0 EC A5                   		mov.L	[r10], r5
 714 00f2 61 05                   		cmp	#0, r5
 715 00f4 21 3D                   		bne	.L55
 556:../src/wolfcrypt/src/dsa.c ****         if (*qSz < qLen) {
 716                             		.loc 2 556 13
 717 00f6 EC 65                   		mov.L	[r6], r5
 718 00f8 EC 55                   		mov.L	[r5], r5
 719                             		.loc 2 556 12
 720 00fa ED A4 02                		mov.L	8[r10], r4
 721 00fd 47 54                   		cmp	r5, r4
 722 00ff 25 19                   		bleu	.L56
 557:../src/wolfcrypt/src/dsa.c ****             WOLFSSL_MSG("Output buffer for DSA q parameter too small, "
 723                             		.loc 2 557 13
 724 0101 FB 12 6F 00 00 00       		mov.L	#.LC2, r1
 725 0107 05 00 00 00             		bsr	_WOLFSSL_MSG
 558:../src/wolfcrypt/src/dsa.c ****                         "required size placed into qSz");
 559:../src/wolfcrypt/src/dsa.c ****             *qSz = qLen;
 726                             		.loc 2 559 18
 727 010b EC 65                   		mov.L	[r6], r5
 728 010d ED A4 02                		mov.L	8[r10], r4
 729 0110 E3 54                   		mov.L	r4, [r5]
 560:../src/wolfcrypt/src/dsa.c ****             return BUFFER_E;
 730                             		.loc 2 560 20
 731 0112 FB 5A 7C FF             		mov.L	#-132, r5
 732 0116 2E 5D                   		bra	.L50
 733                             	.L56:
 561:../src/wolfcrypt/src/dsa.c ****         }
 562:../src/wolfcrypt/src/dsa.c ****         *qSz = qLen;
 734                             		.loc 2 562 14
 735 0118 EC 65                   		mov.L	[r6], r5
 736 011a ED A4 02                		mov.L	8[r10], r4
 737 011d E3 54                   		mov.L	r4, [r5]
 563:../src/wolfcrypt/src/dsa.c ****         err = mp_to_unsigned_bin(&dsa->q, q);
 738                             		.loc 2 563 34
 739 011f ED A5 04                		mov.L	16[r10], r5
 740 0122 72 55 10 03             		add	#0x310, r5
 741                             		.loc 2 563 15
 742 0126 ED A2 07                		mov.L	28[r10], r2
 743 0129 EF 51                   		mov.L	r5, r1
 744 012b 05 00 00 00             		bsr	_sp_to_unsigned_bin
 745 012f E3 A1                   		mov.L	r1, [r10]
 746                             	.L55:
 564:../src/wolfcrypt/src/dsa.c ****     }
 565:../src/wolfcrypt/src/dsa.c **** 
 566:../src/wolfcrypt/src/dsa.c ****     /* export g */
 567:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY) {
 747                             		.loc 2 567 8
 748 0131 EC A5                   		mov.L	[r10], r5
 749 0133 61 05                   		cmp	#0, r5
 750 0135 21 3C                   		bne	.L57
 568:../src/wolfcrypt/src/dsa.c ****         if (*gSz < gLen) {
 751                             		.loc 2 568 13
 752 0137 A8 E5                   		mov.L	8[r6], r5
 753 0139 EC 55                   		mov.L	[r5], r5
 754                             		.loc 2 568 12
 755 013b ED A4 03                		mov.L	12[r10], r4
 756 013e 47 54                   		cmp	r5, r4
 757 0140 25 19                   		bleu	.L58
 569:../src/wolfcrypt/src/dsa.c ****             WOLFSSL_MSG("Output buffer for DSA g parameter too small, "
 758                             		.loc 2 569 13
 759 0142 FB 12 BA 00 00 00       		mov.L	#.LC3, r1
 760 0148 05 00 00 00             		bsr	_WOLFSSL_MSG
 570:../src/wolfcrypt/src/dsa.c ****                         "required size placed into gSz");
 571:../src/wolfcrypt/src/dsa.c ****             *gSz = gLen;
 761                             		.loc 2 571 18
 762 014c A8 E5                   		mov.L	8[r6], r5
 763 014e ED A4 03                		mov.L	12[r10], r4
 764 0151 E3 54                   		mov.L	r4, [r5]
 572:../src/wolfcrypt/src/dsa.c ****             return BUFFER_E;
 765                             		.loc 2 572 20
 766 0153 FB 5A 7C FF             		mov.L	#-132, r5
 767 0157 2E 1C                   		bra	.L50
 768                             	.L58:
 573:../src/wolfcrypt/src/dsa.c ****         }
 574:../src/wolfcrypt/src/dsa.c ****         *gSz = gLen;
 769                             		.loc 2 574 14
 770 0159 A8 E5                   		mov.L	8[r6], r5
 771 015b ED A4 03                		mov.L	12[r10], r4
 772 015e E3 54                   		mov.L	r4, [r5]
 575:../src/wolfcrypt/src/dsa.c ****         err = mp_to_unsigned_bin(&dsa->g, g);
 773                             		.loc 2 575 34
 774 0160 ED A5 04                		mov.L	16[r10], r5
 775 0163 72 55 20 06             		add	#0x620, r5
 776                             		.loc 2 575 15
 777 0167 A8 6A                   		mov.L	4[r6], r2
 778 0169 EF 51                   		mov.L	r5, r1
 779 016b 05 00 00 00             		bsr	_sp_to_unsigned_bin
 780 016f E3 A1                   		mov.L	r1, [r10]
 781                             	.L57:
 576:../src/wolfcrypt/src/dsa.c ****     }
 577:../src/wolfcrypt/src/dsa.c **** 
 578:../src/wolfcrypt/src/dsa.c ****     return err;
 782                             		.loc 2 578 12
 783 0171 EC A5                   		mov.L	[r10], r5
 784                             		.balign 8,3,1
 785                             	.L50:
 579:../src/wolfcrypt/src/dsa.c **** }
 786                             		.loc 2 579 1
 787 0173 EF 51                   		mov.L	r5, r1
 788 0175 71 00 2C                		add	#44, r0
 789 0178 7E B6                   		pop	r6
 790 017a 7E BA                   		pop	r10
 791 017c 02                      		rts
 792                             	.LFE50:
 794 017d FC 13 00                		.section C,"a",@progbits
 795 0105 00 00 00                		.p2align 2
 796                             	.LC4:
 797 0108 4F 75 74 70 75 74 20 62 		.string	"Output buffer for DSA private key (x) too small, required size placed into xSz"
 797      75 66 66 65 72 20 66 6F 
 797      72 20 44 53 41 20 70 72 
 797      69 76 61 74 65 20 6B 65 
 797      79 20 28 78 29 20 74 6F 
 798                             	.LC5:
 799 0157 4F 75 74 70 75 74 20 62 		.string	"Output buffer to DSA public key (y) too small, required size placed into ySz"
 799      75 66 66 65 72 20 74 6F 
 799      20 44 53 41 20 70 75 62 
 799      6C 69 63 20 6B 65 79 20 
 799      28 79 29 20 74 6F 6F 20 
 800                             		.section	.text.wc_DsaExportKeyRaw,"ax",@progbits
 801                             		.global	_wc_DsaExportKeyRaw
 803                             	_wc_DsaExportKeyRaw:
 804                             	.LFB51:
 580:../src/wolfcrypt/src/dsa.c **** 
 581:../src/wolfcrypt/src/dsa.c **** 
 582:../src/wolfcrypt/src/dsa.c **** /* Export raw DSA key (x, y) from DsaKey structure
 583:../src/wolfcrypt/src/dsa.c ****  *
 584:../src/wolfcrypt/src/dsa.c ****  * dsa  - pointer to initialized DsaKey structure
 585:../src/wolfcrypt/src/dsa.c ****  * x    - output location for private key
 586:../src/wolfcrypt/src/dsa.c ****  * xSz  - [IN/OUT] size of output buffer for x, size of x
 587:../src/wolfcrypt/src/dsa.c ****  * y    - output location for public key
 588:../src/wolfcrypt/src/dsa.c ****  * ySz  - [IN/OUT] size of output buffer for y, size of y
 589:../src/wolfcrypt/src/dsa.c ****  *
 590:../src/wolfcrypt/src/dsa.c ****  * If x and y pointers are all passed in as NULL, the function
 591:../src/wolfcrypt/src/dsa.c ****  * will set xSz and ySz to the required output buffer sizes for x
 592:../src/wolfcrypt/src/dsa.c ****  * and y. In this case, the function will return LENGTH_ONLY_E.
 593:../src/wolfcrypt/src/dsa.c ****  *
 594:../src/wolfcrypt/src/dsa.c ****  * returns 0 on success, negative upon failure
 595:../src/wolfcrypt/src/dsa.c ****  */
 596:../src/wolfcrypt/src/dsa.c **** int wc_DsaExportKeyRaw(DsaKey* dsa, byte* x, word32* xSz, byte* y, word32* ySz)
 597:../src/wolfcrypt/src/dsa.c **** {
 805                             		.loc 2 597 1
 806 0000 7E AA                   		push.l	r10
 807                             	.LCFI25:
 808 0002 7E A6                   		push.l	r6
 809                             	.LCFI26:
 810 0004 71 0A E0                		add	#-32, r0, r10
 811                             	.LCFI27:
 812 0007 EF A0                   		mov.L	r10, r0
 813 0009 75 46 2C                		mov.L	#44, r6
 814 000c 4B A6                   		add	r10, r6
 815 000e E7 A1 03                		mov.L	r1, 12[r10]
 816 0011 E7 A2 04                		mov.L	r2, 16[r10]
 817 0014 E7 A3 05                		mov.L	r3, 20[r10]
 818 0017 E7 A4 06                		mov.L	r4, 24[r10]
 598:../src/wolfcrypt/src/dsa.c ****     int err;
 599:../src/wolfcrypt/src/dsa.c ****     word32 xLen, yLen;
 600:../src/wolfcrypt/src/dsa.c **** 
 601:../src/wolfcrypt/src/dsa.c ****     if (dsa == NULL || xSz == NULL || ySz == NULL)
 819                             		.loc 2 601 8
 820 001a ED A5 03                		mov.L	12[r10], r5
 821 001d 61 05                   		cmp	#0, r5
 822 001f 20 0D                   		beq	.L60
 823                             		.loc 2 601 21 discriminator 1
 824 0021 ED A5 05                		mov.L	20[r10], r5
 825 0024 61 05                   		cmp	#0, r5
 826 0026 16                      		beq	.L60
 827                             		.loc 2 601 36 discriminator 2
 828 0027 EC 65                   		mov.L	[r6], r5
 829 0029 61 05                   		cmp	#0, r5
 830 002b 18                      		bne	.L61
 831                             	.L60:
 602:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 832                             		.loc 2 602 16
 833 002c FB 5A 53 FF             		mov.L	#-173, r5
 834 0030 38 E0 00                		bra	.L62
 835                             	.L61:
 603:../src/wolfcrypt/src/dsa.c **** 
 604:../src/wolfcrypt/src/dsa.c ****     /* get required output buffer sizes */
 605:../src/wolfcrypt/src/dsa.c ****     xLen = mp_unsigned_bin_size(&dsa->x);
 836                             		.loc 2 605 33
 837 0033 ED A5 03                		mov.L	12[r10], r5
 838 0036 72 55 40 0C             		add	#0xc40, r5
 839                             		.loc 2 605 12
 840 003a EF 51                   		mov.L	r5, r1
 841 003c 05 00 00 00             		bsr	_sp_unsigned_bin_size
 842 0040 EF 15                   		mov.L	r1, r5
 843                             		.loc 2 605 10
 844 0042 E7 A5 01                		mov.L	r5, 4[r10]
 606:../src/wolfcrypt/src/dsa.c ****     yLen = mp_unsigned_bin_size(&dsa->y);
 845                             		.loc 2 606 33
 846 0045 ED A5 03                		mov.L	12[r10], r5
 847 0048 72 55 30 09             		add	#0x930, r5
 848                             		.loc 2 606 12
 849 004c EF 51                   		mov.L	r5, r1
 850 004e 05 00 00 00             		bsr	_sp_unsigned_bin_size
 851 0052 EF 15                   		mov.L	r1, r5
 852                             		.loc 2 606 10
 853 0054 E7 A5 02                		mov.L	r5, 8[r10]
 607:../src/wolfcrypt/src/dsa.c **** 
 608:../src/wolfcrypt/src/dsa.c ****     /* return buffer sizes and LENGTH_ONLY_E if buffers are NULL */
 609:../src/wolfcrypt/src/dsa.c ****     if (x == NULL && y == NULL) {
 854                             		.loc 2 609 8
 855 0057 ED A5 04                		mov.L	16[r10], r5
 856 005a 61 05                   		cmp	#0, r5
 857 005c 21 1F                   		bne	.L63
 858                             		.loc 2 609 19 discriminator 1
 859 005e ED A5 06                		mov.L	24[r10], r5
 860 0061 61 05                   		cmp	#0, r5
 861 0063 21 18                   		bne	.L63
 610:../src/wolfcrypt/src/dsa.c ****         *xSz = xLen;
 862                             		.loc 2 610 14
 863 0065 ED A5 05                		mov.L	20[r10], r5
 864 0068 ED A4 01                		mov.L	4[r10], r4
 865 006b E3 54                   		mov.L	r4, [r5]
 611:../src/wolfcrypt/src/dsa.c ****         *ySz = yLen;
 866                             		.loc 2 611 14
 867 006d EC 65                   		mov.L	[r6], r5
 868 006f ED A4 02                		mov.L	8[r10], r4
 869 0072 E3 54                   		mov.L	r4, [r5]
 612:../src/wolfcrypt/src/dsa.c ****         return LENGTH_ONLY_E;
 870                             		.loc 2 612 16
 871 0074 FB 5A 36 FF             		mov.L	#-202, r5
 872 0078 38 98 00                		bra	.L62
 873                             	.L63:
 613:../src/wolfcrypt/src/dsa.c ****     }
 614:../src/wolfcrypt/src/dsa.c **** 
 615:../src/wolfcrypt/src/dsa.c ****     if (x == NULL || y == NULL)
 874                             		.loc 2 615 8
 875 007b ED A5 04                		mov.L	16[r10], r5
 876 007e 61 05                   		cmp	#0, r5
 877 0080 17                      		beq	.L64
 878                             		.loc 2 615 19 discriminator 1
 879 0081 ED A5 06                		mov.L	24[r10], r5
 880 0084 61 05                   		cmp	#0, r5
 881 0086 18                      		bne	.L65
 882                             	.L64:
 616:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 883                             		.loc 2 616 16
 884 0087 FB 5A 53 FF             		mov.L	#-173, r5
 885 008b 38 85 00                		bra	.L62
 886                             	.L65:
 617:../src/wolfcrypt/src/dsa.c **** 
 618:../src/wolfcrypt/src/dsa.c ****     /* export x */
 619:../src/wolfcrypt/src/dsa.c ****     if (*xSz < xLen) {
 887                             		.loc 2 619 9
 888 008e ED A5 05                		mov.L	20[r10], r5
 889 0091 EC 55                   		mov.L	[r5], r5
 890                             		.loc 2 619 8
 891 0093 ED A4 01                		mov.L	4[r10], r4
 892 0096 47 54                   		cmp	r5, r4
 893 0098 25 1A                   		bleu	.L66
 620:../src/wolfcrypt/src/dsa.c ****         WOLFSSL_MSG("Output buffer for DSA private key (x) too small, "
 894                             		.loc 2 620 9
 895 009a FB 12 08 01 00 00       		mov.L	#.LC4, r1
 896 00a0 05 00 00 00             		bsr	_WOLFSSL_MSG
 621:../src/wolfcrypt/src/dsa.c ****                     "required size placed into xSz");
 622:../src/wolfcrypt/src/dsa.c ****         *xSz = xLen;
 897                             		.loc 2 622 14
 898 00a4 ED A5 05                		mov.L	20[r10], r5
 899 00a7 ED A4 01                		mov.L	4[r10], r4
 900 00aa E3 54                   		mov.L	r4, [r5]
 623:../src/wolfcrypt/src/dsa.c ****         return BUFFER_E;
 901                             		.loc 2 623 16
 902 00ac FB 5A 7C FF             		mov.L	#-132, r5
 903 00b0 2E 60                   		bra	.L62
 904                             	.L66:
 624:../src/wolfcrypt/src/dsa.c ****     }
 625:../src/wolfcrypt/src/dsa.c ****     *xSz = xLen;
 905                             		.loc 2 625 10
 906 00b2 ED A5 05                		mov.L	20[r10], r5
 907 00b5 ED A4 01                		mov.L	4[r10], r4
 908 00b8 E3 54                   		mov.L	r4, [r5]
 626:../src/wolfcrypt/src/dsa.c ****     err = mp_to_unsigned_bin(&dsa->x, x);
 909                             		.loc 2 626 30
 910 00ba ED A5 03                		mov.L	12[r10], r5
 911 00bd 72 55 40 0C             		add	#0xc40, r5
 912                             		.loc 2 626 11
 913 00c1 ED A2 04                		mov.L	16[r10], r2
 914 00c4 EF 51                   		mov.L	r5, r1
 915 00c6 05 00 00 00             		bsr	_sp_to_unsigned_bin
 916 00ca E3 A1                   		mov.L	r1, [r10]
 627:../src/wolfcrypt/src/dsa.c **** 
 628:../src/wolfcrypt/src/dsa.c ****     /* export y */
 629:../src/wolfcrypt/src/dsa.c ****     if (err == MP_OKAY) {
 917                             		.loc 2 629 8
 918 00cc EC A5                   		mov.L	[r10], r5
 919 00ce 61 05                   		cmp	#0, r5
 920 00d0 21 3D                   		bne	.L67
 630:../src/wolfcrypt/src/dsa.c ****         if (*ySz < yLen) {
 921                             		.loc 2 630 13
 922 00d2 EC 65                   		mov.L	[r6], r5
 923 00d4 EC 55                   		mov.L	[r5], r5
 924                             		.loc 2 630 12
 925 00d6 ED A4 02                		mov.L	8[r10], r4
 926 00d9 47 54                   		cmp	r5, r4
 927 00db 25 19                   		bleu	.L68
 631:../src/wolfcrypt/src/dsa.c ****             WOLFSSL_MSG("Output buffer to DSA public key (y) too small, "
 928                             		.loc 2 631 13
 929 00dd FB 12 57 01 00 00       		mov.L	#.LC5, r1
 930 00e3 05 00 00 00             		bsr	_WOLFSSL_MSG
 632:../src/wolfcrypt/src/dsa.c ****                         "required size placed into ySz");
 633:../src/wolfcrypt/src/dsa.c ****             *ySz = yLen;
 931                             		.loc 2 633 18
 932 00e7 EC 65                   		mov.L	[r6], r5
 933 00e9 ED A4 02                		mov.L	8[r10], r4
 934 00ec E3 54                   		mov.L	r4, [r5]
 634:../src/wolfcrypt/src/dsa.c ****             return BUFFER_E;
 935                             		.loc 2 634 20
 936 00ee FB 5A 7C FF             		mov.L	#-132, r5
 937 00f2 2E 1E                   		bra	.L62
 938                             	.L68:
 635:../src/wolfcrypt/src/dsa.c ****         }
 636:../src/wolfcrypt/src/dsa.c ****         *ySz = yLen;
 939                             		.loc 2 636 14
 940 00f4 EC 65                   		mov.L	[r6], r5
 941 00f6 ED A4 02                		mov.L	8[r10], r4
 942 00f9 E3 54                   		mov.L	r4, [r5]
 637:../src/wolfcrypt/src/dsa.c ****         err = mp_to_unsigned_bin(&dsa->y, y);
 943                             		.loc 2 637 34
 944 00fb ED A5 03                		mov.L	12[r10], r5
 945 00fe 72 55 30 09             		add	#0x930, r5
 946                             		.loc 2 637 15
 947 0102 ED A2 06                		mov.L	24[r10], r2
 948 0105 EF 51                   		mov.L	r5, r1
 949 0107 05 00 00 00             		bsr	_sp_to_unsigned_bin
 950 010b E3 A1                   		mov.L	r1, [r10]
 951                             	.L67:
 638:../src/wolfcrypt/src/dsa.c ****     }
 639:../src/wolfcrypt/src/dsa.c **** 
 640:../src/wolfcrypt/src/dsa.c ****     return err;
 952                             		.loc 2 640 12
 953 010d EC A5                   		mov.L	[r10], r5
 954 010f 03                      		.balign 8,3,1
 955                             	.L62:
 641:../src/wolfcrypt/src/dsa.c **** }
 956                             		.loc 2 641 1
 957 0110 EF 51                   		mov.L	r5, r1
 958 0112 71 00 20                		add	#32, r0
 959 0115 7E B6                   		pop	r6
 960 0117 7E BA                   		pop	r10
 961 0119 02                      		rts
 962                             	.LFE51:
 964 011a 74 10 01 00 00 00       		.section	.text.wc_DsaSign,"ax",@progbits
 965                             		.global	_wc_DsaSign
 967                             	_wc_DsaSign:
 968                             	.LFB52:
 642:../src/wolfcrypt/src/dsa.c **** 
 643:../src/wolfcrypt/src/dsa.c **** 
 644:../src/wolfcrypt/src/dsa.c **** int wc_DsaSign(const byte* digest, byte* out, DsaKey* key, WC_RNG* rng)
 645:../src/wolfcrypt/src/dsa.c **** {
 969                             		.loc 2 645 1
 970 0000 7E AA                   		push.l	r10
 971                             	.LCFI28:
 972 0002 71 0A A0                		add	#-96, r0, r10
 973                             	.LCFI29:
 974 0005 71 A0 F8                		add	#-8, r10, r0
 975                             	.LCFI30:
 976 0008 E7 A1 14                		mov.L	r1, 80[r10]
 977 000b E7 A2 15                		mov.L	r2, 84[r10]
 978 000e E7 A3 16                		mov.L	r3, 88[r10]
 979 0011 E7 A4 17                		mov.L	r4, 92[r10]
 646:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 647:../src/wolfcrypt/src/dsa.c ****     mp_int  *k = NULL;
 980                             		.loc 2 647 14
 981 0014 F9 A6 04 00             		mov.L	#0, 16[r10]
 648:../src/wolfcrypt/src/dsa.c ****     mp_int  *kInv = NULL;
 982                             		.loc 2 648 14
 983 0018 F9 A6 05 00             		mov.L	#0, 20[r10]
 649:../src/wolfcrypt/src/dsa.c ****     mp_int  *r = NULL;
 984                             		.loc 2 649 14
 985 001c F9 A6 06 00             		mov.L	#0, 24[r10]
 650:../src/wolfcrypt/src/dsa.c ****     mp_int  *s = NULL;
 986                             		.loc 2 650 14
 987 0020 F9 A6 07 00             		mov.L	#0, 28[r10]
 651:../src/wolfcrypt/src/dsa.c ****     mp_int  *H = NULL;
 988                             		.loc 2 651 14
 989 0024 F9 A6 08 00             		mov.L	#0, 32[r10]
 652:../src/wolfcrypt/src/dsa.c **** #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME
 653:../src/wolfcrypt/src/dsa.c ****     mp_int  *b = NULL;
 990                             		.loc 2 653 14
 991 0028 F9 A6 09 00             		mov.L	#0, 36[r10]
 654:../src/wolfcrypt/src/dsa.c **** #endif
 655:../src/wolfcrypt/src/dsa.c ****     byte    *buffer = NULL;
 992                             		.loc 2 655 14
 993 002c F9 A6 0A 00             		mov.L	#0, 40[r10]
 656:../src/wolfcrypt/src/dsa.c **** #else
 657:../src/wolfcrypt/src/dsa.c ****     mp_int  k[1], kInv[1], r[1], s[1], H[1];
 658:../src/wolfcrypt/src/dsa.c **** #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME
 659:../src/wolfcrypt/src/dsa.c ****     mp_int  b[1];
 660:../src/wolfcrypt/src/dsa.c **** #endif
 661:../src/wolfcrypt/src/dsa.c ****     byte    buffer[DSA_MAX_HALF_SIZE];
 662:../src/wolfcrypt/src/dsa.c **** #endif
 663:../src/wolfcrypt/src/dsa.c ****     mp_int* qMinus1;
 664:../src/wolfcrypt/src/dsa.c ****     int     ret = 0, halfSz = 0;
 994                             		.loc 2 664 13
 995 0030 F8 A6 00                		mov.L	#0, [r10]
 996                             		.loc 2 664 22
 997 0033 F9 A6 01 00             		mov.L	#0, 4[r10]
 665:../src/wolfcrypt/src/dsa.c ****     byte*   tmp;  /* initial output pointer */
 666:../src/wolfcrypt/src/dsa.c **** 
 667:../src/wolfcrypt/src/dsa.c ****     if (digest == NULL || out == NULL || key == NULL || rng == NULL)
 998                             		.loc 2 667 8
 999 0037 ED A5 14                		mov.L	80[r10], r5
 1000 003a 61 05                   		cmp	#0, r5
 1001 003c 20 15                   		beq	.L70
 1002                             		.loc 2 667 24 discriminator 1
 1003 003e ED A5 15                		mov.L	84[r10], r5
 1004 0041 61 05                   		cmp	#0, r5
 1005 0043 20 0E                   		beq	.L70
 1006                             		.loc 2 667 39 discriminator 2
 1007 0045 ED A5 16                		mov.L	88[r10], r5
 1008 0048 61 05                   		cmp	#0, r5
 1009 004a 17                      		beq	.L70
 1010                             		.loc 2 667 54 discriminator 3
 1011 004b ED A5 17                		mov.L	92[r10], r5
 1012 004e 61 05                   		cmp	#0, r5
 1013 0050 18                      		bne	.L71
 1014                             		.balign 8,3,2
 1015                             	.L70:
 668:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 1016                             		.loc 2 668 16
 1017 0051 FB 5A 53 FF             		mov.L	#-173, r5
 1018 0055 38 D1 04                		bra	.L72
 1019                             	.L71:
 669:../src/wolfcrypt/src/dsa.c **** 
 670:../src/wolfcrypt/src/dsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
 671:../src/wolfcrypt/src/dsa.c **** 
 672:../src/wolfcrypt/src/dsa.c ****     do {
 673:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 674:../src/wolfcrypt/src/dsa.c ****         k = (mp_int *)XMALLOC(sizeof *k, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1020                             		.loc 2 674 23
 1021 0058 FB 1A 10 03             		mov.L	#0x310, r1
 1022 005c 05 00 00 00             		bsr	_wolfSSL_Malloc
 1023 0060 E7 A1 04                		mov.L	r1, 16[r10]
 675:../src/wolfcrypt/src/dsa.c ****         kInv = (mp_int *)XMALLOC(sizeof *kInv, key->heap,
 1024                             		.loc 2 675 26
 1025 0063 FB 1A 10 03             		mov.L	#0x310, r1
 1026 0067 05 00 00 00             		bsr	_wolfSSL_Malloc
 1027 006b E7 A1 05                		mov.L	r1, 20[r10]
 676:../src/wolfcrypt/src/dsa.c ****                                  DYNAMIC_TYPE_TMP_BUFFER);
 677:../src/wolfcrypt/src/dsa.c ****         r = (mp_int *)XMALLOC(sizeof *r, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1028                             		.loc 2 677 23
 1029 006e FB 1A 10 03             		mov.L	#0x310, r1
 1030 0072 05 00 00 00             		bsr	_wolfSSL_Malloc
 1031 0076 E7 A1 06                		mov.L	r1, 24[r10]
 678:../src/wolfcrypt/src/dsa.c ****         s = (mp_int *)XMALLOC(sizeof *s, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1032                             		.loc 2 678 23
 1033 0079 FB 1A 10 03             		mov.L	#0x310, r1
 1034 007d 05 00 00 00             		bsr	_wolfSSL_Malloc
 1035 0081 E7 A1 07                		mov.L	r1, 28[r10]
 679:../src/wolfcrypt/src/dsa.c ****         H = (mp_int *)XMALLOC(sizeof *H, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1036                             		.loc 2 679 23
 1037 0084 FB 1A 10 03             		mov.L	#0x310, r1
 1038 0088 05 00 00 00             		bsr	_wolfSSL_Malloc
 1039 008c E7 A1 08                		mov.L	r1, 32[r10]
 680:../src/wolfcrypt/src/dsa.c **** #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME
 681:../src/wolfcrypt/src/dsa.c ****         b = (mp_int *)XMALLOC(sizeof *b, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1040                             		.loc 2 681 23
 1041 008f FB 1A 10 03             		mov.L	#0x310, r1
 1042 0093 05 00 00 00             		bsr	_wolfSSL_Malloc
 1043 0097 E7 A1 09                		mov.L	r1, 36[r10]
 682:../src/wolfcrypt/src/dsa.c **** #endif
 683:../src/wolfcrypt/src/dsa.c ****         buffer = (byte *)XMALLOC(DSA_MAX_HALF_SIZE, key->heap,
 1044                             		.loc 2 683 26
 1045 009a 75 41 20                		mov.L	#32, r1
 1046 009d 05 00 00 00             		bsr	_wolfSSL_Malloc
 1047 00a1 E7 A1 0A                		mov.L	r1, 40[r10]
 684:../src/wolfcrypt/src/dsa.c ****                                  DYNAMIC_TYPE_TMP_BUFFER);
 685:../src/wolfcrypt/src/dsa.c **** 
 686:../src/wolfcrypt/src/dsa.c ****         if ((k == NULL) ||
 1048                             		.loc 2 686 12
 1049 00a4 ED A5 04                		mov.L	16[r10], r5
 1050 00a7 61 05                   		cmp	#0, r5
 1051 00a9 20 2F                   		beq	.L73
 1052                             		.loc 2 686 25 discriminator 1
 1053 00ab ED A5 05                		mov.L	20[r10], r5
 1054 00ae 61 05                   		cmp	#0, r5
 1055 00b0 20 28                   		beq	.L73
 687:../src/wolfcrypt/src/dsa.c ****             (kInv == NULL) ||
 1056                             		.loc 2 687 28
 1057 00b2 ED A5 06                		mov.L	24[r10], r5
 1058 00b5 61 05                   		cmp	#0, r5
 1059 00b7 20 21                   		beq	.L73
 688:../src/wolfcrypt/src/dsa.c ****             (r == NULL) ||
 1060                             		.loc 2 688 25
 1061 00b9 ED A5 07                		mov.L	28[r10], r5
 1062 00bc 61 05                   		cmp	#0, r5
 1063 00be 20 1A                   		beq	.L73
 689:../src/wolfcrypt/src/dsa.c ****             (s == NULL) ||
 1064                             		.loc 2 689 25
 1065 00c0 ED A5 08                		mov.L	32[r10], r5
 1066 00c3 61 05                   		cmp	#0, r5
 1067 00c5 20 13                   		beq	.L73
 690:../src/wolfcrypt/src/dsa.c ****             (H == NULL)
 691:../src/wolfcrypt/src/dsa.c **** #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME
 692:../src/wolfcrypt/src/dsa.c ****             || (b == NULL)
 1068                             		.loc 2 692 13
 1069 00c7 ED A5 09                		mov.L	36[r10], r5
 1070 00ca 61 05                   		cmp	#0, r5
 1071 00cc 20 0C                   		beq	.L73
 693:../src/wolfcrypt/src/dsa.c **** #endif
 694:../src/wolfcrypt/src/dsa.c ****             || (buffer == NULL)) {
 1072                             		.loc 2 694 13
 1073 00ce ED A5 0A                		mov.L	40[r10], r5
 1074 00d1 61 05                   		cmp	#0, r5
 1075 00d3 21 0B                   		bne	.L74
 1076 00d5 FC 13 00                		.balign 8,3,4
 1077                             	.L73:
 695:../src/wolfcrypt/src/dsa.c ****             ret = MEMORY_E;
 1078                             		.loc 2 695 17
 1079 00d8 F8 A6 83                		mov.L	#-125, [r10]
 696:../src/wolfcrypt/src/dsa.c ****             break;
 1080                             		.loc 2 696 13
 1081 00db 38 39 03                		bra	.L75
 1082                             	.L74:
 697:../src/wolfcrypt/src/dsa.c ****         }
 698:../src/wolfcrypt/src/dsa.c **** #endif
 699:../src/wolfcrypt/src/dsa.c **** 
 700:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_MP_INVMOD_CONSTANT_TIME
 701:../src/wolfcrypt/src/dsa.c ****         if (mp_init_multi(k, kInv, r, s, H, 0) != MP_OKAY)
 702:../src/wolfcrypt/src/dsa.c **** #else
 703:../src/wolfcrypt/src/dsa.c ****             if (mp_init_multi(k, kInv, r, s, H, b) != MP_OKAY)
 1083                             		.loc 2 703 17
 1084 00de ED A5 09                		mov.L	36[r10], r5
 1085 00e1 A0 0D                   		mov.L	r5, 4[r0]
 1086 00e3 ED A5 08                		mov.L	32[r10], r5
 1087 00e6 E3 05                   		mov.L	r5, [r0]
 1088 00e8 ED A4 07                		mov.L	28[r10], r4
 1089 00eb ED A3 06                		mov.L	24[r10], r3
 1090 00ee ED A2 05                		mov.L	20[r10], r2
 1091 00f1 ED A1 04                		mov.L	16[r10], r1
 1092 00f4 05 00 00 00             		bsr	_sp_init_multi
 1093 00f8 EF 15                   		mov.L	r1, r5
 1094                             		.loc 2 703 16
 1095 00fa 61 05                   		cmp	#0, r5
 1096 00fc 17                      		beq	.L76
 704:../src/wolfcrypt/src/dsa.c **** #endif
 705:../src/wolfcrypt/src/dsa.c ****                 {
 706:../src/wolfcrypt/src/dsa.c ****                     ret = MP_INIT_E;
 1097                             		.loc 2 706 25
 1098 00fd F8 A6 92                		mov.L	#-110, [r10]
 707:../src/wolfcrypt/src/dsa.c ****                     break;
 1099                             		.loc 2 707 21
 1100 0100 38 14 03                		bra	.L75
 1101                             	.L76:
 708:../src/wolfcrypt/src/dsa.c ****                 }
 709:../src/wolfcrypt/src/dsa.c **** 
 710:../src/wolfcrypt/src/dsa.c ****         halfSz = min(DSA_MAX_HALF_SIZE, mp_unsigned_bin_size(&key->q));
 1102                             		.loc 2 710 62
 1103 0103 ED A5 16                		mov.L	88[r10], r5
 1104 0106 72 55 10 03             		add	#0x310, r5
 1105                             		.loc 2 710 41
 1106 010a EF 51                   		mov.L	r5, r1
 1107 010c 05 00 00 00             		bsr	_sp_unsigned_bin_size
 1108 0110 EF 15                   		mov.L	r1, r5
 1109                             		.loc 2 710 18
 1110 0112 EF 52                   		mov.L	r5, r2
 1111 0114 75 41 20                		mov.L	#32, r1
 1112 0117 05 00 00 00             		bsr	_min
 1113 011b EF 15                   		mov.L	r1, r5
 1114                             		.loc 2 710 16
 1115 011d E7 A5 01                		mov.L	r5, 4[r10]
 711:../src/wolfcrypt/src/dsa.c ****         /* NIST FIPS 186-4: Sections 4.1
 712:../src/wolfcrypt/src/dsa.c ****          * q is a prime divisor where 2^(N-1) < q < 2^N and N is the bit length
 713:../src/wolfcrypt/src/dsa.c ****          * of q.
 714:../src/wolfcrypt/src/dsa.c ****          * To satisfy this constraint if N is 0 then q would still need to be
 715:../src/wolfcrypt/src/dsa.c ****          * larger than 0.5, but since there is 0 bits in q it can not be any
 716:../src/wolfcrypt/src/dsa.c ****          * value.
 717:../src/wolfcrypt/src/dsa.c ****          */
 718:../src/wolfcrypt/src/dsa.c ****         if (halfSz == 0) {
 1116                             		.loc 2 718 12
 1117 0120 ED A5 01                		mov.L	4[r10], r5
 1118 0123 61 05                   		cmp	#0, r5
 1119 0125 18                      		bne	.L77
 719:../src/wolfcrypt/src/dsa.c ****             ret = BAD_FUNC_ARG;
 1120                             		.loc 2 719 17
 1121 0126 F8 AA 53 FF             		mov.L	#-173, [r10]
 720:../src/wolfcrypt/src/dsa.c ****             break;
 1122                             		.loc 2 720 13
 1123 012a 38 EA 02                		bra	.L75
 1124                             	.L77:
 721:../src/wolfcrypt/src/dsa.c ****         }
 722:../src/wolfcrypt/src/dsa.c **** 
 723:../src/wolfcrypt/src/dsa.c ****         tmp = out;
 1125                             		.loc 2 723 13
 1126 012d ED A5 15                		mov.L	84[r10], r5
 1127 0130 E7 A5 0B                		mov.L	r5, 44[r10]
 724:../src/wolfcrypt/src/dsa.c ****         qMinus1 = kInv;
 1128                             		.loc 2 724 17
 1129 0133 ED A5 05                		mov.L	20[r10], r5
 1130 0136 E7 A5 0C                		mov.L	r5, 48[r10]
 725:../src/wolfcrypt/src/dsa.c **** 
 726:../src/wolfcrypt/src/dsa.c ****         /* NIST FIPS 186-4: B.2.2
 727:../src/wolfcrypt/src/dsa.c ****          * Per-Message Secret Number Generation by Testing Candidates
 728:../src/wolfcrypt/src/dsa.c ****          * Generate k in range [1, q-1].
 729:../src/wolfcrypt/src/dsa.c ****          *   Check that k is less than q-1: range [0, q-2].
 730:../src/wolfcrypt/src/dsa.c ****          *   Add 1 to k: range [1, q-1].
 731:../src/wolfcrypt/src/dsa.c ****          */
 732:../src/wolfcrypt/src/dsa.c ****         if (mp_sub_d(&key->q, 1, qMinus1)) {
 1131                             		.loc 2 732 22
 1132 0139 ED A5 16                		mov.L	88[r10], r5
 1133 013c 72 55 10 03             		add	#0x310, r5
 1134                             		.loc 2 732 13
 1135 0140 ED A3 0C                		mov.L	48[r10], r3
 1136 0143 66 12                   		mov.L	#1, r2
 1137 0145 EF 51                   		mov.L	r5, r1
 1138 0147 05 00 00 00             		bsr	_sp_sub_d
 1139 014b EF 15                   		mov.L	r1, r5
 1140                             		.loc 2 732 12
 1141 014d 61 05                   		cmp	#0, r5
 1142 014f 17                      		beq	.L78
 733:../src/wolfcrypt/src/dsa.c ****             ret = MP_SUB_E;
 1143                             		.loc 2 733 17
 1144 0150 F8 A6 8E                		mov.L	#-114, [r10]
 734:../src/wolfcrypt/src/dsa.c ****             break;
 1145                             		.loc 2 734 13
 1146 0153 38 C1 02                		bra	.L75
 1147                             	.L78:
 735:../src/wolfcrypt/src/dsa.c ****         }
 736:../src/wolfcrypt/src/dsa.c **** 
 737:../src/wolfcrypt/src/dsa.c ****         /* if q-1 is 0 or smaller, k will never end up being less than it */
 738:../src/wolfcrypt/src/dsa.c ****         if (mp_iszero(qMinus1) || mp_isneg(qMinus1)) {
 1148                             		.loc 2 738 13
 1149 0156 ED A5 0C                		mov.L	48[r10], r5
 1150 0159 EC 55                   		mov.L	[r5], r5
 1151                             		.loc 2 738 12
 1152 015b 61 05                   		cmp	#0, r5
 1153 015d 18                      		bne	.L79
 739:../src/wolfcrypt/src/dsa.c ****             ret = BAD_FUNC_ARG;
 1154                             		.loc 2 739 17
 1155 015e F8 AA 53 FF             		mov.L	#-173, [r10]
 740:../src/wolfcrypt/src/dsa.c ****             break;
 1156                             		.loc 2 740 13
 1157 0162 38 B2 02                		bra	.L75
 1158                             	.L79:
 741:../src/wolfcrypt/src/dsa.c ****         }
 742:../src/wolfcrypt/src/dsa.c **** 
 743:../src/wolfcrypt/src/dsa.c ****         do {
 744:../src/wolfcrypt/src/dsa.c ****             /* Step 4: generate k */
 745:../src/wolfcrypt/src/dsa.c ****             if ((ret = wc_RNG_GenerateBlock(rng, buffer, halfSz))) {
 1159                             		.loc 2 745 24
 1160 0165 ED A5 01                		mov.L	4[r10], r5
 1161 0168 EF 53                   		mov.L	r5, r3
 1162 016a ED A2 0A                		mov.L	40[r10], r2
 1163 016d ED A1 17                		mov.L	92[r10], r1
 1164 0170 05 00 00 00             		bsr	_wc_RNG_GenerateBlock
 1165 0174 E3 A1                   		mov.L	r1, [r10]
 1166                             		.loc 2 745 16
 1167 0176 EC A5                   		mov.L	[r10], r5
 1168 0178 61 05                   		cmp	#0, r5
 1169 017a 21 2E                   		bne	.L121
 746:../src/wolfcrypt/src/dsa.c ****                 break;
 747:../src/wolfcrypt/src/dsa.c ****             }
 748:../src/wolfcrypt/src/dsa.c **** 
 749:../src/wolfcrypt/src/dsa.c ****             /* Step 5 */
 750:../src/wolfcrypt/src/dsa.c ****             if (mp_read_unsigned_bin(k, buffer, halfSz) != MP_OKAY) {
 1170                             		.loc 2 750 17
 1171 017c ED A5 01                		mov.L	4[r10], r5
 1172 017f EF 53                   		mov.L	r5, r3
 1173 0181 ED A2 0A                		mov.L	40[r10], r2
 1174 0184 ED A1 04                		mov.L	16[r10], r1
 1175 0187 05 00 00 00             		bsr	_sp_read_unsigned_bin
 1176 018b EF 15                   		mov.L	r1, r5
 1177                             		.loc 2 750 16
 1178 018d 61 05                   		cmp	#0, r5
 1179 018f 16                      		beq	.L82
 751:../src/wolfcrypt/src/dsa.c ****                 ret = MP_READ_E;
 1180                             		.loc 2 751 21
 1181 0190 F8 A6 91                		mov.L	#-111, [r10]
 752:../src/wolfcrypt/src/dsa.c ****                 break;
 1182                             		.loc 2 752 17
 1183 0193 2E 16                   		bra	.L81
 1184                             	.L82:
 753:../src/wolfcrypt/src/dsa.c ****             }
 754:../src/wolfcrypt/src/dsa.c **** 
 755:../src/wolfcrypt/src/dsa.c ****             /* k is a random numnber and it should be less than q-1
 756:../src/wolfcrypt/src/dsa.c ****              * if k greater than repeat
 757:../src/wolfcrypt/src/dsa.c ****              */
 758:../src/wolfcrypt/src/dsa.c ****             /* Step 6 */
 759:../src/wolfcrypt/src/dsa.c ****         } while (mp_cmp(k, qMinus1) != MP_LT);
 1185                             		.loc 2 759 18
 1186 0195 ED A2 0C                		mov.L	48[r10], r2
 1187 0198 ED A1 04                		mov.L	16[r10], r1
 1188 019b 05 00 00 00             		bsr	_sp_cmp
 1189 019f EF 15                   		mov.L	r1, r5
 1190                             		.loc 2 759 9
 1191 01a1 75 05 FF                		cmp	#-1, r5
 1192 01a4 21 C1                   		bne	.L79
 1193 01a6 2E 03                   		bra	.L81
 1194                             	.L121:
 746:../src/wolfcrypt/src/dsa.c ****             }
 1195                             		.loc 2 746 17
 1196 01a8 03                      		nop
 1197                             	.L81:
 760:../src/wolfcrypt/src/dsa.c **** 
 761:../src/wolfcrypt/src/dsa.c ****         if (ret != 0)
 1198                             		.loc 2 761 12
 1199 01a9 EC A5                   		mov.L	[r10], r5
 1200 01ab 61 05                   		cmp	#0, r5
 1201 01ad 3B 63 02                		bne	.L122
 762:../src/wolfcrypt/src/dsa.c ****             break;
 763:../src/wolfcrypt/src/dsa.c **** 
 764:../src/wolfcrypt/src/dsa.c ****         /* Step 7 */
 765:../src/wolfcrypt/src/dsa.c ****         if (mp_add_d(k, 1, k) != MP_OKAY) {
 1202                             		.loc 2 765 13
 1203 01b0 ED A3 04                		mov.L	16[r10], r3
 1204 01b3 66 12                   		mov.L	#1, r2
 1205 01b5 ED A1 04                		mov.L	16[r10], r1
 1206 01b8 05 00 00 00             		bsr	_sp_add_d
 1207 01bc EF 15                   		mov.L	r1, r5
 1208                             		.loc 2 765 12
 1209 01be 61 05                   		cmp	#0, r5
 1210 01c0 17                      		beq	.L84
 766:../src/wolfcrypt/src/dsa.c ****             ret = MP_MOD_E;
 1211                             		.loc 2 766 17
 1212 01c1 F8 A6 8A                		mov.L	#-118, [r10]
 767:../src/wolfcrypt/src/dsa.c ****             break;
 1213                             		.loc 2 767 13
 1214 01c4 38 50 02                		bra	.L75
 1215                             	.L84:
 768:../src/wolfcrypt/src/dsa.c ****         }
 769:../src/wolfcrypt/src/dsa.c **** 
 770:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_MP_INVMOD_CONSTANT_TIME
 771:../src/wolfcrypt/src/dsa.c ****         /* inverse k mod q */
 772:../src/wolfcrypt/src/dsa.c ****         if (mp_invmod(k, &key->q, kInv) != MP_OKAY) {
 773:../src/wolfcrypt/src/dsa.c ****             ret = MP_INVMOD_E;
 774:../src/wolfcrypt/src/dsa.c ****             break;
 775:../src/wolfcrypt/src/dsa.c ****         }
 776:../src/wolfcrypt/src/dsa.c **** 
 777:../src/wolfcrypt/src/dsa.c ****         /* generate r, r = (g exp k mod p) mod q */
 778:../src/wolfcrypt/src/dsa.c ****         if (mp_exptmod_ex(&key->g, k, key->q.used, &key->p, r) != MP_OKAY) {
 779:../src/wolfcrypt/src/dsa.c ****             ret = MP_EXPTMOD_E;
 780:../src/wolfcrypt/src/dsa.c ****             break;
 781:../src/wolfcrypt/src/dsa.c ****         }
 782:../src/wolfcrypt/src/dsa.c **** 
 783:../src/wolfcrypt/src/dsa.c ****         if (mp_mod(r, &key->q, r) != MP_OKAY) {
 784:../src/wolfcrypt/src/dsa.c ****             ret = MP_MOD_E;
 785:../src/wolfcrypt/src/dsa.c ****             break;
 786:../src/wolfcrypt/src/dsa.c ****         }
 787:../src/wolfcrypt/src/dsa.c **** 
 788:../src/wolfcrypt/src/dsa.c ****         /* generate H from sha digest */
 789:../src/wolfcrypt/src/dsa.c ****         if (mp_read_unsigned_bin(H, digest,WC_SHA_DIGEST_SIZE) != MP_OKAY) {
 790:../src/wolfcrypt/src/dsa.c ****             ret = MP_READ_E;
 791:../src/wolfcrypt/src/dsa.c ****             break;
 792:../src/wolfcrypt/src/dsa.c ****         }
 793:../src/wolfcrypt/src/dsa.c **** 
 794:../src/wolfcrypt/src/dsa.c ****         /* generate s, s = (kInv * (H + x*r)) % q */
 795:../src/wolfcrypt/src/dsa.c ****         if (mp_mul(&key->x, r, s) != MP_OKAY) {
 796:../src/wolfcrypt/src/dsa.c ****             ret = MP_MUL_E;
 797:../src/wolfcrypt/src/dsa.c ****             break;
 798:../src/wolfcrypt/src/dsa.c ****         }
 799:../src/wolfcrypt/src/dsa.c **** 
 800:../src/wolfcrypt/src/dsa.c ****         if (mp_add(s, H, s) != MP_OKAY) {
 801:../src/wolfcrypt/src/dsa.c ****             ret = MP_ADD_E;
 802:../src/wolfcrypt/src/dsa.c ****             break;
 803:../src/wolfcrypt/src/dsa.c ****         }
 804:../src/wolfcrypt/src/dsa.c **** 
 805:../src/wolfcrypt/src/dsa.c ****         if (mp_mulmod(s, kInv, &key->q, s) != MP_OKAY) {
 806:../src/wolfcrypt/src/dsa.c ****             ret = MP_MULMOD_E;
 807:../src/wolfcrypt/src/dsa.c ****             break;
 808:../src/wolfcrypt/src/dsa.c ****         }
 809:../src/wolfcrypt/src/dsa.c **** #else
 810:../src/wolfcrypt/src/dsa.c ****         /* Blinding value
 811:../src/wolfcrypt/src/dsa.c ****          * Generate b in range [1, q-1].
 812:../src/wolfcrypt/src/dsa.c ****          */
 813:../src/wolfcrypt/src/dsa.c ****         do {
 814:../src/wolfcrypt/src/dsa.c ****             if ((ret = wc_RNG_GenerateBlock(rng, buffer, halfSz))) {
 1216                             		.loc 2 814 24
 1217 01c7 ED A5 01                		mov.L	4[r10], r5
 1218 01ca EF 53                   		mov.L	r5, r3
 1219 01cc ED A2 0A                		mov.L	40[r10], r2
 1220 01cf ED A1 17                		mov.L	92[r10], r1
 1221 01d2 05 00 00 00             		bsr	_wc_RNG_GenerateBlock
 1222 01d6 E3 A1                   		mov.L	r1, [r10]
 1223                             		.loc 2 814 16
 1224 01d8 EC A5                   		mov.L	[r10], r5
 1225 01da 61 05                   		cmp	#0, r5
 1226 01dc 21 2E                   		bne	.L123
 815:../src/wolfcrypt/src/dsa.c ****                 break;
 816:../src/wolfcrypt/src/dsa.c ****             }
 817:../src/wolfcrypt/src/dsa.c ****             if (mp_read_unsigned_bin(b, buffer, halfSz) != MP_OKAY) {
 1227                             		.loc 2 817 17
 1228 01de ED A5 01                		mov.L	4[r10], r5
 1229 01e1 EF 53                   		mov.L	r5, r3
 1230 01e3 ED A2 0A                		mov.L	40[r10], r2
 1231 01e6 ED A1 09                		mov.L	36[r10], r1
 1232 01e9 05 00 00 00             		bsr	_sp_read_unsigned_bin
 1233 01ed EF 15                   		mov.L	r1, r5
 1234                             		.loc 2 817 16
 1235 01ef 61 05                   		cmp	#0, r5
 1236 01f1 16                      		beq	.L87
 818:../src/wolfcrypt/src/dsa.c ****                 ret = MP_READ_E;
 1237                             		.loc 2 818 21
 1238 01f2 F8 A6 91                		mov.L	#-111, [r10]
 819:../src/wolfcrypt/src/dsa.c ****                 break;
 1239                             		.loc 2 819 17
 1240 01f5 2E 16                   		bra	.L86
 1241                             	.L87:
 820:../src/wolfcrypt/src/dsa.c ****             }
 821:../src/wolfcrypt/src/dsa.c ****         } while (mp_cmp(b, qMinus1) != MP_LT);
 1242                             		.loc 2 821 18
 1243 01f7 ED A2 0C                		mov.L	48[r10], r2
 1244 01fa ED A1 09                		mov.L	36[r10], r1
 1245 01fd 05 00 00 00             		bsr	_sp_cmp
 1246 0201 EF 15                   		mov.L	r1, r5
 1247                             		.loc 2 821 9
 1248 0203 75 05 FF                		cmp	#-1, r5
 1249 0206 21 C1                   		bne	.L84
 1250 0208 2E 03                   		bra	.L86
 1251                             	.L123:
 815:../src/wolfcrypt/src/dsa.c ****             }
 1252                             		.loc 2 815 17
 1253 020a 03                      		nop
 1254                             	.L86:
 822:../src/wolfcrypt/src/dsa.c **** 
 823:../src/wolfcrypt/src/dsa.c ****         if (ret != 0)
 1255                             		.loc 2 823 12
 1256 020b EC A5                   		mov.L	[r10], r5
 1257 020d 61 05                   		cmp	#0, r5
 1258 020f 3B 04 02                		bne	.L124
 824:../src/wolfcrypt/src/dsa.c ****             break;
 825:../src/wolfcrypt/src/dsa.c **** 
 826:../src/wolfcrypt/src/dsa.c ****         if (mp_add_d(b, 1, b) != MP_OKAY) {
 1259                             		.loc 2 826 13
 1260 0212 ED A3 09                		mov.L	36[r10], r3
 1261 0215 66 12                   		mov.L	#1, r2
 1262 0217 ED A1 09                		mov.L	36[r10], r1
 1263 021a 05 00 00 00             		bsr	_sp_add_d
 1264 021e EF 15                   		mov.L	r1, r5
 1265                             		.loc 2 826 12
 1266 0220 61 05                   		cmp	#0, r5
 1267 0222 17                      		beq	.L89
 827:../src/wolfcrypt/src/dsa.c ****             ret = MP_MOD_E;
 1268                             		.loc 2 827 17
 1269 0223 F8 A6 8A                		mov.L	#-118, [r10]
 828:../src/wolfcrypt/src/dsa.c ****             break;
 1270                             		.loc 2 828 13
 1271 0226 38 EE 01                		bra	.L75
 1272                             	.L89:
 829:../src/wolfcrypt/src/dsa.c ****         }
 830:../src/wolfcrypt/src/dsa.c **** 
 831:../src/wolfcrypt/src/dsa.c ****         /* set H from sha digest */
 832:../src/wolfcrypt/src/dsa.c ****         if (mp_read_unsigned_bin(H, digest, WC_SHA_DIGEST_SIZE) != MP_OKAY) {
 1273                             		.loc 2 832 13
 1274 0229 75 43 14                		mov.L	#20, r3
 1275 022c ED A2 14                		mov.L	80[r10], r2
 1276 022f ED A1 08                		mov.L	32[r10], r1
 1277 0232 05 00 00 00             		bsr	_sp_read_unsigned_bin
 1278 0236 EF 15                   		mov.L	r1, r5
 1279                             		.loc 2 832 12
 1280 0238 61 05                   		cmp	#0, r5
 1281 023a 17                      		beq	.L90
 833:../src/wolfcrypt/src/dsa.c ****             ret = MP_READ_E;
 1282                             		.loc 2 833 17
 1283 023b F8 A6 91                		mov.L	#-111, [r10]
 834:../src/wolfcrypt/src/dsa.c ****             break;
 1284                             		.loc 2 834 13
 1285 023e 38 D6 01                		bra	.L75
 1286                             	.L90:
 835:../src/wolfcrypt/src/dsa.c ****         }
 836:../src/wolfcrypt/src/dsa.c **** 
 837:../src/wolfcrypt/src/dsa.c ****         /* generate r, r = (g exp k mod p) mod q */
 838:../src/wolfcrypt/src/dsa.c ****         if (mp_exptmod_ex(&key->g, k, key->q.used, &key->p, r) != MP_OKAY) {
 1287                             		.loc 2 838 27
 1288 0241 ED A5 16                		mov.L	88[r10], r5
 1289 0244 72 51 20 06             		add	#0x620, r5, r1
 1290                             		.loc 2 838 13
 1291 0248 ED A5 16                		mov.L	88[r10], r5
 1292 024b ED 55 C4                		mov.L	784[r5], r5
 1293                             		.loc 2 838 52
 1294 024e ED A4 16                		mov.L	88[r10], r4
 1295                             		.loc 2 838 13
 1296 0251 ED A3 06                		mov.L	24[r10], r3
 1297 0254 E3 03                   		mov.L	r3, [r0]
 1298 0256 EF 53                   		mov.L	r5, r3
 1299 0258 ED A2 04                		mov.L	16[r10], r2
 1300 025b 05 00 00 00             		bsr	_sp_exptmod_ex
 1301 025f EF 15                   		mov.L	r1, r5
 1302                             		.loc 2 838 12
 1303 0261 61 05                   		cmp	#0, r5
 1304 0263 17                      		beq	.L91
 839:../src/wolfcrypt/src/dsa.c ****             ret = MP_EXPTMOD_E;
 1305                             		.loc 2 839 17
 1306 0264 F8 A6 90                		mov.L	#-112, [r10]
 840:../src/wolfcrypt/src/dsa.c ****             break;
 1307                             		.loc 2 840 13
 1308 0267 38 AD 01                		bra	.L75
 1309                             	.L91:
 841:../src/wolfcrypt/src/dsa.c ****         }
 842:../src/wolfcrypt/src/dsa.c **** 
 843:../src/wolfcrypt/src/dsa.c ****         /* calculate s = (H + xr)/k = b.(H/k.b + x.r/k.b) */
 844:../src/wolfcrypt/src/dsa.c **** 
 845:../src/wolfcrypt/src/dsa.c ****         /* k = k.b */
 846:../src/wolfcrypt/src/dsa.c ****         if (mp_mulmod(k, b, &key->q, k) != MP_OKAY) {
 1310                             		.loc 2 846 29
 1311 026a ED A5 16                		mov.L	88[r10], r5
 1312 026d 72 55 10 03             		add	#0x310, r5
 1313                             		.loc 2 846 13
 1314 0271 ED A4 04                		mov.L	16[r10], r4
 1315 0274 EF 53                   		mov.L	r5, r3
 1316 0276 ED A2 09                		mov.L	36[r10], r2
 1317 0279 ED A1 04                		mov.L	16[r10], r1
 1318 027c 05 00 00 00             		bsr	_sp_mulmod
 1319 0280 EF 15                   		mov.L	r1, r5
 1320                             		.loc 2 846 12
 1321 0282 61 05                   		cmp	#0, r5
 1322 0284 17                      		beq	.L92
 847:../src/wolfcrypt/src/dsa.c ****             ret = MP_MULMOD_E;
 1323                             		.loc 2 847 17
 1324 0285 F8 A6 8B                		mov.L	#-117, [r10]
 848:../src/wolfcrypt/src/dsa.c ****             break;
 1325                             		.loc 2 848 13
 1326 0288 38 8C 01                		bra	.L75
 1327                             	.L92:
 849:../src/wolfcrypt/src/dsa.c ****         }
 850:../src/wolfcrypt/src/dsa.c **** 
 851:../src/wolfcrypt/src/dsa.c ****         /* kInv = 1/k.b mod q */
 852:../src/wolfcrypt/src/dsa.c ****         if (mp_invmod(k, &key->q, kInv) != MP_OKAY) {
 1328                             		.loc 2 852 26
 1329 028b ED A5 16                		mov.L	88[r10], r5
 1330 028e 72 55 10 03             		add	#0x310, r5
 1331                             		.loc 2 852 13
 1332 0292 ED A3 05                		mov.L	20[r10], r3
 1333 0295 EF 52                   		mov.L	r5, r2
 1334 0297 ED A1 04                		mov.L	16[r10], r1
 1335 029a 05 00 00 00             		bsr	_sp_invmod
 1336 029e EF 15                   		mov.L	r1, r5
 1337                             		.loc 2 852 12
 1338 02a0 61 05                   		cmp	#0, r5
 1339 02a2 17                      		beq	.L93
 853:../src/wolfcrypt/src/dsa.c ****             ret = MP_INVMOD_E;
 1340                             		.loc 2 853 17
 1341 02a3 F8 A6 89                		mov.L	#-119, [r10]
 854:../src/wolfcrypt/src/dsa.c ****             break;
 1342                             		.loc 2 854 13
 1343 02a6 38 6E 01                		bra	.L75
 1344                             	.L93:
 855:../src/wolfcrypt/src/dsa.c ****         }
 856:../src/wolfcrypt/src/dsa.c **** 
 857:../src/wolfcrypt/src/dsa.c ****         if (mp_mod(r, &key->q, r) != MP_OKAY) {
 1345                             		.loc 2 857 23
 1346 02a9 ED A5 16                		mov.L	88[r10], r5
 1347 02ac 72 55 10 03             		add	#0x310, r5
 1348                             		.loc 2 857 13
 1349 02b0 ED A3 06                		mov.L	24[r10], r3
 1350 02b3 EF 52                   		mov.L	r5, r2
 1351 02b5 ED A1 06                		mov.L	24[r10], r1
 1352 02b8 05 00 00 00             		bsr	_sp_mod
 1353 02bc EF 15                   		mov.L	r1, r5
 1354                             		.loc 2 857 12
 1355 02be 61 05                   		cmp	#0, r5
 1356 02c0 17                      		beq	.L94
 858:../src/wolfcrypt/src/dsa.c ****             ret = MP_MOD_E;
 1357                             		.loc 2 858 17
 1358 02c1 F8 A6 8A                		mov.L	#-118, [r10]
 859:../src/wolfcrypt/src/dsa.c ****             break;
 1359                             		.loc 2 859 13
 1360 02c4 38 50 01                		bra	.L75
 1361                             	.L94:
 860:../src/wolfcrypt/src/dsa.c ****         }
 861:../src/wolfcrypt/src/dsa.c **** 
 862:../src/wolfcrypt/src/dsa.c ****         /* s = x.r */
 863:../src/wolfcrypt/src/dsa.c ****         if (mp_mul(&key->x, r, s) != MP_OKAY) {
 1362                             		.loc 2 863 20
 1363 02c7 ED A5 16                		mov.L	88[r10], r5
 1364 02ca 72 55 40 0C             		add	#0xc40, r5
 1365                             		.loc 2 863 13
 1366 02ce ED A3 07                		mov.L	28[r10], r3
 1367 02d1 ED A2 06                		mov.L	24[r10], r2
 1368 02d4 EF 51                   		mov.L	r5, r1
 1369 02d6 05 00 00 00             		bsr	_sp_mul
 1370 02da EF 15                   		mov.L	r1, r5
 1371                             		.loc 2 863 12
 1372 02dc 61 05                   		cmp	#0, r5
 1373 02de 17                      		beq	.L95
 864:../src/wolfcrypt/src/dsa.c ****             ret = MP_MUL_E;
 1374                             		.loc 2 864 17
 1375 02df F8 A6 8C                		mov.L	#-116, [r10]
 865:../src/wolfcrypt/src/dsa.c ****             break;
 1376                             		.loc 2 865 13
 1377 02e2 38 32 01                		bra	.L75
 1378                             	.L95:
 866:../src/wolfcrypt/src/dsa.c ****         }
 867:../src/wolfcrypt/src/dsa.c **** 
 868:../src/wolfcrypt/src/dsa.c ****         /* s = x.r/k.b */
 869:../src/wolfcrypt/src/dsa.c ****         if (mp_mulmod(s, kInv, &key->q, s) != MP_OKAY) {
 1379                             		.loc 2 869 32
 1380 02e5 ED A5 16                		mov.L	88[r10], r5
 1381 02e8 72 55 10 03             		add	#0x310, r5
 1382                             		.loc 2 869 13
 1383 02ec ED A4 07                		mov.L	28[r10], r4
 1384 02ef EF 53                   		mov.L	r5, r3
 1385 02f1 ED A2 05                		mov.L	20[r10], r2
 1386 02f4 ED A1 07                		mov.L	28[r10], r1
 1387 02f7 05 00 00 00             		bsr	_sp_mulmod
 1388 02fb EF 15                   		mov.L	r1, r5
 1389                             		.loc 2 869 12
 1390 02fd 61 05                   		cmp	#0, r5
 1391 02ff 17                      		beq	.L96
 870:../src/wolfcrypt/src/dsa.c ****             ret = MP_MULMOD_E;
 1392                             		.loc 2 870 17
 1393 0300 F8 A6 8B                		mov.L	#-117, [r10]
 871:../src/wolfcrypt/src/dsa.c ****             break;
 1394                             		.loc 2 871 13
 1395 0303 38 11 01                		bra	.L75
 1396                             	.L96:
 872:../src/wolfcrypt/src/dsa.c ****         }
 873:../src/wolfcrypt/src/dsa.c **** 
 874:../src/wolfcrypt/src/dsa.c ****         /* H = H/k.b */
 875:../src/wolfcrypt/src/dsa.c ****         if (mp_mulmod(H, kInv, &key->q, H) != MP_OKAY) {
 1397                             		.loc 2 875 32
 1398 0306 ED A5 16                		mov.L	88[r10], r5
 1399 0309 72 55 10 03             		add	#0x310, r5
 1400                             		.loc 2 875 13
 1401 030d ED A4 08                		mov.L	32[r10], r4
 1402 0310 EF 53                   		mov.L	r5, r3
 1403 0312 ED A2 05                		mov.L	20[r10], r2
 1404 0315 ED A1 08                		mov.L	32[r10], r1
 1405 0318 05 00 00 00             		bsr	_sp_mulmod
 1406 031c EF 15                   		mov.L	r1, r5
 1407                             		.loc 2 875 12
 1408 031e 61 05                   		cmp	#0, r5
 1409 0320 17                      		beq	.L97
 876:../src/wolfcrypt/src/dsa.c ****             ret = MP_MULMOD_E;
 1410                             		.loc 2 876 17
 1411 0321 F8 A6 8B                		mov.L	#-117, [r10]
 877:../src/wolfcrypt/src/dsa.c ****             break;
 1412                             		.loc 2 877 13
 1413 0324 38 F0 00                		bra	.L75
 1414                             	.L97:
 878:../src/wolfcrypt/src/dsa.c ****         }
 879:../src/wolfcrypt/src/dsa.c **** 
 880:../src/wolfcrypt/src/dsa.c ****         /* s = H/k.b + x.r/k.b = (H + x.r)/k.b */
 881:../src/wolfcrypt/src/dsa.c ****         if (mp_add(s, H, s) != MP_OKAY) {
 1415                             		.loc 2 881 13
 1416 0327 ED A3 07                		mov.L	28[r10], r3
 1417 032a ED A2 08                		mov.L	32[r10], r2
 1418 032d ED A1 07                		mov.L	28[r10], r1
 1419 0330 05 00 00 00             		bsr	_sp_add
 1420 0334 EF 15                   		mov.L	r1, r5
 1421                             		.loc 2 881 12
 1422 0336 61 05                   		cmp	#0, r5
 1423 0338 17                      		beq	.L98
 882:../src/wolfcrypt/src/dsa.c ****             ret = MP_ADD_E;
 1424                             		.loc 2 882 17
 1425 0339 F8 A6 8D                		mov.L	#-115, [r10]
 883:../src/wolfcrypt/src/dsa.c ****             break;
 1426                             		.loc 2 883 13
 1427 033c 38 D8 00                		bra	.L75
 1428                             	.L98:
 884:../src/wolfcrypt/src/dsa.c ****         }
 885:../src/wolfcrypt/src/dsa.c **** 
 886:../src/wolfcrypt/src/dsa.c ****         /* s = b.(e + x.r)/k.b = (e + x.r)/k */
 887:../src/wolfcrypt/src/dsa.c ****         if (mp_mulmod(s, b, &key->q, s) != MP_OKAY) {
 1429                             		.loc 2 887 29
 1430 033f ED A5 16                		mov.L	88[r10], r5
 1431 0342 72 55 10 03             		add	#0x310, r5
 1432                             		.loc 2 887 13
 1433 0346 ED A4 07                		mov.L	28[r10], r4
 1434 0349 EF 53                   		mov.L	r5, r3
 1435 034b ED A2 09                		mov.L	36[r10], r2
 1436 034e ED A1 07                		mov.L	28[r10], r1
 1437 0351 05 00 00 00             		bsr	_sp_mulmod
 1438 0355 EF 15                   		mov.L	r1, r5
 1439                             		.loc 2 887 12
 1440 0357 61 05                   		cmp	#0, r5
 1441 0359 17                      		beq	.L99
 888:../src/wolfcrypt/src/dsa.c ****             ret = MP_MULMOD_E;
 1442                             		.loc 2 888 17
 1443 035a F8 A6 8B                		mov.L	#-117, [r10]
 889:../src/wolfcrypt/src/dsa.c ****             break;
 1444                             		.loc 2 889 13
 1445 035d 38 B7 00                		bra	.L75
 1446                             	.L99:
 890:../src/wolfcrypt/src/dsa.c ****         }
 891:../src/wolfcrypt/src/dsa.c **** 
 892:../src/wolfcrypt/src/dsa.c ****         /* s = (e + x.r)/k */
 893:../src/wolfcrypt/src/dsa.c ****         if (mp_mod(s, &key->q, s) != MP_OKAY) {
 1447                             		.loc 2 893 23
 1448 0360 ED A5 16                		mov.L	88[r10], r5
 1449 0363 72 55 10 03             		add	#0x310, r5
 1450                             		.loc 2 893 13
 1451 0367 ED A3 07                		mov.L	28[r10], r3
 1452 036a EF 52                   		mov.L	r5, r2
 1453 036c ED A1 07                		mov.L	28[r10], r1
 1454 036f 05 00 00 00             		bsr	_sp_mod
 1455 0373 EF 15                   		mov.L	r1, r5
 1456                             		.loc 2 893 12
 1457 0375 61 05                   		cmp	#0, r5
 1458 0377 17                      		beq	.L100
 894:../src/wolfcrypt/src/dsa.c ****             ret = MP_MOD_E;
 1459                             		.loc 2 894 17
 1460 0378 F8 A6 8A                		mov.L	#-118, [r10]
 895:../src/wolfcrypt/src/dsa.c ****             break;
 1461                             		.loc 2 895 13
 1462 037b 38 99 00                		bra	.L75
 1463                             	.L100:
 896:../src/wolfcrypt/src/dsa.c ****         }
 897:../src/wolfcrypt/src/dsa.c **** #endif
 898:../src/wolfcrypt/src/dsa.c **** 
 899:../src/wolfcrypt/src/dsa.c ****         /* detect zero r or s */
 900:../src/wolfcrypt/src/dsa.c ****         if ((mp_iszero(r) == MP_YES) || (mp_iszero(s) == MP_YES)) {
 1464                             		.loc 2 900 14
 1465 037e ED A5 06                		mov.L	24[r10], r5
 1466 0381 EC 55                   		mov.L	[r5], r5
 1467                             		.loc 2 900 12
 1468 0383 61 05                   		cmp	#0, r5
 1469 0385 11                      		beq	.L101
 1470                             		.loc 2 900 42 discriminator 1
 1471 0386 ED A5 07                		mov.L	28[r10], r5
 1472 0389 EC 55                   		mov.L	[r5], r5
 1473                             		.loc 2 900 38 discriminator 1
 1474 038b 61 05                   		cmp	#0, r5
 1475 038d 1F                      		bne	.L102
 1476                             	.L101:
 901:../src/wolfcrypt/src/dsa.c ****             ret = MP_ZERO_E;
 1477                             		.loc 2 901 17
 1478 038e F8 A6 87                		mov.L	#-121, [r10]
 902:../src/wolfcrypt/src/dsa.c ****             break;
 1479                             		.loc 2 902 13
 1480 0391 38 83 00                		bra	.L75
 1481                             	.L102:
 1482                             	.LBB3:
 903:../src/wolfcrypt/src/dsa.c ****         }
 904:../src/wolfcrypt/src/dsa.c **** 
 905:../src/wolfcrypt/src/dsa.c ****         /* write out */
 906:../src/wolfcrypt/src/dsa.c ****         {
 907:../src/wolfcrypt/src/dsa.c ****             int rSz = mp_unsigned_bin_size(r);
 1483                             		.loc 2 907 23
 1484 0394 ED A1 06                		mov.L	24[r10], r1
 1485 0397 05 00 00 00             		bsr	_sp_unsigned_bin_size
 1486 039b E7 A1 02                		mov.L	r1, 8[r10]
 908:../src/wolfcrypt/src/dsa.c ****             int sSz = mp_unsigned_bin_size(s);
 1487                             		.loc 2 908 23
 1488 039e ED A1 07                		mov.L	28[r10], r1
 1489 03a1 05 00 00 00             		bsr	_sp_unsigned_bin_size
 1490 03a5 E7 A1 03                		mov.L	r1, 12[r10]
 909:../src/wolfcrypt/src/dsa.c **** 
 910:../src/wolfcrypt/src/dsa.c ****             while (rSz++ < halfSz) {
 1491                             		.loc 2 910 19
 1492 03a8 2E 0E                   		bra	.L103
 1493                             	.L104:
 911:../src/wolfcrypt/src/dsa.c ****                 *out++ = 0x00;  /* pad front with zeros */
 1494                             		.loc 2 911 21
 1495 03aa ED A5 15                		mov.L	84[r10], r5
 1496 03ad 71 54 01                		add	#1, r5, r4
 1497 03b0 E7 A4 15                		mov.L	r4, 84[r10]
 1498                             		.loc 2 911 24
 1499 03b3 F8 54 00                		mov.B	#0, [r5]
 1500                             	.L103:
 910:../src/wolfcrypt/src/dsa.c ****                 *out++ = 0x00;  /* pad front with zeros */
 1501                             		.loc 2 910 23
 1502 03b6 ED A5 02                		mov.L	8[r10], r5
 1503 03b9 71 54 01                		add	#1, r5, r4
 1504 03bc E7 A4 02                		mov.L	r4, 8[r10]
 910:../src/wolfcrypt/src/dsa.c ****                 *out++ = 0x00;  /* pad front with zeros */
 1505                             		.loc 2 910 19
 1506 03bf ED A4 01                		mov.L	4[r10], r4
 1507 03c2 47 54                   		cmp	r5, r4
 1508 03c4 2A E6                   		bgt	.L104
 912:../src/wolfcrypt/src/dsa.c ****             }
 913:../src/wolfcrypt/src/dsa.c **** 
 914:../src/wolfcrypt/src/dsa.c ****             if (mp_to_unsigned_bin(r, out) != MP_OKAY)
 1509                             		.loc 2 914 17
 1510 03c6 ED A2 15                		mov.L	84[r10], r2
 1511 03c9 ED A1 06                		mov.L	24[r10], r1
 1512 03cc 05 00 00 00             		bsr	_sp_to_unsigned_bin
 1513 03d0 EF 15                   		mov.L	r1, r5
 1514                             		.loc 2 914 16
 1515 03d2 61 05                   		cmp	#0, r5
 1516 03d4 16                      		beq	.L105
 915:../src/wolfcrypt/src/dsa.c ****                 ret = MP_TO_E;
 1517                             		.loc 2 915 21
 1518 03d5 F8 A6 8F                		mov.L	#-113, [r10]
 1519 03d8 2E 3C                   		bra	.L75
 1520                             	.L105:
 916:../src/wolfcrypt/src/dsa.c ****             else {
 917:../src/wolfcrypt/src/dsa.c ****                 out = tmp + halfSz;  /* advance to s in output */
 1521                             		.loc 2 917 27
 1522 03da ED A5 01                		mov.L	4[r10], r5
 1523                             		.loc 2 917 21
 1524 03dd ED A4 0B                		mov.L	44[r10], r4
 1525 03e0 4B 45                   		add	r4, r5
 1526 03e2 E7 A5 15                		mov.L	r5, 84[r10]
 918:../src/wolfcrypt/src/dsa.c ****                 while (sSz++ < halfSz) {
 1527                             		.loc 2 918 23
 1528 03e5 2E 0E                   		bra	.L106
 1529                             	.L107:
 919:../src/wolfcrypt/src/dsa.c ****                     *out++ = 0x00;  /* pad front with zeros */
 1530                             		.loc 2 919 25
 1531 03e7 ED A5 15                		mov.L	84[r10], r5
 1532 03ea 71 54 01                		add	#1, r5, r4
 1533 03ed E7 A4 15                		mov.L	r4, 84[r10]
 1534                             		.loc 2 919 28
 1535 03f0 F8 54 00                		mov.B	#0, [r5]
 1536                             	.L106:
 918:../src/wolfcrypt/src/dsa.c ****                 while (sSz++ < halfSz) {
 1537                             		.loc 2 918 27
 1538 03f3 ED A5 03                		mov.L	12[r10], r5
 1539 03f6 71 54 01                		add	#1, r5, r4
 1540 03f9 E7 A4 03                		mov.L	r4, 12[r10]
 918:../src/wolfcrypt/src/dsa.c ****                 while (sSz++ < halfSz) {
 1541                             		.loc 2 918 23
 1542 03fc ED A4 01                		mov.L	4[r10], r4
 1543 03ff 47 54                   		cmp	r5, r4
 1544 0401 2A E6                   		bgt	.L107
 920:../src/wolfcrypt/src/dsa.c ****                 }
 921:../src/wolfcrypt/src/dsa.c ****                 ret = mp_to_unsigned_bin(s, out);
 1545                             		.loc 2 921 23
 1546 0403 ED A2 15                		mov.L	84[r10], r2
 1547 0406 ED A1 07                		mov.L	28[r10], r1
 1548 0409 05 00 00 00             		bsr	_sp_to_unsigned_bin
 1549 040d E3 A1                   		mov.L	r1, [r10]
 1550 040f 0D                      		bra	.L75
 1551                             	.L122:
 1552                             	.LBE3:
 762:../src/wolfcrypt/src/dsa.c **** 
 1553                             		.loc 2 762 13
 1554 0410 03                      		nop
 1555 0411 2E 03                   		bra	.L75
 1556                             	.L124:
 824:../src/wolfcrypt/src/dsa.c **** 
 1557                             		.loc 2 824 13
 1558 0413 03                      		nop
 1559                             		.balign 8,3,1
 1560                             	.L75:
 922:../src/wolfcrypt/src/dsa.c ****             }
 923:../src/wolfcrypt/src/dsa.c ****         }
 924:../src/wolfcrypt/src/dsa.c ****     } while (0);
 925:../src/wolfcrypt/src/dsa.c **** 
 926:../src/wolfcrypt/src/dsa.c ****     RESTORE_VECTOR_REGISTERS();
 927:../src/wolfcrypt/src/dsa.c **** 
 928:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 929:../src/wolfcrypt/src/dsa.c ****     if (k) {
 1561                             		.loc 2 929 8
 1562 0414 ED A5 04                		mov.L	16[r10], r5
 1563 0417 61 05                   		cmp	#0, r5
 1564 0419 20 22                   		beq	.L108
 930:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 1565                             		.loc 2 930 12
 1566 041b EC A5                   		mov.L	[r10], r5
 1567 041d 75 05 92                		cmp	#-110, r5
 1568 0420 10                      		beq	.L109
 931:../src/wolfcrypt/src/dsa.c ****             mp_forcezero(k);
 1569                             		.loc 2 931 13
 1570 0421 ED A1 04                		mov.L	16[r10], r1
 1571 0424 05 00 00 00             		bsr	_sp_forcezero
 1572                             	.L109:
 1573                             	.LBB4:
 932:../src/wolfcrypt/src/dsa.c ****         XFREE(k, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1574                             		.loc 2 932 9
 1575 0428 ED A5 04                		mov.L	16[r10], r5
 1576 042b E7 A5 0D                		mov.L	r5, 52[r10]
 1577 042e ED A5 0D                		mov.L	52[r10], r5
 1578 0431 61 05                   		cmp	#0, r5
 1579 0433 10                      		beq	.L108
 1580                             		.loc 2 932 9 is_stmt 0 discriminator 1
 1581 0434 ED A1 0D                		mov.L	52[r10], r1
 1582 0437 05 00 00 00             		bsr	_wolfSSL_Free
 1583                             	.L108:
 1584                             	.LBE4:
 933:../src/wolfcrypt/src/dsa.c ****     }
 934:../src/wolfcrypt/src/dsa.c ****     if (kInv) {
 1585                             		.loc 2 934 8 is_stmt 1
 1586 043b ED A5 05                		mov.L	20[r10], r5
 1587 043e 61 05                   		cmp	#0, r5
 1588 0440 20 22                   		beq	.L110
 935:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 1589                             		.loc 2 935 12
 1590 0442 EC A5                   		mov.L	[r10], r5
 1591 0444 75 05 92                		cmp	#-110, r5
 1592 0447 10                      		beq	.L111
 936:../src/wolfcrypt/src/dsa.c ****             mp_forcezero(kInv);
 1593                             		.loc 2 936 13
 1594 0448 ED A1 05                		mov.L	20[r10], r1
 1595 044b 05 00 00 00             		bsr	_sp_forcezero
 1596                             	.L111:
 1597                             	.LBB5:
 937:../src/wolfcrypt/src/dsa.c ****         XFREE(kInv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1598                             		.loc 2 937 9
 1599 044f ED A5 05                		mov.L	20[r10], r5
 1600 0452 E7 A5 0E                		mov.L	r5, 56[r10]
 1601 0455 ED A5 0E                		mov.L	56[r10], r5
 1602 0458 61 05                   		cmp	#0, r5
 1603 045a 10                      		beq	.L110
 1604                             		.loc 2 937 9 is_stmt 0 discriminator 1
 1605 045b ED A1 0E                		mov.L	56[r10], r1
 1606 045e 05 00 00 00             		bsr	_wolfSSL_Free
 1607                             	.L110:
 1608                             	.LBE5:
 938:../src/wolfcrypt/src/dsa.c ****     }
 939:../src/wolfcrypt/src/dsa.c ****     if (r) {
 1609                             		.loc 2 939 8 is_stmt 1
 1610 0462 ED A5 06                		mov.L	24[r10], r5
 1611 0465 61 05                   		cmp	#0, r5
 1612 0467 20 22                   		beq	.L112
 940:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 1613                             		.loc 2 940 12
 1614 0469 EC A5                   		mov.L	[r10], r5
 1615 046b 75 05 92                		cmp	#-110, r5
 1616 046e 10                      		beq	.L113
 941:../src/wolfcrypt/src/dsa.c ****             mp_clear(r);
 1617                             		.loc 2 941 13
 1618 046f ED A1 06                		mov.L	24[r10], r1
 1619 0472 05 00 00 00             		bsr	_sp_clear
 1620                             	.L113:
 1621                             	.LBB6:
 942:../src/wolfcrypt/src/dsa.c ****         XFREE(r, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1622                             		.loc 2 942 9
 1623 0476 ED A5 06                		mov.L	24[r10], r5
 1624 0479 E7 A5 0F                		mov.L	r5, 60[r10]
 1625 047c ED A5 0F                		mov.L	60[r10], r5
 1626 047f 61 05                   		cmp	#0, r5
 1627 0481 10                      		beq	.L112
 1628                             		.loc 2 942 9 is_stmt 0 discriminator 1
 1629 0482 ED A1 0F                		mov.L	60[r10], r1
 1630 0485 05 00 00 00             		bsr	_wolfSSL_Free
 1631                             	.L112:
 1632                             	.LBE6:
 943:../src/wolfcrypt/src/dsa.c ****     }
 944:../src/wolfcrypt/src/dsa.c ****     if (s) {
 1633                             		.loc 2 944 8 is_stmt 1
 1634 0489 ED A5 07                		mov.L	28[r10], r5
 1635 048c 61 05                   		cmp	#0, r5
 1636 048e 20 22                   		beq	.L114
 945:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 1637                             		.loc 2 945 12
 1638 0490 EC A5                   		mov.L	[r10], r5
 1639 0492 75 05 92                		cmp	#-110, r5
 1640 0495 10                      		beq	.L115
 946:../src/wolfcrypt/src/dsa.c ****             mp_clear(s);
 1641                             		.loc 2 946 13
 1642 0496 ED A1 07                		mov.L	28[r10], r1
 1643 0499 05 00 00 00             		bsr	_sp_clear
 1644                             	.L115:
 1645                             	.LBB7:
 947:../src/wolfcrypt/src/dsa.c ****         XFREE(s, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1646                             		.loc 2 947 9
 1647 049d ED A5 07                		mov.L	28[r10], r5
 1648 04a0 E7 A5 10                		mov.L	r5, 64[r10]
 1649 04a3 ED A5 10                		mov.L	64[r10], r5
 1650 04a6 61 05                   		cmp	#0, r5
 1651 04a8 10                      		beq	.L114
 1652                             		.loc 2 947 9 is_stmt 0 discriminator 1
 1653 04a9 ED A1 10                		mov.L	64[r10], r1
 1654 04ac 05 00 00 00             		bsr	_wolfSSL_Free
 1655                             	.L114:
 1656                             	.LBE7:
 948:../src/wolfcrypt/src/dsa.c ****     }
 949:../src/wolfcrypt/src/dsa.c ****     if (H) {
 1657                             		.loc 2 949 8 is_stmt 1
 1658 04b0 ED A5 08                		mov.L	32[r10], r5
 1659 04b3 61 05                   		cmp	#0, r5
 1660 04b5 20 22                   		beq	.L116
 950:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 1661                             		.loc 2 950 12
 1662 04b7 EC A5                   		mov.L	[r10], r5
 1663 04b9 75 05 92                		cmp	#-110, r5
 1664 04bc 10                      		beq	.L117
 951:../src/wolfcrypt/src/dsa.c ****             mp_clear(H);
 1665                             		.loc 2 951 13
 1666 04bd ED A1 08                		mov.L	32[r10], r1
 1667 04c0 05 00 00 00             		bsr	_sp_clear
 1668                             	.L117:
 1669                             	.LBB8:
 952:../src/wolfcrypt/src/dsa.c ****         XFREE(H, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1670                             		.loc 2 952 9
 1671 04c4 ED A5 08                		mov.L	32[r10], r5
 1672 04c7 E7 A5 11                		mov.L	r5, 68[r10]
 1673 04ca ED A5 11                		mov.L	68[r10], r5
 1674 04cd 61 05                   		cmp	#0, r5
 1675 04cf 10                      		beq	.L116
 1676                             		.loc 2 952 9 is_stmt 0 discriminator 1
 1677 04d0 ED A1 11                		mov.L	68[r10], r1
 1678 04d3 05 00 00 00             		bsr	_wolfSSL_Free
 1679                             	.L116:
 1680                             	.LBE8:
 953:../src/wolfcrypt/src/dsa.c ****     }
 954:../src/wolfcrypt/src/dsa.c **** #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME
 955:../src/wolfcrypt/src/dsa.c ****     if (b) {
 1681                             		.loc 2 955 8 is_stmt 1
 1682 04d7 ED A5 09                		mov.L	36[r10], r5
 1683 04da 61 05                   		cmp	#0, r5
 1684 04dc 20 22                   		beq	.L118
 956:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 1685                             		.loc 2 956 12
 1686 04de EC A5                   		mov.L	[r10], r5
 1687 04e0 75 05 92                		cmp	#-110, r5
 1688 04e3 10                      		beq	.L119
 957:../src/wolfcrypt/src/dsa.c ****             mp_forcezero(b);
 1689                             		.loc 2 957 13
 1690 04e4 ED A1 09                		mov.L	36[r10], r1
 1691 04e7 05 00 00 00             		bsr	_sp_forcezero
 1692                             	.L119:
 1693                             	.LBB9:
 958:../src/wolfcrypt/src/dsa.c ****         XFREE(b, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1694                             		.loc 2 958 9
 1695 04eb ED A5 09                		mov.L	36[r10], r5
 1696 04ee E7 A5 12                		mov.L	r5, 72[r10]
 1697 04f1 ED A5 12                		mov.L	72[r10], r5
 1698 04f4 61 05                   		cmp	#0, r5
 1699 04f6 10                      		beq	.L118
 1700                             		.loc 2 958 9 is_stmt 0 discriminator 1
 1701 04f7 ED A1 12                		mov.L	72[r10], r1
 1702 04fa 05 00 00 00             		bsr	_wolfSSL_Free
 1703                             	.L118:
 1704                             	.LBE9:
 959:../src/wolfcrypt/src/dsa.c ****     }
 960:../src/wolfcrypt/src/dsa.c **** #endif
 961:../src/wolfcrypt/src/dsa.c ****     if (buffer) {
 1705                             		.loc 2 961 8 is_stmt 1
 1706 04fe ED A5 0A                		mov.L	40[r10], r5
 1707 0501 61 05                   		cmp	#0, r5
 1708 0503 20 21                   		beq	.L120
 962:../src/wolfcrypt/src/dsa.c ****         ForceZero(buffer, halfSz);
 1709                             		.loc 2 962 9
 1710 0505 ED A5 01                		mov.L	4[r10], r5
 1711 0508 EF 52                   		mov.L	r5, r2
 1712 050a ED A1 0A                		mov.L	40[r10], r1
 1713 050d 05 00 00 00             		bsr	_ForceZero
 1714                             	.LBB10:
 963:../src/wolfcrypt/src/dsa.c ****         XFREE(buffer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1715                             		.loc 2 963 9
 1716 0511 ED A5 0A                		mov.L	40[r10], r5
 1717 0514 E7 A5 13                		mov.L	r5, 76[r10]
 1718 0517 ED A5 13                		mov.L	76[r10], r5
 1719 051a 61 05                   		cmp	#0, r5
 1720 051c 10                      		beq	.L120
 1721                             		.loc 2 963 9 is_stmt 0 discriminator 1
 1722 051d ED A1 13                		mov.L	76[r10], r1
 1723 0520 05 00 00 00             		bsr	_wolfSSL_Free
 1724                             	.L120:
 1725                             	.LBE10:
 964:../src/wolfcrypt/src/dsa.c ****     }
 965:../src/wolfcrypt/src/dsa.c **** #else /* !WOLFSSL_SMALL_STACK */
 966:../src/wolfcrypt/src/dsa.c ****     if (ret != MP_INIT_E) {
 967:../src/wolfcrypt/src/dsa.c ****         ForceZero(buffer, halfSz);
 968:../src/wolfcrypt/src/dsa.c ****         mp_forcezero(kInv);
 969:../src/wolfcrypt/src/dsa.c ****         mp_forcezero(k);
 970:../src/wolfcrypt/src/dsa.c **** #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME
 971:../src/wolfcrypt/src/dsa.c ****         mp_forcezero(b);
 972:../src/wolfcrypt/src/dsa.c **** #endif
 973:../src/wolfcrypt/src/dsa.c ****         mp_clear(H);
 974:../src/wolfcrypt/src/dsa.c ****         mp_clear(s);
 975:../src/wolfcrypt/src/dsa.c ****         mp_clear(r);
 976:../src/wolfcrypt/src/dsa.c ****     }
 977:../src/wolfcrypt/src/dsa.c **** #endif
 978:../src/wolfcrypt/src/dsa.c **** 
 979:../src/wolfcrypt/src/dsa.c ****     return ret;
 1726                             		.loc 2 979 12 is_stmt 1
 1727 0524 EC A5                   		mov.L	[r10], r5
 1728                             	.L72:
 980:../src/wolfcrypt/src/dsa.c **** }
 1729                             		.loc 2 980 1
 1730 0526 EF 51                   		mov.L	r5, r1
 1731 0528 3F AA 1B                		rtsd	#108, r10-r10
 1732                             	.LFE52:
 1734 052b 77 10 01 00 00          		.section	.text.wc_DsaVerify,"ax",@progbits
 1735                             		.global	_wc_DsaVerify
 1737                             	_wc_DsaVerify:
 1738                             	.LFB53:
 981:../src/wolfcrypt/src/dsa.c **** 
 982:../src/wolfcrypt/src/dsa.c **** 
 983:../src/wolfcrypt/src/dsa.c **** int wc_DsaVerify(const byte* digest, const byte* sig, DsaKey* key, int* answer)
 984:../src/wolfcrypt/src/dsa.c **** {
 1739                             		.loc 2 984 1
 1740 0000 7E AA                   		push.l	r10
 1741                             	.LCFI31:
 1742 0002 71 0A B8                		add	#-72, r0, r10
 1743                             	.LCFI32:
 1744 0005 71 A0 F8                		add	#-8, r10, r0
 1745                             	.LCFI33:
 1746 0008 E7 A1 0E                		mov.L	r1, 56[r10]
 1747 000b E7 A2 0F                		mov.L	r2, 60[r10]
 1748 000e E7 A3 10                		mov.L	r3, 64[r10]
 1749 0011 E7 A4 11                		mov.L	r4, 68[r10]
 985:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
 986:../src/wolfcrypt/src/dsa.c ****     mp_int *w = NULL;
 1750                             		.loc 2 986 13
 1751 0014 F9 A6 01 00             		mov.L	#0, 4[r10]
 987:../src/wolfcrypt/src/dsa.c ****     mp_int *u1 = NULL;
 1752                             		.loc 2 987 13
 1753 0018 F9 A6 02 00             		mov.L	#0, 8[r10]
 988:../src/wolfcrypt/src/dsa.c ****     mp_int *u2 = NULL;
 1754                             		.loc 2 988 13
 1755 001c F9 A6 03 00             		mov.L	#0, 12[r10]
 989:../src/wolfcrypt/src/dsa.c ****     mp_int *v = NULL;
 1756                             		.loc 2 989 13
 1757 0020 F9 A6 04 00             		mov.L	#0, 16[r10]
 990:../src/wolfcrypt/src/dsa.c ****     mp_int *r = NULL;
 1758                             		.loc 2 990 13
 1759 0024 F9 A6 05 00             		mov.L	#0, 20[r10]
 991:../src/wolfcrypt/src/dsa.c ****     mp_int *s = NULL;
 1760                             		.loc 2 991 13
 1761 0028 F9 A6 06 00             		mov.L	#0, 24[r10]
 992:../src/wolfcrypt/src/dsa.c **** #else
 993:../src/wolfcrypt/src/dsa.c ****     mp_int w[1], u1[1], u2[1], v[1], r[1], s[1];
 994:../src/wolfcrypt/src/dsa.c **** #endif
 995:../src/wolfcrypt/src/dsa.c ****     int    ret = 0;
 1762                             		.loc 2 995 12
 1763 002c F8 A6 00                		mov.L	#0, [r10]
 996:../src/wolfcrypt/src/dsa.c ****     int    qSz;
 997:../src/wolfcrypt/src/dsa.c **** 
 998:../src/wolfcrypt/src/dsa.c ****     if (digest == NULL || sig == NULL || key == NULL || answer == NULL)
 1764                             		.loc 2 998 8
 1765 002f ED A5 0E                		mov.L	56[r10], r5
 1766 0032 61 05                   		cmp	#0, r5
 1767 0034 20 15                   		beq	.L126
 1768                             		.loc 2 998 24 discriminator 1
 1769 0036 ED A5 0F                		mov.L	60[r10], r5
 1770 0039 61 05                   		cmp	#0, r5
 1771 003b 20 0E                   		beq	.L126
 1772                             		.loc 2 998 39 discriminator 2
 1773 003d ED A5 10                		mov.L	64[r10], r5
 1774 0040 61 05                   		cmp	#0, r5
 1775 0042 17                      		beq	.L126
 1776                             		.loc 2 998 54 discriminator 3
 1777 0043 ED A5 11                		mov.L	68[r10], r5
 1778 0046 61 05                   		cmp	#0, r5
 1779 0048 18                      		bne	.L127
 1780                             		.balign 8,3,2
 1781                             	.L126:
 999:../src/wolfcrypt/src/dsa.c ****         return BAD_FUNC_ARG;
 1782                             		.loc 2 999 16
 1783 0049 FB 5A 53 FF             		mov.L	#-173, r5
 1784 004d 38 32 03                		bra	.L128
 1785                             	.L127:
1000:../src/wolfcrypt/src/dsa.c **** 
1001:../src/wolfcrypt/src/dsa.c ****     do {
1002:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
1003:../src/wolfcrypt/src/dsa.c ****         w = (mp_int *)XMALLOC(sizeof *w, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1786                             		.loc 2 1003 23
 1787 0050 FB 1A 10 03             		mov.L	#0x310, r1
 1788 0054 05 00 00 00             		bsr	_wolfSSL_Malloc
 1789 0058 E7 A1 01                		mov.L	r1, 4[r10]
1004:../src/wolfcrypt/src/dsa.c ****         u1 = (mp_int *)XMALLOC(sizeof *u1, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1790                             		.loc 2 1004 24
 1791 005b FB 1A 10 03             		mov.L	#0x310, r1
 1792 005f 05 00 00 00             		bsr	_wolfSSL_Malloc
 1793 0063 E7 A1 02                		mov.L	r1, 8[r10]
1005:../src/wolfcrypt/src/dsa.c ****         u2 = (mp_int *)XMALLOC(sizeof *u2, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1794                             		.loc 2 1005 24
 1795 0066 FB 1A 10 03             		mov.L	#0x310, r1
 1796 006a 05 00 00 00             		bsr	_wolfSSL_Malloc
 1797 006e E7 A1 03                		mov.L	r1, 12[r10]
1006:../src/wolfcrypt/src/dsa.c ****         v = (mp_int *)XMALLOC(sizeof *v, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1798                             		.loc 2 1006 23
 1799 0071 FB 1A 10 03             		mov.L	#0x310, r1
 1800 0075 05 00 00 00             		bsr	_wolfSSL_Malloc
 1801 0079 E7 A1 04                		mov.L	r1, 16[r10]
1007:../src/wolfcrypt/src/dsa.c ****         r = (mp_int *)XMALLOC(sizeof *r, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1802                             		.loc 2 1007 23
 1803 007c FB 1A 10 03             		mov.L	#0x310, r1
 1804 0080 05 00 00 00             		bsr	_wolfSSL_Malloc
 1805 0084 E7 A1 05                		mov.L	r1, 20[r10]
1008:../src/wolfcrypt/src/dsa.c ****         s = (mp_int *)XMALLOC(sizeof *s, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1806                             		.loc 2 1008 23
 1807 0087 FB 1A 10 03             		mov.L	#0x310, r1
 1808 008b 05 00 00 00             		bsr	_wolfSSL_Malloc
 1809 008f E7 A1 06                		mov.L	r1, 24[r10]
1009:../src/wolfcrypt/src/dsa.c **** 
1010:../src/wolfcrypt/src/dsa.c ****         if ((w == NULL) ||
 1810                             		.loc 2 1010 12
 1811 0092 ED A5 01                		mov.L	4[r10], r5
 1812 0095 61 05                   		cmp	#0, r5
 1813 0097 20 29                   		beq	.L129
 1814                             		.loc 2 1010 25 discriminator 1
 1815 0099 ED A5 02                		mov.L	8[r10], r5
 1816 009c 61 05                   		cmp	#0, r5
 1817 009e 20 22                   		beq	.L129
1011:../src/wolfcrypt/src/dsa.c ****             (u1 == NULL) ||
 1818                             		.loc 2 1011 26
 1819 00a0 ED A5 03                		mov.L	12[r10], r5
 1820 00a3 61 05                   		cmp	#0, r5
 1821 00a5 20 1B                   		beq	.L129
1012:../src/wolfcrypt/src/dsa.c ****             (u2 == NULL) ||
 1822                             		.loc 2 1012 26
 1823 00a7 ED A5 04                		mov.L	16[r10], r5
 1824 00aa 61 05                   		cmp	#0, r5
 1825 00ac 20 14                   		beq	.L129
1013:../src/wolfcrypt/src/dsa.c ****             (v == NULL) ||
 1826                             		.loc 2 1013 25
 1827 00ae ED A5 05                		mov.L	20[r10], r5
 1828 00b1 61 05                   		cmp	#0, r5
 1829 00b3 20 0D                   		beq	.L129
1014:../src/wolfcrypt/src/dsa.c ****             (r == NULL) ||
 1830                             		.loc 2 1014 25
 1831 00b5 ED A5 06                		mov.L	24[r10], r5
 1832 00b8 61 05                   		cmp	#0, r5
 1833 00ba 21 0C                   		bne	.L130
 1834 00bc 76 10 01 00             		.balign 8,3,4
 1835                             	.L129:
1015:../src/wolfcrypt/src/dsa.c ****             (s == NULL)) {
1016:../src/wolfcrypt/src/dsa.c ****             ret = MEMORY_E;
 1836                             		.loc 2 1016 17
 1837 00c0 F8 A6 83                		mov.L	#-125, [r10]
1017:../src/wolfcrypt/src/dsa.c ****             break;
 1838                             		.loc 2 1017 13
 1839 00c3 38 D0 01                		bra	.L131
 1840                             	.L130:
1018:../src/wolfcrypt/src/dsa.c ****         }
1019:../src/wolfcrypt/src/dsa.c **** #endif
1020:../src/wolfcrypt/src/dsa.c **** 
1021:../src/wolfcrypt/src/dsa.c ****         if (mp_init_multi(w, u1, u2, v, r, s) != MP_OKAY) {
 1841                             		.loc 2 1021 13
 1842 00c6 ED A5 06                		mov.L	24[r10], r5
 1843 00c9 A0 0D                   		mov.L	r5, 4[r0]
 1844 00cb ED A5 05                		mov.L	20[r10], r5
 1845 00ce E3 05                   		mov.L	r5, [r0]
 1846 00d0 ED A4 04                		mov.L	16[r10], r4
 1847 00d3 ED A3 03                		mov.L	12[r10], r3
 1848 00d6 ED A2 02                		mov.L	8[r10], r2
 1849 00d9 ED A1 01                		mov.L	4[r10], r1
 1850 00dc 05 00 00 00             		bsr	_sp_init_multi
 1851 00e0 EF 15                   		mov.L	r1, r5
 1852                             		.loc 2 1021 12
 1853 00e2 61 05                   		cmp	#0, r5
 1854 00e4 17                      		beq	.L132
1022:../src/wolfcrypt/src/dsa.c ****             ret = MP_INIT_E;
 1855                             		.loc 2 1022 17
 1856 00e5 F8 A6 92                		mov.L	#-110, [r10]
1023:../src/wolfcrypt/src/dsa.c ****             break;
 1857                             		.loc 2 1023 13
 1858 00e8 38 AB 01                		bra	.L131
 1859                             	.L132:
1024:../src/wolfcrypt/src/dsa.c ****         }
1025:../src/wolfcrypt/src/dsa.c **** 
1026:../src/wolfcrypt/src/dsa.c ****         qSz = mp_unsigned_bin_size(&key->q);
 1860                             		.loc 2 1026 36
 1861 00eb ED A5 10                		mov.L	64[r10], r5
 1862 00ee 72 55 10 03             		add	#0x310, r5
 1863                             		.loc 2 1026 15
 1864 00f2 EF 51                   		mov.L	r5, r1
 1865 00f4 05 00 00 00             		bsr	_sp_unsigned_bin_size
 1866 00f8 E7 A1 07                		mov.L	r1, 28[r10]
1027:../src/wolfcrypt/src/dsa.c ****         if (qSz <= 0) {
 1867                             		.loc 2 1027 12
 1868 00fb ED A5 07                		mov.L	28[r10], r5
 1869 00fe 61 05                   		cmp	#0, r5
 1870 0100 2A 09                   		bgt	.L133
1028:../src/wolfcrypt/src/dsa.c ****             ret = BAD_FUNC_ARG;
 1871                             		.loc 2 1028 17
 1872 0102 F8 AA 53 FF             		mov.L	#-173, [r10]
1029:../src/wolfcrypt/src/dsa.c ****             break;
 1873                             		.loc 2 1029 13
 1874 0106 38 8D 01                		bra	.L131
 1875                             	.L133:
1030:../src/wolfcrypt/src/dsa.c ****         }
1031:../src/wolfcrypt/src/dsa.c **** 
1032:../src/wolfcrypt/src/dsa.c ****         /* set r and s from signature */
1033:../src/wolfcrypt/src/dsa.c ****         if (mp_read_unsigned_bin(r, sig, qSz) != MP_OKAY ||
 1876                             		.loc 2 1033 13
 1877 0109 ED A5 07                		mov.L	28[r10], r5
 1878 010c EF 53                   		mov.L	r5, r3
 1879 010e ED A2 0F                		mov.L	60[r10], r2
 1880 0111 ED A1 05                		mov.L	20[r10], r1
 1881 0114 05 00 00 00             		bsr	_sp_read_unsigned_bin
 1882 0118 EF 15                   		mov.L	r1, r5
 1883                             		.loc 2 1033 12
 1884 011a 61 05                   		cmp	#0, r5
 1885 011c 21 1D                   		bne	.L134
1034:../src/wolfcrypt/src/dsa.c ****             mp_read_unsigned_bin(s, sig + qSz, qSz) != MP_OKAY) {
 1886                             		.loc 2 1034 13 discriminator 1
 1887 011e ED A5 07                		mov.L	28[r10], r5
 1888 0121 ED A4 0F                		mov.L	60[r10], r4
 1889 0124 4B 45                   		add	r4, r5
 1890 0126 ED A4 07                		mov.L	28[r10], r4
 1891 0129 EF 43                   		mov.L	r4, r3
 1892 012b EF 52                   		mov.L	r5, r2
 1893 012d ED A1 06                		mov.L	24[r10], r1
 1894 0130 05 00 00 00             		bsr	_sp_read_unsigned_bin
 1895 0134 EF 15                   		mov.L	r1, r5
1033:../src/wolfcrypt/src/dsa.c ****             mp_read_unsigned_bin(s, sig + qSz, qSz) != MP_OKAY) {
 1896                             		.loc 2 1033 58 discriminator 1
 1897 0136 61 05                   		cmp	#0, r5
 1898 0138 17                      		beq	.L135
 1899                             	.L134:
1035:../src/wolfcrypt/src/dsa.c ****             ret = MP_READ_E;
 1900                             		.loc 2 1035 17
 1901 0139 F8 A6 91                		mov.L	#-111, [r10]
1036:../src/wolfcrypt/src/dsa.c ****             break;
 1902                             		.loc 2 1036 13
 1903 013c 38 57 01                		bra	.L131
 1904                             	.L135:
1037:../src/wolfcrypt/src/dsa.c ****         }
1038:../src/wolfcrypt/src/dsa.c **** 
1039:../src/wolfcrypt/src/dsa.c ****         /* sanity checks */
1040:../src/wolfcrypt/src/dsa.c ****         if (mp_iszero(r) == MP_YES || mp_iszero(s) == MP_YES ||
 1905                             		.loc 2 1040 13
 1906 013f ED A5 05                		mov.L	20[r10], r5
 1907 0142 EC 55                   		mov.L	[r5], r5
 1908                             		.loc 2 1040 12
 1909 0144 61 05                   		cmp	#0, r5
 1910 0146 20 3A                   		beq	.L136
 1911                             		.loc 2 1040 39 discriminator 1
 1912 0148 ED A5 06                		mov.L	24[r10], r5
 1913 014b EC 55                   		mov.L	[r5], r5
 1914                             		.loc 2 1040 36 discriminator 1
 1915 014d 61 05                   		cmp	#0, r5
 1916 014f 20 31                   		beq	.L136
1041:../src/wolfcrypt/src/dsa.c ****             mp_cmp(r, &key->q) != MP_LT || mp_cmp(s, &key->q) != MP_LT) {
 1917                             		.loc 2 1041 23 discriminator 2
 1918 0151 ED A5 10                		mov.L	64[r10], r5
 1919 0154 72 55 10 03             		add	#0x310, r5
 1920                             		.loc 2 1041 13 discriminator 2
 1921 0158 EF 52                   		mov.L	r5, r2
 1922 015a ED A1 05                		mov.L	20[r10], r1
 1923 015d 05 00 00 00             		bsr	_sp_cmp
 1924 0161 EF 15                   		mov.L	r1, r5
1040:../src/wolfcrypt/src/dsa.c ****             mp_cmp(r, &key->q) != MP_LT || mp_cmp(s, &key->q) != MP_LT) {
 1925                             		.loc 2 1040 62 discriminator 2
 1926 0163 75 05 FF                		cmp	#-1, r5
 1927 0166 21 1A                   		bne	.L136
 1928                             		.loc 2 1041 54
 1929 0168 ED A5 10                		mov.L	64[r10], r5
 1930 016b 72 55 10 03             		add	#0x310, r5
 1931                             		.loc 2 1041 44
 1932 016f EF 52                   		mov.L	r5, r2
 1933 0171 ED A1 06                		mov.L	24[r10], r1
 1934 0174 05 00 00 00             		bsr	_sp_cmp
 1935 0178 EF 15                   		mov.L	r1, r5
 1936                             		.loc 2 1041 41
 1937 017a 75 05 FF                		cmp	#-1, r5
 1938 017d 11                      		beq	.L137
 1939 017e EF 00                   		.balign 8,3,4
 1940                             	.L136:
1042:../src/wolfcrypt/src/dsa.c ****             ret = MP_ZERO_E;
 1941                             		.loc 2 1042 17
 1942 0180 F8 A6 87                		mov.L	#-121, [r10]
1043:../src/wolfcrypt/src/dsa.c ****             break;
 1943                             		.loc 2 1043 13
 1944 0183 38 10 01                		bra	.L131
 1945                             	.L137:
1044:../src/wolfcrypt/src/dsa.c ****         }
1045:../src/wolfcrypt/src/dsa.c **** 
1046:../src/wolfcrypt/src/dsa.c ****         /* put H into u1 from sha digest */
1047:../src/wolfcrypt/src/dsa.c ****         if (mp_read_unsigned_bin(u1,digest,WC_SHA_DIGEST_SIZE) != MP_OKAY) {
 1946                             		.loc 2 1047 13
 1947 0186 75 43 14                		mov.L	#20, r3
 1948 0189 ED A2 0E                		mov.L	56[r10], r2
 1949 018c ED A1 02                		mov.L	8[r10], r1
 1950 018f 05 00 00 00             		bsr	_sp_read_unsigned_bin
 1951 0193 EF 15                   		mov.L	r1, r5
 1952                             		.loc 2 1047 12
 1953 0195 61 05                   		cmp	#0, r5
 1954 0197 17                      		beq	.L138
1048:../src/wolfcrypt/src/dsa.c ****             ret = MP_READ_E;
 1955                             		.loc 2 1048 17
 1956 0198 F8 A6 91                		mov.L	#-111, [r10]
1049:../src/wolfcrypt/src/dsa.c ****             break;
 1957                             		.loc 2 1049 13
 1958 019b 38 F8 00                		bra	.L131
 1959                             	.L138:
1050:../src/wolfcrypt/src/dsa.c ****         }
1051:../src/wolfcrypt/src/dsa.c **** 
1052:../src/wolfcrypt/src/dsa.c ****         /* w = s invmod q */
1053:../src/wolfcrypt/src/dsa.c ****         if (mp_invmod(s, &key->q, w) != MP_OKAY) {
 1960                             		.loc 2 1053 26
 1961 019e ED A5 10                		mov.L	64[r10], r5
 1962 01a1 72 55 10 03             		add	#0x310, r5
 1963                             		.loc 2 1053 13
 1964 01a5 ED A3 01                		mov.L	4[r10], r3
 1965 01a8 EF 52                   		mov.L	r5, r2
 1966 01aa ED A1 06                		mov.L	24[r10], r1
 1967 01ad 05 00 00 00             		bsr	_sp_invmod
 1968 01b1 EF 15                   		mov.L	r1, r5
 1969                             		.loc 2 1053 12
 1970 01b3 61 05                   		cmp	#0, r5
 1971 01b5 17                      		beq	.L139
1054:../src/wolfcrypt/src/dsa.c ****             ret = MP_INVMOD_E;
 1972                             		.loc 2 1054 17
 1973 01b6 F8 A6 89                		mov.L	#-119, [r10]
1055:../src/wolfcrypt/src/dsa.c ****             break;
 1974                             		.loc 2 1055 13
 1975 01b9 38 DA 00                		bra	.L131
 1976                             	.L139:
1056:../src/wolfcrypt/src/dsa.c ****         }
1057:../src/wolfcrypt/src/dsa.c **** 
1058:../src/wolfcrypt/src/dsa.c ****         /* u1 = (H * w) % q */
1059:../src/wolfcrypt/src/dsa.c ****         if (mp_mulmod(u1, w, &key->q, u1) != MP_OKAY) {
 1977                             		.loc 2 1059 30
 1978 01bc ED A5 10                		mov.L	64[r10], r5
 1979 01bf 72 55 10 03             		add	#0x310, r5
 1980                             		.loc 2 1059 13
 1981 01c3 ED A4 02                		mov.L	8[r10], r4
 1982 01c6 EF 53                   		mov.L	r5, r3
 1983 01c8 ED A2 01                		mov.L	4[r10], r2
 1984 01cb ED A1 02                		mov.L	8[r10], r1
 1985 01ce 05 00 00 00             		bsr	_sp_mulmod
 1986 01d2 EF 15                   		mov.L	r1, r5
 1987                             		.loc 2 1059 12
 1988 01d4 61 05                   		cmp	#0, r5
 1989 01d6 17                      		beq	.L140
1060:../src/wolfcrypt/src/dsa.c ****             ret = MP_MULMOD_E;
 1990                             		.loc 2 1060 17
 1991 01d7 F8 A6 8B                		mov.L	#-117, [r10]
1061:../src/wolfcrypt/src/dsa.c ****             break;
 1992                             		.loc 2 1061 13
 1993 01da 38 B9 00                		bra	.L131
 1994                             	.L140:
1062:../src/wolfcrypt/src/dsa.c ****         }
1063:../src/wolfcrypt/src/dsa.c **** 
1064:../src/wolfcrypt/src/dsa.c ****         /* u2 = (r * w) % q */
1065:../src/wolfcrypt/src/dsa.c ****         if (mp_mulmod(r, w, &key->q, u2) != MP_OKAY) {
 1995                             		.loc 2 1065 29
 1996 01dd ED A5 10                		mov.L	64[r10], r5
 1997 01e0 72 55 10 03             		add	#0x310, r5
 1998                             		.loc 2 1065 13
 1999 01e4 ED A4 03                		mov.L	12[r10], r4
 2000 01e7 EF 53                   		mov.L	r5, r3
 2001 01e9 ED A2 01                		mov.L	4[r10], r2
 2002 01ec ED A1 05                		mov.L	20[r10], r1
 2003 01ef 05 00 00 00             		bsr	_sp_mulmod
 2004 01f3 EF 15                   		mov.L	r1, r5
 2005                             		.loc 2 1065 12
 2006 01f5 61 05                   		cmp	#0, r5
 2007 01f7 17                      		beq	.L141
1066:../src/wolfcrypt/src/dsa.c ****             ret = MP_MULMOD_E;
 2008                             		.loc 2 1066 17
 2009 01f8 F8 A6 8B                		mov.L	#-117, [r10]
1067:../src/wolfcrypt/src/dsa.c ****             break;
 2010                             		.loc 2 1067 13
 2011 01fb 38 98 00                		bra	.L131
 2012                             	.L141:
1068:../src/wolfcrypt/src/dsa.c ****         }
1069:../src/wolfcrypt/src/dsa.c **** 
1070:../src/wolfcrypt/src/dsa.c ****         /* verify v = ((g^u1 * y^u2) mod p) mod q */
1071:../src/wolfcrypt/src/dsa.c ****         if (mp_exptmod(&key->g, u1, &key->p, u1) != MP_OKAY) {
 2013                             		.loc 2 1071 24
 2014 01fe ED A5 10                		mov.L	64[r10], r5
 2015 0201 72 55 20 06             		add	#0x620, r5
 2016                             		.loc 2 1071 37
 2017 0205 ED A3 10                		mov.L	64[r10], r3
 2018                             		.loc 2 1071 13
 2019 0208 ED A4 02                		mov.L	8[r10], r4
 2020 020b ED A2 02                		mov.L	8[r10], r2
 2021 020e EF 51                   		mov.L	r5, r1
 2022 0210 05 00 00 00             		bsr	_sp_exptmod
 2023 0214 EF 15                   		mov.L	r1, r5
 2024                             		.loc 2 1071 12
 2025 0216 61 05                   		cmp	#0, r5
 2026 0218 16                      		beq	.L142
1072:../src/wolfcrypt/src/dsa.c ****             ret = MP_EXPTMOD_E;
 2027                             		.loc 2 1072 17
 2028 0219 F8 A6 90                		mov.L	#-112, [r10]
1073:../src/wolfcrypt/src/dsa.c ****             break;
 2029                             		.loc 2 1073 13
 2030 021c 2E 77                   		bra	.L131
 2031                             	.L142:
1074:../src/wolfcrypt/src/dsa.c ****         }
1075:../src/wolfcrypt/src/dsa.c **** 
1076:../src/wolfcrypt/src/dsa.c ****         if (mp_exptmod(&key->y, u2, &key->p, u2) != MP_OKAY) {
 2032                             		.loc 2 1076 24
 2033 021e ED A5 10                		mov.L	64[r10], r5
 2034 0221 72 55 30 09             		add	#0x930, r5
 2035                             		.loc 2 1076 37
 2036 0225 ED A3 10                		mov.L	64[r10], r3
 2037                             		.loc 2 1076 13
 2038 0228 ED A4 03                		mov.L	12[r10], r4
 2039 022b ED A2 03                		mov.L	12[r10], r2
 2040 022e EF 51                   		mov.L	r5, r1
 2041 0230 05 00 00 00             		bsr	_sp_exptmod
 2042 0234 EF 15                   		mov.L	r1, r5
 2043                             		.loc 2 1076 12
 2044 0236 61 05                   		cmp	#0, r5
 2045 0238 16                      		beq	.L143
1077:../src/wolfcrypt/src/dsa.c ****             ret = MP_EXPTMOD_E;
 2046                             		.loc 2 1077 17
 2047 0239 F8 A6 90                		mov.L	#-112, [r10]
1078:../src/wolfcrypt/src/dsa.c ****             break;
 2048                             		.loc 2 1078 13
 2049 023c 2E 57                   		bra	.L131
 2050                             	.L143:
1079:../src/wolfcrypt/src/dsa.c ****         }
1080:../src/wolfcrypt/src/dsa.c **** 
1081:../src/wolfcrypt/src/dsa.c ****         if (mp_mulmod(u1, u2, &key->p, v) != MP_OKAY) {
 2051                             		.loc 2 1081 31
 2052 023e ED A5 10                		mov.L	64[r10], r5
 2053                             		.loc 2 1081 13
 2054 0241 ED A4 04                		mov.L	16[r10], r4
 2055 0244 EF 53                   		mov.L	r5, r3
 2056 0246 ED A2 03                		mov.L	12[r10], r2
 2057 0249 ED A1 02                		mov.L	8[r10], r1
 2058 024c 05 00 00 00             		bsr	_sp_mulmod
 2059 0250 EF 15                   		mov.L	r1, r5
 2060                             		.loc 2 1081 12
 2061 0252 61 05                   		cmp	#0, r5
 2062 0254 16                      		beq	.L144
1082:../src/wolfcrypt/src/dsa.c ****             ret = MP_MULMOD_E;
 2063                             		.loc 2 1082 17
 2064 0255 F8 A6 8B                		mov.L	#-117, [r10]
1083:../src/wolfcrypt/src/dsa.c ****             break;
 2065                             		.loc 2 1083 13
 2066 0258 2E 3B                   		bra	.L131
 2067                             	.L144:
1084:../src/wolfcrypt/src/dsa.c ****         }
1085:../src/wolfcrypt/src/dsa.c **** 
1086:../src/wolfcrypt/src/dsa.c ****         if (mp_mod(v, &key->q, v) != MP_OKAY) {
 2068                             		.loc 2 1086 23
 2069 025a ED A5 10                		mov.L	64[r10], r5
 2070 025d 72 55 10 03             		add	#0x310, r5
 2071                             		.loc 2 1086 13
 2072 0261 ED A3 04                		mov.L	16[r10], r3
 2073 0264 EF 52                   		mov.L	r5, r2
 2074 0266 ED A1 04                		mov.L	16[r10], r1
 2075 0269 05 00 00 00             		bsr	_sp_mod
 2076 026d EF 15                   		mov.L	r1, r5
 2077                             		.loc 2 1086 12
 2078 026f 61 05                   		cmp	#0, r5
 2079 0271 16                      		beq	.L145
1087:../src/wolfcrypt/src/dsa.c ****             ret = MP_MULMOD_E;
 2080                             		.loc 2 1087 17
 2081 0272 F8 A6 8B                		mov.L	#-117, [r10]
1088:../src/wolfcrypt/src/dsa.c ****             break;
 2082                             		.loc 2 1088 13
 2083 0275 2E 1E                   		bra	.L131
 2084                             	.L145:
1089:../src/wolfcrypt/src/dsa.c ****         }
1090:../src/wolfcrypt/src/dsa.c **** 
1091:../src/wolfcrypt/src/dsa.c ****         /* do they match */
1092:../src/wolfcrypt/src/dsa.c ****         if (mp_cmp(r, v) == MP_EQ)
 2085                             		.loc 2 1092 13
 2086 0277 ED A2 04                		mov.L	16[r10], r2
 2087 027a ED A1 05                		mov.L	20[r10], r1
 2088 027d 05 00 00 00             		bsr	_sp_cmp
 2089 0281 EF 15                   		mov.L	r1, r5
 2090                             		.loc 2 1092 12
 2091 0283 61 05                   		cmp	#0, r5
 2092 0285 18                      		bne	.L146
1093:../src/wolfcrypt/src/dsa.c ****             *answer = 1;
 2093                             		.loc 2 1093 21
 2094 0286 ED A5 11                		mov.L	68[r10], r5
 2095 0289 F8 56 01                		mov.L	#1, [r5]
 2096 028c 0F                      		bra	.L131
 2097                             	.L146:
1094:../src/wolfcrypt/src/dsa.c ****         else
1095:../src/wolfcrypt/src/dsa.c ****             *answer = 0;
 2098                             		.loc 2 1095 21
 2099 028d ED A5 11                		mov.L	68[r10], r5
 2100 0290 F8 56 00                		mov.L	#0, [r5]
 2101                             		.balign 8,3,1
 2102                             	.L131:
1096:../src/wolfcrypt/src/dsa.c ****     } while (0);
1097:../src/wolfcrypt/src/dsa.c **** 
1098:../src/wolfcrypt/src/dsa.c **** #ifdef WOLFSSL_SMALL_STACK
1099:../src/wolfcrypt/src/dsa.c ****     if (s) {
 2103                             		.loc 2 1099 8
 2104 0293 ED A5 06                		mov.L	24[r10], r5
 2105 0296 61 05                   		cmp	#0, r5
 2106 0298 20 22                   		beq	.L147
1100:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 2107                             		.loc 2 1100 12
 2108 029a EC A5                   		mov.L	[r10], r5
 2109 029c 75 05 92                		cmp	#-110, r5
 2110 029f 10                      		beq	.L148
1101:../src/wolfcrypt/src/dsa.c ****             mp_clear(s);
 2111                             		.loc 2 1101 13
 2112 02a0 ED A1 06                		mov.L	24[r10], r1
 2113 02a3 05 00 00 00             		bsr	_sp_clear
 2114                             	.L148:
 2115                             	.LBB11:
1102:../src/wolfcrypt/src/dsa.c ****         XFREE(s, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 2116                             		.loc 2 1102 9
 2117 02a7 ED A5 06                		mov.L	24[r10], r5
 2118 02aa E7 A5 08                		mov.L	r5, 32[r10]
 2119 02ad ED A5 08                		mov.L	32[r10], r5
 2120 02b0 61 05                   		cmp	#0, r5
 2121 02b2 10                      		beq	.L147
 2122                             		.loc 2 1102 9 is_stmt 0 discriminator 1
 2123 02b3 ED A1 08                		mov.L	32[r10], r1
 2124 02b6 05 00 00 00             		bsr	_wolfSSL_Free
 2125                             	.L147:
 2126                             	.LBE11:
1103:../src/wolfcrypt/src/dsa.c ****     }
1104:../src/wolfcrypt/src/dsa.c ****     if (r) {
 2127                             		.loc 2 1104 8 is_stmt 1
 2128 02ba ED A5 05                		mov.L	20[r10], r5
 2129 02bd 61 05                   		cmp	#0, r5
 2130 02bf 20 22                   		beq	.L149
1105:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 2131                             		.loc 2 1105 12
 2132 02c1 EC A5                   		mov.L	[r10], r5
 2133 02c3 75 05 92                		cmp	#-110, r5
 2134 02c6 10                      		beq	.L150
1106:../src/wolfcrypt/src/dsa.c ****             mp_clear(r);
 2135                             		.loc 2 1106 13
 2136 02c7 ED A1 05                		mov.L	20[r10], r1
 2137 02ca 05 00 00 00             		bsr	_sp_clear
 2138                             	.L150:
 2139                             	.LBB12:
1107:../src/wolfcrypt/src/dsa.c ****         XFREE(r, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 2140                             		.loc 2 1107 9
 2141 02ce ED A5 05                		mov.L	20[r10], r5
 2142 02d1 E7 A5 09                		mov.L	r5, 36[r10]
 2143 02d4 ED A5 09                		mov.L	36[r10], r5
 2144 02d7 61 05                   		cmp	#0, r5
 2145 02d9 10                      		beq	.L149
 2146                             		.loc 2 1107 9 is_stmt 0 discriminator 1
 2147 02da ED A1 09                		mov.L	36[r10], r1
 2148 02dd 05 00 00 00             		bsr	_wolfSSL_Free
 2149                             	.L149:
 2150                             	.LBE12:
1108:../src/wolfcrypt/src/dsa.c ****     }
1109:../src/wolfcrypt/src/dsa.c ****     if (u1) {
 2151                             		.loc 2 1109 8 is_stmt 1
 2152 02e1 ED A5 02                		mov.L	8[r10], r5
 2153 02e4 61 05                   		cmp	#0, r5
 2154 02e6 20 22                   		beq	.L151
1110:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 2155                             		.loc 2 1110 12
 2156 02e8 EC A5                   		mov.L	[r10], r5
 2157 02ea 75 05 92                		cmp	#-110, r5
 2158 02ed 10                      		beq	.L152
1111:../src/wolfcrypt/src/dsa.c ****             mp_clear(u1);
 2159                             		.loc 2 1111 13
 2160 02ee ED A1 02                		mov.L	8[r10], r1
 2161 02f1 05 00 00 00             		bsr	_sp_clear
 2162                             	.L152:
 2163                             	.LBB13:
1112:../src/wolfcrypt/src/dsa.c ****         XFREE(u1, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 2164                             		.loc 2 1112 9
 2165 02f5 ED A5 02                		mov.L	8[r10], r5
 2166 02f8 E7 A5 0A                		mov.L	r5, 40[r10]
 2167 02fb ED A5 0A                		mov.L	40[r10], r5
 2168 02fe 61 05                   		cmp	#0, r5
 2169 0300 10                      		beq	.L151
 2170                             		.loc 2 1112 9 is_stmt 0 discriminator 1
 2171 0301 ED A1 0A                		mov.L	40[r10], r1
 2172 0304 05 00 00 00             		bsr	_wolfSSL_Free
 2173                             	.L151:
 2174                             	.LBE13:
1113:../src/wolfcrypt/src/dsa.c ****     }
1114:../src/wolfcrypt/src/dsa.c ****     if (u2) {
 2175                             		.loc 2 1114 8 is_stmt 1
 2176 0308 ED A5 03                		mov.L	12[r10], r5
 2177 030b 61 05                   		cmp	#0, r5
 2178 030d 20 22                   		beq	.L153
1115:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 2179                             		.loc 2 1115 12
 2180 030f EC A5                   		mov.L	[r10], r5
 2181 0311 75 05 92                		cmp	#-110, r5
 2182 0314 10                      		beq	.L154
1116:../src/wolfcrypt/src/dsa.c ****             mp_clear(u2);
 2183                             		.loc 2 1116 13
 2184 0315 ED A1 03                		mov.L	12[r10], r1
 2185 0318 05 00 00 00             		bsr	_sp_clear
 2186                             	.L154:
 2187                             	.LBB14:
1117:../src/wolfcrypt/src/dsa.c ****         XFREE(u2, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 2188                             		.loc 2 1117 9
 2189 031c ED A5 03                		mov.L	12[r10], r5
 2190 031f E7 A5 0B                		mov.L	r5, 44[r10]
 2191 0322 ED A5 0B                		mov.L	44[r10], r5
 2192 0325 61 05                   		cmp	#0, r5
 2193 0327 10                      		beq	.L153
 2194                             		.loc 2 1117 9 is_stmt 0 discriminator 1
 2195 0328 ED A1 0B                		mov.L	44[r10], r1
 2196 032b 05 00 00 00             		bsr	_wolfSSL_Free
 2197                             	.L153:
 2198                             	.LBE14:
1118:../src/wolfcrypt/src/dsa.c ****     }
1119:../src/wolfcrypt/src/dsa.c ****     if (w) {
 2199                             		.loc 2 1119 8 is_stmt 1
 2200 032f ED A5 01                		mov.L	4[r10], r5
 2201 0332 61 05                   		cmp	#0, r5
 2202 0334 20 22                   		beq	.L155
1120:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 2203                             		.loc 2 1120 12
 2204 0336 EC A5                   		mov.L	[r10], r5
 2205 0338 75 05 92                		cmp	#-110, r5
 2206 033b 10                      		beq	.L156
1121:../src/wolfcrypt/src/dsa.c ****             mp_clear(w);
 2207                             		.loc 2 1121 13
 2208 033c ED A1 01                		mov.L	4[r10], r1
 2209 033f 05 00 00 00             		bsr	_sp_clear
 2210                             	.L156:
 2211                             	.LBB15:
1122:../src/wolfcrypt/src/dsa.c ****         XFREE(w, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 2212                             		.loc 2 1122 9
 2213 0343 ED A5 01                		mov.L	4[r10], r5
 2214 0346 E7 A5 0C                		mov.L	r5, 48[r10]
 2215 0349 ED A5 0C                		mov.L	48[r10], r5
 2216 034c 61 05                   		cmp	#0, r5
 2217 034e 10                      		beq	.L155
 2218                             		.loc 2 1122 9 is_stmt 0 discriminator 1
 2219 034f ED A1 0C                		mov.L	48[r10], r1
 2220 0352 05 00 00 00             		bsr	_wolfSSL_Free
 2221                             	.L155:
 2222                             	.LBE15:
1123:../src/wolfcrypt/src/dsa.c ****     }
1124:../src/wolfcrypt/src/dsa.c ****     if (v) {
 2223                             		.loc 2 1124 8 is_stmt 1
 2224 0356 ED A5 04                		mov.L	16[r10], r5
 2225 0359 61 05                   		cmp	#0, r5
 2226 035b 20 22                   		beq	.L157
1125:../src/wolfcrypt/src/dsa.c ****         if (ret != MP_INIT_E)
 2227                             		.loc 2 1125 12
 2228 035d EC A5                   		mov.L	[r10], r5
 2229 035f 75 05 92                		cmp	#-110, r5
 2230 0362 10                      		beq	.L158
1126:../src/wolfcrypt/src/dsa.c ****             mp_clear(v);
 2231                             		.loc 2 1126 13
 2232 0363 ED A1 04                		mov.L	16[r10], r1
 2233 0366 05 00 00 00             		bsr	_sp_clear
 2234                             	.L158:
 2235                             	.LBB16:
1127:../src/wolfcrypt/src/dsa.c ****         XFREE(v, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 2236                             		.loc 2 1127 9
 2237 036a ED A5 04                		mov.L	16[r10], r5
 2238 036d E7 A5 0D                		mov.L	r5, 52[r10]
 2239 0370 ED A5 0D                		mov.L	52[r10], r5
 2240 0373 61 05                   		cmp	#0, r5
 2241 0375 10                      		beq	.L157
 2242                             		.loc 2 1127 9 is_stmt 0 discriminator 1
 2243 0376 ED A1 0D                		mov.L	52[r10], r1
 2244 0379 05 00 00 00             		bsr	_wolfSSL_Free
 2245                             	.L157:
 2246                             	.LBE16:
1128:../src/wolfcrypt/src/dsa.c ****     }
1129:../src/wolfcrypt/src/dsa.c **** #else
1130:../src/wolfcrypt/src/dsa.c ****     if (ret != MP_INIT_E) {
1131:../src/wolfcrypt/src/dsa.c ****         mp_clear(s);
1132:../src/wolfcrypt/src/dsa.c ****         mp_clear(r);
1133:../src/wolfcrypt/src/dsa.c ****         mp_clear(u1);
1134:../src/wolfcrypt/src/dsa.c ****         mp_clear(u2);
1135:../src/wolfcrypt/src/dsa.c ****         mp_clear(w);
1136:../src/wolfcrypt/src/dsa.c ****         mp_clear(v);
1137:../src/wolfcrypt/src/dsa.c ****     }
1138:../src/wolfcrypt/src/dsa.c **** #endif
1139:../src/wolfcrypt/src/dsa.c **** 
1140:../src/wolfcrypt/src/dsa.c ****     return ret;
 2247                             		.loc 2 1140 12 is_stmt 1
 2248 037d EC A5                   		mov.L	[r10], r5
 2249                             	.L128:
1141:../src/wolfcrypt/src/dsa.c **** }
 2250                             		.loc 2 1141 1
 2251 037f EF 51                   		mov.L	r5, r1
 2252 0381 3F AA 15                		rtsd	#84, r10-r10
 2253                             	.LFE53:
 2563                             	.Letext0:
 2564                             		.file 3 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\lib\\gcc\\rx-
 2565                             		.file 4 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2566                             		.file 5 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2567                             		.file 6 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2568                             		.file 7 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2569                             		.file 8 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/types.h"
 2570                             		.file 9 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2571                             		.file 10 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\incl
 2572                             		.file 11 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/random.h"
 2573                             		.file 12 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sp_int.h"
 2574                             		.file 13 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/wolfmath.h"
 2575                             		.file 14 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/error-crypt.h"
 2576                             		.file 15 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha.h"
 2577                             		.file 16 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/dsa.h"
