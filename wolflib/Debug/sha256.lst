   1                             		.file	"sha256.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.section	.text.rotlFixed,"ax",@progbits
   6                             	_rotlFixed:
   7                             	.LFB1:
   8                             		.file 1 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfcrypt/src/misc.c"
   1:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* misc.c
   2:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   3:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   5:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * This file is part of wolfSSL.
   6:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   7:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * it under the terms of the GNU General Public License as published by
   9:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * (at your option) any later version.
  11:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  12:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * GNU General Public License for more details.
  16:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  17:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * You should have received a copy of the GNU General Public License
  18:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * along with this program; if not, write to the Free Software
  19:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  21:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /*
  22:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  23:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** DESCRIPTION
  24:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** This module implements the arithmetic-shift right, left, byte swapping, XOR,
  25:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** masking and clearing memory logic.
  26:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  27:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** */
  28:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef HAVE_CONFIG_H
  29:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <config.h>
  30:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  31:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  32:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/settings.h>
  33:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  34:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLF_CRYPT_MISC_C
  35:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #define WOLF_CRYPT_MISC_C
  36:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  37:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/misc.h>
  38:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  39:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* inlining these functions is a huge speed increase and a small size decrease,
  40:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    because the functions are smaller than function call setup/cleanup, e.g.,
  41:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    md5 benchmark is twice as fast with inline.  If you don't want it, then
  42:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    define NO_INLINE and compile this file into wolfssl, otherwise it's used as
  43:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    a source header
  44:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  45:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  46:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef NO_INLINE
  47:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC
  48:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  49:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC static
  50:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  51:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  52:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Check for if compiling misc.c when not needed. */
  53:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if !defined(WOLFSSL_MISC_INCLUDED) && !defined(NO_INLINE)
  54:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_IGNORE_FILE_WARN
  55:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #warning misc.c does not need to be compiled when using inline (NO_INLINE not defined)
  56:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
  57:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  58:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  59:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  60:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  61:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__ICCARM__)
  62:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <intrinsics.h>
  63:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  64:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  65:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  66:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef INTEL_INTRINSICS
  67:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  68:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <stdlib.h>      /* get intrinsic definitions */
  69:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  70:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* for non visual studio probably need no long version, 32 bit only
  71:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****      * i.e., _rotl and _rotr */
  72:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #pragma intrinsic(_lrotl, _lrotr)
  73:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  74:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  75:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  76:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotl(x, y) : x;
  77:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  78:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  79:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
  80:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  81:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotr(x, y) : x;
  82:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  83:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  84:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
  85:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  86:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <builtin.h>      /* get intrinsic definitions */
  87:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  88:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if !defined(NO_INLINE)
  89:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  90:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotlFixed(x, y) _builtin_rotl(x, y)
  91:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  92:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotrFixed(x, y) _builtin_rotr(x, y)
  93:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  94:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #else /* create real function */
  95:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  96:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  97:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  98:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotl(x, y);
  99:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 100:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 101:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 102:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 103:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotr(x, y);
 104:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 105:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 106:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 107:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 108:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else /* generic */
 109:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value. */
 110:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 111:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
 112:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
   9                             		.loc 1 112 5
  10 0000 6E 7A                   		pushm	r7-r10
  11                             	.LCFI0:
  12 0002 71 0A F8                		add	#-8, r0, r10
  13                             	.LCFI1:
  14 0005 EF A0                   		mov.L	r10, r0
  15 0007 E3 A1                   		mov.L	r1, [r10]
  16 0009 E7 A2 01                		mov.L	r2, 4[r10]
 113:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x << y) | (x >> (sizeof(y) * 8 - y));
  17                             		.loc 1 113 25
  18 000c EC A4                   		mov.L	[r10], r4
  19 000e ED A5 01                		mov.L	4[r10], r5
  20 0011 EF 47                   		mov.L	r4, r7
  21 0013 FD 66 57                		rotl	r5, r7
  22 0016 EF 75                   		mov.L	r7, r5
 114:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  23                             		.loc 1 114 5
  24 0018 EF 51                   		mov.L	r5, r1
  25 001a 3F 7A 06                		rtsd	#24, r7-r10
  26                             	.LFE1:
  28                             		.section	.text.rotrFixed,"ax",@progbits
  30                             	_rotrFixed:
  31                             	.LFB2:
 115:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 116:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value. */
 117:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 118:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  32                             		.loc 1 118 5
  33 0000 6E 7A                   		pushm	r7-r10
  34                             	.LCFI2:
  35 0002 71 0A F8                		add	#-8, r0, r10
  36                             	.LCFI3:
  37 0005 EF A0                   		mov.L	r10, r0
  38 0007 E3 A1                   		mov.L	r1, [r10]
  39 0009 E7 A2 01                		mov.L	r2, 4[r10]
 119:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x >> y) | (x << (sizeof(y) * 8 - y));
  40                             		.loc 1 119 25
  41 000c EC A4                   		mov.L	[r10], r4
  42 000e ED A5 01                		mov.L	4[r10], r5
  43 0011 EF 47                   		mov.L	r4, r7
  44 0013 FD 64 57                		rotr	r5, r7
  45 0016 EF 75                   		mov.L	r7, r5
 120:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  46                             		.loc 1 120 5
  47 0018 EF 51                   		mov.L	r5, r1
  48 001a 3F 7A 06                		rtsd	#24, r7-r10
  49                             	.LFE2:
  51                             		.section	.text.ByteReverseWord32,"ax",@progbits
  53                             	_ByteReverseWord32:
  54                             	.LFB3:
 121:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 122:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 123:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 124:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef WC_RC2
 125:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 126:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value */
 127:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotlFixed16(word16 x, word16 y)
 128:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 129:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 130:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 131:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 132:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 133:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value */
 134:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotrFixed16(word16 x, word16 y)
 135:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 136:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 137:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 138:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 139:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WC_RC2 */
 140:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 141:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of 32-bit word value. */
 142:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__CCRX__) && !defined(NO_INLINE) /* shortest version for CC-RX */
 143:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define ByteReverseWord32(value) _builtin_revl(value)
 144:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 145:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word32 ByteReverseWord32(word32 value)
 146:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
  55                             		.loc 1 146 1
  56 0000 7E AA                   		push.l	r10
  57                             	.LCFI4:
  58 0002 71 0A FC                		add	#-4, r0, r10
  59                             	.LCFI5:
  60 0005 EF A0                   		mov.L	r10, r0
  61 0007 E3 A1                   		mov.L	r1, [r10]
 147:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef PPC_INTRINSICS
 148:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* PPC: load reverse indexed instruction */
 149:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__lwbrx(&value,0);
 150:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__ICCARM__)
 151:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__REV(value);
 152:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(KEIL_INTRINSICS)
 153:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__rev(value);
 154:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
 155:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)_builtin_revl(value);
 156:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLF_ALLOW_BUILTIN) && \
 157:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 158:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__builtin_bswap32(value);
 159:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 160:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       defined(__aarch64__)
 161:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 162:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV32 %0, %0  \n"
 163:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 164:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 165:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 166:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 167:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 168:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       (defined(__thumb__) || defined(__arm__))
 169:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 170:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV %0, %0  \n"
 171:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 172:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 173:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 174:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 175:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(FAST_ROTATE)
 176:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 5 instructions with rotate instruction, 9 without */
 177:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (rotrFixed(value, 8U) & 0xff00ff00) |
 178:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****            (rotlFixed(value, 8U) & 0x00ff00ff);
 179:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 180:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 6 instructions with rotate instruction, 8 without */
 181:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
  62                             		.loc 1 181 35
  63 0009 EC A5                   		mov.L	[r10], r5
  64 000b 68 85                   		shlr	#8, r5
  65 000d FB 42 FF 00 FF 00       		mov.L	#0xff00ff, r4
  66 0013 53 54                   		and	r5, r4
  67                             		.loc 1 181 65
  68 0015 EC A5                   		mov.L	[r10], r5
  69 0017 6C 85                   		shll	#8, r5
  70 0019 74 25 00 FF 00 FF       		and	#-16711936, r5
  71                             		.loc 1 181 11
  72 001f 57 45                   		or	r4, r5
  73 0021 E3 A5                   		mov.L	r5, [r10]
 182:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed(value, 16U);
  74                             		.loc 1 182 12
  75 0023 75 42 10                		mov.L	#16, r2
  76 0026 EC A1                   		mov.L	[r10], r1
  77 0028 05 00 00 00             		bsr	_rotlFixed
  78 002c EF 15                   		mov.L	r1, r5
 183:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 184:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
  79                             		.loc 1 184 1
  80 002e EF 51                   		mov.L	r5, r1
  81 0030 3F AA 02                		rtsd	#8, r10-r10
  82                             	.LFE3:
  84                             		.section	.text.ByteReverseWords,"ax",@progbits
  86                             	_ByteReverseWords:
  87                             	.LFB4:
 185:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* __CCRX__ */
 186:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of words array of a given count. */
 187:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords(word32* out, const word32* in,
 188:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                     word32 byteCount)
 189:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
  88                             		.loc 1 189 1
  89 0000 7E AA                   		push.l	r10
  90                             	.LCFI6:
  91 0002 7E A6                   		push.l	r6
  92                             	.LCFI7:
  93 0004 71 0A EC                		add	#-20, r0, r10
  94                             	.LCFI8:
  95 0007 EF A0                   		mov.L	r10, r0
  96 0009 E7 A1 02                		mov.L	r1, 8[r10]
  97 000c E7 A2 03                		mov.L	r2, 12[r10]
  98 000f E7 A3 04                		mov.L	r3, 16[r10]
 190:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word32), i;
  99                             		.loc 1 190 12
 100 0012 ED A5 04                		mov.L	16[r10], r5
 101 0015 68 25                   		shlr	#2, r5
 102 0017 E7 A5 01                		mov.L	r5, 4[r10]
 191:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 192:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 103                             		.loc 1 192 12
 104 001a F8 A6 00                		mov.L	#0, [r10]
 105                             		.loc 1 192 5
 106 001d 2E 27                   		bra	.L8
 107                             	.L9:
 193:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord32(in[i]);
 108                             		.loc 1 193 38 discriminator 3
 109 001f EC A5                   		mov.L	[r10], r5
 110 0021 6C 25                   		shll	#2, r5
 111 0023 ED A4 03                		mov.L	12[r10], r4
 112 0026 4B 45                   		add	r4, r5
 113                             		.loc 1 193 18 discriminator 3
 114 0028 EC 53                   		mov.L	[r5], r3
 115                             		.loc 1 193 12 discriminator 3
 116 002a EC A5                   		mov.L	[r10], r5
 117 002c 6C 25                   		shll	#2, r5
 118 002e ED A4 02                		mov.L	8[r10], r4
 119 0031 FF 26 54                		add	r5, r4, r6
 120                             		.loc 1 193 18 discriminator 3
 121 0034 EF 31                   		mov.L	r3, r1
 122 0036 05 00 00 00             		bsr	_ByteReverseWord32
 123 003a EF 15                   		mov.L	r1, r5
 124                             		.loc 1 193 16 discriminator 3
 125 003c E3 65                   		mov.L	r5, [r6]
 192:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord32(in[i]);
 126                             		.loc 1 192 29 discriminator 3
 127 003e EC A5                   		mov.L	[r10], r5
 128 0040 62 15                   		add	#1, r5
 129 0042 E3 A5                   		mov.L	r5, [r10]
 130                             	.L8:
 192:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord32(in[i]);
 131                             		.loc 1 192 5 discriminator 1
 132 0044 EC A4                   		mov.L	[r10], r4
 133 0046 ED A5 01                		mov.L	4[r10], r5
 134 0049 47 54                   		cmp	r5, r4
 135 004b 23 D4                   		bltu	.L9
 194:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 195:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 136                             		.loc 1 195 1
 137 004d 03                      		nop
 138 004e 71 00 14                		add	#20, r0
 139 0051 7E B6                   		pop	r6
 140 0053 7E BA                   		pop	r10
 141 0055 02                      		rts
 142                             	.LFE4:
 144                             		.section	.text.min,"ax",@progbits
 146                             	_min:
 147                             	.LFB15:
 196:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 197:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WORD64_AVAILABLE) && !defined(WOLFSSL_NO_WORD64_OPS)
 198:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 199:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 200:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotlFixed64(word64 x, word64 y)
 201:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 202:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 203:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 204:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 205:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 206:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotrFixed64(word64 x, word64 y)
 207:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 208:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 209:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 210:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 211:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 212:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 ByteReverseWord64(word64 value)
 213:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 214:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WOLF_ALLOW_BUILTIN) && defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 215:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)__builtin_bswap64(value);
 216:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFCRYPT_SLOW_WORD64)
 217:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)((word64)ByteReverseWord32((word32) value)) << 32 |
 218:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         (word64)ByteReverseWord32((word32)(value   >> 32));
 219:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 220:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) |
 221:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
 222:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) |
 223:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
 224:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed64(value, 32U);
 225:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 226:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 227:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 228:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 229:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords64(word64* out, const word64* in,
 230:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                       word32 byteCount)
 231:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 232:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word64), i;
 233:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 234:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 235:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord64(in[i]);
 236:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 237:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 238:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 239:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WORD64_AVAILABLE && !WOLFSSL_NO_WORD64_OPS */
 240:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 241:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_XOR_OPS
 242:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 243:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 244:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWordsOut(wolfssl_word* r, const wolfssl_word* a,
 245:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                      const wolfssl_word* b, word32 n)
 246:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 247:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 248:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 249:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] = a[i] ^ b[i];
 250:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 251:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 252:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 253:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 254:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 255:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbufout(void*out, const void* buf, const void* mask,
 256:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                    word32 count)
 257:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 258:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)out | (wc_ptr_t)buf | (wc_ptr_t)mask | count) %
 259:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                          WOLFSSL_WORD_SIZE == 0)
 260:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWordsOut( (wolfssl_word*)out, (wolfssl_word*)buf,
 261:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                      (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 262:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 263:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 264:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       o = (byte*)out;
 265:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 266:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 267:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 268:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) o[i] = b[i] ^ m[i];
 269:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 270:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 271:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 272:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 273:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 274:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWords(wolfssl_word* r, const wolfssl_word* a, word32 n)
 275:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 276:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 277:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 278:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] ^= a[i];
 279:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 280:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 281:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 282:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 283:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 284:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbuf(void* buf, const void* mask, word32 count)
 285:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 286:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)buf | (wc_ptr_t)mask | count) % WOLFSSL_WORD_SIZE == 0)
 287:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWords( (wolfssl_word*)buf,
 288:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                   (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 289:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 290:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 291:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 292:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 293:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 294:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) b[i] ^= m[i];
 295:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 296:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 297:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 298:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 299:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_FORCE_ZERO
 300:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine fills the first len bytes of the memory area pointed by mem
 301:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    with zeros. It ensures compiler optimizations doesn't skip it  */
 302:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
 303:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 304:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile byte* z = (volatile byte*)mem;
 305:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 306:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if (defined(WOLFSSL_X86_64_BUILD) || defined(WOLFSSL_AARCH64_BUILD)) \
 307:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****             && defined(WORD64_AVAILABLE)
 308:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile word64* w;
 309:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_UNALIGNED_64BIT_ACCESS
 310:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 l = (sizeof(word64) - ((size_t)z & (sizeof(word64)-1))) &
 311:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                              (sizeof(word64)-1);
 312:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 313:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         if (len < l) l = len;
 314:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         len -= l;
 315:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         while (l--) *z++ = 0;
 316:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 317:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
 318:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         *w++ = 0;
 319:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     z = (volatile byte*)w;
 320:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 321:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 322:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     while (len--) *z++ = 0;
 323:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 324:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 325:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 326:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 327:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_CONST_CMP
 328:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* check all length bytes for equality, return 0 on success */
 329:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ConstantCompare(const byte* a, const byte* b, int length)
 330:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 331:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int i;
 332:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int compareSum = 0;
 333:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 334:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < length; i++) {
 335:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         compareSum |= a[i] ^ b[i];
 336:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 337:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 338:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return compareSum;
 339:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 340:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 341:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 342:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 343:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_HAVE_MIN
 344:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WOLFSSL_HAVE_MIN
 345:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
 346:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #define min min
 347:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 348:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* returns the smaller of a and b */
 349:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 min(word32 a, word32 b)
 350:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 148                             		.loc 1 350 5
 149 0000 7E AA                   		push.l	r10
 150                             	.LCFI9:
 151 0002 71 0A F8                		add	#-8, r0, r10
 152                             	.LCFI10:
 153 0005 EF A0                   		mov.L	r10, r0
 154 0007 E3 A1                   		mov.L	r1, [r10]
 155 0009 E7 A2 01                		mov.L	r2, 4[r10]
 351:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return a > b ? b : a;
 156                             		.loc 1 351 26
 157 000c ED A5 01                		mov.L	4[r10], r5
 158 000f EC A3                   		mov.L	[r10], r3
 159 0011 EC A4                   		mov.L	[r10], r4
 160 0013 47 53                   		cmp	r5, r3
 161 0015 24 04                   		bgtu 1f
 162 0017 EF 45                   		mov r4, r5
 163                             	1:
 352:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 164                             		.loc 1 352 5
 165 0019 EF 51                   		mov.L	r5, r1
 166 001b 3F AA 03                		rtsd	#12, r10-r10
 167                             	.LFE15:
 169                             		.section	.text.InitSha256,"ax",@progbits
 171                             	_InitSha256:
 172                             	.LFB43:
 173                             		.file 2 "../src/wolfcrypt/src/sha256.c"
   1:../src/wolfcrypt/src/sha256.c **** /* sha256.c
   2:../src/wolfcrypt/src/sha256.c ****  *
   3:../src/wolfcrypt/src/sha256.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:../src/wolfcrypt/src/sha256.c ****  *
   5:../src/wolfcrypt/src/sha256.c ****  * This file is part of wolfSSL.
   6:../src/wolfcrypt/src/sha256.c ****  *
   7:../src/wolfcrypt/src/sha256.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:../src/wolfcrypt/src/sha256.c ****  * it under the terms of the GNU General Public License as published by
   9:../src/wolfcrypt/src/sha256.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:../src/wolfcrypt/src/sha256.c ****  * (at your option) any later version.
  11:../src/wolfcrypt/src/sha256.c ****  *
  12:../src/wolfcrypt/src/sha256.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:../src/wolfcrypt/src/sha256.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../src/wolfcrypt/src/sha256.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../src/wolfcrypt/src/sha256.c ****  * GNU General Public License for more details.
  16:../src/wolfcrypt/src/sha256.c ****  *
  17:../src/wolfcrypt/src/sha256.c ****  * You should have received a copy of the GNU General Public License
  18:../src/wolfcrypt/src/sha256.c ****  * along with this program; if not, write to the Free Software
  19:../src/wolfcrypt/src/sha256.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:../src/wolfcrypt/src/sha256.c ****  */
  21:../src/wolfcrypt/src/sha256.c **** 
  22:../src/wolfcrypt/src/sha256.c **** /* For more info on the algorithm, see https://tools.ietf.org/html/rfc6234 */
  23:../src/wolfcrypt/src/sha256.c **** /*
  24:../src/wolfcrypt/src/sha256.c **** 
  25:../src/wolfcrypt/src/sha256.c **** DESCRIPTION
  26:../src/wolfcrypt/src/sha256.c **** This library provides the interface to SHA-256 secure hash algorithms.
  27:../src/wolfcrypt/src/sha256.c **** SHA-256 performs processing on message blocks to produce a final hash digest
  28:../src/wolfcrypt/src/sha256.c **** output. It can be used to hash a message, M, having a length of L bits,
  29:../src/wolfcrypt/src/sha256.c **** where 0 <= L < 2^64.
  30:../src/wolfcrypt/src/sha256.c **** 
  31:../src/wolfcrypt/src/sha256.c **** */
  32:../src/wolfcrypt/src/sha256.c **** #ifdef HAVE_CONFIG_H
  33:../src/wolfcrypt/src/sha256.c ****     #include <config.h>
  34:../src/wolfcrypt/src/sha256.c **** #endif
  35:../src/wolfcrypt/src/sha256.c **** 
  36:../src/wolfcrypt/src/sha256.c **** #include <wolfssl/wolfcrypt/settings.h>
  37:../src/wolfcrypt/src/sha256.c **** 
  38:../src/wolfcrypt/src/sha256.c **** /*
  39:../src/wolfcrypt/src/sha256.c ****  * SHA256 Build Options:
  40:../src/wolfcrypt/src/sha256.c ****  * USE_SLOW_SHA256:            Reduces code size by not partially unrolling
  41:../src/wolfcrypt/src/sha256.c ****                                 (~2KB smaller and ~25% slower) (default OFF)
  42:../src/wolfcrypt/src/sha256.c ****  * WOLFSSL_SHA256_BY_SPEC:     Uses the Ch/Maj based on SHA256 specification
  43:../src/wolfcrypt/src/sha256.c ****                                 (default ON)
  44:../src/wolfcrypt/src/sha256.c ****  * WOLFSSL_SHA256_ALT_CH_MAJ:  Alternate Ch/Maj that is easier for compilers to
  45:../src/wolfcrypt/src/sha256.c ****                                 optimize and recognize as SHA256 (default OFF)
  46:../src/wolfcrypt/src/sha256.c ****  * SHA256_MANY_REGISTERS:      A SHA256 version that keeps all data in registers
  47:../src/wolfcrypt/src/sha256.c ****                                 and partial unrolled (default OFF)
  48:../src/wolfcrypt/src/sha256.c ****  */
  49:../src/wolfcrypt/src/sha256.c **** 
  50:../src/wolfcrypt/src/sha256.c **** /* Default SHA256 to use Ch/Maj based on specification */
  51:../src/wolfcrypt/src/sha256.c **** #if !defined(WOLFSSL_SHA256_BY_SPEC) && !defined(WOLFSSL_SHA256_ALT_CH_MAJ)
  52:../src/wolfcrypt/src/sha256.c ****     #define WOLFSSL_SHA256_BY_SPEC
  53:../src/wolfcrypt/src/sha256.c **** #endif
  54:../src/wolfcrypt/src/sha256.c **** 
  55:../src/wolfcrypt/src/sha256.c **** 
  56:../src/wolfcrypt/src/sha256.c **** #if !defined(NO_SHA256) && !defined(WOLFSSL_ARMASM)
  57:../src/wolfcrypt/src/sha256.c **** 
  58:../src/wolfcrypt/src/sha256.c **** #if defined(HAVE_FIPS) && defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)
  59:../src/wolfcrypt/src/sha256.c ****     /* set NO_WRAPPERS before headers, use direct internal f()s not wrappers */
  60:../src/wolfcrypt/src/sha256.c ****     #define FIPS_NO_WRAPPERS
  61:../src/wolfcrypt/src/sha256.c **** 
  62:../src/wolfcrypt/src/sha256.c ****     #ifdef USE_WINDOWS_API
  63:../src/wolfcrypt/src/sha256.c ****         #pragma code_seg(".fipsA$d")
  64:../src/wolfcrypt/src/sha256.c ****         #pragma const_seg(".fipsB$d")
  65:../src/wolfcrypt/src/sha256.c ****     #endif
  66:../src/wolfcrypt/src/sha256.c **** #endif
  67:../src/wolfcrypt/src/sha256.c **** 
  68:../src/wolfcrypt/src/sha256.c **** #include <wolfssl/wolfcrypt/sha256.h>
  69:../src/wolfcrypt/src/sha256.c **** #include <wolfssl/wolfcrypt/error-crypt.h>
  70:../src/wolfcrypt/src/sha256.c **** #include <wolfssl/wolfcrypt/cpuid.h>
  71:../src/wolfcrypt/src/sha256.c **** #include <wolfssl/wolfcrypt/hash.h>
  72:../src/wolfcrypt/src/sha256.c **** 
  73:../src/wolfcrypt/src/sha256.c **** #ifdef WOLF_CRYPTO_CB
  74:../src/wolfcrypt/src/sha256.c ****     #include <wolfssl/wolfcrypt/cryptocb.h>
  75:../src/wolfcrypt/src/sha256.c **** #endif
  76:../src/wolfcrypt/src/sha256.c **** 
  77:../src/wolfcrypt/src/sha256.c **** /* fips wrapper calls, user can call direct */
  78:../src/wolfcrypt/src/sha256.c **** #if defined(HAVE_FIPS) && \
  79:../src/wolfcrypt/src/sha256.c ****     (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION < 2))
  80:../src/wolfcrypt/src/sha256.c **** 
  81:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256(wc_Sha256* sha)
  82:../src/wolfcrypt/src/sha256.c ****     {
  83:../src/wolfcrypt/src/sha256.c ****         if (sha == NULL) {
  84:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
  85:../src/wolfcrypt/src/sha256.c ****         }
  86:../src/wolfcrypt/src/sha256.c ****         return InitSha256_fips(sha);
  87:../src/wolfcrypt/src/sha256.c ****     }
  88:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256_ex(wc_Sha256* sha, void* heap, int devId)
  89:../src/wolfcrypt/src/sha256.c ****     {
  90:../src/wolfcrypt/src/sha256.c ****         (void)heap;
  91:../src/wolfcrypt/src/sha256.c ****         (void)devId;
  92:../src/wolfcrypt/src/sha256.c ****         if (sha == NULL) {
  93:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
  94:../src/wolfcrypt/src/sha256.c ****         }
  95:../src/wolfcrypt/src/sha256.c ****         return InitSha256_fips(sha);
  96:../src/wolfcrypt/src/sha256.c ****     }
  97:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256Update(wc_Sha256* sha, const byte* data, word32 len)
  98:../src/wolfcrypt/src/sha256.c ****     {
  99:../src/wolfcrypt/src/sha256.c ****         if (sha == NULL ||  (data == NULL && len > 0)) {
 100:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 101:../src/wolfcrypt/src/sha256.c ****         }
 102:../src/wolfcrypt/src/sha256.c **** 
 103:../src/wolfcrypt/src/sha256.c ****         if (data == NULL && len == 0) {
 104:../src/wolfcrypt/src/sha256.c ****             /* valid, but do nothing */
 105:../src/wolfcrypt/src/sha256.c ****             return 0;
 106:../src/wolfcrypt/src/sha256.c ****         }
 107:../src/wolfcrypt/src/sha256.c **** 
 108:../src/wolfcrypt/src/sha256.c ****         return Sha256Update_fips(sha, data, len);
 109:../src/wolfcrypt/src/sha256.c ****     }
 110:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256Final(wc_Sha256* sha, byte* out)
 111:../src/wolfcrypt/src/sha256.c ****     {
 112:../src/wolfcrypt/src/sha256.c ****         if (sha == NULL || out == NULL) {
 113:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 114:../src/wolfcrypt/src/sha256.c ****         }
 115:../src/wolfcrypt/src/sha256.c ****         return Sha256Final_fips(sha, out);
 116:../src/wolfcrypt/src/sha256.c ****     }
 117:../src/wolfcrypt/src/sha256.c ****     void wc_Sha256Free(wc_Sha256* sha)
 118:../src/wolfcrypt/src/sha256.c ****     {
 119:../src/wolfcrypt/src/sha256.c ****         (void)sha;
 120:../src/wolfcrypt/src/sha256.c ****         /* Not supported in FIPS */
 121:../src/wolfcrypt/src/sha256.c ****     }
 122:../src/wolfcrypt/src/sha256.c **** 
 123:../src/wolfcrypt/src/sha256.c **** #else /* else build without fips, or for FIPS v2 */
 124:../src/wolfcrypt/src/sha256.c **** 
 125:../src/wolfcrypt/src/sha256.c **** 
 126:../src/wolfcrypt/src/sha256.c **** #if defined(WOLFSSL_TI_HASH)
 127:../src/wolfcrypt/src/sha256.c ****     /* #include <wolfcrypt/src/port/ti/ti-hash.c> included by wc_port.c */
 128:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_CRYPTOCELL)
 129:../src/wolfcrypt/src/sha256.c ****     /* wc_port.c includes wolfcrypt/src/port/arm/cryptoCellHash.c */
 130:../src/wolfcrypt/src/sha256.c **** 
 131:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_PSOC6_CRYPTO)
 132:../src/wolfcrypt/src/sha256.c **** 
 133:../src/wolfcrypt/src/sha256.c **** 
 134:../src/wolfcrypt/src/sha256.c **** #else
 135:../src/wolfcrypt/src/sha256.c **** 
 136:../src/wolfcrypt/src/sha256.c **** #include <wolfssl/wolfcrypt/logging.h>
 137:../src/wolfcrypt/src/sha256.c **** 
 138:../src/wolfcrypt/src/sha256.c **** #ifdef NO_INLINE
 139:../src/wolfcrypt/src/sha256.c ****     #include <wolfssl/wolfcrypt/misc.h>
 140:../src/wolfcrypt/src/sha256.c **** #else
 141:../src/wolfcrypt/src/sha256.c ****     #define WOLFSSL_MISC_INCLUDED
 142:../src/wolfcrypt/src/sha256.c ****     #include <wolfcrypt/src/misc.c>
 143:../src/wolfcrypt/src/sha256.c **** #endif
 144:../src/wolfcrypt/src/sha256.c **** 
 145:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_DEVCRYPTO_HASH
 146:../src/wolfcrypt/src/sha256.c ****     #include <wolfssl/wolfcrypt/port/devcrypto/wc_devcrypto.h>
 147:../src/wolfcrypt/src/sha256.c **** #endif
 148:../src/wolfcrypt/src/sha256.c **** #if defined(WOLFSSL_SE050) && defined(WOLFSSL_SE050_HASH)
 149:../src/wolfcrypt/src/sha256.c ****     #include <wolfssl/wolfcrypt/port/nxp/se050_port.h>
 150:../src/wolfcrypt/src/sha256.c **** #endif
 151:../src/wolfcrypt/src/sha256.c **** 
 152:../src/wolfcrypt/src/sha256.c **** 
 153:../src/wolfcrypt/src/sha256.c **** #if defined(USE_INTEL_SPEEDUP)
 154:../src/wolfcrypt/src/sha256.c ****     #if defined(__GNUC__) && ((__GNUC__ < 4) || \
 155:../src/wolfcrypt/src/sha256.c ****                               (__GNUC__ == 4 && __GNUC_MINOR__ <= 8))
 156:../src/wolfcrypt/src/sha256.c ****         #undef  NO_AVX2_SUPPORT
 157:../src/wolfcrypt/src/sha256.c ****         #define NO_AVX2_SUPPORT
 158:../src/wolfcrypt/src/sha256.c ****     #endif
 159:../src/wolfcrypt/src/sha256.c ****     #if defined(__clang__) && ((__clang_major__ < 3) || \
 160:../src/wolfcrypt/src/sha256.c ****                                (__clang_major__ == 3 && __clang_minor__ <= 5))
 161:../src/wolfcrypt/src/sha256.c ****         #define NO_AVX2_SUPPORT
 162:../src/wolfcrypt/src/sha256.c ****     #elif defined(__clang__) && defined(NO_AVX2_SUPPORT)
 163:../src/wolfcrypt/src/sha256.c ****         #undef NO_AVX2_SUPPORT
 164:../src/wolfcrypt/src/sha256.c ****     #endif
 165:../src/wolfcrypt/src/sha256.c **** 
 166:../src/wolfcrypt/src/sha256.c ****     #define HAVE_INTEL_AVX1
 167:../src/wolfcrypt/src/sha256.c ****     #ifndef NO_AVX2_SUPPORT
 168:../src/wolfcrypt/src/sha256.c ****         #define HAVE_INTEL_AVX2
 169:../src/wolfcrypt/src/sha256.c ****     #endif
 170:../src/wolfcrypt/src/sha256.c **** #else
 171:../src/wolfcrypt/src/sha256.c ****     #undef HAVE_INTEL_AVX1
 172:../src/wolfcrypt/src/sha256.c ****     #undef HAVE_INTEL_AVX2
 173:../src/wolfcrypt/src/sha256.c **** #endif /* USE_INTEL_SPEEDUP */
 174:../src/wolfcrypt/src/sha256.c **** 
 175:../src/wolfcrypt/src/sha256.c **** #if defined(HAVE_INTEL_AVX2)
 176:../src/wolfcrypt/src/sha256.c ****     #define HAVE_INTEL_RORX
 177:../src/wolfcrypt/src/sha256.c **** #endif
 178:../src/wolfcrypt/src/sha256.c **** 
 179:../src/wolfcrypt/src/sha256.c **** 
 180:../src/wolfcrypt/src/sha256.c **** #if !defined(WOLFSSL_PIC32MZ_HASH) && !defined(STM32_HASH_SHA2) && \
 181:../src/wolfcrypt/src/sha256.c ****     (!defined(WOLFSSL_IMX6_CAAM) || defined(NO_IMX6_CAAM_HASH) || \
 182:../src/wolfcrypt/src/sha256.c ****      defined(WOLFSSL_QNX_CAAM)) && \
 183:../src/wolfcrypt/src/sha256.c ****     !defined(WOLFSSL_AFALG_HASH) && !defined(WOLFSSL_DEVCRYPTO_HASH) && \
 184:../src/wolfcrypt/src/sha256.c ****     (!defined(WOLFSSL_ESP32WROOM32_CRYPT) || defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)) && \
 185:../src/wolfcrypt/src/sha256.c ****     (!defined(WOLFSSL_RENESAS_TSIP_CRYPT) || defined(NO_WOLFSSL_RENESAS_TSIP_CRYPT_HASH)) && \
 186:../src/wolfcrypt/src/sha256.c ****     !defined(WOLFSSL_PSOC6_CRYPTO) && !defined(WOLFSSL_IMXRT_DCP) && !defined(WOLFSSL_SILABS_SE_ACC
 187:../src/wolfcrypt/src/sha256.c ****     !defined(WOLFSSL_KCAPI_HASH) && !defined(WOLFSSL_SE050_HASH) && \
 188:../src/wolfcrypt/src/sha256.c ****     (!defined(WOLFSSL_RENESAS_SCEPROTECT) || defined(NO_WOLFSSL_RENESAS_SCEPROTECT_HASH)) && \
 189:../src/wolfcrypt/src/sha256.c ****     (!defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH))
 190:../src/wolfcrypt/src/sha256.c **** 
 191:../src/wolfcrypt/src/sha256.c **** 
 192:../src/wolfcrypt/src/sha256.c **** 
 193:../src/wolfcrypt/src/sha256.c **** static int InitSha256(wc_Sha256* sha256)
 194:../src/wolfcrypt/src/sha256.c **** {
 174                             		.loc 2 194 1
 175 0000 7E AA                   		push.l	r10
 176                             	.LCFI11:
 177 0002 71 0A F8                		add	#-8, r0, r10
 178                             	.LCFI12:
 179 0005 EF A0                   		mov.L	r10, r0
 180 0007 E7 A1 01                		mov.L	r1, 4[r10]
 195:../src/wolfcrypt/src/sha256.c ****     int ret = 0;
 181                             		.loc 2 195 9
 182 000a F8 A6 00                		mov.L	#0, [r10]
 196:../src/wolfcrypt/src/sha256.c **** 
 197:../src/wolfcrypt/src/sha256.c ****     if (sha256 == NULL)
 183                             		.loc 2 197 8
 184 000d ED A5 01                		mov.L	4[r10], r5
 185 0010 61 05                   		cmp	#0, r5
 186 0012 1F                      		bne	.L13
 198:../src/wolfcrypt/src/sha256.c ****         return BAD_FUNC_ARG;
 187                             		.loc 2 198 16
 188 0013 FB 5A 53 FF             		mov.L	#-173, r5
 189 0017 2E 73                   		bra	.L14
 190                             	.L13:
 199:../src/wolfcrypt/src/sha256.c **** 
 200:../src/wolfcrypt/src/sha256.c ****     XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
 191                             		.loc 2 200 5
 192 0019 ED A5 01                		mov.L	4[r10], r5
 193 001c 75 43 20                		mov.L	#32, r3
 194 001f 66 02                   		mov.L	#0, r2
 195 0021 EF 51                   		mov.L	r5, r1
 196 0023 05 00 00 00             		bsr	_memset
 201:../src/wolfcrypt/src/sha256.c ****     sha256->digest[0] = 0x6A09E667L;
 197                             		.loc 2 201 23
 198 0027 ED A5 01                		mov.L	4[r10], r5
 199 002a F8 52 67 E6 09 6A       		mov.L	#0x6a09e667, [r5]
 202:../src/wolfcrypt/src/sha256.c ****     sha256->digest[1] = 0xBB67AE85L;
 200                             		.loc 2 202 23
 201 0030 ED A5 01                		mov.L	4[r10], r5
 202 0033 F9 52 01 85 AE 67 BB    		mov.L	#-1150833019, 4[r5]
 203:../src/wolfcrypt/src/sha256.c ****     sha256->digest[2] = 0x3C6EF372L;
 203                             		.loc 2 203 23
 204 003a ED A5 01                		mov.L	4[r10], r5
 205 003d F9 52 02 72 F3 6E 3C    		mov.L	#0x3c6ef372, 8[r5]
 204:../src/wolfcrypt/src/sha256.c ****     sha256->digest[3] = 0xA54FF53AL;
 206                             		.loc 2 204 23
 207 0044 ED A5 01                		mov.L	4[r10], r5
 208 0047 F9 52 03 3A F5 4F A5    		mov.L	#-1521486534, 12[r5]
 205:../src/wolfcrypt/src/sha256.c ****     sha256->digest[4] = 0x510E527FL;
 209                             		.loc 2 205 23
 210 004e ED A5 01                		mov.L	4[r10], r5
 211 0051 F9 52 04 7F 52 0E 51    		mov.L	#0x510e527f, 16[r5]
 206:../src/wolfcrypt/src/sha256.c ****     sha256->digest[5] = 0x9B05688CL;
 212                             		.loc 2 206 23
 213 0058 ED A5 01                		mov.L	4[r10], r5
 214 005b F9 52 05 8C 68 05 9B    		mov.L	#-1694144372, 20[r5]
 207:../src/wolfcrypt/src/sha256.c ****     sha256->digest[6] = 0x1F83D9ABL;
 215                             		.loc 2 207 23
 216 0062 ED A5 01                		mov.L	4[r10], r5
 217 0065 F9 52 06 AB D9 83 1F    		mov.L	#0x1f83d9ab, 24[r5]
 208:../src/wolfcrypt/src/sha256.c ****     sha256->digest[7] = 0x5BE0CD19L;
 218                             		.loc 2 208 23
 219 006c ED A5 01                		mov.L	4[r10], r5
 220 006f F9 52 07 19 CD E0 5B    		mov.L	#0x5be0cd19, 28[r5]
 209:../src/wolfcrypt/src/sha256.c **** 
 210:../src/wolfcrypt/src/sha256.c ****     sha256->buffLen = 0;
 221                             		.loc 2 210 21
 222 0076 ED A5 01                		mov.L	4[r10], r5
 223 0079 3E D8 00                		mov.L	#0, 96[r5]
 211:../src/wolfcrypt/src/sha256.c ****     sha256->loLen   = 0;
 224                             		.loc 2 211 21
 225 007c ED A5 01                		mov.L	4[r10], r5
 226 007f 3E D9 00                		mov.L	#0, 100[r5]
 212:../src/wolfcrypt/src/sha256.c ****     sha256->hiLen   = 0;
 227                             		.loc 2 212 21
 228 0082 ED A5 01                		mov.L	4[r10], r5
 229 0085 3E DA 00                		mov.L	#0, 104[r5]
 213:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_HASH_FLAGS
 214:../src/wolfcrypt/src/sha256.c ****     sha256->flags = 0;
 215:../src/wolfcrypt/src/sha256.c **** #endif
 216:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_HASH_KEEP
 217:../src/wolfcrypt/src/sha256.c ****     sha256->msg  = NULL;
 218:../src/wolfcrypt/src/sha256.c ****     sha256->len  = 0;
 219:../src/wolfcrypt/src/sha256.c ****     sha256->used = 0;
 220:../src/wolfcrypt/src/sha256.c **** #endif
 221:../src/wolfcrypt/src/sha256.c **** 
 222:../src/wolfcrypt/src/sha256.c **** #ifdef WOLF_CRYPTO_CB
 223:../src/wolfcrypt/src/sha256.c ****     sha256->devId = wc_CryptoCb_DefaultDevID();
 224:../src/wolfcrypt/src/sha256.c **** #endif
 225:../src/wolfcrypt/src/sha256.c **** 
 226:../src/wolfcrypt/src/sha256.c ****     return ret;
 230                             		.loc 2 226 12
 231 0088 EC A5                   		mov.L	[r10], r5
 232                             	.L14:
 227:../src/wolfcrypt/src/sha256.c **** }
 233                             		.loc 2 227 1
 234 008a EF 51                   		mov.L	r5, r1
 235 008c 3F AA 03                		rtsd	#12, r10-r10
 236                             	.LFE43:
 238                             		.section	.text.wc_InitSha256_ex,"ax",@progbits
 239                             		.global	_wc_InitSha256_ex
 241                             	_wc_InitSha256_ex:
 242                             	.LFB44:
 228:../src/wolfcrypt/src/sha256.c **** #endif
 229:../src/wolfcrypt/src/sha256.c **** 
 230:../src/wolfcrypt/src/sha256.c **** 
 231:../src/wolfcrypt/src/sha256.c **** /* Hardware Acceleration */
 232:../src/wolfcrypt/src/sha256.c **** #if defined(USE_INTEL_SPEEDUP) && (defined(HAVE_INTEL_AVX1) || \
 233:../src/wolfcrypt/src/sha256.c ****                                                        defined(HAVE_INTEL_AVX2))
 234:../src/wolfcrypt/src/sha256.c **** 
 235:../src/wolfcrypt/src/sha256.c ****     /* in case intel instructions aren't available, plus we need the K[] global */
 236:../src/wolfcrypt/src/sha256.c ****     #define NEED_SOFT_SHA256
 237:../src/wolfcrypt/src/sha256.c **** 
 238:../src/wolfcrypt/src/sha256.c ****     /*****
 239:../src/wolfcrypt/src/sha256.c ****     Intel AVX1/AVX2 Macro Control Structure
 240:../src/wolfcrypt/src/sha256.c **** 
 241:../src/wolfcrypt/src/sha256.c ****     #define HAVE_INTEL_AVX1
 242:../src/wolfcrypt/src/sha256.c ****     #define HAVE_INTEL_AVX2
 243:../src/wolfcrypt/src/sha256.c **** 
 244:../src/wolfcrypt/src/sha256.c ****     #define HAVE_INTEL_RORX
 245:../src/wolfcrypt/src/sha256.c **** 
 246:../src/wolfcrypt/src/sha256.c **** 
 247:../src/wolfcrypt/src/sha256.c ****     int InitSha256(wc_Sha256* sha256) {
 248:../src/wolfcrypt/src/sha256.c ****          Save/Recover XMM, YMM
 249:../src/wolfcrypt/src/sha256.c ****          ...
 250:../src/wolfcrypt/src/sha256.c ****     }
 251:../src/wolfcrypt/src/sha256.c **** 
 252:../src/wolfcrypt/src/sha256.c ****     #if defined(HAVE_INTEL_AVX1)|| defined(HAVE_INTEL_AVX2)
 253:../src/wolfcrypt/src/sha256.c ****       Transform_Sha256(); Function prototype
 254:../src/wolfcrypt/src/sha256.c ****     #else
 255:../src/wolfcrypt/src/sha256.c ****       Transform_Sha256() {   }
 256:../src/wolfcrypt/src/sha256.c ****       int Sha256Final() {
 257:../src/wolfcrypt/src/sha256.c ****          Save/Recover XMM, YMM
 258:../src/wolfcrypt/src/sha256.c ****          ...
 259:../src/wolfcrypt/src/sha256.c ****       }
 260:../src/wolfcrypt/src/sha256.c ****     #endif
 261:../src/wolfcrypt/src/sha256.c **** 
 262:../src/wolfcrypt/src/sha256.c ****     #if defined(HAVE_INTEL_AVX1)|| defined(HAVE_INTEL_AVX2)
 263:../src/wolfcrypt/src/sha256.c ****         #if defined(HAVE_INTEL_RORX
 264:../src/wolfcrypt/src/sha256.c ****              #define RND with rorx instruction
 265:../src/wolfcrypt/src/sha256.c ****         #else
 266:../src/wolfcrypt/src/sha256.c ****             #define RND
 267:../src/wolfcrypt/src/sha256.c ****         #endif
 268:../src/wolfcrypt/src/sha256.c ****     #endif
 269:../src/wolfcrypt/src/sha256.c **** 
 270:../src/wolfcrypt/src/sha256.c ****     #if defined(HAVE_INTEL_AVX1)
 271:../src/wolfcrypt/src/sha256.c **** 
 272:../src/wolfcrypt/src/sha256.c ****        #define XMM Instructions/inline asm
 273:../src/wolfcrypt/src/sha256.c **** 
 274:../src/wolfcrypt/src/sha256.c ****        int Transform_Sha256() {
 275:../src/wolfcrypt/src/sha256.c ****            Stitched Message Sched/Round
 276:../src/wolfcrypt/src/sha256.c ****         }
 277:../src/wolfcrypt/src/sha256.c **** 
 278:../src/wolfcrypt/src/sha256.c ****     #elif defined(HAVE_INTEL_AVX2)
 279:../src/wolfcrypt/src/sha256.c **** 
 280:../src/wolfcrypt/src/sha256.c ****       #define YMM Instructions/inline asm
 281:../src/wolfcrypt/src/sha256.c **** 
 282:../src/wolfcrypt/src/sha256.c ****       int Transform_Sha256() {
 283:../src/wolfcrypt/src/sha256.c ****           More granular Stitched Message Sched/Round
 284:../src/wolfcrypt/src/sha256.c ****       }
 285:../src/wolfcrypt/src/sha256.c **** 
 286:../src/wolfcrypt/src/sha256.c ****     #endif
 287:../src/wolfcrypt/src/sha256.c **** 
 288:../src/wolfcrypt/src/sha256.c ****     */
 289:../src/wolfcrypt/src/sha256.c **** 
 290:../src/wolfcrypt/src/sha256.c ****     /* Each platform needs to query info type 1 from cpuid to see if aesni is
 291:../src/wolfcrypt/src/sha256.c ****      * supported. Also, let's setup a macro for proper linkage w/o ABI conflicts
 292:../src/wolfcrypt/src/sha256.c ****      */
 293:../src/wolfcrypt/src/sha256.c **** 
 294:../src/wolfcrypt/src/sha256.c ****     /* #if defined(HAVE_INTEL_AVX1/2) at the tail of sha256 */
 295:../src/wolfcrypt/src/sha256.c ****     static int Transform_Sha256(wc_Sha256* sha256, const byte* data);
 296:../src/wolfcrypt/src/sha256.c **** 
 297:../src/wolfcrypt/src/sha256.c **** #ifdef __cplusplus
 298:../src/wolfcrypt/src/sha256.c ****     extern "C" {
 299:../src/wolfcrypt/src/sha256.c **** #endif
 300:../src/wolfcrypt/src/sha256.c **** 
 301:../src/wolfcrypt/src/sha256.c ****     #if defined(HAVE_INTEL_AVX1)
 302:../src/wolfcrypt/src/sha256.c ****         extern int Transform_Sha256_AVX1(wc_Sha256 *sha256, const byte* data);
 303:../src/wolfcrypt/src/sha256.c ****         extern int Transform_Sha256_AVX1_Len(wc_Sha256* sha256,
 304:../src/wolfcrypt/src/sha256.c ****                                              const byte* data, word32 len);
 305:../src/wolfcrypt/src/sha256.c ****     #endif
 306:../src/wolfcrypt/src/sha256.c ****     #if defined(HAVE_INTEL_AVX2)
 307:../src/wolfcrypt/src/sha256.c ****         extern int Transform_Sha256_AVX2(wc_Sha256 *sha256, const byte* data);
 308:../src/wolfcrypt/src/sha256.c ****         extern int Transform_Sha256_AVX2_Len(wc_Sha256* sha256,
 309:../src/wolfcrypt/src/sha256.c ****                                              const byte* data, word32 len);
 310:../src/wolfcrypt/src/sha256.c ****         #ifdef HAVE_INTEL_RORX
 311:../src/wolfcrypt/src/sha256.c ****         extern int Transform_Sha256_AVX1_RORX(wc_Sha256 *sha256, const byte* data);
 312:../src/wolfcrypt/src/sha256.c ****         extern int Transform_Sha256_AVX1_RORX_Len(wc_Sha256* sha256,
 313:../src/wolfcrypt/src/sha256.c ****                                                   const byte* data, word32 len);
 314:../src/wolfcrypt/src/sha256.c ****         extern int Transform_Sha256_AVX2_RORX(wc_Sha256 *sha256, const byte* data);
 315:../src/wolfcrypt/src/sha256.c ****         extern int Transform_Sha256_AVX2_RORX_Len(wc_Sha256* sha256,
 316:../src/wolfcrypt/src/sha256.c ****                                                   const byte* data, word32 len);
 317:../src/wolfcrypt/src/sha256.c ****         #endif /* HAVE_INTEL_RORX */
 318:../src/wolfcrypt/src/sha256.c ****     #endif /* HAVE_INTEL_AVX2 */
 319:../src/wolfcrypt/src/sha256.c **** 
 320:../src/wolfcrypt/src/sha256.c **** #ifdef __cplusplus
 321:../src/wolfcrypt/src/sha256.c ****     }  /* extern "C" */
 322:../src/wolfcrypt/src/sha256.c **** #endif
 323:../src/wolfcrypt/src/sha256.c **** 
 324:../src/wolfcrypt/src/sha256.c ****     static int (*Transform_Sha256_p)(wc_Sha256* sha256, const byte* data);
 325:../src/wolfcrypt/src/sha256.c ****                                                        /* = _Transform_Sha256 */
 326:../src/wolfcrypt/src/sha256.c ****     static int (*Transform_Sha256_Len_p)(wc_Sha256* sha256, const byte* data,
 327:../src/wolfcrypt/src/sha256.c ****                                          word32 len);
 328:../src/wolfcrypt/src/sha256.c ****                                                                     /* = NULL */
 329:../src/wolfcrypt/src/sha256.c ****     static int transform_check = 0;
 330:../src/wolfcrypt/src/sha256.c ****     static word32 intel_flags;
 331:../src/wolfcrypt/src/sha256.c ****     static int Transform_Sha256_is_vectorized = 0;
 332:../src/wolfcrypt/src/sha256.c **** 
 333:../src/wolfcrypt/src/sha256.c ****     static WC_INLINE int inline_XTRANSFORM(wc_Sha256* S, const byte* D) {
 334:../src/wolfcrypt/src/sha256.c ****         int ret;
 335:../src/wolfcrypt/src/sha256.c ****         ret = (*Transform_Sha256_p)(S, D);
 336:../src/wolfcrypt/src/sha256.c ****         return ret;
 337:../src/wolfcrypt/src/sha256.c ****     }
 338:../src/wolfcrypt/src/sha256.c **** #define XTRANSFORM(...) inline_XTRANSFORM(__VA_ARGS__)
 339:../src/wolfcrypt/src/sha256.c **** 
 340:../src/wolfcrypt/src/sha256.c ****     static WC_INLINE int inline_XTRANSFORM_LEN(wc_Sha256* S, const byte* D, word32 L) {
 341:../src/wolfcrypt/src/sha256.c ****         int ret;
 342:../src/wolfcrypt/src/sha256.c ****         ret = (*Transform_Sha256_Len_p)(S, D, L);
 343:../src/wolfcrypt/src/sha256.c ****         return ret;
 344:../src/wolfcrypt/src/sha256.c ****     }
 345:../src/wolfcrypt/src/sha256.c **** #define XTRANSFORM_LEN(...) inline_XTRANSFORM_LEN(__VA_ARGS__)
 346:../src/wolfcrypt/src/sha256.c **** 
 347:../src/wolfcrypt/src/sha256.c ****     static void Sha256_SetTransform(void)
 348:../src/wolfcrypt/src/sha256.c ****     {
 349:../src/wolfcrypt/src/sha256.c **** 
 350:../src/wolfcrypt/src/sha256.c ****         if (transform_check)
 351:../src/wolfcrypt/src/sha256.c ****             return;
 352:../src/wolfcrypt/src/sha256.c **** 
 353:../src/wolfcrypt/src/sha256.c ****         intel_flags = cpuid_get_flags();
 354:../src/wolfcrypt/src/sha256.c **** 
 355:../src/wolfcrypt/src/sha256.c ****     #ifdef HAVE_INTEL_AVX2
 356:../src/wolfcrypt/src/sha256.c ****         if (1 && IS_INTEL_AVX2(intel_flags)) {
 357:../src/wolfcrypt/src/sha256.c ****         #ifdef HAVE_INTEL_RORX
 358:../src/wolfcrypt/src/sha256.c ****             if (IS_INTEL_BMI2(intel_flags)) {
 359:../src/wolfcrypt/src/sha256.c ****                 Transform_Sha256_p = Transform_Sha256_AVX2_RORX;
 360:../src/wolfcrypt/src/sha256.c ****                 Transform_Sha256_Len_p = Transform_Sha256_AVX2_RORX_Len;
 361:../src/wolfcrypt/src/sha256.c ****                 Transform_Sha256_is_vectorized = 1;
 362:../src/wolfcrypt/src/sha256.c ****             }
 363:../src/wolfcrypt/src/sha256.c ****             else
 364:../src/wolfcrypt/src/sha256.c ****         #endif
 365:../src/wolfcrypt/src/sha256.c ****             if (1)
 366:../src/wolfcrypt/src/sha256.c ****             {
 367:../src/wolfcrypt/src/sha256.c ****                 Transform_Sha256_p = Transform_Sha256_AVX2;
 368:../src/wolfcrypt/src/sha256.c ****                 Transform_Sha256_Len_p = Transform_Sha256_AVX2_Len;
 369:../src/wolfcrypt/src/sha256.c ****                 Transform_Sha256_is_vectorized = 1;
 370:../src/wolfcrypt/src/sha256.c ****             }
 371:../src/wolfcrypt/src/sha256.c ****         #ifdef HAVE_INTEL_RORX
 372:../src/wolfcrypt/src/sha256.c ****             else {
 373:../src/wolfcrypt/src/sha256.c ****                 Transform_Sha256_p = Transform_Sha256_AVX1_RORX;
 374:../src/wolfcrypt/src/sha256.c ****                 Transform_Sha256_Len_p = Transform_Sha256_AVX1_RORX_Len;
 375:../src/wolfcrypt/src/sha256.c ****                 Transform_Sha256_is_vectorized = 1;
 376:../src/wolfcrypt/src/sha256.c ****             }
 377:../src/wolfcrypt/src/sha256.c ****         #endif
 378:../src/wolfcrypt/src/sha256.c ****         }
 379:../src/wolfcrypt/src/sha256.c ****         else
 380:../src/wolfcrypt/src/sha256.c ****     #endif
 381:../src/wolfcrypt/src/sha256.c ****     #ifdef HAVE_INTEL_AVX1
 382:../src/wolfcrypt/src/sha256.c ****         if (IS_INTEL_AVX1(intel_flags)) {
 383:../src/wolfcrypt/src/sha256.c ****             Transform_Sha256_p = Transform_Sha256_AVX1;
 384:../src/wolfcrypt/src/sha256.c ****             Transform_Sha256_Len_p = Transform_Sha256_AVX1_Len;
 385:../src/wolfcrypt/src/sha256.c ****             Transform_Sha256_is_vectorized = 1;
 386:../src/wolfcrypt/src/sha256.c ****         }
 387:../src/wolfcrypt/src/sha256.c ****         else
 388:../src/wolfcrypt/src/sha256.c ****     #endif
 389:../src/wolfcrypt/src/sha256.c ****         {
 390:../src/wolfcrypt/src/sha256.c ****             Transform_Sha256_p = Transform_Sha256;
 391:../src/wolfcrypt/src/sha256.c ****             Transform_Sha256_Len_p = NULL;
 392:../src/wolfcrypt/src/sha256.c ****             Transform_Sha256_is_vectorized = 0;
 393:../src/wolfcrypt/src/sha256.c ****         }
 394:../src/wolfcrypt/src/sha256.c **** 
 395:../src/wolfcrypt/src/sha256.c ****         transform_check = 1;
 396:../src/wolfcrypt/src/sha256.c ****     }
 397:../src/wolfcrypt/src/sha256.c **** 
 398:../src/wolfcrypt/src/sha256.c **** #if !defined(WOLFSSL_KCAPI_HASH)
 399:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
 400:../src/wolfcrypt/src/sha256.c ****     {
 401:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 402:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL)
 403:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 404:../src/wolfcrypt/src/sha256.c **** 
 405:../src/wolfcrypt/src/sha256.c ****         sha256->heap = heap;
 406:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLF_CRYPTO_CB
 407:../src/wolfcrypt/src/sha256.c ****         sha256->devId = devId;
 408:../src/wolfcrypt/src/sha256.c ****         sha256->devCtx = NULL;
 409:../src/wolfcrypt/src/sha256.c ****     #endif
 410:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_SMALL_STACK_CACHE
 411:../src/wolfcrypt/src/sha256.c ****         sha256->W = NULL;
 412:../src/wolfcrypt/src/sha256.c ****     #endif
 413:../src/wolfcrypt/src/sha256.c **** 
 414:../src/wolfcrypt/src/sha256.c ****         ret = InitSha256(sha256);
 415:../src/wolfcrypt/src/sha256.c ****         if (ret != 0)
 416:../src/wolfcrypt/src/sha256.c ****             return ret;
 417:../src/wolfcrypt/src/sha256.c **** 
 418:../src/wolfcrypt/src/sha256.c ****         /* choose best Transform function under this runtime environment */
 419:../src/wolfcrypt/src/sha256.c ****         Sha256_SetTransform();
 420:../src/wolfcrypt/src/sha256.c **** 
 421:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
 422:../src/wolfcrypt/src/sha256.c ****         ret = wolfAsync_DevCtxInit(&sha256->asyncDev,
 423:../src/wolfcrypt/src/sha256.c ****                             WOLFSSL_ASYNC_MARKER_SHA256, sha256->heap, devId);
 424:../src/wolfcrypt/src/sha256.c ****     #else
 425:../src/wolfcrypt/src/sha256.c ****         (void)devId;
 426:../src/wolfcrypt/src/sha256.c ****     #endif /* WOLFSSL_ASYNC_CRYPT */
 427:../src/wolfcrypt/src/sha256.c **** 
 428:../src/wolfcrypt/src/sha256.c ****         return ret;
 429:../src/wolfcrypt/src/sha256.c ****     }
 430:../src/wolfcrypt/src/sha256.c **** #endif /* !WOLFSSL_KCAPI_HASH */
 431:../src/wolfcrypt/src/sha256.c **** 
 432:../src/wolfcrypt/src/sha256.c **** #elif defined(FREESCALE_LTC_SHA)
 433:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
 434:../src/wolfcrypt/src/sha256.c ****     {
 435:../src/wolfcrypt/src/sha256.c ****         (void)heap;
 436:../src/wolfcrypt/src/sha256.c ****         (void)devId;
 437:../src/wolfcrypt/src/sha256.c **** 
 438:../src/wolfcrypt/src/sha256.c ****         LTC_HASH_Init(LTC_BASE, &sha256->ctx, kLTC_Sha256, NULL, 0);
 439:../src/wolfcrypt/src/sha256.c **** 
 440:../src/wolfcrypt/src/sha256.c ****         return 0;
 441:../src/wolfcrypt/src/sha256.c ****     }
 442:../src/wolfcrypt/src/sha256.c **** 
 443:../src/wolfcrypt/src/sha256.c **** #elif defined(FREESCALE_MMCAU_SHA)
 444:../src/wolfcrypt/src/sha256.c **** 
 445:../src/wolfcrypt/src/sha256.c ****     #ifdef FREESCALE_MMCAU_CLASSIC_SHA
 446:../src/wolfcrypt/src/sha256.c ****         #include "cau_api.h"
 447:../src/wolfcrypt/src/sha256.c ****     #else
 448:../src/wolfcrypt/src/sha256.c ****         #include "fsl_mmcau.h"
 449:../src/wolfcrypt/src/sha256.c ****     #endif
 450:../src/wolfcrypt/src/sha256.c **** 
 451:../src/wolfcrypt/src/sha256.c ****     #define XTRANSFORM(S, D)         Transform_Sha256((S),(D))
 452:../src/wolfcrypt/src/sha256.c ****     #define XTRANSFORM_LEN(S, D, L)  Transform_Sha256_Len((S),(D),(L))
 453:../src/wolfcrypt/src/sha256.c **** 
 454:../src/wolfcrypt/src/sha256.c ****     #ifndef WC_HASH_DATA_ALIGNMENT
 455:../src/wolfcrypt/src/sha256.c ****         /* these hardware API's require 4 byte (word32) alignment */
 456:../src/wolfcrypt/src/sha256.c ****         #define WC_HASH_DATA_ALIGNMENT 4
 457:../src/wolfcrypt/src/sha256.c ****     #endif
 458:../src/wolfcrypt/src/sha256.c **** 
 459:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
 460:../src/wolfcrypt/src/sha256.c ****     {
 461:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 462:../src/wolfcrypt/src/sha256.c **** 
 463:../src/wolfcrypt/src/sha256.c ****         (void)heap;
 464:../src/wolfcrypt/src/sha256.c ****         (void)devId;
 465:../src/wolfcrypt/src/sha256.c **** 
 466:../src/wolfcrypt/src/sha256.c ****         ret = wolfSSL_CryptHwMutexLock();
 467:../src/wolfcrypt/src/sha256.c ****         if (ret != 0) {
 468:../src/wolfcrypt/src/sha256.c ****             return ret;
 469:../src/wolfcrypt/src/sha256.c ****         }
 470:../src/wolfcrypt/src/sha256.c **** 
 471:../src/wolfcrypt/src/sha256.c ****     #ifdef FREESCALE_MMCAU_CLASSIC_SHA
 472:../src/wolfcrypt/src/sha256.c ****         cau_sha256_initialize_output(sha256->digest);
 473:../src/wolfcrypt/src/sha256.c ****     #else
 474:../src/wolfcrypt/src/sha256.c ****         MMCAU_SHA256_InitializeOutput((uint32_t*)sha256->digest);
 475:../src/wolfcrypt/src/sha256.c ****     #endif
 476:../src/wolfcrypt/src/sha256.c ****         wolfSSL_CryptHwMutexUnLock();
 477:../src/wolfcrypt/src/sha256.c **** 
 478:../src/wolfcrypt/src/sha256.c ****         sha256->buffLen = 0;
 479:../src/wolfcrypt/src/sha256.c ****         sha256->loLen   = 0;
 480:../src/wolfcrypt/src/sha256.c ****         sha256->hiLen   = 0;
 481:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_SMALL_STACK_CACHE
 482:../src/wolfcrypt/src/sha256.c ****         sha256->W = NULL;
 483:../src/wolfcrypt/src/sha256.c ****     #endif
 484:../src/wolfcrypt/src/sha256.c **** 
 485:../src/wolfcrypt/src/sha256.c ****         return ret;
 486:../src/wolfcrypt/src/sha256.c ****     }
 487:../src/wolfcrypt/src/sha256.c **** 
 488:../src/wolfcrypt/src/sha256.c ****     static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
 489:../src/wolfcrypt/src/sha256.c ****     {
 490:../src/wolfcrypt/src/sha256.c ****         int ret = wolfSSL_CryptHwMutexLock();
 491:../src/wolfcrypt/src/sha256.c ****         if (ret == 0) {
 492:../src/wolfcrypt/src/sha256.c ****     #ifdef FREESCALE_MMCAU_CLASSIC_SHA
 493:../src/wolfcrypt/src/sha256.c ****             cau_sha256_hash_n((byte*)data, 1, sha256->digest);
 494:../src/wolfcrypt/src/sha256.c ****     #else
 495:../src/wolfcrypt/src/sha256.c ****             MMCAU_SHA256_HashN((byte*)data, 1, (uint32_t*)sha256->digest);
 496:../src/wolfcrypt/src/sha256.c ****     #endif
 497:../src/wolfcrypt/src/sha256.c ****             wolfSSL_CryptHwMutexUnLock();
 498:../src/wolfcrypt/src/sha256.c ****         }
 499:../src/wolfcrypt/src/sha256.c ****         return ret;
 500:../src/wolfcrypt/src/sha256.c ****     }
 501:../src/wolfcrypt/src/sha256.c **** 
 502:../src/wolfcrypt/src/sha256.c ****     static int Transform_Sha256_Len(wc_Sha256* sha256, const byte* data,
 503:../src/wolfcrypt/src/sha256.c ****         word32 len)
 504:../src/wolfcrypt/src/sha256.c ****     {
 505:../src/wolfcrypt/src/sha256.c ****         int ret = wolfSSL_CryptHwMutexLock();
 506:../src/wolfcrypt/src/sha256.c ****         if (ret == 0) {
 507:../src/wolfcrypt/src/sha256.c ****         #if defined(WC_HASH_DATA_ALIGNMENT) && WC_HASH_DATA_ALIGNMENT > 0
 508:../src/wolfcrypt/src/sha256.c ****             if ((wc_ptr_t)data % WC_HASH_DATA_ALIGNMENT) {
 509:../src/wolfcrypt/src/sha256.c ****                 /* data pointer is NOT aligned,
 510:../src/wolfcrypt/src/sha256.c ****                  * so copy and perform one block at a time */
 511:../src/wolfcrypt/src/sha256.c ****                 byte* local = (byte*)sha256->buffer;
 512:../src/wolfcrypt/src/sha256.c ****                 while (len >= WC_SHA256_BLOCK_SIZE) {
 513:../src/wolfcrypt/src/sha256.c ****                     XMEMCPY(local, data, WC_SHA256_BLOCK_SIZE);
 514:../src/wolfcrypt/src/sha256.c ****                 #ifdef FREESCALE_MMCAU_CLASSIC_SHA
 515:../src/wolfcrypt/src/sha256.c ****                     cau_sha256_hash_n(local, 1, sha256->digest);
 516:../src/wolfcrypt/src/sha256.c ****                 #else
 517:../src/wolfcrypt/src/sha256.c ****                     MMCAU_SHA256_HashN(local, 1, (uint32_t*)sha256->digest);
 518:../src/wolfcrypt/src/sha256.c ****                 #endif
 519:../src/wolfcrypt/src/sha256.c ****                     data += WC_SHA256_BLOCK_SIZE;
 520:../src/wolfcrypt/src/sha256.c ****                     len  -= WC_SHA256_BLOCK_SIZE;
 521:../src/wolfcrypt/src/sha256.c ****                 }
 522:../src/wolfcrypt/src/sha256.c ****             }
 523:../src/wolfcrypt/src/sha256.c ****             else
 524:../src/wolfcrypt/src/sha256.c ****         #endif
 525:../src/wolfcrypt/src/sha256.c ****             {
 526:../src/wolfcrypt/src/sha256.c ****     #ifdef FREESCALE_MMCAU_CLASSIC_SHA
 527:../src/wolfcrypt/src/sha256.c ****             cau_sha256_hash_n((byte*)data, len/WC_SHA256_BLOCK_SIZE,
 528:../src/wolfcrypt/src/sha256.c ****                 sha256->digest);
 529:../src/wolfcrypt/src/sha256.c ****     #else
 530:../src/wolfcrypt/src/sha256.c ****             MMCAU_SHA256_HashN((byte*)data, len/WC_SHA256_BLOCK_SIZE,
 531:../src/wolfcrypt/src/sha256.c ****                 (uint32_t*)sha256->digest);
 532:../src/wolfcrypt/src/sha256.c ****     #endif
 533:../src/wolfcrypt/src/sha256.c ****             }
 534:../src/wolfcrypt/src/sha256.c ****             wolfSSL_CryptHwMutexUnLock();
 535:../src/wolfcrypt/src/sha256.c ****         }
 536:../src/wolfcrypt/src/sha256.c ****         return ret;
 537:../src/wolfcrypt/src/sha256.c ****     }
 538:../src/wolfcrypt/src/sha256.c **** 
 539:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_PIC32MZ_HASH)
 540:../src/wolfcrypt/src/sha256.c ****     #include <wolfssl/wolfcrypt/port/pic32/pic32mz-crypt.h>
 541:../src/wolfcrypt/src/sha256.c **** 
 542:../src/wolfcrypt/src/sha256.c **** #elif defined(STM32_HASH_SHA2)
 543:../src/wolfcrypt/src/sha256.c **** 
 544:../src/wolfcrypt/src/sha256.c ****     /* Supports CubeMX HAL or Standard Peripheral Library */
 545:../src/wolfcrypt/src/sha256.c **** 
 546:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
 547:../src/wolfcrypt/src/sha256.c ****     {
 548:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL)
 549:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 550:../src/wolfcrypt/src/sha256.c **** 
 551:../src/wolfcrypt/src/sha256.c ****         (void)devId;
 552:../src/wolfcrypt/src/sha256.c ****         (void)heap;
 553:../src/wolfcrypt/src/sha256.c **** 
 554:../src/wolfcrypt/src/sha256.c ****         XMEMSET(sha256, 0, sizeof(wc_Sha256));
 555:../src/wolfcrypt/src/sha256.c ****         wc_Stm32_Hash_Init(&sha256->stmCtx);
 556:../src/wolfcrypt/src/sha256.c ****         return 0;
 557:../src/wolfcrypt/src/sha256.c ****     }
 558:../src/wolfcrypt/src/sha256.c **** 
 559:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
 560:../src/wolfcrypt/src/sha256.c ****     {
 561:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 562:../src/wolfcrypt/src/sha256.c **** 
 563:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL || (data == NULL && len > 0)) {
 564:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 565:../src/wolfcrypt/src/sha256.c ****         }
 566:../src/wolfcrypt/src/sha256.c **** 
 567:../src/wolfcrypt/src/sha256.c ****         ret = wolfSSL_CryptHwMutexLock();
 568:../src/wolfcrypt/src/sha256.c ****         if (ret == 0) {
 569:../src/wolfcrypt/src/sha256.c ****             ret = wc_Stm32_Hash_Update(&sha256->stmCtx,
 570:../src/wolfcrypt/src/sha256.c ****                 HASH_AlgoSelection_SHA256, data, len, WC_SHA256_BLOCK_SIZE);
 571:../src/wolfcrypt/src/sha256.c ****             wolfSSL_CryptHwMutexUnLock();
 572:../src/wolfcrypt/src/sha256.c ****         }
 573:../src/wolfcrypt/src/sha256.c ****         return ret;
 574:../src/wolfcrypt/src/sha256.c ****     }
 575:../src/wolfcrypt/src/sha256.c **** 
 576:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
 577:../src/wolfcrypt/src/sha256.c ****     {
 578:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 579:../src/wolfcrypt/src/sha256.c **** 
 580:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL || hash == NULL) {
 581:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 582:../src/wolfcrypt/src/sha256.c ****         }
 583:../src/wolfcrypt/src/sha256.c **** 
 584:../src/wolfcrypt/src/sha256.c ****         ret = wolfSSL_CryptHwMutexLock();
 585:../src/wolfcrypt/src/sha256.c ****         if (ret == 0) {
 586:../src/wolfcrypt/src/sha256.c ****             ret = wc_Stm32_Hash_Final(&sha256->stmCtx,
 587:../src/wolfcrypt/src/sha256.c ****                 HASH_AlgoSelection_SHA256, hash, WC_SHA256_DIGEST_SIZE);
 588:../src/wolfcrypt/src/sha256.c ****             wolfSSL_CryptHwMutexUnLock();
 589:../src/wolfcrypt/src/sha256.c ****         }
 590:../src/wolfcrypt/src/sha256.c **** 
 591:../src/wolfcrypt/src/sha256.c ****         (void)wc_InitSha256(sha256); /* reset state */
 592:../src/wolfcrypt/src/sha256.c **** 
 593:../src/wolfcrypt/src/sha256.c ****         return ret;
 594:../src/wolfcrypt/src/sha256.c ****     }
 595:../src/wolfcrypt/src/sha256.c **** 
 596:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_IMX6_CAAM) && !defined(NO_IMX6_CAAM_HASH) && \
 597:../src/wolfcrypt/src/sha256.c ****     !defined(WOLFSSL_QNX_CAAM)
 598:../src/wolfcrypt/src/sha256.c ****     /* functions defined in wolfcrypt/src/port/caam/caam_sha256.c */
 599:../src/wolfcrypt/src/sha256.c **** 
 600:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_SE050) && defined(WOLFSSL_SE050_HASH)
 601:../src/wolfcrypt/src/sha256.c **** 
 602:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
 603:../src/wolfcrypt/src/sha256.c ****     {
 604:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL) {
 605:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 606:../src/wolfcrypt/src/sha256.c ****         }
 607:../src/wolfcrypt/src/sha256.c ****         (void)devId;
 608:../src/wolfcrypt/src/sha256.c **** 
 609:../src/wolfcrypt/src/sha256.c ****         return se050_hash_init(&sha256->se050Ctx, heap);
 610:../src/wolfcrypt/src/sha256.c ****     }
 611:../src/wolfcrypt/src/sha256.c **** 
 612:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
 613:../src/wolfcrypt/src/sha256.c ****     {
 614:../src/wolfcrypt/src/sha256.c ****         return se050_hash_update(&sha256->se050Ctx, data, len);
 615:../src/wolfcrypt/src/sha256.c ****     }
 616:../src/wolfcrypt/src/sha256.c **** 
 617:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
 618:../src/wolfcrypt/src/sha256.c ****     {
 619:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 620:../src/wolfcrypt/src/sha256.c ****         ret = se050_hash_final(&sha256->se050Ctx, hash, WC_SHA256_DIGEST_SIZE,
 621:../src/wolfcrypt/src/sha256.c ****                                kAlgorithm_SSS_SHA256);
 622:../src/wolfcrypt/src/sha256.c ****         (void)wc_InitSha256(sha256);
 623:../src/wolfcrypt/src/sha256.c ****         return ret;
 624:../src/wolfcrypt/src/sha256.c ****     }
 625:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256FinalRaw(wc_Sha256* sha256, byte* hash)
 626:../src/wolfcrypt/src/sha256.c ****     {
 627:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 628:../src/wolfcrypt/src/sha256.c ****         ret = se050_hash_final(&sha256->se050Ctx, hash, WC_SHA256_DIGEST_SIZE,
 629:../src/wolfcrypt/src/sha256.c ****                                kAlgorithm_SSS_SHA256);
 630:../src/wolfcrypt/src/sha256.c ****         (void)wc_InitSha256(sha256);
 631:../src/wolfcrypt/src/sha256.c ****         return ret;
 632:../src/wolfcrypt/src/sha256.c ****     }
 633:../src/wolfcrypt/src/sha256.c **** 
 634:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_AFALG_HASH)
 635:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/af_alg/afalg_hash.c */
 636:../src/wolfcrypt/src/sha256.c **** 
 637:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_DEVCRYPTO_HASH)
 638:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/devcrypto/devcrypt_hash.c */
 639:../src/wolfcrypt/src/sha256.c **** 
 640:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_SCE) && !defined(WOLFSSL_SCE_NO_HASH)
 641:../src/wolfcrypt/src/sha256.c ****     #include "hal_data.h"
 642:../src/wolfcrypt/src/sha256.c **** 
 643:../src/wolfcrypt/src/sha256.c ****     #ifndef WOLFSSL_SCE_SHA256_HANDLE
 644:../src/wolfcrypt/src/sha256.c ****         #define WOLFSSL_SCE_SHA256_HANDLE g_sce_hash_0
 645:../src/wolfcrypt/src/sha256.c ****     #endif
 646:../src/wolfcrypt/src/sha256.c **** 
 647:../src/wolfcrypt/src/sha256.c ****     #define WC_SHA256_DIGEST_WORD_SIZE 16
 648:../src/wolfcrypt/src/sha256.c ****     #define XTRANSFORM(S, D) wc_Sha256SCE_XTRANSFORM((S), (D))
 649:../src/wolfcrypt/src/sha256.c ****     static int wc_Sha256SCE_XTRANSFORM(wc_Sha256* sha256, const byte* data)
 650:../src/wolfcrypt/src/sha256.c ****     {
 651:../src/wolfcrypt/src/sha256.c ****         if (WOLFSSL_SCE_GSCE_HANDLE.p_cfg->endian_flag ==
 652:../src/wolfcrypt/src/sha256.c ****                 CRYPTO_WORD_ENDIAN_LITTLE)
 653:../src/wolfcrypt/src/sha256.c ****         {
 654:../src/wolfcrypt/src/sha256.c ****             ByteReverseWords((word32*)data, (word32*)data,
 655:../src/wolfcrypt/src/sha256.c ****                     WC_SHA256_BLOCK_SIZE);
 656:../src/wolfcrypt/src/sha256.c ****             ByteReverseWords(sha256->digest, sha256->digest,
 657:../src/wolfcrypt/src/sha256.c ****                     WC_SHA256_DIGEST_SIZE);
 658:../src/wolfcrypt/src/sha256.c ****         }
 659:../src/wolfcrypt/src/sha256.c **** 
 660:../src/wolfcrypt/src/sha256.c ****         if (WOLFSSL_SCE_SHA256_HANDLE.p_api->hashUpdate(
 661:../src/wolfcrypt/src/sha256.c ****                     WOLFSSL_SCE_SHA256_HANDLE.p_ctrl, (word32*)data,
 662:../src/wolfcrypt/src/sha256.c ****                     WC_SHA256_DIGEST_WORD_SIZE, sha256->digest) != SSP_SUCCESS){
 663:../src/wolfcrypt/src/sha256.c ****             WOLFSSL_MSG("Unexpected hardware return value");
 664:../src/wolfcrypt/src/sha256.c ****             return WC_HW_E;
 665:../src/wolfcrypt/src/sha256.c ****         }
 666:../src/wolfcrypt/src/sha256.c **** 
 667:../src/wolfcrypt/src/sha256.c ****         if (WOLFSSL_SCE_GSCE_HANDLE.p_cfg->endian_flag ==
 668:../src/wolfcrypt/src/sha256.c ****                 CRYPTO_WORD_ENDIAN_LITTLE)
 669:../src/wolfcrypt/src/sha256.c ****         {
 670:../src/wolfcrypt/src/sha256.c ****             ByteReverseWords((word32*)data, (word32*)data,
 671:../src/wolfcrypt/src/sha256.c ****                     WC_SHA256_BLOCK_SIZE);
 672:../src/wolfcrypt/src/sha256.c ****             ByteReverseWords(sha256->digest, sha256->digest,
 673:../src/wolfcrypt/src/sha256.c ****                     WC_SHA256_DIGEST_SIZE);
 674:../src/wolfcrypt/src/sha256.c ****         }
 675:../src/wolfcrypt/src/sha256.c **** 
 676:../src/wolfcrypt/src/sha256.c ****         return 0;
 677:../src/wolfcrypt/src/sha256.c ****     }
 678:../src/wolfcrypt/src/sha256.c **** 
 679:../src/wolfcrypt/src/sha256.c **** 
 680:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
 681:../src/wolfcrypt/src/sha256.c ****     {
 682:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 683:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL)
 684:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 685:../src/wolfcrypt/src/sha256.c **** 
 686:../src/wolfcrypt/src/sha256.c ****         sha256->heap = heap;
 687:../src/wolfcrypt/src/sha256.c **** 
 688:../src/wolfcrypt/src/sha256.c ****         ret = InitSha256(sha256);
 689:../src/wolfcrypt/src/sha256.c ****         if (ret != 0)
 690:../src/wolfcrypt/src/sha256.c ****             return ret;
 691:../src/wolfcrypt/src/sha256.c **** 
 692:../src/wolfcrypt/src/sha256.c ****         (void)devId;
 693:../src/wolfcrypt/src/sha256.c **** 
 694:../src/wolfcrypt/src/sha256.c ****         return ret;
 695:../src/wolfcrypt/src/sha256.c ****     }
 696:../src/wolfcrypt/src/sha256.c **** 
 697:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
 698:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
 699:../src/wolfcrypt/src/sha256.c **** 
 700:../src/wolfcrypt/src/sha256.c ****     #define NEED_SOFT_SHA256
 701:../src/wolfcrypt/src/sha256.c **** 
 702:../src/wolfcrypt/src/sha256.c ****     static int InitSha256(wc_Sha256* sha256)
 703:../src/wolfcrypt/src/sha256.c ****     {
 704:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 705:../src/wolfcrypt/src/sha256.c **** 
 706:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL)
 707:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 708:../src/wolfcrypt/src/sha256.c **** 
 709:../src/wolfcrypt/src/sha256.c ****         XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
 710:../src/wolfcrypt/src/sha256.c ****         sha256->digest[0] = 0x6A09E667L;
 711:../src/wolfcrypt/src/sha256.c ****         sha256->digest[1] = 0xBB67AE85L;
 712:../src/wolfcrypt/src/sha256.c ****         sha256->digest[2] = 0x3C6EF372L;
 713:../src/wolfcrypt/src/sha256.c ****         sha256->digest[3] = 0xA54FF53AL;
 714:../src/wolfcrypt/src/sha256.c ****         sha256->digest[4] = 0x510E527FL;
 715:../src/wolfcrypt/src/sha256.c ****         sha256->digest[5] = 0x9B05688CL;
 716:../src/wolfcrypt/src/sha256.c ****         sha256->digest[6] = 0x1F83D9ABL;
 717:../src/wolfcrypt/src/sha256.c ****         sha256->digest[7] = 0x5BE0CD19L;
 718:../src/wolfcrypt/src/sha256.c **** 
 719:../src/wolfcrypt/src/sha256.c ****         sha256->buffLen = 0;
 720:../src/wolfcrypt/src/sha256.c ****         sha256->loLen   = 0;
 721:../src/wolfcrypt/src/sha256.c ****         sha256->hiLen   = 0;
 722:../src/wolfcrypt/src/sha256.c **** 
 723:../src/wolfcrypt/src/sha256.c ****         /* always start firstblock = 1 when using hw engine */
 724:../src/wolfcrypt/src/sha256.c ****         sha256->ctx.isfirstblock = 1;
 725:../src/wolfcrypt/src/sha256.c ****         sha256->ctx.sha_type = SHA2_256;
 726:../src/wolfcrypt/src/sha256.c ****         if(sha256->ctx.mode == ESP32_SHA_HW) {
 727:../src/wolfcrypt/src/sha256.c ****             /* release hw */
 728:../src/wolfcrypt/src/sha256.c ****             esp_sha_hw_unlock();
 729:../src/wolfcrypt/src/sha256.c ****         }
 730:../src/wolfcrypt/src/sha256.c ****         /* always set mode as INIT
 731:../src/wolfcrypt/src/sha256.c ****         *  whether using HW or SW is determined at first call of update()
 732:../src/wolfcrypt/src/sha256.c ****         */
 733:../src/wolfcrypt/src/sha256.c ****         sha256->ctx.mode = ESP32_SHA_INIT;
 734:../src/wolfcrypt/src/sha256.c **** 
 735:../src/wolfcrypt/src/sha256.c ****         return ret;
 736:../src/wolfcrypt/src/sha256.c ****     }
 737:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
 738:../src/wolfcrypt/src/sha256.c ****     {
 739:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 740:../src/wolfcrypt/src/sha256.c **** 
 741:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL)
 742:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 743:../src/wolfcrypt/src/sha256.c **** 
 744:../src/wolfcrypt/src/sha256.c ****         XMEMSET(sha256, 0, sizeof(wc_Sha256));
 745:../src/wolfcrypt/src/sha256.c ****         sha256->ctx.mode = ESP32_SHA_INIT;
 746:../src/wolfcrypt/src/sha256.c ****         sha256->ctx.isfirstblock = 1;
 747:../src/wolfcrypt/src/sha256.c ****         (void)devId;
 748:../src/wolfcrypt/src/sha256.c **** 
 749:../src/wolfcrypt/src/sha256.c ****         ret = InitSha256(sha256);
 750:../src/wolfcrypt/src/sha256.c **** 
 751:../src/wolfcrypt/src/sha256.c ****         return ret;
 752:../src/wolfcrypt/src/sha256.c ****     }
 753:../src/wolfcrypt/src/sha256.c **** 
 754:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_RENESAS_TSIP_CRYPT) && \
 755:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_RENESAS_TSIP_CRYPT_HASH)
 756:../src/wolfcrypt/src/sha256.c **** 
 757:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/Renesas/renesas_tsip_sha.c */
 758:../src/wolfcrypt/src/sha256.c **** 
 759:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_RENESAS_SCEPROTECT) && \
 760:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_RENESAS_SCEPROTECT_HASH)
 761:../src/wolfcrypt/src/sha256.c **** 
 762:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/Renesas/renesas_sce_sha.c */
 763:../src/wolfcrypt/src/sha256.c **** 
 764:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_PSOC6_CRYPTO)
 765:../src/wolfcrypt/src/sha256.c **** 
 766:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/cypress/psoc6_crypto.c */
 767:../src/wolfcrypt/src/sha256.c **** 
 768:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_IMXRT_DCP)
 769:../src/wolfcrypt/src/sha256.c ****     #include <wolfssl/wolfcrypt/port/nxp/dcp_port.h>
 770:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/nxp/dcp_port.c */
 771:../src/wolfcrypt/src/sha256.c **** 
 772:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
 773:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/silabs/silabs_hash.c */
 774:../src/wolfcrypt/src/sha256.c **** 
 775:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_KCAPI_HASH)
 776:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */
 777:../src/wolfcrypt/src/sha256.c **** 
 778:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_HAVE_PSA) && !defined(WOLFSSL_PSA_NO_HASH)
 779:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/psa/psa_hash.c */
 780:../src/wolfcrypt/src/sha256.c **** 
 781:../src/wolfcrypt/src/sha256.c **** #else
 782:../src/wolfcrypt/src/sha256.c ****     #define NEED_SOFT_SHA256
 783:../src/wolfcrypt/src/sha256.c **** 
 784:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
 785:../src/wolfcrypt/src/sha256.c ****     {
 243                             		.loc 2 785 5
 244 0000 7E AA                   		push.l	r10
 245                             	.LCFI13:
 246 0002 71 0A F0                		add	#-16, r0, r10
 247                             	.LCFI14:
 248 0005 EF A0                   		mov.L	r10, r0
 249 0007 E7 A1 01                		mov.L	r1, 4[r10]
 250 000a E7 A2 02                		mov.L	r2, 8[r10]
 251 000d E7 A3 03                		mov.L	r3, 12[r10]
 786:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 252                             		.loc 2 786 13
 253 0010 F8 A6 00                		mov.L	#0, [r10]
 787:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL)
 254                             		.loc 2 787 12
 255 0013 ED A5 01                		mov.L	4[r10], r5
 256 0016 61 05                   		cmp	#0, r5
 257 0018 1F                      		bne	.L16
 788:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 258                             		.loc 2 788 20
 259 0019 FB 5A 53 FF             		mov.L	#-173, r5
 260 001d 2E 1E                   		bra	.L17
 261                             	.L16:
 789:../src/wolfcrypt/src/sha256.c **** 
 790:../src/wolfcrypt/src/sha256.c ****         ret = InitSha256(sha256);
 262                             		.loc 2 790 15
 263 001f ED A1 01                		mov.L	4[r10], r1
 264 0022 05 00 00 00             		bsr	_InitSha256
 265 0026 E3 A1                   		mov.L	r1, [r10]
 791:../src/wolfcrypt/src/sha256.c ****         if (ret != 0)
 266                             		.loc 2 791 12
 267 0028 EC A5                   		mov.L	[r10], r5
 268 002a 61 05                   		cmp	#0, r5
 269 002c 15                      		beq	.L18
 792:../src/wolfcrypt/src/sha256.c ****             return ret;
 270                             		.loc 2 792 20
 271 002d EC A5                   		mov.L	[r10], r5
 272 002f 2E 0C                   		bra	.L17
 273                             	.L18:
 793:../src/wolfcrypt/src/sha256.c **** 
 794:../src/wolfcrypt/src/sha256.c ****         sha256->heap = heap;
 274                             		.loc 2 794 22
 275 0031 ED A5 01                		mov.L	4[r10], r5
 276 0034 ED A4 02                		mov.L	8[r10], r4
 277 0037 A6 DC                   		mov.L	r4, 108[r5]
 795:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLF_CRYPTO_CB
 796:../src/wolfcrypt/src/sha256.c ****         sha256->devId = devId;
 797:../src/wolfcrypt/src/sha256.c ****         sha256->devCtx = NULL;
 798:../src/wolfcrypt/src/sha256.c ****     #endif
 799:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_SMALL_STACK_CACHE
 800:../src/wolfcrypt/src/sha256.c ****         sha256->W = NULL;
 801:../src/wolfcrypt/src/sha256.c ****     #endif
 802:../src/wolfcrypt/src/sha256.c **** 
 803:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
 804:../src/wolfcrypt/src/sha256.c ****         ret = wolfAsync_DevCtxInit(&sha256->asyncDev,
 805:../src/wolfcrypt/src/sha256.c ****                             WOLFSSL_ASYNC_MARKER_SHA256, sha256->heap, devId);
 806:../src/wolfcrypt/src/sha256.c ****     #else
 807:../src/wolfcrypt/src/sha256.c ****         (void)devId;
 808:../src/wolfcrypt/src/sha256.c ****     #endif /* WOLFSSL_ASYNC_CRYPT */
 809:../src/wolfcrypt/src/sha256.c **** 
 810:../src/wolfcrypt/src/sha256.c ****         return ret;
 278                             		.loc 2 810 16
 279 0039 EC A5                   		mov.L	[r10], r5
 280                             	.L17:
 811:../src/wolfcrypt/src/sha256.c ****     }
 281                             		.loc 2 811 5
 282 003b EF 51                   		mov.L	r5, r1
 283 003d 3F AA 05                		rtsd	#20, r10-r10
 284                             	.LFE44:
 286                             		.section	.rodata.K,"a"
 287                             		.balign 4
 290                             	_K:
 291 0000 98 2F 8A 42             		.long	0x428a2f98
 292 0004 91 44 37 71             		.long	0x71374491
 293 0008 CF FB C0 B5             		.long	-1245643825
 294 000c A5 DB B5 E9             		.long	-373957723
 295 0010 5B C2 56 39             		.long	0x3956c25b
 296 0014 F1 11 F1 59             		.long	0x59f111f1
 297 0018 A4 82 3F 92             		.long	-1841331548
 298 001c D5 5E 1C AB             		.long	-1424204075
 299 0020 98 AA 07 D8             		.long	-670586216
 300 0024 01 5B 83 12             		.long	0x12835b01
 301 0028 BE 85 31 24             		.long	0x243185be
 302 002c C3 7D 0C 55             		.long	0x550c7dc3
 303 0030 74 5D BE 72             		.long	0x72be5d74
 304 0034 FE B1 DE 80             		.long	-2132889090
 305 0038 A7 06 DC 9B             		.long	-1680079193
 306 003c 74 F1 9B C1             		.long	-1046744716
 307 0040 C1 69 9B E4             		.long	-459576895
 308 0044 86 47 BE EF             		.long	-272742522
 309 0048 C6 9D C1 0F             		.long	0xfc19dc6
 310 004c CC A1 0C 24             		.long	0x240ca1cc
 311 0050 6F 2C E9 2D             		.long	0x2de92c6f
 312 0054 AA 84 74 4A             		.long	0x4a7484aa
 313 0058 DC A9 B0 5C             		.long	0x5cb0a9dc
 314 005c DA 88 F9 76             		.long	0x76f988da
 315 0060 52 51 3E 98             		.long	-1740746414
 316 0064 6D C6 31 A8             		.long	-1473132947
 317 0068 C8 27 03 B0             		.long	-1341970488
 318 006c C7 7F 59 BF             		.long	-1084653625
 319 0070 F3 0B E0 C6             		.long	-958395405
 320 0074 47 91 A7 D5             		.long	-710438585
 321 0078 51 63 CA 06             		.long	0x6ca6351
 322 007c 67 29 29 14             		.long	0x14292967
 323 0080 85 0A B7 27             		.long	0x27b70a85
 324 0084 38 21 1B 2E             		.long	0x2e1b2138
 325 0088 FC 6D 2C 4D             		.long	0x4d2c6dfc
 326 008c 13 0D 38 53             		.long	0x53380d13
 327 0090 54 73 0A 65             		.long	0x650a7354
 328 0094 BB 0A 6A 76             		.long	0x766a0abb
 329 0098 2E C9 C2 81             		.long	-2117940946
 330 009c 85 2C 72 92             		.long	-1838011259
 331 00a0 A1 E8 BF A2             		.long	-1564481375
 332 00a4 4B 66 1A A8             		.long	-1474664885
 333 00a8 70 8B 4B C2             		.long	-1035236496
 334 00ac A3 51 6C C7             		.long	-949202525
 335 00b0 19 E8 92 D1             		.long	-778901479
 336 00b4 24 06 99 D6             		.long	-694614492
 337 00b8 85 35 0E F4             		.long	-200395387
 338 00bc 70 A0 6A 10             		.long	0x106aa070
 339 00c0 16 C1 A4 19             		.long	0x19a4c116
 340 00c4 08 6C 37 1E             		.long	0x1e376c08
 341 00c8 4C 77 48 27             		.long	0x2748774c
 342 00cc B5 BC B0 34             		.long	0x34b0bcb5
 343 00d0 B3 0C 1C 39             		.long	0x391c0cb3
 344 00d4 4A AA D8 4E             		.long	0x4ed8aa4a
 345 00d8 4F CA 9C 5B             		.long	0x5b9cca4f
 346 00dc F3 6F 2E 68             		.long	0x682e6ff3
 347 00e0 EE 82 8F 74             		.long	0x748f82ee
 348 00e4 6F 63 A5 78             		.long	0x78a5636f
 349 00e8 14 78 C8 84             		.long	-2067236844
 350 00ec 08 02 C7 8C             		.long	-1933114872
 351 00f0 FA FF BE 90             		.long	-1866530822
 352 00f4 EB 6C 50 A4             		.long	-1538233109
 353 00f8 F7 A3 F9 BE             		.long	-1090935817
 354 00fc F2 78 71 C6             		.long	-965641998
 355                             		.section	.text.Transform_Sha256,"ax",@progbits
 357                             	_Transform_Sha256:
 358                             	.LFB45:
 812:../src/wolfcrypt/src/sha256.c **** #endif /* End Hardware Acceleration */
 813:../src/wolfcrypt/src/sha256.c **** 
 814:../src/wolfcrypt/src/sha256.c **** #ifdef NEED_SOFT_SHA256
 815:../src/wolfcrypt/src/sha256.c **** 
 816:../src/wolfcrypt/src/sha256.c ****     static const FLASH_QUALIFIER ALIGN32 word32 K[64] = {
 817:../src/wolfcrypt/src/sha256.c ****         0x428A2F98L, 0x71374491L, 0xB5C0FBCFL, 0xE9B5DBA5L, 0x3956C25BL,
 818:../src/wolfcrypt/src/sha256.c ****         0x59F111F1L, 0x923F82A4L, 0xAB1C5ED5L, 0xD807AA98L, 0x12835B01L,
 819:../src/wolfcrypt/src/sha256.c ****         0x243185BEL, 0x550C7DC3L, 0x72BE5D74L, 0x80DEB1FEL, 0x9BDC06A7L,
 820:../src/wolfcrypt/src/sha256.c ****         0xC19BF174L, 0xE49B69C1L, 0xEFBE4786L, 0x0FC19DC6L, 0x240CA1CCL,
 821:../src/wolfcrypt/src/sha256.c ****         0x2DE92C6FL, 0x4A7484AAL, 0x5CB0A9DCL, 0x76F988DAL, 0x983E5152L,
 822:../src/wolfcrypt/src/sha256.c ****         0xA831C66DL, 0xB00327C8L, 0xBF597FC7L, 0xC6E00BF3L, 0xD5A79147L,
 823:../src/wolfcrypt/src/sha256.c ****         0x06CA6351L, 0x14292967L, 0x27B70A85L, 0x2E1B2138L, 0x4D2C6DFCL,
 824:../src/wolfcrypt/src/sha256.c ****         0x53380D13L, 0x650A7354L, 0x766A0ABBL, 0x81C2C92EL, 0x92722C85L,
 825:../src/wolfcrypt/src/sha256.c ****         0xA2BFE8A1L, 0xA81A664BL, 0xC24B8B70L, 0xC76C51A3L, 0xD192E819L,
 826:../src/wolfcrypt/src/sha256.c ****         0xD6990624L, 0xF40E3585L, 0x106AA070L, 0x19A4C116L, 0x1E376C08L,
 827:../src/wolfcrypt/src/sha256.c ****         0x2748774CL, 0x34B0BCB5L, 0x391C0CB3L, 0x4ED8AA4AL, 0x5B9CCA4FL,
 828:../src/wolfcrypt/src/sha256.c ****         0x682E6FF3L, 0x748F82EEL, 0x78A5636FL, 0x84C87814L, 0x8CC70208L,
 829:../src/wolfcrypt/src/sha256.c ****         0x90BEFFFAL, 0xA4506CEBL, 0xBEF9A3F7L, 0xC67178F2L
 830:../src/wolfcrypt/src/sha256.c ****     };
 831:../src/wolfcrypt/src/sha256.c **** 
 832:../src/wolfcrypt/src/sha256.c **** /* Both versions of Ch and Maj are logically the same, but with the second set
 833:../src/wolfcrypt/src/sha256.c ****     the compilers can recognize them better for optimization */
 834:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_SHA256_BY_SPEC
 835:../src/wolfcrypt/src/sha256.c ****     /* SHA256 math based on specification */
 836:../src/wolfcrypt/src/sha256.c ****     #define Ch(x,y,z)       ((z) ^ ((x) & ((y) ^ (z))))
 837:../src/wolfcrypt/src/sha256.c ****     #define Maj(x,y,z)      ((((x) | (y)) & (z)) | ((x) & (y)))
 838:../src/wolfcrypt/src/sha256.c **** #else
 839:../src/wolfcrypt/src/sha256.c ****     /* SHA256 math reworked for easier compiler optimization */
 840:../src/wolfcrypt/src/sha256.c ****     #define Ch(x,y,z)       ((((y) ^ (z)) & (x)) ^ (z))
 841:../src/wolfcrypt/src/sha256.c ****     #define Maj(x,y,z)      ((((x) ^ (y)) & ((y) ^ (z))) ^ (y))
 842:../src/wolfcrypt/src/sha256.c **** #endif
 843:../src/wolfcrypt/src/sha256.c ****     #define R(x, n)         (((x) & 0xFFFFFFFFU) >> (n))
 844:../src/wolfcrypt/src/sha256.c **** 
 845:../src/wolfcrypt/src/sha256.c ****     #define S(x, n)         rotrFixed(x, n)
 846:../src/wolfcrypt/src/sha256.c ****     #define Sigma0(x)       (S(x, 2)  ^ S(x, 13) ^ S(x, 22))
 847:../src/wolfcrypt/src/sha256.c ****     #define Sigma1(x)       (S(x, 6)  ^ S(x, 11) ^ S(x, 25))
 848:../src/wolfcrypt/src/sha256.c ****     #define Gamma0(x)       (S(x, 7)  ^ S(x, 18) ^ R(x, 3))
 849:../src/wolfcrypt/src/sha256.c ****     #define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
 850:../src/wolfcrypt/src/sha256.c **** 
 851:../src/wolfcrypt/src/sha256.c ****     #define a(i) S[(0-(i)) & 7]
 852:../src/wolfcrypt/src/sha256.c ****     #define b(i) S[(1-(i)) & 7]
 853:../src/wolfcrypt/src/sha256.c ****     #define c(i) S[(2-(i)) & 7]
 854:../src/wolfcrypt/src/sha256.c ****     #define d(i) S[(3-(i)) & 7]
 855:../src/wolfcrypt/src/sha256.c ****     #define e(i) S[(4-(i)) & 7]
 856:../src/wolfcrypt/src/sha256.c ****     #define f(i) S[(5-(i)) & 7]
 857:../src/wolfcrypt/src/sha256.c ****     #define g(i) S[(6-(i)) & 7]
 858:../src/wolfcrypt/src/sha256.c ****     #define h(i) S[(7-(i)) & 7]
 859:../src/wolfcrypt/src/sha256.c **** 
 860:../src/wolfcrypt/src/sha256.c ****     #ifndef XTRANSFORM
 861:../src/wolfcrypt/src/sha256.c ****          #define XTRANSFORM(S, D)         Transform_Sha256((S),(D))
 862:../src/wolfcrypt/src/sha256.c ****     #endif
 863:../src/wolfcrypt/src/sha256.c **** 
 864:../src/wolfcrypt/src/sha256.c **** #ifndef SHA256_MANY_REGISTERS
 865:../src/wolfcrypt/src/sha256.c ****     #define RND(j) \
 866:../src/wolfcrypt/src/sha256.c ****          t0 = h(j) + Sigma1(e(j)) + Ch(e(j), f(j), g(j)) + K[i+(j)] + W[i+(j)]; \
 867:../src/wolfcrypt/src/sha256.c ****          t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
 868:../src/wolfcrypt/src/sha256.c ****          d(j) += t0; \
 869:../src/wolfcrypt/src/sha256.c ****          h(j)  = t0 + t1
 870:../src/wolfcrypt/src/sha256.c **** 
 871:../src/wolfcrypt/src/sha256.c ****     static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
 872:../src/wolfcrypt/src/sha256.c ****     {
 359                             		.loc 2 872 5
 360 0000 6E 6B                   		pushm	r6-r11
 361                             	.LCFI15:
 362 0002 71 0A C4                		add	#-60, r0, r10
 363                             	.LCFI16:
 364 0005 EF A0                   		mov.L	r10, r0
 365 0007 E7 A1 0D                		mov.L	r1, 52[r10]
 366 000a E7 A2 0E                		mov.L	r2, 56[r10]
 873:../src/wolfcrypt/src/sha256.c ****         word32 S[8], t0, t1;
 874:../src/wolfcrypt/src/sha256.c ****         int i;
 875:../src/wolfcrypt/src/sha256.c **** 
 876:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_SMALL_STACK_CACHE
 877:../src/wolfcrypt/src/sha256.c ****         word32* W = sha256->W;
 878:../src/wolfcrypt/src/sha256.c ****         if (W == NULL) {
 879:../src/wolfcrypt/src/sha256.c ****             W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
 880:../src/wolfcrypt/src/sha256.c ****                                                            DYNAMIC_TYPE_DIGEST);
 881:../src/wolfcrypt/src/sha256.c ****             if (W == NULL)
 882:../src/wolfcrypt/src/sha256.c ****                 return MEMORY_E;
 883:../src/wolfcrypt/src/sha256.c ****             sha256->W = W;
 884:../src/wolfcrypt/src/sha256.c ****         }
 885:../src/wolfcrypt/src/sha256.c ****     #elif defined(WOLFSSL_SMALL_STACK)
 886:../src/wolfcrypt/src/sha256.c ****         word32* W;
 887:../src/wolfcrypt/src/sha256.c ****         W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
 367                             		.loc 2 887 22
 368 000d FB 1A 00 01             		mov.L	#0x100, r1
 369 0011 05 00 00 00             		bsr	_wolfSSL_Malloc
 370 0015 E7 A1 01                		mov.L	r1, 4[r10]
 888:../src/wolfcrypt/src/sha256.c ****                                                        DYNAMIC_TYPE_TMP_BUFFER);
 889:../src/wolfcrypt/src/sha256.c ****         if (W == NULL)
 371                             		.loc 2 889 12
 372 0018 ED A5 01                		mov.L	4[r10], r5
 373 001b 61 05                   		cmp	#0, r5
 374 001d 1F                      		bne	.L20
 890:../src/wolfcrypt/src/sha256.c ****             return MEMORY_E;
 375                             		.loc 2 890 20
 376 001e FB 56 83                		mov.L	#-125, r5
 377 0021 38 E8 07                		bra	.L33
 378                             	.L20:
 891:../src/wolfcrypt/src/sha256.c ****     #else
 892:../src/wolfcrypt/src/sha256.c ****         word32 W[WC_SHA256_BLOCK_SIZE];
 893:../src/wolfcrypt/src/sha256.c ****     #endif
 894:../src/wolfcrypt/src/sha256.c **** 
 895:../src/wolfcrypt/src/sha256.c ****         /* Copy context->state[] to working vars */
 896:../src/wolfcrypt/src/sha256.c ****         for (i = 0; i < 8; i++)
 379                             		.loc 2 896 16
 380 0024 F8 A6 00                		mov.L	#0, [r10]
 381                             		.loc 2 896 9
 382 0027 2E 18                   		bra	.L22
 383                             	.L23:
 897:../src/wolfcrypt/src/sha256.c ****             S[i] = sha256->digest[i];
 384                             		.loc 2 897 34 discriminator 3
 385 0029 ED A5 0D                		mov.L	52[r10], r5
 386 002c EC A4                   		mov.L	[r10], r4
 387 002e FE 64 54                		mov.L	[r4,r5], r4
 388                             		.loc 2 897 18 discriminator 3
 389 0031 EC A5                   		mov.L	[r10], r5
 390 0033 6C 25                   		shll	#2, r5
 391 0035 4B A5                   		add	r10, r5
 392 0037 A1 5C                   		mov.L	r4, 20[r5]
 896:../src/wolfcrypt/src/sha256.c ****             S[i] = sha256->digest[i];
 393                             		.loc 2 896 29 discriminator 3
 394 0039 EC A5                   		mov.L	[r10], r5
 395 003b 62 15                   		add	#1, r5
 396 003d E3 A5                   		mov.L	r5, [r10]
 397                             	.L22:
 896:../src/wolfcrypt/src/sha256.c ****             S[i] = sha256->digest[i];
 398                             		.loc 2 896 9 discriminator 1
 399 003f EC A5                   		mov.L	[r10], r5
 400 0041 61 75                   		cmp	#7, r5
 401 0043 2B E6                   		ble	.L23
 898:../src/wolfcrypt/src/sha256.c **** 
 899:../src/wolfcrypt/src/sha256.c ****         for (i = 0; i < 16; i++)
 402                             		.loc 2 899 16
 403 0045 F8 A6 00                		mov.L	#0, [r10]
 404                             		.loc 2 899 9
 405 0048 2E 1E                   		bra	.L24
 406                             	.L25:
 900:../src/wolfcrypt/src/sha256.c ****             W[i] = *((const word32*)&data[i*sizeof(word32)]);
 407                             		.loc 2 900 44 discriminator 3
 408 004a EC A5                   		mov.L	[r10], r5
 409 004c 6C 25                   		shll	#2, r5
 410                             		.loc 2 900 37 discriminator 3
 411 004e ED A4 0E                		mov.L	56[r10], r4
 412 0051 4B 54                   		add	r5, r4
 413                             		.loc 2 900 14 discriminator 3
 414 0053 EC A5                   		mov.L	[r10], r5
 415 0055 6C 25                   		shll	#2, r5
 416 0057 ED A3 01                		mov.L	4[r10], r3
 417 005a 4B 35                   		add	r3, r5
 418                             		.loc 2 900 20 discriminator 3
 419 005c EC 44                   		mov.L	[r4], r4
 420                             		.loc 2 900 18 discriminator 3
 421 005e E3 54                   		mov.L	r4, [r5]
 899:../src/wolfcrypt/src/sha256.c ****             W[i] = *((const word32*)&data[i*sizeof(word32)]);
 422                             		.loc 2 899 30 discriminator 3
 423 0060 EC A5                   		mov.L	[r10], r5
 424 0062 62 15                   		add	#1, r5
 425 0064 E3 A5                   		mov.L	r5, [r10]
 426                             	.L24:
 899:../src/wolfcrypt/src/sha256.c ****             W[i] = *((const word32*)&data[i*sizeof(word32)]);
 427                             		.loc 2 899 9 discriminator 1
 428 0066 EC A5                   		mov.L	[r10], r5
 429 0068 61 F5                   		cmp	#15, r5
 430 006a 2B E0                   		ble	.L25
 901:../src/wolfcrypt/src/sha256.c **** 
 902:../src/wolfcrypt/src/sha256.c ****         for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 431                             		.loc 2 902 16
 432 006c F8 A6 10                		mov.L	#16, [r10]
 433                             		.loc 2 902 9
 434 006f 38 E5 00                		bra	.L26
 435                             	.L27:
 903:../src/wolfcrypt/src/sha256.c ****             W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
 436                             		.loc 2 903 20 discriminator 3
 437 0072 EC A5                   		mov.L	[r10], r5
 438 0074 70 55 FE FF FF 3F       		add	#0x3ffffffe, r5
 439 007a 6C 25                   		shll	#2, r5
 440 007c ED A4 01                		mov.L	4[r10], r4
 441 007f 4B 45                   		add	r4, r5
 442 0081 EC 55                   		mov.L	[r5], r5
 443 0083 75 42 11                		mov.L	#17, r2
 444 0086 EF 51                   		mov.L	r5, r1
 445 0088 05 00 00 00             		bsr	_rotrFixed
 446 008c EF 16                   		mov.L	r1, r6
 447 008e EC A5                   		mov.L	[r10], r5
 448 0090 70 55 FE FF FF 3F       		add	#0x3ffffffe, r5
 449 0096 6C 25                   		shll	#2, r5
 450 0098 ED A4 01                		mov.L	4[r10], r4
 451 009b 4B 45                   		add	r4, r5
 452 009d EC 55                   		mov.L	[r5], r5
 453 009f 75 42 13                		mov.L	#19, r2
 454 00a2 EF 51                   		mov.L	r5, r1
 455 00a4 05 00 00 00             		bsr	_rotrFixed
 456 00a8 EF 15                   		mov.L	r1, r5
 457 00aa EF 63                   		mov.L	r6, r3
 458 00ac FC 37 53                		xor	r5, r3
 459 00af EC A5                   		mov.L	[r10], r5
 460 00b1 70 55 FE FF FF 3F       		add	#0x3ffffffe, r5
 461 00b7 6C 25                   		shll	#2, r5
 462 00b9 ED A4 01                		mov.L	4[r10], r4
 463 00bc 4B 45                   		add	r4, r5
 464 00be EC 55                   		mov.L	[r5], r5
 465 00c0 68 A5                   		shlr	#10, r5
 466 00c2 EF 34                   		mov.L	r3, r4
 467 00c4 FC 37 54                		xor	r5, r4
 468                             		.loc 2 903 38 discriminator 3
 469 00c7 EC A5                   		mov.L	[r10], r5
 470 00c9 70 55 F9 FF FF 3F       		add	#0x3ffffff9, r5
 471 00cf 6C 25                   		shll	#2, r5
 472 00d1 ED A3 01                		mov.L	4[r10], r3
 473 00d4 4B 35                   		add	r3, r5
 474 00d6 EC 55                   		mov.L	[r5], r5
 475                             		.loc 2 903 35 discriminator 3
 476 00d8 FF 26 54                		add	r5, r4, r6
 477                             		.loc 2 903 46 discriminator 3
 478 00db EC A5                   		mov.L	[r10], r5
 479 00dd 70 55 F1 FF FF 3F       		add	#0x3ffffff1, r5
 480 00e3 6C 25                   		shll	#2, r5
 481 00e5 ED A4 01                		mov.L	4[r10], r4
 482 00e8 4B 45                   		add	r4, r5
 483 00ea EC 55                   		mov.L	[r5], r5
 484 00ec 66 72                   		mov.L	#7, r2
 485 00ee EF 51                   		mov.L	r5, r1
 486 00f0 05 00 00 00             		bsr	_rotrFixed
 487 00f4 EF 1B                   		mov.L	r1, r11
 488 00f6 EC A5                   		mov.L	[r10], r5
 489 00f8 70 55 F1 FF FF 3F       		add	#0x3ffffff1, r5
 490 00fe 6C 25                   		shll	#2, r5
 491 0100 ED A4 01                		mov.L	4[r10], r4
 492 0103 4B 45                   		add	r4, r5
 493 0105 EC 55                   		mov.L	[r5], r5
 494 0107 75 42 12                		mov.L	#18, r2
 495 010a EF 51                   		mov.L	r5, r1
 496 010c 05 00 00 00             		bsr	_rotrFixed
 497 0110 EF 15                   		mov.L	r1, r5
 498 0112 EF B3                   		mov.L	r11, r3
 499 0114 FC 37 53                		xor	r5, r3
 500 0117 EC A5                   		mov.L	[r10], r5
 501 0119 70 55 F1 FF FF 3F       		add	#0x3ffffff1, r5
 502 011f 6C 25                   		shll	#2, r5
 503 0121 ED A4 01                		mov.L	4[r10], r4
 504 0124 4B 45                   		add	r4, r5
 505 0126 EC 55                   		mov.L	[r5], r5
 506 0128 68 35                   		shlr	#3, r5
 507 012a FC 37 35                		xor	r3, r5
 508                             		.loc 2 903 44 discriminator 3
 509 012d FF 24 56                		add	r5, r6, r4
 510                             		.loc 2 903 65 discriminator 3
 511 0130 EC A5                   		mov.L	[r10], r5
 512 0132 70 55 F0 FF FF 3F       		add	#0x3ffffff0, r5
 513 0138 6C 25                   		shll	#2, r5
 514 013a ED A3 01                		mov.L	4[r10], r3
 515 013d 4B 35                   		add	r3, r5
 516 013f EC 53                   		mov.L	[r5], r3
 517                             		.loc 2 903 14 discriminator 3
 518 0141 EC A5                   		mov.L	[r10], r5
 519 0143 6C 25                   		shll	#2, r5
 520 0145 ED A2 01                		mov.L	4[r10], r2
 521 0148 4B 25                   		add	r2, r5
 522                             		.loc 2 903 62 discriminator 3
 523 014a 4B 34                   		add	r3, r4
 524                             		.loc 2 903 18 discriminator 3
 525 014c E3 54                   		mov.L	r4, [r5]
 902:../src/wolfcrypt/src/sha256.c ****             W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
 526                             		.loc 2 902 49 discriminator 3
 527 014e EC A5                   		mov.L	[r10], r5
 528 0150 62 15                   		add	#1, r5
 529 0152 E3 A5                   		mov.L	r5, [r10]
 530                             	.L26:
 902:../src/wolfcrypt/src/sha256.c ****             W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
 531                             		.loc 2 902 9 discriminator 1
 532 0154 EC A5                   		mov.L	[r10], r5
 533 0156 75 55 3F                		cmp	#63, r5
 534 0159 2A 05 38 17 FF          		ble	.L27
 904:../src/wolfcrypt/src/sha256.c **** 
 905:../src/wolfcrypt/src/sha256.c ****     #ifdef USE_SLOW_SHA256
 906:../src/wolfcrypt/src/sha256.c ****         /* not unrolled - ~2k smaller and ~25% slower */
 907:../src/wolfcrypt/src/sha256.c ****         for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 908:../src/wolfcrypt/src/sha256.c ****             int j;
 909:../src/wolfcrypt/src/sha256.c ****             for (j = 0; j < 8; j++) { /* braces needed here for macros {} */
 910:../src/wolfcrypt/src/sha256.c ****                 RND(j);
 911:../src/wolfcrypt/src/sha256.c ****             }
 912:../src/wolfcrypt/src/sha256.c ****         }
 913:../src/wolfcrypt/src/sha256.c ****     #else
 914:../src/wolfcrypt/src/sha256.c ****         /* partially loop unrolled */
 915:../src/wolfcrypt/src/sha256.c ****         for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 535                             		.loc 2 915 16
 536 015e F8 A6 00                		mov.L	#0, [r10]
 537                             		.loc 2 915 9
 538 0161 38 5D 06                		bra	.L28
 539                             	.L29:
 916:../src/wolfcrypt/src/sha256.c ****             RND(0); RND(1); RND(2); RND(3);
 540                             		.loc 2 916 13 discriminator 3
 541 0164 ED A6 0C                		mov.L	48[r10], r6
 542 0167 ED A5 09                		mov.L	36[r10], r5
 543 016a 66 62                   		mov.L	#6, r2
 544 016c EF 51                   		mov.L	r5, r1
 545 016e 05 00 00 00             		bsr	_rotrFixed
 546 0172 EF 1B                   		mov.L	r1, r11
 547 0174 ED A5 09                		mov.L	36[r10], r5
 548 0177 66 B2                   		mov.L	#11, r2
 549 0179 EF 51                   		mov.L	r5, r1
 550 017b 05 00 00 00             		bsr	_rotrFixed
 551 017f EF 15                   		mov.L	r1, r5
 552 0181 FC 37 5B                		xor	r5, r11
 553 0184 ED A5 09                		mov.L	36[r10], r5
 554 0187 75 42 19                		mov.L	#25, r2
 555 018a EF 51                   		mov.L	r5, r1
 556 018c 05 00 00 00             		bsr	_rotrFixed
 557 0190 EF 15                   		mov.L	r1, r5
 558 0192 FC 37 B5                		xor	r11, r5
 559 0195 FF 24 56                		add	r5, r6, r4
 560 0198 ED A2 0B                		mov.L	44[r10], r2
 561 019b ED A3 09                		mov.L	36[r10], r3
 562 019e ED A1 0A                		mov.L	40[r10], r1
 563 01a1 ED A5 0B                		mov.L	44[r10], r5
 564 01a4 FC 37 15                		xor	r1, r5
 565 01a7 53 35                   		and	r3, r5
 566 01a9 FC 37 25                		xor	r2, r5
 567 01ac 4B 45                   		add	r4, r5
 568 01ae FB 42 00 00 00 00       		mov.L	#_K, r4
 569 01b4 EC A3                   		mov.L	[r10], r3
 570 01b6 FE 63 44                		mov.L	[r3,r4], r4
 571 01b9 4B 54                   		add	r5, r4
 572 01bb EC A5                   		mov.L	[r10], r5
 573 01bd 6C 25                   		shll	#2, r5
 574 01bf ED A3 01                		mov.L	4[r10], r3
 575 01c2 4B 35                   		add	r3, r5
 576 01c4 EC 55                   		mov.L	[r5], r5
 577 01c6 4B 45                   		add	r4, r5
 578 01c8 E7 A5 02                		mov.L	r5, 8[r10]
 579 01cb ED A5 05                		mov.L	20[r10], r5
 580 01ce 66 22                   		mov.L	#2, r2
 581 01d0 EF 51                   		mov.L	r5, r1
 582 01d2 05 00 00 00             		bsr	_rotrFixed
 583 01d6 EF 16                   		mov.L	r1, r6
 584 01d8 ED A5 05                		mov.L	20[r10], r5
 585 01db 66 D2                   		mov.L	#13, r2
 586 01dd EF 51                   		mov.L	r5, r1
 587 01df 05 00 00 00             		bsr	_rotrFixed
 588 01e3 EF 15                   		mov.L	r1, r5
 589 01e5 FC 37 56                		xor	r5, r6
 590 01e8 ED A5 05                		mov.L	20[r10], r5
 591 01eb 75 42 16                		mov.L	#22, r2
 592 01ee EF 51                   		mov.L	r5, r1
 593 01f0 05 00 00 00             		bsr	_rotrFixed
 594 01f4 EF 15                   		mov.L	r1, r5
 595 01f6 EF 63                   		mov.L	r6, r3
 596 01f8 FC 37 53                		xor	r5, r3
 597 01fb ED A4 05                		mov.L	20[r10], r4
 598 01fe ED A5 06                		mov.L	24[r10], r5
 599 0201 57 45                   		or	r4, r5
 600 0203 ED A4 07                		mov.L	28[r10], r4
 601 0206 53 54                   		and	r5, r4
 602 0208 ED A2 05                		mov.L	20[r10], r2
 603 020b ED A5 06                		mov.L	24[r10], r5
 604 020e 53 25                   		and	r2, r5
 605 0210 57 45                   		or	r4, r5
 606 0212 4B 35                   		add	r3, r5
 607 0214 E7 A5 03                		mov.L	r5, 12[r10]
 608 0217 ED A5 08                		mov.L	32[r10], r5
 609 021a 06 89 A5 02             		add	8[r10].L, r5
 610 021e E7 A5 08                		mov.L	r5, 32[r10]
 611 0221 ED A5 02                		mov.L	8[r10], r5
 612 0224 06 89 A5 03             		add	12[r10].L, r5
 613 0228 E7 A5 0C                		mov.L	r5, 48[r10]
 614                             		.loc 2 916 21 discriminator 3
 615 022b ED A6 0B                		mov.L	44[r10], r6
 616 022e ED A5 08                		mov.L	32[r10], r5
 617 0231 66 62                   		mov.L	#6, r2
 618 0233 EF 51                   		mov.L	r5, r1
 619 0235 05 00 00 00             		bsr	_rotrFixed
 620 0239 EF 1B                   		mov.L	r1, r11
 621 023b ED A5 08                		mov.L	32[r10], r5
 622 023e 66 B2                   		mov.L	#11, r2
 623 0240 EF 51                   		mov.L	r5, r1
 624 0242 05 00 00 00             		bsr	_rotrFixed
 625 0246 EF 15                   		mov.L	r1, r5
 626 0248 FC 37 5B                		xor	r5, r11
 627 024b ED A5 08                		mov.L	32[r10], r5
 628 024e 75 42 19                		mov.L	#25, r2
 629 0251 EF 51                   		mov.L	r5, r1
 630 0253 05 00 00 00             		bsr	_rotrFixed
 631 0257 EF 15                   		mov.L	r1, r5
 632 0259 FC 37 B5                		xor	r11, r5
 633 025c FF 24 56                		add	r5, r6, r4
 634 025f ED A2 0A                		mov.L	40[r10], r2
 635 0262 ED A3 08                		mov.L	32[r10], r3
 636 0265 ED A1 09                		mov.L	36[r10], r1
 637 0268 ED A5 0A                		mov.L	40[r10], r5
 638 026b FC 37 15                		xor	r1, r5
 639 026e 53 35                   		and	r3, r5
 640 0270 FC 37 25                		xor	r2, r5
 641 0273 4B 54                   		add	r5, r4
 642 0275 EC A5                   		mov.L	[r10], r5
 643 0277 62 15                   		add	#1, r5
 644 0279 FB 32 00 00 00 00       		mov.L	#_K, r3
 645 027f FE 65 35                		mov.L	[r5,r3], r5
 646 0282 4B 54                   		add	r5, r4
 647 0284 EC A5                   		mov.L	[r10], r5
 648 0286 62 15                   		add	#1, r5
 649 0288 6C 25                   		shll	#2, r5
 650 028a ED A3 01                		mov.L	4[r10], r3
 651 028d 4B 35                   		add	r3, r5
 652 028f EC 55                   		mov.L	[r5], r5
 653 0291 4B 45                   		add	r4, r5
 654 0293 E7 A5 02                		mov.L	r5, 8[r10]
 655 0296 ED A5 0C                		mov.L	48[r10], r5
 656 0299 66 22                   		mov.L	#2, r2
 657 029b EF 51                   		mov.L	r5, r1
 658 029d 05 00 00 00             		bsr	_rotrFixed
 659 02a1 EF 16                   		mov.L	r1, r6
 660 02a3 ED A5 0C                		mov.L	48[r10], r5
 661 02a6 66 D2                   		mov.L	#13, r2
 662 02a8 EF 51                   		mov.L	r5, r1
 663 02aa 05 00 00 00             		bsr	_rotrFixed
 664 02ae EF 15                   		mov.L	r1, r5
 665 02b0 FC 37 56                		xor	r5, r6
 666 02b3 ED A5 0C                		mov.L	48[r10], r5
 667 02b6 75 42 16                		mov.L	#22, r2
 668 02b9 EF 51                   		mov.L	r5, r1
 669 02bb 05 00 00 00             		bsr	_rotrFixed
 670 02bf EF 15                   		mov.L	r1, r5
 671 02c1 EF 63                   		mov.L	r6, r3
 672 02c3 FC 37 53                		xor	r5, r3
 673 02c6 ED A4 0C                		mov.L	48[r10], r4
 674 02c9 ED A5 05                		mov.L	20[r10], r5
 675 02cc 57 45                   		or	r4, r5
 676 02ce ED A4 06                		mov.L	24[r10], r4
 677 02d1 53 54                   		and	r5, r4
 678 02d3 ED A2 0C                		mov.L	48[r10], r2
 679 02d6 ED A5 05                		mov.L	20[r10], r5
 680 02d9 53 25                   		and	r2, r5
 681 02db 57 45                   		or	r4, r5
 682 02dd 4B 35                   		add	r3, r5
 683 02df E7 A5 03                		mov.L	r5, 12[r10]
 684 02e2 ED A5 07                		mov.L	28[r10], r5
 685 02e5 06 89 A5 02             		add	8[r10].L, r5
 686 02e9 E7 A5 07                		mov.L	r5, 28[r10]
 687 02ec ED A5 02                		mov.L	8[r10], r5
 688 02ef 06 89 A5 03             		add	12[r10].L, r5
 689 02f3 E7 A5 0B                		mov.L	r5, 44[r10]
 690                             		.loc 2 916 29 discriminator 3
 691 02f6 ED A6 0A                		mov.L	40[r10], r6
 692 02f9 ED A5 07                		mov.L	28[r10], r5
 693 02fc 66 62                   		mov.L	#6, r2
 694 02fe EF 51                   		mov.L	r5, r1
 695 0300 05 00 00 00             		bsr	_rotrFixed
 696 0304 EF 1B                   		mov.L	r1, r11
 697 0306 ED A5 07                		mov.L	28[r10], r5
 698 0309 66 B2                   		mov.L	#11, r2
 699 030b EF 51                   		mov.L	r5, r1
 700 030d 05 00 00 00             		bsr	_rotrFixed
 701 0311 EF 15                   		mov.L	r1, r5
 702 0313 FC 37 5B                		xor	r5, r11
 703 0316 ED A5 07                		mov.L	28[r10], r5
 704 0319 75 42 19                		mov.L	#25, r2
 705 031c EF 51                   		mov.L	r5, r1
 706 031e 05 00 00 00             		bsr	_rotrFixed
 707 0322 EF 15                   		mov.L	r1, r5
 708 0324 FC 37 B5                		xor	r11, r5
 709 0327 FF 24 56                		add	r5, r6, r4
 710 032a ED A2 09                		mov.L	36[r10], r2
 711 032d ED A3 07                		mov.L	28[r10], r3
 712 0330 ED A1 08                		mov.L	32[r10], r1
 713 0333 ED A5 09                		mov.L	36[r10], r5
 714 0336 FC 37 15                		xor	r1, r5
 715 0339 53 35                   		and	r3, r5
 716 033b FC 37 25                		xor	r2, r5
 717 033e 4B 54                   		add	r5, r4
 718 0340 EC A5                   		mov.L	[r10], r5
 719 0342 62 25                   		add	#2, r5
 720 0344 FB 32 00 00 00 00       		mov.L	#_K, r3
 721 034a FE 65 35                		mov.L	[r5,r3], r5
 722 034d 4B 54                   		add	r5, r4
 723 034f EC A5                   		mov.L	[r10], r5
 724 0351 62 25                   		add	#2, r5
 725 0353 6C 25                   		shll	#2, r5
 726 0355 ED A3 01                		mov.L	4[r10], r3
 727 0358 4B 35                   		add	r3, r5
 728 035a EC 55                   		mov.L	[r5], r5
 729 035c 4B 45                   		add	r4, r5
 730 035e E7 A5 02                		mov.L	r5, 8[r10]
 731 0361 ED A5 0B                		mov.L	44[r10], r5
 732 0364 66 22                   		mov.L	#2, r2
 733 0366 EF 51                   		mov.L	r5, r1
 734 0368 05 00 00 00             		bsr	_rotrFixed
 735 036c EF 16                   		mov.L	r1, r6
 736 036e ED A5 0B                		mov.L	44[r10], r5
 737 0371 66 D2                   		mov.L	#13, r2
 738 0373 EF 51                   		mov.L	r5, r1
 739 0375 05 00 00 00             		bsr	_rotrFixed
 740 0379 EF 15                   		mov.L	r1, r5
 741 037b FC 37 56                		xor	r5, r6
 742 037e ED A5 0B                		mov.L	44[r10], r5
 743 0381 75 42 16                		mov.L	#22, r2
 744 0384 EF 51                   		mov.L	r5, r1
 745 0386 05 00 00 00             		bsr	_rotrFixed
 746 038a EF 15                   		mov.L	r1, r5
 747 038c EF 63                   		mov.L	r6, r3
 748 038e FC 37 53                		xor	r5, r3
 749 0391 ED A4 0B                		mov.L	44[r10], r4
 750 0394 ED A5 0C                		mov.L	48[r10], r5
 751 0397 57 45                   		or	r4, r5
 752 0399 ED A4 05                		mov.L	20[r10], r4
 753 039c 53 54                   		and	r5, r4
 754 039e ED A2 0B                		mov.L	44[r10], r2
 755 03a1 ED A5 0C                		mov.L	48[r10], r5
 756 03a4 53 25                   		and	r2, r5
 757 03a6 57 45                   		or	r4, r5
 758 03a8 4B 35                   		add	r3, r5
 759 03aa E7 A5 03                		mov.L	r5, 12[r10]
 760 03ad ED A5 06                		mov.L	24[r10], r5
 761 03b0 06 89 A5 02             		add	8[r10].L, r5
 762 03b4 E7 A5 06                		mov.L	r5, 24[r10]
 763 03b7 ED A5 02                		mov.L	8[r10], r5
 764 03ba 06 89 A5 03             		add	12[r10].L, r5
 765 03be E7 A5 0A                		mov.L	r5, 40[r10]
 766                             		.loc 2 916 37 discriminator 3
 767 03c1 ED A6 09                		mov.L	36[r10], r6
 768 03c4 ED A5 06                		mov.L	24[r10], r5
 769 03c7 66 62                   		mov.L	#6, r2
 770 03c9 EF 51                   		mov.L	r5, r1
 771 03cb 05 00 00 00             		bsr	_rotrFixed
 772 03cf EF 1B                   		mov.L	r1, r11
 773 03d1 ED A5 06                		mov.L	24[r10], r5
 774 03d4 66 B2                   		mov.L	#11, r2
 775 03d6 EF 51                   		mov.L	r5, r1
 776 03d8 05 00 00 00             		bsr	_rotrFixed
 777 03dc EF 15                   		mov.L	r1, r5
 778 03de FC 37 5B                		xor	r5, r11
 779 03e1 ED A5 06                		mov.L	24[r10], r5
 780 03e4 75 42 19                		mov.L	#25, r2
 781 03e7 EF 51                   		mov.L	r5, r1
 782 03e9 05 00 00 00             		bsr	_rotrFixed
 783 03ed EF 15                   		mov.L	r1, r5
 784 03ef FC 37 B5                		xor	r11, r5
 785 03f2 FF 24 56                		add	r5, r6, r4
 786 03f5 ED A2 08                		mov.L	32[r10], r2
 787 03f8 ED A3 06                		mov.L	24[r10], r3
 788 03fb ED A1 07                		mov.L	28[r10], r1
 789 03fe ED A5 08                		mov.L	32[r10], r5
 790 0401 FC 37 15                		xor	r1, r5
 791 0404 53 35                   		and	r3, r5
 792 0406 FC 37 25                		xor	r2, r5
 793 0409 4B 54                   		add	r5, r4
 794 040b EC A5                   		mov.L	[r10], r5
 795 040d 62 35                   		add	#3, r5
 796 040f FB 32 00 00 00 00       		mov.L	#_K, r3
 797 0415 FE 65 35                		mov.L	[r5,r3], r5
 798 0418 4B 54                   		add	r5, r4
 799 041a EC A5                   		mov.L	[r10], r5
 800 041c 62 35                   		add	#3, r5
 801 041e 6C 25                   		shll	#2, r5
 802 0420 ED A3 01                		mov.L	4[r10], r3
 803 0423 4B 35                   		add	r3, r5
 804 0425 EC 55                   		mov.L	[r5], r5
 805 0427 4B 45                   		add	r4, r5
 806 0429 E7 A5 02                		mov.L	r5, 8[r10]
 807 042c ED A5 0A                		mov.L	40[r10], r5
 808 042f 66 22                   		mov.L	#2, r2
 809 0431 EF 51                   		mov.L	r5, r1
 810 0433 05 00 00 00             		bsr	_rotrFixed
 811 0437 EF 16                   		mov.L	r1, r6
 812 0439 ED A5 0A                		mov.L	40[r10], r5
 813 043c 66 D2                   		mov.L	#13, r2
 814 043e EF 51                   		mov.L	r5, r1
 815 0440 05 00 00 00             		bsr	_rotrFixed
 816 0444 EF 15                   		mov.L	r1, r5
 817 0446 FC 37 56                		xor	r5, r6
 818 0449 ED A5 0A                		mov.L	40[r10], r5
 819 044c 75 42 16                		mov.L	#22, r2
 820 044f EF 51                   		mov.L	r5, r1
 821 0451 05 00 00 00             		bsr	_rotrFixed
 822 0455 EF 15                   		mov.L	r1, r5
 823 0457 EF 63                   		mov.L	r6, r3
 824 0459 FC 37 53                		xor	r5, r3
 825 045c ED A4 0A                		mov.L	40[r10], r4
 826 045f ED A5 0B                		mov.L	44[r10], r5
 827 0462 57 45                   		or	r4, r5
 828 0464 ED A4 0C                		mov.L	48[r10], r4
 829 0467 53 54                   		and	r5, r4
 830 0469 ED A2 0A                		mov.L	40[r10], r2
 831 046c ED A5 0B                		mov.L	44[r10], r5
 832 046f 53 25                   		and	r2, r5
 833 0471 57 45                   		or	r4, r5
 834 0473 4B 35                   		add	r3, r5
 835 0475 E7 A5 03                		mov.L	r5, 12[r10]
 836 0478 ED A5 05                		mov.L	20[r10], r5
 837 047b 06 89 A5 02             		add	8[r10].L, r5
 838 047f E7 A5 05                		mov.L	r5, 20[r10]
 839 0482 ED A5 02                		mov.L	8[r10], r5
 840 0485 06 89 A5 03             		add	12[r10].L, r5
 841 0489 E7 A5 09                		mov.L	r5, 36[r10]
 917:../src/wolfcrypt/src/sha256.c ****             RND(4); RND(5); RND(6); RND(7);
 842                             		.loc 2 917 13 discriminator 3
 843 048c ED A6 08                		mov.L	32[r10], r6
 844 048f ED A5 05                		mov.L	20[r10], r5
 845 0492 66 62                   		mov.L	#6, r2
 846 0494 EF 51                   		mov.L	r5, r1
 847 0496 05 00 00 00             		bsr	_rotrFixed
 848 049a EF 1B                   		mov.L	r1, r11
 849 049c ED A5 05                		mov.L	20[r10], r5
 850 049f 66 B2                   		mov.L	#11, r2
 851 04a1 EF 51                   		mov.L	r5, r1
 852 04a3 05 00 00 00             		bsr	_rotrFixed
 853 04a7 EF 15                   		mov.L	r1, r5
 854 04a9 FC 37 5B                		xor	r5, r11
 855 04ac ED A5 05                		mov.L	20[r10], r5
 856 04af 75 42 19                		mov.L	#25, r2
 857 04b2 EF 51                   		mov.L	r5, r1
 858 04b4 05 00 00 00             		bsr	_rotrFixed
 859 04b8 EF 15                   		mov.L	r1, r5
 860 04ba FC 37 B5                		xor	r11, r5
 861 04bd FF 24 56                		add	r5, r6, r4
 862 04c0 ED A2 07                		mov.L	28[r10], r2
 863 04c3 ED A3 05                		mov.L	20[r10], r3
 864 04c6 ED A1 06                		mov.L	24[r10], r1
 865 04c9 ED A5 07                		mov.L	28[r10], r5
 866 04cc FC 37 15                		xor	r1, r5
 867 04cf 53 35                   		and	r3, r5
 868 04d1 FC 37 25                		xor	r2, r5
 869 04d4 4B 54                   		add	r5, r4
 870 04d6 EC A5                   		mov.L	[r10], r5
 871 04d8 62 45                   		add	#4, r5
 872 04da FB 32 00 00 00 00       		mov.L	#_K, r3
 873 04e0 FE 65 35                		mov.L	[r5,r3], r5
 874 04e3 4B 54                   		add	r5, r4
 875 04e5 EC A5                   		mov.L	[r10], r5
 876 04e7 62 45                   		add	#4, r5
 877 04e9 6C 25                   		shll	#2, r5
 878 04eb ED A3 01                		mov.L	4[r10], r3
 879 04ee 4B 35                   		add	r3, r5
 880 04f0 EC 55                   		mov.L	[r5], r5
 881 04f2 4B 45                   		add	r4, r5
 882 04f4 E7 A5 02                		mov.L	r5, 8[r10]
 883 04f7 ED A5 09                		mov.L	36[r10], r5
 884 04fa 66 22                   		mov.L	#2, r2
 885 04fc EF 51                   		mov.L	r5, r1
 886 04fe 05 00 00 00             		bsr	_rotrFixed
 887 0502 EF 16                   		mov.L	r1, r6
 888 0504 ED A5 09                		mov.L	36[r10], r5
 889 0507 66 D2                   		mov.L	#13, r2
 890 0509 EF 51                   		mov.L	r5, r1
 891 050b 05 00 00 00             		bsr	_rotrFixed
 892 050f EF 15                   		mov.L	r1, r5
 893 0511 FC 37 56                		xor	r5, r6
 894 0514 ED A5 09                		mov.L	36[r10], r5
 895 0517 75 42 16                		mov.L	#22, r2
 896 051a EF 51                   		mov.L	r5, r1
 897 051c 05 00 00 00             		bsr	_rotrFixed
 898 0520 EF 15                   		mov.L	r1, r5
 899 0522 EF 63                   		mov.L	r6, r3
 900 0524 FC 37 53                		xor	r5, r3
 901 0527 ED A4 09                		mov.L	36[r10], r4
 902 052a ED A5 0A                		mov.L	40[r10], r5
 903 052d 57 45                   		or	r4, r5
 904 052f ED A4 0B                		mov.L	44[r10], r4
 905 0532 53 54                   		and	r5, r4
 906 0534 ED A2 09                		mov.L	36[r10], r2
 907 0537 ED A5 0A                		mov.L	40[r10], r5
 908 053a 53 25                   		and	r2, r5
 909 053c 57 45                   		or	r4, r5
 910 053e 4B 35                   		add	r3, r5
 911 0540 E7 A5 03                		mov.L	r5, 12[r10]
 912 0543 ED A5 0C                		mov.L	48[r10], r5
 913 0546 06 89 A5 02             		add	8[r10].L, r5
 914 054a E7 A5 0C                		mov.L	r5, 48[r10]
 915 054d ED A5 02                		mov.L	8[r10], r5
 916 0550 06 89 A5 03             		add	12[r10].L, r5
 917 0554 E7 A5 08                		mov.L	r5, 32[r10]
 918                             		.loc 2 917 21 discriminator 3
 919 0557 ED A6 07                		mov.L	28[r10], r6
 920 055a ED A5 0C                		mov.L	48[r10], r5
 921 055d 66 62                   		mov.L	#6, r2
 922 055f EF 51                   		mov.L	r5, r1
 923 0561 05 00 00 00             		bsr	_rotrFixed
 924 0565 EF 1B                   		mov.L	r1, r11
 925 0567 ED A5 0C                		mov.L	48[r10], r5
 926 056a 66 B2                   		mov.L	#11, r2
 927 056c EF 51                   		mov.L	r5, r1
 928 056e 05 00 00 00             		bsr	_rotrFixed
 929 0572 EF 15                   		mov.L	r1, r5
 930 0574 FC 37 5B                		xor	r5, r11
 931 0577 ED A5 0C                		mov.L	48[r10], r5
 932 057a 75 42 19                		mov.L	#25, r2
 933 057d EF 51                   		mov.L	r5, r1
 934 057f 05 00 00 00             		bsr	_rotrFixed
 935 0583 EF 15                   		mov.L	r1, r5
 936 0585 FC 37 B5                		xor	r11, r5
 937 0588 FF 24 56                		add	r5, r6, r4
 938 058b ED A2 06                		mov.L	24[r10], r2
 939 058e ED A3 0C                		mov.L	48[r10], r3
 940 0591 ED A1 05                		mov.L	20[r10], r1
 941 0594 ED A5 06                		mov.L	24[r10], r5
 942 0597 FC 37 15                		xor	r1, r5
 943 059a 53 35                   		and	r3, r5
 944 059c FC 37 25                		xor	r2, r5
 945 059f 4B 54                   		add	r5, r4
 946 05a1 EC A5                   		mov.L	[r10], r5
 947 05a3 62 55                   		add	#5, r5
 948 05a5 FB 32 00 00 00 00       		mov.L	#_K, r3
 949 05ab FE 65 35                		mov.L	[r5,r3], r5
 950 05ae 4B 54                   		add	r5, r4
 951 05b0 EC A5                   		mov.L	[r10], r5
 952 05b2 62 55                   		add	#5, r5
 953 05b4 6C 25                   		shll	#2, r5
 954 05b6 ED A3 01                		mov.L	4[r10], r3
 955 05b9 4B 35                   		add	r3, r5
 956 05bb EC 55                   		mov.L	[r5], r5
 957 05bd 4B 45                   		add	r4, r5
 958 05bf E7 A5 02                		mov.L	r5, 8[r10]
 959 05c2 ED A5 08                		mov.L	32[r10], r5
 960 05c5 66 22                   		mov.L	#2, r2
 961 05c7 EF 51                   		mov.L	r5, r1
 962 05c9 05 00 00 00             		bsr	_rotrFixed
 963 05cd EF 16                   		mov.L	r1, r6
 964 05cf ED A5 08                		mov.L	32[r10], r5
 965 05d2 66 D2                   		mov.L	#13, r2
 966 05d4 EF 51                   		mov.L	r5, r1
 967 05d6 05 00 00 00             		bsr	_rotrFixed
 968 05da EF 15                   		mov.L	r1, r5
 969 05dc FC 37 56                		xor	r5, r6
 970 05df ED A5 08                		mov.L	32[r10], r5
 971 05e2 75 42 16                		mov.L	#22, r2
 972 05e5 EF 51                   		mov.L	r5, r1
 973 05e7 05 00 00 00             		bsr	_rotrFixed
 974 05eb EF 15                   		mov.L	r1, r5
 975 05ed EF 63                   		mov.L	r6, r3
 976 05ef FC 37 53                		xor	r5, r3
 977 05f2 ED A4 08                		mov.L	32[r10], r4
 978 05f5 ED A5 09                		mov.L	36[r10], r5
 979 05f8 57 45                   		or	r4, r5
 980 05fa ED A4 0A                		mov.L	40[r10], r4
 981 05fd 53 54                   		and	r5, r4
 982 05ff ED A2 08                		mov.L	32[r10], r2
 983 0602 ED A5 09                		mov.L	36[r10], r5
 984 0605 53 25                   		and	r2, r5
 985 0607 57 45                   		or	r4, r5
 986 0609 4B 35                   		add	r3, r5
 987 060b E7 A5 03                		mov.L	r5, 12[r10]
 988 060e ED A5 0B                		mov.L	44[r10], r5
 989 0611 06 89 A5 02             		add	8[r10].L, r5
 990 0615 E7 A5 0B                		mov.L	r5, 44[r10]
 991 0618 ED A5 02                		mov.L	8[r10], r5
 992 061b 06 89 A5 03             		add	12[r10].L, r5
 993 061f E7 A5 07                		mov.L	r5, 28[r10]
 994                             		.loc 2 917 29 discriminator 3
 995 0622 ED A6 06                		mov.L	24[r10], r6
 996 0625 ED A5 0B                		mov.L	44[r10], r5
 997 0628 66 62                   		mov.L	#6, r2
 998 062a EF 51                   		mov.L	r5, r1
 999 062c 05 00 00 00             		bsr	_rotrFixed
 1000 0630 EF 1B                   		mov.L	r1, r11
 1001 0632 ED A5 0B                		mov.L	44[r10], r5
 1002 0635 66 B2                   		mov.L	#11, r2
 1003 0637 EF 51                   		mov.L	r5, r1
 1004 0639 05 00 00 00             		bsr	_rotrFixed
 1005 063d EF 15                   		mov.L	r1, r5
 1006 063f FC 37 5B                		xor	r5, r11
 1007 0642 ED A5 0B                		mov.L	44[r10], r5
 1008 0645 75 42 19                		mov.L	#25, r2
 1009 0648 EF 51                   		mov.L	r5, r1
 1010 064a 05 00 00 00             		bsr	_rotrFixed
 1011 064e EF 15                   		mov.L	r1, r5
 1012 0650 FC 37 B5                		xor	r11, r5
 1013 0653 FF 24 56                		add	r5, r6, r4
 1014 0656 ED A2 05                		mov.L	20[r10], r2
 1015 0659 ED A3 0B                		mov.L	44[r10], r3
 1016 065c ED A1 0C                		mov.L	48[r10], r1
 1017 065f ED A5 05                		mov.L	20[r10], r5
 1018 0662 FC 37 15                		xor	r1, r5
 1019 0665 53 35                   		and	r3, r5
 1020 0667 FC 37 25                		xor	r2, r5
 1021 066a 4B 54                   		add	r5, r4
 1022 066c EC A5                   		mov.L	[r10], r5
 1023 066e 62 65                   		add	#6, r5
 1024 0670 FB 32 00 00 00 00       		mov.L	#_K, r3
 1025 0676 FE 65 35                		mov.L	[r5,r3], r5
 1026 0679 4B 54                   		add	r5, r4
 1027 067b EC A5                   		mov.L	[r10], r5
 1028 067d 62 65                   		add	#6, r5
 1029 067f 6C 25                   		shll	#2, r5
 1030 0681 ED A3 01                		mov.L	4[r10], r3
 1031 0684 4B 35                   		add	r3, r5
 1032 0686 EC 55                   		mov.L	[r5], r5
 1033 0688 4B 45                   		add	r4, r5
 1034 068a E7 A5 02                		mov.L	r5, 8[r10]
 1035 068d ED A5 07                		mov.L	28[r10], r5
 1036 0690 66 22                   		mov.L	#2, r2
 1037 0692 EF 51                   		mov.L	r5, r1
 1038 0694 05 00 00 00             		bsr	_rotrFixed
 1039 0698 EF 16                   		mov.L	r1, r6
 1040 069a ED A5 07                		mov.L	28[r10], r5
 1041 069d 66 D2                   		mov.L	#13, r2
 1042 069f EF 51                   		mov.L	r5, r1
 1043 06a1 05 00 00 00             		bsr	_rotrFixed
 1044 06a5 EF 15                   		mov.L	r1, r5
 1045 06a7 FC 37 56                		xor	r5, r6
 1046 06aa ED A5 07                		mov.L	28[r10], r5
 1047 06ad 75 42 16                		mov.L	#22, r2
 1048 06b0 EF 51                   		mov.L	r5, r1
 1049 06b2 05 00 00 00             		bsr	_rotrFixed
 1050 06b6 EF 15                   		mov.L	r1, r5
 1051 06b8 EF 63                   		mov.L	r6, r3
 1052 06ba FC 37 53                		xor	r5, r3
 1053 06bd ED A4 07                		mov.L	28[r10], r4
 1054 06c0 ED A5 08                		mov.L	32[r10], r5
 1055 06c3 57 45                   		or	r4, r5
 1056 06c5 ED A4 09                		mov.L	36[r10], r4
 1057 06c8 53 54                   		and	r5, r4
 1058 06ca ED A2 07                		mov.L	28[r10], r2
 1059 06cd ED A5 08                		mov.L	32[r10], r5
 1060 06d0 53 25                   		and	r2, r5
 1061 06d2 57 45                   		or	r4, r5
 1062 06d4 4B 35                   		add	r3, r5
 1063 06d6 E7 A5 03                		mov.L	r5, 12[r10]
 1064 06d9 ED A5 0A                		mov.L	40[r10], r5
 1065 06dc 06 89 A5 02             		add	8[r10].L, r5
 1066 06e0 E7 A5 0A                		mov.L	r5, 40[r10]
 1067 06e3 ED A5 02                		mov.L	8[r10], r5
 1068 06e6 06 89 A5 03             		add	12[r10].L, r5
 1069 06ea E7 A5 06                		mov.L	r5, 24[r10]
 1070                             		.loc 2 917 37 discriminator 3
 1071 06ed ED A6 05                		mov.L	20[r10], r6
 1072 06f0 ED A5 0A                		mov.L	40[r10], r5
 1073 06f3 66 62                   		mov.L	#6, r2
 1074 06f5 EF 51                   		mov.L	r5, r1
 1075 06f7 05 00 00 00             		bsr	_rotrFixed
 1076 06fb EF 1B                   		mov.L	r1, r11
 1077 06fd ED A5 0A                		mov.L	40[r10], r5
 1078 0700 66 B2                   		mov.L	#11, r2
 1079 0702 EF 51                   		mov.L	r5, r1
 1080 0704 05 00 00 00             		bsr	_rotrFixed
 1081 0708 EF 15                   		mov.L	r1, r5
 1082 070a FC 37 5B                		xor	r5, r11
 1083 070d ED A5 0A                		mov.L	40[r10], r5
 1084 0710 75 42 19                		mov.L	#25, r2
 1085 0713 EF 51                   		mov.L	r5, r1
 1086 0715 05 00 00 00             		bsr	_rotrFixed
 1087 0719 EF 15                   		mov.L	r1, r5
 1088 071b FC 37 B5                		xor	r11, r5
 1089 071e FF 24 56                		add	r5, r6, r4
 1090 0721 ED A2 0C                		mov.L	48[r10], r2
 1091 0724 ED A3 0A                		mov.L	40[r10], r3
 1092 0727 ED A1 0B                		mov.L	44[r10], r1
 1093 072a ED A5 0C                		mov.L	48[r10], r5
 1094 072d FC 37 15                		xor	r1, r5
 1095 0730 53 35                   		and	r3, r5
 1096 0732 FC 37 25                		xor	r2, r5
 1097 0735 4B 54                   		add	r5, r4
 1098 0737 EC A5                   		mov.L	[r10], r5
 1099 0739 62 75                   		add	#7, r5
 1100 073b FB 32 00 00 00 00       		mov.L	#_K, r3
 1101 0741 FE 65 35                		mov.L	[r5,r3], r5
 1102 0744 4B 54                   		add	r5, r4
 1103 0746 EC A5                   		mov.L	[r10], r5
 1104 0748 62 75                   		add	#7, r5
 1105 074a 6C 25                   		shll	#2, r5
 1106 074c ED A3 01                		mov.L	4[r10], r3
 1107 074f 4B 35                   		add	r3, r5
 1108 0751 EC 55                   		mov.L	[r5], r5
 1109 0753 4B 45                   		add	r4, r5
 1110 0755 E7 A5 02                		mov.L	r5, 8[r10]
 1111 0758 ED A5 06                		mov.L	24[r10], r5
 1112 075b 66 22                   		mov.L	#2, r2
 1113 075d EF 51                   		mov.L	r5, r1
 1114 075f 05 00 00 00             		bsr	_rotrFixed
 1115 0763 EF 16                   		mov.L	r1, r6
 1116 0765 ED A5 06                		mov.L	24[r10], r5
 1117 0768 66 D2                   		mov.L	#13, r2
 1118 076a EF 51                   		mov.L	r5, r1
 1119 076c 05 00 00 00             		bsr	_rotrFixed
 1120 0770 EF 15                   		mov.L	r1, r5
 1121 0772 FC 37 56                		xor	r5, r6
 1122 0775 ED A5 06                		mov.L	24[r10], r5
 1123 0778 75 42 16                		mov.L	#22, r2
 1124 077b EF 51                   		mov.L	r5, r1
 1125 077d 05 00 00 00             		bsr	_rotrFixed
 1126 0781 EF 15                   		mov.L	r1, r5
 1127 0783 EF 63                   		mov.L	r6, r3
 1128 0785 FC 37 53                		xor	r5, r3
 1129 0788 ED A4 06                		mov.L	24[r10], r4
 1130 078b ED A5 07                		mov.L	28[r10], r5
 1131 078e 57 45                   		or	r4, r5
 1132 0790 ED A4 08                		mov.L	32[r10], r4
 1133 0793 53 54                   		and	r5, r4
 1134 0795 ED A2 06                		mov.L	24[r10], r2
 1135 0798 ED A5 07                		mov.L	28[r10], r5
 1136 079b 53 25                   		and	r2, r5
 1137 079d 57 45                   		or	r4, r5
 1138 079f 4B 35                   		add	r3, r5
 1139 07a1 E7 A5 03                		mov.L	r5, 12[r10]
 1140 07a4 ED A5 09                		mov.L	36[r10], r5
 1141 07a7 06 89 A5 02             		add	8[r10].L, r5
 1142 07ab E7 A5 09                		mov.L	r5, 36[r10]
 1143 07ae ED A5 02                		mov.L	8[r10], r5
 1144 07b1 06 89 A5 03             		add	12[r10].L, r5
 1145 07b5 E7 A5 05                		mov.L	r5, 20[r10]
 915:../src/wolfcrypt/src/sha256.c ****             RND(0); RND(1); RND(2); RND(3);
 1146                             		.loc 2 915 49 discriminator 3
 1147 07b8 EC A5                   		mov.L	[r10], r5
 1148 07ba 62 85                   		add	#8, r5
 1149 07bc E3 A5                   		mov.L	r5, [r10]
 1150                             	.L28:
 915:../src/wolfcrypt/src/sha256.c ****             RND(0); RND(1); RND(2); RND(3);
 1151                             		.loc 2 915 9 discriminator 1
 1152 07be EC A5                   		mov.L	[r10], r5
 1153 07c0 75 55 3F                		cmp	#63, r5
 1154 07c3 2A 05 38 9F F9          		ble	.L29
 918:../src/wolfcrypt/src/sha256.c ****         }
 919:../src/wolfcrypt/src/sha256.c ****     #endif /* USE_SLOW_SHA256 */
 920:../src/wolfcrypt/src/sha256.c **** 
 921:../src/wolfcrypt/src/sha256.c ****         /* Add the working vars back into digest state[] */
 922:../src/wolfcrypt/src/sha256.c ****         for (i = 0; i < 8; i++) {
 1155                             		.loc 2 922 16
 1156 07c8 F8 A6 00                		mov.L	#0, [r10]
 1157                             		.loc 2 922 9
 1158 07cb 2E 23                   		bra	.L30
 1159                             	.L31:
 923:../src/wolfcrypt/src/sha256.c ****             sha256->digest[i] += S[i];
 1160                             		.loc 2 923 31 discriminator 3
 1161 07cd ED A5 0D                		mov.L	52[r10], r5
 1162 07d0 EC A4                   		mov.L	[r10], r4
 1163 07d2 FE 64 54                		mov.L	[r4,r5], r4
 1164                             		.loc 2 923 35 discriminator 3
 1165 07d5 EC A5                   		mov.L	[r10], r5
 1166 07d7 6C 25                   		shll	#2, r5
 1167 07d9 4B A5                   		add	r10, r5
 1168 07db A9 5D                   		mov.L	20[r5], r5
 1169                             		.loc 2 923 31 discriminator 3
 1170 07dd FF 23 54                		add	r5, r4, r3
 1171 07e0 ED A5 0D                		mov.L	52[r10], r5
 1172 07e3 EC A4                   		mov.L	[r10], r4
 1173 07e5 FE 24 53                		mov.L	r3, [r4,r5]
 922:../src/wolfcrypt/src/sha256.c ****             sha256->digest[i] += S[i];
 1174                             		.loc 2 922 29 discriminator 3
 1175 07e8 EC A5                   		mov.L	[r10], r5
 1176 07ea 62 15                   		add	#1, r5
 1177 07ec E3 A5                   		mov.L	r5, [r10]
 1178                             	.L30:
 922:../src/wolfcrypt/src/sha256.c ****             sha256->digest[i] += S[i];
 1179                             		.loc 2 922 9 discriminator 1
 1180 07ee EC A5                   		mov.L	[r10], r5
 1181 07f0 61 75                   		cmp	#7, r5
 1182 07f2 2B DB                   		ble	.L31
 1183                             	.LBB2:
 924:../src/wolfcrypt/src/sha256.c ****         }
 925:../src/wolfcrypt/src/sha256.c **** 
 926:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
 927:../src/wolfcrypt/src/sha256.c ****         XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 1184                             		.loc 2 927 9
 1185 07f4 ED A5 01                		mov.L	4[r10], r5
 1186 07f7 E7 A5 04                		mov.L	r5, 16[r10]
 1187 07fa ED A5 04                		mov.L	16[r10], r5
 1188 07fd 61 05                   		cmp	#0, r5
 1189 07ff 10                      		beq	.L32
 1190                             		.loc 2 927 9 is_stmt 0 discriminator 1
 1191 0800 ED A1 04                		mov.L	16[r10], r1
 1192 0803 05 00 00 00             		bsr	_wolfSSL_Free
 1193                             	.L32:
 1194                             	.LBE2:
 928:../src/wolfcrypt/src/sha256.c ****     #endif
 929:../src/wolfcrypt/src/sha256.c ****         return 0;
 1195                             		.loc 2 929 16 is_stmt 1
 1196 0807 66 05                   		mov.L	#0, r5
 1197                             	.L33:
 930:../src/wolfcrypt/src/sha256.c ****     }
 1198                             		.loc 2 930 5 discriminator 1
 1199 0809 EF 51                   		mov.L	r5, r1
 1200 080b 3F 6B 15                		rtsd	#84, r6-r11
 1201                             	.LFE45:
 1203                             		.section	.text.AddLength,"ax",@progbits
 1205                             	_AddLength:
 1206                             	.LFB46:
 931:../src/wolfcrypt/src/sha256.c **** #else
 932:../src/wolfcrypt/src/sha256.c ****     /* SHA256 version that keeps all data in registers */
 933:../src/wolfcrypt/src/sha256.c ****     #define SCHED1(j) (W[j] = *((word32*)&data[j*sizeof(word32)]))
 934:../src/wolfcrypt/src/sha256.c ****     #define SCHED(j) (               \
 935:../src/wolfcrypt/src/sha256.c ****                    W[ j     & 15] += \
 936:../src/wolfcrypt/src/sha256.c ****             Gamma1(W[(j-2)  & 15])+  \
 937:../src/wolfcrypt/src/sha256.c ****                    W[(j-7)  & 15] +  \
 938:../src/wolfcrypt/src/sha256.c ****             Gamma0(W[(j-15) & 15])   \
 939:../src/wolfcrypt/src/sha256.c ****         )
 940:../src/wolfcrypt/src/sha256.c **** 
 941:../src/wolfcrypt/src/sha256.c ****     #define RND1(j) \
 942:../src/wolfcrypt/src/sha256.c ****          t0 = h(j) + Sigma1(e(j)) + Ch(e(j), f(j), g(j)) + K[i+j] + SCHED1(j); \
 943:../src/wolfcrypt/src/sha256.c ****          t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
 944:../src/wolfcrypt/src/sha256.c ****          d(j) += t0; \
 945:../src/wolfcrypt/src/sha256.c ****          h(j)  = t0 + t1
 946:../src/wolfcrypt/src/sha256.c ****     #define RNDN(j) \
 947:../src/wolfcrypt/src/sha256.c ****          t0 = h(j) + Sigma1(e(j)) + Ch(e(j), f(j), g(j)) + K[i+j] + SCHED(j); \
 948:../src/wolfcrypt/src/sha256.c ****          t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
 949:../src/wolfcrypt/src/sha256.c ****          d(j) += t0; \
 950:../src/wolfcrypt/src/sha256.c ****          h(j)  = t0 + t1
 951:../src/wolfcrypt/src/sha256.c **** 
 952:../src/wolfcrypt/src/sha256.c ****     static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
 953:../src/wolfcrypt/src/sha256.c ****     {
 954:../src/wolfcrypt/src/sha256.c ****         word32 S[8], t0, t1;
 955:../src/wolfcrypt/src/sha256.c ****         int i;
 956:../src/wolfcrypt/src/sha256.c ****         word32 W[WC_SHA256_BLOCK_SIZE/sizeof(word32)];
 957:../src/wolfcrypt/src/sha256.c **** 
 958:../src/wolfcrypt/src/sha256.c ****         /* Copy digest to working vars */
 959:../src/wolfcrypt/src/sha256.c ****         S[0] = sha256->digest[0];
 960:../src/wolfcrypt/src/sha256.c ****         S[1] = sha256->digest[1];
 961:../src/wolfcrypt/src/sha256.c ****         S[2] = sha256->digest[2];
 962:../src/wolfcrypt/src/sha256.c ****         S[3] = sha256->digest[3];
 963:../src/wolfcrypt/src/sha256.c ****         S[4] = sha256->digest[4];
 964:../src/wolfcrypt/src/sha256.c ****         S[5] = sha256->digest[5];
 965:../src/wolfcrypt/src/sha256.c ****         S[6] = sha256->digest[6];
 966:../src/wolfcrypt/src/sha256.c ****         S[7] = sha256->digest[7];
 967:../src/wolfcrypt/src/sha256.c **** 
 968:../src/wolfcrypt/src/sha256.c ****         i = 0;
 969:../src/wolfcrypt/src/sha256.c ****         RND1( 0); RND1( 1); RND1( 2); RND1( 3);
 970:../src/wolfcrypt/src/sha256.c ****         RND1( 4); RND1( 5); RND1( 6); RND1( 7);
 971:../src/wolfcrypt/src/sha256.c ****         RND1( 8); RND1( 9); RND1(10); RND1(11);
 972:../src/wolfcrypt/src/sha256.c ****         RND1(12); RND1(13); RND1(14); RND1(15);
 973:../src/wolfcrypt/src/sha256.c ****         /* 64 operations, partially loop unrolled */
 974:../src/wolfcrypt/src/sha256.c ****         for (i = 16; i < 64; i += 16) {
 975:../src/wolfcrypt/src/sha256.c ****             RNDN( 0); RNDN( 1); RNDN( 2); RNDN( 3);
 976:../src/wolfcrypt/src/sha256.c ****             RNDN( 4); RNDN( 5); RNDN( 6); RNDN( 7);
 977:../src/wolfcrypt/src/sha256.c ****             RNDN( 8); RNDN( 9); RNDN(10); RNDN(11);
 978:../src/wolfcrypt/src/sha256.c ****             RNDN(12); RNDN(13); RNDN(14); RNDN(15);
 979:../src/wolfcrypt/src/sha256.c ****         }
 980:../src/wolfcrypt/src/sha256.c **** 
 981:../src/wolfcrypt/src/sha256.c ****         /* Add the working vars back into digest */
 982:../src/wolfcrypt/src/sha256.c ****         sha256->digest[0] += S[0];
 983:../src/wolfcrypt/src/sha256.c ****         sha256->digest[1] += S[1];
 984:../src/wolfcrypt/src/sha256.c ****         sha256->digest[2] += S[2];
 985:../src/wolfcrypt/src/sha256.c ****         sha256->digest[3] += S[3];
 986:../src/wolfcrypt/src/sha256.c ****         sha256->digest[4] += S[4];
 987:../src/wolfcrypt/src/sha256.c ****         sha256->digest[5] += S[5];
 988:../src/wolfcrypt/src/sha256.c ****         sha256->digest[6] += S[6];
 989:../src/wolfcrypt/src/sha256.c ****         sha256->digest[7] += S[7];
 990:../src/wolfcrypt/src/sha256.c **** 
 991:../src/wolfcrypt/src/sha256.c ****         return 0;
 992:../src/wolfcrypt/src/sha256.c ****     }
 993:../src/wolfcrypt/src/sha256.c **** #endif /* SHA256_MANY_REGISTERS */
 994:../src/wolfcrypt/src/sha256.c **** #endif
 995:../src/wolfcrypt/src/sha256.c **** /* End wc_ software implementation */
 996:../src/wolfcrypt/src/sha256.c **** 
 997:../src/wolfcrypt/src/sha256.c **** 
 998:../src/wolfcrypt/src/sha256.c **** #ifdef XTRANSFORM
 999:../src/wolfcrypt/src/sha256.c **** 
1000:../src/wolfcrypt/src/sha256.c ****     static WC_INLINE void AddLength(wc_Sha256* sha256, word32 len)
1001:../src/wolfcrypt/src/sha256.c ****     {
 1207                             		.loc 2 1001 5
 1208 0000 7E AA                   		push.l	r10
 1209                             	.LCFI17:
 1210 0002 71 0A F4                		add	#-12, r0, r10
 1211                             	.LCFI18:
 1212 0005 EF A0                   		mov.L	r10, r0
 1213 0007 E7 A1 01                		mov.L	r1, 4[r10]
 1214 000a E7 A2 02                		mov.L	r2, 8[r10]
1002:../src/wolfcrypt/src/sha256.c ****         word32 tmp = sha256->loLen;
 1215                             		.loc 2 1002 16
 1216 000d ED A5 01                		mov.L	4[r10], r5
 1217 0010 AE 5D                   		mov.L	100[r5], r5
 1218 0012 E3 A5                   		mov.L	r5, [r10]
1003:../src/wolfcrypt/src/sha256.c ****         if ((sha256->loLen += len) < tmp) {
 1219                             		.loc 2 1003 28
 1220 0014 ED A5 01                		mov.L	4[r10], r5
 1221 0017 AE 5D                   		mov.L	100[r5], r5
 1222 0019 EF 54                   		mov.L	r5, r4
 1223 001b 06 89 A4 02             		add	8[r10].L, r4
 1224 001f ED A5 01                		mov.L	4[r10], r5
 1225 0022 A6 5C                   		mov.L	r4, 100[r5]
 1226 0024 ED A5 01                		mov.L	4[r10], r5
 1227 0027 AE 5D                   		mov.L	100[r5], r5
 1228                             		.loc 2 1003 12
 1229 0029 EC A4                   		mov.L	[r10], r4
 1230 002b 47 54                   		cmp	r5, r4
 1231 002d 25 0F                   		bleu	.L36
1004:../src/wolfcrypt/src/sha256.c ****             sha256->hiLen++;                       /* carry low to high */
 1232                             		.loc 2 1004 19
 1233 002f ED A5 01                		mov.L	4[r10], r5
 1234 0032 AE D5                   		mov.L	104[r5], r5
 1235                             		.loc 2 1004 26
 1236 0034 71 54 01                		add	#1, r5, r4
 1237 0037 ED A5 01                		mov.L	4[r10], r5
 1238 003a A6 D4                   		mov.L	r4, 104[r5]
 1239                             	.L36:
1005:../src/wolfcrypt/src/sha256.c ****         }
1006:../src/wolfcrypt/src/sha256.c ****     }
 1240                             		.loc 2 1006 5
 1241 003c 03                      		nop
 1242 003d 3F AA 04                		rtsd	#16, r10-r10
 1243                             	.LFE46:
 1245                             		.section	.text.Sha256Update,"ax",@progbits
 1247                             	_Sha256Update:
 1248                             	.LFB47:
1007:../src/wolfcrypt/src/sha256.c **** 
1008:../src/wolfcrypt/src/sha256.c ****     /* do block size increments/updates */
1009:../src/wolfcrypt/src/sha256.c ****     static WC_INLINE int Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
1010:../src/wolfcrypt/src/sha256.c ****     {
 1249                             		.loc 2 1010 5
 1250 0000 7E AA                   		push.l	r10
 1251                             	.LCFI19:
 1252 0002 71 0A E4                		add	#-28, r0, r10
 1253                             	.LCFI20:
 1254 0005 EF A0                   		mov.L	r10, r0
 1255 0007 E7 A1 04                		mov.L	r1, 16[r10]
 1256 000a E7 A2 05                		mov.L	r2, 20[r10]
 1257 000d E7 A3 06                		mov.L	r3, 24[r10]
1011:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
 1258                             		.loc 2 1011 13
 1259 0010 F8 A6 00                		mov.L	#0, [r10]
1012:../src/wolfcrypt/src/sha256.c ****         word32 blocksLen;
1013:../src/wolfcrypt/src/sha256.c ****         byte* local;
1014:../src/wolfcrypt/src/sha256.c **** 
1015:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL || (data == NULL && len > 0)) {
 1260                             		.loc 2 1015 12
 1261 0013 ED A5 04                		mov.L	16[r10], r5
 1262 0016 61 05                   		cmp	#0, r5
 1263 0018 20 0F                   		beq	.L38
 1264                             		.loc 2 1015 28 discriminator 1
 1265 001a ED A5 05                		mov.L	20[r10], r5
 1266 001d 61 05                   		cmp	#0, r5
 1267 001f 21 0F                   		bne	.L39
 1268                             		.loc 2 1015 45 discriminator 2
 1269 0021 ED A5 06                		mov.L	24[r10], r5
 1270 0024 61 05                   		cmp	#0, r5
 1271 0026 10                      		beq	.L39
 1272                             	.L38:
1016:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 1273                             		.loc 2 1016 20
 1274 0027 FB 5A 53 FF             		mov.L	#-173, r5
 1275 002b 38 4D 01                		bra	.L40
 1276                             	.L39:
1017:../src/wolfcrypt/src/sha256.c ****         }
1018:../src/wolfcrypt/src/sha256.c **** 
1019:../src/wolfcrypt/src/sha256.c ****         if (data == NULL && len == 0) {
 1277                             		.loc 2 1019 12
 1278 002e ED A5 05                		mov.L	20[r10], r5
 1279 0031 61 05                   		cmp	#0, r5
 1280 0033 21 0D                   		bne	.L41
 1281                             		.loc 2 1019 26 discriminator 1
 1282 0035 ED A5 06                		mov.L	24[r10], r5
 1283 0038 61 05                   		cmp	#0, r5
 1284 003a 1E                      		bne	.L41
1020:../src/wolfcrypt/src/sha256.c ****             /* valid, but do nothing */
1021:../src/wolfcrypt/src/sha256.c ****             return 0;
 1285                             		.loc 2 1021 20
 1286 003b 66 05                   		mov.L	#0, r5
 1287 003d 38 3B 01                		bra	.L40
 1288                             	.L41:
1022:../src/wolfcrypt/src/sha256.c ****         }
1023:../src/wolfcrypt/src/sha256.c **** 
1024:../src/wolfcrypt/src/sha256.c ****         /* check that internal buffLen is valid */
1025:../src/wolfcrypt/src/sha256.c ****         if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
 1289                             		.loc 2 1025 19
 1290 0040 ED A5 04                		mov.L	16[r10], r5
 1291 0043 AE 55                   		mov.L	96[r5], r5
 1292                             		.loc 2 1025 12
 1293 0045 75 55 3F                		cmp	#63, r5
 1294 0048 25 09                   		bleu	.L42
1026:../src/wolfcrypt/src/sha256.c ****             return BUFFER_E;
 1295                             		.loc 2 1026 20
 1296 004a FB 5A 7C FF             		mov.L	#-132, r5
 1297 004e 38 2A 01                		bra	.L40
 1298                             	.L42:
1027:../src/wolfcrypt/src/sha256.c ****         }
1028:../src/wolfcrypt/src/sha256.c **** 
1029:../src/wolfcrypt/src/sha256.c ****         /* add length for final */
1030:../src/wolfcrypt/src/sha256.c ****         AddLength(sha256, len);
 1299                             		.loc 2 1030 9
 1300 0051 ED A2 06                		mov.L	24[r10], r2
 1301 0054 ED A1 04                		mov.L	16[r10], r1
 1302 0057 05 00 00 00             		bsr	_AddLength
1031:../src/wolfcrypt/src/sha256.c **** 
1032:../src/wolfcrypt/src/sha256.c ****         local = (byte*)sha256->buffer;
 1303                             		.loc 2 1032 15
 1304 005b ED A5 04                		mov.L	16[r10], r5
 1305 005e 71 55 20                		add	#32, r5
 1306 0061 E7 A5 01                		mov.L	r5, 4[r10]
1033:../src/wolfcrypt/src/sha256.c **** 
1034:../src/wolfcrypt/src/sha256.c ****         /* process any remainder from previous operation */
1035:../src/wolfcrypt/src/sha256.c ****         if (sha256->buffLen > 0) {
 1307                             		.loc 2 1035 19
 1308 0064 ED A5 04                		mov.L	16[r10], r5
 1309 0067 AE 55                   		mov.L	96[r5], r5
 1310                             		.loc 2 1035 12
 1311 0069 61 05                   		cmp	#0, r5
 1312 006b 3A DD 00                		beq	.L45
1036:../src/wolfcrypt/src/sha256.c ****             blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
 1313                             		.loc 2 1036 63
 1314 006e ED A5 04                		mov.L	16[r10], r5
 1315 0071 AE 55                   		mov.L	96[r5], r5
 1316                             		.loc 2 1036 25
 1317 0073 75 44 40                		mov.L	#0x40, r4
 1318 0076 FF 05 54                		sub	r5, r4, r5
 1319 0079 EF 52                   		mov.L	r5, r2
 1320 007b ED A1 06                		mov.L	24[r10], r1
 1321 007e 05 00 00 00             		bsr	_min
 1322 0082 E7 A1 02                		mov.L	r1, 8[r10]
1037:../src/wolfcrypt/src/sha256.c ****             XMEMCPY(&local[sha256->buffLen], data, blocksLen);
 1323                             		.loc 2 1037 13
 1324 0085 ED A5 04                		mov.L	16[r10], r5
 1325 0088 AE 55                   		mov.L	96[r5], r5
 1326 008a ED A4 01                		mov.L	4[r10], r4
 1327 008d 4B 45                   		add	r4, r5
 1328 008f ED A3 02                		mov.L	8[r10], r3
 1329 0092 ED A2 05                		mov.L	20[r10], r2
 1330 0095 EF 51                   		mov.L	r5, r1
 1331 0097 05 00 00 00             		bsr	_memcpy
1038:../src/wolfcrypt/src/sha256.c **** 
1039:../src/wolfcrypt/src/sha256.c ****             sha256->buffLen += blocksLen;
 1332                             		.loc 2 1039 29
 1333 009b ED A5 04                		mov.L	16[r10], r5
 1334 009e AE 55                   		mov.L	96[r5], r5
 1335 00a0 EF 54                   		mov.L	r5, r4
 1336 00a2 06 89 A4 02             		add	8[r10].L, r4
 1337 00a6 ED A5 04                		mov.L	16[r10], r5
 1338 00a9 A6 54                   		mov.L	r4, 96[r5]
1040:../src/wolfcrypt/src/sha256.c ****             data            += blocksLen;
 1339                             		.loc 2 1040 29
 1340 00ab ED A5 05                		mov.L	20[r10], r5
 1341 00ae 06 89 A5 02             		add	8[r10].L, r5
 1342 00b2 E7 A5 05                		mov.L	r5, 20[r10]
1041:../src/wolfcrypt/src/sha256.c ****             len             -= blocksLen;
 1343                             		.loc 2 1041 29
 1344 00b5 ED A4 06                		mov.L	24[r10], r4
 1345 00b8 ED A5 02                		mov.L	8[r10], r5
 1346 00bb FF 05 54                		sub	r5, r4, r5
 1347 00be E7 A5 06                		mov.L	r5, 24[r10]
1042:../src/wolfcrypt/src/sha256.c **** 
1043:../src/wolfcrypt/src/sha256.c ****             if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
 1348                             		.loc 2 1043 23
 1349 00c1 ED A5 04                		mov.L	16[r10], r5
 1350 00c4 AE 55                   		mov.L	96[r5], r5
 1351                             		.loc 2 1043 16
 1352 00c6 75 55 40                		cmp	#0x40, r5
 1353 00c9 21 7F                   		bne	.L45
1044:../src/wolfcrypt/src/sha256.c ****             #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
1045:../src/wolfcrypt/src/sha256.c ****                 #if defined(USE_INTEL_SPEEDUP) && \
1046:../src/wolfcrypt/src/sha256.c ****                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
1047:../src/wolfcrypt/src/sha256.c ****                 if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
1048:../src/wolfcrypt/src/sha256.c ****                 #endif
1049:../src/wolfcrypt/src/sha256.c ****                 {
1050:../src/wolfcrypt/src/sha256.c ****                     ByteReverseWords(sha256->buffer, sha256->buffer,
 1354                             		.loc 2 1050 44
 1355 00cb ED A5 04                		mov.L	16[r10], r5
 1356 00ce 71 54 20                		add	#32, r5, r4
 1357                             		.loc 2 1050 60
 1358 00d1 ED A5 04                		mov.L	16[r10], r5
 1359 00d4 71 55 20                		add	#32, r5
 1360                             		.loc 2 1050 21
 1361 00d7 75 43 40                		mov.L	#0x40, r3
 1362 00da EF 52                   		mov.L	r5, r2
 1363 00dc EF 41                   		mov.L	r4, r1
 1364 00de 05 00 00 00             		bsr	_ByteReverseWords
1051:../src/wolfcrypt/src/sha256.c ****                         WC_SHA256_BLOCK_SIZE);
1052:../src/wolfcrypt/src/sha256.c ****                 }
1053:../src/wolfcrypt/src/sha256.c ****             #endif
1054:../src/wolfcrypt/src/sha256.c **** 
1055:../src/wolfcrypt/src/sha256.c ****             #if defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
1056:../src/wolfcrypt/src/sha256.c ****                 !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
1057:../src/wolfcrypt/src/sha256.c ****                 if (sha256->ctx.mode == ESP32_SHA_INIT){
1058:../src/wolfcrypt/src/sha256.c ****                     esp_sha_try_hw_lock(&sha256->ctx);
1059:../src/wolfcrypt/src/sha256.c ****                 }
1060:../src/wolfcrypt/src/sha256.c ****                 if (sha256->ctx.mode == ESP32_SHA_SW){
1061:../src/wolfcrypt/src/sha256.c ****                     ret = XTRANSFORM(sha256, (const byte*)local);
1062:../src/wolfcrypt/src/sha256.c ****                 } else {
1063:../src/wolfcrypt/src/sha256.c ****                     esp_sha256_process(sha256, (const byte*)local);
1064:../src/wolfcrypt/src/sha256.c ****                 }
1065:../src/wolfcrypt/src/sha256.c ****             #else
1066:../src/wolfcrypt/src/sha256.c ****                 ret = XTRANSFORM(sha256, (const byte*)local);
 1365                             		.loc 2 1066 23
 1366 00e2 ED A2 01                		mov.L	4[r10], r2
 1367 00e5 ED A1 04                		mov.L	16[r10], r1
 1368 00e8 05 00 00 00             		bsr	_Transform_Sha256
 1369 00ec E3 A1                   		mov.L	r1, [r10]
1067:../src/wolfcrypt/src/sha256.c ****             #endif
1068:../src/wolfcrypt/src/sha256.c **** 
1069:../src/wolfcrypt/src/sha256.c ****                 if (ret == 0)
 1370                             		.loc 2 1069 20
 1371 00ee EC A5                   		mov.L	[r10], r5
 1372 00f0 61 05                   		cmp	#0, r5
 1373 00f2 19                      		bne	.L44
1070:../src/wolfcrypt/src/sha256.c ****                     sha256->buffLen = 0;
 1374                             		.loc 2 1070 37
 1375 00f3 ED A5 04                		mov.L	16[r10], r5
 1376 00f6 3E D8 00                		mov.L	#0, 96[r5]
 1377 00f9 2E 4F                   		bra	.L45
 1378                             	.L44:
1071:../src/wolfcrypt/src/sha256.c ****                 else
1072:../src/wolfcrypt/src/sha256.c ****                     len = 0; /* error */
 1379                             		.loc 2 1072 25
 1380 00fb F9 A6 06 00             		mov.L	#0, 24[r10]
1073:../src/wolfcrypt/src/sha256.c ****             }
1074:../src/wolfcrypt/src/sha256.c ****         }
1075:../src/wolfcrypt/src/sha256.c **** 
1076:../src/wolfcrypt/src/sha256.c ****         /* process blocks */
1077:../src/wolfcrypt/src/sha256.c ****     #ifdef XTRANSFORM_LEN
1078:../src/wolfcrypt/src/sha256.c ****         #if defined(USE_INTEL_SPEEDUP) && \
1079:../src/wolfcrypt/src/sha256.c ****                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
1080:../src/wolfcrypt/src/sha256.c ****         if (Transform_Sha256_Len_p != NULL)
1081:../src/wolfcrypt/src/sha256.c ****         #endif
1082:../src/wolfcrypt/src/sha256.c ****         {
1083:../src/wolfcrypt/src/sha256.c ****             /* get number of blocks */
1084:../src/wolfcrypt/src/sha256.c ****             /* 64-1 = 0x3F (~ Inverted = 0xFFFFFFC0) */
1085:../src/wolfcrypt/src/sha256.c ****             /* len (masked by 0xFFFFFFC0) returns block aligned length */
1086:../src/wolfcrypt/src/sha256.c ****             blocksLen = len & ~(WC_SHA256_BLOCK_SIZE-1);
1087:../src/wolfcrypt/src/sha256.c ****             if (blocksLen > 0) {
1088:../src/wolfcrypt/src/sha256.c ****                 /* Byte reversal and alignment handled in function if required */
1089:../src/wolfcrypt/src/sha256.c ****                 XTRANSFORM_LEN(sha256, data, blocksLen);
1090:../src/wolfcrypt/src/sha256.c ****                 data += blocksLen;
1091:../src/wolfcrypt/src/sha256.c ****                 len  -= blocksLen;
1092:../src/wolfcrypt/src/sha256.c ****             }
1093:../src/wolfcrypt/src/sha256.c ****         }
1094:../src/wolfcrypt/src/sha256.c ****         #if defined(USE_INTEL_SPEEDUP) && \
1095:../src/wolfcrypt/src/sha256.c ****                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
1096:../src/wolfcrypt/src/sha256.c ****         else
1097:../src/wolfcrypt/src/sha256.c ****         #endif
1098:../src/wolfcrypt/src/sha256.c ****     #endif /* XTRANSFORM_LEN */
1099:../src/wolfcrypt/src/sha256.c ****     #if !defined(XTRANSFORM_LEN) || (defined(USE_INTEL_SPEEDUP) && \
1100:../src/wolfcrypt/src/sha256.c ****                          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
1101:../src/wolfcrypt/src/sha256.c ****         {
1102:../src/wolfcrypt/src/sha256.c ****             while (len >= WC_SHA256_BLOCK_SIZE) {
 1381                             		.loc 2 1102 19
 1382 00ff 2E 49                   		bra	.L45
 1383                             	.L47:
 1384                             	.LBB3:
1103:../src/wolfcrypt/src/sha256.c ****                 word32* local32 = sha256->buffer;
 1385                             		.loc 2 1103 25
 1386 0101 ED A5 04                		mov.L	16[r10], r5
 1387 0104 71 55 20                		add	#32, r5
 1388 0107 E7 A5 03                		mov.L	r5, 12[r10]
1104:../src/wolfcrypt/src/sha256.c ****                 /* optimization to avoid memcpy if data pointer is properly aligned */
1105:../src/wolfcrypt/src/sha256.c ****                 /* Intel transform function requires use of sha256->buffer */
1106:../src/wolfcrypt/src/sha256.c ****                 /* Little Endian requires byte swap, so can't use data directly */
1107:../src/wolfcrypt/src/sha256.c ****             #if defined(WC_HASH_DATA_ALIGNMENT) && !defined(LITTLE_ENDIAN_ORDER) && \
1108:../src/wolfcrypt/src/sha256.c ****                 !(defined(USE_INTEL_SPEEDUP) && \
1109:../src/wolfcrypt/src/sha256.c ****                          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
1110:../src/wolfcrypt/src/sha256.c ****                 if (((wc_ptr_t)data % WC_HASH_DATA_ALIGNMENT) == 0) {
1111:../src/wolfcrypt/src/sha256.c ****                     local32 = (word32*)data;
1112:../src/wolfcrypt/src/sha256.c ****                 }
1113:../src/wolfcrypt/src/sha256.c ****                 else
1114:../src/wolfcrypt/src/sha256.c ****             #endif
1115:../src/wolfcrypt/src/sha256.c ****                 {
1116:../src/wolfcrypt/src/sha256.c ****                     XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
 1389                             		.loc 2 1116 21
 1390 010a 75 43 40                		mov.L	#0x40, r3
 1391 010d ED A2 05                		mov.L	20[r10], r2
 1392 0110 ED A1 03                		mov.L	12[r10], r1
 1393 0113 05 00 00 00             		bsr	_memcpy
1117:../src/wolfcrypt/src/sha256.c ****                 }
1118:../src/wolfcrypt/src/sha256.c **** 
1119:../src/wolfcrypt/src/sha256.c ****                 data += WC_SHA256_BLOCK_SIZE;
 1394                             		.loc 2 1119 22
 1395 0117 ED A5 05                		mov.L	20[r10], r5
 1396 011a 71 55 40                		add	#0x40, r5
 1397 011d E7 A5 05                		mov.L	r5, 20[r10]
1120:../src/wolfcrypt/src/sha256.c ****                 len  -= WC_SHA256_BLOCK_SIZE;
 1398                             		.loc 2 1120 22
 1399 0120 ED A5 06                		mov.L	24[r10], r5
 1400 0123 71 55 C0                		add	#-64, r5
 1401 0126 E7 A5 06                		mov.L	r5, 24[r10]
1121:../src/wolfcrypt/src/sha256.c **** 
1122:../src/wolfcrypt/src/sha256.c ****             #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
1123:../src/wolfcrypt/src/sha256.c ****                 #if defined(USE_INTEL_SPEEDUP) && \
1124:../src/wolfcrypt/src/sha256.c ****                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
1125:../src/wolfcrypt/src/sha256.c ****                 if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
1126:../src/wolfcrypt/src/sha256.c ****                 #endif
1127:../src/wolfcrypt/src/sha256.c ****                 {
1128:../src/wolfcrypt/src/sha256.c ****                     ByteReverseWords(local32, local32, WC_SHA256_BLOCK_SIZE);
 1402                             		.loc 2 1128 21
 1403 0129 75 43 40                		mov.L	#0x40, r3
 1404 012c ED A2 03                		mov.L	12[r10], r2
 1405 012f ED A1 03                		mov.L	12[r10], r1
 1406 0132 05 00 00 00             		bsr	_ByteReverseWords
1129:../src/wolfcrypt/src/sha256.c ****                 }
1130:../src/wolfcrypt/src/sha256.c ****             #endif
1131:../src/wolfcrypt/src/sha256.c **** 
1132:../src/wolfcrypt/src/sha256.c ****             #if defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
1133:../src/wolfcrypt/src/sha256.c ****                 !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
1134:../src/wolfcrypt/src/sha256.c ****                 if (sha256->ctx.mode == ESP32_SHA_INIT){
1135:../src/wolfcrypt/src/sha256.c ****                     esp_sha_try_hw_lock(&sha256->ctx);
1136:../src/wolfcrypt/src/sha256.c ****                 }
1137:../src/wolfcrypt/src/sha256.c ****                 if (sha256->ctx.mode == ESP32_SHA_SW){
1138:../src/wolfcrypt/src/sha256.c ****                     ret = XTRANSFORM(sha256, (const byte*)local32);
1139:../src/wolfcrypt/src/sha256.c ****                 } else {
1140:../src/wolfcrypt/src/sha256.c ****                     esp_sha256_process(sha256, (const byte*)local32);
1141:../src/wolfcrypt/src/sha256.c ****                 }
1142:../src/wolfcrypt/src/sha256.c ****             #else
1143:../src/wolfcrypt/src/sha256.c ****                 ret = XTRANSFORM(sha256, (const byte*)local32);
 1407                             		.loc 2 1143 23
 1408 0136 ED A2 03                		mov.L	12[r10], r2
 1409 0139 ED A1 04                		mov.L	16[r10], r1
 1410 013c 05 00 00 00             		bsr	_Transform_Sha256
 1411 0140 E3 A1                   		mov.L	r1, [r10]
1144:../src/wolfcrypt/src/sha256.c ****             #endif
1145:../src/wolfcrypt/src/sha256.c **** 
1146:../src/wolfcrypt/src/sha256.c ****                 if (ret != 0)
 1412                             		.loc 2 1146 20
 1413 0142 EC A5                   		mov.L	[r10], r5
 1414 0144 61 05                   		cmp	#0, r5
 1415 0146 21 0C                   		bne	.L49
 1416                             		.balign 8,3,1
 1417                             	.L45:
 1418                             	.LBE3:
1102:../src/wolfcrypt/src/sha256.c ****                 word32* local32 = sha256->buffer;
 1419                             		.loc 2 1102 19
 1420 0148 ED A5 06                		mov.L	24[r10], r5
 1421 014b 75 55 3F                		cmp	#63, r5
 1422 014e 24 B3                   		bgtu	.L47
 1423 0150 2E 03                   		bra	.L46
 1424                             	.L49:
 1425                             	.LBB4:
1147:../src/wolfcrypt/src/sha256.c ****                     break;
 1426                             		.loc 2 1147 21
 1427 0152 03                      		nop
 1428                             	.L46:
 1429                             	.LBE4:
1148:../src/wolfcrypt/src/sha256.c ****             }
1149:../src/wolfcrypt/src/sha256.c ****         }
1150:../src/wolfcrypt/src/sha256.c ****     #endif
1151:../src/wolfcrypt/src/sha256.c **** 
1152:../src/wolfcrypt/src/sha256.c ****         /* save remainder */
1153:../src/wolfcrypt/src/sha256.c ****         if (ret == 0 && len > 0) {
 1430                             		.loc 2 1153 12
 1431 0153 EC A5                   		mov.L	[r10], r5
 1432 0155 61 05                   		cmp	#0, r5
 1433 0157 21 1E                   		bne	.L48
 1434                             		.loc 2 1153 22 discriminator 1
 1435 0159 ED A5 06                		mov.L	24[r10], r5
 1436 015c 61 05                   		cmp	#0, r5
 1437 015e 20 17                   		beq	.L48
1154:../src/wolfcrypt/src/sha256.c ****             XMEMCPY(local, data, len);
 1438                             		.loc 2 1154 13
 1439 0160 ED A3 06                		mov.L	24[r10], r3
 1440 0163 ED A2 05                		mov.L	20[r10], r2
 1441 0166 ED A1 01                		mov.L	4[r10], r1
 1442 0169 05 00 00 00             		bsr	_memcpy
1155:../src/wolfcrypt/src/sha256.c ****             sha256->buffLen = len;
 1443                             		.loc 2 1155 29
 1444 016d ED A5 04                		mov.L	16[r10], r5
 1445 0170 ED A4 06                		mov.L	24[r10], r4
 1446 0173 A6 54                   		mov.L	r4, 96[r5]
 1447                             	.L48:
1156:../src/wolfcrypt/src/sha256.c ****         }
1157:../src/wolfcrypt/src/sha256.c **** 
1158:../src/wolfcrypt/src/sha256.c ****         return ret;
 1448                             		.loc 2 1158 16
 1449 0175 EC A5                   		mov.L	[r10], r5
 1450 0177 03                      		.balign 8,3,1
 1451                             	.L40:
1159:../src/wolfcrypt/src/sha256.c ****     }
 1452                             		.loc 2 1159 5
 1453 0178 EF 51                   		mov.L	r5, r1
 1454 017a 3F AA 08                		rtsd	#32, r10-r10
 1455                             	.LFE47:
 1457 017d FC 13 00                		.section	.text.wc_Sha256Update,"ax",@progbits
 1458                             		.global	_wc_Sha256Update
 1460                             	_wc_Sha256Update:
 1461                             	.LFB48:
1160:../src/wolfcrypt/src/sha256.c **** 
1161:../src/wolfcrypt/src/sha256.c **** #if defined(WOLFSSL_KCAPI_HASH)
1162:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */
1163:../src/wolfcrypt/src/sha256.c **** 
1164:../src/wolfcrypt/src/sha256.c **** #else
1165:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
1166:../src/wolfcrypt/src/sha256.c ****     {
 1462                             		.loc 2 1166 5
 1463 0000 7E AA                   		push.l	r10
 1464                             	.LCFI21:
 1465 0002 71 0A F4                		add	#-12, r0, r10
 1466                             	.LCFI22:
 1467 0005 EF A0                   		mov.L	r10, r0
 1468 0007 E3 A1                   		mov.L	r1, [r10]
 1469 0009 E7 A2 01                		mov.L	r2, 4[r10]
 1470 000c E7 A3 02                		mov.L	r3, 8[r10]
1167:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL || (data == NULL && len > 0)) {
 1471                             		.loc 2 1167 12
 1472 000f EC A5                   		mov.L	[r10], r5
 1473 0011 61 05                   		cmp	#0, r5
 1474 0013 20 0F                   		beq	.L51
 1475                             		.loc 2 1167 28 discriminator 1
 1476 0015 ED A5 01                		mov.L	4[r10], r5
 1477 0018 61 05                   		cmp	#0, r5
 1478 001a 21 0E                   		bne	.L52
 1479                             		.loc 2 1167 45 discriminator 2
 1480 001c ED A5 02                		mov.L	8[r10], r5
 1481 001f 61 05                   		cmp	#0, r5
 1482 0021 17                      		beq	.L52
 1483                             	.L51:
1168:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 1484                             		.loc 2 1168 20
 1485 0022 FB 5A 53 FF             		mov.L	#-173, r5
 1486 0026 2E 21                   		bra	.L53
 1487                             	.L52:
1169:../src/wolfcrypt/src/sha256.c ****         }
1170:../src/wolfcrypt/src/sha256.c **** 
1171:../src/wolfcrypt/src/sha256.c ****         if (data == NULL && len == 0) {
 1488                             		.loc 2 1171 12
 1489 0028 ED A5 01                		mov.L	4[r10], r5
 1490 002b 61 05                   		cmp	#0, r5
 1491 002d 21 0C                   		bne	.L54
 1492                             		.loc 2 1171 26 discriminator 1
 1493 002f ED A5 02                		mov.L	8[r10], r5
 1494 0032 61 05                   		cmp	#0, r5
 1495 0034 1D                      		bne	.L54
1172:../src/wolfcrypt/src/sha256.c ****             /* valid, but do nothing */
1173:../src/wolfcrypt/src/sha256.c ****             return 0;
 1496                             		.loc 2 1173 20
 1497 0035 66 05                   		mov.L	#0, r5
 1498 0037 2E 10                   		bra	.L53
 1499                             	.L54:
1174:../src/wolfcrypt/src/sha256.c ****         }
1175:../src/wolfcrypt/src/sha256.c **** 
1176:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLF_CRYPTO_CB
1177:../src/wolfcrypt/src/sha256.c ****         if (sha256->devId != INVALID_DEVID) {
1178:../src/wolfcrypt/src/sha256.c ****             int ret = wc_CryptoCb_Sha256Hash(sha256, data, len, NULL);
1179:../src/wolfcrypt/src/sha256.c ****             if (ret != CRYPTOCB_UNAVAILABLE)
1180:../src/wolfcrypt/src/sha256.c ****                 return ret;
1181:../src/wolfcrypt/src/sha256.c ****             /* fall-through when unavailable */
1182:../src/wolfcrypt/src/sha256.c ****         }
1183:../src/wolfcrypt/src/sha256.c ****     #endif
1184:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
1185:../src/wolfcrypt/src/sha256.c ****         if (sha256->asyncDev.marker == WOLFSSL_ASYNC_MARKER_SHA256) {
1186:../src/wolfcrypt/src/sha256.c ****         #if defined(HAVE_INTEL_QA)
1187:../src/wolfcrypt/src/sha256.c ****             return IntelQaSymSha256(&sha256->asyncDev, NULL, data, len);
1188:../src/wolfcrypt/src/sha256.c ****         #endif
1189:../src/wolfcrypt/src/sha256.c ****         }
1190:../src/wolfcrypt/src/sha256.c ****     #endif /* WOLFSSL_ASYNC_CRYPT */
1191:../src/wolfcrypt/src/sha256.c **** 
1192:../src/wolfcrypt/src/sha256.c ****         return Sha256Update(sha256, data, len);
 1500                             		.loc 2 1192 16
 1501 0039 ED A3 02                		mov.L	8[r10], r3
 1502 003c ED A2 01                		mov.L	4[r10], r2
 1503 003f EC A1                   		mov.L	[r10], r1
 1504 0041 05 00 00 00             		bsr	_Sha256Update
 1505 0045 EF 15                   		mov.L	r1, r5
 1506                             	.L53:
1193:../src/wolfcrypt/src/sha256.c ****     }
 1507                             		.loc 2 1193 5
 1508 0047 EF 51                   		mov.L	r5, r1
 1509 0049 3F AA 04                		rtsd	#16, r10-r10
 1510                             	.LFE48:
 1512                             		.section	.text.Sha256Final,"ax",@progbits
 1514                             	_Sha256Final:
 1515                             	.LFB49:
1194:../src/wolfcrypt/src/sha256.c **** #endif
1195:../src/wolfcrypt/src/sha256.c **** 
1196:../src/wolfcrypt/src/sha256.c ****     static WC_INLINE int Sha256Final(wc_Sha256* sha256)
1197:../src/wolfcrypt/src/sha256.c ****     {
 1516                             		.loc 2 1197 5
 1517 0000 7E AA                   		push.l	r10
 1518                             	.LCFI23:
 1519 0002 71 0A F4                		add	#-12, r0, r10
 1520                             	.LCFI24:
 1521 0005 EF A0                   		mov.L	r10, r0
 1522 0007 E7 A1 02                		mov.L	r1, 8[r10]
1198:../src/wolfcrypt/src/sha256.c **** 
1199:../src/wolfcrypt/src/sha256.c ****         int ret;
1200:../src/wolfcrypt/src/sha256.c ****         byte* local;
1201:../src/wolfcrypt/src/sha256.c **** 
1202:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL) {
 1523                             		.loc 2 1202 12
 1524 000a ED A5 02                		mov.L	8[r10], r5
 1525 000d 61 05                   		cmp	#0, r5
 1526 000f 18                      		bne	.L56
1203:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 1527                             		.loc 2 1203 20
 1528 0010 FB 5A 53 FF             		mov.L	#-173, r5
 1529 0014 38 05 01                		bra	.L57
 1530                             	.L56:
1204:../src/wolfcrypt/src/sha256.c ****         }
1205:../src/wolfcrypt/src/sha256.c **** 
1206:../src/wolfcrypt/src/sha256.c ****         local = (byte*)sha256->buffer;
 1531                             		.loc 2 1206 15
 1532 0017 ED A5 02                		mov.L	8[r10], r5
 1533 001a 71 55 20                		add	#32, r5
 1534 001d E3 A5                   		mov.L	r5, [r10]
1207:../src/wolfcrypt/src/sha256.c ****         local[sha256->buffLen++] = 0x80; /* add 1 */
 1535                             		.loc 2 1207 21
 1536 001f ED A5 02                		mov.L	8[r10], r5
 1537 0022 AE 55                   		mov.L	96[r5], r5
 1538                             		.loc 2 1207 30
 1539 0024 71 53 01                		add	#1, r5, r3
 1540 0027 ED A4 02                		mov.L	8[r10], r4
 1541 002a A6 43                   		mov.L	r3, 96[r4]
 1542                             		.loc 2 1207 14
 1543 002c EC A4                   		mov.L	[r10], r4
 1544 002e 4B 45                   		add	r4, r5
 1545                             		.loc 2 1207 34
 1546 0030 F8 54 80                		mov.B	#-128, [r5]
1208:../src/wolfcrypt/src/sha256.c **** 
1209:../src/wolfcrypt/src/sha256.c ****         /* pad with zeros */
1210:../src/wolfcrypt/src/sha256.c ****         if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
 1547                             		.loc 2 1210 19
 1548 0033 ED A5 02                		mov.L	8[r10], r5
 1549 0036 AE 55                   		mov.L	96[r5], r5
 1550                             		.loc 2 1210 12
 1551 0038 75 55 38                		cmp	#56, r5
 1552 003b 25 5A                   		bleu	.L58
1211:../src/wolfcrypt/src/sha256.c ****             XMEMSET(&local[sha256->buffLen], 0,
 1553                             		.loc 2 1211 13
 1554 003d ED A5 02                		mov.L	8[r10], r5
 1555 0040 AE 55                   		mov.L	96[r5], r5
 1556 0042 EC A4                   		mov.L	[r10], r4
 1557 0044 FF 21 54                		add	r5, r4, r1
 1558 0047 ED A5 02                		mov.L	8[r10], r5
 1559 004a AE 55                   		mov.L	96[r5], r5
 1560 004c 75 44 40                		mov.L	#0x40, r4
 1561 004f FF 05 54                		sub	r5, r4, r5
 1562 0052 EF 53                   		mov.L	r5, r3
 1563 0054 66 02                   		mov.L	#0, r2
 1564 0056 05 00 00 00             		bsr	_memset
1212:../src/wolfcrypt/src/sha256.c ****                 WC_SHA256_BLOCK_SIZE - sha256->buffLen);
1213:../src/wolfcrypt/src/sha256.c ****             sha256->buffLen += WC_SHA256_BLOCK_SIZE - sha256->buffLen;
 1565                             		.loc 2 1213 29
 1566 005a ED A5 02                		mov.L	8[r10], r5
 1567 005d 3E D8 40                		mov.L	#0x40, 96[r5]
1214:../src/wolfcrypt/src/sha256.c **** 
1215:../src/wolfcrypt/src/sha256.c ****         #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
1216:../src/wolfcrypt/src/sha256.c ****             #if defined(USE_INTEL_SPEEDUP) && \
1217:../src/wolfcrypt/src/sha256.c ****                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
1218:../src/wolfcrypt/src/sha256.c ****             if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
1219:../src/wolfcrypt/src/sha256.c ****             #endif
1220:../src/wolfcrypt/src/sha256.c ****             {
1221:../src/wolfcrypt/src/sha256.c ****                 ByteReverseWords(sha256->buffer, sha256->buffer,
 1568                             		.loc 2 1221 40
 1569 0060 ED A5 02                		mov.L	8[r10], r5
 1570 0063 71 54 20                		add	#32, r5, r4
 1571                             		.loc 2 1221 56
 1572 0066 ED A5 02                		mov.L	8[r10], r5
 1573 0069 71 55 20                		add	#32, r5
 1574                             		.loc 2 1221 17
 1575 006c 75 43 40                		mov.L	#0x40, r3
 1576 006f EF 52                   		mov.L	r5, r2
 1577 0071 EF 41                   		mov.L	r4, r1
 1578 0073 05 00 00 00             		bsr	_ByteReverseWords
1222:../src/wolfcrypt/src/sha256.c ****                                                       WC_SHA256_BLOCK_SIZE);
1223:../src/wolfcrypt/src/sha256.c ****             }
1224:../src/wolfcrypt/src/sha256.c ****         #endif
1225:../src/wolfcrypt/src/sha256.c **** 
1226:../src/wolfcrypt/src/sha256.c ****         #if defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
1227:../src/wolfcrypt/src/sha256.c ****              !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
1228:../src/wolfcrypt/src/sha256.c ****             if (sha256->ctx.mode == ESP32_SHA_INIT) {
1229:../src/wolfcrypt/src/sha256.c ****                 esp_sha_try_hw_lock(&sha256->ctx);
1230:../src/wolfcrypt/src/sha256.c ****             }
1231:../src/wolfcrypt/src/sha256.c ****             if (sha256->ctx.mode == ESP32_SHA_SW) {
1232:../src/wolfcrypt/src/sha256.c ****                 ret = XTRANSFORM(sha256, (const byte*)local);
1233:../src/wolfcrypt/src/sha256.c ****             } else {
1234:../src/wolfcrypt/src/sha256.c ****                 ret = esp_sha256_process(sha256, (const byte*)local);
1235:../src/wolfcrypt/src/sha256.c ****             }
1236:../src/wolfcrypt/src/sha256.c ****         #else
1237:../src/wolfcrypt/src/sha256.c ****             ret = XTRANSFORM(sha256, (const byte*)local);
 1579                             		.loc 2 1237 19
 1580 0077 EC A2                   		mov.L	[r10], r2
 1581 0079 ED A1 02                		mov.L	8[r10], r1
 1582 007c 05 00 00 00             		bsr	_Transform_Sha256
 1583 0080 E7 A1 01                		mov.L	r1, 4[r10]
1238:../src/wolfcrypt/src/sha256.c ****         #endif
1239:../src/wolfcrypt/src/sha256.c ****             if (ret != 0)
 1584                             		.loc 2 1239 16
 1585 0083 ED A5 01                		mov.L	4[r10], r5
 1586 0086 61 05                   		cmp	#0, r5
 1587 0088 17                      		beq	.L59
1240:../src/wolfcrypt/src/sha256.c ****                 return ret;
 1588                             		.loc 2 1240 24
 1589 0089 ED A5 01                		mov.L	4[r10], r5
 1590 008c 38 8D 00                		bra	.L57
 1591                             	.L59:
1241:../src/wolfcrypt/src/sha256.c **** 
1242:../src/wolfcrypt/src/sha256.c ****             sha256->buffLen = 0;
 1592                             		.loc 2 1242 29
 1593 008f ED A5 02                		mov.L	8[r10], r5
 1594 0092 3E D8 00                		mov.L	#0, 96[r5]
 1595                             	.L58:
1243:../src/wolfcrypt/src/sha256.c ****         }
1244:../src/wolfcrypt/src/sha256.c ****         XMEMSET(&local[sha256->buffLen], 0,
 1596                             		.loc 2 1244 9
 1597 0095 ED A5 02                		mov.L	8[r10], r5
 1598 0098 AE 55                   		mov.L	96[r5], r5
 1599 009a EC A4                   		mov.L	[r10], r4
 1600 009c FF 21 54                		add	r5, r4, r1
 1601 009f ED A5 02                		mov.L	8[r10], r5
 1602 00a2 AE 55                   		mov.L	96[r5], r5
 1603 00a4 75 44 38                		mov.L	#56, r4
 1604 00a7 FF 05 54                		sub	r5, r4, r5
 1605 00aa EF 53                   		mov.L	r5, r3
 1606 00ac 66 02                   		mov.L	#0, r2
 1607 00ae 05 00 00 00             		bsr	_memset
1245:../src/wolfcrypt/src/sha256.c ****             WC_SHA256_PAD_SIZE - sha256->buffLen);
1246:../src/wolfcrypt/src/sha256.c **** 
1247:../src/wolfcrypt/src/sha256.c ****         /* put lengths in bits */
1248:../src/wolfcrypt/src/sha256.c ****         sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 1608                             		.loc 2 1248 32
 1609 00b2 ED A5 02                		mov.L	8[r10], r5
 1610 00b5 AE 5D                   		mov.L	100[r5], r5
 1611                             		.loc 2 1248 40
 1612 00b7 FD 9D 54                		shlr	#29, r5, r4
1249:../src/wolfcrypt/src/sha256.c ****                                                          (sha256->hiLen << 3);
 1613                             		.loc 2 1249 65
 1614 00ba ED A5 02                		mov.L	8[r10], r5
 1615 00bd AE D5                   		mov.L	104[r5], r5
 1616                             		.loc 2 1249 73
 1617 00bf 6C 35                   		shll	#3, r5
1248:../src/wolfcrypt/src/sha256.c ****                                                          (sha256->hiLen << 3);
 1618                             		.loc 2 1248 76
 1619 00c1 4B 54                   		add	r5, r4
1248:../src/wolfcrypt/src/sha256.c ****                                                          (sha256->hiLen << 3);
 1620                             		.loc 2 1248 23
 1621 00c3 ED A5 02                		mov.L	8[r10], r5
 1622 00c6 A6 D4                   		mov.L	r4, 104[r5]
1250:../src/wolfcrypt/src/sha256.c ****         sha256->loLen = sha256->loLen << 3;
 1623                             		.loc 2 1250 31
 1624 00c8 ED A5 02                		mov.L	8[r10], r5
 1625 00cb AE 5D                   		mov.L	100[r5], r5
 1626                             		.loc 2 1250 39
 1627 00cd FD C3 54                		shll	#3, r5, r4
 1628                             		.loc 2 1250 23
 1629 00d0 ED A5 02                		mov.L	8[r10], r5
 1630 00d3 A6 5C                   		mov.L	r4, 100[r5]
1251:../src/wolfcrypt/src/sha256.c **** 
1252:../src/wolfcrypt/src/sha256.c ****         /* store lengths */
1253:../src/wolfcrypt/src/sha256.c ****     #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
1254:../src/wolfcrypt/src/sha256.c ****         #if defined(USE_INTEL_SPEEDUP) && \
1255:../src/wolfcrypt/src/sha256.c ****                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
1256:../src/wolfcrypt/src/sha256.c ****         if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
1257:../src/wolfcrypt/src/sha256.c ****         #endif
1258:../src/wolfcrypt/src/sha256.c ****         {
1259:../src/wolfcrypt/src/sha256.c ****             ByteReverseWords(sha256->buffer, sha256->buffer,
 1631                             		.loc 2 1259 36
 1632 00d5 ED A5 02                		mov.L	8[r10], r5
 1633 00d8 71 54 20                		add	#32, r5, r4
 1634                             		.loc 2 1259 52
 1635 00db ED A5 02                		mov.L	8[r10], r5
 1636 00de 71 55 20                		add	#32, r5
 1637                             		.loc 2 1259 13
 1638 00e1 75 43 40                		mov.L	#0x40, r3
 1639 00e4 EF 52                   		mov.L	r5, r2
 1640 00e6 EF 41                   		mov.L	r4, r1
 1641 00e8 05 00 00 00             		bsr	_ByteReverseWords
1260:../src/wolfcrypt/src/sha256.c ****                 WC_SHA256_BLOCK_SIZE);
1261:../src/wolfcrypt/src/sha256.c ****         }
1262:../src/wolfcrypt/src/sha256.c ****     #endif
1263:../src/wolfcrypt/src/sha256.c ****         /* ! length ordering dependent on digest endian type ! */
1264:../src/wolfcrypt/src/sha256.c ****         XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
 1642                             		.loc 2 1264 9
 1643 00ec EC A5                   		mov.L	[r10], r5
 1644 00ee 71 55 38                		add	#56, r5
 1645 00f1 ED A4 02                		mov.L	8[r10], r4
 1646 00f4 71 44 68                		add	#0x68, r4
 1647 00f7 EC 44                   		mov.L	[r4], r4
 1648 00f9 E3 54                   		mov.L	r4, [r5]
1265:../src/wolfcrypt/src/sha256.c ****         XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
 1649                             		.loc 2 1265 9
 1650 00fb EC A5                   		mov.L	[r10], r5
 1651 00fd 71 55 3C                		add	#60, r5
 1652 0100 ED A4 02                		mov.L	8[r10], r4
 1653 0103 71 44 64                		add	#0x64, r4
 1654 0106 EC 44                   		mov.L	[r4], r4
 1655 0108 E3 54                   		mov.L	r4, [r5]
1266:../src/wolfcrypt/src/sha256.c ****                 sizeof(word32));
1267:../src/wolfcrypt/src/sha256.c **** 
1268:../src/wolfcrypt/src/sha256.c ****     #if defined(FREESCALE_MMCAU_SHA) || (defined(USE_INTEL_SPEEDUP) && \
1269:../src/wolfcrypt/src/sha256.c ****                          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
1270:../src/wolfcrypt/src/sha256.c ****         /* Kinetis requires only these bytes reversed */
1271:../src/wolfcrypt/src/sha256.c ****         #if defined(USE_INTEL_SPEEDUP) && \
1272:../src/wolfcrypt/src/sha256.c ****                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
1273:../src/wolfcrypt/src/sha256.c ****         if (IS_INTEL_AVX1(intel_flags) || IS_INTEL_AVX2(intel_flags))
1274:../src/wolfcrypt/src/sha256.c ****         #endif
1275:../src/wolfcrypt/src/sha256.c ****         {
1276:../src/wolfcrypt/src/sha256.c ****             ByteReverseWords(
1277:../src/wolfcrypt/src/sha256.c ****                 &sha256->buffer[WC_SHA256_PAD_SIZE / sizeof(word32)],
1278:../src/wolfcrypt/src/sha256.c ****                 &sha256->buffer[WC_SHA256_PAD_SIZE / sizeof(word32)],
1279:../src/wolfcrypt/src/sha256.c ****                 2 * sizeof(word32));
1280:../src/wolfcrypt/src/sha256.c ****         }
1281:../src/wolfcrypt/src/sha256.c ****     #endif
1282:../src/wolfcrypt/src/sha256.c **** 
1283:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
1284:../src/wolfcrypt/src/sha256.c ****          !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
1285:../src/wolfcrypt/src/sha256.c ****         if (sha256->ctx.mode == ESP32_SHA_INIT) {
1286:../src/wolfcrypt/src/sha256.c ****             esp_sha_try_hw_lock(&sha256->ctx);
1287:../src/wolfcrypt/src/sha256.c ****         }
1288:../src/wolfcrypt/src/sha256.c ****         if (sha256->ctx.mode == ESP32_SHA_SW) {
1289:../src/wolfcrypt/src/sha256.c ****             ret = XTRANSFORM(sha256, (const byte*)local);
1290:../src/wolfcrypt/src/sha256.c ****         } else {
1291:../src/wolfcrypt/src/sha256.c ****             ret = esp_sha256_digest_process(sha256, 1);
1292:../src/wolfcrypt/src/sha256.c ****         }
1293:../src/wolfcrypt/src/sha256.c ****     #else
1294:../src/wolfcrypt/src/sha256.c ****         ret = XTRANSFORM(sha256, (const byte*)local);
 1656                             		.loc 2 1294 15
 1657 010a EC A2                   		mov.L	[r10], r2
 1658 010c ED A1 02                		mov.L	8[r10], r1
 1659 010f 05 00 00 00             		bsr	_Transform_Sha256
 1660 0113 E7 A1 01                		mov.L	r1, 4[r10]
1295:../src/wolfcrypt/src/sha256.c ****     #endif
1296:../src/wolfcrypt/src/sha256.c **** 
1297:../src/wolfcrypt/src/sha256.c ****         return ret;
 1661                             		.loc 2 1297 16
 1662 0116 ED A5 01                		mov.L	4[r10], r5
 1663                             	.L57:
1298:../src/wolfcrypt/src/sha256.c ****     }
 1664                             		.loc 2 1298 5
 1665 0119 EF 51                   		mov.L	r5, r1
 1666 011b 3F AA 04                		rtsd	#16, r10-r10
 1667                             	.LFE49:
 1669                             		.section	.text.wc_Sha256FinalRaw,"ax",@progbits
 1670                             		.global	_wc_Sha256FinalRaw
 1672                             	_wc_Sha256FinalRaw:
 1673                             	.LFB50:
1299:../src/wolfcrypt/src/sha256.c **** 
1300:../src/wolfcrypt/src/sha256.c **** #if !defined(WOLFSSL_KCAPI_HASH)
1301:../src/wolfcrypt/src/sha256.c **** 
1302:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256FinalRaw(wc_Sha256* sha256, byte* hash)
1303:../src/wolfcrypt/src/sha256.c ****     {
 1674                             		.loc 2 1303 5
 1675 0000 7E AA                   		push.l	r10
 1676                             	.LCFI25:
 1677 0002 71 0A D8                		add	#-40, r0, r10
 1678                             	.LCFI26:
 1679 0005 EF A0                   		mov.L	r10, r0
 1680 0007 E7 A1 08                		mov.L	r1, 32[r10]
 1681 000a E7 A2 09                		mov.L	r2, 36[r10]
1304:../src/wolfcrypt/src/sha256.c ****     #ifdef LITTLE_ENDIAN_ORDER
1305:../src/wolfcrypt/src/sha256.c ****         word32 digest[WC_SHA256_DIGEST_SIZE / sizeof(word32)];
1306:../src/wolfcrypt/src/sha256.c ****     #endif
1307:../src/wolfcrypt/src/sha256.c **** 
1308:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL || hash == NULL) {
 1682                             		.loc 2 1308 12
 1683 000d ED A5 08                		mov.L	32[r10], r5
 1684 0010 61 05                   		cmp	#0, r5
 1685 0012 17                      		beq	.L61
 1686                             		.loc 2 1308 28 discriminator 1
 1687 0013 ED A5 09                		mov.L	36[r10], r5
 1688 0016 61 05                   		cmp	#0, r5
 1689 0018 1F                      		bne	.L62
 1690                             	.L61:
1309:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 1691                             		.loc 2 1309 20
 1692 0019 FB 5A 53 FF             		mov.L	#-173, r5
 1693 001d 2E 20                   		bra	.L64
 1694                             	.L62:
1310:../src/wolfcrypt/src/sha256.c ****         }
1311:../src/wolfcrypt/src/sha256.c **** 
1312:../src/wolfcrypt/src/sha256.c ****     #ifdef LITTLE_ENDIAN_ORDER
1313:../src/wolfcrypt/src/sha256.c ****         ByteReverseWords((word32*)digest, (word32*)sha256->digest,
 1695                             		.loc 2 1313 52
 1696 001f ED A5 08                		mov.L	32[r10], r5
 1697                             		.loc 2 1313 9
 1698 0022 75 43 20                		mov.L	#32, r3
 1699 0025 EF 52                   		mov.L	r5, r2
 1700 0027 EF A1                   		mov.L	r10, r1
 1701 0029 05 00 00 00             		bsr	_ByteReverseWords
1314:../src/wolfcrypt/src/sha256.c ****                                                          WC_SHA256_DIGEST_SIZE);
1315:../src/wolfcrypt/src/sha256.c ****         XMEMCPY(hash, digest, WC_SHA256_DIGEST_SIZE);
 1702                             		.loc 2 1315 9
 1703 002d ED A4 09                		mov.L	36[r10], r4
 1704 0030 75 45 20                		mov.L	#32, r5
 1705 0033 EF 41                   		mov.L	r4, r1
 1706 0035 EF A2                   		mov.L	r10, r2
 1707 0037 EF 53                   		mov.L	r5, r3
 1708 0039 7F 8F                   		smovf
1316:../src/wolfcrypt/src/sha256.c ****     #else
1317:../src/wolfcrypt/src/sha256.c ****         XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
1318:../src/wolfcrypt/src/sha256.c ****     #endif
1319:../src/wolfcrypt/src/sha256.c **** 
1320:../src/wolfcrypt/src/sha256.c ****         return 0;
 1709                             		.loc 2 1320 16
 1710 003b 66 05                   		mov.L	#0, r5
 1711                             	.L64:
1321:../src/wolfcrypt/src/sha256.c ****     }
 1712                             		.loc 2 1321 5 discriminator 1
 1713 003d EF 51                   		mov.L	r5, r1
 1714 003f 3F AA 0B                		rtsd	#44, r10-r10
 1715                             	.LFE50:
 1717                             		.section	.text.wc_Sha256Final,"ax",@progbits
 1718                             		.global	_wc_Sha256Final
 1720                             	_wc_Sha256Final:
 1721                             	.LFB51:
1322:../src/wolfcrypt/src/sha256.c **** 
1323:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
1324:../src/wolfcrypt/src/sha256.c ****     {
 1722                             		.loc 2 1324 5
 1723 0000 7E AA                   		push.l	r10
 1724                             	.LCFI27:
 1725 0002 71 0A F4                		add	#-12, r0, r10
 1726                             	.LCFI28:
 1727 0005 EF A0                   		mov.L	r10, r0
 1728 0007 E7 A1 01                		mov.L	r1, 4[r10]
 1729 000a E7 A2 02                		mov.L	r2, 8[r10]
1325:../src/wolfcrypt/src/sha256.c ****         int ret;
1326:../src/wolfcrypt/src/sha256.c **** 
1327:../src/wolfcrypt/src/sha256.c ****         if (sha256 == NULL || hash == NULL) {
 1730                             		.loc 2 1327 12
 1731 000d ED A5 01                		mov.L	4[r10], r5
 1732 0010 61 05                   		cmp	#0, r5
 1733 0012 17                      		beq	.L66
 1734                             		.loc 2 1327 28 discriminator 1
 1735 0013 ED A5 02                		mov.L	8[r10], r5
 1736 0016 61 05                   		cmp	#0, r5
 1737 0018 1F                      		bne	.L67
 1738                             	.L66:
1328:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
 1739                             		.loc 2 1328 20
 1740 0019 FB 5A 53 FF             		mov.L	#-173, r5
 1741 001d 2E 3D                   		bra	.L68
 1742                             	.L67:
1329:../src/wolfcrypt/src/sha256.c ****         }
1330:../src/wolfcrypt/src/sha256.c **** 
1331:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLF_CRYPTO_CB
1332:../src/wolfcrypt/src/sha256.c ****         if (sha256->devId != INVALID_DEVID) {
1333:../src/wolfcrypt/src/sha256.c ****             ret = wc_CryptoCb_Sha256Hash(sha256, NULL, 0, hash);
1334:../src/wolfcrypt/src/sha256.c ****             if (ret != CRYPTOCB_UNAVAILABLE)
1335:../src/wolfcrypt/src/sha256.c ****                 return ret;
1336:../src/wolfcrypt/src/sha256.c ****             /* fall-through when unavailable */
1337:../src/wolfcrypt/src/sha256.c ****         }
1338:../src/wolfcrypt/src/sha256.c ****     #endif
1339:../src/wolfcrypt/src/sha256.c **** 
1340:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
1341:../src/wolfcrypt/src/sha256.c ****         if (sha256->asyncDev.marker == WOLFSSL_ASYNC_MARKER_SHA256) {
1342:../src/wolfcrypt/src/sha256.c ****         #if defined(HAVE_INTEL_QA)
1343:../src/wolfcrypt/src/sha256.c ****             return IntelQaSymSha256(&sha256->asyncDev, hash, NULL,
1344:../src/wolfcrypt/src/sha256.c ****                                             WC_SHA256_DIGEST_SIZE);
1345:../src/wolfcrypt/src/sha256.c ****         #endif
1346:../src/wolfcrypt/src/sha256.c ****         }
1347:../src/wolfcrypt/src/sha256.c ****     #endif /* WOLFSSL_ASYNC_CRYPT */
1348:../src/wolfcrypt/src/sha256.c **** 
1349:../src/wolfcrypt/src/sha256.c ****         ret = Sha256Final(sha256);
 1743                             		.loc 2 1349 15
 1744 001f ED A1 01                		mov.L	4[r10], r1
 1745 0022 05 00 00 00             		bsr	_Sha256Final
 1746 0026 E3 A1                   		mov.L	r1, [r10]
1350:../src/wolfcrypt/src/sha256.c ****         if (ret != 0)
 1747                             		.loc 2 1350 12
 1748 0028 EC A5                   		mov.L	[r10], r5
 1749 002a 61 05                   		cmp	#0, r5
 1750 002c 15                      		beq	.L69
1351:../src/wolfcrypt/src/sha256.c ****             return ret;
 1751                             		.loc 2 1351 20
 1752 002d EC A5                   		mov.L	[r10], r5
 1753 002f 2E 2B                   		bra	.L68
 1754                             	.L69:
1352:../src/wolfcrypt/src/sha256.c **** 
1353:../src/wolfcrypt/src/sha256.c ****     #if defined(LITTLE_ENDIAN_ORDER)
1354:../src/wolfcrypt/src/sha256.c ****         ByteReverseWords(sha256->digest, sha256->digest, WC_SHA256_DIGEST_SIZE);
 1755                             		.loc 2 1354 32
 1756 0031 ED A5 01                		mov.L	4[r10], r5
 1757                             		.loc 2 1354 48
 1758 0034 ED A4 01                		mov.L	4[r10], r4
 1759                             		.loc 2 1354 9
 1760 0037 75 43 20                		mov.L	#32, r3
 1761 003a EF 42                   		mov.L	r4, r2
 1762 003c EF 51                   		mov.L	r5, r1
 1763 003e 05 00 00 00             		bsr	_ByteReverseWords
1355:../src/wolfcrypt/src/sha256.c ****     #endif
1356:../src/wolfcrypt/src/sha256.c ****         XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
 1764                             		.loc 2 1356 9
 1765 0042 ED A5 01                		mov.L	4[r10], r5
 1766 0045 75 43 20                		mov.L	#32, r3
 1767 0048 EF 52                   		mov.L	r5, r2
 1768 004a ED A1 02                		mov.L	8[r10], r1
 1769 004d 05 00 00 00             		bsr	_memcpy
1357:../src/wolfcrypt/src/sha256.c **** 
1358:../src/wolfcrypt/src/sha256.c ****         return InitSha256(sha256);  /* reset state */
 1770                             		.loc 2 1358 16
 1771 0051 ED A1 01                		mov.L	4[r10], r1
 1772 0054 05 00 00 00             		bsr	_InitSha256
 1773 0058 EF 15                   		mov.L	r1, r5
 1774                             	.L68:
1359:../src/wolfcrypt/src/sha256.c ****     }
 1775                             		.loc 2 1359 5
 1776 005a EF 51                   		mov.L	r5, r1
 1777 005c 3F AA 04                		rtsd	#16, r10-r10
 1778                             	.LFE51:
 1780                             		.section	.text.wc_InitSha256,"ax",@progbits
 1781                             		.global	_wc_InitSha256
 1783                             	_wc_InitSha256:
 1784                             	.LFB52:
1360:../src/wolfcrypt/src/sha256.c **** 
1361:../src/wolfcrypt/src/sha256.c **** #endif /* !WOLFSSL_KCAPI_HASH */
1362:../src/wolfcrypt/src/sha256.c **** 
1363:../src/wolfcrypt/src/sha256.c ****     #if defined(OPENSSL_EXTRA)
1364:../src/wolfcrypt/src/sha256.c **** /* Apply SHA256 transformation to the data                */
1365:../src/wolfcrypt/src/sha256.c **** /* @param sha  a pointer to wc_Sha256 structure           */
1366:../src/wolfcrypt/src/sha256.c **** /* @param data data to be applied SHA256 transformation   */
1367:../src/wolfcrypt/src/sha256.c **** /* @return 0 on successful, otherwise non-zero on failure */
1368:../src/wolfcrypt/src/sha256.c ****     int wc_Sha256Transform(wc_Sha256* sha, const unsigned char* data)
1369:../src/wolfcrypt/src/sha256.c ****     {
1370:../src/wolfcrypt/src/sha256.c ****         if (sha == NULL || data == NULL) {
1371:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1372:../src/wolfcrypt/src/sha256.c ****         }
1373:../src/wolfcrypt/src/sha256.c ****         return (Transform_Sha256(sha, data));
1374:../src/wolfcrypt/src/sha256.c ****     }
1375:../src/wolfcrypt/src/sha256.c ****     #endif
1376:../src/wolfcrypt/src/sha256.c **** #endif /* XTRANSFORM */
1377:../src/wolfcrypt/src/sha256.c **** 
1378:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_SHA224
1379:../src/wolfcrypt/src/sha256.c **** 
1380:../src/wolfcrypt/src/sha256.c **** #ifdef STM32_HASH_SHA2
1381:../src/wolfcrypt/src/sha256.c **** 
1382:../src/wolfcrypt/src/sha256.c ****     /* Supports CubeMX HAL or Standard Peripheral Library */
1383:../src/wolfcrypt/src/sha256.c **** 
1384:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha224_ex(wc_Sha224* sha224, void* heap, int devId)
1385:../src/wolfcrypt/src/sha256.c ****     {
1386:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL)
1387:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1388:../src/wolfcrypt/src/sha256.c **** 
1389:../src/wolfcrypt/src/sha256.c ****         (void)devId;
1390:../src/wolfcrypt/src/sha256.c ****         (void)heap;
1391:../src/wolfcrypt/src/sha256.c **** 
1392:../src/wolfcrypt/src/sha256.c ****         XMEMSET(sha224, 0, sizeof(wc_Sha224));
1393:../src/wolfcrypt/src/sha256.c ****         wc_Stm32_Hash_Init(&sha224->stmCtx);
1394:../src/wolfcrypt/src/sha256.c ****         return 0;
1395:../src/wolfcrypt/src/sha256.c ****     }
1396:../src/wolfcrypt/src/sha256.c **** 
1397:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224Update(wc_Sha224* sha224, const byte* data, word32 len)
1398:../src/wolfcrypt/src/sha256.c ****     {
1399:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
1400:../src/wolfcrypt/src/sha256.c **** 
1401:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL || (data == NULL && len > 0)) {
1402:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1403:../src/wolfcrypt/src/sha256.c ****         }
1404:../src/wolfcrypt/src/sha256.c **** 
1405:../src/wolfcrypt/src/sha256.c ****         ret = wolfSSL_CryptHwMutexLock();
1406:../src/wolfcrypt/src/sha256.c ****         if (ret == 0) {
1407:../src/wolfcrypt/src/sha256.c ****             ret = wc_Stm32_Hash_Update(&sha224->stmCtx,
1408:../src/wolfcrypt/src/sha256.c ****                 HASH_AlgoSelection_SHA224, data, len, WC_SHA224_BLOCK_SIZE);
1409:../src/wolfcrypt/src/sha256.c ****             wolfSSL_CryptHwMutexUnLock();
1410:../src/wolfcrypt/src/sha256.c ****         }
1411:../src/wolfcrypt/src/sha256.c ****         return ret;
1412:../src/wolfcrypt/src/sha256.c ****     }
1413:../src/wolfcrypt/src/sha256.c **** 
1414:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224Final(wc_Sha224* sha224, byte* hash)
1415:../src/wolfcrypt/src/sha256.c ****     {
1416:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
1417:../src/wolfcrypt/src/sha256.c **** 
1418:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL || hash == NULL) {
1419:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1420:../src/wolfcrypt/src/sha256.c ****         }
1421:../src/wolfcrypt/src/sha256.c **** 
1422:../src/wolfcrypt/src/sha256.c ****         ret = wolfSSL_CryptHwMutexLock();
1423:../src/wolfcrypt/src/sha256.c ****         if (ret == 0) {
1424:../src/wolfcrypt/src/sha256.c ****             ret = wc_Stm32_Hash_Final(&sha224->stmCtx,
1425:../src/wolfcrypt/src/sha256.c ****                 HASH_AlgoSelection_SHA224, hash, WC_SHA224_DIGEST_SIZE);
1426:../src/wolfcrypt/src/sha256.c ****             wolfSSL_CryptHwMutexUnLock();
1427:../src/wolfcrypt/src/sha256.c ****         }
1428:../src/wolfcrypt/src/sha256.c **** 
1429:../src/wolfcrypt/src/sha256.c ****         (void)wc_InitSha224(sha224); /* reset state */
1430:../src/wolfcrypt/src/sha256.c **** 
1431:../src/wolfcrypt/src/sha256.c ****         return ret;
1432:../src/wolfcrypt/src/sha256.c ****     }
1433:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_SE050) && defined(WOLFSSL_SE050_HASH)
1434:../src/wolfcrypt/src/sha256.c **** 
1435:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha224_ex(wc_Sha224* sha224, void* heap, int devId)
1436:../src/wolfcrypt/src/sha256.c ****     {
1437:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL) {
1438:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1439:../src/wolfcrypt/src/sha256.c ****         }
1440:../src/wolfcrypt/src/sha256.c ****         (void)devId;
1441:../src/wolfcrypt/src/sha256.c **** 
1442:../src/wolfcrypt/src/sha256.c ****         return se050_hash_init(&sha224->se050Ctx, heap);
1443:../src/wolfcrypt/src/sha256.c ****     }
1444:../src/wolfcrypt/src/sha256.c **** 
1445:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224Update(wc_Sha224* sha224, const byte* data, word32 len)
1446:../src/wolfcrypt/src/sha256.c ****     {
1447:../src/wolfcrypt/src/sha256.c ****         return se050_hash_update(&sha224->se050Ctx, data, len);
1448:../src/wolfcrypt/src/sha256.c ****     }
1449:../src/wolfcrypt/src/sha256.c **** 
1450:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224Final(wc_Sha224* sha224, byte* hash)
1451:../src/wolfcrypt/src/sha256.c ****     {
1452:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
1453:../src/wolfcrypt/src/sha256.c ****         ret = se050_hash_final(&sha224->se050Ctx, hash, WC_SHA224_DIGEST_SIZE,
1454:../src/wolfcrypt/src/sha256.c ****                                kAlgorithm_SSS_SHA224);
1455:../src/wolfcrypt/src/sha256.c ****         (void)wc_InitSha224(sha224);
1456:../src/wolfcrypt/src/sha256.c ****         return ret;
1457:../src/wolfcrypt/src/sha256.c ****     }
1458:../src/wolfcrypt/src/sha256.c **** 
1459:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_IMX6_CAAM) && !defined(NO_IMX6_CAAM_HASH) && \
1460:../src/wolfcrypt/src/sha256.c ****     !defined(WOLFSSL_QNX_CAAM)
1461:../src/wolfcrypt/src/sha256.c ****     /* functions defined in wolfcrypt/src/port/caam/caam_sha256.c */
1462:../src/wolfcrypt/src/sha256.c **** 
1463:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_AFALG_HASH)
1464:../src/wolfcrypt/src/sha256.c ****     #error SHA224 currently not supported with AF_ALG enabled
1465:../src/wolfcrypt/src/sha256.c **** 
1466:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_DEVCRYPTO_HASH)
1467:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/devcrypto/devcrypt_hash.c */
1468:../src/wolfcrypt/src/sha256.c **** 
1469:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
1470:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/silabs/silabs_hash.c */
1471:../src/wolfcrypt/src/sha256.c **** 
1472:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_KCAPI_HASH) && !defined(WOLFSSL_NO_KCAPI_SHA224)
1473:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */
1474:../src/wolfcrypt/src/sha256.c **** 
1475:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_HAVE_PSA) && !defined(WOLFSSL_PSA_NO_HASH)
1476:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/psa/psa_hash.c */
1477:../src/wolfcrypt/src/sha256.c **** 
1478:../src/wolfcrypt/src/sha256.c **** #else
1479:../src/wolfcrypt/src/sha256.c **** 
1480:../src/wolfcrypt/src/sha256.c ****     #define NEED_SOFT_SHA224
1481:../src/wolfcrypt/src/sha256.c **** 
1482:../src/wolfcrypt/src/sha256.c **** 
1483:../src/wolfcrypt/src/sha256.c ****     static int InitSha224(wc_Sha224* sha224)
1484:../src/wolfcrypt/src/sha256.c ****     {
1485:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
1486:../src/wolfcrypt/src/sha256.c **** 
1487:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL) {
1488:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1489:../src/wolfcrypt/src/sha256.c ****         }
1490:../src/wolfcrypt/src/sha256.c **** 
1491:../src/wolfcrypt/src/sha256.c ****         sha224->digest[0] = 0xc1059ed8;
1492:../src/wolfcrypt/src/sha256.c ****         sha224->digest[1] = 0x367cd507;
1493:../src/wolfcrypt/src/sha256.c ****         sha224->digest[2] = 0x3070dd17;
1494:../src/wolfcrypt/src/sha256.c ****         sha224->digest[3] = 0xf70e5939;
1495:../src/wolfcrypt/src/sha256.c ****         sha224->digest[4] = 0xffc00b31;
1496:../src/wolfcrypt/src/sha256.c ****         sha224->digest[5] = 0x68581511;
1497:../src/wolfcrypt/src/sha256.c ****         sha224->digest[6] = 0x64f98fa7;
1498:../src/wolfcrypt/src/sha256.c ****         sha224->digest[7] = 0xbefa4fa4;
1499:../src/wolfcrypt/src/sha256.c **** 
1500:../src/wolfcrypt/src/sha256.c ****         sha224->buffLen = 0;
1501:../src/wolfcrypt/src/sha256.c ****         sha224->loLen   = 0;
1502:../src/wolfcrypt/src/sha256.c ****         sha224->hiLen   = 0;
1503:../src/wolfcrypt/src/sha256.c **** 
1504:../src/wolfcrypt/src/sha256.c ****     #if defined(USE_INTEL_SPEEDUP) && \
1505:../src/wolfcrypt/src/sha256.c ****                           (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
1506:../src/wolfcrypt/src/sha256.c ****         /* choose best Transform function under this runtime environment */
1507:../src/wolfcrypt/src/sha256.c ****         Sha256_SetTransform();
1508:../src/wolfcrypt/src/sha256.c ****     #endif
1509:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_HASH_FLAGS
1510:../src/wolfcrypt/src/sha256.c ****         sha224->flags = 0;
1511:../src/wolfcrypt/src/sha256.c ****     #endif
1512:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_HASH_KEEP
1513:../src/wolfcrypt/src/sha256.c ****         sha224->msg  = NULL;
1514:../src/wolfcrypt/src/sha256.c ****         sha224->len  = 0;
1515:../src/wolfcrypt/src/sha256.c ****         sha224->used = 0;
1516:../src/wolfcrypt/src/sha256.c ****     #endif
1517:../src/wolfcrypt/src/sha256.c **** 
1518:../src/wolfcrypt/src/sha256.c **** 
1519:../src/wolfcrypt/src/sha256.c ****         return ret;
1520:../src/wolfcrypt/src/sha256.c ****     }
1521:../src/wolfcrypt/src/sha256.c **** 
1522:../src/wolfcrypt/src/sha256.c **** #endif
1523:../src/wolfcrypt/src/sha256.c **** 
1524:../src/wolfcrypt/src/sha256.c **** #ifdef NEED_SOFT_SHA224
1525:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha224_ex(wc_Sha224* sha224, void* heap, int devId)
1526:../src/wolfcrypt/src/sha256.c ****     {
1527:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
1528:../src/wolfcrypt/src/sha256.c **** 
1529:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL)
1530:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1531:../src/wolfcrypt/src/sha256.c **** 
1532:../src/wolfcrypt/src/sha256.c ****         sha224->heap = heap;
1533:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_SMALL_STACK_CACHE
1534:../src/wolfcrypt/src/sha256.c ****         sha224->W = NULL;
1535:../src/wolfcrypt/src/sha256.c ****     #endif
1536:../src/wolfcrypt/src/sha256.c **** 
1537:../src/wolfcrypt/src/sha256.c ****         ret = InitSha224(sha224);
1538:../src/wolfcrypt/src/sha256.c ****         if (ret != 0)
1539:../src/wolfcrypt/src/sha256.c ****             return ret;
1540:../src/wolfcrypt/src/sha256.c **** 
1541:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA224)
1542:../src/wolfcrypt/src/sha256.c ****         ret = wolfAsync_DevCtxInit(&sha224->asyncDev,
1543:../src/wolfcrypt/src/sha256.c ****                             WOLFSSL_ASYNC_MARKER_SHA224, sha224->heap, devId);
1544:../src/wolfcrypt/src/sha256.c ****     #else
1545:../src/wolfcrypt/src/sha256.c ****         (void)devId;
1546:../src/wolfcrypt/src/sha256.c ****     #endif /* WOLFSSL_ASYNC_CRYPT */
1547:../src/wolfcrypt/src/sha256.c **** 
1548:../src/wolfcrypt/src/sha256.c ****         return ret;
1549:../src/wolfcrypt/src/sha256.c ****     }
1550:../src/wolfcrypt/src/sha256.c **** 
1551:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224Update(wc_Sha224* sha224, const byte* data, word32 len)
1552:../src/wolfcrypt/src/sha256.c ****     {
1553:../src/wolfcrypt/src/sha256.c ****         int ret;
1554:../src/wolfcrypt/src/sha256.c **** 
1555:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL || (data == NULL && len > 0)) {
1556:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1557:../src/wolfcrypt/src/sha256.c ****         }
1558:../src/wolfcrypt/src/sha256.c **** 
1559:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA224)
1560:../src/wolfcrypt/src/sha256.c ****         if (sha224->asyncDev.marker == WOLFSSL_ASYNC_MARKER_SHA224) {
1561:../src/wolfcrypt/src/sha256.c ****         #if defined(HAVE_INTEL_QA)
1562:../src/wolfcrypt/src/sha256.c ****             return IntelQaSymSha224(&sha224->asyncDev, NULL, data, len);
1563:../src/wolfcrypt/src/sha256.c ****         #endif
1564:../src/wolfcrypt/src/sha256.c ****         }
1565:../src/wolfcrypt/src/sha256.c ****     #endif /* WOLFSSL_ASYNC_CRYPT */
1566:../src/wolfcrypt/src/sha256.c **** 
1567:../src/wolfcrypt/src/sha256.c ****         ret = Sha256Update((wc_Sha256*)sha224, data, len);
1568:../src/wolfcrypt/src/sha256.c **** 
1569:../src/wolfcrypt/src/sha256.c ****         return ret;
1570:../src/wolfcrypt/src/sha256.c ****     }
1571:../src/wolfcrypt/src/sha256.c **** 
1572:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224Final(wc_Sha224* sha224, byte* hash)
1573:../src/wolfcrypt/src/sha256.c ****     {
1574:../src/wolfcrypt/src/sha256.c ****         int ret;
1575:../src/wolfcrypt/src/sha256.c **** 
1576:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL || hash == NULL) {
1577:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1578:../src/wolfcrypt/src/sha256.c ****         }
1579:../src/wolfcrypt/src/sha256.c **** 
1580:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA224)
1581:../src/wolfcrypt/src/sha256.c ****         if (sha224->asyncDev.marker == WOLFSSL_ASYNC_MARKER_SHA224) {
1582:../src/wolfcrypt/src/sha256.c ****         #if defined(HAVE_INTEL_QA)
1583:../src/wolfcrypt/src/sha256.c ****             return IntelQaSymSha224(&sha224->asyncDev, hash, NULL,
1584:../src/wolfcrypt/src/sha256.c ****                                             WC_SHA224_DIGEST_SIZE);
1585:../src/wolfcrypt/src/sha256.c ****         #endif
1586:../src/wolfcrypt/src/sha256.c ****         }
1587:../src/wolfcrypt/src/sha256.c ****     #endif /* WOLFSSL_ASYNC_CRYPT */
1588:../src/wolfcrypt/src/sha256.c **** 
1589:../src/wolfcrypt/src/sha256.c ****         ret = Sha256Final((wc_Sha256*)sha224);
1590:../src/wolfcrypt/src/sha256.c ****         if (ret != 0)
1591:../src/wolfcrypt/src/sha256.c ****             return ret;
1592:../src/wolfcrypt/src/sha256.c **** 
1593:../src/wolfcrypt/src/sha256.c ****     #if defined(LITTLE_ENDIAN_ORDER)
1594:../src/wolfcrypt/src/sha256.c ****         ByteReverseWords(sha224->digest, sha224->digest, WC_SHA224_DIGEST_SIZE);
1595:../src/wolfcrypt/src/sha256.c ****     #endif
1596:../src/wolfcrypt/src/sha256.c ****         XMEMCPY(hash, sha224->digest, WC_SHA224_DIGEST_SIZE);
1597:../src/wolfcrypt/src/sha256.c **** 
1598:../src/wolfcrypt/src/sha256.c ****         return InitSha224(sha224);  /* reset state */
1599:../src/wolfcrypt/src/sha256.c ****     }
1600:../src/wolfcrypt/src/sha256.c **** #endif /* end of SHA224 software implementation */
1601:../src/wolfcrypt/src/sha256.c **** 
1602:../src/wolfcrypt/src/sha256.c ****     int wc_InitSha224(wc_Sha224* sha224)
1603:../src/wolfcrypt/src/sha256.c ****     {
1604:../src/wolfcrypt/src/sha256.c ****         int devId = INVALID_DEVID;
1605:../src/wolfcrypt/src/sha256.c **** 
1606:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLF_CRYPTO_CB
1607:../src/wolfcrypt/src/sha256.c ****         devId = wc_CryptoCb_DefaultDevID();
1608:../src/wolfcrypt/src/sha256.c ****     #endif
1609:../src/wolfcrypt/src/sha256.c ****         return wc_InitSha224_ex(sha224, NULL, devId);
1610:../src/wolfcrypt/src/sha256.c ****     }
1611:../src/wolfcrypt/src/sha256.c **** 
1612:../src/wolfcrypt/src/sha256.c **** #if !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)
1613:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/psa/psa_hash.c */
1614:../src/wolfcrypt/src/sha256.c **** 
1615:../src/wolfcrypt/src/sha256.c ****     void wc_Sha224Free(wc_Sha224* sha224)
1616:../src/wolfcrypt/src/sha256.c ****     {
1617:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL)
1618:../src/wolfcrypt/src/sha256.c ****             return;
1619:../src/wolfcrypt/src/sha256.c **** 
1620:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
1621:../src/wolfcrypt/src/sha256.c ****     if (sha224->W != NULL) {
1622:../src/wolfcrypt/src/sha256.c ****         XFREE(sha224->W, NULL, DYNAMIC_TYPE_DIGEST);
1623:../src/wolfcrypt/src/sha256.c ****         sha224->W = NULL;
1624:../src/wolfcrypt/src/sha256.c ****     }
1625:../src/wolfcrypt/src/sha256.c **** #endif
1626:../src/wolfcrypt/src/sha256.c **** 
1627:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA224)
1628:../src/wolfcrypt/src/sha256.c ****         wolfAsync_DevCtxFree(&sha224->asyncDev, WOLFSSL_ASYNC_MARKER_SHA224);
1629:../src/wolfcrypt/src/sha256.c ****     #endif /* WOLFSSL_ASYNC_CRYPT */
1630:../src/wolfcrypt/src/sha256.c **** 
1631:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_PIC32MZ_HASH
1632:../src/wolfcrypt/src/sha256.c ****         wc_Sha256Pic32Free(sha224);
1633:../src/wolfcrypt/src/sha256.c ****     #endif
1634:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_KCAPI_HASH)
1635:../src/wolfcrypt/src/sha256.c ****         KcapiHashFree(&sha224->kcapi);
1636:../src/wolfcrypt/src/sha256.c ****     #endif
1637:../src/wolfcrypt/src/sha256.c ****     }
1638:../src/wolfcrypt/src/sha256.c **** #endif /* WOLFSSL_SHA224 */
1639:../src/wolfcrypt/src/sha256.c **** #endif /* !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH) */
1640:../src/wolfcrypt/src/sha256.c **** 
1641:../src/wolfcrypt/src/sha256.c **** 
1642:../src/wolfcrypt/src/sha256.c **** int wc_InitSha256(wc_Sha256* sha256)
1643:../src/wolfcrypt/src/sha256.c **** {
 1785                             		.loc 2 1643 1
 1786 0000 7E AA                   		push.l	r10
 1787                             	.LCFI29:
 1788 0002 71 0A F8                		add	#-8, r0, r10
 1789                             	.LCFI30:
 1790 0005 EF A0                   		mov.L	r10, r0
 1791 0007 E7 A1 01                		mov.L	r1, 4[r10]
1644:../src/wolfcrypt/src/sha256.c ****     int devId = INVALID_DEVID;
 1792                             		.loc 2 1644 9
 1793 000a F8 A6 FE                		mov.L	#-2, [r10]
1645:../src/wolfcrypt/src/sha256.c **** 
1646:../src/wolfcrypt/src/sha256.c **** #ifdef WOLF_CRYPTO_CB
1647:../src/wolfcrypt/src/sha256.c ****     devId = wc_CryptoCb_DefaultDevID();
1648:../src/wolfcrypt/src/sha256.c **** #endif
1649:../src/wolfcrypt/src/sha256.c ****     return wc_InitSha256_ex(sha256, NULL, devId);
 1794                             		.loc 2 1649 12
 1795 000d EC A3                   		mov.L	[r10], r3
 1796 000f 66 02                   		mov.L	#0, r2
 1797 0011 ED A1 01                		mov.L	4[r10], r1
 1798 0014 05 00 00 00             		bsr	_wc_InitSha256_ex
 1799 0018 EF 15                   		mov.L	r1, r5
1650:../src/wolfcrypt/src/sha256.c **** }
 1800                             		.loc 2 1650 1
 1801 001a EF 51                   		mov.L	r5, r1
 1802 001c 3F AA 03                		rtsd	#12, r10-r10
 1803                             	.LFE52:
 1805                             		.section	.text.wc_Sha256Free,"ax",@progbits
 1806                             		.global	_wc_Sha256Free
 1808                             	_wc_Sha256Free:
 1809                             	.LFB53:
1651:../src/wolfcrypt/src/sha256.c **** 
1652:../src/wolfcrypt/src/sha256.c **** #if !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)
1653:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/psa/psa_hash.c */
1654:../src/wolfcrypt/src/sha256.c **** 
1655:../src/wolfcrypt/src/sha256.c **** void wc_Sha256Free(wc_Sha256* sha256)
1656:../src/wolfcrypt/src/sha256.c **** {
 1810                             		.loc 2 1656 1
 1811 0000 7E AA                   		push.l	r10
 1812                             	.LCFI31:
 1813 0002 71 0A FC                		add	#-4, r0, r10
 1814                             	.LCFI32:
 1815 0005 EF A0                   		mov.L	r10, r0
 1816 0007 E3 A1                   		mov.L	r1, [r10]
1657:../src/wolfcrypt/src/sha256.c ****     if (sha256 == NULL)
1658:../src/wolfcrypt/src/sha256.c ****         return;
1659:../src/wolfcrypt/src/sha256.c **** 
1660:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
1661:../src/wolfcrypt/src/sha256.c ****     if (sha256->W != NULL) {
1662:../src/wolfcrypt/src/sha256.c ****         XFREE(sha256->W, NULL, DYNAMIC_TYPE_DIGEST);
1663:../src/wolfcrypt/src/sha256.c ****         sha256->W = NULL;
1664:../src/wolfcrypt/src/sha256.c ****     }
1665:../src/wolfcrypt/src/sha256.c **** #endif
1666:../src/wolfcrypt/src/sha256.c **** 
1667:../src/wolfcrypt/src/sha256.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
1668:../src/wolfcrypt/src/sha256.c ****     wolfAsync_DevCtxFree(&sha256->asyncDev, WOLFSSL_ASYNC_MARKER_SHA256);
1669:../src/wolfcrypt/src/sha256.c **** #endif /* WOLFSSL_ASYNC_CRYPT */
1670:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_PIC32MZ_HASH
1671:../src/wolfcrypt/src/sha256.c ****     wc_Sha256Pic32Free(sha256);
1672:../src/wolfcrypt/src/sha256.c **** #endif
1673:../src/wolfcrypt/src/sha256.c **** #if defined(WOLFSSL_AFALG_HASH)
1674:../src/wolfcrypt/src/sha256.c ****     if (sha256->alFd > 0) {
1675:../src/wolfcrypt/src/sha256.c ****         close(sha256->alFd);
1676:../src/wolfcrypt/src/sha256.c ****         sha256->alFd = -1; /* avoid possible double close on socket */
1677:../src/wolfcrypt/src/sha256.c ****     }
1678:../src/wolfcrypt/src/sha256.c ****     if (sha256->rdFd > 0) {
1679:../src/wolfcrypt/src/sha256.c ****         close(sha256->rdFd);
1680:../src/wolfcrypt/src/sha256.c ****         sha256->rdFd = -1; /* avoid possible double close on socket */
1681:../src/wolfcrypt/src/sha256.c ****     }
1682:../src/wolfcrypt/src/sha256.c **** #endif /* WOLFSSL_AFALG_HASH */
1683:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_DEVCRYPTO_HASH
1684:../src/wolfcrypt/src/sha256.c ****     wc_DevCryptoFree(&sha256->ctx);
1685:../src/wolfcrypt/src/sha256.c **** #endif /* WOLFSSL_DEVCRYPTO */
1686:../src/wolfcrypt/src/sha256.c **** #if (defined(WOLFSSL_AFALG_HASH) && defined(WOLFSSL_AFALG_HASH_KEEP)) || \
1687:../src/wolfcrypt/src/sha256.c ****     (defined(WOLFSSL_DEVCRYPTO_HASH) && defined(WOLFSSL_DEVCRYPTO_HASH_KEEP)) || \
1688:../src/wolfcrypt/src/sha256.c ****     (defined(WOLFSSL_RENESAS_TSIP_CRYPT) && \
1689:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_RENESAS_TSIP_CRYPT_HASH)) || \
1690:../src/wolfcrypt/src/sha256.c ****     (defined(WOLFSSL_RENESAS_SCEPROTECT) && \
1691:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_RENESAS_SCEPROTECT_HASH)) || \
1692:../src/wolfcrypt/src/sha256.c ****     defined(WOLFSSL_HASH_KEEP)
1693:../src/wolfcrypt/src/sha256.c **** 
1694:../src/wolfcrypt/src/sha256.c ****     if (sha256->msg != NULL) {
1695:../src/wolfcrypt/src/sha256.c ****         XFREE(sha256->msg, sha256->heap, DYNAMIC_TYPE_TMP_BUFFER);
1696:../src/wolfcrypt/src/sha256.c ****         sha256->msg = NULL;
1697:../src/wolfcrypt/src/sha256.c ****     }
1698:../src/wolfcrypt/src/sha256.c **** #endif
1699:../src/wolfcrypt/src/sha256.c **** #if defined(WOLFSSL_KCAPI_HASH)
1700:../src/wolfcrypt/src/sha256.c ****     KcapiHashFree(&sha256->kcapi);
1701:../src/wolfcrypt/src/sha256.c **** #endif
1702:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_IMXRT_DCP
1703:../src/wolfcrypt/src/sha256.c ****     DCPSha256Free(sha256);
1704:../src/wolfcrypt/src/sha256.c **** #endif
1705:../src/wolfcrypt/src/sha256.c **** }
 1817                             		.loc 2 1705 1
 1818 0009 3F AA 02                		rtsd	#8, r10-r10
 1819                             	.LFE53:
 1821                             		.section	.text.wc_Sha256GetHash,"ax",@progbits
 1822                             		.global	_wc_Sha256GetHash
 1824                             	_wc_Sha256GetHash:
 1825                             	.LFB54:
1706:../src/wolfcrypt/src/sha256.c **** 
1707:../src/wolfcrypt/src/sha256.c **** #endif /* !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH) */
1708:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_HASH_KEEP
1709:../src/wolfcrypt/src/sha256.c **** /* Some hardware have issues with update, this function stores the data to be
1710:../src/wolfcrypt/src/sha256.c ****  * hashed into an array. Once ready, the Final operation is called on all of the
1711:../src/wolfcrypt/src/sha256.c ****  * data to be hashed at once.
1712:../src/wolfcrypt/src/sha256.c ****  * returns 0 on success
1713:../src/wolfcrypt/src/sha256.c ****  */
1714:../src/wolfcrypt/src/sha256.c **** int wc_Sha256_Grow(wc_Sha256* sha256, const byte* in, int inSz)
1715:../src/wolfcrypt/src/sha256.c **** {
1716:../src/wolfcrypt/src/sha256.c ****     return _wc_Hash_Grow(&(sha256->msg), &(sha256->used), &(sha256->len), in,
1717:../src/wolfcrypt/src/sha256.c ****                         inSz, sha256->heap);
1718:../src/wolfcrypt/src/sha256.c **** }
1719:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_SHA224
1720:../src/wolfcrypt/src/sha256.c **** int wc_Sha224_Grow(wc_Sha224* sha224, const byte* in, int inSz)
1721:../src/wolfcrypt/src/sha256.c **** {
1722:../src/wolfcrypt/src/sha256.c ****     return _wc_Hash_Grow(&(sha224->msg), &(sha224->used), &(sha224->len), in,
1723:../src/wolfcrypt/src/sha256.c ****                         inSz, sha224->heap);
1724:../src/wolfcrypt/src/sha256.c **** }
1725:../src/wolfcrypt/src/sha256.c **** #endif /* WOLFSSL_SHA224 */
1726:../src/wolfcrypt/src/sha256.c **** #endif /* WOLFSSL_HASH_KEEP */
1727:../src/wolfcrypt/src/sha256.c **** 
1728:../src/wolfcrypt/src/sha256.c **** #endif /* !WOLFSSL_TI_HASH */
1729:../src/wolfcrypt/src/sha256.c **** #endif /* HAVE_FIPS */
1730:../src/wolfcrypt/src/sha256.c **** 
1731:../src/wolfcrypt/src/sha256.c **** 
1732:../src/wolfcrypt/src/sha256.c **** #ifndef WOLFSSL_TI_HASH
1733:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_SHA224
1734:../src/wolfcrypt/src/sha256.c **** 
1735:../src/wolfcrypt/src/sha256.c **** #if defined(WOLFSSL_KCAPI_HASH) && !defined(WOLFSSL_NO_KCAPI_SHA224)
1736:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */
1737:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_HAVE_PSA) && !defined(WOLFSSL_PSA_NO_HASH)
1738:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/psa/psa_hash.c */
1739:../src/wolfcrypt/src/sha256.c **** 
1740:../src/wolfcrypt/src/sha256.c **** #else
1741:../src/wolfcrypt/src/sha256.c **** 
1742:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224GetHash(wc_Sha224* sha224, byte* hash)
1743:../src/wolfcrypt/src/sha256.c ****     {
1744:../src/wolfcrypt/src/sha256.c ****         int ret;
1745:../src/wolfcrypt/src/sha256.c ****         wc_Sha224 tmpSha224;
1746:../src/wolfcrypt/src/sha256.c **** 
1747:../src/wolfcrypt/src/sha256.c ****         wc_InitSha224(&tmpSha224);
1748:../src/wolfcrypt/src/sha256.c ****         if (sha224 == NULL || hash == NULL)
1749:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1750:../src/wolfcrypt/src/sha256.c **** 
1751:../src/wolfcrypt/src/sha256.c ****         ret = wc_Sha224Copy(sha224, &tmpSha224);
1752:../src/wolfcrypt/src/sha256.c ****         if (ret == 0) {
1753:../src/wolfcrypt/src/sha256.c ****             ret = wc_Sha224Final(&tmpSha224, hash);
1754:../src/wolfcrypt/src/sha256.c ****             wc_Sha224Free(&tmpSha224);
1755:../src/wolfcrypt/src/sha256.c ****         }
1756:../src/wolfcrypt/src/sha256.c ****         return ret;
1757:../src/wolfcrypt/src/sha256.c ****     }
1758:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224Copy(wc_Sha224* src, wc_Sha224* dst)
1759:../src/wolfcrypt/src/sha256.c ****     {
1760:../src/wolfcrypt/src/sha256.c ****         int ret = 0;
1761:../src/wolfcrypt/src/sha256.c **** 
1762:../src/wolfcrypt/src/sha256.c ****         if (src == NULL || dst == NULL)
1763:../src/wolfcrypt/src/sha256.c ****             return BAD_FUNC_ARG;
1764:../src/wolfcrypt/src/sha256.c **** 
1765:../src/wolfcrypt/src/sha256.c ****         XMEMCPY(dst, src, sizeof(wc_Sha224));
1766:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_SMALL_STACK_CACHE
1767:../src/wolfcrypt/src/sha256.c ****         dst->W = NULL;
1768:../src/wolfcrypt/src/sha256.c ****     #endif
1769:../src/wolfcrypt/src/sha256.c **** 
1770:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_SILABS_SE_ACCEL
1771:../src/wolfcrypt/src/sha256.c ****         dst->silabsCtx.hash_ctx.cmd_ctx = &(dst->silabsCtx.cmd_ctx);
1772:../src/wolfcrypt/src/sha256.c ****         dst->silabsCtx.hash_ctx.hash_type_ctx = &(dst->silabsCtx.hash_type_ctx);
1773:../src/wolfcrypt/src/sha256.c ****     #endif
1774:../src/wolfcrypt/src/sha256.c **** 
1775:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA224)
1776:../src/wolfcrypt/src/sha256.c ****         ret = wolfAsync_DevCopy(&src->asyncDev, &dst->asyncDev);
1777:../src/wolfcrypt/src/sha256.c ****     #endif
1778:../src/wolfcrypt/src/sha256.c ****     #ifdef WOLFSSL_HASH_FLAGS
1779:../src/wolfcrypt/src/sha256.c ****         dst->flags |= WC_HASH_FLAG_ISCOPY;
1780:../src/wolfcrypt/src/sha256.c ****     #endif
1781:../src/wolfcrypt/src/sha256.c ****     #if defined(WOLFSSL_HASH_KEEP)
1782:../src/wolfcrypt/src/sha256.c ****         if (src->msg != NULL) {
1783:../src/wolfcrypt/src/sha256.c ****             dst->msg = (byte*)XMALLOC(src->len, dst->heap,
1784:../src/wolfcrypt/src/sha256.c ****                                       DYNAMIC_TYPE_TMP_BUFFER);
1785:../src/wolfcrypt/src/sha256.c ****             if (dst->msg == NULL)
1786:../src/wolfcrypt/src/sha256.c ****                 return MEMORY_E;
1787:../src/wolfcrypt/src/sha256.c ****             XMEMCPY(dst->msg, src->msg, src->len);
1788:../src/wolfcrypt/src/sha256.c ****         }
1789:../src/wolfcrypt/src/sha256.c ****     #endif
1790:../src/wolfcrypt/src/sha256.c **** 
1791:../src/wolfcrypt/src/sha256.c ****         return ret;
1792:../src/wolfcrypt/src/sha256.c ****     }
1793:../src/wolfcrypt/src/sha256.c **** 
1794:../src/wolfcrypt/src/sha256.c **** #endif /* WOLFSSL_KCAPI_HASH && !WOLFSSL_NO_KCAPI_SHA224 */
1795:../src/wolfcrypt/src/sha256.c **** 
1796:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_HASH_FLAGS
1797:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224SetFlags(wc_Sha224* sha224, word32 flags)
1798:../src/wolfcrypt/src/sha256.c ****     {
1799:../src/wolfcrypt/src/sha256.c ****         if (sha224) {
1800:../src/wolfcrypt/src/sha256.c ****             sha224->flags = flags;
1801:../src/wolfcrypt/src/sha256.c ****         }
1802:../src/wolfcrypt/src/sha256.c ****         return 0;
1803:../src/wolfcrypt/src/sha256.c ****     }
1804:../src/wolfcrypt/src/sha256.c ****     int wc_Sha224GetFlags(wc_Sha224* sha224, word32* flags)
1805:../src/wolfcrypt/src/sha256.c ****     {
1806:../src/wolfcrypt/src/sha256.c ****         if (sha224 && flags) {
1807:../src/wolfcrypt/src/sha256.c ****             *flags = sha224->flags;
1808:../src/wolfcrypt/src/sha256.c ****         }
1809:../src/wolfcrypt/src/sha256.c ****         return 0;
1810:../src/wolfcrypt/src/sha256.c ****     }
1811:../src/wolfcrypt/src/sha256.c **** #endif
1812:../src/wolfcrypt/src/sha256.c **** 
1813:../src/wolfcrypt/src/sha256.c **** #endif /* WOLFSSL_SHA224 */
1814:../src/wolfcrypt/src/sha256.c **** 
1815:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_AFALG_HASH
1816:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/af_alg/afalg_hash.c */
1817:../src/wolfcrypt/src/sha256.c **** 
1818:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_DEVCRYPTO_HASH)
1819:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/devcrypto/devcrypt_hash.c */
1820:../src/wolfcrypt/src/sha256.c **** 
1821:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_RENESAS_TSIP_CRYPT) && \
1822:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_RENESAS_TSIP_CRYPT_HASH)
1823:../src/wolfcrypt/src/sha256.c **** 
1824:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/Renesas/renesas_tsip_sha.c */
1825:../src/wolfcrypt/src/sha256.c **** 
1826:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_RENESAS_SCEPROTECT) && \
1827:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_RENESAS_SCEPROTECT_HASH)
1828:../src/wolfcrypt/src/sha256.c **** 
1829:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/Renesas/renesas_sce_sha.c */
1830:../src/wolfcrypt/src/sha256.c **** 
1831:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_PSOC6_CRYPTO)
1832:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/cypress/psoc6_crypto.c */
1833:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_IMXRT_DCP)
1834:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/nxp/dcp_port.c */
1835:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_KCAPI_HASH)
1836:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */
1837:../src/wolfcrypt/src/sha256.c **** 
1838:../src/wolfcrypt/src/sha256.c **** #elif defined(WOLFSSL_HAVE_PSA) && !defined(WOLFSSL_PSA_NO_HASH)
1839:../src/wolfcrypt/src/sha256.c ****     /* implemented in wolfcrypt/src/port/psa/psa_hash.c */
1840:../src/wolfcrypt/src/sha256.c **** 
1841:../src/wolfcrypt/src/sha256.c **** #else
1842:../src/wolfcrypt/src/sha256.c **** 
1843:../src/wolfcrypt/src/sha256.c **** int wc_Sha256GetHash(wc_Sha256* sha256, byte* hash)
1844:../src/wolfcrypt/src/sha256.c **** {
 1826                             		.loc 2 1844 1
 1827 0000 7E AA                   		push.l	r10
 1828                             	.LCFI33:
 1829 0002 71 0A 84                		add	#-124, r0, r10
 1830                             	.LCFI34:
 1831 0005 EF A0                   		mov.L	r10, r0
 1832 0007 E7 A1 1D                		mov.L	r1, 116[r10]
 1833 000a E7 A2 1E                		mov.L	r2, 120[r10]
1845:../src/wolfcrypt/src/sha256.c ****     int ret;
1846:../src/wolfcrypt/src/sha256.c ****     wc_Sha256 tmpSha256;
1847:../src/wolfcrypt/src/sha256.c **** 
1848:../src/wolfcrypt/src/sha256.c ****     if (sha256 == NULL || hash == NULL)
 1834                             		.loc 2 1848 8
 1835 000d ED A5 1D                		mov.L	116[r10], r5
 1836 0010 61 05                   		cmp	#0, r5
 1837 0012 17                      		beq	.L75
 1838                             		.loc 2 1848 24 discriminator 1
 1839 0013 ED A5 1E                		mov.L	120[r10], r5
 1840 0016 61 05                   		cmp	#0, r5
 1841 0018 1F                      		bne	.L76
 1842                             	.L75:
1849:../src/wolfcrypt/src/sha256.c ****         return BAD_FUNC_ARG;
 1843                             		.loc 2 1849 16
 1844 0019 FB 5A 53 FF             		mov.L	#-173, r5
 1845 001d 2E 2F                   		bra	.L79
 1846                             	.L76:
1850:../src/wolfcrypt/src/sha256.c **** 
1851:../src/wolfcrypt/src/sha256.c **** #if  defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
1852:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
1853:../src/wolfcrypt/src/sha256.c ****     if(sha256->ctx.mode == ESP32_SHA_INIT){
1854:../src/wolfcrypt/src/sha256.c ****         esp_sha_try_hw_lock(&sha256->ctx);
1855:../src/wolfcrypt/src/sha256.c ****     }
1856:../src/wolfcrypt/src/sha256.c ****     if(sha256->ctx.mode == ESP32_SHA_HW)
1857:../src/wolfcrypt/src/sha256.c ****     {
1858:../src/wolfcrypt/src/sha256.c ****         esp_sha256_digest_process(sha256, 0);
1859:../src/wolfcrypt/src/sha256.c ****     }
1860:../src/wolfcrypt/src/sha256.c **** #endif
1861:../src/wolfcrypt/src/sha256.c ****     ret = wc_Sha256Copy(sha256, &tmpSha256);
 1847                             		.loc 2 1861 11
 1848 001f 71 A5 04                		add	#4, r10, r5
 1849 0022 EF 52                   		mov.L	r5, r2
 1850 0024 ED A1 1D                		mov.L	116[r10], r1
 1851 0027 05 00 00 00             		bsr	_wc_Sha256Copy
 1852 002b E3 A1                   		mov.L	r1, [r10]
1862:../src/wolfcrypt/src/sha256.c ****     if (ret == 0) {
 1853                             		.loc 2 1862 8
 1854 002d EC A5                   		mov.L	[r10], r5
 1855 002f 61 05                   		cmp	#0, r5
 1856 0031 21 19                   		bne	.L78
1863:../src/wolfcrypt/src/sha256.c ****         ret = wc_Sha256Final(&tmpSha256, hash);
 1857                             		.loc 2 1863 15
 1858 0033 71 A5 04                		add	#4, r10, r5
 1859 0036 ED A2 1E                		mov.L	120[r10], r2
 1860 0039 EF 51                   		mov.L	r5, r1
 1861 003b 05 00 00 00             		bsr	_wc_Sha256Final
 1862 003f E3 A1                   		mov.L	r1, [r10]
1864:../src/wolfcrypt/src/sha256.c **** #if  defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
1865:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
1866:../src/wolfcrypt/src/sha256.c ****         sha256->ctx.mode = ESP32_SHA_SW;
1867:../src/wolfcrypt/src/sha256.c **** #endif
1868:../src/wolfcrypt/src/sha256.c **** 
1869:../src/wolfcrypt/src/sha256.c ****         wc_Sha256Free(&tmpSha256);
 1863                             		.loc 2 1869 9
 1864 0041 71 A5 04                		add	#4, r10, r5
 1865 0044 EF 51                   		mov.L	r5, r1
 1866 0046 05 00 00 00             		bsr	_wc_Sha256Free
 1867                             	.L78:
1870:../src/wolfcrypt/src/sha256.c ****     }
1871:../src/wolfcrypt/src/sha256.c ****     return ret;
 1868                             		.loc 2 1871 12
 1869 004a EC A5                   		mov.L	[r10], r5
 1870                             	.L79:
1872:../src/wolfcrypt/src/sha256.c **** }
 1871                             		.loc 2 1872 1 discriminator 1
 1872 004c EF 51                   		mov.L	r5, r1
 1873 004e 3F AA 20                		rtsd	#128, r10-r10
 1874                             	.LFE54:
 1876                             		.section	.text.wc_Sha256Copy,"ax",@progbits
 1877                             		.global	_wc_Sha256Copy
 1879                             	_wc_Sha256Copy:
 1880                             	.LFB55:
1873:../src/wolfcrypt/src/sha256.c **** int wc_Sha256Copy(wc_Sha256* src, wc_Sha256* dst)
1874:../src/wolfcrypt/src/sha256.c **** {
 1881                             		.loc 2 1874 1
 1882 0000 7E AA                   		push.l	r10
 1883                             	.LCFI35:
 1884 0002 71 0A F4                		add	#-12, r0, r10
 1885                             	.LCFI36:
 1886 0005 EF A0                   		mov.L	r10, r0
 1887 0007 E7 A1 01                		mov.L	r1, 4[r10]
 1888 000a E7 A2 02                		mov.L	r2, 8[r10]
1875:../src/wolfcrypt/src/sha256.c ****     int ret = 0;
 1889                             		.loc 2 1875 9
 1890 000d F8 A6 00                		mov.L	#0, [r10]
1876:../src/wolfcrypt/src/sha256.c **** 
1877:../src/wolfcrypt/src/sha256.c ****     if (src == NULL || dst == NULL)
 1891                             		.loc 2 1877 8
 1892 0010 ED A5 01                		mov.L	4[r10], r5
 1893 0013 61 05                   		cmp	#0, r5
 1894 0015 17                      		beq	.L81
 1895                             		.loc 2 1877 21 discriminator 1
 1896 0016 ED A5 02                		mov.L	8[r10], r5
 1897 0019 61 05                   		cmp	#0, r5
 1898 001b 1F                      		bne	.L82
 1899                             	.L81:
1878:../src/wolfcrypt/src/sha256.c ****         return BAD_FUNC_ARG;
 1900                             		.loc 2 1878 16
 1901 001c FB 5A 53 FF             		mov.L	#-173, r5
 1902 0020 2E 11                   		bra	.L83
 1903                             	.L82:
1879:../src/wolfcrypt/src/sha256.c **** 
1880:../src/wolfcrypt/src/sha256.c ****     XMEMCPY(dst, src, sizeof(wc_Sha256));
 1904                             		.loc 2 1880 5
 1905 0022 75 43 70                		mov.L	#0x70, r3
 1906 0025 ED A2 01                		mov.L	4[r10], r2
 1907 0028 ED A1 02                		mov.L	8[r10], r1
 1908 002b 05 00 00 00             		bsr	_memcpy
1881:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
1882:../src/wolfcrypt/src/sha256.c ****     dst->W = NULL;
1883:../src/wolfcrypt/src/sha256.c **** #endif
1884:../src/wolfcrypt/src/sha256.c **** 
1885:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_SILABS_SE_ACCEL
1886:../src/wolfcrypt/src/sha256.c ****     dst->silabsCtx.hash_ctx.cmd_ctx = &(dst->silabsCtx.cmd_ctx);
1887:../src/wolfcrypt/src/sha256.c ****     dst->silabsCtx.hash_ctx.hash_type_ctx = &(dst->silabsCtx.hash_type_ctx);
1888:../src/wolfcrypt/src/sha256.c **** #endif
1889:../src/wolfcrypt/src/sha256.c **** 
1890:../src/wolfcrypt/src/sha256.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
1891:../src/wolfcrypt/src/sha256.c ****     ret = wolfAsync_DevCopy(&src->asyncDev, &dst->asyncDev);
1892:../src/wolfcrypt/src/sha256.c **** #endif
1893:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_PIC32MZ_HASH
1894:../src/wolfcrypt/src/sha256.c ****     ret = wc_Pic32HashCopy(&src->cache, &dst->cache);
1895:../src/wolfcrypt/src/sha256.c **** #endif
1896:../src/wolfcrypt/src/sha256.c **** #if  defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
1897:../src/wolfcrypt/src/sha256.c ****     !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
1898:../src/wolfcrypt/src/sha256.c ****      dst->ctx.mode = src->ctx.mode;
1899:../src/wolfcrypt/src/sha256.c ****      dst->ctx.isfirstblock = src->ctx.isfirstblock;
1900:../src/wolfcrypt/src/sha256.c ****      dst->ctx.sha_type = src->ctx.sha_type;
1901:../src/wolfcrypt/src/sha256.c **** #endif
1902:../src/wolfcrypt/src/sha256.c **** #ifdef WOLFSSL_HASH_FLAGS
1903:../src/wolfcrypt/src/sha256.c ****      dst->flags |= WC_HASH_FLAG_ISCOPY;
1904:../src/wolfcrypt/src/sha256.c **** #endif
1905:../src/wolfcrypt/src/sha256.c **** #if defined(WOLFSSL_HASH_KEEP)
1906:../src/wolfcrypt/src/sha256.c ****     if (src->msg != NULL) {
1907:../src/wolfcrypt/src/sha256.c ****         dst->msg = (byte*)XMALLOC(src->len, dst->heap, DYNAMIC_TYPE_TMP_BUFFER);
1908:../src/wolfcrypt/src/sha256.c ****         if (dst->msg == NULL)
1909:../src/wolfcrypt/src/sha256.c ****             return MEMORY_E;
1910:../src/wolfcrypt/src/sha256.c ****         XMEMCPY(dst->msg, src->msg, src->len);
1911:../src/wolfcrypt/src/sha256.c ****     }
1912:../src/wolfcrypt/src/sha256.c **** #endif
1913:../src/wolfcrypt/src/sha256.c **** 
1914:../src/wolfcrypt/src/sha256.c ****     return ret;
 1909                             		.loc 2 1914 12
 1910 002f EC A5                   		mov.L	[r10], r5
 1911                             	.L83:
1915:../src/wolfcrypt/src/sha256.c **** }
 1912                             		.loc 2 1915 1
 1913 0031 EF 51                   		mov.L	r5, r1
 1914 0033 3F AA 04                		rtsd	#16, r10-r10
 1915                             	.LFE55:
 2305                             	.Letext0:
 2306                             		.file 3 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\lib\\gcc\\rx-
 2307                             		.file 4 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2308                             		.file 5 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2309                             		.file 6 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2310                             		.file 7 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2311                             		.file 8 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/types.h"
 2312                             		.file 9 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 2313                             		.file 10 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\incl
 2314                             		.file 11 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha256.h"
 2315                             		.file 12 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/error-crypt.h"
 2316                             		.file 13 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/md5.h"
 2317                             		.file 14 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha.h"
 2318                             		.file 15 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha512.h"
 2319                             		.file 16 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/md4.h"
