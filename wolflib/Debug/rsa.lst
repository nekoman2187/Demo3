   1                             		.file	"rsa.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.section	.text.ForceZero,"ax",@progbits
   6                             	_ForceZero:
   7                             	.LFB13:
   8                             		.file 1 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfcrypt/src/misc.c"
   1:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* misc.c
   2:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   3:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   5:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * This file is part of wolfSSL.
   6:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   7:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * it under the terms of the GNU General Public License as published by
   9:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * (at your option) any later version.
  11:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  12:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * GNU General Public License for more details.
  16:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  17:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * You should have received a copy of the GNU General Public License
  18:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * along with this program; if not, write to the Free Software
  19:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  21:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /*
  22:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  23:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** DESCRIPTION
  24:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** This module implements the arithmetic-shift right, left, byte swapping, XOR,
  25:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** masking and clearing memory logic.
  26:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  27:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** */
  28:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef HAVE_CONFIG_H
  29:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <config.h>
  30:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  31:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  32:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/settings.h>
  33:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  34:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLF_CRYPT_MISC_C
  35:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #define WOLF_CRYPT_MISC_C
  36:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  37:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/misc.h>
  38:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  39:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* inlining these functions is a huge speed increase and a small size decrease,
  40:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    because the functions are smaller than function call setup/cleanup, e.g.,
  41:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    md5 benchmark is twice as fast with inline.  If you don't want it, then
  42:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    define NO_INLINE and compile this file into wolfssl, otherwise it's used as
  43:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    a source header
  44:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  45:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  46:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef NO_INLINE
  47:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC
  48:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  49:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC static
  50:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  51:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  52:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Check for if compiling misc.c when not needed. */
  53:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if !defined(WOLFSSL_MISC_INCLUDED) && !defined(NO_INLINE)
  54:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_IGNORE_FILE_WARN
  55:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #warning misc.c does not need to be compiled when using inline (NO_INLINE not defined)
  56:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
  57:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  58:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  59:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  60:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  61:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__ICCARM__)
  62:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <intrinsics.h>
  63:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  64:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  65:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  66:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef INTEL_INTRINSICS
  67:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  68:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <stdlib.h>      /* get intrinsic definitions */
  69:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  70:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* for non visual studio probably need no long version, 32 bit only
  71:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****      * i.e., _rotl and _rotr */
  72:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #pragma intrinsic(_lrotl, _lrotr)
  73:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  74:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  75:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  76:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotl(x, y) : x;
  77:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  78:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  79:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
  80:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  81:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotr(x, y) : x;
  82:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  83:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  84:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
  85:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  86:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <builtin.h>      /* get intrinsic definitions */
  87:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  88:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if !defined(NO_INLINE)
  89:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  90:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotlFixed(x, y) _builtin_rotl(x, y)
  91:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  92:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotrFixed(x, y) _builtin_rotr(x, y)
  93:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  94:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #else /* create real function */
  95:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  96:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  97:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  98:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotl(x, y);
  99:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 100:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 101:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 102:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 103:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotr(x, y);
 104:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 105:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 106:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 107:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 108:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else /* generic */
 109:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value. */
 110:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 111:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
 112:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 113:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x << y) | (x >> (sizeof(y) * 8 - y));
 114:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 115:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 116:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value. */
 117:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 118:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 119:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x >> y) | (x << (sizeof(y) * 8 - y));
 120:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 121:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 122:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 123:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 124:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef WC_RC2
 125:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 126:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value */
 127:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotlFixed16(word16 x, word16 y)
 128:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 129:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 130:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 131:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 132:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 133:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value */
 134:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotrFixed16(word16 x, word16 y)
 135:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 136:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 137:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 138:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 139:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WC_RC2 */
 140:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 141:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of 32-bit word value. */
 142:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__CCRX__) && !defined(NO_INLINE) /* shortest version for CC-RX */
 143:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define ByteReverseWord32(value) _builtin_revl(value)
 144:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 145:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word32 ByteReverseWord32(word32 value)
 146:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 147:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef PPC_INTRINSICS
 148:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* PPC: load reverse indexed instruction */
 149:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__lwbrx(&value,0);
 150:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__ICCARM__)
 151:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__REV(value);
 152:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(KEIL_INTRINSICS)
 153:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__rev(value);
 154:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
 155:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)_builtin_revl(value);
 156:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLF_ALLOW_BUILTIN) && \
 157:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 158:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__builtin_bswap32(value);
 159:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 160:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       defined(__aarch64__)
 161:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 162:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV32 %0, %0  \n"
 163:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 164:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 165:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 166:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 167:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 168:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       (defined(__thumb__) || defined(__arm__))
 169:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 170:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV %0, %0  \n"
 171:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 172:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 173:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 174:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 175:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(FAST_ROTATE)
 176:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 5 instructions with rotate instruction, 9 without */
 177:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (rotrFixed(value, 8U) & 0xff00ff00) |
 178:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****            (rotlFixed(value, 8U) & 0x00ff00ff);
 179:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 180:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 6 instructions with rotate instruction, 8 without */
 181:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 182:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed(value, 16U);
 183:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 184:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 185:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* __CCRX__ */
 186:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of words array of a given count. */
 187:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords(word32* out, const word32* in,
 188:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                     word32 byteCount)
 189:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 190:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word32), i;
 191:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 192:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 193:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord32(in[i]);
 194:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 195:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 196:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 197:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WORD64_AVAILABLE) && !defined(WOLFSSL_NO_WORD64_OPS)
 198:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 199:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 200:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotlFixed64(word64 x, word64 y)
 201:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 202:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 203:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 204:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 205:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 206:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotrFixed64(word64 x, word64 y)
 207:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 208:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 209:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 210:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 211:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 212:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 ByteReverseWord64(word64 value)
 213:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 214:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WOLF_ALLOW_BUILTIN) && defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 215:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)__builtin_bswap64(value);
 216:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFCRYPT_SLOW_WORD64)
 217:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)((word64)ByteReverseWord32((word32) value)) << 32 |
 218:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         (word64)ByteReverseWord32((word32)(value   >> 32));
 219:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 220:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) |
 221:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
 222:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) |
 223:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
 224:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed64(value, 32U);
 225:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 226:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 227:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 228:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 229:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords64(word64* out, const word64* in,
 230:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                       word32 byteCount)
 231:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 232:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word64), i;
 233:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 234:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 235:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord64(in[i]);
 236:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 237:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 238:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 239:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WORD64_AVAILABLE && !WOLFSSL_NO_WORD64_OPS */
 240:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 241:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_XOR_OPS
 242:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 243:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 244:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWordsOut(wolfssl_word* r, const wolfssl_word* a,
 245:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                      const wolfssl_word* b, word32 n)
 246:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 247:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 248:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 249:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] = a[i] ^ b[i];
 250:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 251:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 252:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 253:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 254:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 255:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbufout(void*out, const void* buf, const void* mask,
 256:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                    word32 count)
 257:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 258:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)out | (wc_ptr_t)buf | (wc_ptr_t)mask | count) %
 259:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                          WOLFSSL_WORD_SIZE == 0)
 260:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWordsOut( (wolfssl_word*)out, (wolfssl_word*)buf,
 261:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                      (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 262:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 263:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 264:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       o = (byte*)out;
 265:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 266:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 267:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 268:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) o[i] = b[i] ^ m[i];
 269:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 270:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 271:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 272:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 273:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 274:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWords(wolfssl_word* r, const wolfssl_word* a, word32 n)
 275:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 276:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 277:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 278:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] ^= a[i];
 279:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 280:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 281:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 282:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 283:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 284:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbuf(void* buf, const void* mask, word32 count)
 285:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 286:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)buf | (wc_ptr_t)mask | count) % WOLFSSL_WORD_SIZE == 0)
 287:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWords( (wolfssl_word*)buf,
 288:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                   (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 289:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 290:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 291:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 292:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 293:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 294:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) b[i] ^= m[i];
 295:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 296:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 297:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 298:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 299:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_FORCE_ZERO
 300:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine fills the first len bytes of the memory area pointed by mem
 301:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    with zeros. It ensures compiler optimizations doesn't skip it  */
 302:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
 303:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
   9                             		.loc 1 303 1
  10 0000 7E AA                   		push.l	r10
  11                             	.LCFI0:
  12 0002 71 0A F4                		add	#-12, r0, r10
  13                             	.LCFI1:
  14 0005 EF A0                   		mov.L	r10, r0
  15 0007 E7 A1 01                		mov.L	r1, 4[r10]
  16 000a E7 A2 02                		mov.L	r2, 8[r10]
 304:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile byte* z = (volatile byte*)mem;
  17                             		.loc 1 304 20
  18 000d ED A5 01                		mov.L	4[r10], r5
  19 0010 E3 A5                   		mov.L	r5, [r10]
 305:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 306:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if (defined(WOLFSSL_X86_64_BUILD) || defined(WOLFSSL_AARCH64_BUILD)) \
 307:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****             && defined(WORD64_AVAILABLE)
 308:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile word64* w;
 309:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_UNALIGNED_64BIT_ACCESS
 310:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 l = (sizeof(word64) - ((size_t)z & (sizeof(word64)-1))) &
 311:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                              (sizeof(word64)-1);
 312:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 313:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         if (len < l) l = len;
 314:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         len -= l;
 315:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         while (l--) *z++ = 0;
 316:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 317:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
 318:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         *w++ = 0;
 319:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     z = (volatile byte*)w;
 320:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 321:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 322:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     while (len--) *z++ = 0;
  20                             		.loc 1 322 11
  21 0012 2E 0C                   		bra	.L2
  22                             	.L3:
  23                             		.loc 1 322 21 discriminator 2
  24 0014 EC A5                   		mov.L	[r10], r5
  25 0016 71 54 01                		add	#1, r5, r4
  26 0019 E3 A4                   		mov.L	r4, [r10]
  27                             		.loc 1 322 24 discriminator 2
  28 001b F8 54 00                		mov.B	#0, [r5]
  29                             	.L2:
  30                             		.loc 1 322 15 discriminator 1
  31 001e ED A5 02                		mov.L	8[r10], r5
  32 0021 71 54 FF                		add	#-1, r5, r4
  33 0024 E7 A4 02                		mov.L	r4, 8[r10]
  34                             		.loc 1 322 11 discriminator 1
  35 0027 61 05                   		cmp	#0, r5
  36 0029 21 EB                   		bne	.L3
 323:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
  37                             		.loc 1 323 1
  38 002b 03                      		nop
  39 002c 3F AA 04                		rtsd	#16, r10-r10
  40                             	.LFE13:
  42                             		.section	.text.ConstantCompare,"ax",@progbits
  44                             	_ConstantCompare:
  45                             	.LFB14:
 324:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 325:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 326:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 327:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_CONST_CMP
 328:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* check all length bytes for equality, return 0 on success */
 329:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ConstantCompare(const byte* a, const byte* b, int length)
 330:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
  46                             		.loc 1 330 1
  47 0000 7E AA                   		push.l	r10
  48                             	.LCFI2:
  49 0002 71 0A EC                		add	#-20, r0, r10
  50                             	.LCFI3:
  51 0005 EF A0                   		mov.L	r10, r0
  52 0007 E7 A1 02                		mov.L	r1, 8[r10]
  53 000a E7 A2 03                		mov.L	r2, 12[r10]
  54 000d E7 A3 04                		mov.L	r3, 16[r10]
 331:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int i;
 332:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int compareSum = 0;
  55                             		.loc 1 332 9
  56 0010 F9 A6 01 00             		mov.L	#0, 4[r10]
 333:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 334:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < length; i++) {
  57                             		.loc 1 334 12
  58 0014 F8 A6 00                		mov.L	#0, [r10]
  59                             		.loc 1 334 5
  60 0017 2E 27                   		bra	.L5
  61                             	.L6:
 335:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         compareSum |= a[i] ^ b[i];
  62                             		.loc 1 335 24 discriminator 3
  63 0019 EC A5                   		mov.L	[r10], r5
  64 001b ED A4 02                		mov.L	8[r10], r4
  65 001e 4B 45                   		add	r4, r5
  66 0020 CC 53                   		mov.B	[r5], r3
  67                             		.loc 1 335 31 discriminator 3
  68 0022 EC A5                   		mov.L	[r10], r5
  69 0024 ED A4 03                		mov.L	12[r10], r4
  70 0027 4B 45                   		add	r4, r5
  71 0029 CC 55                   		mov.B	[r5], r5
  72                             		.loc 1 335 28 discriminator 3
  73 002b FC 37 35                		xor	r3, r5
  74 002e 5B 55                   		movu.B	r5, r5
  75                             		.loc 1 335 20 discriminator 3
  76 0030 ED A4 01                		mov.L	4[r10], r4
  77 0033 57 45                   		or	r4, r5
  78 0035 E7 A5 01                		mov.L	r5, 4[r10]
 334:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         compareSum |= a[i] ^ b[i];
  79                             		.loc 1 334 30 discriminator 3
  80 0038 EC A5                   		mov.L	[r10], r5
  81 003a 62 15                   		add	#1, r5
  82 003c E3 A5                   		mov.L	r5, [r10]
  83                             	.L5:
 334:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         compareSum |= a[i] ^ b[i];
  84                             		.loc 1 334 5 discriminator 1
  85 003e EC A4                   		mov.L	[r10], r4
  86 0040 ED A5 04                		mov.L	16[r10], r5
  87 0043 47 54                   		cmp	r5, r4
  88 0045 29 D4                   		blt	.L6
 336:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 337:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 338:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return compareSum;
  89                             		.loc 1 338 12
  90 0047 ED A5 01                		mov.L	4[r10], r5
 339:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
  91                             		.loc 1 339 1
  92 004a EF 51                   		mov.L	r5, r1
  93 004c 3F AA 06                		rtsd	#24, r10-r10
  94                             	.LFE14:
  96                             		.section	.text.ctMaskGT,"ax",@progbits
  98                             	_ctMaskGT:
  99                             	.LFB28:
 340:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 341:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 342:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 343:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_HAVE_MIN
 344:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WOLFSSL_HAVE_MIN
 345:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
 346:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #define min min
 347:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 348:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* returns the smaller of a and b */
 349:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 min(word32 a, word32 b)
 350:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 351:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return a > b ? b : a;
 352:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 353:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* !WOLFSSL_HAVE_MIN */
 354:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 355:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_HAVE_MAX
 356:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WOLFSSL_HAVE_MAX
 357:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if defined(HAVE_FIPS) && !defined(max) /* so ifdef check passes */
 358:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #define max max
 359:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 360:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 max(word32 a, word32 b)
 361:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 362:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return a > b ? a : b;
 363:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 364:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* !WOLFSSL_HAVE_MAX */
 365:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 366:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_INT_ENCODE
 367:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* converts a 32 bit integer to 24 bit */
 368:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void c32to24(word32 in, word24 out)
 369:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 370:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[0] = (in >> 16) & 0xff;
 371:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[1] = (in >>  8) & 0xff;
 372:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[2] =  in & 0xff;
 373:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 374:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 375:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert 16 bit integer to opaque */
 376:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void c16toa(word16 wc_u16, byte* c)
 377:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 378:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[0] = (wc_u16 >> 8) & 0xff;
 379:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[1] =  wc_u16 & 0xff;
 380:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 381:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 382:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert 32 bit integer to opaque */
 383:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void c32toa(word32 wc_u32, byte* c)
 384:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 385:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[0] = (wc_u32 >> 24) & 0xff;
 386:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[1] = (wc_u32 >> 16) & 0xff;
 387:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[2] = (wc_u32 >>  8) & 0xff;
 388:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[3] =  wc_u32 & 0xff;
 389:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 390:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 391:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 392:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_INT_DECODE
 393:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert a 24 bit integer into a 32 bit one */
 394:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void c24to32(const word24 wc_u24, word32* wc_u32)
 395:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 396:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     *wc_u32 = ((word32)wc_u24[0] << 16) | (wc_u24[1] << 8) | wc_u24[2];
 397:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 398:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 399:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 400:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert opaque to 24 bit integer */
 401:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ato24(const byte* c, word32* wc_u24)
 402:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 403:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     *wc_u24 = ((word32)c[0] << 16) | (c[1] << 8) | c[2];
 404:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 405:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 406:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert opaque to 16 bit integer */
 407:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ato16(const byte* c, word16* wc_u16)
 408:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 409:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     *wc_u16 = (word16) ((c[0] << 8) | (c[1]));
 410:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 411:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 412:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert opaque to 32 bit integer */
 413:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ato32(const byte* c, word32* wc_u32)
 414:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 415:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     *wc_u32 = ((word32)c[0] << 24) | ((word32)c[1] << 16) | (c[2] << 8) | c[3];
 416:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 417:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 418:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 419:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word32 btoi(byte b)
 420:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 421:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)(b - 0x30);
 422:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 423:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 424:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 425:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE signed char HexCharToByte(char ch)
 426:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 427:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     signed char ret = (signed char)ch;
 428:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (ret >= '0' && ret <= '9')
 429:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ret -= '0';
 430:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else if (ret >= 'A' && ret <= 'F')
 431:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ret -= 'A' - 10;
 432:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else if (ret >= 'a' && ret <= 'f')
 433:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ret -= 'a' - 10;
 434:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else
 435:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ret = -1; /* error case - return code must be signed */
 436:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return ret;
 437:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 438:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 439:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE char ByteToHex(byte in)
 440:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 441:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     static const char kHexChar[] = { '0', '1', '2', '3', '4', '5', '6', '7',
 442:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                      '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
 443:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (char)(kHexChar[in & 0xF]);
 444:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 445:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 446:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ByteToHexStr(byte in, char* out)
 447:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 448:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (out == NULL)
 449:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return -1;
 450:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 451:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[0] = ByteToHex(in >> 4);
 452:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[1] = ByteToHex(in & 0xf);
 453:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return 0;
 454:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 455:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 456:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_CT_OPS
 457:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a > b. */
 458:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskGT(int a, int b)
 459:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 100                             		.loc 1 459 1
 101 0000 7E AA                   		push.l	r10
 102                             	.LCFI4:
 103 0002 71 0A F8                		add	#-8, r0, r10
 104                             	.LCFI5:
 105 0005 EF A0                   		mov.L	r10, r0
 106 0007 E3 A1                   		mov.L	r1, [r10]
 107 0009 E7 A2 01                		mov.L	r2, 4[r10]
 460:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((((word32)a - b - 1) >> 31) - 1);
 108                             		.loc 1 460 21
 109 000c EC A4                   		mov.L	[r10], r4
 110                             		.loc 1 460 31
 111 000e ED A5 01                		mov.L	4[r10], r5
 112 0011 FF 05 54                		sub	r5, r4, r5
 113                             		.loc 1 460 35
 114 0014 60 15                   		sub	#1, r5
 115                             		.loc 1 460 40
 116 0016 69 F5                   		shlr	#31, r5
 117                             		.loc 1 460 12
 118 0018 60 15                   		sub	#1, r5
 119 001a 5B 55                   		movu.B	r5, r5
 461:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 120                             		.loc 1 461 1
 121 001c EF 51                   		mov.L	r5, r1
 122 001e 3F AA 03                		rtsd	#12, r10-r10
 123                             	.LFE28:
 125                             		.section	.text.ctMaskGTE,"ax",@progbits
 127                             	_ctMaskGTE:
 128                             	.LFB29:
 462:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 463:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a >= b. */
 464:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskGTE(int a, int b)
 465:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 129                             		.loc 1 465 1
 130 0000 7E AA                   		push.l	r10
 131                             	.LCFI6:
 132 0002 71 0A F8                		add	#-8, r0, r10
 133                             	.LCFI7:
 134 0005 EF A0                   		mov.L	r10, r0
 135 0007 E3 A1                   		mov.L	r1, [r10]
 136 0009 E7 A2 01                		mov.L	r2, 4[r10]
 466:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((((word32)a - b    ) >> 31) - 1);
 137                             		.loc 1 466 21
 138 000c EC A4                   		mov.L	[r10], r4
 139                             		.loc 1 466 31
 140 000e ED A5 01                		mov.L	4[r10], r5
 141 0011 FF 05 54                		sub	r5, r4, r5
 142                             		.loc 1 466 40
 143 0014 69 F5                   		shlr	#31, r5
 144                             		.loc 1 466 12
 145 0016 60 15                   		sub	#1, r5
 146 0018 5B 55                   		movu.B	r5, r5
 467:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 147                             		.loc 1 467 1
 148 001a EF 51                   		mov.L	r5, r1
 149 001c 3F AA 03                		rtsd	#12, r10-r10
 150                             	.LFE29:
 152                             		.section	.text.ctMaskLT,"ax",@progbits
 154                             	_ctMaskLT:
 155                             	.LFB31:
 468:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 469:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a >= b. */
 470:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ctMaskIntGTE(int a, int b)
 471:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 472:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (int)((((word32)a - b    ) >> 31) - 1);
 473:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 474:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 475:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a < b. */
 476:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskLT(int a, int b)
 477:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 156                             		.loc 1 477 1
 157 0000 7E AA                   		push.l	r10
 158                             	.LCFI8:
 159 0002 71 0A F8                		add	#-8, r0, r10
 160                             	.LCFI9:
 161 0005 EF A0                   		mov.L	r10, r0
 162 0007 E3 A1                   		mov.L	r1, [r10]
 163 0009 E7 A2 01                		mov.L	r2, 4[r10]
 478:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((((word32)b - a - 1) >> 31) - 1);
 164                             		.loc 1 478 21
 165 000c ED A4 01                		mov.L	4[r10], r4
 166                             		.loc 1 478 31
 167 000f EC A5                   		mov.L	[r10], r5
 168 0011 FF 05 54                		sub	r5, r4, r5
 169                             		.loc 1 478 35
 170 0014 60 15                   		sub	#1, r5
 171                             		.loc 1 478 40
 172 0016 69 F5                   		shlr	#31, r5
 173                             		.loc 1 478 12
 174 0018 60 15                   		sub	#1, r5
 175 001a 5B 55                   		movu.B	r5, r5
 479:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 176                             		.loc 1 479 1
 177 001c EF 51                   		mov.L	r5, r1
 178 001e 3F AA 03                		rtsd	#12, r10-r10
 179                             	.LFE31:
 181                             		.section	.text.ctMaskLTE,"ax",@progbits
 183                             	_ctMaskLTE:
 184                             	.LFB32:
 480:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 481:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a <= b. */
 482:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskLTE(int a, int b)
 483:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 185                             		.loc 1 483 1
 186 0000 7E AA                   		push.l	r10
 187                             	.LCFI10:
 188 0002 71 0A F8                		add	#-8, r0, r10
 189                             	.LCFI11:
 190 0005 EF A0                   		mov.L	r10, r0
 191 0007 E3 A1                   		mov.L	r1, [r10]
 192 0009 E7 A2 01                		mov.L	r2, 4[r10]
 484:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((((word32)b - a    ) >> 31) - 1);
 193                             		.loc 1 484 21
 194 000c ED A4 01                		mov.L	4[r10], r4
 195                             		.loc 1 484 31
 196 000f EC A5                   		mov.L	[r10], r5
 197 0011 FF 05 54                		sub	r5, r4, r5
 198                             		.loc 1 484 40
 199 0014 69 F5                   		shlr	#31, r5
 200                             		.loc 1 484 12
 201 0016 60 15                   		sub	#1, r5
 202 0018 5B 55                   		movu.B	r5, r5
 485:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 203                             		.loc 1 485 1
 204 001a EF 51                   		mov.L	r5, r1
 205 001c 3F AA 03                		rtsd	#12, r10-r10
 206                             	.LFE32:
 208                             		.section	.text.ctMaskEq,"ax",@progbits
 210                             	_ctMaskEq:
 211                             	.LFB33:
 486:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 487:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a == b. */
 488:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskEq(int a, int b)
 489:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 212                             		.loc 1 489 1
 213 0000 7E AA                   		push.l	r10
 214                             	.LCFI12:
 215 0002 7E A6                   		push.l	r6
 216                             	.LCFI13:
 217 0004 71 0A F8                		add	#-8, r0, r10
 218                             	.LCFI14:
 219 0007 EF A0                   		mov.L	r10, r0
 220 0009 E3 A1                   		mov.L	r1, [r10]
 221 000b E7 A2 01                		mov.L	r2, 4[r10]
 490:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)(~ctMaskGT(a, b)) & (byte)(~ctMaskLT(a, b));
 222                             		.loc 1 490 20
 223 000e ED A2 01                		mov.L	4[r10], r2
 224 0011 EC A1                   		mov.L	[r10], r1
 225 0013 05 00 00 00             		bsr	_ctMaskGT
 226 0017 EF 15                   		mov.L	r1, r5
 227 0019 CF 56                   		mov.B	r5, r6
 228                             		.loc 1 490 46
 229 001b ED A2 01                		mov.L	4[r10], r2
 230 001e EC A1                   		mov.L	[r10], r1
 231 0020 05 00 00 00             		bsr	_ctMaskLT
 232 0024 EF 15                   		mov.L	r1, r5
 233                             		.loc 1 490 36
 234 0026 57 65                   		or	r6, r5
 235 0028 7E 05                   		not	r5
 236 002a 5B 55                   		movu.B	r5, r5
 491:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 237                             		.loc 1 491 1
 238 002c EF 51                   		mov.L	r5, r1
 239 002e 62 80                   		add	#8, r0
 240 0030 7E B6                   		pop	r6
 241 0032 7E BA                   		pop	r10
 242 0034 02                      		rts
 243                             	.LFE33:
 245                             		.section	.text.ctMask16GT,"ax",@progbits
 247                             	_ctMask16GT:
 248                             	.LFB34:
 492:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 493:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a > b */
 494:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16GT(int a, int b)
 495:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 249                             		.loc 1 495 1
 250 0000 7E AA                   		push.l	r10
 251                             	.LCFI15:
 252 0002 71 0A F8                		add	#-8, r0, r10
 253                             	.LCFI16:
 254 0005 EF A0                   		mov.L	r10, r0
 255 0007 E3 A1                   		mov.L	r1, [r10]
 256 0009 E7 A2 01                		mov.L	r2, 4[r10]
 496:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)((((word32)a - b - 1) >> 31) - 1);
 257                             		.loc 1 496 23
 258 000c EC A4                   		mov.L	[r10], r4
 259                             		.loc 1 496 33
 260 000e ED A5 01                		mov.L	4[r10], r5
 261 0011 FF 05 54                		sub	r5, r4, r5
 262                             		.loc 1 496 37
 263 0014 60 15                   		sub	#1, r5
 264                             		.loc 1 496 42
 265 0016 69 F5                   		shlr	#31, r5
 266                             		.loc 1 496 12
 267 0018 60 15                   		sub	#1, r5
 268 001a 5F 55                   		movu.W	r5, r5
 497:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 269                             		.loc 1 497 1
 270 001c EF 51                   		mov.L	r5, r1
 271 001e 3F AA 03                		rtsd	#12, r10-r10
 272                             	.LFE34:
 274                             		.section	.text.ctMask16LT,"ax",@progbits
 276                             	_ctMask16LT:
 277                             	.LFB36:
 498:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 499:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a >= b */
 500:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16GTE(int a, int b)
 501:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 502:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)((((word32)a - b    ) >> 31) - 1);
 503:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 504:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 505:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a < b. */
 506:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16LT(int a, int b)
 507:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 278                             		.loc 1 507 1
 279 0000 7E AA                   		push.l	r10
 280                             	.LCFI17:
 281 0002 71 0A F8                		add	#-8, r0, r10
 282                             	.LCFI18:
 283 0005 EF A0                   		mov.L	r10, r0
 284 0007 E3 A1                   		mov.L	r1, [r10]
 285 0009 E7 A2 01                		mov.L	r2, 4[r10]
 508:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)((((word32)b - a - 1) >> 31) - 1);
 286                             		.loc 1 508 23
 287 000c ED A4 01                		mov.L	4[r10], r4
 288                             		.loc 1 508 33
 289 000f EC A5                   		mov.L	[r10], r5
 290 0011 FF 05 54                		sub	r5, r4, r5
 291                             		.loc 1 508 37
 292 0014 60 15                   		sub	#1, r5
 293                             		.loc 1 508 42
 294 0016 69 F5                   		shlr	#31, r5
 295                             		.loc 1 508 12
 296 0018 60 15                   		sub	#1, r5
 297 001a 5F 55                   		movu.W	r5, r5
 509:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 298                             		.loc 1 509 1
 299 001c EF 51                   		mov.L	r5, r1
 300 001e 3F AA 03                		rtsd	#12, r10-r10
 301                             	.LFE36:
 303                             		.section	.text.ctMask16Eq,"ax",@progbits
 305                             	_ctMask16Eq:
 306                             	.LFB38:
 510:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 511:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a <= b. */
 512:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16LTE(int a, int b)
 513:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 514:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)((((word32)b - a    ) >> 31) - 1);
 515:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 516:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 517:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a == b. */
 518:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16Eq(int a, int b)
 519:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 307                             		.loc 1 519 1
 308 0000 7E AA                   		push.l	r10
 309                             	.LCFI19:
 310 0002 7E A6                   		push.l	r6
 311                             	.LCFI20:
 312 0004 71 0A F8                		add	#-8, r0, r10
 313                             	.LCFI21:
 314 0007 EF A0                   		mov.L	r10, r0
 315 0009 E3 A1                   		mov.L	r1, [r10]
 316 000b E7 A2 01                		mov.L	r2, 4[r10]
 520:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)(~ctMask16GT(a, b)) & (word16)(~ctMask16LT(a, b));
 317                             		.loc 1 520 22
 318 000e ED A2 01                		mov.L	4[r10], r2
 319 0011 EC A1                   		mov.L	[r10], r1
 320 0013 05 00 00 00             		bsr	_ctMask16GT
 321 0017 EF 15                   		mov.L	r1, r5
 322 0019 DF 56                   		mov.W	r5, r6
 323                             		.loc 1 520 52
 324 001b ED A2 01                		mov.L	4[r10], r2
 325 001e EC A1                   		mov.L	[r10], r1
 326 0020 05 00 00 00             		bsr	_ctMask16LT
 327 0024 EF 15                   		mov.L	r1, r5
 328                             		.loc 1 520 40
 329 0026 57 65                   		or	r6, r5
 330 0028 7E 05                   		not	r5
 331 002a 5F 55                   		movu.W	r5, r5
 521:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 332                             		.loc 1 521 1
 333 002c EF 51                   		mov.L	r5, r1
 334 002e 62 80                   		add	#8, r0
 335 0030 7E B6                   		pop	r6
 336 0032 7E BA                   		pop	r10
 337 0034 02                      		rts
 338                             	.LFE38:
 340                             		.section	.text.ctMaskNotEq,"ax",@progbits
 342                             	_ctMaskNotEq:
 343                             	.LFB39:
 522:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 523:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a != b. */
 524:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskNotEq(int a, int b)
 525:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 344                             		.loc 1 525 1
 345 0000 7E AA                   		push.l	r10
 346                             	.LCFI22:
 347 0002 7E A6                   		push.l	r6
 348                             	.LCFI23:
 349 0004 71 0A F8                		add	#-8, r0, r10
 350                             	.LCFI24:
 351 0007 EF A0                   		mov.L	r10, r0
 352 0009 E3 A1                   		mov.L	r1, [r10]
 353 000b E7 A2 01                		mov.L	r2, 4[r10]
 526:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)ctMaskGT(a, b) | (byte)ctMaskLT(a, b);
 354                             		.loc 1 526 18
 355 000e ED A2 01                		mov.L	4[r10], r2
 356 0011 EC A1                   		mov.L	[r10], r1
 357 0013 05 00 00 00             		bsr	_ctMaskGT
 358 0017 EF 15                   		mov.L	r1, r5
 359 0019 CF 56                   		mov.B	r5, r6
 360                             		.loc 1 526 41
 361 001b ED A2 01                		mov.L	4[r10], r2
 362 001e EC A1                   		mov.L	[r10], r1
 363 0020 05 00 00 00             		bsr	_ctMaskLT
 364 0024 EF 15                   		mov.L	r1, r5
 365                             		.loc 1 526 33
 366 0026 57 65                   		or	r6, r5
 367 0028 5B 55                   		movu.B	r5, r5
 527:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 368                             		.loc 1 527 1
 369 002a EF 51                   		mov.L	r5, r1
 370 002c 62 80                   		add	#8, r0
 371 002e 7E B6                   		pop	r6
 372 0030 7E BA                   		pop	r10
 373 0032 02                      		rts
 374                             	.LFE39:
 376                             		.section	.text.ctMaskSelInt,"ax",@progbits
 378                             	_ctMaskSelInt:
 379                             	.LFB41:
 528:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 529:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - select a when mask is set and b otherwise. */
 530:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskSel(byte m, byte a, byte b)
 531:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 532:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((b & ((byte)~(word32)m)) | (a & m));
 533:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 534:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 535:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - select integer a when mask is set and integer b otherwise. */
 536:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ctMaskSelInt(byte m, int a, int b)
 537:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 380                             		.loc 1 537 1
 381 0000 7E AA                   		push.l	r10
 382                             	.LCFI25:
 383 0002 71 0A F4                		add	#-12, r0, r10
 384                             	.LCFI26:
 385 0005 EF A0                   		mov.L	r10, r0
 386 0007 C3 A1                   		mov.B	r1, [r10]
 387 0009 E7 A2 01                		mov.L	r2, 4[r10]
 388 000c E7 A3 02                		mov.L	r3, 8[r10]
 538:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (b & (~(signed int)(signed char)m)) |
 389                             		.loc 1 538 31
 390 000f CC A5                   		mov.B	[r10], r5
 391                             		.loc 1 538 19
 392 0011 CF 55                   		mov.B	r5, r5
 393                             		.loc 1 538 18
 394 0013 7E 05                   		not	r5
 395                             		.loc 1 538 15
 396 0015 ED A4 02                		mov.L	8[r10], r4
 397 0018 53 54                   		and	r5, r4
 539:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****            (a & ( (signed int)(signed char)m));
 398                             		.loc 1 539 31
 399 001a CC A5                   		mov.B	[r10], r5
 400                             		.loc 1 539 19
 401 001c CF 55                   		mov.B	r5, r5
 402                             		.loc 1 539 15
 403 001e ED A3 01                		mov.L	4[r10], r3
 404 0021 53 35                   		and	r3, r5
 538:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (b & (~(signed int)(signed char)m)) |
 405                             		.loc 1 538 48
 406 0023 57 45                   		or	r4, r5
 540:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 407                             		.loc 1 540 1
 408 0025 EF 51                   		mov.L	r5, r1
 409 0027 3F AA 04                		rtsd	#16, r10-r10
 410                             	.LFE41:
 412                             		.section	.text.wc_RsaCleanup,"ax",@progbits
 414                             	_wc_RsaCleanup:
 415                             	.LFB43:
 416                             		.file 2 "../src/wolfcrypt/src/rsa.c"
   1:../src/wolfcrypt/src/rsa.c **** /* rsa.c
   2:../src/wolfcrypt/src/rsa.c ****  *
   3:../src/wolfcrypt/src/rsa.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:../src/wolfcrypt/src/rsa.c ****  *
   5:../src/wolfcrypt/src/rsa.c ****  * This file is part of wolfSSL.
   6:../src/wolfcrypt/src/rsa.c ****  *
   7:../src/wolfcrypt/src/rsa.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:../src/wolfcrypt/src/rsa.c ****  * it under the terms of the GNU General Public License as published by
   9:../src/wolfcrypt/src/rsa.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:../src/wolfcrypt/src/rsa.c ****  * (at your option) any later version.
  11:../src/wolfcrypt/src/rsa.c ****  *
  12:../src/wolfcrypt/src/rsa.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:../src/wolfcrypt/src/rsa.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../src/wolfcrypt/src/rsa.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../src/wolfcrypt/src/rsa.c ****  * GNU General Public License for more details.
  16:../src/wolfcrypt/src/rsa.c ****  *
  17:../src/wolfcrypt/src/rsa.c ****  * You should have received a copy of the GNU General Public License
  18:../src/wolfcrypt/src/rsa.c ****  * along with this program; if not, write to the Free Software
  19:../src/wolfcrypt/src/rsa.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:../src/wolfcrypt/src/rsa.c ****  */
  21:../src/wolfcrypt/src/rsa.c **** 
  22:../src/wolfcrypt/src/rsa.c **** /*
  23:../src/wolfcrypt/src/rsa.c **** 
  24:../src/wolfcrypt/src/rsa.c **** DESCRIPTION
  25:../src/wolfcrypt/src/rsa.c **** This library provides the interface to the RSA.
  26:../src/wolfcrypt/src/rsa.c **** RSA keys can be used to encrypt, decrypt, sign and verify data.
  27:../src/wolfcrypt/src/rsa.c **** 
  28:../src/wolfcrypt/src/rsa.c **** */
  29:../src/wolfcrypt/src/rsa.c **** #ifdef HAVE_CONFIG_H
  30:../src/wolfcrypt/src/rsa.c ****     #include <config.h>
  31:../src/wolfcrypt/src/rsa.c **** #endif
  32:../src/wolfcrypt/src/rsa.c **** 
  33:../src/wolfcrypt/src/rsa.c **** #include <wolfssl/wolfcrypt/settings.h>
  34:../src/wolfcrypt/src/rsa.c **** #include <wolfssl/wolfcrypt/error-crypt.h>
  35:../src/wolfcrypt/src/rsa.c **** 
  36:../src/wolfcrypt/src/rsa.c **** #ifndef NO_RSA
  37:../src/wolfcrypt/src/rsa.c **** 
  38:../src/wolfcrypt/src/rsa.c **** #if defined(HAVE_FIPS) && \
  39:../src/wolfcrypt/src/rsa.c ****     defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)
  40:../src/wolfcrypt/src/rsa.c **** 
  41:../src/wolfcrypt/src/rsa.c ****     /* set NO_WRAPPERS before headers, use direct internal f()s not wrappers */
  42:../src/wolfcrypt/src/rsa.c ****     #define FIPS_NO_WRAPPERS
  43:../src/wolfcrypt/src/rsa.c **** 
  44:../src/wolfcrypt/src/rsa.c ****        #ifdef USE_WINDOWS_API
  45:../src/wolfcrypt/src/rsa.c ****                #pragma code_seg(".fipsA$e")
  46:../src/wolfcrypt/src/rsa.c ****                #pragma const_seg(".fipsB$e")
  47:../src/wolfcrypt/src/rsa.c ****        #endif
  48:../src/wolfcrypt/src/rsa.c **** #endif
  49:../src/wolfcrypt/src/rsa.c **** 
  50:../src/wolfcrypt/src/rsa.c **** #include <wolfssl/wolfcrypt/rsa.h>
  51:../src/wolfcrypt/src/rsa.c **** 
  52:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_AFALG_XILINX_RSA
  53:../src/wolfcrypt/src/rsa.c **** #include <wolfssl/wolfcrypt/port/af_alg/wc_afalg.h>
  54:../src/wolfcrypt/src/rsa.c **** #endif
  55:../src/wolfcrypt/src/rsa.c **** 
  56:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_HAVE_SP_RSA
  57:../src/wolfcrypt/src/rsa.c **** #include <wolfssl/wolfcrypt/sp.h>
  58:../src/wolfcrypt/src/rsa.c **** #endif
  59:../src/wolfcrypt/src/rsa.c **** 
  60:../src/wolfcrypt/src/rsa.c **** /*
  61:../src/wolfcrypt/src/rsa.c **** Possible RSA enable options:
  62:../src/wolfcrypt/src/rsa.c ****  * NO_RSA:                Overall control of RSA                    default: on
  63:../src/wolfcrypt/src/rsa.c ****  *                                                                 (not defined)
  64:../src/wolfcrypt/src/rsa.c ****  * WC_RSA_BLINDING:       Uses Blinding w/ Private Ops              default: off
  65:../src/wolfcrypt/src/rsa.c ****                           Note: slower by ~20%
  66:../src/wolfcrypt/src/rsa.c ****  * WOLFSSL_KEY_GEN:       Allows Private Key Generation             default: off
  67:../src/wolfcrypt/src/rsa.c ****  * RSA_LOW_MEM:           NON CRT Private Operations, less memory   default: off
  68:../src/wolfcrypt/src/rsa.c ****  * WC_NO_RSA_OAEP:        Disables RSA OAEP padding                 default: on
  69:../src/wolfcrypt/src/rsa.c ****  *                                                                 (not defined)
  70:../src/wolfcrypt/src/rsa.c ****  * WC_RSA_NONBLOCK:       Enables support for RSA non-blocking      default: off
  71:../src/wolfcrypt/src/rsa.c ****  * WC_RSA_NONBLOCK_TIME:  Enables support for time based blocking   default: off
  72:../src/wolfcrypt/src/rsa.c ****  *                        time calculation.
  73:../src/wolfcrypt/src/rsa.c ****  * WC_RSA_NO_FERMAT_CHECK:Don't check for small difference in       default: off
  74:../src/wolfcrypt/src/rsa.c ****  *                        p and q (Fermat's factorization is       (not defined)
  75:../src/wolfcrypt/src/rsa.c ****  *                        possible when small difference).
  76:../src/wolfcrypt/src/rsa.c **** */
  77:../src/wolfcrypt/src/rsa.c **** 
  78:../src/wolfcrypt/src/rsa.c **** /*
  79:../src/wolfcrypt/src/rsa.c **** RSA Key Size Configuration:
  80:../src/wolfcrypt/src/rsa.c ****  * FP_MAX_BITS:         With USE_FAST_MATH only                     default: 4096
  81:../src/wolfcrypt/src/rsa.c ****     If USE_FAST_MATH then use this to override default.
  82:../src/wolfcrypt/src/rsa.c ****     Value is key size * 2. Example: RSA 3072 = 6144
  83:../src/wolfcrypt/src/rsa.c **** */
  84:../src/wolfcrypt/src/rsa.c **** 
  85:../src/wolfcrypt/src/rsa.c **** 
  86:../src/wolfcrypt/src/rsa.c **** /* If building for old FIPS. */
  87:../src/wolfcrypt/src/rsa.c **** #if defined(HAVE_FIPS) && \
  88:../src/wolfcrypt/src/rsa.c ****     (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION < 2))
  89:../src/wolfcrypt/src/rsa.c **** 
  90:../src/wolfcrypt/src/rsa.c **** int  wc_InitRsaKey(RsaKey* key, void* ptr)
  91:../src/wolfcrypt/src/rsa.c **** {
  92:../src/wolfcrypt/src/rsa.c ****     if (key == NULL) {
  93:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
  94:../src/wolfcrypt/src/rsa.c ****     }
  95:../src/wolfcrypt/src/rsa.c **** 
  96:../src/wolfcrypt/src/rsa.c ****     return InitRsaKey_fips(key, ptr);
  97:../src/wolfcrypt/src/rsa.c **** }
  98:../src/wolfcrypt/src/rsa.c **** 
  99:../src/wolfcrypt/src/rsa.c **** 
 100:../src/wolfcrypt/src/rsa.c **** int  wc_InitRsaKey_ex(RsaKey* key, void* ptr, int devId)
 101:../src/wolfcrypt/src/rsa.c **** {
 102:../src/wolfcrypt/src/rsa.c ****     (void)devId;
 103:../src/wolfcrypt/src/rsa.c ****     if (key == NULL) {
 104:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 105:../src/wolfcrypt/src/rsa.c ****     }
 106:../src/wolfcrypt/src/rsa.c ****     return InitRsaKey_fips(key, ptr);
 107:../src/wolfcrypt/src/rsa.c **** }
 108:../src/wolfcrypt/src/rsa.c **** 
 109:../src/wolfcrypt/src/rsa.c **** 
 110:../src/wolfcrypt/src/rsa.c **** int  wc_FreeRsaKey(RsaKey* key)
 111:../src/wolfcrypt/src/rsa.c **** {
 112:../src/wolfcrypt/src/rsa.c ****     return FreeRsaKey_fips(key);
 113:../src/wolfcrypt/src/rsa.c **** }
 114:../src/wolfcrypt/src/rsa.c **** 
 115:../src/wolfcrypt/src/rsa.c **** 
 116:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
 117:../src/wolfcrypt/src/rsa.c **** int  wc_RsaPublicEncrypt(const byte* in, word32 inLen, byte* out,
 118:../src/wolfcrypt/src/rsa.c ****                                  word32 outLen, RsaKey* key, WC_RNG* rng)
 119:../src/wolfcrypt/src/rsa.c **** {
 120:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || out == NULL || key == NULL || rng == NULL) {
 121:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 122:../src/wolfcrypt/src/rsa.c ****     }
 123:../src/wolfcrypt/src/rsa.c ****     return RsaPublicEncrypt_fips(in, inLen, out, outLen, key, rng);
 124:../src/wolfcrypt/src/rsa.c **** }
 125:../src/wolfcrypt/src/rsa.c **** #endif
 126:../src/wolfcrypt/src/rsa.c **** 
 127:../src/wolfcrypt/src/rsa.c **** 
 128:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
 129:../src/wolfcrypt/src/rsa.c **** int  wc_RsaPrivateDecryptInline(byte* in, word32 inLen, byte** out,
 130:../src/wolfcrypt/src/rsa.c ****                                         RsaKey* key)
 131:../src/wolfcrypt/src/rsa.c **** {
 132:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || out == NULL || key == NULL) {
 133:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 134:../src/wolfcrypt/src/rsa.c ****     }
 135:../src/wolfcrypt/src/rsa.c ****     return RsaPrivateDecryptInline_fips(in, inLen, out, key);
 136:../src/wolfcrypt/src/rsa.c **** }
 137:../src/wolfcrypt/src/rsa.c **** 
 138:../src/wolfcrypt/src/rsa.c **** 
 139:../src/wolfcrypt/src/rsa.c **** int  wc_RsaPrivateDecrypt(const byte* in, word32 inLen, byte* out,
 140:../src/wolfcrypt/src/rsa.c ****                                   word32 outLen, RsaKey* key)
 141:../src/wolfcrypt/src/rsa.c **** {
 142:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || out == NULL || key == NULL) {
 143:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 144:../src/wolfcrypt/src/rsa.c ****     }
 145:../src/wolfcrypt/src/rsa.c ****     return RsaPrivateDecrypt_fips(in, inLen, out, outLen, key);
 146:../src/wolfcrypt/src/rsa.c **** }
 147:../src/wolfcrypt/src/rsa.c **** 
 148:../src/wolfcrypt/src/rsa.c **** 
 149:../src/wolfcrypt/src/rsa.c **** int  wc_RsaSSL_Sign(const byte* in, word32 inLen, byte* out,
 150:../src/wolfcrypt/src/rsa.c ****                             word32 outLen, RsaKey* key, WC_RNG* rng)
 151:../src/wolfcrypt/src/rsa.c **** {
 152:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || out == NULL || key == NULL || inLen == 0) {
 153:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 154:../src/wolfcrypt/src/rsa.c ****     }
 155:../src/wolfcrypt/src/rsa.c ****     return RsaSSL_Sign_fips(in, inLen, out, outLen, key, rng);
 156:../src/wolfcrypt/src/rsa.c **** }
 157:../src/wolfcrypt/src/rsa.c **** #endif
 158:../src/wolfcrypt/src/rsa.c **** 
 159:../src/wolfcrypt/src/rsa.c **** 
 160:../src/wolfcrypt/src/rsa.c **** int  wc_RsaSSL_VerifyInline(byte* in, word32 inLen, byte** out, RsaKey* key)
 161:../src/wolfcrypt/src/rsa.c **** {
 162:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || out == NULL || key == NULL) {
 163:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 164:../src/wolfcrypt/src/rsa.c ****     }
 165:../src/wolfcrypt/src/rsa.c ****     return RsaSSL_VerifyInline_fips(in, inLen, out, key);
 166:../src/wolfcrypt/src/rsa.c **** }
 167:../src/wolfcrypt/src/rsa.c **** 
 168:../src/wolfcrypt/src/rsa.c **** 
 169:../src/wolfcrypt/src/rsa.c **** int  wc_RsaSSL_Verify(const byte* in, word32 inLen, byte* out,
 170:../src/wolfcrypt/src/rsa.c ****                               word32 outLen, RsaKey* key)
 171:../src/wolfcrypt/src/rsa.c **** {
 172:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || out == NULL || key == NULL || inLen == 0) {
 173:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 174:../src/wolfcrypt/src/rsa.c ****     }
 175:../src/wolfcrypt/src/rsa.c ****     return RsaSSL_Verify_fips(in, inLen, out, outLen, key);
 176:../src/wolfcrypt/src/rsa.c **** }
 177:../src/wolfcrypt/src/rsa.c **** 
 178:../src/wolfcrypt/src/rsa.c **** 
 179:../src/wolfcrypt/src/rsa.c **** int  wc_RsaEncryptSize(const RsaKey* key)
 180:../src/wolfcrypt/src/rsa.c **** {
 181:../src/wolfcrypt/src/rsa.c ****     if (key == NULL) {
 182:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 183:../src/wolfcrypt/src/rsa.c ****     }
 184:../src/wolfcrypt/src/rsa.c ****     return RsaEncryptSize_fips((RsaKey*)key);
 185:../src/wolfcrypt/src/rsa.c **** }
 186:../src/wolfcrypt/src/rsa.c **** 
 187:../src/wolfcrypt/src/rsa.c **** 
 188:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
 189:../src/wolfcrypt/src/rsa.c **** int wc_RsaFlattenPublicKey(RsaKey* key, byte* a, word32* aSz, byte* b,
 190:../src/wolfcrypt/src/rsa.c ****                            word32* bSz)
 191:../src/wolfcrypt/src/rsa.c **** {
 192:../src/wolfcrypt/src/rsa.c **** 
 193:../src/wolfcrypt/src/rsa.c ****     /* not specified as fips so not needing _fips */
 194:../src/wolfcrypt/src/rsa.c ****     return RsaFlattenPublicKey(key, a, aSz, b, bSz);
 195:../src/wolfcrypt/src/rsa.c **** }
 196:../src/wolfcrypt/src/rsa.c **** #endif
 197:../src/wolfcrypt/src/rsa.c **** 
 198:../src/wolfcrypt/src/rsa.c **** 
 199:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_KEY_GEN
 200:../src/wolfcrypt/src/rsa.c ****     int wc_MakeRsaKey(RsaKey* key, int size, long e, WC_RNG* rng)
 201:../src/wolfcrypt/src/rsa.c ****     {
 202:../src/wolfcrypt/src/rsa.c ****         return MakeRsaKey(key, size, e, rng);
 203:../src/wolfcrypt/src/rsa.c ****     }
 204:../src/wolfcrypt/src/rsa.c **** #endif
 205:../src/wolfcrypt/src/rsa.c **** 
 206:../src/wolfcrypt/src/rsa.c **** 
 207:../src/wolfcrypt/src/rsa.c **** /* these are functions in asn and are routed to wolfssl/wolfcrypt/asn.c
 208:../src/wolfcrypt/src/rsa.c **** * wc_RsaPrivateKeyDecode
 209:../src/wolfcrypt/src/rsa.c **** * wc_RsaPublicKeyDecode
 210:../src/wolfcrypt/src/rsa.c **** */
 211:../src/wolfcrypt/src/rsa.c **** 
 212:../src/wolfcrypt/src/rsa.c **** #else /* else build without fips, or for new fips */
 213:../src/wolfcrypt/src/rsa.c **** 
 214:../src/wolfcrypt/src/rsa.c **** #include <wolfssl/wolfcrypt/random.h>
 215:../src/wolfcrypt/src/rsa.c **** #include <wolfssl/wolfcrypt/logging.h>
 216:../src/wolfcrypt/src/rsa.c **** #ifdef WOLF_CRYPTO_CB
 217:../src/wolfcrypt/src/rsa.c ****     #include <wolfssl/wolfcrypt/cryptocb.h>
 218:../src/wolfcrypt/src/rsa.c **** #endif
 219:../src/wolfcrypt/src/rsa.c **** #ifdef NO_INLINE
 220:../src/wolfcrypt/src/rsa.c ****     #include <wolfssl/wolfcrypt/misc.h>
 221:../src/wolfcrypt/src/rsa.c **** #else
 222:../src/wolfcrypt/src/rsa.c ****     #define WOLFSSL_MISC_INCLUDED
 223:../src/wolfcrypt/src/rsa.c ****     #include <wolfcrypt/src/misc.c>
 224:../src/wolfcrypt/src/rsa.c **** #endif
 225:../src/wolfcrypt/src/rsa.c **** 
 226:../src/wolfcrypt/src/rsa.c **** 
 227:../src/wolfcrypt/src/rsa.c **** enum {
 228:../src/wolfcrypt/src/rsa.c ****     RSA_STATE_NONE = 0,
 229:../src/wolfcrypt/src/rsa.c **** 
 230:../src/wolfcrypt/src/rsa.c ****     RSA_STATE_ENCRYPT_PAD,
 231:../src/wolfcrypt/src/rsa.c ****     RSA_STATE_ENCRYPT_EXPTMOD,
 232:../src/wolfcrypt/src/rsa.c ****     RSA_STATE_ENCRYPT_RES,
 233:../src/wolfcrypt/src/rsa.c **** 
 234:../src/wolfcrypt/src/rsa.c ****     RSA_STATE_DECRYPT_EXPTMOD,
 235:../src/wolfcrypt/src/rsa.c ****     RSA_STATE_DECRYPT_UNPAD,
 236:../src/wolfcrypt/src/rsa.c ****     RSA_STATE_DECRYPT_RES,
 237:../src/wolfcrypt/src/rsa.c **** };
 238:../src/wolfcrypt/src/rsa.c **** 
 239:../src/wolfcrypt/src/rsa.c **** 
 240:../src/wolfcrypt/src/rsa.c **** static void wc_RsaCleanup(RsaKey* key)
 241:../src/wolfcrypt/src/rsa.c **** {
 417                             		.loc 2 241 1
 418 0000 7E AA                   		push.l	r10
 419                             	.LCFI27:
 420 0002 71 0A F8                		add	#-8, r0, r10
 421                             	.LCFI28:
 422 0005 EF A0                   		mov.L	r10, r0
 423 0007 E7 A1 01                		mov.L	r1, 4[r10]
 242:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_INLINE) && !defined(WOLFSSL_NO_MALLOC)
 243:../src/wolfcrypt/src/rsa.c ****     if (key && key->data) {
 424                             		.loc 2 243 8
 425 000a ED A5 01                		mov.L	4[r10], r5
 426 000d 61 05                   		cmp	#0, r5
 427 000f 20 72                   		beq	.L34
 428                             		.loc 2 243 19 discriminator 1
 429 0011 ED A5 01                		mov.L	4[r10], r5
 430 0014 EE 55 21 06             		mov.L	6276[r5], r5
 431                             		.loc 2 243 13 discriminator 1
 432 0018 61 05                   		cmp	#0, r5
 433 001a 20 67                   		beq	.L34
 244:../src/wolfcrypt/src/rsa.c ****         /* make sure any allocated memory is free'd */
 245:../src/wolfcrypt/src/rsa.c ****         if (key->dataIsAlloc) {
 434                             		.loc 2 245 16
 435 001c ED A5 01                		mov.L	4[r10], r5
 436 001f CE 55 98 18             		mov.B	6296[r5], r5
 437                             		.loc 2 245 12
 438 0023 5B 55                   		movu.B	r5, r5
 439 0025 61 05                   		cmp	#0, r5
 440 0027 20 4A                   		beq	.L30
 246:../src/wolfcrypt/src/rsa.c ****         #ifndef WOLFSSL_RSA_PUBLIC_ONLY
 247:../src/wolfcrypt/src/rsa.c ****             if (key->type == RSA_PRIVATE_DECRYPT ||
 441                             		.loc 2 247 20
 442 0029 ED A5 01                		mov.L	4[r10], r5
 443 002c EE 55 22 06             		mov.L	6280[r5], r5
 444                             		.loc 2 247 16
 445 0030 61 35                   		cmp	#3, r5
 446 0032 20 0D                   		beq	.L31
 248:../src/wolfcrypt/src/rsa.c ****                 key->type == RSA_PRIVATE_ENCRYPT) {
 447                             		.loc 2 248 20 discriminator 1
 448 0034 ED A5 01                		mov.L	4[r10], r5
 449 0037 EE 55 22 06             		mov.L	6280[r5], r5
 247:../src/wolfcrypt/src/rsa.c ****                 key->type == RSA_PRIVATE_ENCRYPT) {
 450                             		.loc 2 247 50 discriminator 1
 451 003b 61 25                   		cmp	#2, r5
 452 003d 21 18                   		bne	.L32
 453                             	.L31:
 249:../src/wolfcrypt/src/rsa.c ****                 ForceZero(key->data, key->dataLen);
 454                             		.loc 2 249 30
 455 003f ED A5 01                		mov.L	4[r10], r5
 456 0042 EE 54 21 06             		mov.L	6276[r5], r4
 457                             		.loc 2 249 17
 458 0046 ED A5 01                		mov.L	4[r10], r5
 459 0049 EE 55 24 06             		mov.L	6288[r5], r5
 460 004d EF 52                   		mov.L	r5, r2
 461 004f EF 41                   		mov.L	r4, r1
 462 0051 05 00 00 00             		bsr	_ForceZero
 463                             	.L32:
 464                             	.LBB2:
 250:../src/wolfcrypt/src/rsa.c ****             }
 251:../src/wolfcrypt/src/rsa.c ****         #endif
 252:../src/wolfcrypt/src/rsa.c ****             XFREE(key->data, key->heap, DYNAMIC_TYPE_WOLF_BIGINT);
 465                             		.loc 2 252 13
 466 0055 ED A5 01                		mov.L	4[r10], r5
 467 0058 EE 55 21 06             		mov.L	6276[r5], r5
 468 005c E3 A5                   		mov.L	r5, [r10]
 469 005e EC A5                   		mov.L	[r10], r5
 470 0060 61 05                   		cmp	#0, r5
 471 0062 17                      		beq	.L33
 472                             		.loc 2 252 13 is_stmt 0 discriminator 1
 473 0063 EC A1                   		mov.L	[r10], r1
 474 0065 05 00 00 00             		bsr	_wolfSSL_Free
 475                             	.L33:
 476                             	.LBE2:
 253:../src/wolfcrypt/src/rsa.c ****             key->dataIsAlloc = 0;
 477                             		.loc 2 253 30 is_stmt 1
 478 0069 ED A5 01                		mov.L	4[r10], r5
 479 006c FA 54 98 18 00          		mov.B	#0, 6296[r5]
 480                             	.L30:
 254:../src/wolfcrypt/src/rsa.c ****         }
 255:../src/wolfcrypt/src/rsa.c ****         key->data = NULL;
 481                             		.loc 2 255 19
 482 0071 ED A5 01                		mov.L	4[r10], r5
 483 0074 FA 56 21 06 00          		mov.L	#0, 6276[r5]
 256:../src/wolfcrypt/src/rsa.c ****         key->dataLen = 0;
 484                             		.loc 2 256 22
 485 0079 ED A5 01                		mov.L	4[r10], r5
 486 007c FA 56 24 06 00          		mov.L	#0, 6288[r5]
 487                             	.L34:
 257:../src/wolfcrypt/src/rsa.c ****     }
 258:../src/wolfcrypt/src/rsa.c **** #else
 259:../src/wolfcrypt/src/rsa.c ****     (void)key;
 260:../src/wolfcrypt/src/rsa.c **** #endif
 261:../src/wolfcrypt/src/rsa.c **** }
 488                             		.loc 2 261 1
 489 0081 03                      		nop
 490 0082 3F AA 03                		rtsd	#12, r10-r10
 491                             	.LFE43:
 493                             		.section	.text.wc_InitRsaKey_ex,"ax",@progbits
 494                             		.global	_wc_InitRsaKey_ex
 496                             	_wc_InitRsaKey_ex:
 497                             	.LFB44:
 262:../src/wolfcrypt/src/rsa.c **** 
 263:../src/wolfcrypt/src/rsa.c **** int wc_InitRsaKey_ex(RsaKey* key, void* heap, int devId)
 264:../src/wolfcrypt/src/rsa.c **** {
 498                             		.loc 2 264 1
 499 0000 7E AA                   		push.l	r10
 500                             	.LCFI29:
 501 0002 7E A6                   		push.l	r6
 502                             	.LCFI30:
 503 0004 71 0A F0                		add	#-16, r0, r10
 504                             	.LCFI31:
 505 0007 71 A0 F8                		add	#-8, r10, r0
 506                             	.LCFI32:
 507 000a E7 A1 01                		mov.L	r1, 4[r10]
 508 000d E7 A2 02                		mov.L	r2, 8[r10]
 509 0010 E7 A3 03                		mov.L	r3, 12[r10]
 265:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 510                             		.loc 2 265 9
 511 0013 F8 A6 00                		mov.L	#0, [r10]
 266:../src/wolfcrypt/src/rsa.c **** 
 267:../src/wolfcrypt/src/rsa.c ****     if (key == NULL) {
 512                             		.loc 2 267 8
 513 0016 ED A5 01                		mov.L	4[r10], r5
 514 0019 61 05                   		cmp	#0, r5
 515 001b 18                      		bne	.L36
 268:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 516                             		.loc 2 268 16
 517 001c FB 5A 53 FF             		mov.L	#-173, r5
 518 0020 38 C4 00                		bra	.L37
 519                             	.L36:
 269:../src/wolfcrypt/src/rsa.c ****     }
 270:../src/wolfcrypt/src/rsa.c **** 
 271:../src/wolfcrypt/src/rsa.c ****     XMEMSET(key, 0, sizeof(RsaKey));
 520                             		.loc 2 271 5
 521 0023 FB 3A 9C 18             		mov.L	#0x189c, r3
 522 0027 66 02                   		mov.L	#0, r2
 523 0029 ED A1 01                		mov.L	4[r10], r1
 524 002c 05 00 00 00             		bsr	_memset
 272:../src/wolfcrypt/src/rsa.c **** 
 273:../src/wolfcrypt/src/rsa.c ****     key->type = RSA_TYPE_UNKNOWN;
 525                             		.loc 2 273 15
 526 0030 ED A5 01                		mov.L	4[r10], r5
 527 0033 FA 56 22 06 FF          		mov.L	#-1, 6280[r5]
 274:../src/wolfcrypt/src/rsa.c ****     key->state = RSA_STATE_NONE;
 528                             		.loc 2 274 16
 529 0038 ED A5 01                		mov.L	4[r10], r5
 530 003b FA 56 23 06 00          		mov.L	#0, 6284[r5]
 275:../src/wolfcrypt/src/rsa.c ****     key->heap = heap;
 531                             		.loc 2 275 15
 532 0040 ED A5 01                		mov.L	4[r10], r5
 533 0043 ED A4 02                		mov.L	8[r10], r4
 534 0046 EB 54 20 06             		mov.L	r4, 6272[r5]
 276:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_INLINE) && !defined(WOLFSSL_NO_MALLOC)
 277:../src/wolfcrypt/src/rsa.c ****     key->dataIsAlloc = 0;
 535                             		.loc 2 277 22
 536 004a ED A5 01                		mov.L	4[r10], r5
 537 004d FA 54 98 18 00          		mov.B	#0, 6296[r5]
 278:../src/wolfcrypt/src/rsa.c ****     key->data = NULL;
 538                             		.loc 2 278 15
 539 0052 ED A5 01                		mov.L	4[r10], r5
 540 0055 FA 56 21 06 00          		mov.L	#0, 6276[r5]
 279:../src/wolfcrypt/src/rsa.c **** #endif
 280:../src/wolfcrypt/src/rsa.c ****     key->dataLen = 0;
 541                             		.loc 2 280 18
 542 005a ED A5 01                		mov.L	4[r10], r5
 543 005d FA 56 24 06 00          		mov.L	#0, 6288[r5]
 281:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
 282:../src/wolfcrypt/src/rsa.c ****     key->rng = NULL;
 544                             		.loc 2 282 14
 545 0062 ED A5 01                		mov.L	4[r10], r5
 546 0065 FA 56 25 06 00          		mov.L	#0, 6292[r5]
 283:../src/wolfcrypt/src/rsa.c **** #endif
 284:../src/wolfcrypt/src/rsa.c **** 
 285:../src/wolfcrypt/src/rsa.c **** #ifdef WOLF_CRYPTO_CB
 286:../src/wolfcrypt/src/rsa.c ****     key->devId = devId;
 287:../src/wolfcrypt/src/rsa.c **** #else
 288:../src/wolfcrypt/src/rsa.c ****     (void)devId;
 289:../src/wolfcrypt/src/rsa.c **** #endif
 290:../src/wolfcrypt/src/rsa.c **** 
 291:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_ASYNC_CRYPT
 292:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_CERT_GEN
 293:../src/wolfcrypt/src/rsa.c ****         XMEMSET(&key->certSignCtx, 0, sizeof(CertSignCtx));
 294:../src/wolfcrypt/src/rsa.c ****     #endif
 295:../src/wolfcrypt/src/rsa.c **** 
 296:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_ASYNC_ENABLE_RSA
 297:../src/wolfcrypt/src/rsa.c ****         /* handle as async */
 298:../src/wolfcrypt/src/rsa.c ****         ret = wolfAsync_DevCtxInit(&key->asyncDev, WOLFSSL_ASYNC_MARKER_RSA,
 299:../src/wolfcrypt/src/rsa.c ****                                                             key->heap, devId);
 300:../src/wolfcrypt/src/rsa.c ****         if (ret != 0)
 301:../src/wolfcrypt/src/rsa.c ****             return ret;
 302:../src/wolfcrypt/src/rsa.c ****     #endif /* WC_ASYNC_ENABLE_RSA */
 303:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_ASYNC_CRYPT */
 304:../src/wolfcrypt/src/rsa.c **** 
 305:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
 306:../src/wolfcrypt/src/rsa.c ****     ret = mp_init_multi(&key->n, &key->e, NULL, NULL, NULL, NULL);
 547                             		.loc 2 306 25
 548 006a ED A1 01                		mov.L	4[r10], r1
 549                             		.loc 2 306 34
 550 006d ED A5 01                		mov.L	4[r10], r5
 551 0070 72 55 10 03             		add	#0x310, r5
 552                             		.loc 2 306 11
 553 0074 3E 01 00                		mov.L	#0, 4[r0]
 554 0077 F8 06 00                		mov.L	#0, [r0]
 555 007a 66 04                   		mov.L	#0, r4
 556 007c 66 03                   		mov.L	#0, r3
 557 007e EF 52                   		mov.L	r5, r2
 558 0080 05 00 00 00             		bsr	_sp_init_multi
 559 0084 E3 A1                   		mov.L	r1, [r10]
 307:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY)
 560                             		.loc 2 307 8
 561 0086 EC A5                   		mov.L	[r10], r5
 562 0088 61 05                   		cmp	#0, r5
 563 008a 15                      		beq	.L38
 308:../src/wolfcrypt/src/rsa.c ****         return ret;
 564                             		.loc 2 308 16
 565 008b EC A5                   		mov.L	[r10], r5
 566 008d 2E 57                   		bra	.L37
 567                             	.L38:
 309:../src/wolfcrypt/src/rsa.c **** 
 310:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_KEY_GEN) && !defined(OPENSSL_EXTRA) && defined(RSA_LOW_MEM)
 311:../src/wolfcrypt/src/rsa.c ****     ret = mp_init_multi(&key->d, &key->p, &key->q, NULL, NULL, NULL);
 312:../src/wolfcrypt/src/rsa.c **** #else
 313:../src/wolfcrypt/src/rsa.c ****     ret = mp_init_multi(&key->d, &key->p, &key->q, &key->dP, &key->dQ, &key->u);
 568                             		.loc 2 313 25
 569 008f ED A5 01                		mov.L	4[r10], r5
 570 0092 72 51 20 06             		add	#0x620, r5, r1
 571                             		.loc 2 313 34
 572 0096 ED A5 01                		mov.L	4[r10], r5
 573 0099 72 52 30 09             		add	#0x930, r5, r2
 574                             		.loc 2 313 43
 575 009d ED A5 01                		mov.L	4[r10], r5
 576 00a0 72 53 40 0C             		add	#0xc40, r5, r3
 577                             		.loc 2 313 52
 578 00a4 ED A5 01                		mov.L	4[r10], r5
 579 00a7 72 54 50 0F             		add	#0xf50, r5, r4
 580                             		.loc 2 313 62
 581 00ab ED A5 01                		mov.L	4[r10], r5
 582 00ae 72 56 60 12             		add	#0x1260, r5, r6
 583                             		.loc 2 313 72
 584 00b2 ED A5 01                		mov.L	4[r10], r5
 585 00b5 72 55 70 15             		add	#0x1570, r5
 586                             		.loc 2 313 11
 587 00b9 A0 0D                   		mov.L	r5, 4[r0]
 588 00bb E3 06                   		mov.L	r6, [r0]
 589 00bd 05 00 00 00             		bsr	_sp_init_multi
 590 00c1 E3 A1                   		mov.L	r1, [r10]
 314:../src/wolfcrypt/src/rsa.c **** #endif
 315:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY) {
 591                             		.loc 2 315 8
 592 00c3 EC A5                   		mov.L	[r10], r5
 593 00c5 61 05                   		cmp	#0, r5
 594 00c7 20 1B                   		beq	.L39
 316:../src/wolfcrypt/src/rsa.c ****         mp_clear(&key->n);
 595                             		.loc 2 316 18
 596 00c9 ED A5 01                		mov.L	4[r10], r5
 597                             		.loc 2 316 9
 598 00cc EF 51                   		mov.L	r5, r1
 599 00ce 05 00 00 00             		bsr	_sp_clear
 317:../src/wolfcrypt/src/rsa.c ****         mp_clear(&key->e);
 600                             		.loc 2 317 18
 601 00d2 ED A5 01                		mov.L	4[r10], r5
 602 00d5 72 55 10 03             		add	#0x310, r5
 603                             		.loc 2 317 9
 604 00d9 EF 51                   		mov.L	r5, r1
 605 00db 05 00 00 00             		bsr	_sp_clear
 318:../src/wolfcrypt/src/rsa.c ****         return ret;
 606                             		.loc 2 318 16
 607 00df EC A5                   		mov.L	[r10], r5
 608 00e1 0B                      		bra	.L37
 609                             	.L39:
 319:../src/wolfcrypt/src/rsa.c ****     }
 320:../src/wolfcrypt/src/rsa.c **** #else
 321:../src/wolfcrypt/src/rsa.c ****     ret = mp_init(&key->n);
 322:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY)
 323:../src/wolfcrypt/src/rsa.c ****         return ret;
 324:../src/wolfcrypt/src/rsa.c ****     ret = mp_init(&key->e);
 325:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY) {
 326:../src/wolfcrypt/src/rsa.c ****         mp_clear(&key->n);
 327:../src/wolfcrypt/src/rsa.c ****         return ret;
 328:../src/wolfcrypt/src/rsa.c ****     }
 329:../src/wolfcrypt/src/rsa.c **** #endif
 330:../src/wolfcrypt/src/rsa.c **** 
 331:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_XILINX_CRYPT
 332:../src/wolfcrypt/src/rsa.c ****     key->pubExp = 0;
 333:../src/wolfcrypt/src/rsa.c ****     key->mod    = NULL;
 334:../src/wolfcrypt/src/rsa.c **** #endif
 335:../src/wolfcrypt/src/rsa.c **** 
 336:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_AFALG_XILINX_RSA
 337:../src/wolfcrypt/src/rsa.c ****     key->alFd = WC_SOCK_NOTSET;
 338:../src/wolfcrypt/src/rsa.c ****     key->rdFd = WC_SOCK_NOTSET;
 339:../src/wolfcrypt/src/rsa.c **** #endif
 340:../src/wolfcrypt/src/rsa.c **** 
 341:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_KCAPI_RSA
 342:../src/wolfcrypt/src/rsa.c ****     key->handle = NULL;
 343:../src/wolfcrypt/src/rsa.c **** #endif
 344:../src/wolfcrypt/src/rsa.c **** 
 345:../src/wolfcrypt/src/rsa.c ****     return ret;
 610                             		.loc 2 345 12
 611 00e2 EC A5                   		mov.L	[r10], r5
 612                             		.balign 8,3,1
 613                             	.L37:
 346:../src/wolfcrypt/src/rsa.c **** }
 614                             		.loc 2 346 1
 615 00e4 EF 51                   		mov.L	r5, r1
 616 00e6 71 00 18                		add	#24, r0
 617 00e9 7E B6                   		pop	r6
 618 00eb 7E BA                   		pop	r10
 619 00ed 02                      		rts
 620                             	.LFE44:
 622 00ee EF 00                   		.section	.text.wc_InitRsaKey,"ax",@progbits
 623                             		.global	_wc_InitRsaKey
 625                             	_wc_InitRsaKey:
 626                             	.LFB45:
 347:../src/wolfcrypt/src/rsa.c **** 
 348:../src/wolfcrypt/src/rsa.c **** int wc_InitRsaKey(RsaKey* key, void* heap)
 349:../src/wolfcrypt/src/rsa.c **** {
 627                             		.loc 2 349 1
 628 0000 7E AA                   		push.l	r10
 629                             	.LCFI33:
 630 0002 71 0A F8                		add	#-8, r0, r10
 631                             	.LCFI34:
 632 0005 EF A0                   		mov.L	r10, r0
 633 0007 E3 A1                   		mov.L	r1, [r10]
 634 0009 E7 A2 01                		mov.L	r2, 4[r10]
 350:../src/wolfcrypt/src/rsa.c ****     return wc_InitRsaKey_ex(key, heap, INVALID_DEVID);
 635                             		.loc 2 350 12
 636 000c FB 36 FE                		mov.L	#-2, r3
 637 000f ED A2 01                		mov.L	4[r10], r2
 638 0012 EC A1                   		mov.L	[r10], r1
 639 0014 05 00 00 00             		bsr	_wc_InitRsaKey_ex
 640 0018 EF 15                   		mov.L	r1, r5
 351:../src/wolfcrypt/src/rsa.c **** }
 641                             		.loc 2 351 1
 642 001a EF 51                   		mov.L	r5, r1
 643 001c 3F AA 03                		rtsd	#12, r10-r10
 644                             	.LFE45:
 646                             		.section	.text.wc_FreeRsaKey,"ax",@progbits
 647                             		.global	_wc_FreeRsaKey
 649                             	_wc_FreeRsaKey:
 650                             	.LFB46:
 352:../src/wolfcrypt/src/rsa.c **** 
 353:../src/wolfcrypt/src/rsa.c **** #ifdef WOLF_PRIVATE_KEY_ID
 354:../src/wolfcrypt/src/rsa.c **** int wc_InitRsaKey_Id(RsaKey* key, unsigned char* id, int len, void* heap,
 355:../src/wolfcrypt/src/rsa.c ****                      int devId)
 356:../src/wolfcrypt/src/rsa.c **** {
 357:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 358:../src/wolfcrypt/src/rsa.c **** 
 359:../src/wolfcrypt/src/rsa.c ****     if (key == NULL)
 360:../src/wolfcrypt/src/rsa.c ****         ret = BAD_FUNC_ARG;
 361:../src/wolfcrypt/src/rsa.c ****     if (ret == 0 && (len < 0 || len > RSA_MAX_ID_LEN))
 362:../src/wolfcrypt/src/rsa.c ****         ret = BUFFER_E;
 363:../src/wolfcrypt/src/rsa.c **** 
 364:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 365:../src/wolfcrypt/src/rsa.c ****         ret = wc_InitRsaKey_ex(key, heap, devId);
 366:../src/wolfcrypt/src/rsa.c ****     if (ret == 0 && id != NULL && len != 0) {
 367:../src/wolfcrypt/src/rsa.c ****         XMEMCPY(key->id, id, len);
 368:../src/wolfcrypt/src/rsa.c ****         key->idLen = len;
 369:../src/wolfcrypt/src/rsa.c ****     }
 370:../src/wolfcrypt/src/rsa.c **** 
 371:../src/wolfcrypt/src/rsa.c ****     return ret;
 372:../src/wolfcrypt/src/rsa.c **** }
 373:../src/wolfcrypt/src/rsa.c **** 
 374:../src/wolfcrypt/src/rsa.c **** int wc_InitRsaKey_Label(RsaKey* key, const char* label, void* heap, int devId)
 375:../src/wolfcrypt/src/rsa.c **** {
 376:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 377:../src/wolfcrypt/src/rsa.c ****     int labelLen = 0;
 378:../src/wolfcrypt/src/rsa.c **** 
 379:../src/wolfcrypt/src/rsa.c ****     if (key == NULL || label == NULL)
 380:../src/wolfcrypt/src/rsa.c ****         ret = BAD_FUNC_ARG;
 381:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 382:../src/wolfcrypt/src/rsa.c ****         labelLen = (int)XSTRLEN(label);
 383:../src/wolfcrypt/src/rsa.c ****         if (labelLen == 0 || labelLen > RSA_MAX_LABEL_LEN)
 384:../src/wolfcrypt/src/rsa.c ****             ret = BUFFER_E;
 385:../src/wolfcrypt/src/rsa.c ****     }
 386:../src/wolfcrypt/src/rsa.c **** 
 387:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 388:../src/wolfcrypt/src/rsa.c ****         ret = wc_InitRsaKey_ex(key, heap, devId);
 389:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 390:../src/wolfcrypt/src/rsa.c ****         XMEMCPY(key->label, label, labelLen);
 391:../src/wolfcrypt/src/rsa.c ****         key->labelLen = labelLen;
 392:../src/wolfcrypt/src/rsa.c ****     }
 393:../src/wolfcrypt/src/rsa.c **** 
 394:../src/wolfcrypt/src/rsa.c ****     return ret;
 395:../src/wolfcrypt/src/rsa.c **** }
 396:../src/wolfcrypt/src/rsa.c **** #endif /* WOLF_PRIVATE_KEY_ID */
 397:../src/wolfcrypt/src/rsa.c **** 
 398:../src/wolfcrypt/src/rsa.c **** 
 399:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_XILINX_CRYPT
 400:../src/wolfcrypt/src/rsa.c **** #define MAX_E_SIZE 4
 401:../src/wolfcrypt/src/rsa.c **** /* Used to setup hardware state
 402:../src/wolfcrypt/src/rsa.c ****  *
 403:../src/wolfcrypt/src/rsa.c ****  * key  the RSA key to setup
 404:../src/wolfcrypt/src/rsa.c ****  *
 405:../src/wolfcrypt/src/rsa.c ****  * returns 0 on success
 406:../src/wolfcrypt/src/rsa.c ****  */
 407:../src/wolfcrypt/src/rsa.c **** int wc_InitRsaHw(RsaKey* key)
 408:../src/wolfcrypt/src/rsa.c **** {
 409:../src/wolfcrypt/src/rsa.c ****     unsigned char* m; /* RSA modulus */
 410:../src/wolfcrypt/src/rsa.c ****     word32 e = 0;     /* RSA public exponent */
 411:../src/wolfcrypt/src/rsa.c ****     int mSz;
 412:../src/wolfcrypt/src/rsa.c ****     int eSz;
 413:../src/wolfcrypt/src/rsa.c **** 
 414:../src/wolfcrypt/src/rsa.c ****     if (key == NULL) {
 415:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 416:../src/wolfcrypt/src/rsa.c ****     }
 417:../src/wolfcrypt/src/rsa.c **** 
 418:../src/wolfcrypt/src/rsa.c ****     mSz = mp_unsigned_bin_size(&(key->n));
 419:../src/wolfcrypt/src/rsa.c ****     m = (unsigned char*)XMALLOC(mSz, key->heap, DYNAMIC_TYPE_KEY);
 420:../src/wolfcrypt/src/rsa.c ****     if (m == NULL) {
 421:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
 422:../src/wolfcrypt/src/rsa.c ****     }
 423:../src/wolfcrypt/src/rsa.c **** 
 424:../src/wolfcrypt/src/rsa.c ****     if (mp_to_unsigned_bin(&(key->n), m) != MP_OKAY) {
 425:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Unable to get RSA key modulus");
 426:../src/wolfcrypt/src/rsa.c ****         XFREE(m, key->heap, DYNAMIC_TYPE_KEY);
 427:../src/wolfcrypt/src/rsa.c ****         return MP_READ_E;
 428:../src/wolfcrypt/src/rsa.c ****     }
 429:../src/wolfcrypt/src/rsa.c **** 
 430:../src/wolfcrypt/src/rsa.c ****     eSz = mp_unsigned_bin_size(&(key->e));
 431:../src/wolfcrypt/src/rsa.c ****     if (eSz > MAX_E_SIZE) {
 432:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Exponent of size 4 bytes expected");
 433:../src/wolfcrypt/src/rsa.c ****         XFREE(m, key->heap, DYNAMIC_TYPE_KEY);
 434:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 435:../src/wolfcrypt/src/rsa.c ****     }
 436:../src/wolfcrypt/src/rsa.c **** 
 437:../src/wolfcrypt/src/rsa.c ****     if (mp_to_unsigned_bin(&(key->e), (byte*)&e + (MAX_E_SIZE - eSz))
 438:../src/wolfcrypt/src/rsa.c ****                 != MP_OKAY) {
 439:../src/wolfcrypt/src/rsa.c ****         XFREE(m, key->heap, DYNAMIC_TYPE_KEY);
 440:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Unable to get RSA key exponent");
 441:../src/wolfcrypt/src/rsa.c ****         return MP_READ_E;
 442:../src/wolfcrypt/src/rsa.c ****     }
 443:../src/wolfcrypt/src/rsa.c **** 
 444:../src/wolfcrypt/src/rsa.c ****     /* check for existing mod buffer to avoid memory leak */
 445:../src/wolfcrypt/src/rsa.c ****     if (key->mod != NULL) {
 446:../src/wolfcrypt/src/rsa.c ****         XFREE(key->mod, key->heap, DYNAMIC_TYPE_KEY);
 447:../src/wolfcrypt/src/rsa.c ****     }
 448:../src/wolfcrypt/src/rsa.c **** 
 449:../src/wolfcrypt/src/rsa.c ****     key->pubExp = e;
 450:../src/wolfcrypt/src/rsa.c ****     key->mod    = m;
 451:../src/wolfcrypt/src/rsa.c **** 
 452:../src/wolfcrypt/src/rsa.c ****     if (XSecure_RsaInitialize(&(key->xRsa), key->mod, NULL,
 453:../src/wolfcrypt/src/rsa.c ****                 (byte*)&(key->pubExp)) != XST_SUCCESS) {
 454:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Unable to initialize RSA on hardware");
 455:../src/wolfcrypt/src/rsa.c ****         XFREE(m, key->heap, DYNAMIC_TYPE_KEY);
 456:../src/wolfcrypt/src/rsa.c ****         return BAD_STATE_E;
 457:../src/wolfcrypt/src/rsa.c ****     }
 458:../src/wolfcrypt/src/rsa.c **** 
 459:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_XILINX_PATCH
 460:../src/wolfcrypt/src/rsa.c ****    /* currently a patch of xsecure_rsa.c for 2048 bit keys */
 461:../src/wolfcrypt/src/rsa.c ****    if (wc_RsaEncryptSize(key) == 256) {
 462:../src/wolfcrypt/src/rsa.c ****        if (XSecure_RsaSetSize(&(key->xRsa), 2048) != XST_SUCCESS) {
 463:../src/wolfcrypt/src/rsa.c ****            WOLFSSL_MSG("Unable to set RSA key size on hardware");
 464:../src/wolfcrypt/src/rsa.c ****            XFREE(m, key->heap, DYNAMIC_TYPE_KEY);
 465:../src/wolfcrypt/src/rsa.c ****            return BAD_STATE_E;
 466:../src/wolfcrypt/src/rsa.c ****        }
 467:../src/wolfcrypt/src/rsa.c ****    }
 468:../src/wolfcrypt/src/rsa.c **** #endif
 469:../src/wolfcrypt/src/rsa.c ****     return 0;
 470:../src/wolfcrypt/src/rsa.c **** } /* WOLFSSL_XILINX_CRYPT*/
 471:../src/wolfcrypt/src/rsa.c **** 
 472:../src/wolfcrypt/src/rsa.c **** #elif defined(WOLFSSL_CRYPTOCELL)
 473:../src/wolfcrypt/src/rsa.c **** 
 474:../src/wolfcrypt/src/rsa.c **** int wc_InitRsaHw(RsaKey* key)
 475:../src/wolfcrypt/src/rsa.c **** {
 476:../src/wolfcrypt/src/rsa.c ****     CRYSError_t ret = 0;
 477:../src/wolfcrypt/src/rsa.c ****     byte e[3];
 478:../src/wolfcrypt/src/rsa.c ****     word32 eSz = sizeof(e);
 479:../src/wolfcrypt/src/rsa.c ****     byte n[256];
 480:../src/wolfcrypt/src/rsa.c ****     word32 nSz = sizeof(n);
 481:../src/wolfcrypt/src/rsa.c ****     byte d[256];
 482:../src/wolfcrypt/src/rsa.c ****     word32 dSz = sizeof(d);
 483:../src/wolfcrypt/src/rsa.c ****     byte p[128];
 484:../src/wolfcrypt/src/rsa.c ****     word32 pSz = sizeof(p);
 485:../src/wolfcrypt/src/rsa.c ****     byte q[128];
 486:../src/wolfcrypt/src/rsa.c ****     word32 qSz = sizeof(q);
 487:../src/wolfcrypt/src/rsa.c **** 
 488:../src/wolfcrypt/src/rsa.c ****     if (key == NULL) {
 489:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 490:../src/wolfcrypt/src/rsa.c ****     }
 491:../src/wolfcrypt/src/rsa.c **** 
 492:../src/wolfcrypt/src/rsa.c ****     ret = wc_RsaExportKey(key, e, &eSz, n, &nSz, d, &dSz, p, &pSz, q, &qSz);
 493:../src/wolfcrypt/src/rsa.c ****     if (ret != 0)
 494:../src/wolfcrypt/src/rsa.c ****         return MP_READ_E;
 495:../src/wolfcrypt/src/rsa.c **** 
 496:../src/wolfcrypt/src/rsa.c ****     ret = CRYS_RSA_Build_PubKey(&key->ctx.pubKey, e, eSz, n, nSz);
 497:../src/wolfcrypt/src/rsa.c ****     if (ret != SA_SILIB_RET_OK){
 498:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("CRYS_RSA_Build_PubKey failed");
 499:../src/wolfcrypt/src/rsa.c ****         return ret;
 500:../src/wolfcrypt/src/rsa.c ****     }
 501:../src/wolfcrypt/src/rsa.c **** 
 502:../src/wolfcrypt/src/rsa.c ****     ret =  CRYS_RSA_Build_PrivKey(&key->ctx.privKey, d, dSz, e, eSz, n, nSz);
 503:../src/wolfcrypt/src/rsa.c **** 
 504:../src/wolfcrypt/src/rsa.c ****     if (ret != SA_SILIB_RET_OK){
 505:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("CRYS_RSA_Build_PrivKey failed");
 506:../src/wolfcrypt/src/rsa.c ****         return ret;
 507:../src/wolfcrypt/src/rsa.c ****     }
 508:../src/wolfcrypt/src/rsa.c ****     key->type = RSA_PRIVATE;
 509:../src/wolfcrypt/src/rsa.c ****     return 0;
 510:../src/wolfcrypt/src/rsa.c **** }
 511:../src/wolfcrypt/src/rsa.c **** 
 512:../src/wolfcrypt/src/rsa.c **** static int cc310_RSA_GenerateKeyPair(RsaKey* key, int size, long e)
 513:../src/wolfcrypt/src/rsa.c **** {
 514:../src/wolfcrypt/src/rsa.c ****     CRYSError_t             ret = 0;
 515:../src/wolfcrypt/src/rsa.c ****     CRYS_RSAKGData_t        KeyGenData;
 516:../src/wolfcrypt/src/rsa.c ****     CRYS_RSAKGFipsContext_t FipsCtx;
 517:../src/wolfcrypt/src/rsa.c ****     byte ex[3];
 518:../src/wolfcrypt/src/rsa.c ****     word16 eSz = sizeof(ex);
 519:../src/wolfcrypt/src/rsa.c ****     byte n[256];
 520:../src/wolfcrypt/src/rsa.c ****     word16 nSz = sizeof(n);
 521:../src/wolfcrypt/src/rsa.c **** 
 522:../src/wolfcrypt/src/rsa.c ****     ret = CRYS_RSA_KG_GenerateKeyPair(&wc_rndState,
 523:../src/wolfcrypt/src/rsa.c ****                         wc_rndGenVectFunc,
 524:../src/wolfcrypt/src/rsa.c ****                         (byte*)&e,
 525:../src/wolfcrypt/src/rsa.c ****                         3*sizeof(byte),
 526:../src/wolfcrypt/src/rsa.c ****                         size,
 527:../src/wolfcrypt/src/rsa.c ****                         &key->ctx.privKey,
 528:../src/wolfcrypt/src/rsa.c ****                         &key->ctx.pubKey,
 529:../src/wolfcrypt/src/rsa.c ****                         &KeyGenData,
 530:../src/wolfcrypt/src/rsa.c ****                         &FipsCtx);
 531:../src/wolfcrypt/src/rsa.c **** 
 532:../src/wolfcrypt/src/rsa.c ****     if (ret != SA_SILIB_RET_OK){
 533:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("CRYS_RSA_KG_GenerateKeyPair failed");
 534:../src/wolfcrypt/src/rsa.c ****         return ret;
 535:../src/wolfcrypt/src/rsa.c ****     }
 536:../src/wolfcrypt/src/rsa.c **** 
 537:../src/wolfcrypt/src/rsa.c ****     ret = CRYS_RSA_Get_PubKey(&key->ctx.pubKey, ex, &eSz, n, &nSz);
 538:../src/wolfcrypt/src/rsa.c ****     if (ret != SA_SILIB_RET_OK){
 539:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("CRYS_RSA_Get_PubKey failed");
 540:../src/wolfcrypt/src/rsa.c ****         return ret;
 541:../src/wolfcrypt/src/rsa.c ****     }
 542:../src/wolfcrypt/src/rsa.c ****     ret = wc_RsaPublicKeyDecodeRaw(n, nSz, ex, eSz, key);
 543:../src/wolfcrypt/src/rsa.c **** 
 544:../src/wolfcrypt/src/rsa.c ****     key->type = RSA_PRIVATE;
 545:../src/wolfcrypt/src/rsa.c **** 
 546:../src/wolfcrypt/src/rsa.c ****     return ret;
 547:../src/wolfcrypt/src/rsa.c **** }
 548:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_CRYPTOCELL */
 549:../src/wolfcrypt/src/rsa.c **** 
 550:../src/wolfcrypt/src/rsa.c **** int wc_FreeRsaKey(RsaKey* key)
 551:../src/wolfcrypt/src/rsa.c **** {
 651                             		.loc 2 551 1
 652 0000 7E AA                   		push.l	r10
 653                             	.LCFI35:
 654 0002 71 0A F8                		add	#-8, r0, r10
 655                             	.LCFI36:
 656 0005 EF A0                   		mov.L	r10, r0
 657 0007 E7 A1 01                		mov.L	r1, 4[r10]
 552:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 658                             		.loc 2 552 9
 659 000a F8 A6 00                		mov.L	#0, [r10]
 553:../src/wolfcrypt/src/rsa.c **** 
 554:../src/wolfcrypt/src/rsa.c ****     if (key == NULL) {
 660                             		.loc 2 554 8
 661 000d ED A5 01                		mov.L	4[r10], r5
 662 0010 61 05                   		cmp	#0, r5
 663 0012 18                      		bne	.L43
 555:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 664                             		.loc 2 555 16
 665 0013 FB 5A 53 FF             		mov.L	#-173, r5
 666 0017 38 CB 00                		bra	.L44
 667                             	.L43:
 556:../src/wolfcrypt/src/rsa.c ****     }
 557:../src/wolfcrypt/src/rsa.c **** 
 558:../src/wolfcrypt/src/rsa.c ****     wc_RsaCleanup(key);
 668                             		.loc 2 558 5
 669 001a ED A1 01                		mov.L	4[r10], r1
 670 001d 05 00 00 00             		bsr	_wc_RsaCleanup
 559:../src/wolfcrypt/src/rsa.c **** 
 560:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA)
 561:../src/wolfcrypt/src/rsa.c ****     wolfAsync_DevCtxFree(&key->asyncDev, WOLFSSL_ASYNC_MARKER_RSA);
 562:../src/wolfcrypt/src/rsa.c **** #endif
 563:../src/wolfcrypt/src/rsa.c **** 
 564:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
 565:../src/wolfcrypt/src/rsa.c ****     if (key->type == RSA_PRIVATE) {
 671                             		.loc 2 565 12
 672 0021 ED A5 01                		mov.L	4[r10], r5
 673 0024 EE 55 22 06             		mov.L	6280[r5], r5
 674                             		.loc 2 565 8
 675 0028 61 15                   		cmp	#1, r5
 676 002a 21 52                   		bne	.L45
 566:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
 567:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(&key->u);
 677                             		.loc 2 567 22
 678 002c ED A5 01                		mov.L	4[r10], r5
 679 002f 72 55 70 15             		add	#0x1570, r5
 680                             		.loc 2 567 9
 681 0033 EF 51                   		mov.L	r5, r1
 682 0035 05 00 00 00             		bsr	_sp_forcezero
 568:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(&key->dQ);
 683                             		.loc 2 568 22
 684 0039 ED A5 01                		mov.L	4[r10], r5
 685 003c 72 55 60 12             		add	#0x1260, r5
 686                             		.loc 2 568 9
 687 0040 EF 51                   		mov.L	r5, r1
 688 0042 05 00 00 00             		bsr	_sp_forcezero
 569:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(&key->dP);
 689                             		.loc 2 569 22
 690 0046 ED A5 01                		mov.L	4[r10], r5
 691 0049 72 55 50 0F             		add	#0xf50, r5
 692                             		.loc 2 569 9
 693 004d EF 51                   		mov.L	r5, r1
 694 004f 05 00 00 00             		bsr	_sp_forcezero
 570:../src/wolfcrypt/src/rsa.c **** #endif
 571:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(&key->q);
 695                             		.loc 2 571 22
 696 0053 ED A5 01                		mov.L	4[r10], r5
 697 0056 72 55 40 0C             		add	#0xc40, r5
 698                             		.loc 2 571 9
 699 005a EF 51                   		mov.L	r5, r1
 700 005c 05 00 00 00             		bsr	_sp_forcezero
 572:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(&key->p);
 701                             		.loc 2 572 22
 702 0060 ED A5 01                		mov.L	4[r10], r5
 703 0063 72 55 30 09             		add	#0x930, r5
 704                             		.loc 2 572 9
 705 0067 EF 51                   		mov.L	r5, r1
 706 0069 05 00 00 00             		bsr	_sp_forcezero
 573:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(&key->d);
 707                             		.loc 2 573 22
 708 006d ED A5 01                		mov.L	4[r10], r5
 709 0070 72 55 20 06             		add	#0x620, r5
 710                             		.loc 2 573 9
 711 0074 EF 51                   		mov.L	r5, r1
 712 0076 05 00 00 00             		bsr	_sp_forcezero
 713 007a 2E 50                   		bra	.L46
 714                             	.L45:
 574:../src/wolfcrypt/src/rsa.c ****     }
 575:../src/wolfcrypt/src/rsa.c ****     else {
 576:../src/wolfcrypt/src/rsa.c ****         /* private part */
 577:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
 578:../src/wolfcrypt/src/rsa.c ****         mp_clear(&key->u);
 715                             		.loc 2 578 18
 716 007c ED A5 01                		mov.L	4[r10], r5
 717 007f 72 55 70 15             		add	#0x1570, r5
 718                             		.loc 2 578 9
 719 0083 EF 51                   		mov.L	r5, r1
 720 0085 05 00 00 00             		bsr	_sp_clear
 579:../src/wolfcrypt/src/rsa.c ****         mp_clear(&key->dQ);
 721                             		.loc 2 579 18
 722 0089 ED A5 01                		mov.L	4[r10], r5
 723 008c 72 55 60 12             		add	#0x1260, r5
 724                             		.loc 2 579 9
 725 0090 EF 51                   		mov.L	r5, r1
 726 0092 05 00 00 00             		bsr	_sp_clear
 580:../src/wolfcrypt/src/rsa.c ****         mp_clear(&key->dP);
 727                             		.loc 2 580 18
 728 0096 ED A5 01                		mov.L	4[r10], r5
 729 0099 72 55 50 0F             		add	#0xf50, r5
 730                             		.loc 2 580 9
 731 009d EF 51                   		mov.L	r5, r1
 732 009f 05 00 00 00             		bsr	_sp_clear
 581:../src/wolfcrypt/src/rsa.c **** #endif
 582:../src/wolfcrypt/src/rsa.c ****         mp_clear(&key->q);
 733                             		.loc 2 582 18
 734 00a3 ED A5 01                		mov.L	4[r10], r5
 735 00a6 72 55 40 0C             		add	#0xc40, r5
 736                             		.loc 2 582 9
 737 00aa EF 51                   		mov.L	r5, r1
 738 00ac 05 00 00 00             		bsr	_sp_clear
 583:../src/wolfcrypt/src/rsa.c ****         mp_clear(&key->p);
 739                             		.loc 2 583 18
 740 00b0 ED A5 01                		mov.L	4[r10], r5
 741 00b3 72 55 30 09             		add	#0x930, r5
 742                             		.loc 2 583 9
 743 00b7 EF 51                   		mov.L	r5, r1
 744 00b9 05 00 00 00             		bsr	_sp_clear
 584:../src/wolfcrypt/src/rsa.c ****         mp_clear(&key->d);
 745                             		.loc 2 584 18
 746 00bd ED A5 01                		mov.L	4[r10], r5
 747 00c0 72 55 20 06             		add	#0x620, r5
 748                             		.loc 2 584 9
 749 00c4 EF 51                   		mov.L	r5, r1
 750 00c6 05 00 00 00             		bsr	_sp_clear
 751                             	.L46:
 585:../src/wolfcrypt/src/rsa.c ****     }
 586:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_RSA_PUBLIC_ONLY */
 587:../src/wolfcrypt/src/rsa.c **** 
 588:../src/wolfcrypt/src/rsa.c ****     /* public part */
 589:../src/wolfcrypt/src/rsa.c ****     mp_clear(&key->e);
 752                             		.loc 2 589 14
 753 00ca ED A5 01                		mov.L	4[r10], r5
 754 00cd 72 55 10 03             		add	#0x310, r5
 755                             		.loc 2 589 5
 756 00d1 EF 51                   		mov.L	r5, r1
 757 00d3 05 00 00 00             		bsr	_sp_clear
 590:../src/wolfcrypt/src/rsa.c ****     mp_clear(&key->n);
 758                             		.loc 2 590 14
 759 00d7 ED A5 01                		mov.L	4[r10], r5
 760                             		.loc 2 590 5
 761 00da EF 51                   		mov.L	r5, r1
 762 00dc 05 00 00 00             		bsr	_sp_clear
 591:../src/wolfcrypt/src/rsa.c **** 
 592:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_XILINX_CRYPT
 593:../src/wolfcrypt/src/rsa.c ****     XFREE(key->mod, key->heap, DYNAMIC_TYPE_KEY);
 594:../src/wolfcrypt/src/rsa.c ****     key->mod = NULL;
 595:../src/wolfcrypt/src/rsa.c **** #endif
 596:../src/wolfcrypt/src/rsa.c **** 
 597:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_AFALG_XILINX_RSA
 598:../src/wolfcrypt/src/rsa.c ****     /* make sure that sockets are closed on cleanup */
 599:../src/wolfcrypt/src/rsa.c ****     if (key->alFd > 0) {
 600:../src/wolfcrypt/src/rsa.c ****         close(key->alFd);
 601:../src/wolfcrypt/src/rsa.c ****         key->alFd = WC_SOCK_NOTSET;
 602:../src/wolfcrypt/src/rsa.c ****     }
 603:../src/wolfcrypt/src/rsa.c ****     if (key->rdFd > 0) {
 604:../src/wolfcrypt/src/rsa.c ****         close(key->rdFd);
 605:../src/wolfcrypt/src/rsa.c ****         key->rdFd = WC_SOCK_NOTSET;
 606:../src/wolfcrypt/src/rsa.c ****     }
 607:../src/wolfcrypt/src/rsa.c **** #endif
 608:../src/wolfcrypt/src/rsa.c **** 
 609:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_KCAPI_RSA
 610:../src/wolfcrypt/src/rsa.c ****     KcapiRsa_Free(key);
 611:../src/wolfcrypt/src/rsa.c **** #endif
 612:../src/wolfcrypt/src/rsa.c **** 
 613:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
 614:../src/wolfcrypt/src/rsa.c ****     wc_MemZero_Check(key, sizeof(RsaKey));
 615:../src/wolfcrypt/src/rsa.c **** #endif
 616:../src/wolfcrypt/src/rsa.c **** 
 617:../src/wolfcrypt/src/rsa.c ****     return ret;
 763                             		.loc 2 617 12
 764 00e0 EC A5                   		mov.L	[r10], r5
 765                             	.L44:
 618:../src/wolfcrypt/src/rsa.c **** }
 766                             		.loc 2 618 1
 767 00e2 EF 51                   		mov.L	r5, r1
 768 00e4 3F AA 03                		rtsd	#12, r10-r10
 769                             	.LFE46:
 771                             		.section	.text.RsaMGF1,"ax",@progbits
 773                             	_RsaMGF1:
 774                             	.LFB47:
 619:../src/wolfcrypt/src/rsa.c **** 
 620:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_RSA_KEY_CHECK
 621:../src/wolfcrypt/src/rsa.c **** /* Check the pair-wise consistency of the RSA key. */
 622:../src/wolfcrypt/src/rsa.c **** static int _ifc_pairwise_consistency_test(RsaKey* key, WC_RNG* rng)
 623:../src/wolfcrypt/src/rsa.c **** {
 624:../src/wolfcrypt/src/rsa.c ****     const char* msg = "Everyone gets Friday off.";
 625:../src/wolfcrypt/src/rsa.c ****     byte* sig;
 626:../src/wolfcrypt/src/rsa.c ****     byte* plain;
 627:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 628:../src/wolfcrypt/src/rsa.c ****     word32 msgLen, plainLen, sigLen;
 629:../src/wolfcrypt/src/rsa.c **** 
 630:../src/wolfcrypt/src/rsa.c ****     msgLen = (word32)XSTRLEN(msg);
 631:../src/wolfcrypt/src/rsa.c ****     sigLen = wc_RsaEncryptSize(key);
 632:../src/wolfcrypt/src/rsa.c **** 
 633:../src/wolfcrypt/src/rsa.c ****     WOLFSSL_MSG("Doing RSA consistency test");
 634:../src/wolfcrypt/src/rsa.c **** 
 635:../src/wolfcrypt/src/rsa.c ****     /* Sign and verify. */
 636:../src/wolfcrypt/src/rsa.c ****     sig = (byte*)XMALLOC(sigLen, key->heap, DYNAMIC_TYPE_RSA);
 637:../src/wolfcrypt/src/rsa.c ****     if (sig == NULL) {
 638:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
 639:../src/wolfcrypt/src/rsa.c ****     }
 640:../src/wolfcrypt/src/rsa.c ****     XMEMSET(sig, 0, sigLen);
 641:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
 642:../src/wolfcrypt/src/rsa.c ****     wc_MemZero_Add("Pairwise CT sig", sig, sigLen);
 643:../src/wolfcrypt/src/rsa.c **** #endif
 644:../src/wolfcrypt/src/rsa.c ****     plain = sig;
 645:../src/wolfcrypt/src/rsa.c **** 
 646:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_ASYNC_CRYPT
 647:../src/wolfcrypt/src/rsa.c ****     /* Do blocking async calls here, caller does not support WC_PENDING_E */
 648:../src/wolfcrypt/src/rsa.c ****     do {
 649:../src/wolfcrypt/src/rsa.c ****         if (ret == WC_PENDING_E)
 650:../src/wolfcrypt/src/rsa.c ****             ret = wc_AsyncWait(ret, &key->asyncDev, WC_ASYNC_FLAG_CALL_AGAIN);
 651:../src/wolfcrypt/src/rsa.c ****         if (ret >= 0)
 652:../src/wolfcrypt/src/rsa.c **** #endif
 653:../src/wolfcrypt/src/rsa.c ****             ret = wc_RsaSSL_Sign((const byte*)msg, msgLen, sig, sigLen, key, rng);
 654:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_ASYNC_CRYPT
 655:../src/wolfcrypt/src/rsa.c ****     } while (ret == WC_PENDING_E);
 656:../src/wolfcrypt/src/rsa.c **** #endif
 657:../src/wolfcrypt/src/rsa.c **** 
 658:../src/wolfcrypt/src/rsa.c ****     if (ret > 0) {
 659:../src/wolfcrypt/src/rsa.c ****         sigLen = (word32)ret;
 660:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_ASYNC_CRYPT
 661:../src/wolfcrypt/src/rsa.c ****         /* Do blocking async calls here, caller does not support WC_PENDING_E */
 662:../src/wolfcrypt/src/rsa.c ****         do {
 663:../src/wolfcrypt/src/rsa.c ****             if (ret == WC_PENDING_E)
 664:../src/wolfcrypt/src/rsa.c ****                 ret = wc_AsyncWait(ret, &key->asyncDev, WC_ASYNC_FLAG_CALL_AGAIN);
 665:../src/wolfcrypt/src/rsa.c ****             if (ret >= 0)
 666:../src/wolfcrypt/src/rsa.c **** #endif
 667:../src/wolfcrypt/src/rsa.c ****                 ret = wc_RsaSSL_VerifyInline(sig, sigLen, &plain, key);
 668:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_ASYNC_CRYPT
 669:../src/wolfcrypt/src/rsa.c ****         } while (ret == WC_PENDING_E);
 670:../src/wolfcrypt/src/rsa.c **** #endif
 671:../src/wolfcrypt/src/rsa.c ****     }
 672:../src/wolfcrypt/src/rsa.c **** 
 673:../src/wolfcrypt/src/rsa.c ****     if (ret > 0) {
 674:../src/wolfcrypt/src/rsa.c ****         plainLen = (word32)ret;
 675:../src/wolfcrypt/src/rsa.c ****         ret = (msgLen != plainLen) || (XMEMCMP(plain, msg, msgLen) != 0);
 676:../src/wolfcrypt/src/rsa.c ****     }
 677:../src/wolfcrypt/src/rsa.c **** 
 678:../src/wolfcrypt/src/rsa.c ****     if (ret != 0)
 679:../src/wolfcrypt/src/rsa.c ****         ret = RSA_KEY_PAIR_E;
 680:../src/wolfcrypt/src/rsa.c **** 
 681:../src/wolfcrypt/src/rsa.c ****     ForceZero(sig, sigLen);
 682:../src/wolfcrypt/src/rsa.c ****     XFREE(sig, key->heap, DYNAMIC_TYPE_RSA);
 683:../src/wolfcrypt/src/rsa.c **** 
 684:../src/wolfcrypt/src/rsa.c ****     return ret;
 685:../src/wolfcrypt/src/rsa.c **** }
 686:../src/wolfcrypt/src/rsa.c **** 
 687:../src/wolfcrypt/src/rsa.c **** 
 688:../src/wolfcrypt/src/rsa.c **** int wc_CheckRsaKey(RsaKey* key)
 689:../src/wolfcrypt/src/rsa.c **** {
 690:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
 691:../src/wolfcrypt/src/rsa.c ****     mp_int *tmp = NULL;
 692:../src/wolfcrypt/src/rsa.c ****     WC_RNG *rng = NULL;
 693:../src/wolfcrypt/src/rsa.c **** #else
 694:../src/wolfcrypt/src/rsa.c ****     mp_int tmp[1];
 695:../src/wolfcrypt/src/rsa.c ****     WC_RNG rng[1];
 696:../src/wolfcrypt/src/rsa.c **** #endif
 697:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 698:../src/wolfcrypt/src/rsa.c **** 
 699:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CAAM
 700:../src/wolfcrypt/src/rsa.c ****     /* can not perform these checks on an encrypted key */
 701:../src/wolfcrypt/src/rsa.c ****     if (key->blackKey != 0) {
 702:../src/wolfcrypt/src/rsa.c ****         return 0;
 703:../src/wolfcrypt/src/rsa.c ****     }
 704:../src/wolfcrypt/src/rsa.c **** #endif
 705:../src/wolfcrypt/src/rsa.c **** 
 706:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
 707:../src/wolfcrypt/src/rsa.c ****     rng = (WC_RNG*)XMALLOC(sizeof(WC_RNG), NULL, DYNAMIC_TYPE_RNG);
 708:../src/wolfcrypt/src/rsa.c ****     if (rng != NULL)
 709:../src/wolfcrypt/src/rsa.c ****         tmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_RSA);
 710:../src/wolfcrypt/src/rsa.c ****     if (rng == NULL || tmp == NULL) {
 711:../src/wolfcrypt/src/rsa.c ****         XFREE(rng, NULL, DYNAMIC_TYPE_RNG);
 712:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp, NULL, DYNAMIC_TYPE_RSA);
 713:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
 714:../src/wolfcrypt/src/rsa.c ****     }
 715:../src/wolfcrypt/src/rsa.c **** #endif
 716:../src/wolfcrypt/src/rsa.c **** 
 717:../src/wolfcrypt/src/rsa.c ****     ret = wc_InitRng(rng);
 718:../src/wolfcrypt/src/rsa.c **** 
 719:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 720:../src/wolfcrypt/src/rsa.c ****         SAVE_VECTOR_REGISTERS(ret = _svr_ret;);
 721:../src/wolfcrypt/src/rsa.c **** 
 722:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 723:../src/wolfcrypt/src/rsa.c ****         if (mp_init(tmp) != MP_OKAY)
 724:../src/wolfcrypt/src/rsa.c ****             ret = MP_INIT_E;
 725:../src/wolfcrypt/src/rsa.c ****     }
 726:../src/wolfcrypt/src/rsa.c **** 
 727:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 728:../src/wolfcrypt/src/rsa.c ****         if (key == NULL)
 729:../src/wolfcrypt/src/rsa.c ****             ret = BAD_FUNC_ARG;
 730:../src/wolfcrypt/src/rsa.c ****     }
 731:../src/wolfcrypt/src/rsa.c **** 
 732:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 733:../src/wolfcrypt/src/rsa.c ****         ret = _ifc_pairwise_consistency_test(key, rng);
 734:../src/wolfcrypt/src/rsa.c **** 
 735:../src/wolfcrypt/src/rsa.c ****     /* Check d is less than n. */
 736:../src/wolfcrypt/src/rsa.c ****     if (ret == 0 ) {
 737:../src/wolfcrypt/src/rsa.c ****         if (mp_cmp(&key->d, &key->n) != MP_LT) {
 738:../src/wolfcrypt/src/rsa.c ****             ret = MP_EXPTMOD_E;
 739:../src/wolfcrypt/src/rsa.c ****         }
 740:../src/wolfcrypt/src/rsa.c ****     }
 741:../src/wolfcrypt/src/rsa.c ****     /* Check p*q = n. */
 742:../src/wolfcrypt/src/rsa.c ****     if (ret == 0 ) {
 743:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_CHECK_MEM_ZERO
 744:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("RSA CheckKey tmp", tmp);
 745:../src/wolfcrypt/src/rsa.c ****     #endif
 746:../src/wolfcrypt/src/rsa.c ****         if (mp_mul(&key->p, &key->q, tmp) != MP_OKAY) {
 747:../src/wolfcrypt/src/rsa.c ****             ret = MP_EXPTMOD_E;
 748:../src/wolfcrypt/src/rsa.c ****         }
 749:../src/wolfcrypt/src/rsa.c ****     }
 750:../src/wolfcrypt/src/rsa.c ****     if (ret == 0 ) {
 751:../src/wolfcrypt/src/rsa.c ****         if (mp_cmp(&key->n, tmp) != MP_EQ) {
 752:../src/wolfcrypt/src/rsa.c ****             ret = MP_EXPTMOD_E;
 753:../src/wolfcrypt/src/rsa.c ****         }
 754:../src/wolfcrypt/src/rsa.c ****     }
 755:../src/wolfcrypt/src/rsa.c **** 
 756:../src/wolfcrypt/src/rsa.c **** #ifndef WC_RSA_NO_FERMAT_CHECK
 757:../src/wolfcrypt/src/rsa.c ****     /* Fermat's Factorization works when difference between p and q
 758:../src/wolfcrypt/src/rsa.c ****      * is less than (conservatively):
 759:../src/wolfcrypt/src/rsa.c ****      *     n^(1/4) + 32
 760:../src/wolfcrypt/src/rsa.c ****      *  ~= 2^(bit count of n)^(1/4) + 32) = 2^((bit count of n)/4 + 32)
 761:../src/wolfcrypt/src/rsa.c ****      */
 762:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 763:../src/wolfcrypt/src/rsa.c ****         ret = mp_sub(&key->p, &key->q, tmp);
 764:../src/wolfcrypt/src/rsa.c ****     }
 765:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 766:../src/wolfcrypt/src/rsa.c ****         if (mp_count_bits(tmp) <= (mp_count_bits(&key->n) / 4 + 32)) {
 767:../src/wolfcrypt/src/rsa.c ****             ret = MP_EXPTMOD_E;
 768:../src/wolfcrypt/src/rsa.c ****         }
 769:../src/wolfcrypt/src/rsa.c ****     }
 770:../src/wolfcrypt/src/rsa.c **** #endif
 771:../src/wolfcrypt/src/rsa.c **** 
 772:../src/wolfcrypt/src/rsa.c ****     /* Check dP, dQ and u if they exist */
 773:../src/wolfcrypt/src/rsa.c ****     if (ret == 0 && !mp_iszero(&key->dP)) {
 774:../src/wolfcrypt/src/rsa.c ****         if (mp_sub_d(&key->p, 1, tmp) != MP_OKAY) {
 775:../src/wolfcrypt/src/rsa.c ****             ret = MP_EXPTMOD_E;
 776:../src/wolfcrypt/src/rsa.c ****         }
 777:../src/wolfcrypt/src/rsa.c ****         /* Check dP <= p-1. */
 778:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 779:../src/wolfcrypt/src/rsa.c ****             if (mp_cmp(&key->dP, tmp) != MP_LT) {
 780:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 781:../src/wolfcrypt/src/rsa.c ****             }
 782:../src/wolfcrypt/src/rsa.c ****         }
 783:../src/wolfcrypt/src/rsa.c ****         /* Check e*dP mod p-1 = 1. (dP = 1/e mod p-1) */
 784:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 785:../src/wolfcrypt/src/rsa.c ****             if (mp_mulmod(&key->dP, &key->e, tmp, tmp) != MP_OKAY) {
 786:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 787:../src/wolfcrypt/src/rsa.c ****             }
 788:../src/wolfcrypt/src/rsa.c ****         }
 789:../src/wolfcrypt/src/rsa.c ****         if (ret == 0 ) {
 790:../src/wolfcrypt/src/rsa.c ****             if (!mp_isone(tmp)) {
 791:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 792:../src/wolfcrypt/src/rsa.c ****             }
 793:../src/wolfcrypt/src/rsa.c ****         }
 794:../src/wolfcrypt/src/rsa.c **** 
 795:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 796:../src/wolfcrypt/src/rsa.c ****             if (mp_sub_d(&key->q, 1, tmp) != MP_OKAY) {
 797:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 798:../src/wolfcrypt/src/rsa.c ****             }
 799:../src/wolfcrypt/src/rsa.c ****         }
 800:../src/wolfcrypt/src/rsa.c ****         /* Check dQ <= q-1. */
 801:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 802:../src/wolfcrypt/src/rsa.c ****             if (mp_cmp(&key->dQ, tmp) != MP_LT) {
 803:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 804:../src/wolfcrypt/src/rsa.c ****             }
 805:../src/wolfcrypt/src/rsa.c ****         }
 806:../src/wolfcrypt/src/rsa.c ****         /* Check e*dP mod p-1 = 1. (dQ = 1/e mod q-1) */
 807:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 808:../src/wolfcrypt/src/rsa.c ****             if (mp_mulmod(&key->dQ, &key->e, tmp, tmp) != MP_OKAY) {
 809:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 810:../src/wolfcrypt/src/rsa.c ****             }
 811:../src/wolfcrypt/src/rsa.c ****         }
 812:../src/wolfcrypt/src/rsa.c ****         if (ret == 0 ) {
 813:../src/wolfcrypt/src/rsa.c ****             if (!mp_isone(tmp)) {
 814:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 815:../src/wolfcrypt/src/rsa.c ****             }
 816:../src/wolfcrypt/src/rsa.c ****         }
 817:../src/wolfcrypt/src/rsa.c **** 
 818:../src/wolfcrypt/src/rsa.c ****         /* Check u <= p. */
 819:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 820:../src/wolfcrypt/src/rsa.c ****             if (mp_cmp(&key->u, &key->p) != MP_LT) {
 821:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 822:../src/wolfcrypt/src/rsa.c ****             }
 823:../src/wolfcrypt/src/rsa.c ****         }
 824:../src/wolfcrypt/src/rsa.c ****         /* Check u*q mod p = 1. (u = 1/q mod p) */
 825:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 826:../src/wolfcrypt/src/rsa.c ****             if (mp_mulmod(&key->u, &key->q, &key->p, tmp) != MP_OKAY) {
 827:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 828:../src/wolfcrypt/src/rsa.c ****             }
 829:../src/wolfcrypt/src/rsa.c ****         }
 830:../src/wolfcrypt/src/rsa.c ****         if (ret == 0 ) {
 831:../src/wolfcrypt/src/rsa.c ****             if (!mp_isone(tmp)) {
 832:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 833:../src/wolfcrypt/src/rsa.c ****             }
 834:../src/wolfcrypt/src/rsa.c ****         }
 835:../src/wolfcrypt/src/rsa.c ****     }
 836:../src/wolfcrypt/src/rsa.c **** 
 837:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(tmp);
 838:../src/wolfcrypt/src/rsa.c **** 
 839:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
 840:../src/wolfcrypt/src/rsa.c **** 
 841:../src/wolfcrypt/src/rsa.c ****     wc_FreeRng(rng);
 842:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
 843:../src/wolfcrypt/src/rsa.c ****     XFREE(tmp, NULL, DYNAMIC_TYPE_RSA);
 844:../src/wolfcrypt/src/rsa.c ****     XFREE(rng, NULL, DYNAMIC_TYPE_RNG);
 845:../src/wolfcrypt/src/rsa.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
 846:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(tmp);
 847:../src/wolfcrypt/src/rsa.c **** #endif
 848:../src/wolfcrypt/src/rsa.c **** 
 849:../src/wolfcrypt/src/rsa.c ****     return ret;
 850:../src/wolfcrypt/src/rsa.c **** }
 851:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_RSA_KEY_CHECK */
 852:../src/wolfcrypt/src/rsa.c **** 
 853:../src/wolfcrypt/src/rsa.c **** 
 854:../src/wolfcrypt/src/rsa.c **** #if !defined(WC_NO_RSA_OAEP) || defined(WC_RSA_PSS)
 855:../src/wolfcrypt/src/rsa.c **** /* Uses MGF1 standard as a mask generation function
 856:../src/wolfcrypt/src/rsa.c ****    hType: hash type used
 857:../src/wolfcrypt/src/rsa.c ****    seed:  seed to use for generating mask
 858:../src/wolfcrypt/src/rsa.c ****    seedSz: size of seed buffer
 859:../src/wolfcrypt/src/rsa.c ****    out:   mask output after generation
 860:../src/wolfcrypt/src/rsa.c ****    outSz: size of output buffer
 861:../src/wolfcrypt/src/rsa.c ****  */
 862:../src/wolfcrypt/src/rsa.c **** #if !defined(NO_SHA) || !defined(NO_SHA256) || defined(WOLFSSL_SHA384) || defined(WOLFSSL_SHA512)
 863:../src/wolfcrypt/src/rsa.c **** static int RsaMGF1(enum wc_HashType hType, byte* seed, word32 seedSz,
 864:../src/wolfcrypt/src/rsa.c ****                                         byte* out, word32 outSz, void* heap)
 865:../src/wolfcrypt/src/rsa.c **** {
 775                             		.loc 2 865 1
 776 0000 7E AA                   		push.l	r10
 777                             	.LCFI37:
 778 0002 7E A6                   		push.l	r6
 779                             	.LCFI38:
 780 0004 72 0A 7C FF             		add	#-132, r0, r10
 781                             	.LCFI39:
 782 0008 71 A0 FC                		add	#-4, r10, r0
 783                             	.LCFI40:
 784 000b 75 46 90                		mov.L	#0x90, r6
 785 000e 4B A6                   		add	r10, r6
 786 0010 E7 A1 1B                		mov.L	r1, 108[r10]
 787 0013 E7 A2 1C                		mov.L	r2, 112[r10]
 788 0016 E7 A3 1D                		mov.L	r3, 116[r10]
 789 0019 E7 A4 1E                		mov.L	r4, 120[r10]
 866:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
 867:../src/wolfcrypt/src/rsa.c ****     byte* tmp = NULL;
 790                             		.loc 2 867 11
 791 001c F8 A6 00                		mov.L	#0, [r10]
 868:../src/wolfcrypt/src/rsa.c ****     byte   tmpF = 0;     /* 1 if dynamic memory needs freed */
 792                             		.loc 2 868 12
 793 001f F9 A4 04 00             		mov.B	#0, 4[r10]
 869:../src/wolfcrypt/src/rsa.c **** #else
 870:../src/wolfcrypt/src/rsa.c ****     byte tmp[RSA_MAX_SIZE/8];
 871:../src/wolfcrypt/src/rsa.c **** #endif
 872:../src/wolfcrypt/src/rsa.c ****     /* needs to be large enough for seed size plus counter(4) */
 873:../src/wolfcrypt/src/rsa.c ****     byte  tmpA[WC_MAX_DIGEST_SIZE + 4];
 874:../src/wolfcrypt/src/rsa.c ****     word32 tmpSz = 0;
 794                             		.loc 2 874 12
 795 0023 F9 A6 02 00             		mov.L	#0, 8[r10]
 875:../src/wolfcrypt/src/rsa.c ****     int hLen;
 876:../src/wolfcrypt/src/rsa.c ****     int ret;
 877:../src/wolfcrypt/src/rsa.c ****     word32 counter;
 878:../src/wolfcrypt/src/rsa.c ****     word32 idx;
 879:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
 880:../src/wolfcrypt/src/rsa.c ****     wc_HashAlg *hash;
 881:../src/wolfcrypt/src/rsa.c **** #endif
 882:../src/wolfcrypt/src/rsa.c ****     hLen    = wc_HashGetDigestSize(hType);
 796                             		.loc 2 882 15
 797 0027 ED A1 1B                		mov.L	108[r10], r1
 798 002a 05 00 00 00             		bsr	_wc_HashGetDigestSize
 799 002e E7 A1 06                		mov.L	r1, 24[r10]
 883:../src/wolfcrypt/src/rsa.c ****     counter = 0;
 800                             		.loc 2 883 13
 801 0031 F9 A6 03 00             		mov.L	#0, 12[r10]
 884:../src/wolfcrypt/src/rsa.c ****     idx     = 0;
 802                             		.loc 2 884 13
 803 0035 F9 A6 04 00             		mov.L	#0, 16[r10]
 885:../src/wolfcrypt/src/rsa.c **** 
 886:../src/wolfcrypt/src/rsa.c ****     (void)heap;
 887:../src/wolfcrypt/src/rsa.c **** 
 888:../src/wolfcrypt/src/rsa.c ****     XMEMSET(tmpA, 0, sizeof(tmpA));
 804                             		.loc 2 888 5
 805 0039 71 A5 28                		add	#40, r10, r5
 806 003c 75 43 44                		mov.L	#0x44, r3
 807 003f 66 02                   		mov.L	#0, r2
 808 0041 EF 51                   		mov.L	r5, r1
 809 0043 05 00 00 00             		bsr	_memset
 889:../src/wolfcrypt/src/rsa.c ****     /* check error return of wc_HashGetDigestSize */
 890:../src/wolfcrypt/src/rsa.c ****     if (hLen < 0) {
 810                             		.loc 2 890 8
 811 0047 ED A5 06                		mov.L	24[r10], r5
 812 004a 61 05                   		cmp	#0, r5
 813 004c 28 08                   		bge	.L48
 891:../src/wolfcrypt/src/rsa.c ****         return hLen;
 814                             		.loc 2 891 16
 815 004e ED A5 06                		mov.L	24[r10], r5
 816 0051 38 47 01                		bra	.L61
 817                             	.L48:
 892:../src/wolfcrypt/src/rsa.c ****     }
 893:../src/wolfcrypt/src/rsa.c **** 
 894:../src/wolfcrypt/src/rsa.c ****     /* if tmp is not large enough than use some dynamic memory */
 895:../src/wolfcrypt/src/rsa.c ****     if ((seedSz + 4) > sizeof(tmpA) || (word32)hLen > sizeof(tmpA)) {
 818                             		.loc 2 895 17
 819 0054 ED A5 1D                		mov.L	116[r10], r5
 820 0057 62 45                   		add	#4, r5
 821                             		.loc 2 895 8
 822 0059 75 55 44                		cmp	#0x44, r5
 823 005c 24 0A                   		bgtu	.L50
 824                             		.loc 2 895 40 discriminator 1
 825 005e ED A5 06                		mov.L	24[r10], r5
 826                             		.loc 2 895 37 discriminator 1
 827 0061 75 55 44                		cmp	#0x44, r5
 828 0064 25 2D                   		bleu	.L51
 829                             	.L50:
 896:../src/wolfcrypt/src/rsa.c ****         /* find largest amount of memory needed which will be the max of
 897:../src/wolfcrypt/src/rsa.c ****          * hLen and (seedSz + 4) since tmp is used to store the hash digest */
 898:../src/wolfcrypt/src/rsa.c ****         tmpSz = ((seedSz + 4) > (word32)hLen)? seedSz + 4: (word32)hLen;
 830                             		.loc 2 898 26
 831 0066 ED A5 1D                		mov.L	116[r10], r5
 832 0069 62 45                   		add	#4, r5
 833                             		.loc 2 898 33
 834 006b ED A4 06                		mov.L	24[r10], r4
 835                             		.loc 2 898 15
 836 006e 47 45                   		cmp	r4, r5
 837 0070 22 04                   		bgeu 1f
 838 0072 EF 45                   		mov r4, r5
 839                             	1:
 840 0074 E7 A5 02                		mov.L	r5, 8[r10]
 899:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
 900:../src/wolfcrypt/src/rsa.c ****         tmp = (byte*)XMALLOC(tmpSz, heap, DYNAMIC_TYPE_RSA_BUFFER);
 841                             		.loc 2 900 22
 842 0077 ED A1 02                		mov.L	8[r10], r1
 843 007a 05 00 00 00             		bsr	_wolfSSL_Malloc
 844 007e E3 A1                   		mov.L	r1, [r10]
 901:../src/wolfcrypt/src/rsa.c ****         if (tmp == NULL) {
 845                             		.loc 2 901 12
 846 0080 EC A5                   		mov.L	[r10], r5
 847 0082 61 05                   		cmp	#0, r5
 848 0084 1F                      		bne	.L52
 902:../src/wolfcrypt/src/rsa.c ****             return MEMORY_E;
 849                             		.loc 2 902 20
 850 0085 FB 56 83                		mov.L	#-125, r5
 851 0088 38 10 01                		bra	.L61
 852                             	.L52:
 903:../src/wolfcrypt/src/rsa.c ****         }
 904:../src/wolfcrypt/src/rsa.c ****         tmpF = 1; /* make sure to free memory when done */
 853                             		.loc 2 904 14
 854 008b F9 A4 04 01             		mov.B	#1, 4[r10]
 855 008f 2E 0F                   		bra	.L59
 856                             	.L51:
 905:../src/wolfcrypt/src/rsa.c **** #else
 906:../src/wolfcrypt/src/rsa.c ****         if (tmpSz > RSA_MAX_SIZE/8)
 907:../src/wolfcrypt/src/rsa.c ****             return BAD_FUNC_ARG;
 908:../src/wolfcrypt/src/rsa.c **** #endif
 909:../src/wolfcrypt/src/rsa.c ****     }
 910:../src/wolfcrypt/src/rsa.c ****     else {
 911:../src/wolfcrypt/src/rsa.c ****         /* use array on the stack */
 912:../src/wolfcrypt/src/rsa.c ****     #ifndef WOLFSSL_SMALL_STACK_CACHE
 913:../src/wolfcrypt/src/rsa.c ****         tmpSz = sizeof(tmpA);
 857                             		.loc 2 913 15
 858 0091 F9 A6 02 44             		mov.L	#0x44, 8[r10]
 914:../src/wolfcrypt/src/rsa.c ****     #endif
 915:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
 916:../src/wolfcrypt/src/rsa.c ****         tmp  = tmpA;
 859                             		.loc 2 916 14
 860 0095 71 A5 28                		add	#40, r10, r5
 861 0098 E3 A5                   		mov.L	r5, [r10]
 917:../src/wolfcrypt/src/rsa.c ****         tmpF = 0; /* no need to free memory at end */
 862                             		.loc 2 917 14
 863 009a F9 A4 04 00             		mov.B	#0, 4[r10]
 864                             	.L59:
 865                             	.LBB3:
 918:../src/wolfcrypt/src/rsa.c **** #endif
 919:../src/wolfcrypt/src/rsa.c ****     }
 920:../src/wolfcrypt/src/rsa.c **** 
 921:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
 922:../src/wolfcrypt/src/rsa.c ****     hash = (wc_HashAlg*)XMALLOC(sizeof(*hash), heap, DYNAMIC_TYPE_DIGEST);
 923:../src/wolfcrypt/src/rsa.c ****     if (hash == NULL) {
 924:../src/wolfcrypt/src/rsa.c ****     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
 925:../src/wolfcrypt/src/rsa.c ****         if (tmpF) {
 926:../src/wolfcrypt/src/rsa.c ****             XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 927:../src/wolfcrypt/src/rsa.c ****         }
 928:../src/wolfcrypt/src/rsa.c ****     #endif
 929:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
 930:../src/wolfcrypt/src/rsa.c ****     }
 931:../src/wolfcrypt/src/rsa.c ****     ret = wc_HashInit_ex(hash, hType, heap, INVALID_DEVID);
 932:../src/wolfcrypt/src/rsa.c ****     if (ret != 0) {
 933:../src/wolfcrypt/src/rsa.c ****         XFREE(hash, heap, DYNAMIC_TYPE_DIGEST);
 934:../src/wolfcrypt/src/rsa.c ****     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
 935:../src/wolfcrypt/src/rsa.c ****         if (tmpF) {
 936:../src/wolfcrypt/src/rsa.c ****             XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 937:../src/wolfcrypt/src/rsa.c ****         }
 938:../src/wolfcrypt/src/rsa.c ****     #endif
 939:../src/wolfcrypt/src/rsa.c ****         return ret;
 940:../src/wolfcrypt/src/rsa.c ****     }
 941:../src/wolfcrypt/src/rsa.c **** #endif
 942:../src/wolfcrypt/src/rsa.c **** 
 943:../src/wolfcrypt/src/rsa.c ****     do {
 944:../src/wolfcrypt/src/rsa.c ****         int i = 0;
 866                             		.loc 2 944 13
 867 009e F9 A6 05 00             		mov.L	#0, 20[r10]
 945:../src/wolfcrypt/src/rsa.c ****         XMEMCPY(tmp, seed, seedSz);
 868                             		.loc 2 945 9
 869 00a2 ED A3 1D                		mov.L	116[r10], r3
 870 00a5 ED A2 1C                		mov.L	112[r10], r2
 871 00a8 EC A1                   		mov.L	[r10], r1
 872 00aa 05 00 00 00             		bsr	_memcpy
 946:../src/wolfcrypt/src/rsa.c **** 
 947:../src/wolfcrypt/src/rsa.c ****         /* counter to byte array appended to tmp */
 948:../src/wolfcrypt/src/rsa.c ****         tmp[seedSz]     = (byte)((counter >> 24) & 0xFF);
 873                             		.loc 2 948 43
 874 00ae ED A5 03                		mov.L	12[r10], r5
 875 00b1 FD 98 54                		shlr	#24, r5, r4
 876                             		.loc 2 948 12
 877 00b4 EC A5                   		mov.L	[r10], r5
 878 00b6 06 89 A5 1D             		add	116[r10].L, r5
 879                             		.loc 2 948 25
 880 00ba C3 54                   		mov.B	r4, [r5]
 949:../src/wolfcrypt/src/rsa.c ****         tmp[seedSz + 1] = (byte)((counter >> 16) & 0xFF);
 881                             		.loc 2 949 43
 882 00bc ED A5 03                		mov.L	12[r10], r5
 883 00bf FD 90 53                		shlr	#16, r5, r3
 884                             		.loc 2 949 12
 885 00c2 ED A5 1D                		mov.L	116[r10], r5
 886 00c5 62 15                   		add	#1, r5
 887 00c7 EC A4                   		mov.L	[r10], r4
 888 00c9 4B 45                   		add	r4, r5
 889                             		.loc 2 949 27
 890 00cb CF 34                   		mov.B	r3, r4
 891                             		.loc 2 949 25
 892 00cd C3 54                   		mov.B	r4, [r5]
 950:../src/wolfcrypt/src/rsa.c ****         tmp[seedSz + 2] = (byte)((counter >>  8) & 0xFF);
 893                             		.loc 2 950 43
 894 00cf ED A5 03                		mov.L	12[r10], r5
 895 00d2 FD 88 53                		shlr	#8, r5, r3
 896                             		.loc 2 950 12
 897 00d5 ED A5 1D                		mov.L	116[r10], r5
 898 00d8 62 25                   		add	#2, r5
 899 00da EC A4                   		mov.L	[r10], r4
 900 00dc 4B 45                   		add	r4, r5
 901                             		.loc 2 950 27
 902 00de CF 34                   		mov.B	r3, r4
 903                             		.loc 2 950 25
 904 00e0 C3 54                   		mov.B	r4, [r5]
 951:../src/wolfcrypt/src/rsa.c ****         tmp[seedSz + 3] = (byte)((counter)       & 0xFF);
 905                             		.loc 2 951 12
 906 00e2 ED A5 1D                		mov.L	116[r10], r5
 907 00e5 62 35                   		add	#3, r5
 908 00e7 EC A4                   		mov.L	[r10], r4
 909 00e9 4B 45                   		add	r4, r5
 910                             		.loc 2 951 27
 911 00eb ED A4 03                		mov.L	12[r10], r4
 912                             		.loc 2 951 25
 913 00ee C3 54                   		mov.B	r4, [r5]
 952:../src/wolfcrypt/src/rsa.c **** 
 953:../src/wolfcrypt/src/rsa.c ****         /* hash and append to existing output */
 954:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
 955:../src/wolfcrypt/src/rsa.c ****         ret = wc_HashUpdate(hash, hType, tmp, (seedSz + 4));
 956:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 957:../src/wolfcrypt/src/rsa.c ****             ret = wc_HashFinal(hash, hType, tmp);
 958:../src/wolfcrypt/src/rsa.c ****         }
 959:../src/wolfcrypt/src/rsa.c **** #else
 960:../src/wolfcrypt/src/rsa.c ****         ret = wc_Hash(hType, tmp, (seedSz + 4), tmp, tmpSz);
 914                             		.loc 2 960 15
 915 00f0 ED A5 1D                		mov.L	116[r10], r5
 916 00f3 62 45                   		add	#4, r5
 917 00f5 ED A4 02                		mov.L	8[r10], r4
 918 00f8 E3 04                   		mov.L	r4, [r0]
 919 00fa EC A4                   		mov.L	[r10], r4
 920 00fc EF 53                   		mov.L	r5, r3
 921 00fe EC A2                   		mov.L	[r10], r2
 922 0100 ED A1 1B                		mov.L	108[r10], r1
 923 0103 05 00 00 00             		bsr	_wc_Hash
 924 0107 E7 A1 07                		mov.L	r1, 28[r10]
 961:../src/wolfcrypt/src/rsa.c **** #endif
 962:../src/wolfcrypt/src/rsa.c ****         if (ret != 0) {
 925                             		.loc 2 962 12
 926 010a ED A5 07                		mov.L	28[r10], r5
 927 010d 61 05                   		cmp	#0, r5
 928 010f 20 20                   		beq	.L54
 963:../src/wolfcrypt/src/rsa.c ****             /* check for if dynamic memory was needed, then free */
 964:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
 965:../src/wolfcrypt/src/rsa.c ****             if (tmpF) {
 929                             		.loc 2 965 16
 930 0111 59 A5 04                		movu.B	4[r10], r5
 931 0114 61 05                   		cmp	#0, r5
 932 0116 20 14                   		beq	.L55
 933                             	.LBB4:
 966:../src/wolfcrypt/src/rsa.c ****                 XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 934                             		.loc 2 966 17
 935 0118 EC A5                   		mov.L	[r10], r5
 936 011a E7 A5 08                		mov.L	r5, 32[r10]
 937 011d ED A5 08                		mov.L	32[r10], r5
 938 0120 61 05                   		cmp	#0, r5
 939 0122 10                      		beq	.L55
 940                             		.loc 2 966 17 is_stmt 0 discriminator 1
 941 0123 ED A1 08                		mov.L	32[r10], r1
 942 0126 05 00 00 00             		bsr	_wolfSSL_Free
 943                             	.L55:
 944                             	.LBE4:
 967:../src/wolfcrypt/src/rsa.c ****             }
 968:../src/wolfcrypt/src/rsa.c **** #endif
 969:../src/wolfcrypt/src/rsa.c ****             return ret;
 945                             		.loc 2 969 20 is_stmt 1
 946 012a ED A5 07                		mov.L	28[r10], r5
 947 012d 2E 6B                   		bra	.L61
 948                             	.L54:
 970:../src/wolfcrypt/src/rsa.c ****         }
 971:../src/wolfcrypt/src/rsa.c **** 
 972:../src/wolfcrypt/src/rsa.c ****         for (i = 0; i < hLen && idx < outSz; i++) {
 949                             		.loc 2 972 16
 950 012f F9 A6 05 00             		mov.L	#0, 20[r10]
 951                             		.loc 2 972 9
 952 0133 2E 23                   		bra	.L56
 953                             	.L58:
 973:../src/wolfcrypt/src/rsa.c ****             out[idx++] = tmp[i];
 954                             		.loc 2 973 29 discriminator 4
 955 0135 ED A5 05                		mov.L	20[r10], r5
 956 0138 EC A4                   		mov.L	[r10], r4
 957 013a 4B 54                   		add	r5, r4
 958                             		.loc 2 973 20 discriminator 4
 959 013c ED A5 04                		mov.L	16[r10], r5
 960 013f 71 53 01                		add	#1, r5, r3
 961 0142 E7 A3 04                		mov.L	r3, 16[r10]
 962                             		.loc 2 973 16 discriminator 4
 963 0145 ED A3 1E                		mov.L	120[r10], r3
 964 0148 4B 35                   		add	r3, r5
 965                             		.loc 2 973 29 discriminator 4
 966 014a CC 44                   		mov.B	[r4], r4
 967                             		.loc 2 973 24 discriminator 4
 968 014c C3 54                   		mov.B	r4, [r5]
 972:../src/wolfcrypt/src/rsa.c ****             out[idx++] = tmp[i];
 969                             		.loc 2 972 47 discriminator 4
 970 014e ED A5 05                		mov.L	20[r10], r5
 971 0151 62 15                   		add	#1, r5
 972 0153 E7 A5 05                		mov.L	r5, 20[r10]
 973                             	.L56:
 972:../src/wolfcrypt/src/rsa.c ****             out[idx++] = tmp[i];
 974                             		.loc 2 972 9 discriminator 1
 975 0156 ED A4 05                		mov.L	20[r10], r4
 976 0159 ED A5 06                		mov.L	24[r10], r5
 977 015c 47 54                   		cmp	r5, r4
 978 015e 28 0B                   		bge	.L57
 972:../src/wolfcrypt/src/rsa.c ****             out[idx++] = tmp[i];
 979                             		.loc 2 972 30 discriminator 3
 980 0160 ED A4 04                		mov.L	16[r10], r4
 981 0163 EC 65                   		mov.L	[r6], r5
 982 0165 47 54                   		cmp	r5, r4
 983 0167 23 CE                   		bltu	.L58
 984                             	.L57:
 974:../src/wolfcrypt/src/rsa.c ****         }
 975:../src/wolfcrypt/src/rsa.c ****         counter++;
 985                             		.loc 2 975 16
 986 0169 ED A5 03                		mov.L	12[r10], r5
 987 016c 62 15                   		add	#1, r5
 988 016e E7 A5 03                		mov.L	r5, 12[r10]
 989                             	.LBE3:
 976:../src/wolfcrypt/src/rsa.c ****     } while (idx < outSz);
 990                             		.loc 2 976 5
 991 0171 ED A4 04                		mov.L	16[r10], r4
 992 0174 EC 65                   		mov.L	[r6], r5
 993 0176 47 54                   		cmp	r5, r4
 994 0178 22 05 38 24 FF          		bltu	.L59
 977:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
 978:../src/wolfcrypt/src/rsa.c ****     /* check for if dynamic memory was needed, then free */
 979:../src/wolfcrypt/src/rsa.c ****     if (tmpF) {
 995                             		.loc 2 979 8
 996 017d 59 A5 04                		movu.B	4[r10], r5
 997 0180 61 05                   		cmp	#0, r5
 998 0182 20 14                   		beq	.L60
 999                             	.LBB5:
 980:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1000                             		.loc 2 980 9
 1001 0184 EC A5                   		mov.L	[r10], r5
 1002 0186 E7 A5 09                		mov.L	r5, 36[r10]
 1003 0189 ED A5 09                		mov.L	36[r10], r5
 1004 018c 61 05                   		cmp	#0, r5
 1005 018e 10                      		beq	.L60
 1006                             		.loc 2 980 9 is_stmt 0 discriminator 1
 1007 018f ED A1 09                		mov.L	36[r10], r1
 1008 0192 05 00 00 00             		bsr	_wolfSSL_Free
 1009                             	.L60:
 1010                             	.LBE5:
 981:../src/wolfcrypt/src/rsa.c ****     }
 982:../src/wolfcrypt/src/rsa.c **** #endif
 983:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
 984:../src/wolfcrypt/src/rsa.c ****     wc_HashFree(hash, hType);
 985:../src/wolfcrypt/src/rsa.c ****     XFREE(hash, heap, DYNAMIC_TYPE_DIGEST);
 986:../src/wolfcrypt/src/rsa.c **** #endif
 987:../src/wolfcrypt/src/rsa.c **** 
 988:../src/wolfcrypt/src/rsa.c ****     return 0;
 1011                             		.loc 2 988 12 is_stmt 1
 1012 0196 66 05                   		mov.L	#0, r5
 1013                             		.balign 8,3,1
 1014                             	.L61:
 989:../src/wolfcrypt/src/rsa.c **** }
 1015                             		.loc 2 989 1 discriminator 1
 1016 0198 EF 51                   		mov.L	r5, r1
 1017 019a 72 00 88 00             		add	#0x88, r0
 1018 019e 7E B6                   		pop	r6
 1019 01a0 7E BA                   		pop	r10
 1020 01a2 02                      		rts
 1021                             	.LFE47:
 1023 01a3 77 10 01 00 00          		.section C,"a",@progbits
 1024                             		.p2align 2
 1025                             	.LC0:
 1026 0000 55 6E 6B 6E 6F 77 6E 20 		.string	"Unknown MGF type: check build options"
 1026      4D 47 46 20 74 79 70 65 
 1026      3A 20 63 68 65 63 6B 20 
 1026      62 75 69 6C 64 20 6F 70 
 1026      74 69 6F 6E 73 00 
 1027                             		.section	.text.RsaMGF,"ax",@progbits
 1029                             	_RsaMGF:
 1030                             	.LFB48:
 990:../src/wolfcrypt/src/rsa.c **** #endif /* SHA2 Hashes */
 991:../src/wolfcrypt/src/rsa.c **** 
 992:../src/wolfcrypt/src/rsa.c **** /* helper function to direct which mask generation function is used
 993:../src/wolfcrypt/src/rsa.c ****    switched on type input
 994:../src/wolfcrypt/src/rsa.c ****  */
 995:../src/wolfcrypt/src/rsa.c **** static int RsaMGF(int type, byte* seed, word32 seedSz, byte* out,
 996:../src/wolfcrypt/src/rsa.c ****                                                     word32 outSz, void* heap)
 997:../src/wolfcrypt/src/rsa.c **** {
 1031                             		.loc 2 997 1
 1032 0000 7E AA                   		push.l	r10
 1033                             	.LCFI41:
 1034 0002 71 0A E4                		add	#-28, r0, r10
 1035                             	.LCFI42:
 1036 0005 71 A0 F8                		add	#-8, r10, r0
 1037                             	.LCFI43:
 1038 0008 75 45 24                		mov.L	#36, r5
 1039 000b 4B A5                   		add	r10, r5
 1040 000d E7 A1 01                		mov.L	r1, 4[r10]
 1041 0010 E7 A2 02                		mov.L	r2, 8[r10]
 1042 0013 E7 A3 03                		mov.L	r3, 12[r10]
 1043 0016 E7 A4 04                		mov.L	r4, 16[r10]
 998:../src/wolfcrypt/src/rsa.c ****     int ret;
 999:../src/wolfcrypt/src/rsa.c **** 
1000:../src/wolfcrypt/src/rsa.c ****     switch(type) {
 1044                             		.loc 2 1000 5
 1045 0019 ED A4 01                		mov.L	4[r10], r4
 1046 001c 61 34                   		cmp	#3, r4
 1047 001e 3A 87 00                		beq	.L63
 1048 0021 ED A4 01                		mov.L	4[r10], r4
 1049 0024 61 34                   		cmp	#3, r4
 1050 0026 2A 13                   		bgt	.L64
 1051 0028 ED A4 01                		mov.L	4[r10], r4
 1052 002b 61 14                   		cmp	#1, r4
 1053 002d 20 42                   		beq	.L65
 1054 002f ED A4 01                		mov.L	4[r10], r4
 1055 0032 61 24                   		cmp	#2, r4
 1056 0034 20 56                   		beq	.L66
 1057 0036 38 C2 00                		bra	.L67
 1058                             	.L64:
 1059 0039 ED A4 01                		mov.L	4[r10], r4
 1060 003c 61 64                   		cmp	#6, r4
 1061 003e 3A 9E 00                		beq	.L68
 1062 0041 ED A4 01                		mov.L	4[r10], r4
 1063 0044 75 54 1A                		cmp	#26, r4
 1064 0047 20 0C                   		beq	.L69
 1065 0049 ED A4 01                		mov.L	4[r10], r4
 1066 004c 61 54                   		cmp	#5, r4
 1067 004e 20 72                   		beq	.L70
 1068 0050 38 A8 00                		bra	.L67
 1069                             	.L69:
1001:../src/wolfcrypt/src/rsa.c ****     #ifndef NO_SHA
1002:../src/wolfcrypt/src/rsa.c ****         case WC_MGF1SHA1:
1003:../src/wolfcrypt/src/rsa.c ****             ret = RsaMGF1(WC_HASH_TYPE_SHA, seed, seedSz, out, outSz, heap);
 1070                             		.loc 2 1003 19
 1071 0053 A8 5C                   		mov.L	4[r5], r4
 1072 0055 A0 0C                   		mov.L	r4, 4[r0]
 1073 0057 EC 55                   		mov.L	[r5], r5
 1074 0059 E3 05                   		mov.L	r5, [r0]
 1075 005b ED A4 04                		mov.L	16[r10], r4
 1076 005e ED A3 03                		mov.L	12[r10], r3
 1077 0061 ED A2 02                		mov.L	8[r10], r2
 1078 0064 66 41                   		mov.L	#4, r1
 1079 0066 05 00 00 00             		bsr	_RsaMGF1
 1080 006a E3 A1                   		mov.L	r1, [r10]
1004:../src/wolfcrypt/src/rsa.c ****             break;
 1081                             		.loc 2 1004 13
 1082 006c 38 9A 00                		bra	.L71
 1083                             	.L65:
1005:../src/wolfcrypt/src/rsa.c ****     #endif
1006:../src/wolfcrypt/src/rsa.c ****     #ifndef NO_SHA256
1007:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_SHA224
1008:../src/wolfcrypt/src/rsa.c ****         case WC_MGF1SHA224:
1009:../src/wolfcrypt/src/rsa.c ****             ret = RsaMGF1(WC_HASH_TYPE_SHA224, seed, seedSz, out, outSz, heap);
1010:../src/wolfcrypt/src/rsa.c ****             break;
1011:../src/wolfcrypt/src/rsa.c ****     #endif
1012:../src/wolfcrypt/src/rsa.c ****         case WC_MGF1SHA256:
1013:../src/wolfcrypt/src/rsa.c ****             ret = RsaMGF1(WC_HASH_TYPE_SHA256, seed, seedSz, out, outSz, heap);
 1084                             		.loc 2 1013 19
 1085 006f A8 5C                   		mov.L	4[r5], r4
 1086 0071 A0 0C                   		mov.L	r4, 4[r0]
 1087 0073 EC 55                   		mov.L	[r5], r5
 1088 0075 E3 05                   		mov.L	r5, [r0]
 1089 0077 ED A4 04                		mov.L	16[r10], r4
 1090 007a ED A3 03                		mov.L	12[r10], r3
 1091 007d ED A2 02                		mov.L	8[r10], r2
 1092 0080 66 61                   		mov.L	#6, r1
 1093 0082 05 00 00 00             		bsr	_RsaMGF1
 1094 0086 E3 A1                   		mov.L	r1, [r10]
1014:../src/wolfcrypt/src/rsa.c ****             break;
 1095                             		.loc 2 1014 13
 1096 0088 2E 7E                   		bra	.L71
 1097                             	.L66:
1015:../src/wolfcrypt/src/rsa.c ****     #endif
1016:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_SHA384
1017:../src/wolfcrypt/src/rsa.c ****         case WC_MGF1SHA384:
1018:../src/wolfcrypt/src/rsa.c ****             ret = RsaMGF1(WC_HASH_TYPE_SHA384, seed, seedSz, out, outSz, heap);
 1098                             		.loc 2 1018 19
 1099 008a A8 5C                   		mov.L	4[r5], r4
 1100 008c A0 0C                   		mov.L	r4, 4[r0]
 1101 008e EC 55                   		mov.L	[r5], r5
 1102 0090 E3 05                   		mov.L	r5, [r0]
 1103 0092 ED A4 04                		mov.L	16[r10], r4
 1104 0095 ED A3 03                		mov.L	12[r10], r3
 1105 0098 ED A2 02                		mov.L	8[r10], r2
 1106 009b 66 71                   		mov.L	#7, r1
 1107 009d 05 00 00 00             		bsr	_RsaMGF1
 1108 00a1 E3 A1                   		mov.L	r1, [r10]
1019:../src/wolfcrypt/src/rsa.c ****             break;
 1109                             		.loc 2 1019 13
 1110 00a3 2E 63                   		bra	.L71
 1111                             	.L63:
1020:../src/wolfcrypt/src/rsa.c ****     #endif
1021:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_SHA512
1022:../src/wolfcrypt/src/rsa.c ****         case WC_MGF1SHA512:
1023:../src/wolfcrypt/src/rsa.c ****             ret = RsaMGF1(WC_HASH_TYPE_SHA512, seed, seedSz, out, outSz, heap);
 1112                             		.loc 2 1023 19
 1113 00a5 A8 5C                   		mov.L	4[r5], r4
 1114 00a7 A0 0C                   		mov.L	r4, 4[r0]
 1115 00a9 EC 55                   		mov.L	[r5], r5
 1116 00ab E3 05                   		mov.L	r5, [r0]
 1117 00ad ED A4 04                		mov.L	16[r10], r4
 1118 00b0 ED A3 03                		mov.L	12[r10], r3
 1119 00b3 ED A2 02                		mov.L	8[r10], r2
 1120 00b6 66 81                   		mov.L	#8, r1
 1121 00b8 05 00 00 00             		bsr	_RsaMGF1
 1122 00bc E3 A1                   		mov.L	r1, [r10]
1024:../src/wolfcrypt/src/rsa.c ****             break;
 1123                             		.loc 2 1024 13
 1124 00be 2E 48                   		bra	.L71
 1125                             	.L70:
1025:../src/wolfcrypt/src/rsa.c ****         #ifndef WOLFSSL_NOSHA512_224
1026:../src/wolfcrypt/src/rsa.c ****         case WC_MGF1SHA512_224:
1027:../src/wolfcrypt/src/rsa.c ****             ret = RsaMGF1(WC_HASH_TYPE_SHA512_224, seed, seedSz, out, outSz,
 1126                             		.loc 2 1027 19
 1127 00c0 A8 5C                   		mov.L	4[r5], r4
 1128 00c2 A0 0C                   		mov.L	r4, 4[r0]
 1129 00c4 EC 55                   		mov.L	[r5], r5
 1130 00c6 E3 05                   		mov.L	r5, [r0]
 1131 00c8 ED A4 04                		mov.L	16[r10], r4
 1132 00cb ED A3 03                		mov.L	12[r10], r3
 1133 00ce ED A2 02                		mov.L	8[r10], r2
 1134 00d1 75 41 10                		mov.L	#16, r1
 1135 00d4 05 00 00 00             		bsr	_RsaMGF1
 1136 00d8 E3 A1                   		mov.L	r1, [r10]
1028:../src/wolfcrypt/src/rsa.c ****                 heap);
1029:../src/wolfcrypt/src/rsa.c ****             break;
 1137                             		.loc 2 1029 13
 1138 00da 2E 2C                   		bra	.L71
 1139                             	.L68:
1030:../src/wolfcrypt/src/rsa.c ****         #endif
1031:../src/wolfcrypt/src/rsa.c ****         #ifndef WOLFSSL_NOSHA512_256
1032:../src/wolfcrypt/src/rsa.c ****         case WC_MGF1SHA512_256:
1033:../src/wolfcrypt/src/rsa.c ****             ret = RsaMGF1(WC_HASH_TYPE_SHA512_256, seed, seedSz, out, outSz,
 1140                             		.loc 2 1033 19
 1141 00dc A8 5C                   		mov.L	4[r5], r4
 1142 00de A0 0C                   		mov.L	r4, 4[r0]
 1143 00e0 EC 55                   		mov.L	[r5], r5
 1144 00e2 E3 05                   		mov.L	r5, [r0]
 1145 00e4 ED A4 04                		mov.L	16[r10], r4
 1146 00e7 ED A3 03                		mov.L	12[r10], r3
 1147 00ea ED A2 02                		mov.L	8[r10], r2
 1148 00ed 75 41 11                		mov.L	#17, r1
 1149 00f0 05 00 00 00             		bsr	_RsaMGF1
 1150 00f4 E3 A1                   		mov.L	r1, [r10]
1034:../src/wolfcrypt/src/rsa.c ****                 heap);
1035:../src/wolfcrypt/src/rsa.c ****             break;
 1151                             		.loc 2 1035 13
 1152 00f6 2E 10                   		bra	.L71
 1153                             	.L67:
1036:../src/wolfcrypt/src/rsa.c ****         #endif
1037:../src/wolfcrypt/src/rsa.c ****     #endif
1038:../src/wolfcrypt/src/rsa.c ****         default:
1039:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("Unknown MGF type: check build options");
 1154                             		.loc 2 1039 13
 1155 00f8 FB 12 00 00 00 00       		mov.L	#.LC0, r1
 1156 00fe 05 00 00 00             		bsr	_WOLFSSL_MSG
1040:../src/wolfcrypt/src/rsa.c ****             ret = BAD_FUNC_ARG;
 1157                             		.loc 2 1040 17
 1158 0102 F8 AA 53 FF             		mov.L	#-173, [r10]
 1159                             		.balign 8,3,1
 1160                             	.L71:
1041:../src/wolfcrypt/src/rsa.c ****     }
1042:../src/wolfcrypt/src/rsa.c **** 
1043:../src/wolfcrypt/src/rsa.c ****     /* in case of default avoid unused warning */
1044:../src/wolfcrypt/src/rsa.c ****     (void)seed;
1045:../src/wolfcrypt/src/rsa.c ****     (void)seedSz;
1046:../src/wolfcrypt/src/rsa.c ****     (void)out;
1047:../src/wolfcrypt/src/rsa.c ****     (void)outSz;
1048:../src/wolfcrypt/src/rsa.c ****     (void)heap;
1049:../src/wolfcrypt/src/rsa.c **** 
1050:../src/wolfcrypt/src/rsa.c ****     return ret;
 1161                             		.loc 2 1050 12
 1162 0106 EC A5                   		mov.L	[r10], r5
1051:../src/wolfcrypt/src/rsa.c **** }
 1163                             		.loc 2 1051 1
 1164 0108 EF 51                   		mov.L	r5, r1
 1165 010a 3F AA 0A                		rtsd	#40, r10-r10
 1166                             	.LFE48:
 1168 010d FC 13 00                		.section C,"a",@progbits
 1169 0026 00 00                   		.p2align 2
 1170                             	.LC1:
 1171 0028 4F 41 45 50 20 68 61 73 		.string	"OAEP hash type possibly not supported or lHash to small"
 1171      68 20 74 79 70 65 20 70 
 1171      6F 73 73 69 62 6C 79 20 
 1171      6E 6F 74 20 73 75 70 70 
 1171      6F 72 74 65 64 20 6F 72 
 1172                             	.LC2:
 1173 0060 4F 41 45 50 20 70 61 64 		.string	"OAEP pad error hash to big for RSA key size"
 1173      20 65 72 72 6F 72 20 68 
 1173      61 73 68 20 74 6F 20 62 
 1173      69 67 20 66 6F 72 20 52 
 1173      53 41 20 6B 65 79 20 73 
 1174                             	.LC3:
 1175 008c 4F 41 45 50 20 70 61 64 		.string	"OAEP pad error message too long"
 1175      20 65 72 72 6F 72 20 6D 
 1175      65 73 73 61 67 65 20 74 
 1175      6F 6F 20 6C 6F 6E 67 00 
 1176                             		.section	.text.RsaPad_OAEP,"ax",@progbits
 1178                             	_RsaPad_OAEP:
 1179                             	.LFB49:
1052:../src/wolfcrypt/src/rsa.c **** #endif /* !WC_NO_RSA_OAEP || WC_RSA_PSS */
1053:../src/wolfcrypt/src/rsa.c **** 
1054:../src/wolfcrypt/src/rsa.c **** 
1055:../src/wolfcrypt/src/rsa.c **** /* Padding */
1056:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
1057:../src/wolfcrypt/src/rsa.c **** #ifndef WC_NO_RNG
1058:../src/wolfcrypt/src/rsa.c **** #ifndef WC_NO_RSA_OAEP
1059:../src/wolfcrypt/src/rsa.c **** static int RsaPad_OAEP(const byte* input, word32 inputLen, byte* pkcsBlock,
1060:../src/wolfcrypt/src/rsa.c ****         word32 pkcsBlockLen, byte padValue, WC_RNG* rng,
1061:../src/wolfcrypt/src/rsa.c ****         enum wc_HashType hType, int mgf, byte* optLabel, word32 labelLen,
1062:../src/wolfcrypt/src/rsa.c ****         void* heap)
1063:../src/wolfcrypt/src/rsa.c **** {
 1180                             		.loc 2 1063 1
 1181 0000 7E AA                   		push.l	r10
 1182                             	.LCFI44:
 1183 0002 7E A6                   		push.l	r6
 1184                             	.LCFI45:
 1185 0004 72 0A 60 FF             		add	#-160, r0, r10
 1186                             	.LCFI46:
 1187 0008 71 A0 F8                		add	#-8, r10, r0
 1188                             	.LCFI47:
 1189 000b 75 46 AC                		mov.L	#0xac, r6
 1190 000e 4B A6                   		add	r10, r6
 1191 0010 E7 A1 1D                		mov.L	r1, 116[r10]
 1192 0013 E7 A2 1E                		mov.L	r2, 120[r10]
 1193 0016 E7 A3 1F                		mov.L	r3, 124[r10]
 1194 0019 E7 A4 20                		mov.L	r4, 128[r10]
1064:../src/wolfcrypt/src/rsa.c ****     int ret;
1065:../src/wolfcrypt/src/rsa.c ****     int hLen;
1066:../src/wolfcrypt/src/rsa.c ****     int psLen;
1067:../src/wolfcrypt/src/rsa.c ****     int i;
1068:../src/wolfcrypt/src/rsa.c ****     word32 idx;
1069:../src/wolfcrypt/src/rsa.c **** 
1070:../src/wolfcrypt/src/rsa.c ****     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
1071:../src/wolfcrypt/src/rsa.c ****         byte* dbMask = NULL;
 1195                             		.loc 2 1071 15
 1196 001c F9 A6 03 00             		mov.L	#0, 12[r10]
1072:../src/wolfcrypt/src/rsa.c ****         byte* lHash = NULL;
 1197                             		.loc 2 1072 15
 1198 0020 F9 A6 04 00             		mov.L	#0, 16[r10]
1073:../src/wolfcrypt/src/rsa.c ****         byte* seed  = NULL;
 1199                             		.loc 2 1073 15
 1200 0024 F9 A6 05 00             		mov.L	#0, 20[r10]
1074:../src/wolfcrypt/src/rsa.c ****     #else
1075:../src/wolfcrypt/src/rsa.c ****         byte dbMask[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];
1076:../src/wolfcrypt/src/rsa.c ****         /* must be large enough to contain largest hash */
1077:../src/wolfcrypt/src/rsa.c ****         byte lHash[WC_MAX_DIGEST_SIZE];
1078:../src/wolfcrypt/src/rsa.c ****         byte seed[WC_MAX_DIGEST_SIZE];
1079:../src/wolfcrypt/src/rsa.c ****     #endif
1080:../src/wolfcrypt/src/rsa.c **** 
1081:../src/wolfcrypt/src/rsa.c ****     /* no label is allowed, but catch if no label provided and length > 0 */
1082:../src/wolfcrypt/src/rsa.c ****     if (optLabel == NULL && labelLen > 0) {
 1201                             		.loc 2 1082 8
 1202 0028 A9 65                   		mov.L	16[r6], r5
 1203 002a 61 05                   		cmp	#0, r5
 1204 002c 21 0E                   		bne	.L74
 1205                             		.loc 2 1082 26 discriminator 1
 1206 002e A9 6D                   		mov.L	20[r6], r5
 1207 0030 61 05                   		cmp	#0, r5
 1208 0032 10                      		beq	.L74
1083:../src/wolfcrypt/src/rsa.c ****         return BUFFER_E;
 1209                             		.loc 2 1083 16
 1210 0033 FB 5A 7C FF             		mov.L	#-132, r5
 1211 0037 38 74 04                		bra	.L75
 1212                             	.L74:
1084:../src/wolfcrypt/src/rsa.c ****     }
1085:../src/wolfcrypt/src/rsa.c **** 
1086:../src/wolfcrypt/src/rsa.c ****     /* limit of label is the same as limit of hash function which is massive */
1087:../src/wolfcrypt/src/rsa.c ****     hLen = wc_HashGetDigestSize(hType);
 1213                             		.loc 2 1087 12
 1214 003a A8 E1                   		mov.L	8[r6], r1
 1215 003c 05 00 00 00             		bsr	_wc_HashGetDigestSize
 1216 0040 E7 A1 06                		mov.L	r1, 24[r10]
1088:../src/wolfcrypt/src/rsa.c ****     if (hLen < 0) {
 1217                             		.loc 2 1088 8
 1218 0043 ED A5 06                		mov.L	24[r10], r5
 1219 0046 61 05                   		cmp	#0, r5
 1220 0048 28 08                   		bge	.L76
1089:../src/wolfcrypt/src/rsa.c ****         return hLen;
 1221                             		.loc 2 1089 16
 1222 004a ED A5 06                		mov.L	24[r10], r5
 1223 004d 38 5E 04                		bra	.L75
 1224                             	.L76:
1090:../src/wolfcrypt/src/rsa.c ****     }
1091:../src/wolfcrypt/src/rsa.c **** 
1092:../src/wolfcrypt/src/rsa.c ****     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
1093:../src/wolfcrypt/src/rsa.c ****         lHash = (byte*)XMALLOC(hLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1225                             		.loc 2 1093 24
 1226 0050 ED A5 06                		mov.L	24[r10], r5
 1227 0053 EF 51                   		mov.L	r5, r1
 1228 0055 05 00 00 00             		bsr	_wolfSSL_Malloc
 1229 0059 E7 A1 04                		mov.L	r1, 16[r10]
1094:../src/wolfcrypt/src/rsa.c ****         if (lHash == NULL) {
 1230                             		.loc 2 1094 12
 1231 005c ED A5 04                		mov.L	16[r10], r5
 1232 005f 61 05                   		cmp	#0, r5
 1233 0061 1F                      		bne	.L77
1095:../src/wolfcrypt/src/rsa.c ****             return MEMORY_E;
 1234                             		.loc 2 1095 20
 1235 0062 FB 56 83                		mov.L	#-125, r5
 1236 0065 38 46 04                		bra	.L75
 1237                             	.L77:
1096:../src/wolfcrypt/src/rsa.c ****         }
1097:../src/wolfcrypt/src/rsa.c ****         seed = (byte*)XMALLOC(hLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1238                             		.loc 2 1097 23
 1239 0068 ED A5 06                		mov.L	24[r10], r5
 1240 006b EF 51                   		mov.L	r5, r1
 1241 006d 05 00 00 00             		bsr	_wolfSSL_Malloc
 1242 0071 E7 A1 05                		mov.L	r1, 20[r10]
1098:../src/wolfcrypt/src/rsa.c ****         if (seed == NULL) {
 1243                             		.loc 2 1098 12
 1244 0074 ED A5 05                		mov.L	20[r10], r5
 1245 0077 61 05                   		cmp	#0, r5
 1246 0079 21 1B                   		bne	.L78
 1247                             	.LBB6:
1099:../src/wolfcrypt/src/rsa.c ****             XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1248                             		.loc 2 1099 13
 1249 007b ED A5 04                		mov.L	16[r10], r5
 1250 007e E7 A5 07                		mov.L	r5, 28[r10]
 1251 0081 ED A5 07                		mov.L	28[r10], r5
 1252 0084 61 05                   		cmp	#0, r5
 1253 0086 10                      		beq	.L79
 1254                             		.loc 2 1099 13 is_stmt 0 discriminator 1
 1255 0087 ED A1 07                		mov.L	28[r10], r1
 1256 008a 05 00 00 00             		bsr	_wolfSSL_Free
 1257                             	.L79:
 1258                             	.LBE6:
1100:../src/wolfcrypt/src/rsa.c ****             return MEMORY_E;
 1259                             		.loc 2 1100 20 is_stmt 1
 1260 008e FB 56 83                		mov.L	#-125, r5
 1261 0091 38 1A 04                		bra	.L75
 1262                             	.L78:
1101:../src/wolfcrypt/src/rsa.c ****         }
1102:../src/wolfcrypt/src/rsa.c ****     #else
1103:../src/wolfcrypt/src/rsa.c ****         /* hLen should never be larger than lHash since size is max digest size,
1104:../src/wolfcrypt/src/rsa.c ****            but check before blindly calling wc_Hash */
1105:../src/wolfcrypt/src/rsa.c ****         if ((word32)hLen > sizeof(lHash)) {
1106:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("OAEP lHash to small for digest!!");
1107:../src/wolfcrypt/src/rsa.c ****             return MEMORY_E;
1108:../src/wolfcrypt/src/rsa.c ****         }
1109:../src/wolfcrypt/src/rsa.c ****     #endif
1110:../src/wolfcrypt/src/rsa.c **** 
1111:../src/wolfcrypt/src/rsa.c ****     if ((ret = wc_Hash(hType, optLabel, labelLen, lHash, hLen)) != 0) {
 1263                             		.loc 2 1111 16
 1264 0094 ED A5 06                		mov.L	24[r10], r5
 1265 0097 E3 05                   		mov.L	r5, [r0]
 1266 0099 ED A4 04                		mov.L	16[r10], r4
 1267 009c A9 6B                   		mov.L	20[r6], r3
 1268 009e A9 62                   		mov.L	16[r6], r2
 1269 00a0 A8 E1                   		mov.L	8[r6], r1
 1270 00a2 05 00 00 00             		bsr	_wc_Hash
 1271 00a6 E7 A1 08                		mov.L	r1, 32[r10]
 1272                             		.loc 2 1111 8
 1273 00a9 ED A5 08                		mov.L	32[r10], r5
 1274 00ac 61 05                   		cmp	#0, r5
 1275 00ae 20 38                   		beq	.L80
1112:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("OAEP hash type possibly not supported or lHash to small");
 1276                             		.loc 2 1112 9
 1277 00b0 FB 12 28 00 00 00       		mov.L	#.LC1, r1
 1278 00b6 05 00 00 00             		bsr	_WOLFSSL_MSG
 1279                             	.LBB7:
1113:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_SMALL_STACK
1114:../src/wolfcrypt/src/rsa.c ****             XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1280                             		.loc 2 1114 13
 1281 00ba ED A5 04                		mov.L	16[r10], r5
 1282 00bd E7 A5 09                		mov.L	r5, 36[r10]
 1283 00c0 ED A5 09                		mov.L	36[r10], r5
 1284 00c3 61 05                   		cmp	#0, r5
 1285 00c5 10                      		beq	.L81
 1286                             		.loc 2 1114 13 is_stmt 0 discriminator 1
 1287 00c6 ED A1 09                		mov.L	36[r10], r1
 1288 00c9 05 00 00 00             		bsr	_wolfSSL_Free
 1289                             	.L81:
 1290                             	.LBE7:
 1291                             	.LBB8:
1115:../src/wolfcrypt/src/rsa.c ****             XFREE(seed,  heap, DYNAMIC_TYPE_RSA_BUFFER);
 1292                             		.loc 2 1115 13 is_stmt 1
 1293 00cd ED A5 05                		mov.L	20[r10], r5
 1294 00d0 E7 A5 0A                		mov.L	r5, 40[r10]
 1295 00d3 ED A5 0A                		mov.L	40[r10], r5
 1296 00d6 61 05                   		cmp	#0, r5
 1297 00d8 10                      		beq	.L82
 1298                             		.loc 2 1115 13 is_stmt 0 discriminator 1
 1299 00d9 ED A1 0A                		mov.L	40[r10], r1
 1300 00dc 05 00 00 00             		bsr	_wolfSSL_Free
 1301                             	.L82:
 1302                             	.LBE8:
1116:../src/wolfcrypt/src/rsa.c ****         #endif
1117:../src/wolfcrypt/src/rsa.c ****         return ret;
 1303                             		.loc 2 1117 16 is_stmt 1
 1304 00e0 ED A5 08                		mov.L	32[r10], r5
 1305 00e3 38 C8 03                		bra	.L75
 1306                             	.L80:
1118:../src/wolfcrypt/src/rsa.c ****     }
1119:../src/wolfcrypt/src/rsa.c **** 
1120:../src/wolfcrypt/src/rsa.c ****     /* handles check of location for idx as well as psLen, cast to int to check
1121:../src/wolfcrypt/src/rsa.c ****        for pkcsBlockLen(k) - 2 * hLen - 2 being negative
1122:../src/wolfcrypt/src/rsa.c ****        This check is similar to decryption where k > 2 * hLen + 2 as msg
1123:../src/wolfcrypt/src/rsa.c ****        size approaches 0. In decryption if k is less than or equal -- then there
1124:../src/wolfcrypt/src/rsa.c ****        is no possible room for msg.
1125:../src/wolfcrypt/src/rsa.c ****        k = RSA key size
1126:../src/wolfcrypt/src/rsa.c ****        hLen = hash digest size -- will always be >= 0 at this point
1127:../src/wolfcrypt/src/rsa.c ****      */
1128:../src/wolfcrypt/src/rsa.c ****     if ((word32)(2 * hLen + 2) > pkcsBlockLen) {
 1307                             		.loc 2 1128 27
 1308 00e6 ED A5 06                		mov.L	24[r10], r5
 1309 00e9 62 15                   		add	#1, r5
 1310 00eb 4B 55                   		add	r5, r5
 1311                             		.loc 2 1128 8
 1312 00ed ED A4 20                		mov.L	128[r10], r4
 1313 00f0 47 54                   		cmp	r5, r4
 1314 00f2 22 39                   		bgeu	.L83
1129:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("OAEP pad error hash to big for RSA key size");
 1315                             		.loc 2 1129 9
 1316 00f4 FB 12 60 00 00 00       		mov.L	#.LC2, r1
 1317 00fa 05 00 00 00             		bsr	_WOLFSSL_MSG
 1318                             	.LBB9:
1130:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_SMALL_STACK
1131:../src/wolfcrypt/src/rsa.c ****             XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1319                             		.loc 2 1131 13
 1320 00fe ED A5 04                		mov.L	16[r10], r5
 1321 0101 E7 A5 0B                		mov.L	r5, 44[r10]
 1322 0104 ED A5 0B                		mov.L	44[r10], r5
 1323 0107 61 05                   		cmp	#0, r5
 1324 0109 10                      		beq	.L84
 1325                             		.loc 2 1131 13 is_stmt 0 discriminator 1
 1326 010a ED A1 0B                		mov.L	44[r10], r1
 1327 010d 05 00 00 00             		bsr	_wolfSSL_Free
 1328                             	.L84:
 1329                             	.LBE9:
 1330                             	.LBB10:
1132:../src/wolfcrypt/src/rsa.c ****             XFREE(seed,  heap, DYNAMIC_TYPE_RSA_BUFFER);
 1331                             		.loc 2 1132 13 is_stmt 1
 1332 0111 ED A5 05                		mov.L	20[r10], r5
 1333 0114 E7 A5 0C                		mov.L	r5, 48[r10]
 1334 0117 ED A5 0C                		mov.L	48[r10], r5
 1335 011a 61 05                   		cmp	#0, r5
 1336 011c 10                      		beq	.L85
 1337                             		.loc 2 1132 13 is_stmt 0 discriminator 1
 1338 011d ED A1 0C                		mov.L	48[r10], r1
 1339 0120 05 00 00 00             		bsr	_wolfSSL_Free
 1340                             	.L85:
 1341                             	.LBE10:
1133:../src/wolfcrypt/src/rsa.c ****         #endif
1134:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 1342                             		.loc 2 1134 16 is_stmt 1
 1343 0124 FB 5A 53 FF             		mov.L	#-173, r5
 1344 0128 38 83 03                		bra	.L75
 1345                             	.L83:
1135:../src/wolfcrypt/src/rsa.c ****     }
1136:../src/wolfcrypt/src/rsa.c **** 
1137:../src/wolfcrypt/src/rsa.c ****     if (inputLen > (pkcsBlockLen - 2 * hLen - 2)) {
 1346                             		.loc 2 1137 38
 1347 012b ED A5 06                		mov.L	24[r10], r5
 1348 012e 4B 55                   		add	r5, r5
 1349                             		.loc 2 1137 34
 1350 0130 ED A4 20                		mov.L	128[r10], r4
 1351 0133 FF 05 54                		sub	r5, r4, r5
 1352                             		.loc 2 1137 45
 1353 0136 60 25                   		sub	#2, r5
 1354                             		.loc 2 1137 8
 1355 0138 ED A4 1E                		mov.L	120[r10], r4
 1356 013b 47 54                   		cmp	r5, r4
 1357 013d 25 39                   		bleu	.L86
1138:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("OAEP pad error message too long");
 1358                             		.loc 2 1138 9
 1359 013f FB 12 8C 00 00 00       		mov.L	#.LC3, r1
 1360 0145 05 00 00 00             		bsr	_WOLFSSL_MSG
 1361                             	.LBB11:
1139:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_SMALL_STACK
1140:../src/wolfcrypt/src/rsa.c ****             XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1362                             		.loc 2 1140 13
 1363 0149 ED A5 04                		mov.L	16[r10], r5
 1364 014c E7 A5 0D                		mov.L	r5, 52[r10]
 1365 014f ED A5 0D                		mov.L	52[r10], r5
 1366 0152 61 05                   		cmp	#0, r5
 1367 0154 10                      		beq	.L87
 1368                             		.loc 2 1140 13 is_stmt 0 discriminator 1
 1369 0155 ED A1 0D                		mov.L	52[r10], r1
 1370 0158 05 00 00 00             		bsr	_wolfSSL_Free
 1371                             	.L87:
 1372                             	.LBE11:
 1373                             	.LBB12:
1141:../src/wolfcrypt/src/rsa.c ****             XFREE(seed,  heap, DYNAMIC_TYPE_RSA_BUFFER);
 1374                             		.loc 2 1141 13 is_stmt 1
 1375 015c ED A5 05                		mov.L	20[r10], r5
 1376 015f E7 A5 0E                		mov.L	r5, 56[r10]
 1377 0162 ED A5 0E                		mov.L	56[r10], r5
 1378 0165 61 05                   		cmp	#0, r5
 1379 0167 10                      		beq	.L88
 1380                             		.loc 2 1141 13 is_stmt 0 discriminator 1
 1381 0168 ED A1 0E                		mov.L	56[r10], r1
 1382 016b 05 00 00 00             		bsr	_wolfSSL_Free
 1383                             	.L88:
 1384                             	.LBE12:
1142:../src/wolfcrypt/src/rsa.c ****         #endif
1143:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 1385                             		.loc 2 1143 16 is_stmt 1
 1386 016f FB 5A 53 FF             		mov.L	#-173, r5
 1387 0173 38 38 03                		bra	.L75
 1388                             	.L86:
1144:../src/wolfcrypt/src/rsa.c ****     }
1145:../src/wolfcrypt/src/rsa.c **** 
1146:../src/wolfcrypt/src/rsa.c ****     /* concatenate lHash || PS || 0x01 || msg */
1147:../src/wolfcrypt/src/rsa.c ****     idx = pkcsBlockLen - 1 - inputLen;
 1389                             		.loc 2 1147 28
 1390 0176 ED A4 20                		mov.L	128[r10], r4
 1391 0179 ED A5 1E                		mov.L	120[r10], r5
 1392 017c FF 05 54                		sub	r5, r4, r5
 1393                             		.loc 2 1147 9
 1394 017f 60 15                   		sub	#1, r5
 1395 0181 E7 A5 02                		mov.L	r5, 8[r10]
1148:../src/wolfcrypt/src/rsa.c ****     psLen = pkcsBlockLen - inputLen - 2 * hLen - 2;
 1396                             		.loc 2 1148 26
 1397 0184 ED A4 20                		mov.L	128[r10], r4
 1398 0187 ED A5 1E                		mov.L	120[r10], r5
 1399 018a 43 54                   		sub	r5, r4
 1400                             		.loc 2 1148 41
 1401 018c ED A5 06                		mov.L	24[r10], r5
 1402 018f 4B 55                   		add	r5, r5
 1403                             		.loc 2 1148 37
 1404 0191 FF 05 54                		sub	r5, r4, r5
 1405                             		.loc 2 1148 48
 1406 0194 60 25                   		sub	#2, r5
 1407                             		.loc 2 1148 11
 1408 0196 E3 A5                   		mov.L	r5, [r10]
1149:../src/wolfcrypt/src/rsa.c ****     if (pkcsBlockLen < inputLen) { /*make sure not writing over end of buffer */
 1409                             		.loc 2 1149 8
 1410 0198 ED A4 20                		mov.L	128[r10], r4
 1411 019b ED A5 1E                		mov.L	120[r10], r5
 1412 019e 47 54                   		cmp	r5, r4
 1413 01a0 22 2F                   		bgeu	.L89
 1414                             	.LBB13:
1150:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_SMALL_STACK
1151:../src/wolfcrypt/src/rsa.c ****             XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1415                             		.loc 2 1151 13
 1416 01a2 ED A5 04                		mov.L	16[r10], r5
 1417 01a5 E7 A5 0F                		mov.L	r5, 60[r10]
 1418 01a8 ED A5 0F                		mov.L	60[r10], r5
 1419 01ab 61 05                   		cmp	#0, r5
 1420 01ad 10                      		beq	.L90
 1421                             		.loc 2 1151 13 is_stmt 0 discriminator 1
 1422 01ae ED A1 0F                		mov.L	60[r10], r1
 1423 01b1 05 00 00 00             		bsr	_wolfSSL_Free
 1424                             	.L90:
 1425                             	.LBE13:
 1426                             	.LBB14:
1152:../src/wolfcrypt/src/rsa.c ****             XFREE(seed,  heap, DYNAMIC_TYPE_RSA_BUFFER);
 1427                             		.loc 2 1152 13 is_stmt 1
 1428 01b5 ED A5 05                		mov.L	20[r10], r5
 1429 01b8 E7 A5 10                		mov.L	r5, 64[r10]
 1430 01bb ED A5 10                		mov.L	64[r10], r5
 1431 01be 61 05                   		cmp	#0, r5
 1432 01c0 10                      		beq	.L91
 1433                             		.loc 2 1152 13 is_stmt 0 discriminator 1
 1434 01c1 ED A1 10                		mov.L	64[r10], r1
 1435 01c4 05 00 00 00             		bsr	_wolfSSL_Free
 1436                             	.L91:
 1437                             	.LBE14:
1153:../src/wolfcrypt/src/rsa.c ****         #endif
1154:../src/wolfcrypt/src/rsa.c ****         return BUFFER_E;
 1438                             		.loc 2 1154 16 is_stmt 1
 1439 01c8 FB 5A 7C FF             		mov.L	#-132, r5
 1440 01cc 38 DF 02                		bra	.L75
 1441                             	.L89:
1155:../src/wolfcrypt/src/rsa.c ****     }
1156:../src/wolfcrypt/src/rsa.c ****     XMEMCPY(pkcsBlock + (pkcsBlockLen - inputLen), input, inputLen);
 1442                             		.loc 2 1156 5
 1443 01cf ED A4 20                		mov.L	128[r10], r4
 1444 01d2 ED A5 1E                		mov.L	120[r10], r5
 1445 01d5 FF 05 54                		sub	r5, r4, r5
 1446 01d8 ED A4 1F                		mov.L	124[r10], r4
 1447 01db 4B 45                   		add	r4, r5
 1448 01dd ED A3 1E                		mov.L	120[r10], r3
 1449 01e0 ED A2 1D                		mov.L	116[r10], r2
 1450 01e3 EF 51                   		mov.L	r5, r1
 1451 01e5 05 00 00 00             		bsr	_memcpy
1157:../src/wolfcrypt/src/rsa.c ****     pkcsBlock[idx--] = 0x01; /* PS and M separator */
 1452                             		.loc 2 1157 18
 1453 01e9 ED A5 02                		mov.L	8[r10], r5
 1454 01ec 71 54 FF                		add	#-1, r5, r4
 1455 01ef E7 A4 02                		mov.L	r4, 8[r10]
 1456                             		.loc 2 1157 14
 1457 01f2 ED A4 1F                		mov.L	124[r10], r4
 1458 01f5 4B 45                   		add	r4, r5
 1459                             		.loc 2 1157 22
 1460 01f7 F8 54 01                		mov.B	#1, [r5]
1158:../src/wolfcrypt/src/rsa.c ****     while (psLen > 0 && idx > 0) {
 1461                             		.loc 2 1158 11
 1462 01fa 2E 19                   		bra	.L92
 1463                             	.L94:
1159:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[idx--] = 0x00;
 1464                             		.loc 2 1159 22
 1465 01fc ED A5 02                		mov.L	8[r10], r5
 1466 01ff 71 54 FF                		add	#-1, r5, r4
 1467 0202 E7 A4 02                		mov.L	r4, 8[r10]
 1468                             		.loc 2 1159 18
 1469 0205 ED A4 1F                		mov.L	124[r10], r4
 1470 0208 4B 45                   		add	r4, r5
 1471                             		.loc 2 1159 26
 1472 020a F8 54 00                		mov.B	#0, [r5]
1160:../src/wolfcrypt/src/rsa.c ****         psLen--;
 1473                             		.loc 2 1160 14
 1474 020d EC A5                   		mov.L	[r10], r5
 1475 020f 60 15                   		sub	#1, r5
 1476 0211 E3 A5                   		mov.L	r5, [r10]
 1477                             	.L92:
1158:../src/wolfcrypt/src/rsa.c ****     while (psLen > 0 && idx > 0) {
 1478                             		.loc 2 1158 11
 1479 0213 EC A5                   		mov.L	[r10], r5
 1480 0215 61 05                   		cmp	#0, r5
 1481 0217 2B 09                   		ble	.L93
1158:../src/wolfcrypt/src/rsa.c ****     while (psLen > 0 && idx > 0) {
 1482                             		.loc 2 1158 22 discriminator 1
 1483 0219 ED A5 02                		mov.L	8[r10], r5
 1484 021c 61 05                   		cmp	#0, r5
 1485 021e 21 DE                   		bne	.L94
 1486                             	.L93:
1161:../src/wolfcrypt/src/rsa.c ****     }
1162:../src/wolfcrypt/src/rsa.c **** 
1163:../src/wolfcrypt/src/rsa.c ****     idx = idx - hLen + 1;
 1487                             		.loc 2 1163 15
 1488 0220 ED A5 06                		mov.L	24[r10], r5
 1489 0223 ED A4 02                		mov.L	8[r10], r4
 1490 0226 FF 05 54                		sub	r5, r4, r5
 1491                             		.loc 2 1163 9
 1492 0229 62 15                   		add	#1, r5
 1493 022b E7 A5 02                		mov.L	r5, 8[r10]
1164:../src/wolfcrypt/src/rsa.c ****     XMEMCPY(pkcsBlock + idx, lHash, hLen);
 1494                             		.loc 2 1164 5
 1495 022e ED A5 1F                		mov.L	124[r10], r5
 1496 0231 06 89 A5 02             		add	8[r10].L, r5
 1497 0235 ED A4 06                		mov.L	24[r10], r4
 1498 0238 EF 43                   		mov.L	r4, r3
 1499 023a ED A2 04                		mov.L	16[r10], r2
 1500 023d EF 51                   		mov.L	r5, r1
 1501 023f 05 00 00 00             		bsr	_memcpy
1165:../src/wolfcrypt/src/rsa.c **** 
1166:../src/wolfcrypt/src/rsa.c ****     /* generate random seed */
1167:../src/wolfcrypt/src/rsa.c ****     if ((ret = wc_RNG_GenerateBlock(rng, seed, hLen)) != 0) {
 1502                             		.loc 2 1167 16
 1503 0243 ED A5 06                		mov.L	24[r10], r5
 1504 0246 EF 53                   		mov.L	r5, r3
 1505 0248 ED A2 05                		mov.L	20[r10], r2
 1506 024b A8 69                   		mov.L	4[r6], r1
 1507 024d 05 00 00 00             		bsr	_wc_RNG_GenerateBlock
 1508 0251 E7 A1 08                		mov.L	r1, 32[r10]
 1509                             		.loc 2 1167 8
 1510 0254 ED A5 08                		mov.L	32[r10], r5
 1511 0257 61 05                   		cmp	#0, r5
 1512 0259 20 2E                   		beq	.L95
 1513                             	.LBB15:
1168:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_SMALL_STACK
1169:../src/wolfcrypt/src/rsa.c ****             XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1514                             		.loc 2 1169 13
 1515 025b ED A5 04                		mov.L	16[r10], r5
 1516 025e E7 A5 11                		mov.L	r5, 68[r10]
 1517 0261 ED A5 11                		mov.L	68[r10], r5
 1518 0264 61 05                   		cmp	#0, r5
 1519 0266 10                      		beq	.L96
 1520                             		.loc 2 1169 13 is_stmt 0 discriminator 1
 1521 0267 ED A1 11                		mov.L	68[r10], r1
 1522 026a 05 00 00 00             		bsr	_wolfSSL_Free
 1523                             	.L96:
 1524                             	.LBE15:
 1525                             	.LBB16:
1170:../src/wolfcrypt/src/rsa.c ****             XFREE(seed,  heap, DYNAMIC_TYPE_RSA_BUFFER);
 1526                             		.loc 2 1170 13 is_stmt 1
 1527 026e ED A5 05                		mov.L	20[r10], r5
 1528 0271 E7 A5 12                		mov.L	r5, 72[r10]
 1529 0274 ED A5 12                		mov.L	72[r10], r5
 1530 0277 61 05                   		cmp	#0, r5
 1531 0279 10                      		beq	.L97
 1532                             		.loc 2 1170 13 is_stmt 0 discriminator 1
 1533 027a ED A1 12                		mov.L	72[r10], r1
 1534 027d 05 00 00 00             		bsr	_wolfSSL_Free
 1535                             	.L97:
 1536                             	.LBE16:
1171:../src/wolfcrypt/src/rsa.c ****         #endif
1172:../src/wolfcrypt/src/rsa.c ****         return ret;
 1537                             		.loc 2 1172 16 is_stmt 1
 1538 0281 ED A5 08                		mov.L	32[r10], r5
 1539 0284 38 27 02                		bra	.L75
 1540                             	.L95:
1173:../src/wolfcrypt/src/rsa.c ****     }
1174:../src/wolfcrypt/src/rsa.c **** 
1175:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
1176:../src/wolfcrypt/src/rsa.c ****     /* create maskedDB from dbMask */
1177:../src/wolfcrypt/src/rsa.c ****     dbMask = (byte*)XMALLOC(pkcsBlockLen - hLen - 1, heap, DYNAMIC_TYPE_RSA);
 1541                             		.loc 2 1177 21
 1542 0287 ED A5 06                		mov.L	24[r10], r5
 1543 028a ED A4 20                		mov.L	128[r10], r4
 1544 028d FF 05 54                		sub	r5, r4, r5
 1545 0290 60 15                   		sub	#1, r5
 1546 0292 EF 51                   		mov.L	r5, r1
 1547 0294 05 00 00 00             		bsr	_wolfSSL_Malloc
 1548 0298 E7 A1 03                		mov.L	r1, 12[r10]
1178:../src/wolfcrypt/src/rsa.c ****     if (dbMask == NULL) {
 1549                             		.loc 2 1178 8
 1550 029b ED A5 03                		mov.L	12[r10], r5
 1551 029e 61 05                   		cmp	#0, r5
 1552 02a0 21 2E                   		bne	.L98
 1553                             	.LBB17:
1179:../src/wolfcrypt/src/rsa.c **** 
1180:../src/wolfcrypt/src/rsa.c ****             XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1554                             		.loc 2 1180 13
 1555 02a2 ED A5 04                		mov.L	16[r10], r5
 1556 02a5 E7 A5 13                		mov.L	r5, 76[r10]
 1557 02a8 ED A5 13                		mov.L	76[r10], r5
 1558 02ab 61 05                   		cmp	#0, r5
 1559 02ad 10                      		beq	.L99
 1560                             		.loc 2 1180 13 is_stmt 0 discriminator 1
 1561 02ae ED A1 13                		mov.L	76[r10], r1
 1562 02b1 05 00 00 00             		bsr	_wolfSSL_Free
 1563                             	.L99:
 1564                             	.LBE17:
 1565                             	.LBB18:
1181:../src/wolfcrypt/src/rsa.c ****             XFREE(seed,  heap, DYNAMIC_TYPE_RSA_BUFFER);
 1566                             		.loc 2 1181 13 is_stmt 1
 1567 02b5 ED A5 05                		mov.L	20[r10], r5
 1568 02b8 E7 A5 14                		mov.L	r5, 80[r10]
 1569 02bb ED A5 14                		mov.L	80[r10], r5
 1570 02be 61 05                   		cmp	#0, r5
 1571 02c0 10                      		beq	.L100
 1572                             		.loc 2 1181 13 is_stmt 0 discriminator 1
 1573 02c1 ED A1 14                		mov.L	80[r10], r1
 1574 02c4 05 00 00 00             		bsr	_wolfSSL_Free
 1575                             	.L100:
 1576                             	.LBE18:
1182:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
 1577                             		.loc 2 1182 16 is_stmt 1
 1578 02c8 FB 56 83                		mov.L	#-125, r5
 1579 02cb 38 E0 01                		bra	.L75
 1580                             	.L98:
1183:../src/wolfcrypt/src/rsa.c ****     }
1184:../src/wolfcrypt/src/rsa.c **** #else
1185:../src/wolfcrypt/src/rsa.c ****     if (pkcsBlockLen - hLen - 1 > sizeof(dbMask)) {
1186:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
1187:../src/wolfcrypt/src/rsa.c ****     }
1188:../src/wolfcrypt/src/rsa.c **** #endif
1189:../src/wolfcrypt/src/rsa.c ****     XMEMSET(dbMask, 0, pkcsBlockLen - hLen - 1); /* help static analyzer */
 1581                             		.loc 2 1189 5
 1582 02ce ED A5 06                		mov.L	24[r10], r5
 1583 02d1 ED A4 20                		mov.L	128[r10], r4
 1584 02d4 FF 05 54                		sub	r5, r4, r5
 1585 02d7 60 15                   		sub	#1, r5
 1586 02d9 EF 53                   		mov.L	r5, r3
 1587 02db 66 02                   		mov.L	#0, r2
 1588 02dd ED A1 03                		mov.L	12[r10], r1
 1589 02e0 05 00 00 00             		bsr	_memset
1190:../src/wolfcrypt/src/rsa.c ****     ret = RsaMGF(mgf, seed, hLen, dbMask, pkcsBlockLen - hLen - 1, heap);
 1590                             		.loc 2 1190 11
 1591 02e4 ED A3 06                		mov.L	24[r10], r3
 1592                             		.loc 2 1190 56
 1593 02e7 ED A5 06                		mov.L	24[r10], r5
 1594 02ea ED A4 20                		mov.L	128[r10], r4
 1595 02ed FF 05 54                		sub	r5, r4, r5
 1596                             		.loc 2 1190 11
 1597 02f0 60 15                   		sub	#1, r5
 1598 02f2 A9 E4                   		mov.L	24[r6], r4
 1599 02f4 A0 0C                   		mov.L	r4, 4[r0]
 1600 02f6 E3 05                   		mov.L	r5, [r0]
 1601 02f8 ED A4 03                		mov.L	12[r10], r4
 1602 02fb ED A2 05                		mov.L	20[r10], r2
 1603 02fe A8 E9                   		mov.L	12[r6], r1
 1604 0300 05 00 00 00             		bsr	_RsaMGF
 1605 0304 E7 A1 08                		mov.L	r1, 32[r10]
1191:../src/wolfcrypt/src/rsa.c ****     if (ret != 0) {
 1606                             		.loc 2 1191 8
 1607 0307 ED A5 08                		mov.L	32[r10], r5
 1608 030a 61 05                   		cmp	#0, r5
 1609 030c 20 41                   		beq	.L101
 1610                             	.LBB19:
1192:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_SMALL_STACK
1193:../src/wolfcrypt/src/rsa.c ****             XFREE(dbMask, heap, DYNAMIC_TYPE_RSA);
 1611                             		.loc 2 1193 13
 1612 030e ED A5 03                		mov.L	12[r10], r5
 1613 0311 E7 A5 15                		mov.L	r5, 84[r10]
 1614 0314 ED A5 15                		mov.L	84[r10], r5
 1615 0317 61 05                   		cmp	#0, r5
 1616 0319 10                      		beq	.L102
 1617                             		.loc 2 1193 13 is_stmt 0 discriminator 1
 1618 031a ED A1 15                		mov.L	84[r10], r1
 1619 031d 05 00 00 00             		bsr	_wolfSSL_Free
 1620                             	.L102:
 1621                             	.LBE19:
 1622                             	.LBB20:
1194:../src/wolfcrypt/src/rsa.c ****             XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1623                             		.loc 2 1194 13 is_stmt 1
 1624 0321 ED A5 04                		mov.L	16[r10], r5
 1625 0324 E7 A5 16                		mov.L	r5, 88[r10]
 1626 0327 ED A5 16                		mov.L	88[r10], r5
 1627 032a 61 05                   		cmp	#0, r5
 1628 032c 10                      		beq	.L103
 1629                             		.loc 2 1194 13 is_stmt 0 discriminator 1
 1630 032d ED A1 16                		mov.L	88[r10], r1
 1631 0330 05 00 00 00             		bsr	_wolfSSL_Free
 1632                             	.L103:
 1633                             	.LBE20:
 1634                             	.LBB21:
1195:../src/wolfcrypt/src/rsa.c ****             XFREE(seed,  heap, DYNAMIC_TYPE_RSA_BUFFER);
 1635                             		.loc 2 1195 13 is_stmt 1
 1636 0334 ED A5 05                		mov.L	20[r10], r5
 1637 0337 E7 A5 17                		mov.L	r5, 92[r10]
 1638 033a ED A5 17                		mov.L	92[r10], r5
 1639 033d 61 05                   		cmp	#0, r5
 1640 033f 10                      		beq	.L104
 1641                             		.loc 2 1195 13 is_stmt 0 discriminator 1
 1642 0340 ED A1 17                		mov.L	92[r10], r1
 1643 0343 05 00 00 00             		bsr	_wolfSSL_Free
 1644                             	.L104:
 1645                             	.LBE21:
1196:../src/wolfcrypt/src/rsa.c ****         #endif
1197:../src/wolfcrypt/src/rsa.c ****         return ret;
 1646                             		.loc 2 1197 16 is_stmt 1
 1647 0347 ED A5 08                		mov.L	32[r10], r5
 1648 034a 38 61 01                		bra	.L75
 1649                             	.L101:
1198:../src/wolfcrypt/src/rsa.c ****     }
1199:../src/wolfcrypt/src/rsa.c **** 
1200:../src/wolfcrypt/src/rsa.c ****     i = 0;
 1650                             		.loc 2 1200 7
 1651 034d F9 A6 01 00             		mov.L	#0, 4[r10]
1201:../src/wolfcrypt/src/rsa.c ****     idx = hLen + 1;
 1652                             		.loc 2 1201 16
 1653 0351 ED A5 06                		mov.L	24[r10], r5
 1654 0354 62 15                   		add	#1, r5
 1655                             		.loc 2 1201 9
 1656 0356 E7 A5 02                		mov.L	r5, 8[r10]
1202:../src/wolfcrypt/src/rsa.c ****     while (idx < pkcsBlockLen && (word32)i < (pkcsBlockLen - hLen -1)) {
 1657                             		.loc 2 1202 11
 1658 0359 2E 2F                   		bra	.L105
 1659                             	.L107:
1203:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[idx] = dbMask[i++] ^ pkcsBlock[idx];
 1660                             		.loc 2 1203 34
 1661 035b ED A5 01                		mov.L	4[r10], r5
 1662 035e 71 54 01                		add	#1, r5, r4
 1663 0361 E7 A4 01                		mov.L	r4, 4[r10]
 1664                             		.loc 2 1203 32
 1665 0364 ED A4 03                		mov.L	12[r10], r4
 1666 0367 4B 45                   		add	r4, r5
 1667 0369 CC 53                   		mov.B	[r5], r3
 1668                             		.loc 2 1203 49
 1669 036b ED A5 1F                		mov.L	124[r10], r5
 1670 036e 06 89 A5 02             		add	8[r10].L, r5
 1671 0372 CC 54                   		mov.B	[r5], r4
 1672                             		.loc 2 1203 18
 1673 0374 ED A5 1F                		mov.L	124[r10], r5
 1674 0377 06 89 A5 02             		add	8[r10].L, r5
 1675                             		.loc 2 1203 24
 1676 037b FC 37 34                		xor	r3, r4
 1677 037e C3 54                   		mov.B	r4, [r5]
1204:../src/wolfcrypt/src/rsa.c ****         idx++;
 1678                             		.loc 2 1204 12
 1679 0380 ED A5 02                		mov.L	8[r10], r5
 1680 0383 62 15                   		add	#1, r5
 1681 0385 E7 A5 02                		mov.L	r5, 8[r10]
 1682                             	.L105:
1202:../src/wolfcrypt/src/rsa.c ****     while (idx < pkcsBlockLen && (word32)i < (pkcsBlockLen - hLen -1)) {
 1683                             		.loc 2 1202 11
 1684 0388 ED A4 02                		mov.L	8[r10], r4
 1685 038b ED A5 20                		mov.L	128[r10], r5
 1686 038e 47 54                   		cmp	r5, r4
 1687 0390 22 14                   		bgeu	.L106
1202:../src/wolfcrypt/src/rsa.c ****     while (idx < pkcsBlockLen && (word32)i < (pkcsBlockLen - hLen -1)) {
 1688                             		.loc 2 1202 60 discriminator 1
 1689 0392 ED A5 06                		mov.L	24[r10], r5
 1690 0395 ED A4 20                		mov.L	128[r10], r4
 1691 0398 FF 05 54                		sub	r5, r4, r5
1202:../src/wolfcrypt/src/rsa.c ****     while (idx < pkcsBlockLen && (word32)i < (pkcsBlockLen - hLen -1)) {
 1692                             		.loc 2 1202 67 discriminator 1
 1693 039b 60 15                   		sub	#1, r5
1202:../src/wolfcrypt/src/rsa.c ****     while (idx < pkcsBlockLen && (word32)i < (pkcsBlockLen - hLen -1)) {
 1694                             		.loc 2 1202 44 discriminator 1
 1695 039d ED A4 01                		mov.L	4[r10], r4
1202:../src/wolfcrypt/src/rsa.c ****     while (idx < pkcsBlockLen && (word32)i < (pkcsBlockLen - hLen -1)) {
 1696                             		.loc 2 1202 31 discriminator 1
 1697 03a0 47 45                   		cmp	r4, r5
 1698 03a2 24 B9                   		bgtu	.L107
 1699                             	.L106:
 1700                             	.LBB22:
1205:../src/wolfcrypt/src/rsa.c ****     }
1206:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
1207:../src/wolfcrypt/src/rsa.c ****     XFREE(dbMask, heap, DYNAMIC_TYPE_RSA);
 1701                             		.loc 2 1207 5
 1702 03a4 ED A5 03                		mov.L	12[r10], r5
 1703 03a7 E7 A5 18                		mov.L	r5, 96[r10]
 1704 03aa ED A5 18                		mov.L	96[r10], r5
 1705 03ad 61 05                   		cmp	#0, r5
 1706 03af 10                      		beq	.L108
 1707                             		.loc 2 1207 5 is_stmt 0 discriminator 1
 1708 03b0 ED A1 18                		mov.L	96[r10], r1
 1709 03b3 05 00 00 00             		bsr	_wolfSSL_Free
 1710                             	.L108:
 1711                             	.LBE22:
1208:../src/wolfcrypt/src/rsa.c **** #endif
1209:../src/wolfcrypt/src/rsa.c **** 
1210:../src/wolfcrypt/src/rsa.c ****     /* create maskedSeed from seedMask */
1211:../src/wolfcrypt/src/rsa.c ****     idx = 0;
 1712                             		.loc 2 1211 9 is_stmt 1
 1713 03b7 F9 A6 02 00             		mov.L	#0, 8[r10]
1212:../src/wolfcrypt/src/rsa.c ****     pkcsBlock[idx++] = 0x00;
 1714                             		.loc 2 1212 18
 1715 03bb ED A5 02                		mov.L	8[r10], r5
 1716 03be 71 54 01                		add	#1, r5, r4
 1717 03c1 E7 A4 02                		mov.L	r4, 8[r10]
 1718                             		.loc 2 1212 14
 1719 03c4 ED A4 1F                		mov.L	124[r10], r4
 1720 03c7 4B 45                   		add	r4, r5
 1721                             		.loc 2 1212 22
 1722 03c9 F8 54 00                		mov.B	#0, [r5]
1213:../src/wolfcrypt/src/rsa.c ****     /* create seedMask inline */
1214:../src/wolfcrypt/src/rsa.c ****     if ((ret = RsaMGF(mgf, pkcsBlock + hLen + 1, pkcsBlockLen - hLen - 1,
 1723                             		.loc 2 1214 45
 1724 03cc ED A5 06                		mov.L	24[r10], r5
 1725 03cf 62 15                   		add	#1, r5
 1726                             		.loc 2 1214 16
 1727 03d1 ED A4 1F                		mov.L	124[r10], r4
 1728 03d4 FF 22 54                		add	r5, r4, r2
 1729                             		.loc 2 1214 63
 1730 03d7 ED A5 06                		mov.L	24[r10], r5
 1731 03da ED A4 20                		mov.L	128[r10], r4
 1732 03dd FF 05 54                		sub	r5, r4, r5
 1733                             		.loc 2 1214 16
 1734 03e0 71 53 FF                		add	#-1, r5, r3
 1735 03e3 ED A5 1F                		mov.L	124[r10], r5
 1736 03e6 62 15                   		add	#1, r5
 1737 03e8 ED A4 06                		mov.L	24[r10], r4
 1738 03eb A9 E1                   		mov.L	24[r6], r1
 1739 03ed A0 09                   		mov.L	r1, 4[r0]
 1740 03ef E3 04                   		mov.L	r4, [r0]
 1741 03f1 EF 54                   		mov.L	r5, r4
 1742 03f3 A8 E9                   		mov.L	12[r6], r1
 1743 03f5 05 00 00 00             		bsr	_RsaMGF
 1744 03f9 E7 A1 08                		mov.L	r1, 32[r10]
 1745                             		.loc 2 1214 8
 1746 03fc ED A5 08                		mov.L	32[r10], r5
 1747 03ff 61 05                   		cmp	#0, r5
 1748 0401 20 2D                   		beq	.L109
 1749                             	.LBB23:
1215:../src/wolfcrypt/src/rsa.c ****                                            pkcsBlock + 1, hLen, heap)) != 0) {
1216:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_SMALL_STACK
1217:../src/wolfcrypt/src/rsa.c ****             XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1750                             		.loc 2 1217 13
 1751 0403 ED A5 04                		mov.L	16[r10], r5
 1752 0406 E7 A5 19                		mov.L	r5, 100[r10]
 1753 0409 ED A5 19                		mov.L	100[r10], r5
 1754 040c 61 05                   		cmp	#0, r5
 1755 040e 10                      		beq	.L110
 1756                             		.loc 2 1217 13 is_stmt 0 discriminator 1
 1757 040f ED A1 19                		mov.L	100[r10], r1
 1758 0412 05 00 00 00             		bsr	_wolfSSL_Free
 1759                             	.L110:
 1760                             	.LBE23:
 1761                             	.LBB24:
1218:../src/wolfcrypt/src/rsa.c ****             XFREE(seed,  heap, DYNAMIC_TYPE_RSA_BUFFER);
 1762                             		.loc 2 1218 13 is_stmt 1
 1763 0416 ED A5 05                		mov.L	20[r10], r5
 1764 0419 E7 A5 1A                		mov.L	r5, 104[r10]
 1765 041c ED A5 1A                		mov.L	104[r10], r5
 1766 041f 61 05                   		cmp	#0, r5
 1767 0421 10                      		beq	.L111
 1768                             		.loc 2 1218 13 is_stmt 0 discriminator 1
 1769 0422 ED A1 1A                		mov.L	104[r10], r1
 1770 0425 05 00 00 00             		bsr	_wolfSSL_Free
 1771                             	.L111:
 1772                             	.LBE24:
1219:../src/wolfcrypt/src/rsa.c ****         #endif
1220:../src/wolfcrypt/src/rsa.c ****         return ret;
 1773                             		.loc 2 1220 16 is_stmt 1
 1774 0429 ED A5 08                		mov.L	32[r10], r5
 1775 042c 2E 7F                   		bra	.L75
 1776                             	.L109:
1221:../src/wolfcrypt/src/rsa.c ****     }
1222:../src/wolfcrypt/src/rsa.c **** 
1223:../src/wolfcrypt/src/rsa.c ****     /* xor created seedMask with seed to make maskedSeed */
1224:../src/wolfcrypt/src/rsa.c ****     i = 0;
 1777                             		.loc 2 1224 7
 1778 042e F9 A6 01 00             		mov.L	#0, 4[r10]
1225:../src/wolfcrypt/src/rsa.c ****     while (idx < (word32)(hLen + 1) && i < hLen) {
 1779                             		.loc 2 1225 11
 1780 0432 2E 2F                   		bra	.L112
 1781                             	.L114:
1226:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[idx] = pkcsBlock[idx] ^ seed[i++];
 1782                             		.loc 2 1226 35
 1783 0434 ED A5 1F                		mov.L	124[r10], r5
 1784 0437 06 89 A5 02             		add	8[r10].L, r5
 1785 043b CC 53                   		mov.B	[r5], r3
 1786                             		.loc 2 1226 49
 1787 043d ED A5 01                		mov.L	4[r10], r5
 1788 0440 71 54 01                		add	#1, r5, r4
 1789 0443 E7 A4 01                		mov.L	r4, 4[r10]
 1790                             		.loc 2 1226 47
 1791 0446 ED A4 05                		mov.L	20[r10], r4
 1792 0449 4B 45                   		add	r4, r5
 1793 044b CC 54                   		mov.B	[r5], r4
 1794                             		.loc 2 1226 18
 1795 044d ED A5 1F                		mov.L	124[r10], r5
 1796 0450 06 89 A5 02             		add	8[r10].L, r5
 1797                             		.loc 2 1226 24
 1798 0454 FC 37 34                		xor	r3, r4
 1799 0457 C3 54                   		mov.B	r4, [r5]
1227:../src/wolfcrypt/src/rsa.c ****         idx++;
 1800                             		.loc 2 1227 12
 1801 0459 ED A5 02                		mov.L	8[r10], r5
 1802 045c 62 15                   		add	#1, r5
 1803 045e E7 A5 02                		mov.L	r5, 8[r10]
 1804                             	.L112:
1225:../src/wolfcrypt/src/rsa.c ****     while (idx < (word32)(hLen + 1) && i < hLen) {
 1805                             		.loc 2 1225 32
 1806 0461 ED A5 06                		mov.L	24[r10], r5
 1807 0464 62 15                   		add	#1, r5
1225:../src/wolfcrypt/src/rsa.c ****     while (idx < (word32)(hLen + 1) && i < hLen) {
 1808                             		.loc 2 1225 11
 1809 0466 ED A4 02                		mov.L	8[r10], r4
 1810 0469 47 54                   		cmp	r5, r4
 1811 046b 22 0C                   		bgeu	.L113
1225:../src/wolfcrypt/src/rsa.c ****     while (idx < (word32)(hLen + 1) && i < hLen) {
 1812                             		.loc 2 1225 37 discriminator 1
 1813 046d ED A4 01                		mov.L	4[r10], r4
 1814 0470 ED A5 06                		mov.L	24[r10], r5
 1815 0473 47 54                   		cmp	r5, r4
 1816 0475 29 BF                   		blt	.L114
 1817                             	.L113:
1228:../src/wolfcrypt/src/rsa.c ****     }
1229:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
1230:../src/wolfcrypt/src/rsa.c ****     /* Seed must be zeroized now that it has been used. */
1231:../src/wolfcrypt/src/rsa.c ****     wc_MemZero_Add("Pad OAEP seed", seed, hLen);
1232:../src/wolfcrypt/src/rsa.c **** #endif
1233:../src/wolfcrypt/src/rsa.c **** 
1234:../src/wolfcrypt/src/rsa.c ****     /* Zeroize masking bytes so that padding can't be unmasked. */
1235:../src/wolfcrypt/src/rsa.c ****     ForceZero(seed, hLen);
 1818                             		.loc 2 1235 5
 1819 0477 ED A5 06                		mov.L	24[r10], r5
 1820 047a EF 52                   		mov.L	r5, r2
 1821 047c ED A1 05                		mov.L	20[r10], r1
 1822 047f 05 00 00 00             		bsr	_ForceZero
 1823                             	.LBB25:
1236:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_SMALL_STACK
1237:../src/wolfcrypt/src/rsa.c ****         XFREE(lHash, heap, DYNAMIC_TYPE_RSA_BUFFER);
 1824                             		.loc 2 1237 9
 1825 0483 ED A5 04                		mov.L	16[r10], r5
 1826 0486 E7 A5 1B                		mov.L	r5, 108[r10]
 1827 0489 ED A5 1B                		mov.L	108[r10], r5
 1828 048c 61 05                   		cmp	#0, r5
 1829 048e 10                      		beq	.L115
 1830                             		.loc 2 1237 9 is_stmt 0 discriminator 1
 1831 048f ED A1 1B                		mov.L	108[r10], r1
 1832 0492 05 00 00 00             		bsr	_wolfSSL_Free
 1833                             	.L115:
 1834                             	.LBE25:
 1835                             	.LBB26:
1238:../src/wolfcrypt/src/rsa.c ****         XFREE(seed,  heap, DYNAMIC_TYPE_RSA_BUFFER);
 1836                             		.loc 2 1238 9 is_stmt 1
 1837 0496 ED A5 05                		mov.L	20[r10], r5
 1838 0499 E7 A5 1C                		mov.L	r5, 112[r10]
 1839 049c ED A5 1C                		mov.L	112[r10], r5
 1840 049f 61 05                   		cmp	#0, r5
 1841 04a1 10                      		beq	.L116
 1842                             		.loc 2 1238 9 is_stmt 0 discriminator 1
 1843 04a2 ED A1 1C                		mov.L	112[r10], r1
 1844 04a5 05 00 00 00             		bsr	_wolfSSL_Free
 1845                             	.L116:
 1846                             	.LBE26:
1239:../src/wolfcrypt/src/rsa.c ****     #elif defined(WOLFSSL_CHECK_MEM_ZERO)
1240:../src/wolfcrypt/src/rsa.c ****         wc_MemZero_Check(seed, hLen);
1241:../src/wolfcrypt/src/rsa.c ****     #endif
1242:../src/wolfcrypt/src/rsa.c ****     (void)padValue;
1243:../src/wolfcrypt/src/rsa.c **** 
1244:../src/wolfcrypt/src/rsa.c ****     return 0;
 1847                             		.loc 2 1244 12 is_stmt 1
 1848 04a9 66 05                   		mov.L	#0, r5
 1849                             		.balign 8,3,1
 1850                             	.L75:
1245:../src/wolfcrypt/src/rsa.c **** }
 1851                             		.loc 2 1245 1
 1852 04ab EF 51                   		mov.L	r5, r1
 1853 04ad 72 00 A8 00             		add	#0xa8, r0
 1854 04b1 7E B6                   		pop	r6
 1855 04b3 7E BA                   		pop	r10
 1856 04b5 02                      		rts
 1857                             	.LFE49:
 1859 04b6 EF 00                   		.section	.text.RsaPad_PSS,"ax",@progbits
 1861                             	_RsaPad_PSS:
 1862                             	.LFB50:
1246:../src/wolfcrypt/src/rsa.c **** #endif /* !WC_NO_RSA_OAEP */
1247:../src/wolfcrypt/src/rsa.c **** 
1248:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_PSS
1249:../src/wolfcrypt/src/rsa.c **** 
1250:../src/wolfcrypt/src/rsa.c **** /* 0x00 .. 0x00 0x01 | Salt | Gen Hash | 0xbc
1251:../src/wolfcrypt/src/rsa.c ****  * XOR MGF over all bytes down to end of Salt
1252:../src/wolfcrypt/src/rsa.c ****  * Gen Hash = HASH(8 * 0x00 | Message Hash | Salt)
1253:../src/wolfcrypt/src/rsa.c ****  *
1254:../src/wolfcrypt/src/rsa.c ****  * input         Digest of the message.
1255:../src/wolfcrypt/src/rsa.c ****  * inputLen      Length of digest.
1256:../src/wolfcrypt/src/rsa.c ****  * pkcsBlock     Buffer to write to.
1257:../src/wolfcrypt/src/rsa.c ****  * pkcsBlockLen  Length of buffer to write to.
1258:../src/wolfcrypt/src/rsa.c ****  * rng           Random number generator (for salt).
1259:../src/wolfcrypt/src/rsa.c ****  * htype         Hash function to use.
1260:../src/wolfcrypt/src/rsa.c ****  * mgf           Mask generation function.
1261:../src/wolfcrypt/src/rsa.c ****  * saltLen       Length of salt to put in padding.
1262:../src/wolfcrypt/src/rsa.c ****  * bits          Length of key in bits.
1263:../src/wolfcrypt/src/rsa.c ****  * heap          Used for dynamic memory allocation.
1264:../src/wolfcrypt/src/rsa.c ****  * returns 0 on success, PSS_SALTLEN_E when the salt length is invalid
1265:../src/wolfcrypt/src/rsa.c ****  * and other negative values on error.
1266:../src/wolfcrypt/src/rsa.c ****  */
1267:../src/wolfcrypt/src/rsa.c **** static int RsaPad_PSS(const byte* input, word32 inputLen, byte* pkcsBlock,
1268:../src/wolfcrypt/src/rsa.c ****         word32 pkcsBlockLen, WC_RNG* rng, enum wc_HashType hType, int mgf,
1269:../src/wolfcrypt/src/rsa.c ****         int saltLen, int bits, void* heap)
1270:../src/wolfcrypt/src/rsa.c **** {
 1863                             		.loc 2 1270 1
 1864 0000 6E 6A                   		pushm	r6-r10
 1865                             	.LCFI48:
 1866 0002 72 0A 70 FF             		add	#-144, r0, r10
 1867                             	.LCFI49:
 1868 0006 71 A0 F8                		add	#-8, r10, r0
 1869                             	.LCFI50:
 1870 0009 75 46 A8                		mov.L	#0xa8, r6
 1871 000c 4B A6                   		add	r10, r6
 1872 000e E7 A1 1A                		mov.L	r1, 104[r10]
 1873 0011 E7 A2 1B                		mov.L	r2, 108[r10]
 1874 0014 E7 A3 1C                		mov.L	r3, 112[r10]
 1875 0017 E7 A4 1D                		mov.L	r4, 116[r10]
1271:../src/wolfcrypt/src/rsa.c ****     int   ret = 0;
 1876                             		.loc 2 1271 11
 1877 001a F8 A6 00                		mov.L	#0, [r10]
1272:../src/wolfcrypt/src/rsa.c ****     int   hLen, i, o, maskLen, hiBits;
1273:../src/wolfcrypt/src/rsa.c ****     byte* m;
1274:../src/wolfcrypt/src/rsa.c ****     byte* s;
1275:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)
1276:../src/wolfcrypt/src/rsa.c ****     byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];
1277:../src/wolfcrypt/src/rsa.c **** #else
1278:../src/wolfcrypt/src/rsa.c ****     byte* msg = NULL;
 1878                             		.loc 2 1278 11
 1879 001d F9 A6 03 00             		mov.L	#0, 12[r10]
1279:../src/wolfcrypt/src/rsa.c **** #endif
1280:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)
1281:../src/wolfcrypt/src/rsa.c ****     byte* salt;
1282:../src/wolfcrypt/src/rsa.c **** #else
1283:../src/wolfcrypt/src/rsa.c ****     byte salt[WC_MAX_DIGEST_SIZE];
1284:../src/wolfcrypt/src/rsa.c **** #endif
1285:../src/wolfcrypt/src/rsa.c **** 
1286:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)
1287:../src/wolfcrypt/src/rsa.c ****     if (pkcsBlockLen > RSA_MAX_SIZE/8) {
1288:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
1289:../src/wolfcrypt/src/rsa.c ****     }
1290:../src/wolfcrypt/src/rsa.c **** #endif
1291:../src/wolfcrypt/src/rsa.c **** 
1292:../src/wolfcrypt/src/rsa.c ****     hLen = wc_HashGetDigestSize(hType);
 1880                             		.loc 2 1292 12
 1881 0021 A8 69                   		mov.L	4[r6], r1
 1882 0023 05 00 00 00             		bsr	_wc_HashGetDigestSize
 1883 0027 E7 A1 04                		mov.L	r1, 16[r10]
1293:../src/wolfcrypt/src/rsa.c ****     if (hLen < 0)
 1884                             		.loc 2 1293 8
 1885 002a ED A5 04                		mov.L	16[r10], r5
 1886 002d 61 05                   		cmp	#0, r5
 1887 002f 28 08                   		bge	.L118
1294:../src/wolfcrypt/src/rsa.c ****         return hLen;
 1888                             		.loc 2 1294 16
 1889 0031 ED A5 04                		mov.L	16[r10], r5
 1890 0034 38 40 02                		bra	.L138
 1891                             	.L118:
1295:../src/wolfcrypt/src/rsa.c ****     if ((int)inputLen != hLen) {
 1892                             		.loc 2 1295 9
 1893 0037 ED A5 1B                		mov.L	108[r10], r5
 1894                             		.loc 2 1295 8
 1895 003a ED A4 04                		mov.L	16[r10], r4
 1896 003d 47 54                   		cmp	r5, r4
 1897 003f 10                      		beq	.L120
1296:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 1898                             		.loc 2 1296 16
 1899 0040 FB 5A 53 FF             		mov.L	#-173, r5
 1900 0044 38 30 02                		bra	.L138
 1901                             	.L120:
1297:../src/wolfcrypt/src/rsa.c ****     }
1298:../src/wolfcrypt/src/rsa.c **** 
1299:../src/wolfcrypt/src/rsa.c ****     hiBits = (bits - 1) & 0x7;
 1902                             		.loc 2 1299 20
 1903 0047 A9 65                   		mov.L	16[r6], r5
 1904 0049 60 15                   		sub	#1, r5
 1905                             		.loc 2 1299 12
 1906 004b 64 75                   		and	#7, r5
 1907 004d E7 A5 05                		mov.L	r5, 20[r10]
1300:../src/wolfcrypt/src/rsa.c ****     if (hiBits == 0) {
 1908                             		.loc 2 1300 8
 1909 0050 ED A5 05                		mov.L	20[r10], r5
 1910 0053 61 05                   		cmp	#0, r5
 1911 0055 21 16                   		bne	.L121
1301:../src/wolfcrypt/src/rsa.c ****         /* Per RFC8017, set the leftmost 8emLen - emBits bits of the
1302:../src/wolfcrypt/src/rsa.c ****            leftmost octet in DB to zero.
1303:../src/wolfcrypt/src/rsa.c ****         */
1304:../src/wolfcrypt/src/rsa.c ****         *(pkcsBlock++) = 0;
 1912                             		.loc 2 1304 20
 1913 0057 ED A5 1C                		mov.L	112[r10], r5
 1914 005a 71 54 01                		add	#1, r5, r4
 1915 005d E7 A4 1C                		mov.L	r4, 112[r10]
 1916                             		.loc 2 1304 24
 1917 0060 F8 54 00                		mov.B	#0, [r5]
1305:../src/wolfcrypt/src/rsa.c ****         pkcsBlockLen--;
 1918                             		.loc 2 1305 21
 1919 0063 ED A5 1D                		mov.L	116[r10], r5
 1920 0066 60 15                   		sub	#1, r5
 1921 0068 E7 A5 1D                		mov.L	r5, 116[r10]
 1922                             	.L121:
1306:../src/wolfcrypt/src/rsa.c ****     }
1307:../src/wolfcrypt/src/rsa.c **** 
1308:../src/wolfcrypt/src/rsa.c ****     if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 1923                             		.loc 2 1308 8
 1924 006b A8 ED                   		mov.L	12[r6], r5
 1925 006d 75 05 FF                		cmp	#-1, r5
 1926 0070 21 1C                   		bne	.L122
1309:../src/wolfcrypt/src/rsa.c ****         saltLen = hLen;
 1927                             		.loc 2 1309 17
 1928 0072 ED A5 04                		mov.L	16[r10], r5
 1929 0075 A0 ED                   		mov.L	r5, 12[r6]
1310:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_SHA512
1311:../src/wolfcrypt/src/rsa.c ****             /* See FIPS 186-4 section 5.5 item (e). */
1312:../src/wolfcrypt/src/rsa.c ****             if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE) {
 1930                             		.loc 2 1312 16
 1931 0077 A9 65                   		mov.L	16[r6], r5
 1932 0079 76 05 00 04             		cmp	#0x400, r5
 1933 007d 21 2D                   		bne	.L124
 1934                             		.loc 2 1312 30 discriminator 1
 1935 007f ED A5 04                		mov.L	16[r10], r5
 1936 0082 75 55 40                		cmp	#0x40, r5
 1937 0085 21 25                   		bne	.L124
1313:../src/wolfcrypt/src/rsa.c ****                 saltLen = RSA_PSS_SALT_MAX_SZ;
 1938                             		.loc 2 1313 25
 1939 0087 3E 63 3E                		mov.L	#62, 12[r6]
 1940 008a 2E 20                   		bra	.L124
 1941                             	.L122:
1314:../src/wolfcrypt/src/rsa.c ****             }
1315:../src/wolfcrypt/src/rsa.c ****         #endif
1316:../src/wolfcrypt/src/rsa.c ****     }
1317:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_LONG_SALT
1318:../src/wolfcrypt/src/rsa.c ****     else if (saltLen > hLen) {
 1942                             		.loc 2 1318 13
 1943 008c A8 EC                   		mov.L	12[r6], r4
 1944 008e ED A5 04                		mov.L	16[r10], r5
 1945 0091 47 54                   		cmp	r5, r4
 1946 0093 2B 09                   		ble	.L125
1319:../src/wolfcrypt/src/rsa.c ****         return PSS_SALTLEN_E;
 1947                             		.loc 2 1319 16
 1948 0095 FB 5A 06 FF             		mov.L	#-250, r5
 1949 0099 38 DB 01                		bra	.L138
 1950                             	.L125:
1320:../src/wolfcrypt/src/rsa.c ****     }
1321:../src/wolfcrypt/src/rsa.c **** #endif
1322:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
1323:../src/wolfcrypt/src/rsa.c ****     else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {
 1951                             		.loc 2 1323 13
 1952 009c A8 ED                   		mov.L	12[r6], r5
 1953 009e 75 05 FF                		cmp	#-1, r5
 1954 00a1 28 09                   		bge	.L124
1324:../src/wolfcrypt/src/rsa.c ****         return PSS_SALTLEN_E;
 1955                             		.loc 2 1324 16
 1956 00a3 FB 5A 06 FF             		mov.L	#-250, r5
 1957 00a7 38 CD 01                		bra	.L138
 1958                             	.L124:
1325:../src/wolfcrypt/src/rsa.c ****     }
1326:../src/wolfcrypt/src/rsa.c **** #else
1327:../src/wolfcrypt/src/rsa.c ****     else if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {
1328:../src/wolfcrypt/src/rsa.c ****         saltLen = (int)pkcsBlockLen - hLen - 2;
1329:../src/wolfcrypt/src/rsa.c ****         if (saltLen < 0) {
1330:../src/wolfcrypt/src/rsa.c ****             return PSS_SALTLEN_E;
1331:../src/wolfcrypt/src/rsa.c ****         }
1332:../src/wolfcrypt/src/rsa.c ****     }
1333:../src/wolfcrypt/src/rsa.c ****     else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER) {
1334:../src/wolfcrypt/src/rsa.c ****         return PSS_SALTLEN_E;
1335:../src/wolfcrypt/src/rsa.c ****     }
1336:../src/wolfcrypt/src/rsa.c **** #endif
1337:../src/wolfcrypt/src/rsa.c ****     if ((int)pkcsBlockLen - hLen < saltLen + 2) {
 1959                             		.loc 2 1337 34
 1960 00aa A8 ED                   		mov.L	12[r6], r5
 1961 00ac 71 54 01                		add	#1, r5, r4
 1962                             		.loc 2 1337 9
 1963 00af ED A3 1D                		mov.L	116[r10], r3
 1964                             		.loc 2 1337 27
 1965 00b2 ED A5 04                		mov.L	16[r10], r5
 1966 00b5 FF 05 53                		sub	r5, r3, r5
 1967                             		.loc 2 1337 8
 1968 00b8 47 54                   		cmp	r5, r4
 1969 00ba 29 09                   		blt	.L126
1338:../src/wolfcrypt/src/rsa.c ****         return PSS_SALTLEN_E;
 1970                             		.loc 2 1338 16
 1971 00bc FB 5A 06 FF             		mov.L	#-250, r5
 1972 00c0 38 B4 01                		bra	.L138
 1973                             	.L126:
1339:../src/wolfcrypt/src/rsa.c ****     }
1340:../src/wolfcrypt/src/rsa.c ****     maskLen = pkcsBlockLen - 1 - hLen;
 1974                             		.loc 2 1340 32
 1975 00c3 ED A5 04                		mov.L	16[r10], r5
 1976 00c6 ED A4 1D                		mov.L	116[r10], r4
 1977 00c9 FF 05 54                		sub	r5, r4, r5
 1978 00cc 60 15                   		sub	#1, r5
 1979                             		.loc 2 1340 13
 1980 00ce E7 A5 06                		mov.L	r5, 24[r10]
1341:../src/wolfcrypt/src/rsa.c **** 
1342:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)
1343:../src/wolfcrypt/src/rsa.c ****     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
1344:../src/wolfcrypt/src/rsa.c ****         msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,
1345:../src/wolfcrypt/src/rsa.c ****                                                        DYNAMIC_TYPE_RSA_BUFFER);
1346:../src/wolfcrypt/src/rsa.c ****         if (msg == NULL) {
1347:../src/wolfcrypt/src/rsa.c ****             return MEMORY_E;
1348:../src/wolfcrypt/src/rsa.c ****         }
1349:../src/wolfcrypt/src/rsa.c ****     #endif
1350:../src/wolfcrypt/src/rsa.c ****     salt = s = m = msg;
1351:../src/wolfcrypt/src/rsa.c ****     XMEMSET(m, 0, RSA_PSS_PAD_SZ);
1352:../src/wolfcrypt/src/rsa.c ****     m += RSA_PSS_PAD_SZ;
1353:../src/wolfcrypt/src/rsa.c ****     XMEMCPY(m, input, inputLen);
1354:../src/wolfcrypt/src/rsa.c ****     m += inputLen;
1355:../src/wolfcrypt/src/rsa.c ****     o = (int)(m - s);
1356:../src/wolfcrypt/src/rsa.c ****     if (saltLen > 0) {
1357:../src/wolfcrypt/src/rsa.c ****         ret = wc_RNG_GenerateBlock(rng, m, saltLen);
1358:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
1359:../src/wolfcrypt/src/rsa.c ****             m += saltLen;
1360:../src/wolfcrypt/src/rsa.c ****         }
1361:../src/wolfcrypt/src/rsa.c ****     }
1362:../src/wolfcrypt/src/rsa.c **** #else
1363:../src/wolfcrypt/src/rsa.c ****     if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen) {
 1981                             		.loc 2 1363 50
 1982 00d1 A8 ED                   		mov.L	12[r6], r5
 1983 00d3 06 89 A5 1B             		add	108[r10].L, r5
 1984 00d7 62 85                   		add	#8, r5
 1985                             		.loc 2 1363 8
 1986 00d9 ED A4 1D                		mov.L	116[r10], r4
 1987 00dc 47 54                   		cmp	r5, r4
 1988 00de 22 26                   		bgeu	.L127
1364:../src/wolfcrypt/src/rsa.c ****     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
1365:../src/wolfcrypt/src/rsa.c ****         msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,
 1989                             		.loc 2 1365 22
 1990 00e0 A8 ED                   		mov.L	12[r6], r5
 1991 00e2 06 89 A5 1B             		add	108[r10].L, r5
 1992 00e6 62 85                   		add	#8, r5
 1993 00e8 EF 51                   		mov.L	r5, r1
 1994 00ea 05 00 00 00             		bsr	_wolfSSL_Malloc
 1995 00ee E7 A1 03                		mov.L	r1, 12[r10]
1366:../src/wolfcrypt/src/rsa.c ****                                                        DYNAMIC_TYPE_RSA_BUFFER);
1367:../src/wolfcrypt/src/rsa.c ****         if (msg == NULL) {
 1996                             		.loc 2 1367 12
 1997 00f1 ED A5 03                		mov.L	12[r10], r5
 1998 00f4 61 05                   		cmp	#0, r5
 1999 00f6 1F                      		bne	.L128
1368:../src/wolfcrypt/src/rsa.c ****             return MEMORY_E;
 2000                             		.loc 2 1368 20
 2001 00f7 FB 56 83                		mov.L	#-125, r5
 2002 00fa 38 7A 01                		bra	.L138
 2003                             	.L128:
1369:../src/wolfcrypt/src/rsa.c ****         }
1370:../src/wolfcrypt/src/rsa.c ****     #endif
1371:../src/wolfcrypt/src/rsa.c ****         m = msg;
 2004                             		.loc 2 1371 11
 2005 00fd ED A5 03                		mov.L	12[r10], r5
 2006 0100 E7 A5 02                		mov.L	r5, 8[r10]
 2007 0103 0F                      		bra	.L129
 2008                             	.L127:
1372:../src/wolfcrypt/src/rsa.c ****     }
1373:../src/wolfcrypt/src/rsa.c ****     else {
1374:../src/wolfcrypt/src/rsa.c ****         m = pkcsBlock;
 2009                             		.loc 2 1374 11
 2010 0104 ED A5 1C                		mov.L	112[r10], r5
 2011 0107 E7 A5 02                		mov.L	r5, 8[r10]
 2012                             	.L129:
1375:../src/wolfcrypt/src/rsa.c ****     }
1376:../src/wolfcrypt/src/rsa.c ****     s = m;
 2013                             		.loc 2 1376 7
 2014 010a ED A5 02                		mov.L	8[r10], r5
 2015 010d E7 A5 07                		mov.L	r5, 28[r10]
1377:../src/wolfcrypt/src/rsa.c ****     XMEMSET(m, 0, RSA_PSS_PAD_SZ);
 2016                             		.loc 2 1377 5
 2017 0110 66 83                   		mov.L	#8, r3
 2018 0112 66 02                   		mov.L	#0, r2
 2019 0114 ED A1 02                		mov.L	8[r10], r1
 2020 0117 05 00 00 00             		bsr	_memset
1378:../src/wolfcrypt/src/rsa.c ****     m += RSA_PSS_PAD_SZ;
 2021                             		.loc 2 1378 7
 2022 011b ED A5 02                		mov.L	8[r10], r5
 2023 011e 62 85                   		add	#8, r5
 2024 0120 E7 A5 02                		mov.L	r5, 8[r10]
1379:../src/wolfcrypt/src/rsa.c ****     XMEMCPY(m, input, inputLen);
 2025                             		.loc 2 1379 5
 2026 0123 ED A3 1B                		mov.L	108[r10], r3
 2027 0126 ED A2 1A                		mov.L	104[r10], r2
 2028 0129 ED A1 02                		mov.L	8[r10], r1
 2029 012c 05 00 00 00             		bsr	_memcpy
1380:../src/wolfcrypt/src/rsa.c ****     m += inputLen;
 2030                             		.loc 2 1380 7
 2031 0130 ED A5 02                		mov.L	8[r10], r5
 2032 0133 06 89 A5 1B             		add	108[r10].L, r5
 2033 0137 E7 A5 02                		mov.L	r5, 8[r10]
1381:../src/wolfcrypt/src/rsa.c ****     o = 0;
 2034                             		.loc 2 1381 7
 2035 013a F9 A6 08 00             		mov.L	#0, 32[r10]
1382:../src/wolfcrypt/src/rsa.c ****     if (saltLen > 0) {
 2036                             		.loc 2 1382 8
 2037 013e A8 ED                   		mov.L	12[r6], r5
 2038 0140 61 05                   		cmp	#0, r5
 2039 0142 2B 33                   		ble	.L130
1383:../src/wolfcrypt/src/rsa.c ****         ret = wc_RNG_GenerateBlock(rng, salt, saltLen);
 2040                             		.loc 2 1383 15
 2041 0144 A8 EC                   		mov.L	12[r6], r4
 2042 0146 71 A5 28                		add	#40, r10, r5
 2043 0149 EF 43                   		mov.L	r4, r3
 2044 014b EF 52                   		mov.L	r5, r2
 2045 014d EC 61                   		mov.L	[r6], r1
 2046 014f 05 00 00 00             		bsr	_wc_RNG_GenerateBlock
 2047 0153 E3 A1                   		mov.L	r1, [r10]
1384:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 2048                             		.loc 2 1384 12
 2049 0155 EC A5                   		mov.L	[r10], r5
 2050 0157 61 05                   		cmp	#0, r5
 2051 0159 21 1C                   		bne	.L130
1385:../src/wolfcrypt/src/rsa.c ****             XMEMCPY(m, salt, saltLen);
 2052                             		.loc 2 1385 13
 2053 015b A8 EC                   		mov.L	12[r6], r4
 2054 015d 71 A5 28                		add	#40, r10, r5
 2055 0160 EF 43                   		mov.L	r4, r3
 2056 0162 EF 52                   		mov.L	r5, r2
 2057 0164 ED A1 02                		mov.L	8[r10], r1
 2058 0167 05 00 00 00             		bsr	_memcpy
1386:../src/wolfcrypt/src/rsa.c ****             m += saltLen;
 2059                             		.loc 2 1386 15
 2060 016b A8 ED                   		mov.L	12[r6], r5
 2061 016d ED A4 02                		mov.L	8[r10], r4
 2062 0170 4B 45                   		add	r4, r5
 2063 0172 E7 A5 02                		mov.L	r5, 8[r10]
 2064                             	.L130:
1387:../src/wolfcrypt/src/rsa.c ****         }
1388:../src/wolfcrypt/src/rsa.c ****     }
1389:../src/wolfcrypt/src/rsa.c **** #endif
1390:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 2065                             		.loc 2 1390 8
 2066 0175 EC A5                   		mov.L	[r10], r5
 2067 0177 61 05                   		cmp	#0, r5
 2068 0179 21 27                   		bne	.L131
1391:../src/wolfcrypt/src/rsa.c ****         /* Put Hash at end of pkcsBlock - 1 */
1392:../src/wolfcrypt/src/rsa.c ****         ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);
 2069                             		.loc 2 1392 44
 2070 017b ED A4 02                		mov.L	8[r10], r4
 2071 017e ED A5 07                		mov.L	28[r10], r5
 2072 0181 FF 05 54                		sub	r5, r4, r5
 2073                             		.loc 2 1392 15
 2074 0184 EF 53                   		mov.L	r5, r3
 2075 0186 ED A5 06                		mov.L	24[r10], r5
 2076 0189 ED A4 1C                		mov.L	112[r10], r4
 2077 018c 4B 45                   		add	r4, r5
 2078 018e ED A4 04                		mov.L	16[r10], r4
 2079 0191 E3 04                   		mov.L	r4, [r0]
 2080 0193 EF 54                   		mov.L	r5, r4
 2081 0195 ED A2 07                		mov.L	28[r10], r2
 2082 0198 A8 69                   		mov.L	4[r6], r1
 2083 019a 05 00 00 00             		bsr	_wc_Hash
 2084 019e E3 A1                   		mov.L	r1, [r10]
 2085                             	.L131:
1393:../src/wolfcrypt/src/rsa.c ****     }
1394:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 2086                             		.loc 2 1394 8
 2087 01a0 EC A5                   		mov.L	[r10], r5
 2088 01a2 61 05                   		cmp	#0, r5
 2089 01a4 21 30                   		bne	.L132
1395:../src/wolfcrypt/src/rsa.c ****        /* Set the last eight bits or trailer field to the octet 0xbc */
1396:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;
 2090                             		.loc 2 1396 18
 2091 01a6 ED A5 1D                		mov.L	116[r10], r5
 2092 01a9 60 15                   		sub	#1, r5
 2093 01ab ED A4 1C                		mov.L	112[r10], r4
 2094 01ae 4B 45                   		add	r4, r5
 2095                             		.loc 2 1396 37
 2096 01b0 F8 54 BC                		mov.B	#-68, [r5]
1397:../src/wolfcrypt/src/rsa.c **** 
1398:../src/wolfcrypt/src/rsa.c ****         ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);
 2097                             		.loc 2 1398 15
 2098 01b3 ED A5 06                		mov.L	24[r10], r5
 2099 01b6 ED A4 1C                		mov.L	112[r10], r4
 2100 01b9 4B 45                   		add	r4, r5
 2101 01bb ED A3 04                		mov.L	16[r10], r3
 2102 01be ED A4 06                		mov.L	24[r10], r4
 2103 01c1 A9 6A                   		mov.L	20[r6], r2
 2104 01c3 A0 0A                   		mov.L	r2, 4[r0]
 2105 01c5 E3 04                   		mov.L	r4, [r0]
 2106 01c7 ED A4 1C                		mov.L	112[r10], r4
 2107 01ca EF 52                   		mov.L	r5, r2
 2108 01cc A8 E1                   		mov.L	8[r6], r1
 2109 01ce 05 00 00 00             		bsr	_RsaMGF
 2110 01d2 E3 A1                   		mov.L	r1, [r10]
 2111                             	.L132:
1399:../src/wolfcrypt/src/rsa.c ****     }
1400:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 2112                             		.loc 2 1400 8
 2113 01d4 EC A5                   		mov.L	[r10], r5
 2114 01d6 61 05                   		cmp	#0, r5
 2115 01d8 3B 87 00                		bne	.L133
1401:../src/wolfcrypt/src/rsa.c ****         /* Clear the first high bit when "8emLen - emBits" is non-zero.
1402:../src/wolfcrypt/src/rsa.c ****            where emBits = n modBits - 1 */
1403:../src/wolfcrypt/src/rsa.c ****         if (hiBits)
 2116                             		.loc 2 1403 12
 2117 01db ED A5 05                		mov.L	20[r10], r5
 2118 01de 61 05                   		cmp	#0, r5
 2119 01e0 20 20                   		beq	.L134
1404:../src/wolfcrypt/src/rsa.c ****             pkcsBlock[0] &= (1 << hiBits) - 1;
 2120                             		.loc 2 1404 26
 2121 01e2 ED A5 1C                		mov.L	112[r10], r5
 2122 01e5 CC 55                   		mov.B	[r5], r5
 2123 01e7 CF 53                   		mov.B	r5, r3
 2124                             		.loc 2 1404 32
 2125 01e9 66 14                   		mov.L	#1, r4
 2126 01eb ED A5 05                		mov.L	20[r10], r5
 2127 01ee EF 47                   		mov.L	r4, r7
 2128 01f0 FD 62 57                		shll	r5, r7
 2129 01f3 EF 75                   		mov.L	r7, r5
 2130                             		.loc 2 1404 43
 2131 01f5 60 15                   		sub	#1, r5
 2132                             		.loc 2 1404 26
 2133 01f7 53 35                   		and	r3, r5
 2134 01f9 CF 54                   		mov.B	r5, r4
 2135 01fb ED A5 1C                		mov.L	112[r10], r5
 2136 01fe C3 54                   		mov.B	r4, [r5]
 2137                             	.L134:
1405:../src/wolfcrypt/src/rsa.c **** 
1406:../src/wolfcrypt/src/rsa.c ****         m = pkcsBlock + maskLen - saltLen - 1;
 2138                             		.loc 2 1406 33
 2139 0200 ED A4 06                		mov.L	24[r10], r4
 2140 0203 A8 ED                   		mov.L	12[r6], r5
 2141 0205 FF 05 54                		sub	r5, r4, r5
 2142                             		.loc 2 1406 43
 2143 0208 60 15                   		sub	#1, r5
 2144                             		.loc 2 1406 11
 2145 020a ED A4 1C                		mov.L	112[r10], r4
 2146 020d 4B 45                   		add	r4, r5
 2147 020f E7 A5 02                		mov.L	r5, 8[r10]
1407:../src/wolfcrypt/src/rsa.c ****         *(m++) ^= 0x01;
 2148                             		.loc 2 1407 12
 2149 0212 ED A5 02                		mov.L	8[r10], r5
 2150 0215 71 54 01                		add	#1, r5, r4
 2151 0218 E7 A4 02                		mov.L	r4, 8[r10]
 2152                             		.loc 2 1407 16
 2153 021b CC 54                   		mov.B	[r5], r4
 2154 021d FD 74 D4 01             		xor	#1, r4
 2155 0221 C3 54                   		mov.B	r4, [r5]
1408:../src/wolfcrypt/src/rsa.c ****         for (i = 0; i < saltLen; i++) {
 2156                             		.loc 2 1408 16
 2157 0223 F9 A6 01 00             		mov.L	#0, 4[r10]
 2158                             		.loc 2 1408 9
 2159 0227 2E 2F                   		bra	.L135
 2160                             	.L136:
1409:../src/wolfcrypt/src/rsa.c ****             m[i] ^= salt[o + i];
 2161                             		.loc 2 1409 18 discriminator 3
 2162 0229 ED A5 01                		mov.L	4[r10], r5
 2163 022c ED A4 02                		mov.L	8[r10], r4
 2164 022f 4B 45                   		add	r4, r5
 2165 0231 CC 52                   		mov.B	[r5], r2
 2166                             		.loc 2 1409 28 discriminator 3
 2167 0233 ED A5 08                		mov.L	32[r10], r5
 2168 0236 06 89 A5 01             		add	4[r10].L, r5
 2169                             		.loc 2 1409 25 discriminator 3
 2170 023a 4B A5                   		add	r10, r5
 2171 023c CD 53 28                		mov.B	40[r5], r3
 2172                             		.loc 2 1409 18 discriminator 3
 2173 023f ED A5 01                		mov.L	4[r10], r5
 2174 0242 ED A4 02                		mov.L	8[r10], r4
 2175 0245 4B 45                   		add	r4, r5
 2176 0247 EF 24                   		mov.L	r2, r4
 2177 0249 FC 37 34                		xor	r3, r4
 2178 024c C3 54                   		mov.B	r4, [r5]
1408:../src/wolfcrypt/src/rsa.c ****         for (i = 0; i < saltLen; i++) {
 2179                             		.loc 2 1408 35 discriminator 3
 2180 024e ED A5 01                		mov.L	4[r10], r5
 2181 0251 62 15                   		add	#1, r5
 2182 0253 E7 A5 01                		mov.L	r5, 4[r10]
 2183                             	.L135:
1408:../src/wolfcrypt/src/rsa.c ****         for (i = 0; i < saltLen; i++) {
 2184                             		.loc 2 1408 9 discriminator 1
 2185 0256 ED A4 01                		mov.L	4[r10], r4
 2186 0259 A8 ED                   		mov.L	12[r6], r5
 2187 025b 47 54                   		cmp	r5, r4
 2188 025d 29 CC                   		blt	.L136
 2189                             	.L133:
 2190                             	.LBB27:
1410:../src/wolfcrypt/src/rsa.c ****         }
1411:../src/wolfcrypt/src/rsa.c ****     }
1412:../src/wolfcrypt/src/rsa.c **** 
1413:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
1414:../src/wolfcrypt/src/rsa.c ****     /* msg is always not NULL as we bail on allocation failure */
1415:../src/wolfcrypt/src/rsa.c ****     XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);
 2191                             		.loc 2 1415 5
 2192 025f ED A5 03                		mov.L	12[r10], r5
 2193 0262 E7 A5 09                		mov.L	r5, 36[r10]
 2194 0265 ED A5 09                		mov.L	36[r10], r5
 2195 0268 61 05                   		cmp	#0, r5
 2196 026a 10                      		beq	.L137
 2197                             		.loc 2 1415 5 is_stmt 0 discriminator 1
 2198 026b ED A1 09                		mov.L	36[r10], r1
 2199 026e 05 00 00 00             		bsr	_wolfSSL_Free
 2200                             	.L137:
 2201                             	.LBE27:
1416:../src/wolfcrypt/src/rsa.c **** #endif
1417:../src/wolfcrypt/src/rsa.c ****     return ret;
 2202                             		.loc 2 1417 12 is_stmt 1
 2203 0272 EC A5                   		mov.L	[r10], r5
 2204                             		.balign 8,3,1
 2205                             	.L138:
1418:../src/wolfcrypt/src/rsa.c **** }
 2206                             		.loc 2 1418 1 discriminator 1
 2207 0274 EF 51                   		mov.L	r5, r1
 2208 0276 3F 6A 2B                		rtsd	#172, r6-r10
 2209                             	.LFE50:
 2211 0279 FD 70 40 00 00 00 80    		.section C,"a",@progbits
 2212                             		.p2align 2
 2213                             	.LC4:
 2214 00ac 52 73 61 50 61 64 20 65 		.string	"RsaPad error, invalid length"
 2214      72 72 6F 72 2C 20 69 6E 
 2214      76 61 6C 69 64 20 6C 65 
 2214      6E 67 74 68 00 
 2215                             		.section	.text.RsaPad,"ax",@progbits
 2217                             	_RsaPad:
 2218                             	.LFB51:
1419:../src/wolfcrypt/src/rsa.c **** #endif /* WC_RSA_PSS */
1420:../src/wolfcrypt/src/rsa.c **** #endif /* !WC_NO_RNG */
1421:../src/wolfcrypt/src/rsa.c **** 
1422:../src/wolfcrypt/src/rsa.c **** static int RsaPad(const byte* input, word32 inputLen, byte* pkcsBlock,
1423:../src/wolfcrypt/src/rsa.c ****                            word32 pkcsBlockLen, byte padValue, WC_RNG* rng)
1424:../src/wolfcrypt/src/rsa.c **** {
 2219                             		.loc 2 1424 1
 2220 0000 7E AA                   		push.l	r10
 2221                             	.LCFI51:
 2222 0002 71 0A DC                		add	#-36, r0, r10
 2223                             	.LCFI52:
 2224 0005 EF A0                   		mov.L	r10, r0
 2225 0007 75 45 2C                		mov.L	#44, r5
 2226 000a 4B A5                   		add	r10, r5
 2227 000c E7 A1 03                		mov.L	r1, 12[r10]
 2228 000f E7 A2 04                		mov.L	r2, 16[r10]
 2229 0012 E7 A3 05                		mov.L	r3, 20[r10]
 2230 0015 E7 A4 06                		mov.L	r4, 24[r10]
1425:../src/wolfcrypt/src/rsa.c ****     if (input == NULL || inputLen == 0 || pkcsBlock == NULL ||
 2231                             		.loc 2 1425 8
 2232 0018 ED A4 03                		mov.L	12[r10], r4
 2233 001b 61 04                   		cmp	#0, r4
 2234 001d 20 15                   		beq	.L140
 2235                             		.loc 2 1425 23 discriminator 1
 2236 001f ED A4 04                		mov.L	16[r10], r4
 2237 0022 61 04                   		cmp	#0, r4
 2238 0024 20 0E                   		beq	.L140
 2239                             		.loc 2 1425 40 discriminator 2
 2240 0026 ED A4 05                		mov.L	20[r10], r4
 2241 0029 61 04                   		cmp	#0, r4
 2242 002b 17                      		beq	.L140
 2243                             		.loc 2 1425 61 discriminator 3
 2244 002c ED A4 06                		mov.L	24[r10], r4
 2245 002f 61 04                   		cmp	#0, r4
 2246 0031 18                      		bne	.L141
 2247                             		.balign 8,3,2
 2248                             	.L140:
1426:../src/wolfcrypt/src/rsa.c ****                                                         pkcsBlockLen == 0) {
1427:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 2249                             		.loc 2 1427 16
 2250 0032 FB 5A 53 FF             		mov.L	#-173, r5
 2251 0036 38 E4 00                		bra	.L142
 2252                             	.L141:
1428:../src/wolfcrypt/src/rsa.c ****     }
1429:../src/wolfcrypt/src/rsa.c **** 
1430:../src/wolfcrypt/src/rsa.c ****     if (pkcsBlockLen - RSA_MIN_PAD_SZ < inputLen) {
 2253                             		.loc 2 1430 22
 2254 0039 ED A4 06                		mov.L	24[r10], r4
 2255 003c 60 B4                   		sub	#11, r4
 2256                             		.loc 2 1430 8
 2257 003e ED A3 04                		mov.L	16[r10], r3
 2258 0041 47 43                   		cmp	r4, r3
 2259 0043 25 13                   		bleu	.L143
1431:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("RsaPad error, invalid length");
 2260                             		.loc 2 1431 9
 2261 0045 FB 12 AC 00 00 00       		mov.L	#.LC4, r1
 2262 004b 05 00 00 00             		bsr	_WOLFSSL_MSG
1432:../src/wolfcrypt/src/rsa.c ****         return RSA_PAD_E;
 2263                             		.loc 2 1432 16
 2264 004f FB 5A 37 FF             		mov.L	#-201, r5
 2265 0053 38 C7 00                		bra	.L142
 2266                             	.L143:
1433:../src/wolfcrypt/src/rsa.c ****     }
1434:../src/wolfcrypt/src/rsa.c ****     pkcsBlock[0] = 0x0;       /* set first byte to zero and advance */
 2267                             		.loc 2 1434 18
 2268 0056 ED A4 05                		mov.L	20[r10], r4
 2269 0059 F8 44 00                		mov.B	#0, [r4]
1435:../src/wolfcrypt/src/rsa.c ****     pkcsBlock++; pkcsBlockLen--;
 2270                             		.loc 2 1435 14
 2271 005c ED A4 05                		mov.L	20[r10], r4
 2272 005f 62 14                   		add	#1, r4
 2273 0061 E7 A4 05                		mov.L	r4, 20[r10]
 2274                             		.loc 2 1435 30
 2275 0064 ED A4 06                		mov.L	24[r10], r4
 2276 0067 60 14                   		sub	#1, r4
 2277 0069 E7 A4 06                		mov.L	r4, 24[r10]
1436:../src/wolfcrypt/src/rsa.c ****     pkcsBlock[0] = padValue;  /* insert padValue */
 2278                             		.loc 2 1436 18
 2279 006c ED A4 05                		mov.L	20[r10], r4
 2280 006f CC 53                   		mov.B	[r5], r3
 2281 0071 C3 43                   		mov.B	r3, [r4]
1437:../src/wolfcrypt/src/rsa.c **** 
1438:../src/wolfcrypt/src/rsa.c ****     if (padValue == RSA_BLOCK_TYPE_1) {
 2282                             		.loc 2 1438 8
 2283 0073 58 54                   		movu.B	[r5], r4
 2284 0075 61 14                   		cmp	#1, r4
 2285 0077 21 1E                   		bne	.L144
1439:../src/wolfcrypt/src/rsa.c **** 
1440:../src/wolfcrypt/src/rsa.c ****         /* pad with 0xff bytes */
1441:../src/wolfcrypt/src/rsa.c ****         XMEMSET(&pkcsBlock[1], 0xFF, pkcsBlockLen - inputLen - 2);
 2286                             		.loc 2 1441 9
 2287 0079 ED A5 05                		mov.L	20[r10], r5
 2288 007c 71 51 01                		add	#1, r5, r1
 2289 007f ED A4 06                		mov.L	24[r10], r4
 2290 0082 ED A5 04                		mov.L	16[r10], r5
 2291 0085 FF 05 54                		sub	r5, r4, r5
 2292 0088 60 25                   		sub	#2, r5
 2293 008a EF 53                   		mov.L	r5, r3
 2294 008c 75 42 FF                		mov.L	#0xff, r2
 2295 008f 05 00 00 00             		bsr	_memset
 2296 0093 2E 58                   		bra	.L145
 2297                             	.L144:
 2298                             	.LBB28:
1442:../src/wolfcrypt/src/rsa.c ****     }
1443:../src/wolfcrypt/src/rsa.c ****     else {
1444:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WC_NO_RNG)
1445:../src/wolfcrypt/src/rsa.c ****         /* pad with non-zero random bytes */
1446:../src/wolfcrypt/src/rsa.c ****         word32 padLen, i;
1447:../src/wolfcrypt/src/rsa.c ****         int    ret;
1448:../src/wolfcrypt/src/rsa.c ****         padLen = pkcsBlockLen - inputLen - 1;
 2299                             		.loc 2 1448 31
 2300 0095 ED A3 06                		mov.L	24[r10], r3
 2301 0098 ED A4 04                		mov.L	16[r10], r4
 2302 009b FF 04 43                		sub	r4, r3, r4
 2303                             		.loc 2 1448 16
 2304 009e 60 14                   		sub	#1, r4
 2305 00a0 E7 A4 01                		mov.L	r4, 4[r10]
1449:../src/wolfcrypt/src/rsa.c ****         ret    = wc_RNG_GenerateBlock(rng, &pkcsBlock[1], padLen);
 2306                             		.loc 2 1449 18
 2307 00a3 ED A4 05                		mov.L	20[r10], r4
 2308 00a6 62 14                   		add	#1, r4
 2309 00a8 ED A3 01                		mov.L	4[r10], r3
 2310 00ab EF 42                   		mov.L	r4, r2
 2311 00ad A8 59                   		mov.L	4[r5], r1
 2312 00af 05 00 00 00             		bsr	_wc_RNG_GenerateBlock
 2313 00b3 E7 A1 02                		mov.L	r1, 8[r10]
1450:../src/wolfcrypt/src/rsa.c ****         if (ret != 0) {
 2314                             		.loc 2 1450 12
 2315 00b6 ED A5 02                		mov.L	8[r10], r5
 2316 00b9 61 05                   		cmp	#0, r5
 2317 00bb 16                      		beq	.L146
1451:../src/wolfcrypt/src/rsa.c ****             return ret;
 2318                             		.loc 2 1451 20
 2319 00bc ED A5 02                		mov.L	8[r10], r5
 2320 00bf 2E 5B                   		bra	.L142
 2321                             	.L146:
1452:../src/wolfcrypt/src/rsa.c ****         }
1453:../src/wolfcrypt/src/rsa.c **** 
1454:../src/wolfcrypt/src/rsa.c ****         /* remove zeros */
1455:../src/wolfcrypt/src/rsa.c ****         for (i = 1; i < padLen; i++) {
 2322                             		.loc 2 1455 16
 2323 00c1 F8 A6 01                		mov.L	#1, [r10]
 2324                             		.loc 2 1455 9
 2325 00c4 2E 1E                   		bra	.L147
 2326                             	.L149:
1456:../src/wolfcrypt/src/rsa.c ****             if (pkcsBlock[i] == 0) pkcsBlock[i] = 0x01;
 2327                             		.loc 2 1456 26
 2328 00c6 ED A5 05                		mov.L	20[r10], r5
 2329 00c9 06 88 A5                		add	[r10].L, r5
 2330 00cc CC 55                   		mov.B	[r5], r5
 2331                             		.loc 2 1456 16
 2332 00ce 5B 55                   		movu.B	r5, r5
 2333 00d0 61 05                   		cmp	#0, r5
 2334 00d2 1A                      		bne	.L148
 2335                             		.loc 2 1456 45 discriminator 1
 2336 00d3 ED A5 05                		mov.L	20[r10], r5
 2337 00d6 06 88 A5                		add	[r10].L, r5
 2338                             		.loc 2 1456 49 discriminator 1
 2339 00d9 F8 54 01                		mov.B	#1, [r5]
 2340                             	.L148:
1455:../src/wolfcrypt/src/rsa.c ****             if (pkcsBlock[i] == 0) pkcsBlock[i] = 0x01;
 2341                             		.loc 2 1455 34 discriminator 2
 2342 00dc EC A5                   		mov.L	[r10], r5
 2343 00de 62 15                   		add	#1, r5
 2344 00e0 E3 A5                   		mov.L	r5, [r10]
 2345                             	.L147:
1455:../src/wolfcrypt/src/rsa.c ****             if (pkcsBlock[i] == 0) pkcsBlock[i] = 0x01;
 2346                             		.loc 2 1455 9 discriminator 1
 2347 00e2 EC A4                   		mov.L	[r10], r4
 2348 00e4 ED A5 01                		mov.L	4[r10], r5
 2349 00e7 47 54                   		cmp	r5, r4
 2350 00e9 23 DD                   		bltu	.L149
 2351                             	.L145:
 2352                             	.LBE28:
1457:../src/wolfcrypt/src/rsa.c ****         }
1458:../src/wolfcrypt/src/rsa.c **** #else
1459:../src/wolfcrypt/src/rsa.c ****         (void)rng;
1460:../src/wolfcrypt/src/rsa.c ****         return RSA_WRONG_TYPE_E;
1461:../src/wolfcrypt/src/rsa.c **** #endif
1462:../src/wolfcrypt/src/rsa.c ****     }
1463:../src/wolfcrypt/src/rsa.c **** 
1464:../src/wolfcrypt/src/rsa.c ****     pkcsBlock[pkcsBlockLen-inputLen-1] = 0;     /* separator */
 2353                             		.loc 2 1464 27
 2354 00eb ED A4 06                		mov.L	24[r10], r4
 2355 00ee ED A5 04                		mov.L	16[r10], r5
 2356 00f1 FF 05 54                		sub	r5, r4, r5
 2357                             		.loc 2 1464 14
 2358 00f4 60 15                   		sub	#1, r5
 2359 00f6 ED A4 05                		mov.L	20[r10], r4
 2360 00f9 4B 45                   		add	r4, r5
 2361                             		.loc 2 1464 40
 2362 00fb F8 54 00                		mov.B	#0, [r5]
1465:../src/wolfcrypt/src/rsa.c ****     XMEMCPY(pkcsBlock+pkcsBlockLen-inputLen, input, inputLen);
 2363                             		.loc 2 1465 5
 2364 00fe ED A4 06                		mov.L	24[r10], r4
 2365 0101 ED A5 04                		mov.L	16[r10], r5
 2366 0104 FF 05 54                		sub	r5, r4, r5
 2367 0107 ED A4 05                		mov.L	20[r10], r4
 2368 010a 4B 45                   		add	r4, r5
 2369 010c ED A3 04                		mov.L	16[r10], r3
 2370 010f ED A2 03                		mov.L	12[r10], r2
 2371 0112 EF 51                   		mov.L	r5, r1
 2372 0114 05 00 00 00             		bsr	_memcpy
1466:../src/wolfcrypt/src/rsa.c **** 
1467:../src/wolfcrypt/src/rsa.c ****     return 0;
 2373                             		.loc 2 1467 12
 2374 0118 66 05                   		mov.L	#0, r5
 2375                             		.balign 8,3,1
 2376                             	.L142:
1468:../src/wolfcrypt/src/rsa.c **** }
 2377                             		.loc 2 1468 1
 2378 011a EF 51                   		mov.L	r5, r1
 2379 011c 3F AA 0A                		rtsd	#40, r10-r10
 2380                             	.LFE51:
 2382 011f 03                      		.section C,"a",@progbits
 2383 00c9 00 00 00                		.p2align 2
 2384                             	.LC5:
 2385 00cc 77 6F 6C 66 53 53 4C 20 		.string	"wolfSSL Using RSA OAEP padding"
 2385      55 73 69 6E 67 20 52 53 
 2385      41 20 4F 41 45 50 20 70 
 2385      61 64 64 69 6E 67 00 
 2386                             	.LC6:
 2387 00eb 77 6F 6C 66 53 53 4C 20 		.string	"wolfSSL Using RSA PSS padding"
 2387      55 73 69 6E 67 20 52 53 
 2387      41 20 50 53 53 20 70 61 
 2387      64 64 69 6E 67 00 
 2388                             	.LC7:
 2389 0109 55 6E 6B 6E 6F 77 6E 20 		.string	"Unknown RSA Pad Type"
 2389      52 53 41 20 50 61 64 20 
 2389      54 79 70 65 00 
 2390                             		.section	.text.wc_RsaPad_ex,"ax",@progbits
 2391                             		.global	_wc_RsaPad_ex
 2393                             	_wc_RsaPad_ex:
 2394                             	.LFB52:
1469:../src/wolfcrypt/src/rsa.c **** 
1470:../src/wolfcrypt/src/rsa.c **** /* helper function to direct which padding is used */
1471:../src/wolfcrypt/src/rsa.c **** int wc_RsaPad_ex(const byte* input, word32 inputLen, byte* pkcsBlock,
1472:../src/wolfcrypt/src/rsa.c ****     word32 pkcsBlockLen, byte padValue, WC_RNG* rng, int padType,
1473:../src/wolfcrypt/src/rsa.c ****     enum wc_HashType hType, int mgf, byte* optLabel, word32 labelLen,
1474:../src/wolfcrypt/src/rsa.c ****     int saltLen, int bits, void* heap)
1475:../src/wolfcrypt/src/rsa.c **** {
 2395                             		.loc 2 1475 1
 2396 0000 7E AA                   		push.l	r10
 2397                             	.LCFI53:
 2398 0002 7E A6                   		push.l	r6
 2399                             	.LCFI54:
 2400 0004 71 0A C4                		add	#-60, r0, r10
 2401                             	.LCFI55:
 2402 0007 71 A0 E4                		add	#-28, r10, r0
 2403                             	.LCFI56:
 2404 000a 75 46 48                		mov.L	#0x48, r6
 2405 000d 4B A6                   		add	r10, r6
 2406 000f E7 A1 01                		mov.L	r1, 4[r10]
 2407 0012 E7 A2 02                		mov.L	r2, 8[r10]
 2408 0015 E7 A3 03                		mov.L	r3, 12[r10]
 2409 0018 E7 A4 04                		mov.L	r4, 16[r10]
1476:../src/wolfcrypt/src/rsa.c ****     int ret;
1477:../src/wolfcrypt/src/rsa.c **** 
1478:../src/wolfcrypt/src/rsa.c ****     switch (padType)
 2410                             		.loc 2 1478 5
 2411 001b A8 E5                   		mov.L	8[r6], r5
 2412 001d 61 15                   		cmp	#1, r5
 2413 001f 20 2C                   		beq	.L151
 2414 0021 A8 E5                   		mov.L	8[r6], r5
 2415 0023 61 25                   		cmp	#2, r5
 2416 0025 20 60                   		beq	.L152
 2417 0027 A8 E5                   		mov.L	8[r6], r5
 2418 0029 61 05                   		cmp	#0, r5
 2419 002b 3B 90 00                		bne	.L153
1479:../src/wolfcrypt/src/rsa.c ****     {
1480:../src/wolfcrypt/src/rsa.c ****         case WC_RSA_PKCSV15_PAD:
1481:../src/wolfcrypt/src/rsa.c ****             /*WOLFSSL_MSG("wolfSSL Using RSA PKCSV15 padding");*/
1482:../src/wolfcrypt/src/rsa.c ****             ret = RsaPad(input, inputLen, pkcsBlock, pkcsBlockLen,
 2420                             		.loc 2 1482 19
 2421 002e A8 6D                   		mov.L	4[r6], r5
 2422 0030 A0 0D                   		mov.L	r5, 4[r0]
 2423 0032 CC 65                   		mov.B	[r6], r5
 2424 0034 C3 05                   		mov.B	r5, [r0]
 2425 0036 ED A4 04                		mov.L	16[r10], r4
 2426 0039 ED A3 03                		mov.L	12[r10], r3
 2427 003c ED A2 02                		mov.L	8[r10], r2
 2428 003f ED A1 01                		mov.L	4[r10], r1
 2429 0042 05 00 00 00             		bsr	_RsaPad
 2430 0046 E3 A1                   		mov.L	r1, [r10]
1483:../src/wolfcrypt/src/rsa.c ****                                                                  padValue, rng);
1484:../src/wolfcrypt/src/rsa.c ****             break;
 2431                             		.loc 2 1484 13
 2432 0048 38 81 00                		bra	.L154
 2433                             	.L151:
1485:../src/wolfcrypt/src/rsa.c **** 
1486:../src/wolfcrypt/src/rsa.c **** #ifndef WC_NO_RNG
1487:../src/wolfcrypt/src/rsa.c ****     #ifndef WC_NO_RSA_OAEP
1488:../src/wolfcrypt/src/rsa.c ****         case WC_RSA_OAEP_PAD:
1489:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("wolfSSL Using RSA OAEP padding");
 2434                             		.loc 2 1489 13
 2435 004b FB 12 CC 00 00 00       		mov.L	#.LC5, r1
 2436 0051 05 00 00 00             		bsr	_WOLFSSL_MSG
1490:../src/wolfcrypt/src/rsa.c ****             ret = RsaPad_OAEP(input, inputLen, pkcsBlock, pkcsBlockLen,
 2437                             		.loc 2 1490 19
 2438 0055 AA 6D                   		mov.L	36[r6], r5
 2439 0057 A1 85                   		mov.L	r5, 24[r0]
 2440 0059 A9 E5                   		mov.L	24[r6], r5
 2441 005b A1 0D                   		mov.L	r5, 20[r0]
 2442 005d A9 6D                   		mov.L	20[r6], r5
 2443 005f A1 05                   		mov.L	r5, 16[r0]
 2444 0061 A9 65                   		mov.L	16[r6], r5
 2445 0063 A0 8D                   		mov.L	r5, 12[r0]
 2446 0065 A8 ED                   		mov.L	12[r6], r5
 2447 0067 A0 85                   		mov.L	r5, 8[r0]
 2448 0069 A8 6D                   		mov.L	4[r6], r5
 2449 006b A0 0D                   		mov.L	r5, 4[r0]
 2450 006d CC 65                   		mov.B	[r6], r5
 2451 006f C3 05                   		mov.B	r5, [r0]
 2452 0071 ED A4 04                		mov.L	16[r10], r4
 2453 0074 ED A3 03                		mov.L	12[r10], r3
 2454 0077 ED A2 02                		mov.L	8[r10], r2
 2455 007a ED A1 01                		mov.L	4[r10], r1
 2456 007d 05 00 00 00             		bsr	_RsaPad_OAEP
 2457 0081 E3 A1                   		mov.L	r1, [r10]
1491:../src/wolfcrypt/src/rsa.c ****                            padValue, rng, hType, mgf, optLabel, labelLen, heap);
1492:../src/wolfcrypt/src/rsa.c ****             break;
 2458                             		.loc 2 1492 13
 2459 0083 2E 46                   		bra	.L154
 2460                             	.L152:
1493:../src/wolfcrypt/src/rsa.c ****     #endif
1494:../src/wolfcrypt/src/rsa.c **** 
1495:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_PSS
1496:../src/wolfcrypt/src/rsa.c ****         case WC_RSA_PSS_PAD:
1497:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("wolfSSL Using RSA PSS padding");
 2461                             		.loc 2 1497 13
 2462 0085 FB 12 EB 00 00 00       		mov.L	#.LC6, r1
 2463 008b 05 00 00 00             		bsr	_WOLFSSL_MSG
1498:../src/wolfcrypt/src/rsa.c ****             ret = RsaPad_PSS(input, inputLen, pkcsBlock, pkcsBlockLen, rng,
 2464                             		.loc 2 1498 19
 2465 008f AA 6D                   		mov.L	36[r6], r5
 2466 0091 A1 0D                   		mov.L	r5, 20[r0]
 2467 0093 AA 65                   		mov.L	32[r6], r5
 2468 0095 A1 05                   		mov.L	r5, 16[r0]
 2469 0097 A9 ED                   		mov.L	28[r6], r5
 2470 0099 A0 8D                   		mov.L	r5, 12[r0]
 2471 009b A9 65                   		mov.L	16[r6], r5
 2472 009d A0 85                   		mov.L	r5, 8[r0]
 2473 009f A8 ED                   		mov.L	12[r6], r5
 2474 00a1 A0 0D                   		mov.L	r5, 4[r0]
 2475 00a3 A8 6D                   		mov.L	4[r6], r5
 2476 00a5 E3 05                   		mov.L	r5, [r0]
 2477 00a7 ED A4 04                		mov.L	16[r10], r4
 2478 00aa ED A3 03                		mov.L	12[r10], r3
 2479 00ad ED A2 02                		mov.L	8[r10], r2
 2480 00b0 ED A1 01                		mov.L	4[r10], r1
 2481 00b3 05 00 00 00             		bsr	_RsaPad_PSS
 2482 00b7 E3 A1                   		mov.L	r1, [r10]
1499:../src/wolfcrypt/src/rsa.c ****                                                hType, mgf, saltLen, bits, heap);
1500:../src/wolfcrypt/src/rsa.c ****             break;
 2483                             		.loc 2 1500 13
 2484 00b9 2E 10                   		bra	.L154
 2485                             	.L153:
1501:../src/wolfcrypt/src/rsa.c ****     #endif
1502:../src/wolfcrypt/src/rsa.c **** #endif /* !WC_NO_RNG */
1503:../src/wolfcrypt/src/rsa.c **** 
1504:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_NO_PADDING
1505:../src/wolfcrypt/src/rsa.c ****         case WC_RSA_NO_PAD:
1506:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("wolfSSL Using NO padding");
1507:../src/wolfcrypt/src/rsa.c **** 
1508:../src/wolfcrypt/src/rsa.c ****             /* In the case of no padding being used check that input is exactly
1509:../src/wolfcrypt/src/rsa.c ****              * the RSA key length */
1510:../src/wolfcrypt/src/rsa.c ****             if (bits <= 0 || inputLen != ((word32)bits/WOLFSSL_BIT_SIZE)) {
1511:../src/wolfcrypt/src/rsa.c ****                 WOLFSSL_MSG("Bad input size");
1512:../src/wolfcrypt/src/rsa.c ****                 ret = RSA_PAD_E;
1513:../src/wolfcrypt/src/rsa.c ****             }
1514:../src/wolfcrypt/src/rsa.c ****             else {
1515:../src/wolfcrypt/src/rsa.c ****                 XMEMCPY(pkcsBlock, input, inputLen);
1516:../src/wolfcrypt/src/rsa.c ****                 ret = 0;
1517:../src/wolfcrypt/src/rsa.c ****             }
1518:../src/wolfcrypt/src/rsa.c ****             break;
1519:../src/wolfcrypt/src/rsa.c ****     #endif
1520:../src/wolfcrypt/src/rsa.c **** 
1521:../src/wolfcrypt/src/rsa.c ****         default:
1522:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("Unknown RSA Pad Type");
 2486                             		.loc 2 1522 13
 2487 00bb FB 12 09 01 00 00       		mov.L	#.LC7, r1
 2488 00c1 05 00 00 00             		bsr	_WOLFSSL_MSG
1523:../src/wolfcrypt/src/rsa.c ****             ret = RSA_PAD_E;
 2489                             		.loc 2 1523 17
 2490 00c5 F8 AA 37 FF             		mov.L	#-201, [r10]
 2491                             		.balign 8,3,1
 2492                             	.L154:
1524:../src/wolfcrypt/src/rsa.c ****     }
1525:../src/wolfcrypt/src/rsa.c **** 
1526:../src/wolfcrypt/src/rsa.c ****     /* silence warning if not used with padding scheme */
1527:../src/wolfcrypt/src/rsa.c ****     (void)input;
1528:../src/wolfcrypt/src/rsa.c ****     (void)inputLen;
1529:../src/wolfcrypt/src/rsa.c ****     (void)pkcsBlock;
1530:../src/wolfcrypt/src/rsa.c ****     (void)pkcsBlockLen;
1531:../src/wolfcrypt/src/rsa.c ****     (void)padValue;
1532:../src/wolfcrypt/src/rsa.c ****     (void)rng;
1533:../src/wolfcrypt/src/rsa.c ****     (void)padType;
1534:../src/wolfcrypt/src/rsa.c ****     (void)hType;
1535:../src/wolfcrypt/src/rsa.c ****     (void)mgf;
1536:../src/wolfcrypt/src/rsa.c ****     (void)optLabel;
1537:../src/wolfcrypt/src/rsa.c ****     (void)labelLen;
1538:../src/wolfcrypt/src/rsa.c ****     (void)saltLen;
1539:../src/wolfcrypt/src/rsa.c ****     (void)bits;
1540:../src/wolfcrypt/src/rsa.c ****     (void)heap;
1541:../src/wolfcrypt/src/rsa.c **** 
1542:../src/wolfcrypt/src/rsa.c ****     return ret;
 2493                             		.loc 2 1542 12
 2494 00c9 EC A5                   		mov.L	[r10], r5
1543:../src/wolfcrypt/src/rsa.c **** }
 2495                             		.loc 2 1543 1
 2496 00cb EF 51                   		mov.L	r5, r1
 2497 00cd 71 00 58                		add	#0x58, r0
 2498 00d0 7E B6                   		pop	r6
 2499 00d2 7E BA                   		pop	r10
 2500 00d4 02                      		rts
 2501                             	.LFE52:
 2503 00d5 FC 13 00                		.section	.text.RsaUnPad_OAEP,"ax",@progbits
 2505                             	_RsaUnPad_OAEP:
 2506                             	.LFB53:
1544:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_RSA_VERIFY_ONLY */
1545:../src/wolfcrypt/src/rsa.c **** 
1546:../src/wolfcrypt/src/rsa.c **** 
1547:../src/wolfcrypt/src/rsa.c **** /* UnPadding */
1548:../src/wolfcrypt/src/rsa.c **** #ifndef WC_NO_RSA_OAEP
1549:../src/wolfcrypt/src/rsa.c **** /* UnPad plaintext, set start to *output, return length of plaintext,
1550:../src/wolfcrypt/src/rsa.c ****  * < 0 on error */
1551:../src/wolfcrypt/src/rsa.c **** static int RsaUnPad_OAEP(byte *pkcsBlock, unsigned int pkcsBlockLen,
1552:../src/wolfcrypt/src/rsa.c ****                             byte **output, enum wc_HashType hType, int mgf,
1553:../src/wolfcrypt/src/rsa.c ****                             byte* optLabel, word32 labelLen, void* heap)
1554:../src/wolfcrypt/src/rsa.c **** {
 2507                             		.loc 2 1554 1
 2508 0000 7E AA                   		push.l	r10
 2509                             	.LCFI57:
 2510 0002 7E A6                   		push.l	r6
 2511                             	.LCFI58:
 2512 0004 72 0A 7C FF             		add	#-132, r0, r10
 2513                             	.LCFI59:
 2514 0008 71 A0 F8                		add	#-8, r10, r0
 2515                             	.LCFI60:
 2516 000b 75 46 90                		mov.L	#0x90, r6
 2517 000e 4B A6                   		add	r10, r6
 2518 0010 E7 A1 19                		mov.L	r1, 100[r10]
 2519 0013 E7 A2 1A                		mov.L	r2, 104[r10]
 2520 0016 E7 A3 1B                		mov.L	r3, 108[r10]
 2521 0019 E7 A4 1C                		mov.L	r4, 112[r10]
1555:../src/wolfcrypt/src/rsa.c ****     int hLen;
1556:../src/wolfcrypt/src/rsa.c ****     int ret;
1557:../src/wolfcrypt/src/rsa.c ****     byte h[WC_MAX_DIGEST_SIZE]; /* max digest size */
1558:../src/wolfcrypt/src/rsa.c ****     word32 idx;
1559:../src/wolfcrypt/src/rsa.c ****     word32 i;
1560:../src/wolfcrypt/src/rsa.c ****     word32 inc;
1561:../src/wolfcrypt/src/rsa.c **** 
1562:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
1563:../src/wolfcrypt/src/rsa.c ****     byte* tmp  = NULL;
 2522                             		.loc 2 1563 11
 2523 001c F9 A6 03 00             		mov.L	#0, 12[r10]
1564:../src/wolfcrypt/src/rsa.c **** #else
1565:../src/wolfcrypt/src/rsa.c ****     byte tmp[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];
1566:../src/wolfcrypt/src/rsa.c **** #endif
1567:../src/wolfcrypt/src/rsa.c **** 
1568:../src/wolfcrypt/src/rsa.c ****     /* no label is allowed, but catch if no label provided and length > 0 */
1569:../src/wolfcrypt/src/rsa.c ****     if (optLabel == NULL && labelLen > 0) {
 2524                             		.loc 2 1569 8
 2525 0020 A8 6D                   		mov.L	4[r6], r5
 2526 0022 61 05                   		cmp	#0, r5
 2527 0024 21 0E                   		bne	.L157
 2528                             		.loc 2 1569 26 discriminator 1
 2529 0026 A8 E5                   		mov.L	8[r6], r5
 2530 0028 61 05                   		cmp	#0, r5
 2531 002a 10                      		beq	.L157
1570:../src/wolfcrypt/src/rsa.c ****         return BUFFER_E;
 2532                             		.loc 2 1570 16
 2533 002b FB 5A 7C FF             		mov.L	#-132, r5
 2534 002f 38 84 02                		bra	.L174
 2535                             	.L157:
1571:../src/wolfcrypt/src/rsa.c ****     }
1572:../src/wolfcrypt/src/rsa.c **** 
1573:../src/wolfcrypt/src/rsa.c ****     hLen = wc_HashGetDigestSize(hType);
 2536                             		.loc 2 1573 12
 2537 0032 ED A1 1C                		mov.L	112[r10], r1
 2538 0035 05 00 00 00             		bsr	_wc_HashGetDigestSize
 2539 0039 E7 A1 04                		mov.L	r1, 16[r10]
1574:../src/wolfcrypt/src/rsa.c ****     if ((hLen < 0) || (pkcsBlockLen < (2 * (word32)hLen + 2))) {
 2540                             		.loc 2 1574 8
 2541 003c ED A5 04                		mov.L	16[r10], r5
 2542 003f 61 05                   		cmp	#0, r5
 2543 0041 29 10                   		blt	.L159
 2544                             		.loc 2 1574 44 discriminator 1
 2545 0043 ED A5 04                		mov.L	16[r10], r5
 2546                             		.loc 2 1574 57 discriminator 1
 2547 0046 62 15                   		add	#1, r5
 2548 0048 4B 55                   		add	r5, r5
 2549                             		.loc 2 1574 20 discriminator 1
 2550 004a ED A4 1A                		mov.L	104[r10], r4
 2551 004d 47 54                   		cmp	r5, r4
 2552 004f 22 09                   		bgeu	.L160
 2553                             	.L159:
1575:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 2554                             		.loc 2 1575 16
 2555 0051 FB 5A 53 FF             		mov.L	#-173, r5
 2556 0055 38 5E 02                		bra	.L174
 2557                             	.L160:
1576:../src/wolfcrypt/src/rsa.c ****     }
1577:../src/wolfcrypt/src/rsa.c **** 
1578:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
1579:../src/wolfcrypt/src/rsa.c ****     tmp = (byte*)XMALLOC(pkcsBlockLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 2558                             		.loc 2 1579 18
 2559 0058 ED A1 1A                		mov.L	104[r10], r1
 2560 005b 05 00 00 00             		bsr	_wolfSSL_Malloc
 2561 005f E7 A1 03                		mov.L	r1, 12[r10]
1580:../src/wolfcrypt/src/rsa.c ****     if (tmp == NULL) {
 2562                             		.loc 2 1580 8
 2563 0062 ED A5 03                		mov.L	12[r10], r5
 2564 0065 61 05                   		cmp	#0, r5
 2565 0067 1F                      		bne	.L161
1581:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
 2566                             		.loc 2 1581 16
 2567 0068 FB 56 83                		mov.L	#-125, r5
 2568 006b 38 48 02                		bra	.L174
 2569                             	.L161:
1582:../src/wolfcrypt/src/rsa.c ****     }
1583:../src/wolfcrypt/src/rsa.c **** #endif
1584:../src/wolfcrypt/src/rsa.c ****     XMEMSET(tmp, 0, pkcsBlockLen);
 2570                             		.loc 2 1584 5
 2571 006e ED A3 1A                		mov.L	104[r10], r3
 2572 0071 66 02                   		mov.L	#0, r2
 2573 0073 ED A1 03                		mov.L	12[r10], r1
 2574 0076 05 00 00 00             		bsr	_memset
1585:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
1586:../src/wolfcrypt/src/rsa.c ****     wc_MemZero_Add("OAEP UnPad temp", tmp, pkcsBlockLen);
1587:../src/wolfcrypt/src/rsa.c **** #endif
1588:../src/wolfcrypt/src/rsa.c **** 
1589:../src/wolfcrypt/src/rsa.c ****     /* find seedMask value */
1590:../src/wolfcrypt/src/rsa.c ****     if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 2575                             		.loc 2 1590 46
 2576 007a ED A5 04                		mov.L	16[r10], r5
 2577 007d 62 15                   		add	#1, r5
 2578                             		.loc 2 1590 16
 2579 007f ED A4 19                		mov.L	100[r10], r4
 2580 0082 FF 22 54                		add	r5, r4, r2
1591:../src/wolfcrypt/src/rsa.c ****                             pkcsBlockLen - hLen - 1, tmp, hLen, heap)) != 0) {
 2581                             		.loc 2 1591 42
 2582 0085 ED A5 04                		mov.L	16[r10], r5
 2583 0088 ED A4 1A                		mov.L	104[r10], r4
 2584 008b FF 05 54                		sub	r5, r4, r5
1590:../src/wolfcrypt/src/rsa.c ****                             pkcsBlockLen - hLen - 1, tmp, hLen, heap)) != 0) {
 2585                             		.loc 2 1590 16
 2586 008e 60 15                   		sub	#1, r5
 2587 0090 ED A4 04                		mov.L	16[r10], r4
 2588 0093 A8 EB                   		mov.L	12[r6], r3
 2589 0095 A0 0B                   		mov.L	r3, 4[r0]
 2590 0097 E3 04                   		mov.L	r4, [r0]
 2591 0099 ED A4 03                		mov.L	12[r10], r4
 2592 009c EF 53                   		mov.L	r5, r3
 2593 009e EC 61                   		mov.L	[r6], r1
 2594 00a0 05 00 00 00             		bsr	_RsaMGF
 2595 00a4 E7 A1 05                		mov.L	r1, 20[r10]
1590:../src/wolfcrypt/src/rsa.c ****                             pkcsBlockLen - hLen - 1, tmp, hLen, heap)) != 0) {
 2596                             		.loc 2 1590 8
 2597 00a7 ED A5 05                		mov.L	20[r10], r5
 2598 00aa 61 05                   		cmp	#0, r5
 2599 00ac 20 1B                   		beq	.L162
 2600                             	.LBB29:
1592:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
1593:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 2601                             		.loc 2 1593 9
 2602 00ae ED A5 03                		mov.L	12[r10], r5
 2603 00b1 E7 A5 06                		mov.L	r5, 24[r10]
 2604 00b4 ED A5 06                		mov.L	24[r10], r5
 2605 00b7 61 05                   		cmp	#0, r5
 2606 00b9 10                      		beq	.L163
 2607                             		.loc 2 1593 9 is_stmt 0 discriminator 1
 2608 00ba ED A1 06                		mov.L	24[r10], r1
 2609 00bd 05 00 00 00             		bsr	_wolfSSL_Free
 2610                             	.L163:
 2611                             	.LBE29:
1594:../src/wolfcrypt/src/rsa.c **** #endif
1595:../src/wolfcrypt/src/rsa.c ****         return ret;
 2612                             		.loc 2 1595 16 is_stmt 1
 2613 00c1 ED A5 05                		mov.L	20[r10], r5
 2614 00c4 38 EF 01                		bra	.L174
 2615                             	.L162:
1596:../src/wolfcrypt/src/rsa.c ****     }
1597:../src/wolfcrypt/src/rsa.c **** 
1598:../src/wolfcrypt/src/rsa.c ****     /* xor seedMask value with maskedSeed to get seed value */
1599:../src/wolfcrypt/src/rsa.c ****     for (idx = 0; idx < (word32)hLen; idx++) {
 2616                             		.loc 2 1599 14
 2617 00c7 F8 A6 00                		mov.L	#0, [r10]
 2618                             		.loc 2 1599 5
 2619 00ca 2E 26                   		bra	.L164
 2620                             	.L165:
1600:../src/wolfcrypt/src/rsa.c ****         tmp[idx] = tmp[idx] ^ pkcsBlock[1 + idx];
 2621                             		.loc 2 1600 23 discriminator 3
 2622 00cc ED A5 03                		mov.L	12[r10], r5
 2623 00cf 06 88 A5                		add	[r10].L, r5
 2624 00d2 CC 53                   		mov.B	[r5], r3
 2625                             		.loc 2 1600 43 discriminator 3
 2626 00d4 EC A5                   		mov.L	[r10], r5
 2627 00d6 62 15                   		add	#1, r5
 2628                             		.loc 2 1600 40 discriminator 3
 2629 00d8 ED A4 19                		mov.L	100[r10], r4
 2630 00db 4B 45                   		add	r4, r5
 2631 00dd CC 54                   		mov.B	[r5], r4
 2632                             		.loc 2 1600 12 discriminator 3
 2633 00df ED A5 03                		mov.L	12[r10], r5
 2634 00e2 06 88 A5                		add	[r10].L, r5
 2635                             		.loc 2 1600 18 discriminator 3
 2636 00e5 FC 37 34                		xor	r3, r4
 2637 00e8 C3 54                   		mov.B	r4, [r5]
1599:../src/wolfcrypt/src/rsa.c ****         tmp[idx] = tmp[idx] ^ pkcsBlock[1 + idx];
 2638                             		.loc 2 1599 42 discriminator 3
 2639 00ea EC A5                   		mov.L	[r10], r5
 2640 00ec 62 15                   		add	#1, r5
 2641 00ee E3 A5                   		mov.L	r5, [r10]
 2642                             	.L164:
1599:../src/wolfcrypt/src/rsa.c ****         tmp[idx] = tmp[idx] ^ pkcsBlock[1 + idx];
 2643                             		.loc 2 1599 25 discriminator 1
 2644 00f0 ED A5 04                		mov.L	16[r10], r5
1599:../src/wolfcrypt/src/rsa.c ****         tmp[idx] = tmp[idx] ^ pkcsBlock[1 + idx];
 2645                             		.loc 2 1599 5 discriminator 1
 2646 00f3 EC A4                   		mov.L	[r10], r4
 2647 00f5 47 54                   		cmp	r5, r4
 2648 00f7 23 D5                   		bltu	.L165
1601:../src/wolfcrypt/src/rsa.c ****     }
1602:../src/wolfcrypt/src/rsa.c **** 
1603:../src/wolfcrypt/src/rsa.c ****     /* get dbMask value */
1604:../src/wolfcrypt/src/rsa.c ****     if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 2649                             		.loc 2 1604 16
 2650 00f9 ED A2 04                		mov.L	16[r10], r2
 2651 00fc ED A5 04                		mov.L	16[r10], r5
 2652 00ff ED A4 03                		mov.L	12[r10], r4
 2653 0102 FF 23 54                		add	r5, r4, r3
1605:../src/wolfcrypt/src/rsa.c ****                                        pkcsBlockLen - hLen - 1, heap)) != 0) {
 2654                             		.loc 2 1605 53
 2655 0105 ED A5 04                		mov.L	16[r10], r5
 2656 0108 ED A4 1A                		mov.L	104[r10], r4
 2657 010b FF 05 54                		sub	r5, r4, r5
1604:../src/wolfcrypt/src/rsa.c ****                                        pkcsBlockLen - hLen - 1, heap)) != 0) {
 2658                             		.loc 2 1604 16
 2659 010e 60 15                   		sub	#1, r5
 2660 0110 A8 EC                   		mov.L	12[r6], r4
 2661 0112 A0 0C                   		mov.L	r4, 4[r0]
 2662 0114 E3 05                   		mov.L	r5, [r0]
 2663 0116 EF 34                   		mov.L	r3, r4
 2664 0118 EF 23                   		mov.L	r2, r3
 2665 011a ED A2 03                		mov.L	12[r10], r2
 2666 011d EC 61                   		mov.L	[r6], r1
 2667 011f 05 00 00 00             		bsr	_RsaMGF
 2668 0123 E7 A1 05                		mov.L	r1, 20[r10]
1604:../src/wolfcrypt/src/rsa.c ****                                        pkcsBlockLen - hLen - 1, heap)) != 0) {
 2669                             		.loc 2 1604 8
 2670 0126 ED A5 05                		mov.L	20[r10], r5
 2671 0129 61 05                   		cmp	#0, r5
 2672 012b 20 27                   		beq	.L166
1606:../src/wolfcrypt/src/rsa.c ****         ForceZero(tmp, hLen);
 2673                             		.loc 2 1606 9
 2674 012d ED A5 04                		mov.L	16[r10], r5
 2675 0130 EF 52                   		mov.L	r5, r2
 2676 0132 ED A1 03                		mov.L	12[r10], r1
 2677 0135 05 00 00 00             		bsr	_ForceZero
 2678                             	.LBB30:
1607:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
1608:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp, NULL, DYNAMIC_TYPE_RSA_BUFFER);
 2679                             		.loc 2 1608 9
 2680 0139 ED A5 03                		mov.L	12[r10], r5
 2681 013c E7 A5 07                		mov.L	r5, 28[r10]
 2682 013f ED A5 07                		mov.L	28[r10], r5
 2683 0142 61 05                   		cmp	#0, r5
 2684 0144 10                      		beq	.L167
 2685                             		.loc 2 1608 9 is_stmt 0 discriminator 1
 2686 0145 ED A1 07                		mov.L	28[r10], r1
 2687 0148 05 00 00 00             		bsr	_wolfSSL_Free
 2688                             	.L167:
 2689                             	.LBE30:
1609:../src/wolfcrypt/src/rsa.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
1610:../src/wolfcrypt/src/rsa.c ****         wc_MemZero_Check(tmp, hLen);
1611:../src/wolfcrypt/src/rsa.c **** #endif
1612:../src/wolfcrypt/src/rsa.c ****         return ret;
 2690                             		.loc 2 1612 16 is_stmt 1
 2691 014c ED A5 05                		mov.L	20[r10], r5
 2692 014f 38 64 01                		bra	.L174
 2693                             	.L166:
1613:../src/wolfcrypt/src/rsa.c ****     }
1614:../src/wolfcrypt/src/rsa.c **** 
1615:../src/wolfcrypt/src/rsa.c ****     /* get DB value by doing maskedDB xor dbMask */
1616:../src/wolfcrypt/src/rsa.c ****     for (idx = 0; idx < (pkcsBlockLen - hLen - 1); idx++) {
 2694                             		.loc 2 1616 14
 2695 0152 F8 A6 00                		mov.L	#0, [r10]
 2696                             		.loc 2 1616 5
 2697 0155 2E 38                   		bra	.L168
 2698                             	.L169:
1617:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[hLen + 1 + idx] = pkcsBlock[hLen + 1 + idx] ^ tmp[idx + hLen];
 2699                             		.loc 2 1617 56 discriminator 3
 2700 0157 ED A5 04                		mov.L	16[r10], r5
 2701 015a 06 88 A5                		add	[r10].L, r5
 2702 015d 62 15                   		add	#1, r5
 2703                             		.loc 2 1617 46 discriminator 3
 2704 015f ED A4 19                		mov.L	100[r10], r4
 2705 0162 4B 45                   		add	r4, r5
 2706 0164 CC 52                   		mov.B	[r5], r2
 2707                             		.loc 2 1617 73 discriminator 3
 2708 0166 ED A5 04                		mov.L	16[r10], r5
 2709 0169 06 88 A5                		add	[r10].L, r5
 2710                             		.loc 2 1617 68 discriminator 3
 2711 016c ED A4 03                		mov.L	12[r10], r4
 2712 016f 4B 45                   		add	r4, r5
 2713 0171 CC 53                   		mov.B	[r5], r3
 2714                             		.loc 2 1617 28 discriminator 3
 2715 0173 ED A5 04                		mov.L	16[r10], r5
 2716 0176 06 88 A5                		add	[r10].L, r5
 2717 0179 62 15                   		add	#1, r5
 2718                             		.loc 2 1617 18 discriminator 3
 2719 017b ED A4 19                		mov.L	100[r10], r4
 2720 017e 4B 45                   		add	r4, r5
 2721                             		.loc 2 1617 35 discriminator 3
 2722 0180 EF 24                   		mov.L	r2, r4
 2723 0182 FC 37 34                		xor	r3, r4
 2724 0185 C3 54                   		mov.B	r4, [r5]
1616:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[hLen + 1 + idx] = pkcsBlock[hLen + 1 + idx] ^ tmp[idx + hLen];
 2725                             		.loc 2 1616 55 discriminator 3
 2726 0187 EC A5                   		mov.L	[r10], r5
 2727 0189 62 15                   		add	#1, r5
 2728 018b E3 A5                   		mov.L	r5, [r10]
 2729                             	.L168:
1616:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[hLen + 1 + idx] = pkcsBlock[hLen + 1 + idx] ^ tmp[idx + hLen];
 2730                             		.loc 2 1616 39 discriminator 1
 2731 018d ED A5 04                		mov.L	16[r10], r5
 2732 0190 ED A4 1A                		mov.L	104[r10], r4
 2733 0193 FF 05 54                		sub	r5, r4, r5
1616:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[hLen + 1 + idx] = pkcsBlock[hLen + 1 + idx] ^ tmp[idx + hLen];
 2734                             		.loc 2 1616 46 discriminator 1
 2735 0196 60 15                   		sub	#1, r5
1616:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[hLen + 1 + idx] = pkcsBlock[hLen + 1 + idx] ^ tmp[idx + hLen];
 2736                             		.loc 2 1616 5 discriminator 1
 2737 0198 EC A4                   		mov.L	[r10], r4
 2738 019a 47 54                   		cmp	r5, r4
 2739 019c 23 BB                   		bltu	.L169
1618:../src/wolfcrypt/src/rsa.c ****     }
1619:../src/wolfcrypt/src/rsa.c **** 
1620:../src/wolfcrypt/src/rsa.c ****     ForceZero(tmp, pkcsBlockLen);
 2740                             		.loc 2 1620 5
 2741 019e ED A2 1A                		mov.L	104[r10], r2
 2742 01a1 ED A1 03                		mov.L	12[r10], r1
 2743 01a4 05 00 00 00             		bsr	_ForceZero
 2744                             	.LBB31:
1621:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
1622:../src/wolfcrypt/src/rsa.c ****     /* done with use of tmp buffer */
1623:../src/wolfcrypt/src/rsa.c ****     XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 2745                             		.loc 2 1623 5
 2746 01a8 ED A5 03                		mov.L	12[r10], r5
 2747 01ab E7 A5 08                		mov.L	r5, 32[r10]
 2748 01ae ED A5 08                		mov.L	32[r10], r5
 2749 01b1 61 05                   		cmp	#0, r5
 2750 01b3 10                      		beq	.L170
 2751                             		.loc 2 1623 5 is_stmt 0 discriminator 1
 2752 01b4 ED A1 08                		mov.L	32[r10], r1
 2753 01b7 05 00 00 00             		bsr	_wolfSSL_Free
 2754                             	.L170:
 2755                             	.LBE31:
1624:../src/wolfcrypt/src/rsa.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
1625:../src/wolfcrypt/src/rsa.c ****     wc_MemZero_Check(tmp, pkcsBlockLen);
1626:../src/wolfcrypt/src/rsa.c **** #endif
1627:../src/wolfcrypt/src/rsa.c **** 
1628:../src/wolfcrypt/src/rsa.c ****     /* advance idx to index of PS and msg separator, account for PS size of 0*/
1629:../src/wolfcrypt/src/rsa.c ****     idx = hLen + 1 + hLen;
 2756                             		.loc 2 1629 16 is_stmt 1
 2757 01bb ED A5 04                		mov.L	16[r10], r5
 2758 01be 62 15                   		add	#1, r5
 2759                             		.loc 2 1629 20
 2760 01c0 06 89 A5 04             		add	16[r10].L, r5
 2761                             		.loc 2 1629 9
 2762 01c4 E3 A5                   		mov.L	r5, [r10]
1630:../src/wolfcrypt/src/rsa.c ****     /* Don't reveal length of message: look at every byte. */
1631:../src/wolfcrypt/src/rsa.c ****     inc = 1;
 2763                             		.loc 2 1631 9
 2764 01c6 F9 A6 02 01             		mov.L	#1, 8[r10]
1632:../src/wolfcrypt/src/rsa.c ****     for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 2765                             		.loc 2 1632 19
 2766 01ca ED A5 04                		mov.L	16[r10], r5
 2767 01cd 62 15                   		add	#1, r5
 2768                             		.loc 2 1632 23
 2769 01cf 06 89 A5 04             		add	16[r10].L, r5
 2770                             		.loc 2 1632 12
 2771 01d3 E7 A5 01                		mov.L	r5, 4[r10]
 2772                             		.loc 2 1632 5
 2773 01d6 2E 2B                   		bra	.L171
 2774                             	.L172:
1633:../src/wolfcrypt/src/rsa.c ****         /* Looking for non-zero byte. */
1634:../src/wolfcrypt/src/rsa.c ****         inc &= 1 - (((word32)0 - pkcsBlock[i]) >> 31);
 2775                             		.loc 2 1634 43 discriminator 3
 2776 01d8 ED A5 19                		mov.L	100[r10], r5
 2777 01db 06 89 A5 01             		add	4[r10].L, r5
 2778 01df CC 55                   		mov.B	[r5], r5
 2779 01e1 5B 55                   		movu.B	r5, r5
 2780                             		.loc 2 1634 32 discriminator 3
 2781 01e3 7E 15                   		neg	r5
 2782                             		.loc 2 1634 48 discriminator 3
 2783 01e5 6B F5                   		shar	#31, r5
 2784                             		.loc 2 1634 18 discriminator 3
 2785 01e7 62 15                   		add	#1, r5
 2786                             		.loc 2 1634 13 discriminator 3
 2787 01e9 ED A4 02                		mov.L	8[r10], r4
 2788 01ec 53 45                   		and	r4, r5
 2789 01ee E7 A5 02                		mov.L	r5, 8[r10]
1635:../src/wolfcrypt/src/rsa.c ****         idx += inc;
 2790                             		.loc 2 1635 13 discriminator 3
 2791 01f1 EC A5                   		mov.L	[r10], r5
 2792 01f3 06 89 A5 02             		add	8[r10].L, r5
 2793 01f7 E3 A5                   		mov.L	r5, [r10]
1632:../src/wolfcrypt/src/rsa.c ****     for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 2794                             		.loc 2 1632 54 discriminator 3
 2795 01f9 ED A5 01                		mov.L	4[r10], r5
 2796 01fc 62 15                   		add	#1, r5
 2797 01fe E7 A5 01                		mov.L	r5, 4[r10]
 2798                             	.L171:
1632:../src/wolfcrypt/src/rsa.c ****     for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 2799                             		.loc 2 1632 48 discriminator 1
 2800 0201 ED A5 1A                		mov.L	104[r10], r5
 2801 0204 60 15                   		sub	#1, r5
1632:../src/wolfcrypt/src/rsa.c ****     for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 2802                             		.loc 2 1632 5 discriminator 1
 2803 0206 ED A4 01                		mov.L	4[r10], r4
 2804 0209 47 54                   		cmp	r5, r4
 2805 020b 23 CD                   		bltu	.L172
1636:../src/wolfcrypt/src/rsa.c ****     }
1637:../src/wolfcrypt/src/rsa.c **** 
1638:../src/wolfcrypt/src/rsa.c ****     /* create hash of label for comparison with hash sent */
1639:../src/wolfcrypt/src/rsa.c ****     if ((ret = wc_Hash(hType, optLabel, labelLen, h, hLen)) != 0) {
 2806                             		.loc 2 1639 16
 2807 020d ED A4 04                		mov.L	16[r10], r4
 2808 0210 71 A5 24                		add	#36, r10, r5
 2809 0213 E3 04                   		mov.L	r4, [r0]
 2810 0215 EF 54                   		mov.L	r5, r4
 2811 0217 A8 E3                   		mov.L	8[r6], r3
 2812 0219 A8 6A                   		mov.L	4[r6], r2
 2813 021b ED A1 1C                		mov.L	112[r10], r1
 2814 021e 05 00 00 00             		bsr	_wc_Hash
 2815 0222 E7 A1 05                		mov.L	r1, 20[r10]
 2816                             		.loc 2 1639 8
 2817 0225 ED A5 05                		mov.L	20[r10], r5
 2818 0228 61 05                   		cmp	#0, r5
 2819 022a 17                      		beq	.L173
1640:../src/wolfcrypt/src/rsa.c ****         return ret;
 2820                             		.loc 2 1640 16
 2821 022b ED A5 05                		mov.L	20[r10], r5
 2822 022e 38 85 00                		bra	.L174
 2823                             	.L173:
1641:../src/wolfcrypt/src/rsa.c ****     }
1642:../src/wolfcrypt/src/rsa.c **** 
1643:../src/wolfcrypt/src/rsa.c ****     /* say no to chosen ciphertext attack.
1644:../src/wolfcrypt/src/rsa.c ****        Comparison of lHash, Y, and separator value needs to all happen in
1645:../src/wolfcrypt/src/rsa.c ****        constant time.
1646:../src/wolfcrypt/src/rsa.c ****        Attackers should not be able to get error condition from the timing of
1647:../src/wolfcrypt/src/rsa.c ****        these checks.
1648:../src/wolfcrypt/src/rsa.c ****      */
1649:../src/wolfcrypt/src/rsa.c ****     ret = 0;
 2824                             		.loc 2 1649 9
 2825 0231 F9 A6 05 00             		mov.L	#0, 20[r10]
1650:../src/wolfcrypt/src/rsa.c ****     ret |= ConstantCompare(pkcsBlock + hLen + 1, h, hLen);
 2826                             		.loc 2 1650 45
 2827 0235 ED A5 04                		mov.L	16[r10], r5
 2828 0238 62 15                   		add	#1, r5
 2829 023a ED A4 19                		mov.L	100[r10], r4
 2830 023d 4B 45                   		add	r4, r5
 2831                             		.loc 2 1650 12
 2832 023f 71 A4 24                		add	#36, r10, r4
 2833 0242 ED A3 04                		mov.L	16[r10], r3
 2834 0245 EF 42                   		mov.L	r4, r2
 2835 0247 EF 51                   		mov.L	r5, r1
 2836 0249 05 00 00 00             		bsr	_ConstantCompare
 2837 024d EF 15                   		mov.L	r1, r5
 2838                             		.loc 2 1650 9
 2839 024f ED A4 05                		mov.L	20[r10], r4
 2840 0252 57 45                   		or	r4, r5
 2841 0254 E7 A5 05                		mov.L	r5, 20[r10]
1651:../src/wolfcrypt/src/rsa.c ****     ret += pkcsBlock[idx++] ^ 0x01; /* separator value is 0x01 */
 2842                             		.loc 2 1651 25
 2843 0257 EC A5                   		mov.L	[r10], r5
 2844 0259 71 54 01                		add	#1, r5, r4
 2845 025c E3 A4                   		mov.L	r4, [r10]
 2846                             		.loc 2 1651 21
 2847 025e ED A4 19                		mov.L	100[r10], r4
 2848 0261 4B 45                   		add	r4, r5
 2849 0263 CC 55                   		mov.B	[r5], r5
 2850                             		.loc 2 1651 29
 2851 0265 FD 74 D5 01             		xor	#1, r5
 2852 0269 5B 55                   		movu.B	r5, r5
 2853                             		.loc 2 1651 9
 2854 026b ED A4 05                		mov.L	20[r10], r4
 2855 026e 4B 45                   		add	r4, r5
 2856 0270 E7 A5 05                		mov.L	r5, 20[r10]
1652:../src/wolfcrypt/src/rsa.c ****     ret += pkcsBlock[0]     ^ 0x00; /* Y, the first value, should be 0 */
 2857                             		.loc 2 1652 21
 2858 0273 ED A5 19                		mov.L	100[r10], r5
 2859 0276 CC 55                   		mov.B	[r5], r5
 2860                             		.loc 2 1652 29
 2861 0278 5B 55                   		movu.B	r5, r5
 2862                             		.loc 2 1652 9
 2863 027a ED A4 05                		mov.L	20[r10], r4
 2864 027d 4B 45                   		add	r4, r5
 2865 027f E7 A5 05                		mov.L	r5, 20[r10]
1653:../src/wolfcrypt/src/rsa.c **** 
1654:../src/wolfcrypt/src/rsa.c ****     /* Return 0 data length on error. */
1655:../src/wolfcrypt/src/rsa.c ****     idx = ctMaskSelInt(ctMaskEq(ret, 0), idx, pkcsBlockLen);
 2866                             		.loc 2 1655 11
 2867 0282 66 02                   		mov.L	#0, r2
 2868 0284 ED A1 05                		mov.L	20[r10], r1
 2869 0287 05 00 00 00             		bsr	_ctMaskEq
 2870 028b EF 15                   		mov.L	r1, r5
 2871 028d EC A4                   		mov.L	[r10], r4
 2872 028f ED A3 1A                		mov.L	104[r10], r3
 2873 0292 EF 42                   		mov.L	r4, r2
 2874 0294 CF 51                   		mov.B	r5, r1
 2875 0296 05 00 00 00             		bsr	_ctMaskSelInt
 2876 029a EF 15                   		mov.L	r1, r5
 2877                             		.loc 2 1655 9
 2878 029c E3 A5                   		mov.L	r5, [r10]
1656:../src/wolfcrypt/src/rsa.c **** 
1657:../src/wolfcrypt/src/rsa.c ****     /* adjust pointer to correct location in array and return size of M */
1658:../src/wolfcrypt/src/rsa.c ****     *output = (byte*)(pkcsBlock + idx);
 2879                             		.loc 2 1658 15
 2880 029e ED A5 19                		mov.L	100[r10], r5
 2881 02a1 EF 54                   		mov.L	r5, r4
 2882 02a3 06 88 A4                		add	[r10].L, r4
 2883                             		.loc 2 1658 13
 2884 02a6 ED A5 1B                		mov.L	108[r10], r5
 2885 02a9 E3 54                   		mov.L	r4, [r5]
1659:../src/wolfcrypt/src/rsa.c ****     return pkcsBlockLen - idx;
 2886                             		.loc 2 1659 25
 2887 02ab ED A4 1A                		mov.L	104[r10], r4
 2888 02ae EC A5                   		mov.L	[r10], r5
 2889 02b0 FF 05 54                		sub	r5, r4, r5
 2890                             		.balign 8,3,1
 2891                             	.L174:
1660:../src/wolfcrypt/src/rsa.c **** }
 2892                             		.loc 2 1660 1 discriminator 1
 2893 02b3 EF 51                   		mov.L	r5, r1
 2894 02b5 72 00 8C 00             		add	#0x8c, r0
 2895 02b9 7E B6                   		pop	r6
 2896 02bb 7E BA                   		pop	r10
 2897 02bd 02                      		rts
 2898                             	.LFE53:
 2900 02be EF 00                   		.section C,"a",@progbits
 2901 011e 00 00                   		.p2align 2
 2902                             	.LC8:
 2903 0120 52 73 61 55 6E 50 61 64 		.string	"RsaUnPad_PSS: Hash too large"
 2903      5F 50 53 53 3A 20 48 61 
 2903      73 68 20 74 6F 6F 20 6C 
 2903      61 72 67 65 00 
 2904                             	.LC9:
 2905 013d 52 73 61 55 6E 50 61 64 		.string	"RsaUnPad_PSS: Padding Term Error"
 2905      5F 50 53 53 3A 20 50 61 
 2905      64 64 69 6E 67 20 54 65 
 2905      72 6D 20 45 72 72 6F 72 
 2905      00 
 2906                             	.LC10:
 2907 015e 52 73 61 55 6E 50 61 64 		.string	"RsaUnPad_PSS: Padding Error Match"
 2907      5F 50 53 53 3A 20 50 61 
 2907      64 64 69 6E 67 20 45 72 
 2907      72 6F 72 20 4D 61 74 63 
 2907      68 00 
 2908                             	.LC11:
 2909 0180 52 73 61 55 6E 50 61 64 		.string	"RsaUnPad_PSS: Padding Error End"
 2909      5F 50 53 53 3A 20 50 61 
 2909      64 64 69 6E 67 20 45 72 
 2909      72 6F 72 20 45 6E 64 00 
 2910                             		.section	.text.RsaUnPad_PSS,"ax",@progbits
 2912                             	_RsaUnPad_PSS:
 2913                             	.LFB54:
1661:../src/wolfcrypt/src/rsa.c **** #endif /* WC_NO_RSA_OAEP */
1662:../src/wolfcrypt/src/rsa.c **** 
1663:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_PSS
1664:../src/wolfcrypt/src/rsa.c **** /* 0x00 .. 0x00 0x01 | Salt | Gen Hash | 0xbc
1665:../src/wolfcrypt/src/rsa.c ****  * MGF over all bytes down to end of Salt
1666:../src/wolfcrypt/src/rsa.c ****  *
1667:../src/wolfcrypt/src/rsa.c ****  * pkcsBlock     Buffer holding decrypted data.
1668:../src/wolfcrypt/src/rsa.c ****  * pkcsBlockLen  Length of buffer.
1669:../src/wolfcrypt/src/rsa.c ****  * htype         Hash function to use.
1670:../src/wolfcrypt/src/rsa.c ****  * mgf           Mask generation function.
1671:../src/wolfcrypt/src/rsa.c ****  * saltLen       Length of salt to put in padding.
1672:../src/wolfcrypt/src/rsa.c ****  * bits          Length of key in bits.
1673:../src/wolfcrypt/src/rsa.c ****  * heap          Used for dynamic memory allocation.
1674:../src/wolfcrypt/src/rsa.c ****  * returns       the sum of salt length and SHA-256 digest size on success.
1675:../src/wolfcrypt/src/rsa.c ****  *               Otherwise, PSS_SALTLEN_E for an incorrect salt length,
1676:../src/wolfcrypt/src/rsa.c ****  *               WC_KEY_SIZE_E for an incorrect encoded message (EM) size
1677:../src/wolfcrypt/src/rsa.c ****                  and other negative values on error.
1678:../src/wolfcrypt/src/rsa.c ****  */
1679:../src/wolfcrypt/src/rsa.c **** static int RsaUnPad_PSS(byte *pkcsBlock, unsigned int pkcsBlockLen,
1680:../src/wolfcrypt/src/rsa.c ****                         byte **output, enum wc_HashType hType, int mgf,
1681:../src/wolfcrypt/src/rsa.c ****                         int saltLen, int bits, void* heap)
1682:../src/wolfcrypt/src/rsa.c **** {
 2914                             		.loc 2 1682 1
 2915 0000 6E 6A                   		pushm	r6-r10
 2916                             	.LCFI61:
 2917 0002 71 0A B8                		add	#-72, r0, r10
 2918                             	.LCFI62:
 2919 0005 71 A0 F8                		add	#-8, r10, r0
 2920                             	.LCFI63:
 2921 0008 75 46 60                		mov.L	#0x60, r6
 2922 000b 4B A6                   		add	r10, r6
 2923 000d E7 A1 0A                		mov.L	r1, 40[r10]
 2924 0010 E7 A2 0B                		mov.L	r2, 44[r10]
 2925 0013 E7 A3 0C                		mov.L	r3, 48[r10]
 2926 0016 E7 A4 0D                		mov.L	r4, 52[r10]
1683:../src/wolfcrypt/src/rsa.c ****     int   ret;
1684:../src/wolfcrypt/src/rsa.c ****     byte* tmp;
1685:../src/wolfcrypt/src/rsa.c ****     int   hLen, i, maskLen;
1686:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SHA512
1687:../src/wolfcrypt/src/rsa.c ****     int orig_bits = bits;
 2927                             		.loc 2 1687 9
 2928 0019 A8 E5                   		mov.L	8[r6], r5
 2929 001b E7 A5 01                		mov.L	r5, 4[r10]
1688:../src/wolfcrypt/src/rsa.c **** #endif
1689:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)
1690:../src/wolfcrypt/src/rsa.c ****     byte tmp_buf[RSA_MAX_SIZE/8];
1691:../src/wolfcrypt/src/rsa.c ****     tmp = tmp_buf;
1692:../src/wolfcrypt/src/rsa.c **** 
1693:../src/wolfcrypt/src/rsa.c ****     if (pkcsBlockLen > RSA_MAX_SIZE/8) {
1694:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
1695:../src/wolfcrypt/src/rsa.c ****     }
1696:../src/wolfcrypt/src/rsa.c **** #endif
1697:../src/wolfcrypt/src/rsa.c **** 
1698:../src/wolfcrypt/src/rsa.c ****     hLen = wc_HashGetDigestSize(hType);
 2930                             		.loc 2 1698 12
 2931 001e ED A1 0D                		mov.L	52[r10], r1
 2932 0021 05 00 00 00             		bsr	_wc_HashGetDigestSize
 2933 0025 E7 A1 02                		mov.L	r1, 8[r10]
1699:../src/wolfcrypt/src/rsa.c ****     if (hLen < 0)
 2934                             		.loc 2 1699 8
 2935 0028 ED A5 02                		mov.L	8[r10], r5
 2936 002b 61 05                   		cmp	#0, r5
 2937 002d 28 08                   		bge	.L176
1700:../src/wolfcrypt/src/rsa.c ****         return hLen;
 2938                             		.loc 2 1700 16
 2939 002f ED A5 02                		mov.L	8[r10], r5
 2940 0032 38 68 02                		bra	.L177
 2941                             	.L176:
1701:../src/wolfcrypt/src/rsa.c ****     bits = (bits - 1) & 0x7;
 2942                             		.loc 2 1701 18
 2943 0035 A8 E5                   		mov.L	8[r6], r5
 2944 0037 60 15                   		sub	#1, r5
 2945                             		.loc 2 1701 10
 2946 0039 64 75                   		and	#7, r5
 2947 003b A0 E5                   		mov.L	r5, 8[r6]
1702:../src/wolfcrypt/src/rsa.c ****     if ((pkcsBlock[0] & (0xff << bits)) != 0) {
 2948                             		.loc 2 1702 19
 2949 003d ED A5 0A                		mov.L	40[r10], r5
 2950 0040 CC 55                   		mov.B	[r5], r5
 2951 0042 5B 54                   		movu.B	r5, r4
 2952                             		.loc 2 1702 31
 2953 0044 75 43 FF                		mov.L	#0xff, r3
 2954 0047 A8 E5                   		mov.L	8[r6], r5
 2955 0049 EF 37                   		mov.L	r3, r7
 2956 004b FD 62 57                		shll	r5, r7
 2957 004e EF 75                   		mov.L	r7, r5
 2958                             		.loc 2 1702 23
 2959 0050 53 45                   		and	r4, r5
 2960                             		.loc 2 1702 8
 2961 0052 61 05                   		cmp	#0, r5
 2962 0054 10                      		beq	.L178
1703:../src/wolfcrypt/src/rsa.c ****         return BAD_PADDING_E;
 2963                             		.loc 2 1703 16
 2964 0055 FB 5A 3F FF             		mov.L	#-193, r5
 2965 0059 38 41 02                		bra	.L177
 2966                             	.L178:
1704:../src/wolfcrypt/src/rsa.c ****     }
1705:../src/wolfcrypt/src/rsa.c ****     if (bits == 0) {
 2967                             		.loc 2 1705 8
 2968 005c A8 E5                   		mov.L	8[r6], r5
 2969 005e 61 05                   		cmp	#0, r5
 2970 0060 21 12                   		bne	.L179
1706:../src/wolfcrypt/src/rsa.c ****         pkcsBlock++;
 2971                             		.loc 2 1706 18
 2972 0062 ED A5 0A                		mov.L	40[r10], r5
 2973 0065 62 15                   		add	#1, r5
 2974 0067 E7 A5 0A                		mov.L	r5, 40[r10]
1707:../src/wolfcrypt/src/rsa.c ****         pkcsBlockLen--;
 2975                             		.loc 2 1707 21
 2976 006a ED A5 0B                		mov.L	44[r10], r5
 2977 006d 60 15                   		sub	#1, r5
 2978 006f E7 A5 0B                		mov.L	r5, 44[r10]
 2979                             	.L179:
1708:../src/wolfcrypt/src/rsa.c ****     }
1709:../src/wolfcrypt/src/rsa.c ****     maskLen = (int)pkcsBlockLen - 1 - hLen;
 2980                             		.loc 2 1709 15
 2981 0072 ED A5 0B                		mov.L	44[r10], r5
 2982                             		.loc 2 1709 33
 2983 0075 60 15                   		sub	#1, r5
 2984                             		.loc 2 1709 13
 2985 0077 ED A4 02                		mov.L	8[r10], r4
 2986 007a 43 45                   		sub	r4, r5
 2987 007c E7 A5 03                		mov.L	r5, 12[r10]
1710:../src/wolfcrypt/src/rsa.c ****     if (maskLen < 0) {
 2988                             		.loc 2 1710 8
 2989 007f ED A5 03                		mov.L	12[r10], r5
 2990 0082 61 05                   		cmp	#0, r5
 2991 0084 28 13                   		bge	.L180
1711:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("RsaUnPad_PSS: Hash too large");
 2992                             		.loc 2 1711 9
 2993 0086 FB 12 20 01 00 00       		mov.L	#.LC8, r1
 2994 008c 05 00 00 00             		bsr	_WOLFSSL_MSG
1712:../src/wolfcrypt/src/rsa.c ****         return WC_KEY_SIZE_E;
 2995                             		.loc 2 1712 16
 2996 0090 FB 5A 16 FF             		mov.L	#-234, r5
 2997 0094 38 06 02                		bra	.L177
 2998                             	.L180:
1713:../src/wolfcrypt/src/rsa.c ****     }
1714:../src/wolfcrypt/src/rsa.c **** 
1715:../src/wolfcrypt/src/rsa.c ****     if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 2999                             		.loc 2 1715 8
 3000 0097 A8 6D                   		mov.L	4[r6], r5
 3001 0099 75 05 FF                		cmp	#-1, r5
 3002 009c 21 1D                   		bne	.L181
1716:../src/wolfcrypt/src/rsa.c ****         saltLen = hLen;
 3003                             		.loc 2 1716 17
 3004 009e ED A5 02                		mov.L	8[r10], r5
 3005 00a1 A0 6D                   		mov.L	r5, 4[r6]
1717:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_SHA512
1718:../src/wolfcrypt/src/rsa.c ****             /* See FIPS 186-4 section 5.5 item (e). */
1719:../src/wolfcrypt/src/rsa.c ****             if (orig_bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE)
 3006                             		.loc 2 1719 16
 3007 00a3 ED A5 01                		mov.L	4[r10], r5
 3008 00a6 76 05 00 04             		cmp	#0x400, r5
 3009 00aa 21 2D                   		bne	.L183
 3010                             		.loc 2 1719 35 discriminator 1
 3011 00ac ED A5 02                		mov.L	8[r10], r5
 3012 00af 75 55 40                		cmp	#0x40, r5
 3013 00b2 21 25                   		bne	.L183
1720:../src/wolfcrypt/src/rsa.c ****                 saltLen = RSA_PSS_SALT_MAX_SZ;
 3014                             		.loc 2 1720 25
 3015 00b4 3E 61 3E                		mov.L	#62, 4[r6]
 3016 00b7 2E 20                   		bra	.L183
 3017                             	.L181:
1721:../src/wolfcrypt/src/rsa.c ****         #endif
1722:../src/wolfcrypt/src/rsa.c ****     }
1723:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_LONG_SALT
1724:../src/wolfcrypt/src/rsa.c ****     else if (saltLen > hLen)
 3018                             		.loc 2 1724 13
 3019 00b9 A8 6C                   		mov.L	4[r6], r4
 3020 00bb ED A5 02                		mov.L	8[r10], r5
 3021 00be 47 54                   		cmp	r5, r4
 3022 00c0 2B 09                   		ble	.L184
1725:../src/wolfcrypt/src/rsa.c ****         return PSS_SALTLEN_E;
 3023                             		.loc 2 1725 16
 3024 00c2 FB 5A 06 FF             		mov.L	#-250, r5
 3025 00c6 38 D4 01                		bra	.L177
 3026                             	.L184:
1726:../src/wolfcrypt/src/rsa.c **** #endif
1727:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
1728:../src/wolfcrypt/src/rsa.c ****     else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT)
 3027                             		.loc 2 1728 13
 3028 00c9 A8 6D                   		mov.L	4[r6], r5
 3029 00cb 75 05 FF                		cmp	#-1, r5
 3030 00ce 28 09                   		bge	.L183
1729:../src/wolfcrypt/src/rsa.c ****         return PSS_SALTLEN_E;
 3031                             		.loc 2 1729 16
 3032 00d0 FB 5A 06 FF             		mov.L	#-250, r5
 3033 00d4 38 C6 01                		bra	.L177
 3034                             	.L183:
1730:../src/wolfcrypt/src/rsa.c ****     if (maskLen < saltLen + 1) {
 3035                             		.loc 2 1730 8
 3036 00d7 A8 6C                   		mov.L	4[r6], r4
 3037 00d9 ED A5 03                		mov.L	12[r10], r5
 3038 00dc 47 54                   		cmp	r5, r4
 3039 00de 29 09                   		blt	.L185
1731:../src/wolfcrypt/src/rsa.c ****         return PSS_SALTLEN_E;
 3040                             		.loc 2 1731 16
 3041 00e0 FB 5A 06 FF             		mov.L	#-250, r5
 3042 00e4 38 B6 01                		bra	.L177
 3043                             	.L185:
1732:../src/wolfcrypt/src/rsa.c ****     }
1733:../src/wolfcrypt/src/rsa.c **** #else
1734:../src/wolfcrypt/src/rsa.c ****     else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER)
1735:../src/wolfcrypt/src/rsa.c ****         return PSS_SALTLEN_E;
1736:../src/wolfcrypt/src/rsa.c ****     if (saltLen != RSA_PSS_SALT_LEN_DISCOVER && maskLen < saltLen + 1) {
1737:../src/wolfcrypt/src/rsa.c ****         return WC_KEY_SIZE_E;
1738:../src/wolfcrypt/src/rsa.c ****     }
1739:../src/wolfcrypt/src/rsa.c **** #endif
1740:../src/wolfcrypt/src/rsa.c **** 
1741:../src/wolfcrypt/src/rsa.c ****     if (pkcsBlock[pkcsBlockLen - 1] != RSA_PSS_PAD_TERM) {
 3044                             		.loc 2 1741 18
 3045 00e7 ED A5 0B                		mov.L	44[r10], r5
 3046 00ea 60 15                   		sub	#1, r5
 3047 00ec ED A4 0A                		mov.L	40[r10], r4
 3048 00ef 4B 45                   		add	r4, r5
 3049 00f1 CC 55                   		mov.B	[r5], r5
 3050                             		.loc 2 1741 8
 3051 00f3 5B 55                   		movu.B	r5, r5
 3052 00f5 75 55 BC                		cmp	#0xbc, r5
 3053 00f8 20 13                   		beq	.L186
1742:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("RsaUnPad_PSS: Padding Term Error");
 3054                             		.loc 2 1742 9
 3055 00fa FB 12 3D 01 00 00       		mov.L	#.LC9, r1
 3056 0100 05 00 00 00             		bsr	_WOLFSSL_MSG
1743:../src/wolfcrypt/src/rsa.c ****         return BAD_PADDING_E;
 3057                             		.loc 2 1743 16
 3058 0104 FB 5A 3F FF             		mov.L	#-193, r5
 3059 0108 38 92 01                		bra	.L177
 3060                             	.L186:
1744:../src/wolfcrypt/src/rsa.c ****     }
1745:../src/wolfcrypt/src/rsa.c **** 
1746:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
1747:../src/wolfcrypt/src/rsa.c ****     tmp = (byte*)XMALLOC(maskLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 3061                             		.loc 2 1747 18
 3062 010b ED A5 03                		mov.L	12[r10], r5
 3063 010e EF 51                   		mov.L	r5, r1
 3064 0110 05 00 00 00             		bsr	_wolfSSL_Malloc
 3065 0114 E7 A1 04                		mov.L	r1, 16[r10]
1748:../src/wolfcrypt/src/rsa.c ****     if (tmp == NULL) {
 3066                             		.loc 2 1748 8
 3067 0117 ED A5 04                		mov.L	16[r10], r5
 3068 011a 61 05                   		cmp	#0, r5
 3069 011c 1F                      		bne	.L187
1749:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
 3070                             		.loc 2 1749 16
 3071 011d FB 56 83                		mov.L	#-125, r5
 3072 0120 38 7A 01                		bra	.L177
 3073                             	.L187:
1750:../src/wolfcrypt/src/rsa.c ****     }
1751:../src/wolfcrypt/src/rsa.c **** #endif
1752:../src/wolfcrypt/src/rsa.c **** 
1753:../src/wolfcrypt/src/rsa.c ****     if ((ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, tmp, maskLen,
 3074                             		.loc 2 1753 16
 3075 0123 ED A5 03                		mov.L	12[r10], r5
 3076 0126 ED A4 0A                		mov.L	40[r10], r4
 3077 0129 4B 45                   		add	r4, r5
 3078 012b ED A3 02                		mov.L	8[r10], r3
 3079 012e ED A4 03                		mov.L	12[r10], r4
 3080 0131 A8 EA                   		mov.L	12[r6], r2
 3081 0133 A0 0A                   		mov.L	r2, 4[r0]
 3082 0135 E3 04                   		mov.L	r4, [r0]
 3083 0137 ED A4 04                		mov.L	16[r10], r4
 3084 013a EF 52                   		mov.L	r5, r2
 3085 013c EC 61                   		mov.L	[r6], r1
 3086 013e 05 00 00 00             		bsr	_RsaMGF
 3087 0142 E7 A1 05                		mov.L	r1, 20[r10]
 3088                             		.loc 2 1753 8
 3089 0145 ED A5 05                		mov.L	20[r10], r5
 3090 0148 61 05                   		cmp	#0, r5
 3091 014a 20 1B                   		beq	.L188
 3092                             	.LBB32:
1754:../src/wolfcrypt/src/rsa.c ****                                                                   heap)) != 0) {
1755:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 3093                             		.loc 2 1755 9
 3094 014c ED A5 04                		mov.L	16[r10], r5
 3095 014f E7 A5 06                		mov.L	r5, 24[r10]
 3096 0152 ED A5 06                		mov.L	24[r10], r5
 3097 0155 61 05                   		cmp	#0, r5
 3098 0157 10                      		beq	.L189
 3099                             		.loc 2 1755 9 is_stmt 0 discriminator 1
 3100 0158 ED A1 06                		mov.L	24[r10], r1
 3101 015b 05 00 00 00             		bsr	_wolfSSL_Free
 3102                             	.L189:
 3103                             	.LBE32:
1756:../src/wolfcrypt/src/rsa.c ****         return ret;
 3104                             		.loc 2 1756 16 is_stmt 1
 3105 015f ED A5 05                		mov.L	20[r10], r5
 3106 0162 38 38 01                		bra	.L177
 3107                             	.L188:
1757:../src/wolfcrypt/src/rsa.c ****     }
1758:../src/wolfcrypt/src/rsa.c **** 
1759:../src/wolfcrypt/src/rsa.c ****     tmp[0] &= (1 << bits) - 1;
 3108                             		.loc 2 1759 12
 3109 0165 ED A5 04                		mov.L	16[r10], r5
 3110 0168 CC 55                   		mov.B	[r5], r5
 3111 016a CF 53                   		mov.B	r5, r3
 3112                             		.loc 2 1759 18
 3113 016c 66 14                   		mov.L	#1, r4
 3114 016e A8 E5                   		mov.L	8[r6], r5
 3115 0170 EF 47                   		mov.L	r4, r7
 3116 0172 FD 62 57                		shll	r5, r7
 3117 0175 EF 75                   		mov.L	r7, r5
 3118                             		.loc 2 1759 27
 3119 0177 60 15                   		sub	#1, r5
 3120                             		.loc 2 1759 12
 3121 0179 53 35                   		and	r3, r5
 3122 017b CF 54                   		mov.B	r5, r4
 3123 017d ED A5 04                		mov.L	16[r10], r5
 3124 0180 C3 54                   		mov.B	r4, [r5]
1760:../src/wolfcrypt/src/rsa.c ****     pkcsBlock[0] &= (1 << bits) - 1;
 3125                             		.loc 2 1760 18
 3126 0182 ED A5 0A                		mov.L	40[r10], r5
 3127 0185 CC 55                   		mov.B	[r5], r5
 3128 0187 CF 53                   		mov.B	r5, r3
 3129                             		.loc 2 1760 24
 3130 0189 66 14                   		mov.L	#1, r4
 3131 018b A8 E5                   		mov.L	8[r6], r5
 3132 018d EF 47                   		mov.L	r4, r7
 3133 018f FD 62 57                		shll	r5, r7
 3134 0192 EF 75                   		mov.L	r7, r5
 3135                             		.loc 2 1760 33
 3136 0194 60 15                   		sub	#1, r5
 3137                             		.loc 2 1760 18
 3138 0196 53 35                   		and	r3, r5
 3139 0198 CF 54                   		mov.B	r5, r4
 3140 019a ED A5 0A                		mov.L	40[r10], r5
 3141 019d C3 54                   		mov.B	r4, [r5]
1761:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_PSS_SALT_LEN_DISCOVER
1762:../src/wolfcrypt/src/rsa.c ****     if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {
1763:../src/wolfcrypt/src/rsa.c ****         for (i = 0; i < maskLen - 1; i++) {
1764:../src/wolfcrypt/src/rsa.c ****             if (tmp[i] != pkcsBlock[i]) {
1765:../src/wolfcrypt/src/rsa.c ****                 break;
1766:../src/wolfcrypt/src/rsa.c ****             }
1767:../src/wolfcrypt/src/rsa.c ****         }
1768:../src/wolfcrypt/src/rsa.c ****         if (tmp[i] != (pkcsBlock[i] ^ 0x01)) {
1769:../src/wolfcrypt/src/rsa.c ****             XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
1770:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("RsaUnPad_PSS: Padding Error Match");
1771:../src/wolfcrypt/src/rsa.c ****             return PSS_SALTLEN_RECOVER_E;
1772:../src/wolfcrypt/src/rsa.c ****         }
1773:../src/wolfcrypt/src/rsa.c ****         saltLen = maskLen - (i + 1);
1774:../src/wolfcrypt/src/rsa.c ****     }
1775:../src/wolfcrypt/src/rsa.c ****     else
1776:../src/wolfcrypt/src/rsa.c **** #endif
1777:../src/wolfcrypt/src/rsa.c ****     {
1778:../src/wolfcrypt/src/rsa.c ****         for (i = 0; i < maskLen - 1 - saltLen; i++) {
 3142                             		.loc 2 1778 16
 3143 019f F8 A6 00                		mov.L	#0, [r10]
 3144                             		.loc 2 1778 9
 3145 01a2 2E 46                   		bra	.L190
 3146                             	.L193:
1779:../src/wolfcrypt/src/rsa.c ****             if (tmp[i] != pkcsBlock[i]) {
 3147                             		.loc 2 1779 20
 3148 01a4 EC A5                   		mov.L	[r10], r5
 3149 01a6 ED A4 04                		mov.L	16[r10], r4
 3150 01a9 4B 45                   		add	r4, r5
 3151 01ab CC 53                   		mov.B	[r5], r3
 3152                             		.loc 2 1779 36
 3153 01ad EC A5                   		mov.L	[r10], r5
 3154 01af ED A4 0A                		mov.L	40[r10], r4
 3155 01b2 4B 45                   		add	r4, r5
 3156 01b4 CC 55                   		mov.B	[r5], r5
 3157                             		.loc 2 1779 16
 3158 01b6 5B 34                   		movu.B	r3, r4
 3159 01b8 5B 55                   		movu.B	r5, r5
 3160 01ba 47 54                   		cmp	r5, r4
 3161 01bc 20 26                   		beq	.L191
 3162                             	.LBB33:
1780:../src/wolfcrypt/src/rsa.c ****                 XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 3163                             		.loc 2 1780 17
 3164 01be ED A5 04                		mov.L	16[r10], r5
 3165 01c1 E7 A5 07                		mov.L	r5, 28[r10]
 3166 01c4 ED A5 07                		mov.L	28[r10], r5
 3167 01c7 61 05                   		cmp	#0, r5
 3168 01c9 10                      		beq	.L192
 3169                             		.loc 2 1780 17 is_stmt 0 discriminator 1
 3170 01ca ED A1 07                		mov.L	28[r10], r1
 3171 01cd 05 00 00 00             		bsr	_wolfSSL_Free
 3172                             	.L192:
 3173                             	.LBE33:
1781:../src/wolfcrypt/src/rsa.c ****                 WOLFSSL_MSG("RsaUnPad_PSS: Padding Error Match");
 3174                             		.loc 2 1781 17 is_stmt 1
 3175 01d1 FB 12 5E 01 00 00       		mov.L	#.LC10, r1
 3176 01d7 05 00 00 00             		bsr	_WOLFSSL_MSG
1782:../src/wolfcrypt/src/rsa.c ****                 return PSS_SALTLEN_E;
 3177                             		.loc 2 1782 24
 3178 01db FB 5A 06 FF             		mov.L	#-250, r5
 3179 01df 38 BB 00                		bra	.L177
 3180                             	.L191:
1778:../src/wolfcrypt/src/rsa.c ****             if (tmp[i] != pkcsBlock[i]) {
 3181                             		.loc 2 1778 49 discriminator 2
 3182 01e2 EC A5                   		mov.L	[r10], r5
 3183 01e4 62 15                   		add	#1, r5
 3184 01e6 E3 A5                   		mov.L	r5, [r10]
 3185                             	.L190:
1778:../src/wolfcrypt/src/rsa.c ****             if (tmp[i] != pkcsBlock[i]) {
 3186                             		.loc 2 1778 33 discriminator 1
 3187 01e8 ED A5 03                		mov.L	12[r10], r5
 3188 01eb 60 15                   		sub	#1, r5
1778:../src/wolfcrypt/src/rsa.c ****             if (tmp[i] != pkcsBlock[i]) {
 3189                             		.loc 2 1778 37 discriminator 1
 3190 01ed A8 6C                   		mov.L	4[r6], r4
 3191 01ef 43 45                   		sub	r4, r5
1778:../src/wolfcrypt/src/rsa.c ****             if (tmp[i] != pkcsBlock[i]) {
 3192                             		.loc 2 1778 9 discriminator 1
 3193 01f1 EC A4                   		mov.L	[r10], r4
 3194 01f3 47 54                   		cmp	r5, r4
 3195 01f5 29 AF                   		blt	.L193
1783:../src/wolfcrypt/src/rsa.c ****             }
1784:../src/wolfcrypt/src/rsa.c ****         }
1785:../src/wolfcrypt/src/rsa.c ****         if (tmp[i] != (pkcsBlock[i] ^ 0x01)) {
 3196                             		.loc 2 1785 16
 3197 01f7 EC A5                   		mov.L	[r10], r5
 3198 01f9 ED A4 04                		mov.L	16[r10], r4
 3199 01fc 4B 45                   		add	r4, r5
 3200 01fe CC 53                   		mov.B	[r5], r3
 3201                             		.loc 2 1785 33
 3202 0200 EC A5                   		mov.L	[r10], r5
 3203 0202 ED A4 0A                		mov.L	40[r10], r4
 3204 0205 4B 45                   		add	r4, r5
 3205 0207 CC 55                   		mov.B	[r5], r5
 3206                             		.loc 2 1785 20
 3207 0209 FD 74 D5 01             		xor	#1, r5
 3208                             		.loc 2 1785 12
 3209 020d 5B 34                   		movu.B	r3, r4
 3210 020f 5B 55                   		movu.B	r5, r5
 3211 0211 47 54                   		cmp	r5, r4
 3212 0213 20 25                   		beq	.L194
 3213                             	.LBB34:
1786:../src/wolfcrypt/src/rsa.c ****             XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 3214                             		.loc 2 1786 13
 3215 0215 ED A5 04                		mov.L	16[r10], r5
 3216 0218 E7 A5 08                		mov.L	r5, 32[r10]
 3217 021b ED A5 08                		mov.L	32[r10], r5
 3218 021e 61 05                   		cmp	#0, r5
 3219 0220 10                      		beq	.L195
 3220                             		.loc 2 1786 13 is_stmt 0 discriminator 1
 3221 0221 ED A1 08                		mov.L	32[r10], r1
 3222 0224 05 00 00 00             		bsr	_wolfSSL_Free
 3223                             	.L195:
 3224                             	.LBE34:
1787:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("RsaUnPad_PSS: Padding Error End");
 3225                             		.loc 2 1787 13 is_stmt 1
 3226 0228 FB 12 80 01 00 00       		mov.L	#.LC11, r1
 3227 022e 05 00 00 00             		bsr	_WOLFSSL_MSG
1788:../src/wolfcrypt/src/rsa.c ****             return PSS_SALTLEN_E;
 3228                             		.loc 2 1788 20
 3229 0232 FB 5A 06 FF             		mov.L	#-250, r5
 3230 0236 2E 64                   		bra	.L177
 3231                             	.L194:
1789:../src/wolfcrypt/src/rsa.c ****         }
1790:../src/wolfcrypt/src/rsa.c ****     }
1791:../src/wolfcrypt/src/rsa.c ****     for (i++; i < maskLen; i++)
 3232                             		.loc 2 1791 11
 3233 0238 EC A5                   		mov.L	[r10], r5
 3234 023a 62 15                   		add	#1, r5
 3235 023c E3 A5                   		mov.L	r5, [r10]
 3236                             		.loc 2 1791 5
 3237 023e 2E 28                   		bra	.L196
 3238                             	.L197:
1792:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[i] ^= tmp[i];
 3239                             		.loc 2 1792 22 discriminator 3
 3240 0240 EC A5                   		mov.L	[r10], r5
 3241 0242 ED A4 0A                		mov.L	40[r10], r4
 3242 0245 4B 45                   		add	r4, r5
 3243 0247 CC 52                   		mov.B	[r5], r2
 3244                             		.loc 2 1792 28 discriminator 3
 3245 0249 EC A5                   		mov.L	[r10], r5
 3246 024b ED A4 04                		mov.L	16[r10], r4
 3247 024e 4B 45                   		add	r4, r5
 3248 0250 CC 53                   		mov.B	[r5], r3
 3249                             		.loc 2 1792 22 discriminator 3
 3250 0252 EC A5                   		mov.L	[r10], r5
 3251 0254 ED A4 0A                		mov.L	40[r10], r4
 3252 0257 4B 45                   		add	r4, r5
 3253 0259 EF 24                   		mov.L	r2, r4
 3254 025b FC 37 34                		xor	r3, r4
 3255 025e C3 54                   		mov.B	r4, [r5]
1791:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[i] ^= tmp[i];
 3256                             		.loc 2 1791 29 discriminator 3
 3257 0260 EC A5                   		mov.L	[r10], r5
 3258 0262 62 15                   		add	#1, r5
 3259 0264 E3 A5                   		mov.L	r5, [r10]
 3260                             	.L196:
1791:../src/wolfcrypt/src/rsa.c ****         pkcsBlock[i] ^= tmp[i];
 3261                             		.loc 2 1791 5 discriminator 1
 3262 0266 EC A4                   		mov.L	[r10], r4
 3263 0268 ED A5 03                		mov.L	12[r10], r5
 3264 026b 47 54                   		cmp	r5, r4
 3265 026d 29 D3                   		blt	.L197
 3266                             	.LBB35:
1793:../src/wolfcrypt/src/rsa.c **** 
1794:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
1795:../src/wolfcrypt/src/rsa.c ****     XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 3267                             		.loc 2 1795 5
 3268 026f ED A5 04                		mov.L	16[r10], r5
 3269 0272 E7 A5 09                		mov.L	r5, 36[r10]
 3270 0275 ED A5 09                		mov.L	36[r10], r5
 3271 0278 61 05                   		cmp	#0, r5
 3272 027a 10                      		beq	.L198
 3273                             		.loc 2 1795 5 is_stmt 0 discriminator 1
 3274 027b ED A1 09                		mov.L	36[r10], r1
 3275 027e 05 00 00 00             		bsr	_wolfSSL_Free
 3276                             	.L198:
 3277                             	.LBE35:
1796:../src/wolfcrypt/src/rsa.c **** #endif
1797:../src/wolfcrypt/src/rsa.c **** 
1798:../src/wolfcrypt/src/rsa.c ****     *output = pkcsBlock + maskLen - saltLen;
 3278                             		.loc 2 1798 35 is_stmt 1
 3279 0282 ED A4 03                		mov.L	12[r10], r4
 3280 0285 A8 6D                   		mov.L	4[r6], r5
 3281 0287 FF 05 54                		sub	r5, r4, r5
 3282 028a ED A4 0A                		mov.L	40[r10], r4
 3283 028d 4B 54                   		add	r5, r4
 3284                             		.loc 2 1798 13
 3285 028f ED A5 0C                		mov.L	48[r10], r5
 3286 0292 E3 54                   		mov.L	r4, [r5]
1799:../src/wolfcrypt/src/rsa.c ****     return saltLen + hLen;
 3287                             		.loc 2 1799 20
 3288 0294 A8 6D                   		mov.L	4[r6], r5
 3289 0296 06 89 A5 02             		add	8[r10].L, r5
 3290                             		.balign 8,3,1
 3291                             	.L177:
1800:../src/wolfcrypt/src/rsa.c **** }
 3292                             		.loc 2 1800 1
 3293 029a EF 51                   		mov.L	r5, r1
 3294 029c 3F 6A 19                		rtsd	#100, r6-r10
 3295                             	.LFE54:
 3297 029f 03                      		.section C,"a",@progbits
 3298                             		.p2align 2
 3299                             	.LC12:
 3300 01a0 52 73 61 55 6E 50 61 64 		.string	"RsaUnPad error, invalid formatting"
 3300      20 65 72 72 6F 72 2C 20 
 3300      69 6E 76 61 6C 69 64 20 
 3300      66 6F 72 6D 61 74 74 69 
 3300      6E 67 00 
 3301                             	.LC13:
 3302 01c3 52 73 61 55 6E 50 61 64 		.string	"RsaUnPad error, bad formatting"
 3302      20 65 72 72 6F 72 2C 20 
 3302      62 61 64 20 66 6F 72 6D 
 3302      61 74 74 69 6E 67 00 
 3303                             		.section	.text.RsaUnPad,"ax",@progbits
 3305                             	_RsaUnPad:
 3306                             	.LFB55:
1801:../src/wolfcrypt/src/rsa.c **** #endif
1802:../src/wolfcrypt/src/rsa.c **** 
1803:../src/wolfcrypt/src/rsa.c **** /* UnPad plaintext, set start to *output, return length of plaintext,
1804:../src/wolfcrypt/src/rsa.c ****  * < 0 on error */
1805:../src/wolfcrypt/src/rsa.c **** static int RsaUnPad(const byte *pkcsBlock, unsigned int pkcsBlockLen,
1806:../src/wolfcrypt/src/rsa.c ****                     byte **output, byte padValue)
1807:../src/wolfcrypt/src/rsa.c **** {
 3307                             		.loc 2 1807 1
 3308 0000 7E AA                   		push.l	r10
 3309                             	.LCFI64:
 3310 0002 7E A6                   		push.l	r6
 3311                             	.LCFI65:
 3312 0004 71 0A E0                		add	#-32, r0, r10
 3313                             	.LCFI66:
 3314 0007 EF A0                   		mov.L	r10, r0
 3315 0009 E7 A1 04                		mov.L	r1, 16[r10]
 3316 000c E7 A2 05                		mov.L	r2, 20[r10]
 3317 000f E7 A3 06                		mov.L	r3, 24[r10]
 3318 0012 C7 A4 1C                		mov.B	r4, 28[r10]
1808:../src/wolfcrypt/src/rsa.c ****     int    ret = BAD_FUNC_ARG;
 3319                             		.loc 2 1808 12
 3320 0015 F8 AA 53 FF             		mov.L	#-173, [r10]
1809:../src/wolfcrypt/src/rsa.c ****     word16 i;
1810:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
1811:../src/wolfcrypt/src/rsa.c ****     byte   invalid = 0;
 3321                             		.loc 2 1811 12
 3322 0019 F9 A4 0E 00             		mov.B	#0, 14[r10]
1812:../src/wolfcrypt/src/rsa.c **** #endif
1813:../src/wolfcrypt/src/rsa.c **** 
1814:../src/wolfcrypt/src/rsa.c ****     if (output == NULL || pkcsBlockLen < 2 || pkcsBlockLen > 0xFFFF) {
 3323                             		.loc 2 1814 8
 3324 001d ED A5 06                		mov.L	24[r10], r5
 3325 0020 61 05                   		cmp	#0, r5
 3326 0022 20 13                   		beq	.L200
 3327                             		.loc 2 1814 24 discriminator 1
 3328 0024 ED A5 05                		mov.L	20[r10], r5
 3329 0027 61 15                   		cmp	#1, r5
 3330 0029 25 0C                   		bleu	.L200
 3331                             		.loc 2 1814 44 discriminator 2
 3332 002b ED A5 05                		mov.L	20[r10], r5
 3333 002e 77 05 FF FF 00          		cmp	#0xffff, r5
 3334 0033 25 09                   		bleu	.L201
 3335                             	.L200:
1815:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 3336                             		.loc 2 1815 16
 3337 0035 FB 5A 53 FF             		mov.L	#-173, r5
 3338 0039 38 9C 01                		bra	.L202
 3339                             	.L201:
1816:../src/wolfcrypt/src/rsa.c ****     }
1817:../src/wolfcrypt/src/rsa.c **** 
1818:../src/wolfcrypt/src/rsa.c ****     if (padValue == RSA_BLOCK_TYPE_1) {
 3340                             		.loc 2 1818 8
 3341 003c 59 A5 1C                		movu.B	28[r10], r5
 3342 003f 61 15                   		cmp	#1, r5
 3343 0041 3B 9D 00                		bne	.L203
1819:../src/wolfcrypt/src/rsa.c ****         /* First byte must be 0x00 and Second byte, block type, 0x01 */
1820:../src/wolfcrypt/src/rsa.c ****         if (pkcsBlock[0] != 0 || pkcsBlock[1] != RSA_BLOCK_TYPE_1) {
 3344                             		.loc 2 1820 22
 3345 0044 ED A5 04                		mov.L	16[r10], r5
 3346 0047 CC 55                   		mov.B	[r5], r5
 3347                             		.loc 2 1820 12
 3348 0049 5B 55                   		movu.B	r5, r5
 3349 004b 61 05                   		cmp	#0, r5
 3350 004d 21 0F                   		bne	.L204
 3351                             		.loc 2 1820 43 discriminator 1
 3352 004f ED A5 04                		mov.L	16[r10], r5
 3353 0052 62 15                   		add	#1, r5
 3354 0054 CC 55                   		mov.B	[r5], r5
 3355                             		.loc 2 1820 31 discriminator 1
 3356 0056 5B 55                   		movu.B	r5, r5
 3357 0058 61 15                   		cmp	#1, r5
 3358 005a 20 13                   		beq	.L205
 3359                             	.L204:
1821:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("RsaUnPad error, invalid formatting");
 3360                             		.loc 2 1821 13
 3361 005c FB 12 A0 01 00 00       		mov.L	#.LC12, r1
 3362 0062 05 00 00 00             		bsr	_WOLFSSL_MSG
1822:../src/wolfcrypt/src/rsa.c ****             return RSA_PAD_E;
 3363                             		.loc 2 1822 20
 3364 0066 FB 5A 37 FF             		mov.L	#-201, r5
 3365 006a 38 6B 01                		bra	.L202
 3366                             	.L205:
1823:../src/wolfcrypt/src/rsa.c ****         }
1824:../src/wolfcrypt/src/rsa.c **** 
1825:../src/wolfcrypt/src/rsa.c ****         /* check the padding until we find the separator */
1826:../src/wolfcrypt/src/rsa.c ****         for (i = 2; i < pkcsBlockLen; ) {
 3367                             		.loc 2 1826 16
 3368 006d F9 A5 02 02             		mov.W	#2, 4[r10]
 3369                             		.loc 2 1826 9
 3370 0071 2E 1B                   		bra	.L206
 3371                             	.L208:
1827:../src/wolfcrypt/src/rsa.c ****             if (pkcsBlock[i++] != 0xFF) {
 3372                             		.loc 2 1827 28
 3373 0073 DD A5 02                		mov.W	4[r10], r5
 3374 0076 71 54 01                		add	#1, r5, r4
 3375 0079 D7 A4 02                		mov.W	r4, 4[r10]
 3376 007c 5F 55                   		movu.W	r5, r5
 3377                             		.loc 2 1827 26
 3378 007e ED A4 04                		mov.L	16[r10], r4
 3379 0081 4B 45                   		add	r4, r5
 3380 0083 CC 55                   		mov.B	[r5], r5
 3381                             		.loc 2 1827 16
 3382 0085 5B 55                   		movu.B	r5, r5
 3383 0087 75 55 FF                		cmp	#0xff, r5
 3384 008a 21 0E                   		bne	.L214
 3385                             	.L206:
1826:../src/wolfcrypt/src/rsa.c ****             if (pkcsBlock[i++] != 0xFF) {
 3386                             		.loc 2 1826 23 discriminator 1
 3387 008c 5D A5 02                		movu.W	4[r10], r5
1826:../src/wolfcrypt/src/rsa.c ****             if (pkcsBlock[i++] != 0xFF) {
 3388                             		.loc 2 1826 9 discriminator 1
 3389 008f ED A4 05                		mov.L	20[r10], r4
 3390 0092 47 54                   		cmp	r5, r4
 3391 0094 24 DF                   		bgtu	.L208
 3392 0096 2E 03                   		bra	.L207
 3393                             	.L214:
1828:../src/wolfcrypt/src/rsa.c ****                 break;
 3394                             		.loc 2 1828 17
 3395 0098 03                      		nop
 3396                             	.L207:
1829:../src/wolfcrypt/src/rsa.c ****             }
1830:../src/wolfcrypt/src/rsa.c ****         }
1831:../src/wolfcrypt/src/rsa.c **** 
1832:../src/wolfcrypt/src/rsa.c ****         /* Minimum of 11 bytes of pre-message data and must have separator. */
1833:../src/wolfcrypt/src/rsa.c ****         if (i < RSA_MIN_PAD_SZ || pkcsBlock[i-1] != 0) {
 3397                             		.loc 2 1833 12
 3398 0099 5D A5 02                		movu.W	4[r10], r5
 3399 009c 61 A5                   		cmp	#10, r5
 3400 009e 25 14                   		bleu	.L209
 3401                             		.loc 2 1833 44 discriminator 1
 3402 00a0 5D A5 02                		movu.W	4[r10], r5
 3403 00a3 60 15                   		sub	#1, r5
 3404 00a5 ED A4 04                		mov.L	16[r10], r4
 3405 00a8 4B 45                   		add	r4, r5
 3406 00aa CC 55                   		mov.B	[r5], r5
 3407                             		.loc 2 1833 32 discriminator 1
 3408 00ac 5B 55                   		movu.B	r5, r5
 3409 00ae 61 05                   		cmp	#0, r5
 3410 00b0 20 13                   		beq	.L210
 3411                             	.L209:
1834:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("RsaUnPad error, bad formatting");
 3412                             		.loc 2 1834 13
 3413 00b2 FB 12 C3 01 00 00       		mov.L	#.LC13, r1
 3414 00b8 05 00 00 00             		bsr	_WOLFSSL_MSG
1835:../src/wolfcrypt/src/rsa.c ****             return RSA_PAD_E;
 3415                             		.loc 2 1835 20
 3416 00bc FB 5A 37 FF             		mov.L	#-201, r5
 3417 00c0 38 15 01                		bra	.L202
 3418                             	.L210:
1836:../src/wolfcrypt/src/rsa.c ****         }
1837:../src/wolfcrypt/src/rsa.c **** 
1838:../src/wolfcrypt/src/rsa.c ****         *output = (byte *)(pkcsBlock + i);
 3419                             		.loc 2 1838 38
 3420 00c3 5D A5 02                		movu.W	4[r10], r5
 3421 00c6 ED A4 04                		mov.L	16[r10], r4
 3422 00c9 4B 54                   		add	r5, r4
 3423                             		.loc 2 1838 17
 3424 00cb ED A5 06                		mov.L	24[r10], r5
 3425 00ce E3 54                   		mov.L	r4, [r5]
1839:../src/wolfcrypt/src/rsa.c ****         ret = pkcsBlockLen - i;
 3426                             		.loc 2 1839 28
 3427 00d0 5D A5 02                		movu.W	4[r10], r5
 3428 00d3 ED A4 05                		mov.L	20[r10], r4
 3429 00d6 FF 05 54                		sub	r5, r4, r5
 3430                             		.loc 2 1839 13
 3431 00d9 E3 A5                   		mov.L	r5, [r10]
 3432 00db 38 F8 00                		bra	.L211
 3433                             	.L203:
 3434                             	.LBB36:
1840:../src/wolfcrypt/src/rsa.c ****     }
1841:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
1842:../src/wolfcrypt/src/rsa.c ****     else {
1843:../src/wolfcrypt/src/rsa.c ****         unsigned int j;
1844:../src/wolfcrypt/src/rsa.c ****         word16 pastSep = 0;
 3435                             		.loc 2 1844 16
 3436 00de F9 A5 06 00             		mov.W	#0, 12[r10]
1845:../src/wolfcrypt/src/rsa.c **** 
1846:../src/wolfcrypt/src/rsa.c ****         i = 0;
 3437                             		.loc 2 1846 11
 3438 00e2 F9 A5 02 00             		mov.W	#0, 4[r10]
1847:../src/wolfcrypt/src/rsa.c ****         /* Decrypted with private key - unpad must be constant time. */
1848:../src/wolfcrypt/src/rsa.c ****         for (j = 2; j < pkcsBlockLen; j++) {
 3439                             		.loc 2 1848 16
 3440 00e6 F9 A6 02 02             		mov.L	#2, 8[r10]
 3441                             		.loc 2 1848 9
 3442 00ea 2E 59                   		bra	.L212
 3443                             	.L213:
1849:../src/wolfcrypt/src/rsa.c ****            /* Update i if not passed the separator and at separator. */
1850:../src/wolfcrypt/src/rsa.c ****             i |= (~pastSep) & ctMask16Eq(pkcsBlock[j], 0x00) & (j + 1);
 3444                             		.loc 2 1850 19 discriminator 3
 3445 00ec 5D A5 06                		movu.W	12[r10], r5
 3446 00ef FC 3B 56                		not	r5, r6
 3447                             		.loc 2 1850 51 discriminator 3
 3448 00f2 ED A5 04                		mov.L	16[r10], r5
 3449 00f5 06 89 A5 02             		add	8[r10].L, r5
 3450 00f9 CC 55                   		mov.B	[r5], r5
 3451                             		.loc 2 1850 31 discriminator 3
 3452 00fb 5B 55                   		movu.B	r5, r5
 3453 00fd 66 02                   		mov.L	#0, r2
 3454 00ff EF 51                   		mov.L	r5, r1
 3455 0101 05 00 00 00             		bsr	_ctMask16Eq
 3456 0105 EF 15                   		mov.L	r1, r5
 3457 0107 5F 55                   		movu.W	r5, r5
 3458                             		.loc 2 1850 29 discriminator 3
 3459 0109 53 65                   		and	r6, r5
 3460 010b EF 54                   		mov.L	r5, r4
 3461                             		.loc 2 1850 67 discriminator 3
 3462 010d ED A5 02                		mov.L	8[r10], r5
 3463 0110 62 15                   		add	#1, r5
 3464                             		.loc 2 1850 62 discriminator 3
 3465 0112 53 45                   		and	r4, r5
 3466                             		.loc 2 1850 15 discriminator 3
 3467 0114 DD A4 02                		mov.W	4[r10], r4
 3468 0117 57 45                   		or	r4, r5
 3469 0119 D7 A5 02                		mov.W	r5, 4[r10]
1851:../src/wolfcrypt/src/rsa.c ****             pastSep |= ctMask16Eq(pkcsBlock[j], 0x00);
 3470                             		.loc 2 1851 44 discriminator 3
 3471 011c ED A5 04                		mov.L	16[r10], r5
 3472 011f 06 89 A5 02             		add	8[r10].L, r5
 3473 0123 CC 55                   		mov.B	[r5], r5
 3474                             		.loc 2 1851 24 discriminator 3
 3475 0125 5B 55                   		movu.B	r5, r5
 3476 0127 66 02                   		mov.L	#0, r2
 3477 0129 EF 51                   		mov.L	r5, r1
 3478 012b 05 00 00 00             		bsr	_ctMask16Eq
 3479 012f EF 15                   		mov.L	r1, r5
 3480 0131 DF 54                   		mov.W	r5, r4
 3481                             		.loc 2 1851 21 discriminator 3
 3482 0133 DD A5 06                		mov.W	12[r10], r5
 3483 0136 57 45                   		or	r4, r5
 3484 0138 D7 A5 06                		mov.W	r5, 12[r10]
1848:../src/wolfcrypt/src/rsa.c ****            /* Update i if not passed the separator and at separator. */
 3485                             		.loc 2 1848 40 discriminator 3
 3486 013b ED A5 02                		mov.L	8[r10], r5
 3487 013e 62 15                   		add	#1, r5
 3488 0140 E7 A5 02                		mov.L	r5, 8[r10]
 3489                             	.L212:
1848:../src/wolfcrypt/src/rsa.c ****            /* Update i if not passed the separator and at separator. */
 3490                             		.loc 2 1848 9 discriminator 1
 3491 0143 ED A4 02                		mov.L	8[r10], r4
 3492 0146 ED A5 05                		mov.L	20[r10], r5
 3493 0149 47 54                   		cmp	r5, r4
 3494 014b 23 A1                   		bltu	.L213
1852:../src/wolfcrypt/src/rsa.c ****         }
1853:../src/wolfcrypt/src/rsa.c **** 
1854:../src/wolfcrypt/src/rsa.c ****         /* Minimum of 11 bytes of pre-message data - including leading 0x00. */
1855:../src/wolfcrypt/src/rsa.c ****         invalid |= ctMaskLT(i, RSA_MIN_PAD_SZ);
 3495                             		.loc 2 1855 20
 3496 014d 5D A5 02                		movu.W	4[r10], r5
 3497 0150 66 B2                   		mov.L	#11, r2
 3498 0152 EF 51                   		mov.L	r5, r1
 3499 0154 05 00 00 00             		bsr	_ctMaskLT
 3500 0158 EF 15                   		mov.L	r1, r5
 3501 015a CF 54                   		mov.B	r5, r4
 3502                             		.loc 2 1855 17
 3503 015c CD A5 0E                		mov.B	14[r10], r5
 3504 015f 57 45                   		or	r4, r5
 3505 0161 C7 A5 0E                		mov.B	r5, 14[r10]
1856:../src/wolfcrypt/src/rsa.c ****         /* Must have seen separator. */
1857:../src/wolfcrypt/src/rsa.c ****         invalid |= ~pastSep;
 3506                             		.loc 2 1857 17
 3507 0164 DD A5 06                		mov.W	12[r10], r5
 3508 0167 7E 05                   		not	r5
 3509 0169 CF 54                   		mov.B	r5, r4
 3510 016b CD A5 0E                		mov.B	14[r10], r5
 3511 016e 57 45                   		or	r4, r5
 3512 0170 C7 A5 0E                		mov.B	r5, 14[r10]
1858:../src/wolfcrypt/src/rsa.c ****         /* First byte must be 0x00. */
1859:../src/wolfcrypt/src/rsa.c ****         invalid |= ctMaskNotEq(pkcsBlock[0], 0x00);
 3513                             		.loc 2 1859 41
 3514 0173 ED A5 04                		mov.L	16[r10], r5
 3515 0176 CC 55                   		mov.B	[r5], r5
 3516                             		.loc 2 1859 20
 3517 0178 5B 55                   		movu.B	r5, r5
 3518 017a 66 02                   		mov.L	#0, r2
 3519 017c EF 51                   		mov.L	r5, r1
 3520 017e 05 00 00 00             		bsr	_ctMaskNotEq
 3521 0182 EF 15                   		mov.L	r1, r5
 3522 0184 CF 54                   		mov.B	r5, r4
 3523                             		.loc 2 1859 17
 3524 0186 CD A5 0E                		mov.B	14[r10], r5
 3525 0189 57 45                   		or	r4, r5
 3526 018b C7 A5 0E                		mov.B	r5, 14[r10]
1860:../src/wolfcrypt/src/rsa.c ****         /* Check against expected block type: padValue */
1861:../src/wolfcrypt/src/rsa.c ****         invalid |= ctMaskNotEq(pkcsBlock[1], padValue);
 3527                             		.loc 2 1861 41
 3528 018e ED A5 04                		mov.L	16[r10], r5
 3529 0191 62 15                   		add	#1, r5
 3530 0193 CC 55                   		mov.B	[r5], r5
 3531                             		.loc 2 1861 20
 3532 0195 5B 55                   		movu.B	r5, r5
 3533 0197 59 A4 1C                		movu.B	28[r10], r4
 3534 019a EF 42                   		mov.L	r4, r2
 3535 019c EF 51                   		mov.L	r5, r1
 3536 019e 05 00 00 00             		bsr	_ctMaskNotEq
 3537 01a2 EF 15                   		mov.L	r1, r5
 3538 01a4 CF 54                   		mov.B	r5, r4
 3539                             		.loc 2 1861 17
 3540 01a6 CD A5 0E                		mov.B	14[r10], r5
 3541 01a9 57 45                   		or	r4, r5
 3542 01ab C7 A5 0E                		mov.B	r5, 14[r10]
1862:../src/wolfcrypt/src/rsa.c **** 
1863:../src/wolfcrypt/src/rsa.c ****         *output = (byte *)(pkcsBlock + i);
 3543                             		.loc 2 1863 38
 3544 01ae 5D A5 02                		movu.W	4[r10], r5
 3545 01b1 ED A4 04                		mov.L	16[r10], r4
 3546 01b4 4B 54                   		add	r5, r4
 3547                             		.loc 2 1863 17
 3548 01b6 ED A5 06                		mov.L	24[r10], r5
 3549 01b9 E3 54                   		mov.L	r4, [r5]
1864:../src/wolfcrypt/src/rsa.c ****         ret = ((int)-1 + (int)(invalid >> 7)) & (pkcsBlockLen - i);
 3550                             		.loc 2 1864 26
 3551 01bb 59 A5 0E                		movu.B	14[r10], r5
 3552 01be 68 75                   		shlr	#7, r5
 3553 01c0 5B 55                   		movu.B	r5, r5
 3554                             		.loc 2 1864 24
 3555 01c2 60 15                   		sub	#1, r5
 3556 01c4 EF 53                   		mov.L	r5, r3
 3557                             		.loc 2 1864 63
 3558 01c6 5D A5 02                		movu.W	4[r10], r5
 3559 01c9 ED A4 05                		mov.L	20[r10], r4
 3560 01cc FF 05 54                		sub	r5, r4, r5
 3561                             		.loc 2 1864 47
 3562 01cf 53 35                   		and	r3, r5
 3563                             		.loc 2 1864 13
 3564 01d1 E3 A5                   		mov.L	r5, [r10]
 3565                             	.L211:
 3566                             	.LBE36:
1865:../src/wolfcrypt/src/rsa.c ****     }
1866:../src/wolfcrypt/src/rsa.c **** #endif
1867:../src/wolfcrypt/src/rsa.c **** 
1868:../src/wolfcrypt/src/rsa.c ****     return ret;
 3567                             		.loc 2 1868 12
 3568 01d3 EC A5                   		mov.L	[r10], r5
 3569                             		.balign 8,3,1
 3570                             	.L202:
1869:../src/wolfcrypt/src/rsa.c **** }
 3571                             		.loc 2 1869 1
 3572 01d5 EF 51                   		mov.L	r5, r1
 3573 01d7 71 00 20                		add	#32, r0
 3574 01da 7E B6                   		pop	r6
 3575 01dc 7E BA                   		pop	r10
 3576 01de 02                      		rts
 3577                             	.LFE55:
 3579 01df 03                      		.section C,"a",@progbits
 3580 01e2 00 00                   		.p2align 2
 3581                             	.LC14:
 3582 01e4 77 6F 6C 66 53 53 4C 20 		.string	"wolfSSL Using RSA OAEP un-padding"
 3582      55 73 69 6E 67 20 52 53 
 3582      41 20 4F 41 45 50 20 75 
 3582      6E 2D 70 61 64 64 69 6E 
 3582      67 00 
 3583                             	.LC15:
 3584 0206 77 6F 6C 66 53 53 4C 20 		.string	"wolfSSL Using RSA PSS un-padding"
 3584      55 73 69 6E 67 20 52 53 
 3584      41 20 50 53 53 20 75 6E 
 3584      2D 70 61 64 64 69 6E 67 
 3584      00 
 3585                             	.LC16:
 3586 0227 55 6E 6B 6E 6F 77 6E 20 		.string	"Unknown RSA UnPad Type"
 3586      52 53 41 20 55 6E 50 61 
 3586      64 20 54 79 70 65 00 
 3587                             		.section	.text.wc_RsaUnPad_ex,"ax",@progbits
 3588                             		.global	_wc_RsaUnPad_ex
 3590                             	_wc_RsaUnPad_ex:
 3591                             	.LFB56:
1870:../src/wolfcrypt/src/rsa.c **** 
1871:../src/wolfcrypt/src/rsa.c **** /* helper function to direct unpadding
1872:../src/wolfcrypt/src/rsa.c ****  *
1873:../src/wolfcrypt/src/rsa.c ****  * bits is the key modulus size in bits
1874:../src/wolfcrypt/src/rsa.c ****  */
1875:../src/wolfcrypt/src/rsa.c **** int wc_RsaUnPad_ex(byte* pkcsBlock, word32 pkcsBlockLen, byte** out,
1876:../src/wolfcrypt/src/rsa.c ****                    byte padValue, int padType, enum wc_HashType hType,
1877:../src/wolfcrypt/src/rsa.c ****                    int mgf, byte* optLabel, word32 labelLen, int saltLen,
1878:../src/wolfcrypt/src/rsa.c ****                    int bits, void* heap)
1879:../src/wolfcrypt/src/rsa.c **** {
 3592                             		.loc 2 1879 1
 3593 0000 7E AA                   		push.l	r10
 3594                             	.LCFI67:
 3595 0002 7E A6                   		push.l	r6
 3596                             	.LCFI68:
 3597 0004 71 0A CC                		add	#-52, r0, r10
 3598                             	.LCFI69:
 3599 0007 71 A0 F0                		add	#-16, r10, r0
 3600                             	.LCFI70:
 3601 000a 75 46 40                		mov.L	#0x40, r6
 3602 000d 4B A6                   		add	r10, r6
 3603 000f E7 A1 01                		mov.L	r1, 4[r10]
 3604 0012 E7 A2 02                		mov.L	r2, 8[r10]
 3605 0015 E7 A3 03                		mov.L	r3, 12[r10]
 3606 0018 C7 A4 10                		mov.B	r4, 16[r10]
1880:../src/wolfcrypt/src/rsa.c ****     int ret;
1881:../src/wolfcrypt/src/rsa.c **** 
1882:../src/wolfcrypt/src/rsa.c ****     switch (padType) {
 3607                             		.loc 2 1882 5
 3608 001b EC 65                   		mov.L	[r6], r5
 3609 001d 61 15                   		cmp	#1, r5
 3610 001f 20 22                   		beq	.L216
 3611 0021 EC 65                   		mov.L	[r6], r5
 3612 0023 61 25                   		cmp	#2, r5
 3613 0025 20 49                   		beq	.L217
 3614 0027 EC 65                   		mov.L	[r6], r5
 3615 0029 61 05                   		cmp	#0, r5
 3616 002b 21 70                   		bne	.L218
1883:../src/wolfcrypt/src/rsa.c ****         case WC_RSA_PKCSV15_PAD:
1884:../src/wolfcrypt/src/rsa.c ****             /*WOLFSSL_MSG("wolfSSL Using RSA PKCSV15 un-padding");*/
1885:../src/wolfcrypt/src/rsa.c ****             ret = RsaUnPad(pkcsBlock, pkcsBlockLen, out, padValue);
 3617                             		.loc 2 1885 19
 3618 002d CD A4 10                		mov.B	16[r10], r4
 3619 0030 ED A3 03                		mov.L	12[r10], r3
 3620 0033 ED A2 02                		mov.L	8[r10], r2
 3621 0036 ED A1 01                		mov.L	4[r10], r1
 3622 0039 05 00 00 00             		bsr	_RsaUnPad
 3623 003d E3 A1                   		mov.L	r1, [r10]
1886:../src/wolfcrypt/src/rsa.c ****             break;
 3624                             		.loc 2 1886 13
 3625 003f 2E 6A                   		bra	.L219
 3626                             	.L216:
1887:../src/wolfcrypt/src/rsa.c **** 
1888:../src/wolfcrypt/src/rsa.c ****     #ifndef WC_NO_RSA_OAEP
1889:../src/wolfcrypt/src/rsa.c ****         case WC_RSA_OAEP_PAD:
1890:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("wolfSSL Using RSA OAEP un-padding");
 3627                             		.loc 2 1890 13
 3628 0041 FB 12 E4 01 00 00       		mov.L	#.LC14, r1
 3629 0047 05 00 00 00             		bsr	_WOLFSSL_MSG
1891:../src/wolfcrypt/src/rsa.c ****             ret = RsaUnPad_OAEP((byte*)pkcsBlock, pkcsBlockLen, out,
 3630                             		.loc 2 1891 19
 3631 004b A9 ED                   		mov.L	28[r6], r5
 3632 004d A0 8D                   		mov.L	r5, 12[r0]
 3633 004f A9 65                   		mov.L	16[r6], r5
 3634 0051 A0 85                   		mov.L	r5, 8[r0]
 3635 0053 A8 ED                   		mov.L	12[r6], r5
 3636 0055 A0 0D                   		mov.L	r5, 4[r0]
 3637 0057 A8 E5                   		mov.L	8[r6], r5
 3638 0059 E3 05                   		mov.L	r5, [r0]
 3639 005b A8 6C                   		mov.L	4[r6], r4
 3640 005d ED A3 03                		mov.L	12[r10], r3
 3641 0060 ED A2 02                		mov.L	8[r10], r2
 3642 0063 ED A1 01                		mov.L	4[r10], r1
 3643 0066 05 00 00 00             		bsr	_RsaUnPad_OAEP
 3644 006a E3 A1                   		mov.L	r1, [r10]
1892:../src/wolfcrypt/src/rsa.c ****                                         hType, mgf, optLabel, labelLen, heap);
1893:../src/wolfcrypt/src/rsa.c ****             break;
 3645                             		.loc 2 1893 13
 3646 006c 2E 3D                   		bra	.L219
 3647                             	.L217:
1894:../src/wolfcrypt/src/rsa.c ****     #endif
1895:../src/wolfcrypt/src/rsa.c **** 
1896:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_PSS
1897:../src/wolfcrypt/src/rsa.c ****         case WC_RSA_PSS_PAD:
1898:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("wolfSSL Using RSA PSS un-padding");
 3648                             		.loc 2 1898 13
 3649 006e FB 12 06 02 00 00       		mov.L	#.LC15, r1
 3650 0074 05 00 00 00             		bsr	_WOLFSSL_MSG
1899:../src/wolfcrypt/src/rsa.c ****             ret = RsaUnPad_PSS((byte*)pkcsBlock, pkcsBlockLen, out, hType, mgf,
 3651                             		.loc 2 1899 19
 3652 0078 A9 ED                   		mov.L	28[r6], r5
 3653 007a A0 8D                   		mov.L	r5, 12[r0]
 3654 007c A9 E5                   		mov.L	24[r6], r5
 3655 007e A0 85                   		mov.L	r5, 8[r0]
 3656 0080 A9 6D                   		mov.L	20[r6], r5
 3657 0082 A0 0D                   		mov.L	r5, 4[r0]
 3658 0084 A8 E5                   		mov.L	8[r6], r5
 3659 0086 E3 05                   		mov.L	r5, [r0]
 3660 0088 A8 6C                   		mov.L	4[r6], r4
 3661 008a ED A3 03                		mov.L	12[r10], r3
 3662 008d ED A2 02                		mov.L	8[r10], r2
 3663 0090 ED A1 01                		mov.L	4[r10], r1
 3664 0093 05 00 00 00             		bsr	_RsaUnPad_PSS
 3665 0097 E3 A1                   		mov.L	r1, [r10]
1900:../src/wolfcrypt/src/rsa.c ****                                                            saltLen, bits, heap);
1901:../src/wolfcrypt/src/rsa.c ****             break;
 3666                             		.loc 2 1901 13
 3667 0099 2E 10                   		bra	.L219
 3668                             	.L218:
1902:../src/wolfcrypt/src/rsa.c ****     #endif
1903:../src/wolfcrypt/src/rsa.c **** 
1904:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_NO_PADDING
1905:../src/wolfcrypt/src/rsa.c ****         case WC_RSA_NO_PAD:
1906:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("wolfSSL Using NO un-padding");
1907:../src/wolfcrypt/src/rsa.c **** 
1908:../src/wolfcrypt/src/rsa.c ****             /* In the case of no padding being used check that input is exactly
1909:../src/wolfcrypt/src/rsa.c ****              * the RSA key length */
1910:../src/wolfcrypt/src/rsa.c ****             if (bits <= 0 || pkcsBlockLen !=
1911:../src/wolfcrypt/src/rsa.c ****                          ((word32)(bits+WOLFSSL_BIT_SIZE-1)/WOLFSSL_BIT_SIZE)) {
1912:../src/wolfcrypt/src/rsa.c ****                 WOLFSSL_MSG("Bad input size");
1913:../src/wolfcrypt/src/rsa.c ****                 ret = RSA_PAD_E;
1914:../src/wolfcrypt/src/rsa.c ****             }
1915:../src/wolfcrypt/src/rsa.c ****             else {
1916:../src/wolfcrypt/src/rsa.c ****                 if (out != NULL) {
1917:../src/wolfcrypt/src/rsa.c ****                     *out = pkcsBlock;
1918:../src/wolfcrypt/src/rsa.c ****                 }
1919:../src/wolfcrypt/src/rsa.c ****                 ret = pkcsBlockLen;
1920:../src/wolfcrypt/src/rsa.c ****             }
1921:../src/wolfcrypt/src/rsa.c ****             break;
1922:../src/wolfcrypt/src/rsa.c ****     #endif /* WC_RSA_NO_PADDING */
1923:../src/wolfcrypt/src/rsa.c **** 
1924:../src/wolfcrypt/src/rsa.c ****         default:
1925:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("Unknown RSA UnPad Type");
 3669                             		.loc 2 1925 13
 3670 009b FB 12 27 02 00 00       		mov.L	#.LC16, r1
 3671 00a1 05 00 00 00             		bsr	_WOLFSSL_MSG
1926:../src/wolfcrypt/src/rsa.c ****             ret = RSA_PAD_E;
 3672                             		.loc 2 1926 17
 3673 00a5 F8 AA 37 FF             		mov.L	#-201, [r10]
 3674                             		.balign 8,3,1
 3675                             	.L219:
1927:../src/wolfcrypt/src/rsa.c ****     }
1928:../src/wolfcrypt/src/rsa.c **** 
1929:../src/wolfcrypt/src/rsa.c ****     /* silence warning if not used with padding scheme */
1930:../src/wolfcrypt/src/rsa.c ****     (void)hType;
1931:../src/wolfcrypt/src/rsa.c ****     (void)mgf;
1932:../src/wolfcrypt/src/rsa.c ****     (void)optLabel;
1933:../src/wolfcrypt/src/rsa.c ****     (void)labelLen;
1934:../src/wolfcrypt/src/rsa.c ****     (void)saltLen;
1935:../src/wolfcrypt/src/rsa.c ****     (void)bits;
1936:../src/wolfcrypt/src/rsa.c ****     (void)heap;
1937:../src/wolfcrypt/src/rsa.c **** 
1938:../src/wolfcrypt/src/rsa.c ****     return ret;
 3676                             		.loc 2 1938 12
 3677 00a9 EC A5                   		mov.L	[r10], r5
1939:../src/wolfcrypt/src/rsa.c **** }
 3678                             		.loc 2 1939 1
 3679 00ab EF 51                   		mov.L	r5, r1
 3680 00ad 71 00 44                		add	#0x44, r0
 3681 00b0 7E B6                   		pop	r6
 3682 00b2 7E BA                   		pop	r10
 3683 00b4 02                      		rts
 3684                             	.LFE56:
 3686 00b5 FC 13 00                		.section C,"a",@progbits
 3687 023e 00 00                   		.p2align 2
 3688                             	.LC17:
 3689 0240 55 6E 72 65 63 6F 67 6E 		.string	"Unrecognized or unsupported hash function"
 3689      69 7A 65 64 20 6F 72 20 
 3689      75 6E 73 75 70 70 6F 72 
 3689      74 65 64 20 68 61 73 68 
 3689      20 66 75 6E 63 74 69 6F 
 3690                             		.section	.text.wc_hash2mgf,"ax",@progbits
 3691                             		.global	_wc_hash2mgf
 3693                             	_wc_hash2mgf:
 3694                             	.LFB57:
1940:../src/wolfcrypt/src/rsa.c **** 
1941:../src/wolfcrypt/src/rsa.c **** int wc_hash2mgf(enum wc_HashType hType)
1942:../src/wolfcrypt/src/rsa.c **** {
 3695                             		.loc 2 1942 1
 3696 0000 7E AA                   		push.l	r10
 3697                             	.LCFI71:
 3698 0002 71 0A FC                		add	#-4, r0, r10
 3699                             	.LCFI72:
 3700 0005 EF A0                   		mov.L	r10, r0
 3701 0007 E3 A1                   		mov.L	r1, [r10]
1943:../src/wolfcrypt/src/rsa.c ****     switch (hType) {
 3702                             		.loc 2 1943 5
 3703 0009 EC A5                   		mov.L	[r10], r5
 3704 000b 61 55                   		cmp	#5, r5
 3705 000d 20 3F                   		beq	.L232
 3706 000f EC A5                   		mov.L	[r10], r5
 3707 0011 61 55                   		cmp	#5, r5
 3708 0013 24 10                   		bgtu	.L223
 3709 0015 EC A5                   		mov.L	[r10], r5
 3710 0017 61 05                   		cmp	#0, r5
 3711 0019 20 1E                   		beq	.L224
 3712 001b EC A5                   		mov.L	[r10], r5
 3713 001d 61 45                   		cmp	#4, r5
 3714 001f 20 1C                   		beq	.L225
1944:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_NONE:
1945:../src/wolfcrypt/src/rsa.c ****         return WC_MGF1NONE;
1946:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA:
1947:../src/wolfcrypt/src/rsa.c **** #ifndef NO_SHA
1948:../src/wolfcrypt/src/rsa.c ****         return WC_MGF1SHA1;
1949:../src/wolfcrypt/src/rsa.c **** #else
1950:../src/wolfcrypt/src/rsa.c ****         break;
1951:../src/wolfcrypt/src/rsa.c **** #endif
1952:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA224:
1953:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SHA224
1954:../src/wolfcrypt/src/rsa.c ****         return WC_MGF1SHA224;
1955:../src/wolfcrypt/src/rsa.c **** #else
1956:../src/wolfcrypt/src/rsa.c ****         break;
1957:../src/wolfcrypt/src/rsa.c **** #endif
1958:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA256:
1959:../src/wolfcrypt/src/rsa.c **** #ifndef NO_SHA256
1960:../src/wolfcrypt/src/rsa.c ****         return WC_MGF1SHA256;
1961:../src/wolfcrypt/src/rsa.c **** #else
1962:../src/wolfcrypt/src/rsa.c ****         break;
1963:../src/wolfcrypt/src/rsa.c **** #endif
1964:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA384:
1965:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SHA384
1966:../src/wolfcrypt/src/rsa.c ****         return WC_MGF1SHA384;
1967:../src/wolfcrypt/src/rsa.c **** #else
1968:../src/wolfcrypt/src/rsa.c ****         break;
1969:../src/wolfcrypt/src/rsa.c **** #endif
1970:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA512:
1971:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SHA512
1972:../src/wolfcrypt/src/rsa.c ****         return WC_MGF1SHA512;
1973:../src/wolfcrypt/src/rsa.c **** #else
1974:../src/wolfcrypt/src/rsa.c ****         break;
1975:../src/wolfcrypt/src/rsa.c **** #endif
1976:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_MD2:
1977:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_MD4:
1978:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_MD5:
1979:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_MD5_SHA:
1980:../src/wolfcrypt/src/rsa.c ****     #ifndef WOLFSSL_NOSHA512_224
1981:../src/wolfcrypt/src/rsa.c ****         case WC_HASH_TYPE_SHA512_224:
1982:../src/wolfcrypt/src/rsa.c ****     #endif
1983:../src/wolfcrypt/src/rsa.c ****     #ifndef WOLFSSL_NOSHA512_256
1984:../src/wolfcrypt/src/rsa.c ****         case WC_HASH_TYPE_SHA512_256:
1985:../src/wolfcrypt/src/rsa.c ****     #endif
1986:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA3_224:
1987:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA3_256:
1988:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA3_384:
1989:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA3_512:
1990:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_BLAKE2B:
1991:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_BLAKE2S:
1992:../src/wolfcrypt/src/rsa.c ****     #ifndef WOLFSSL_NO_SHAKE256
1993:../src/wolfcrypt/src/rsa.c ****         case WC_HASH_TYPE_SHAKE128:
1994:../src/wolfcrypt/src/rsa.c ****         case WC_HASH_TYPE_SHAKE256:
1995:../src/wolfcrypt/src/rsa.c ****     #endif
1996:../src/wolfcrypt/src/rsa.c ****     default:
1997:../src/wolfcrypt/src/rsa.c ****         break;
 3715                             		.loc 2 1997 9
 3716 0021 2E 2C                   		bra	.L231
 3717                             	.L223:
1943:../src/wolfcrypt/src/rsa.c ****     switch (hType) {
 3718                             		.loc 2 1943 5
 3719 0023 EC A5                   		mov.L	[r10], r5
 3720 0025 61 75                   		cmp	#7, r5
 3721 0027 20 1D                   		beq	.L227
 3722 0029 EC A5                   		mov.L	[r10], r5
 3723 002b 61 75                   		cmp	#7, r5
 3724 002d 23 13                   		bltu	.L228
 3725 002f EC A5                   		mov.L	[r10], r5
 3726 0031 61 85                   		cmp	#8, r5
 3727 0033 20 15                   		beq	.L229
 3728                             		.loc 2 1997 9
 3729 0035 2E 18                   		bra	.L231
 3730                             	.L224:
1945:../src/wolfcrypt/src/rsa.c ****     case WC_HASH_TYPE_SHA:
 3731                             		.loc 2 1945 16
 3732 0037 66 05                   		mov.L	#0, r5
 3733 0039 2E 20                   		bra	.L230
 3734                             	.L225:
1948:../src/wolfcrypt/src/rsa.c **** #else
 3735                             		.loc 2 1948 16
 3736 003b 75 45 1A                		mov.L	#26, r5
 3737 003e 2E 1B                   		bra	.L230
 3738                             	.L228:
1960:../src/wolfcrypt/src/rsa.c **** #else
 3739                             		.loc 2 1960 16
 3740 0040 66 15                   		mov.L	#1, r5
 3741 0042 2E 17                   		bra	.L230
 3742                             	.L227:
1966:../src/wolfcrypt/src/rsa.c **** #else
 3743                             		.loc 2 1966 16
 3744 0044 66 25                   		mov.L	#2, r5
 3745 0046 2E 13                   		bra	.L230
 3746                             	.L229:
1972:../src/wolfcrypt/src/rsa.c **** #else
 3747                             		.loc 2 1972 16
 3748 0048 66 35                   		mov.L	#3, r5
 3749 004a 2E 0F                   		bra	.L230
 3750                             	.L232:
1956:../src/wolfcrypt/src/rsa.c **** #endif
 3751                             		.loc 2 1956 9
 3752 004c 03                      		nop
 3753                             	.L231:
1998:../src/wolfcrypt/src/rsa.c ****     }
1999:../src/wolfcrypt/src/rsa.c ****     WOLFSSL_MSG("Unrecognized or unsupported hash function");
 3754                             		.loc 2 1999 5
 3755 004d FB 12 40 02 00 00       		mov.L	#.LC17, r1
 3756 0053 05 00 00 00             		bsr	_WOLFSSL_MSG
2000:../src/wolfcrypt/src/rsa.c ****     return WC_MGF1NONE;
 3757                             		.loc 2 2000 12
 3758 0057 66 05                   		mov.L	#0, r5
 3759                             		.balign 8,3,1
 3760                             	.L230:
2001:../src/wolfcrypt/src/rsa.c **** }
 3761                             		.loc 2 2001 1
 3762 0059 EF 51                   		mov.L	r5, r1
 3763 005b 3F AA 02                		rtsd	#8, r10-r10
 3764                             	.LFE57:
 3766 005e EF 00                   		.section C,"a",@progbits
 3767 026a 00 00                   		.p2align 2
 3768                             	.LC18:
 3769 026c 45 78 70 65 63 74 65 64 		.string	"Expected that inLen be no longer RSA key length"
 3769      20 74 68 61 74 20 69 6E 
 3769      4C 65 6E 20 62 65 20 6E 
 3769      6F 20 6C 6F 6E 67 65 72 
 3769      20 52 53 41 20 6B 65 79 
 3770                             		.section	.text.wc_RsaFunctionSync,"ax",@progbits
 3772                             	_wc_RsaFunctionSync:
 3773                             	.LFB58:
2002:../src/wolfcrypt/src/rsa.c **** 
2003:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_NONBLOCK
2004:../src/wolfcrypt/src/rsa.c **** static int wc_RsaFunctionNonBlock(const byte* in, word32 inLen, byte* out,
2005:../src/wolfcrypt/src/rsa.c ****                           word32* outLen, int type, RsaKey* key)
2006:../src/wolfcrypt/src/rsa.c **** {
2007:../src/wolfcrypt/src/rsa.c ****     int    ret = 0;
2008:../src/wolfcrypt/src/rsa.c ****     word32 keyLen, len;
2009:../src/wolfcrypt/src/rsa.c **** 
2010:../src/wolfcrypt/src/rsa.c ****     if (key == NULL || key->nb == NULL) {
2011:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
2012:../src/wolfcrypt/src/rsa.c ****     }
2013:../src/wolfcrypt/src/rsa.c **** 
2014:../src/wolfcrypt/src/rsa.c ****     if (key->nb->exptmod.state == TFM_EXPTMOD_NB_INIT) {
2015:../src/wolfcrypt/src/rsa.c ****         if (mp_init(&key->nb->tmp) != MP_OKAY) {
2016:../src/wolfcrypt/src/rsa.c ****             ret = MP_INIT_E;
2017:../src/wolfcrypt/src/rsa.c ****         }
2018:../src/wolfcrypt/src/rsa.c **** 
2019:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
2020:../src/wolfcrypt/src/rsa.c ****             if (mp_read_unsigned_bin(&key->nb->tmp, (byte*)in, inLen) != MP_OKAY) {
2021:../src/wolfcrypt/src/rsa.c ****                 ret = MP_READ_E;
2022:../src/wolfcrypt/src/rsa.c ****             }
2023:../src/wolfcrypt/src/rsa.c ****         }
2024:../src/wolfcrypt/src/rsa.c ****     }
2025:../src/wolfcrypt/src/rsa.c **** 
2026:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
2027:../src/wolfcrypt/src/rsa.c ****         switch(type) {
2028:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_DECRYPT:
2029:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_ENCRYPT:
2030:../src/wolfcrypt/src/rsa.c ****             ret = fp_exptmod_nb(&key->nb->exptmod, &key->nb->tmp, &key->d,
2031:../src/wolfcrypt/src/rsa.c ****                 &key->n, &key->nb->tmp);
2032:../src/wolfcrypt/src/rsa.c ****             if (ret == FP_WOULDBLOCK)
2033:../src/wolfcrypt/src/rsa.c ****                 return ret;
2034:../src/wolfcrypt/src/rsa.c ****             if (ret != MP_OKAY)
2035:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
2036:../src/wolfcrypt/src/rsa.c ****             break;
2037:../src/wolfcrypt/src/rsa.c **** 
2038:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_ENCRYPT:
2039:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_DECRYPT:
2040:../src/wolfcrypt/src/rsa.c ****             ret = fp_exptmod_nb(&key->nb->exptmod, &key->nb->tmp, &key->e,
2041:../src/wolfcrypt/src/rsa.c ****                 &key->n, &key->nb->tmp);
2042:../src/wolfcrypt/src/rsa.c ****             if (ret == FP_WOULDBLOCK)
2043:../src/wolfcrypt/src/rsa.c ****                 return ret;
2044:../src/wolfcrypt/src/rsa.c ****             if (ret != MP_OKAY)
2045:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
2046:../src/wolfcrypt/src/rsa.c ****             break;
2047:../src/wolfcrypt/src/rsa.c ****         default:
2048:../src/wolfcrypt/src/rsa.c ****             ret = RSA_WRONG_TYPE_E;
2049:../src/wolfcrypt/src/rsa.c ****             break;
2050:../src/wolfcrypt/src/rsa.c ****         }
2051:../src/wolfcrypt/src/rsa.c ****     }
2052:../src/wolfcrypt/src/rsa.c **** 
2053:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
2054:../src/wolfcrypt/src/rsa.c ****         keyLen = wc_RsaEncryptSize(key);
2055:../src/wolfcrypt/src/rsa.c ****         if (keyLen > *outLen)
2056:../src/wolfcrypt/src/rsa.c ****             ret = RSA_BUFFER_E;
2057:../src/wolfcrypt/src/rsa.c ****     }
2058:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
2059:../src/wolfcrypt/src/rsa.c ****         len = mp_unsigned_bin_size(&key->nb->tmp);
2060:../src/wolfcrypt/src/rsa.c **** 
2061:../src/wolfcrypt/src/rsa.c ****         /* pad front w/ zeros to match key length */
2062:../src/wolfcrypt/src/rsa.c ****         while (len < keyLen) {
2063:../src/wolfcrypt/src/rsa.c ****             *out++ = 0x00;
2064:../src/wolfcrypt/src/rsa.c ****             len++;
2065:../src/wolfcrypt/src/rsa.c ****         }
2066:../src/wolfcrypt/src/rsa.c **** 
2067:../src/wolfcrypt/src/rsa.c ****         *outLen = keyLen;
2068:../src/wolfcrypt/src/rsa.c **** 
2069:../src/wolfcrypt/src/rsa.c ****         /* convert */
2070:../src/wolfcrypt/src/rsa.c ****         if (mp_to_unsigned_bin(&key->nb->tmp, out) != MP_OKAY) {
2071:../src/wolfcrypt/src/rsa.c ****              ret = MP_TO_E;
2072:../src/wolfcrypt/src/rsa.c ****         }
2073:../src/wolfcrypt/src/rsa.c ****     }
2074:../src/wolfcrypt/src/rsa.c **** 
2075:../src/wolfcrypt/src/rsa.c ****     mp_clear(&key->nb->tmp);
2076:../src/wolfcrypt/src/rsa.c **** 
2077:../src/wolfcrypt/src/rsa.c ****     return ret;
2078:../src/wolfcrypt/src/rsa.c **** }
2079:../src/wolfcrypt/src/rsa.c **** #endif /* WC_RSA_NONBLOCK */
2080:../src/wolfcrypt/src/rsa.c **** 
2081:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_XILINX_CRYPT
2082:../src/wolfcrypt/src/rsa.c **** /*
2083:../src/wolfcrypt/src/rsa.c ****  * Xilinx hardened crypto acceleration.
2084:../src/wolfcrypt/src/rsa.c ****  *
2085:../src/wolfcrypt/src/rsa.c ****  * Returns 0 on success and negative values on error.
2086:../src/wolfcrypt/src/rsa.c ****  */
2087:../src/wolfcrypt/src/rsa.c **** static int wc_RsaFunctionSync(const byte* in, word32 inLen, byte* out,
2088:../src/wolfcrypt/src/rsa.c ****                           word32* outLen, int type, RsaKey* key, WC_RNG* rng)
2089:../src/wolfcrypt/src/rsa.c **** {
2090:../src/wolfcrypt/src/rsa.c ****     int    ret = 0;
2091:../src/wolfcrypt/src/rsa.c ****     word32 keyLen;
2092:../src/wolfcrypt/src/rsa.c ****     (void)rng;
2093:../src/wolfcrypt/src/rsa.c **** 
2094:../src/wolfcrypt/src/rsa.c ****     keyLen = wc_RsaEncryptSize(key);
2095:../src/wolfcrypt/src/rsa.c ****     if (keyLen > *outLen) {
2096:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Output buffer is not big enough");
2097:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
2098:../src/wolfcrypt/src/rsa.c ****     }
2099:../src/wolfcrypt/src/rsa.c **** 
2100:../src/wolfcrypt/src/rsa.c ****     if (inLen != keyLen) {
2101:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Expected that inLen equals RSA key length");
2102:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
2103:../src/wolfcrypt/src/rsa.c ****     }
2104:../src/wolfcrypt/src/rsa.c **** 
2105:../src/wolfcrypt/src/rsa.c ****     switch(type) {
2106:../src/wolfcrypt/src/rsa.c ****     case RSA_PRIVATE_DECRYPT:
2107:../src/wolfcrypt/src/rsa.c ****     case RSA_PRIVATE_ENCRYPT:
2108:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_XILINX_CRYPTO_OLD
2109:../src/wolfcrypt/src/rsa.c ****         /* Currently public exponent is loaded by default.
2110:../src/wolfcrypt/src/rsa.c ****          * In SDK 2017.1 RSA exponent values are expected to be of 4 bytes
2111:../src/wolfcrypt/src/rsa.c ****          * leading to private key operations with Xsecure_RsaDecrypt not being
2112:../src/wolfcrypt/src/rsa.c ****          * supported */
2113:../src/wolfcrypt/src/rsa.c ****         ret = RSA_WRONG_TYPE_E;
2114:../src/wolfcrypt/src/rsa.c ****     #else
2115:../src/wolfcrypt/src/rsa.c ****         {
2116:../src/wolfcrypt/src/rsa.c ****             byte *d;
2117:../src/wolfcrypt/src/rsa.c ****             int dSz;
2118:../src/wolfcrypt/src/rsa.c ****             XSecure_Rsa rsa;
2119:../src/wolfcrypt/src/rsa.c **** 
2120:../src/wolfcrypt/src/rsa.c ****             dSz = mp_unsigned_bin_size(&key->d);
2121:../src/wolfcrypt/src/rsa.c ****             d = (byte*)XMALLOC(dSz, key->heap, DYNAMIC_TYPE_PRIVATE_KEY);
2122:../src/wolfcrypt/src/rsa.c ****             if (d == NULL) {
2123:../src/wolfcrypt/src/rsa.c ****                 ret = MEMORY_E;
2124:../src/wolfcrypt/src/rsa.c ****             }
2125:../src/wolfcrypt/src/rsa.c ****             else {
2126:../src/wolfcrypt/src/rsa.c ****                 ret = mp_to_unsigned_bin(&key->d, d);
2127:../src/wolfcrypt/src/rsa.c ****                 XSecure_RsaInitialize(&rsa, key->mod, NULL, d);
2128:../src/wolfcrypt/src/rsa.c ****             }
2129:../src/wolfcrypt/src/rsa.c **** 
2130:../src/wolfcrypt/src/rsa.c ****             if (ret == 0) {
2131:../src/wolfcrypt/src/rsa.c ****                 if (XSecure_RsaPrivateDecrypt(&rsa, (u8*)in, inLen, out) !=
2132:../src/wolfcrypt/src/rsa.c ****                         XST_SUCCESS) {
2133:../src/wolfcrypt/src/rsa.c ****                     ret = BAD_STATE_E;
2134:../src/wolfcrypt/src/rsa.c ****                 }
2135:../src/wolfcrypt/src/rsa.c ****             }
2136:../src/wolfcrypt/src/rsa.c **** 
2137:../src/wolfcrypt/src/rsa.c ****             if (d != NULL) {
2138:../src/wolfcrypt/src/rsa.c ****                 XFREE(d, key->heap, DYNAMIC_TYPE_PRIVATE_KEY);
2139:../src/wolfcrypt/src/rsa.c ****             }
2140:../src/wolfcrypt/src/rsa.c ****         }
2141:../src/wolfcrypt/src/rsa.c ****     #endif
2142:../src/wolfcrypt/src/rsa.c ****         break;
2143:../src/wolfcrypt/src/rsa.c ****     case RSA_PUBLIC_ENCRYPT:
2144:../src/wolfcrypt/src/rsa.c ****     case RSA_PUBLIC_DECRYPT:
2145:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_XILINX_CRYPTO_OLD
2146:../src/wolfcrypt/src/rsa.c ****         if (XSecure_RsaDecrypt(&(key->xRsa), in, out) != XST_SUCCESS) {
2147:../src/wolfcrypt/src/rsa.c ****             ret = BAD_STATE_E;
2148:../src/wolfcrypt/src/rsa.c ****         }
2149:../src/wolfcrypt/src/rsa.c **** #else
2150:../src/wolfcrypt/src/rsa.c ****         /* starting at Xilinx release 2019 the function XSecure_RsaDecrypt was removed */
2151:../src/wolfcrypt/src/rsa.c ****         if (XSecure_RsaPublicEncrypt(&(key->xRsa), (u8*)in, inLen, out) != XST_SUCCESS) {
2152:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("Error happened when calling hardware RSA public operation");
2153:../src/wolfcrypt/src/rsa.c ****             ret = BAD_STATE_E;
2154:../src/wolfcrypt/src/rsa.c ****         }
2155:../src/wolfcrypt/src/rsa.c **** #endif
2156:../src/wolfcrypt/src/rsa.c ****         break;
2157:../src/wolfcrypt/src/rsa.c ****     default:
2158:../src/wolfcrypt/src/rsa.c ****         ret = RSA_WRONG_TYPE_E;
2159:../src/wolfcrypt/src/rsa.c ****     }
2160:../src/wolfcrypt/src/rsa.c **** 
2161:../src/wolfcrypt/src/rsa.c ****     *outLen = keyLen;
2162:../src/wolfcrypt/src/rsa.c **** 
2163:../src/wolfcrypt/src/rsa.c ****     return ret;
2164:../src/wolfcrypt/src/rsa.c **** }
2165:../src/wolfcrypt/src/rsa.c **** 
2166:../src/wolfcrypt/src/rsa.c **** #elif defined(WOLFSSL_AFALG_XILINX_RSA)
2167:../src/wolfcrypt/src/rsa.c **** #ifndef ERROR_OUT
2168:../src/wolfcrypt/src/rsa.c **** #define ERROR_OUT(x) ret = (x); goto done
2169:../src/wolfcrypt/src/rsa.c **** #endif
2170:../src/wolfcrypt/src/rsa.c **** 
2171:../src/wolfcrypt/src/rsa.c **** static const char WC_TYPE_ASYMKEY[] = "skcipher";
2172:../src/wolfcrypt/src/rsa.c **** static const char WC_NAME_RSA[] = "xilinx-zynqmp-rsa";
2173:../src/wolfcrypt/src/rsa.c **** #ifndef MAX_XILINX_RSA_KEY
2174:../src/wolfcrypt/src/rsa.c ****     /* max key size of 4096 bits / 512 bytes */
2175:../src/wolfcrypt/src/rsa.c ****     #define MAX_XILINX_RSA_KEY 512
2176:../src/wolfcrypt/src/rsa.c **** #endif
2177:../src/wolfcrypt/src/rsa.c **** static const byte XILINX_RSA_FLAG[] = {0x1};
2178:../src/wolfcrypt/src/rsa.c **** 
2179:../src/wolfcrypt/src/rsa.c **** 
2180:../src/wolfcrypt/src/rsa.c **** /* AF_ALG implementation of RSA */
2181:../src/wolfcrypt/src/rsa.c **** static int wc_RsaFunctionSync(const byte* in, word32 inLen, byte* out,
2182:../src/wolfcrypt/src/rsa.c ****                           word32* outLen, int type, RsaKey* key, WC_RNG* rng)
2183:../src/wolfcrypt/src/rsa.c **** {
2184:../src/wolfcrypt/src/rsa.c ****     struct msghdr   msg;
2185:../src/wolfcrypt/src/rsa.c ****     struct cmsghdr* cmsg;
2186:../src/wolfcrypt/src/rsa.c ****     struct iovec      iov;
2187:../src/wolfcrypt/src/rsa.c ****     byte*  keyBuf   = NULL;
2188:../src/wolfcrypt/src/rsa.c ****     word32 keyBufSz = 0;
2189:../src/wolfcrypt/src/rsa.c ****     char cbuf[CMSG_SPACE(4) + CMSG_SPACE(sizeof(struct af_alg_iv) + 1)] = {0};
2190:../src/wolfcrypt/src/rsa.c ****     int    ret = 0;
2191:../src/wolfcrypt/src/rsa.c ****     int    op  = 0;    /* decryption vs encryption flag */
2192:../src/wolfcrypt/src/rsa.c ****     word32 keyLen;
2193:../src/wolfcrypt/src/rsa.c **** 
2194:../src/wolfcrypt/src/rsa.c ****     /* input and output buffer need to be aligned */
2195:../src/wolfcrypt/src/rsa.c ****     ALIGN64 byte outBuf[MAX_XILINX_RSA_KEY];
2196:../src/wolfcrypt/src/rsa.c ****     ALIGN64 byte inBuf[MAX_XILINX_RSA_KEY];
2197:../src/wolfcrypt/src/rsa.c **** 
2198:../src/wolfcrypt/src/rsa.c ****     XMEMSET(&msg, 0, sizeof(struct msghdr));
2199:../src/wolfcrypt/src/rsa.c ****     (void)rng;
2200:../src/wolfcrypt/src/rsa.c **** 
2201:../src/wolfcrypt/src/rsa.c ****     keyLen = wc_RsaEncryptSize(key);
2202:../src/wolfcrypt/src/rsa.c ****     if (keyLen > *outLen) {
2203:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(RSA_BUFFER_E);
2204:../src/wolfcrypt/src/rsa.c ****     }
2205:../src/wolfcrypt/src/rsa.c **** 
2206:../src/wolfcrypt/src/rsa.c ****     if (keyLen > MAX_XILINX_RSA_KEY) {
2207:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("RSA key size larger than supported");
2208:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(BAD_FUNC_ARG);
2209:../src/wolfcrypt/src/rsa.c ****     }
2210:../src/wolfcrypt/src/rsa.c **** 
2211:../src/wolfcrypt/src/rsa.c ****     if ((keyBuf = (byte*)XMALLOC(keyLen * 2, key->heap, DYNAMIC_TYPE_KEY))
2212:../src/wolfcrypt/src/rsa.c ****             == NULL) {
2213:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(MEMORY_E);
2214:../src/wolfcrypt/src/rsa.c ****     }
2215:../src/wolfcrypt/src/rsa.c **** 
2216:../src/wolfcrypt/src/rsa.c ****     if ((ret = mp_to_unsigned_bin(&(key->n), keyBuf)) != MP_OKAY) {
2217:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(MP_TO_E);
2218:../src/wolfcrypt/src/rsa.c ****     }
2219:../src/wolfcrypt/src/rsa.c **** 
2220:../src/wolfcrypt/src/rsa.c ****     switch(type) {
2221:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_DECRYPT:
2222:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_ENCRYPT:
2223:../src/wolfcrypt/src/rsa.c ****             op = 1; /* set as decrypt */
2224:../src/wolfcrypt/src/rsa.c ****             {
2225:../src/wolfcrypt/src/rsa.c ****                 keyBufSz = mp_unsigned_bin_size(&(key->d));
2226:../src/wolfcrypt/src/rsa.c ****                 if ((mp_to_unsigned_bin(&(key->d), keyBuf + keyLen))
2227:../src/wolfcrypt/src/rsa.c ****                         != MP_OKAY) {
2228:../src/wolfcrypt/src/rsa.c ****                     ERROR_OUT(MP_TO_E);
2229:../src/wolfcrypt/src/rsa.c ****                 }
2230:../src/wolfcrypt/src/rsa.c ****             #ifdef WOLFSSL_CHECK_MEM_ZERO
2231:../src/wolfcrypt/src/rsa.c ****                 /* Seed must be zeroized now that it has been used. */
2232:../src/wolfcrypt/src/rsa.c ****                 wc_MemZero_Add("RSA Sync Priv Enc/Dec keyBuf", keyBuf + keyLen,
2233:../src/wolfcrypt/src/rsa.c ****                     keyBufSz);
2234:../src/wolfcrypt/src/rsa.c ****             #endif
2235:../src/wolfcrypt/src/rsa.c ****             }
2236:../src/wolfcrypt/src/rsa.c ****             break;
2237:../src/wolfcrypt/src/rsa.c **** 
2238:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_DECRYPT:
2239:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_ENCRYPT: {
2240:../src/wolfcrypt/src/rsa.c ****             word32 exp = 0;
2241:../src/wolfcrypt/src/rsa.c ****             word32 eSz = mp_unsigned_bin_size(&(key->e));
2242:../src/wolfcrypt/src/rsa.c ****             if ((mp_to_unsigned_bin(&(key->e), (byte*)&exp +
2243:../src/wolfcrypt/src/rsa.c ****                             (sizeof(word32) - eSz))) != MP_OKAY) {
2244:../src/wolfcrypt/src/rsa.c ****                 ERROR_OUT(MP_TO_E);
2245:../src/wolfcrypt/src/rsa.c ****             }
2246:../src/wolfcrypt/src/rsa.c ****             keyBufSz = sizeof(word32);
2247:../src/wolfcrypt/src/rsa.c ****             XMEMCPY(keyBuf + keyLen, (byte*)&exp, keyBufSz);
2248:../src/wolfcrypt/src/rsa.c ****             break;
2249:../src/wolfcrypt/src/rsa.c ****         }
2250:../src/wolfcrypt/src/rsa.c **** 
2251:../src/wolfcrypt/src/rsa.c ****         default:
2252:../src/wolfcrypt/src/rsa.c ****             ERROR_OUT(RSA_WRONG_TYPE_E);
2253:../src/wolfcrypt/src/rsa.c ****     }
2254:../src/wolfcrypt/src/rsa.c ****     keyBufSz += keyLen; /* add size of modulus */
2255:../src/wolfcrypt/src/rsa.c **** 
2256:../src/wolfcrypt/src/rsa.c ****     /* check for existing sockets before creating new ones */
2257:../src/wolfcrypt/src/rsa.c ****     if (key->alFd > 0) {
2258:../src/wolfcrypt/src/rsa.c ****         close(key->alFd);
2259:../src/wolfcrypt/src/rsa.c ****         key->alFd = WC_SOCK_NOTSET;
2260:../src/wolfcrypt/src/rsa.c ****     }
2261:../src/wolfcrypt/src/rsa.c ****     if (key->rdFd > 0) {
2262:../src/wolfcrypt/src/rsa.c ****         close(key->rdFd);
2263:../src/wolfcrypt/src/rsa.c ****         key->rdFd = WC_SOCK_NOTSET;
2264:../src/wolfcrypt/src/rsa.c ****     }
2265:../src/wolfcrypt/src/rsa.c **** 
2266:../src/wolfcrypt/src/rsa.c ****     /* create new sockets and set the key to use */
2267:../src/wolfcrypt/src/rsa.c ****     if ((key->alFd = wc_Afalg_Socket()) < 0) {
2268:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Unable to create socket");
2269:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(key->alFd);
2270:../src/wolfcrypt/src/rsa.c ****     }
2271:../src/wolfcrypt/src/rsa.c ****     if ((key->rdFd = wc_Afalg_CreateRead(key->alFd, WC_TYPE_ASYMKEY,
2272:../src/wolfcrypt/src/rsa.c ****                     WC_NAME_RSA)) < 0) {
2273:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Unable to bind and create read/send socket");
2274:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(key->rdFd);
2275:../src/wolfcrypt/src/rsa.c ****     }
2276:../src/wolfcrypt/src/rsa.c ****     if ((ret = setsockopt(key->alFd, SOL_ALG, ALG_SET_KEY, keyBuf,
2277:../src/wolfcrypt/src/rsa.c ****                     keyBufSz)) < 0) {
2278:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Error setting RSA key");
2279:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(ret);
2280:../src/wolfcrypt/src/rsa.c ****     }
2281:../src/wolfcrypt/src/rsa.c **** 
2282:../src/wolfcrypt/src/rsa.c ****     msg.msg_control    = cbuf;
2283:../src/wolfcrypt/src/rsa.c ****     msg.msg_controllen = sizeof(cbuf);
2284:../src/wolfcrypt/src/rsa.c ****     cmsg = CMSG_FIRSTHDR(&msg);
2285:../src/wolfcrypt/src/rsa.c ****     if ((ret = wc_Afalg_SetOp(cmsg, op)) < 0) {
2286:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(ret);
2287:../src/wolfcrypt/src/rsa.c ****     }
2288:../src/wolfcrypt/src/rsa.c **** 
2289:../src/wolfcrypt/src/rsa.c ****     /* set flag in IV spot, needed for Xilinx hardware acceleration use */
2290:../src/wolfcrypt/src/rsa.c ****     cmsg = CMSG_NXTHDR(&msg, cmsg);
2291:../src/wolfcrypt/src/rsa.c ****     if ((ret = wc_Afalg_SetIv(cmsg, (byte*)XILINX_RSA_FLAG,
2292:../src/wolfcrypt/src/rsa.c ****                     sizeof(XILINX_RSA_FLAG))) != 0) {
2293:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(ret);
2294:../src/wolfcrypt/src/rsa.c ****     }
2295:../src/wolfcrypt/src/rsa.c **** 
2296:../src/wolfcrypt/src/rsa.c ****     /* compose and send msg */
2297:../src/wolfcrypt/src/rsa.c ****     XMEMCPY(inBuf, (byte*)in, inLen); /* for alignment */
2298:../src/wolfcrypt/src/rsa.c ****     iov.iov_base = inBuf;
2299:../src/wolfcrypt/src/rsa.c ****     iov.iov_len  = inLen;
2300:../src/wolfcrypt/src/rsa.c ****     msg.msg_iov  = &iov;
2301:../src/wolfcrypt/src/rsa.c ****     msg.msg_iovlen = 1;
2302:../src/wolfcrypt/src/rsa.c ****     if ((ret = sendmsg(key->rdFd, &msg, 0)) <= 0) {
2303:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(WC_AFALG_SOCK_E);
2304:../src/wolfcrypt/src/rsa.c ****     }
2305:../src/wolfcrypt/src/rsa.c **** 
2306:../src/wolfcrypt/src/rsa.c ****     if ((ret = read(key->rdFd, outBuf, inLen)) <= 0) {
2307:../src/wolfcrypt/src/rsa.c ****         ERROR_OUT(WC_AFALG_SOCK_E);
2308:../src/wolfcrypt/src/rsa.c ****     }
2309:../src/wolfcrypt/src/rsa.c ****     XMEMCPY(out, outBuf, ret);
2310:../src/wolfcrypt/src/rsa.c ****     *outLen = keyLen;
2311:../src/wolfcrypt/src/rsa.c **** 
2312:../src/wolfcrypt/src/rsa.c **** done:
2313:../src/wolfcrypt/src/rsa.c ****     /* clear key data and free buffer */
2314:../src/wolfcrypt/src/rsa.c ****     if (keyBuf != NULL) {
2315:../src/wolfcrypt/src/rsa.c ****         ForceZero(keyBuf, keyBufSz);
2316:../src/wolfcrypt/src/rsa.c ****     }
2317:../src/wolfcrypt/src/rsa.c ****     XFREE(keyBuf, key->heap, DYNAMIC_TYPE_KEY);
2318:../src/wolfcrypt/src/rsa.c **** 
2319:../src/wolfcrypt/src/rsa.c ****     if (key->alFd > 0) {
2320:../src/wolfcrypt/src/rsa.c ****         close(key->alFd);
2321:../src/wolfcrypt/src/rsa.c ****         key->alFd = WC_SOCK_NOTSET;
2322:../src/wolfcrypt/src/rsa.c ****     }
2323:../src/wolfcrypt/src/rsa.c ****     if (key->rdFd > 0) {
2324:../src/wolfcrypt/src/rsa.c ****         close(key->rdFd);
2325:../src/wolfcrypt/src/rsa.c ****         key->rdFd = WC_SOCK_NOTSET;
2326:../src/wolfcrypt/src/rsa.c ****     }
2327:../src/wolfcrypt/src/rsa.c **** 
2328:../src/wolfcrypt/src/rsa.c ****     return ret;
2329:../src/wolfcrypt/src/rsa.c **** }
2330:../src/wolfcrypt/src/rsa.c **** 
2331:../src/wolfcrypt/src/rsa.c **** #elif defined(WOLFSSL_KCAPI_RSA)
2332:../src/wolfcrypt/src/rsa.c **** static int wc_RsaFunctionSync(const byte* in, word32 inLen, byte* out,
2333:../src/wolfcrypt/src/rsa.c ****                               word32* outLen, int type, RsaKey* key,
2334:../src/wolfcrypt/src/rsa.c ****                               WC_RNG* rng)
2335:../src/wolfcrypt/src/rsa.c **** {
2336:../src/wolfcrypt/src/rsa.c ****     int ret;
2337:../src/wolfcrypt/src/rsa.c **** 
2338:../src/wolfcrypt/src/rsa.c ****     (void)rng;
2339:../src/wolfcrypt/src/rsa.c **** 
2340:../src/wolfcrypt/src/rsa.c ****     switch(type) {
2341:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_DECRYPT:
2342:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_ENCRYPT:
2343:../src/wolfcrypt/src/rsa.c ****             ret = KcapiRsa_Decrypt(key, in, inLen, out, outLen);
2344:../src/wolfcrypt/src/rsa.c ****             break;
2345:../src/wolfcrypt/src/rsa.c **** 
2346:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_DECRYPT:
2347:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_ENCRYPT:
2348:../src/wolfcrypt/src/rsa.c ****             ret = KcapiRsa_Encrypt(key, in, inLen, out, outLen);
2349:../src/wolfcrypt/src/rsa.c ****             break;
2350:../src/wolfcrypt/src/rsa.c **** 
2351:../src/wolfcrypt/src/rsa.c ****         default:
2352:../src/wolfcrypt/src/rsa.c ****             ret = RSA_WRONG_TYPE_E;
2353:../src/wolfcrypt/src/rsa.c ****     }
2354:../src/wolfcrypt/src/rsa.c **** 
2355:../src/wolfcrypt/src/rsa.c ****     return ret;
2356:../src/wolfcrypt/src/rsa.c **** }
2357:../src/wolfcrypt/src/rsa.c **** #else
2358:../src/wolfcrypt/src/rsa.c **** #ifndef WOLF_CRYPTO_CB_ONLY_RSA
2359:../src/wolfcrypt/src/rsa.c **** static int wc_RsaFunctionSync(const byte* in, word32 inLen, byte* out,
2360:../src/wolfcrypt/src/rsa.c ****                           word32* outLen, int type, RsaKey* key, WC_RNG* rng)
2361:../src/wolfcrypt/src/rsa.c **** {
 3774                             		.loc 2 2361 1
 3775 0000 7E AA                   		push.l	r10
 3776                             	.LCFI73:
 3777 0002 7E A6                   		push.l	r6
 3778                             	.LCFI74:
 3779 0004 71 0A B0                		add	#-80, r0, r10
 3780                             	.LCFI75:
 3781 0007 71 A0 F8                		add	#-8, r10, r0
 3782                             	.LCFI76:
 3783 000a 75 46 5C                		mov.L	#0x5c, r6
 3784 000d 4B A6                   		add	r10, r6
 3785 000f E7 A1 0D                		mov.L	r1, 52[r10]
 3786 0012 E7 A2 0E                		mov.L	r2, 56[r10]
 3787 0015 E7 A3 0F                		mov.L	r3, 60[r10]
 3788 0018 E7 A4 10                		mov.L	r4, 64[r10]
2362:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_SP_MATH)
2363:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
2364:../src/wolfcrypt/src/rsa.c ****     mp_int* tmp;
2365:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
2366:../src/wolfcrypt/src/rsa.c ****     mp_int* rnd;
2367:../src/wolfcrypt/src/rsa.c ****     mp_int* rndi;
2368:../src/wolfcrypt/src/rsa.c **** #endif
2369:../src/wolfcrypt/src/rsa.c **** #else
2370:../src/wolfcrypt/src/rsa.c ****     mp_int tmp[1];
2371:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
2372:../src/wolfcrypt/src/rsa.c ****     mp_int rnd[1], rndi[1];
2373:../src/wolfcrypt/src/rsa.c **** #endif
2374:../src/wolfcrypt/src/rsa.c **** #endif
2375:../src/wolfcrypt/src/rsa.c ****     int    ret = 0;
 3789                             		.loc 2 2375 12
 3790 001b F8 A6 00                		mov.L	#0, [r10]
2376:../src/wolfcrypt/src/rsa.c **** #endif
2377:../src/wolfcrypt/src/rsa.c ****     word32 keyLen = wc_RsaEncryptSize(key);
 3791                             		.loc 2 2377 21
 3792 001e A8 69                   		mov.L	4[r6], r1
 3793 0020 05 00 00 00             		bsr	_wc_RsaEncryptSize
 3794 0024 EF 15                   		mov.L	r1, r5
 3795                             		.loc 2 2377 12
 3796 0026 E7 A5 04                		mov.L	r5, 16[r10]
2378:../src/wolfcrypt/src/rsa.c **** 
2379:../src/wolfcrypt/src/rsa.c ****     if (inLen > keyLen) {
 3797                             		.loc 2 2379 8
 3798 0029 ED A4 0E                		mov.L	56[r10], r4
 3799 002c ED A5 04                		mov.L	16[r10], r5
 3800 002f 47 54                   		cmp	r5, r4
 3801 0031 25 13                   		bleu	.L234
2380:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Expected that inLen be no longer RSA key length");
 3802                             		.loc 2 2380 9
 3803 0033 FB 12 6C 02 00 00       		mov.L	#.LC18, r1
 3804 0039 05 00 00 00             		bsr	_WOLFSSL_MSG
2381:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 3805                             		.loc 2 2381 16
 3806 003d FB 5A 53 FF             		mov.L	#-173, r5
 3807 0041 38 8F 03                		bra	.L235
 3808                             	.L234:
2382:../src/wolfcrypt/src/rsa.c ****     }
2383:../src/wolfcrypt/src/rsa.c **** 
2384:../src/wolfcrypt/src/rsa.c ****     if (mp_iseven(&key->n)) {
 3809                             		.loc 2 2384 9
 3810 0044 A8 6D                   		mov.L	4[r6], r5
 3811 0046 EC 55                   		mov.L	[r5], r5
 3812                             		.loc 2 2384 8
 3813 0048 61 05                   		cmp	#0, r5
 3814 004a 20 11                   		beq	.L236
 3815                             		.loc 2 2384 9 discriminator 1
 3816 004c A8 6D                   		mov.L	4[r6], r5
 3817 004e A8 D5                   		mov.L	8[r5], r5
 3818 0050 64 15                   		and	#1, r5
 3819 0052 61 05                   		cmp	#0, r5
 3820 0054 1F                      		bne	.L236
2385:../src/wolfcrypt/src/rsa.c ****         return MP_VAL;
 3821                             		.loc 2 2385 16
 3822 0055 FB 56 FD                		mov.L	#-3, r5
 3823 0058 38 78 03                		bra	.L235
 3824                             	.L236:
2386:../src/wolfcrypt/src/rsa.c ****     }
2387:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_HAVE_SP_RSA
2388:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_SP_NO_2048
2389:../src/wolfcrypt/src/rsa.c ****     if (mp_count_bits(&key->n) == 2048) {
2390:../src/wolfcrypt/src/rsa.c ****         switch(type) {
2391:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
2392:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_DECRYPT:
2393:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_ENCRYPT:
2394:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_BLINDING
2395:../src/wolfcrypt/src/rsa.c ****             if (rng == NULL)
2396:../src/wolfcrypt/src/rsa.c ****                 return MISSING_RNG_E;
2397:../src/wolfcrypt/src/rsa.c ****     #endif
2398:../src/wolfcrypt/src/rsa.c ****     #ifndef RSA_LOW_MEM
2399:../src/wolfcrypt/src/rsa.c ****             if ((mp_count_bits(&key->p) == 1024) &&
2400:../src/wolfcrypt/src/rsa.c ****                                              (mp_count_bits(&key->q) == 1024)) {
2401:../src/wolfcrypt/src/rsa.c ****                 return sp_RsaPrivate_2048(in, inLen, &key->d, &key->p, &key->q,
2402:../src/wolfcrypt/src/rsa.c ****                                           &key->dP, &key->dQ, &key->u, &key->n,
2403:../src/wolfcrypt/src/rsa.c ****                                           out, outLen);
2404:../src/wolfcrypt/src/rsa.c ****             }
2405:../src/wolfcrypt/src/rsa.c ****             break;
2406:../src/wolfcrypt/src/rsa.c ****     #else
2407:../src/wolfcrypt/src/rsa.c ****             return sp_RsaPrivate_2048(in, inLen, &key->d, NULL, NULL, NULL,
2408:../src/wolfcrypt/src/rsa.c ****                                       NULL, NULL, &key->n, out, outLen);
2409:../src/wolfcrypt/src/rsa.c ****     #endif
2410:../src/wolfcrypt/src/rsa.c **** #endif
2411:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_ENCRYPT:
2412:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_DECRYPT:
2413:../src/wolfcrypt/src/rsa.c ****             return sp_RsaPublic_2048(in, inLen, &key->e, &key->n, out, outLen);
2414:../src/wolfcrypt/src/rsa.c ****         default:
2415:../src/wolfcrypt/src/rsa.c ****             break;
2416:../src/wolfcrypt/src/rsa.c ****         }
2417:../src/wolfcrypt/src/rsa.c ****     }
2418:../src/wolfcrypt/src/rsa.c **** #endif
2419:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_SP_NO_3072
2420:../src/wolfcrypt/src/rsa.c ****     if (mp_count_bits(&key->n) == 3072) {
2421:../src/wolfcrypt/src/rsa.c ****         switch(type) {
2422:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
2423:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_DECRYPT:
2424:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_ENCRYPT:
2425:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_BLINDING
2426:../src/wolfcrypt/src/rsa.c ****             if (rng == NULL)
2427:../src/wolfcrypt/src/rsa.c ****                 return MISSING_RNG_E;
2428:../src/wolfcrypt/src/rsa.c ****     #endif
2429:../src/wolfcrypt/src/rsa.c ****     #ifndef RSA_LOW_MEM
2430:../src/wolfcrypt/src/rsa.c ****             if ((mp_count_bits(&key->p) == 1536) &&
2431:../src/wolfcrypt/src/rsa.c ****                                              (mp_count_bits(&key->q) == 1536)) {
2432:../src/wolfcrypt/src/rsa.c ****                 return sp_RsaPrivate_3072(in, inLen, &key->d, &key->p, &key->q,
2433:../src/wolfcrypt/src/rsa.c ****                                           &key->dP, &key->dQ, &key->u, &key->n,
2434:../src/wolfcrypt/src/rsa.c ****                                           out, outLen);
2435:../src/wolfcrypt/src/rsa.c ****             }
2436:../src/wolfcrypt/src/rsa.c ****             break;
2437:../src/wolfcrypt/src/rsa.c ****     #else
2438:../src/wolfcrypt/src/rsa.c ****             return sp_RsaPrivate_3072(in, inLen, &key->d, NULL, NULL, NULL,
2439:../src/wolfcrypt/src/rsa.c ****                                       NULL, NULL, &key->n, out, outLen);
2440:../src/wolfcrypt/src/rsa.c ****     #endif
2441:../src/wolfcrypt/src/rsa.c **** #endif
2442:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_ENCRYPT:
2443:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_DECRYPT:
2444:../src/wolfcrypt/src/rsa.c ****             return sp_RsaPublic_3072(in, inLen, &key->e, &key->n, out, outLen);
2445:../src/wolfcrypt/src/rsa.c ****         default:
2446:../src/wolfcrypt/src/rsa.c ****             break;
2447:../src/wolfcrypt/src/rsa.c ****         }
2448:../src/wolfcrypt/src/rsa.c ****     }
2449:../src/wolfcrypt/src/rsa.c **** #endif
2450:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SP_4096
2451:../src/wolfcrypt/src/rsa.c ****     if (mp_count_bits(&key->n) == 4096) {
2452:../src/wolfcrypt/src/rsa.c ****         switch(type) {
2453:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
2454:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_DECRYPT:
2455:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_ENCRYPT:
2456:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_BLINDING
2457:../src/wolfcrypt/src/rsa.c ****             if (rng == NULL)
2458:../src/wolfcrypt/src/rsa.c ****                 return MISSING_RNG_E;
2459:../src/wolfcrypt/src/rsa.c ****     #endif
2460:../src/wolfcrypt/src/rsa.c ****     #ifndef RSA_LOW_MEM
2461:../src/wolfcrypt/src/rsa.c ****             if ((mp_count_bits(&key->p) == 2048) &&
2462:../src/wolfcrypt/src/rsa.c ****                                              (mp_count_bits(&key->q) == 2048)) {
2463:../src/wolfcrypt/src/rsa.c ****                 return sp_RsaPrivate_4096(in, inLen, &key->d, &key->p, &key->q,
2464:../src/wolfcrypt/src/rsa.c ****                                           &key->dP, &key->dQ, &key->u, &key->n,
2465:../src/wolfcrypt/src/rsa.c ****                                           out, outLen);
2466:../src/wolfcrypt/src/rsa.c ****             }
2467:../src/wolfcrypt/src/rsa.c ****             break;
2468:../src/wolfcrypt/src/rsa.c ****     #else
2469:../src/wolfcrypt/src/rsa.c ****             return sp_RsaPrivate_4096(in, inLen, &key->d, NULL, NULL, NULL,
2470:../src/wolfcrypt/src/rsa.c ****                                       NULL, NULL, &key->n, out, outLen);
2471:../src/wolfcrypt/src/rsa.c ****     #endif
2472:../src/wolfcrypt/src/rsa.c **** #endif
2473:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_ENCRYPT:
2474:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_DECRYPT:
2475:../src/wolfcrypt/src/rsa.c ****             return sp_RsaPublic_4096(in, inLen, &key->e, &key->n, out, outLen);
2476:../src/wolfcrypt/src/rsa.c ****         default:
2477:../src/wolfcrypt/src/rsa.c ****             break;
2478:../src/wolfcrypt/src/rsa.c ****         }
2479:../src/wolfcrypt/src/rsa.c ****     }
2480:../src/wolfcrypt/src/rsa.c **** #endif
2481:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_HAVE_SP_RSA */
2482:../src/wolfcrypt/src/rsa.c **** 
2483:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SP_MATH)
2484:../src/wolfcrypt/src/rsa.c ****     (void)rng;
2485:../src/wolfcrypt/src/rsa.c ****     #ifndef WOLFSSL_HAVE_SP_RSA
2486:../src/wolfcrypt/src/rsa.c ****     (void)in;
2487:../src/wolfcrypt/src/rsa.c ****     (void)inLen;
2488:../src/wolfcrypt/src/rsa.c ****     (void)out;
2489:../src/wolfcrypt/src/rsa.c ****     (void)outLen;
2490:../src/wolfcrypt/src/rsa.c ****     (void)type;
2491:../src/wolfcrypt/src/rsa.c ****     (void)key;
2492:../src/wolfcrypt/src/rsa.c ****     #error RSA SP option invalid (enable WOLFSSL_HAVE_SP_RSA or disable WOLFSSL_SP_MATH)
2493:../src/wolfcrypt/src/rsa.c ****     return NOT_COMPILED_IN;
2494:../src/wolfcrypt/src/rsa.c ****     #else
2495:../src/wolfcrypt/src/rsa.c ****     WOLFSSL_MSG("SP Key Size Error");
2496:../src/wolfcrypt/src/rsa.c ****     return WC_KEY_SIZE_E;
2497:../src/wolfcrypt/src/rsa.c ****     #endif
2498:../src/wolfcrypt/src/rsa.c **** #else
2499:../src/wolfcrypt/src/rsa.c ****     (void)rng;
2500:../src/wolfcrypt/src/rsa.c **** 
2501:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
2502:../src/wolfcrypt/src/rsa.c ****     tmp = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_RSA);
 3825                             		.loc 2 2502 20
 3826 005b FB 1A 10 03             		mov.L	#0x310, r1
 3827 005f 05 00 00 00             		bsr	_wolfSSL_Malloc
 3828 0063 E7 A1 05                		mov.L	r1, 20[r10]
2503:../src/wolfcrypt/src/rsa.c ****     if (tmp == NULL)
 3829                             		.loc 2 2503 8
 3830 0066 ED A5 05                		mov.L	20[r10], r5
 3831 0069 61 05                   		cmp	#0, r5
 3832 006b 1F                      		bne	.L237
2504:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
 3833                             		.loc 2 2504 16
 3834 006c FB 56 83                		mov.L	#-125, r5
 3835 006f 38 61 03                		bra	.L235
 3836                             	.L237:
2505:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
2506:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
2507:../src/wolfcrypt/src/rsa.c ****     rnd = (mp_int*)XMALLOC(sizeof(mp_int) * 2, key->heap, DYNAMIC_TYPE_RSA);
 3837                             		.loc 2 2507 20
 3838 0072 FB 1A 20 06             		mov.L	#0x620, r1
 3839 0076 05 00 00 00             		bsr	_wolfSSL_Malloc
 3840 007a E7 A1 06                		mov.L	r1, 24[r10]
2508:../src/wolfcrypt/src/rsa.c ****     if (rnd == NULL) {
 3841                             		.loc 2 2508 8
 3842 007d ED A5 06                		mov.L	24[r10], r5
 3843 0080 61 05                   		cmp	#0, r5
 3844 0082 21 1B                   		bne	.L238
 3845                             	.LBB37:
2509:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp, key->heap, DYNAMIC_TYPE_RSA);
 3846                             		.loc 2 2509 9
 3847 0084 ED A5 05                		mov.L	20[r10], r5
 3848 0087 E7 A5 07                		mov.L	r5, 28[r10]
 3849 008a ED A5 07                		mov.L	28[r10], r5
 3850 008d 61 05                   		cmp	#0, r5
 3851 008f 10                      		beq	.L239
 3852                             		.loc 2 2509 9 is_stmt 0 discriminator 1
 3853 0090 ED A1 07                		mov.L	28[r10], r1
 3854 0093 05 00 00 00             		bsr	_wolfSSL_Free
 3855                             	.L239:
 3856                             	.LBE37:
2510:../src/wolfcrypt/src/rsa.c ****         return MEMORY_E;
 3857                             		.loc 2 2510 16 is_stmt 1
 3858 0097 FB 56 83                		mov.L	#-125, r5
 3859 009a 38 36 03                		bra	.L235
 3860                             	.L238:
2511:../src/wolfcrypt/src/rsa.c ****     }
2512:../src/wolfcrypt/src/rsa.c ****     rndi = rnd + 1;
 3861                             		.loc 2 2512 10
 3862 009d ED A5 06                		mov.L	24[r10], r5
 3863 00a0 72 55 10 03             		add	#0x310, r5
 3864 00a4 E7 A5 08                		mov.L	r5, 32[r10]
2513:../src/wolfcrypt/src/rsa.c **** #else
2514:../src/wolfcrypt/src/rsa.c ****     rnd = NULL;
2515:../src/wolfcrypt/src/rsa.c ****     rndi = NULL;
2516:../src/wolfcrypt/src/rsa.c **** #endif
2517:../src/wolfcrypt/src/rsa.c **** #endif /* WC_RSA_BLINDING */
2518:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_SMALL_STACK */
2519:../src/wolfcrypt/src/rsa.c **** 
2520:../src/wolfcrypt/src/rsa.c ****     if (mp_init(tmp) != MP_OKAY)
 3865                             		.loc 2 2520 9
 3866 00a7 ED A1 05                		mov.L	20[r10], r1
 3867 00aa 05 00 00 00             		bsr	_sp_init
 3868 00ae EF 15                   		mov.L	r1, r5
 3869                             		.loc 2 2520 8
 3870 00b0 61 05                   		cmp	#0, r5
 3871 00b2 14                      		beq	.L240
2521:../src/wolfcrypt/src/rsa.c ****         ret = MP_INIT_E;
 3872                             		.loc 2 2521 13
 3873 00b3 F8 A6 92                		mov.L	#-110, [r10]
 3874                             	.L240:
2522:../src/wolfcrypt/src/rsa.c **** 
2523:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
2524:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
2525:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 3875                             		.loc 2 2525 8
 3876 00b6 EC A5                   		mov.L	[r10], r5
 3877 00b8 61 05                   		cmp	#0, r5
 3878 00ba 21 31                   		bne	.L241
2526:../src/wolfcrypt/src/rsa.c ****         if (type == RSA_PRIVATE_DECRYPT || type == RSA_PRIVATE_ENCRYPT) {
 3879                             		.loc 2 2526 12
 3880 00bc EC 65                   		mov.L	[r6], r5
 3881 00be 61 35                   		cmp	#3, r5
 3882 00c0 17                      		beq	.L242
 3883                             		.loc 2 2526 41 discriminator 1
 3884 00c1 EC 65                   		mov.L	[r6], r5
 3885 00c3 61 25                   		cmp	#2, r5
 3886 00c5 21 26                   		bne	.L241
 3887                             	.L242:
2527:../src/wolfcrypt/src/rsa.c ****             if (mp_init_multi(rnd, rndi, NULL, NULL, NULL, NULL) != MP_OKAY) {
 3888                             		.loc 2 2527 17
 3889 00c7 3E 01 00                		mov.L	#0, 4[r0]
 3890 00ca F8 06 00                		mov.L	#0, [r0]
 3891 00cd 66 04                   		mov.L	#0, r4
 3892 00cf 66 03                   		mov.L	#0, r3
 3893 00d1 ED A2 08                		mov.L	32[r10], r2
 3894 00d4 ED A1 06                		mov.L	24[r10], r1
 3895 00d7 05 00 00 00             		bsr	_sp_init_multi
 3896 00db EF 15                   		mov.L	r1, r5
 3897                             		.loc 2 2527 16
 3898 00dd 61 05                   		cmp	#0, r5
 3899 00df 20 0C                   		beq	.L241
2528:../src/wolfcrypt/src/rsa.c ****                 mp_clear(tmp);
 3900                             		.loc 2 2528 17
 3901 00e1 ED A1 05                		mov.L	20[r10], r1
 3902 00e4 05 00 00 00             		bsr	_sp_clear
2529:../src/wolfcrypt/src/rsa.c ****                 ret = MP_INIT_E;
 3903                             		.loc 2 2529 21
 3904 00e8 F8 A6 92                		mov.L	#-110, [r10]
 3905                             		.balign 8,3,1
 3906                             	.L241:
2530:../src/wolfcrypt/src/rsa.c ****             }
2531:../src/wolfcrypt/src/rsa.c ****         }
2532:../src/wolfcrypt/src/rsa.c ****     }
2533:../src/wolfcrypt/src/rsa.c **** #endif
2534:../src/wolfcrypt/src/rsa.c **** #endif
2535:../src/wolfcrypt/src/rsa.c **** 
2536:../src/wolfcrypt/src/rsa.c **** #ifndef TEST_UNPAD_CONSTANT_TIME
2537:../src/wolfcrypt/src/rsa.c ****     if (ret == 0 && mp_read_unsigned_bin(tmp, in, inLen) != MP_OKAY)
 3907                             		.loc 2 2537 8
 3908 00eb EC A5                   		mov.L	[r10], r5
 3909 00ed 61 05                   		cmp	#0, r5
 3910 00ef 21 17                   		bne	.L243
 3911                             		.loc 2 2537 21 discriminator 1
 3912 00f1 ED A3 0E                		mov.L	56[r10], r3
 3913 00f4 ED A2 0D                		mov.L	52[r10], r2
 3914 00f7 ED A1 05                		mov.L	20[r10], r1
 3915 00fa 05 00 00 00             		bsr	_sp_read_unsigned_bin
 3916 00fe EF 15                   		mov.L	r1, r5
 3917                             		.loc 2 2537 18 discriminator 1
 3918 0100 61 05                   		cmp	#0, r5
 3919 0102 14                      		beq	.L243
2538:../src/wolfcrypt/src/rsa.c ****         ret = MP_READ_E;
 3920                             		.loc 2 2538 13
 3921 0103 F8 A6 91                		mov.L	#-111, [r10]
 3922                             	.L243:
2539:../src/wolfcrypt/src/rsa.c **** 
2540:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
2541:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
2542:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("RSA sync tmp", tmp);
2543:../src/wolfcrypt/src/rsa.c ****     }
2544:../src/wolfcrypt/src/rsa.c **** #endif
2545:../src/wolfcrypt/src/rsa.c **** 
2546:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 3923                             		.loc 2 2546 8
 3924 0106 EC A5                   		mov.L	[r10], r5
 3925 0108 61 05                   		cmp	#0, r5
 3926 010a 3B 3A 02                		bne	.L274
2547:../src/wolfcrypt/src/rsa.c ****         switch(type) {
 3927                             		.loc 2 2547 9
 3928 010d EC 65                   		mov.L	[r6], r5
 3929 010f 61 05                   		cmp	#0, r5
 3930 0111 28 05 38 2C 02          		blt	.L245
 3931 0116 EC 65                   		mov.L	[r6], r5
 3932 0118 61 15                   		cmp	#1, r5
 3933 011a 2A 05 38 04 02          		ble	.L246
 3934 011f EC 65                   		mov.L	[r6], r5
 3935 0121 61 35                   		cmp	#3, r5
 3936 0123 2B 05 38 1A 02          		bgt	.L245
2548:../src/wolfcrypt/src/rsa.c ****     #if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
2549:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_DECRYPT:
2550:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_ENCRYPT:
2551:../src/wolfcrypt/src/rsa.c ****         {
2552:../src/wolfcrypt/src/rsa.c ****         #if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
2553:../src/wolfcrypt/src/rsa.c ****             /* blind */
2554:../src/wolfcrypt/src/rsa.c ****             ret = mp_rand(rnd, get_digit_count(&key->n), rng);
 3937                             		.loc 2 2554 48
 3938 0128 A8 6D                   		mov.L	4[r6], r5
 3939                             		.loc 2 2554 19
 3940 012a EF 51                   		mov.L	r5, r1
 3941 012c 05 00 00 00             		bsr	_get_digit_count
 3942 0130 EF 15                   		mov.L	r1, r5
 3943 0132 A8 E3                   		mov.L	8[r6], r3
 3944 0134 EF 52                   		mov.L	r5, r2
 3945 0136 ED A1 06                		mov.L	24[r10], r1
 3946 0139 05 00 00 00             		bsr	_mp_rand
 3947 013d E3 A1                   		mov.L	r1, [r10]
2555:../src/wolfcrypt/src/rsa.c ****             if (ret != 0)
 3948                             		.loc 2 2555 16
 3949 013f EC A5                   		mov.L	[r10], r5
 3950 0141 61 05                   		cmp	#0, r5
 3951 0143 3B 03 02                		bne	.L275
2556:../src/wolfcrypt/src/rsa.c ****                 break;
2557:../src/wolfcrypt/src/rsa.c ****             /* rndi = 1/rnd mod n */
2558:../src/wolfcrypt/src/rsa.c ****             if (mp_invmod(rnd, &key->n, rndi) != MP_OKAY) {
 3952                             		.loc 2 2558 32
 3953 0146 A8 6D                   		mov.L	4[r6], r5
 3954                             		.loc 2 2558 17
 3955 0148 ED A3 08                		mov.L	32[r10], r3
 3956 014b EF 52                   		mov.L	r5, r2
 3957 014d ED A1 06                		mov.L	24[r10], r1
 3958 0150 05 00 00 00             		bsr	_sp_invmod
 3959 0154 EF 15                   		mov.L	r1, r5
 3960                             		.loc 2 2558 16
 3961 0156 61 05                   		cmp	#0, r5
 3962 0158 17                      		beq	.L248
2559:../src/wolfcrypt/src/rsa.c ****                 ret = MP_INVMOD_E;
 3963                             		.loc 2 2559 21
 3964 0159 F8 A6 89                		mov.L	#-119, [r10]
2560:../src/wolfcrypt/src/rsa.c ****                 break;
 3965                             		.loc 2 2560 17
 3966 015c 38 F0 01                		bra	.L244
 3967                             	.L248:
2561:../src/wolfcrypt/src/rsa.c ****             }
2562:../src/wolfcrypt/src/rsa.c ****         #ifdef WOLFSSL_CHECK_MEM_ZERO
2563:../src/wolfcrypt/src/rsa.c ****             mp_memzero_add("RSA sync rnd", rnd);
2564:../src/wolfcrypt/src/rsa.c ****             mp_memzero_add("RSA sync rndi", rndi);
2565:../src/wolfcrypt/src/rsa.c ****         #endif
2566:../src/wolfcrypt/src/rsa.c **** 
2567:../src/wolfcrypt/src/rsa.c ****             /* rnd = rnd^e */
2568:../src/wolfcrypt/src/rsa.c ****         #ifndef WOLFSSL_SP_MATH_ALL
2569:../src/wolfcrypt/src/rsa.c ****             if (mp_exptmod(rnd, &key->e, &key->n, rnd) != MP_OKAY) {
2570:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
2571:../src/wolfcrypt/src/rsa.c ****                 break;
2572:../src/wolfcrypt/src/rsa.c ****             }
2573:../src/wolfcrypt/src/rsa.c ****         #else
2574:../src/wolfcrypt/src/rsa.c ****             if (mp_exptmod_nct(rnd, &key->e, &key->n, rnd) != MP_OKAY) {
 3968                             		.loc 2 2574 37
 3969 015f A8 6D                   		mov.L	4[r6], r5
 3970 0161 72 55 10 03             		add	#0x310, r5
 3971                             		.loc 2 2574 46
 3972 0165 A8 6B                   		mov.L	4[r6], r3
 3973                             		.loc 2 2574 17
 3974 0167 ED A4 06                		mov.L	24[r10], r4
 3975 016a EF 52                   		mov.L	r5, r2
 3976 016c ED A1 06                		mov.L	24[r10], r1
 3977 016f 05 00 00 00             		bsr	_sp_exptmod_nct
 3978 0173 EF 15                   		mov.L	r1, r5
 3979                             		.loc 2 2574 16
 3980 0175 61 05                   		cmp	#0, r5
 3981 0177 17                      		beq	.L249
2575:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 3982                             		.loc 2 2575 21
 3983 0178 F8 A6 90                		mov.L	#-112, [r10]
2576:../src/wolfcrypt/src/rsa.c ****                 break;
 3984                             		.loc 2 2576 17
 3985 017b 38 D1 01                		bra	.L244
 3986                             	.L249:
2577:../src/wolfcrypt/src/rsa.c ****             }
2578:../src/wolfcrypt/src/rsa.c ****         #endif
2579:../src/wolfcrypt/src/rsa.c **** 
2580:../src/wolfcrypt/src/rsa.c ****             /* tmp = tmp*rnd mod n */
2581:../src/wolfcrypt/src/rsa.c ****             if (mp_mulmod(tmp, rnd, &key->n, tmp) != MP_OKAY) {
 3987                             		.loc 2 2581 37
 3988 017e A8 6D                   		mov.L	4[r6], r5
 3989                             		.loc 2 2581 17
 3990 0180 ED A4 05                		mov.L	20[r10], r4
 3991 0183 EF 53                   		mov.L	r5, r3
 3992 0185 ED A2 06                		mov.L	24[r10], r2
 3993 0188 ED A1 05                		mov.L	20[r10], r1
 3994 018b 05 00 00 00             		bsr	_sp_mulmod
 3995 018f EF 15                   		mov.L	r1, r5
 3996                             		.loc 2 2581 16
 3997 0191 61 05                   		cmp	#0, r5
 3998 0193 17                      		beq	.L250
2582:../src/wolfcrypt/src/rsa.c ****                 ret = MP_MULMOD_E;
 3999                             		.loc 2 2582 21
 4000 0194 F8 A6 8B                		mov.L	#-117, [r10]
2583:../src/wolfcrypt/src/rsa.c ****                 break;
 4001                             		.loc 2 2583 17
 4002 0197 38 B5 01                		bra	.L244
 4003                             	.L250:
 4004                             	.LBB38:
2584:../src/wolfcrypt/src/rsa.c ****             }
2585:../src/wolfcrypt/src/rsa.c ****         #endif /* WC_RSA_BLINDING && !WC_NO_RNG */
2586:../src/wolfcrypt/src/rsa.c **** 
2587:../src/wolfcrypt/src/rsa.c ****         #ifdef RSA_LOW_MEM      /* half as much memory but twice as slow */
2588:../src/wolfcrypt/src/rsa.c ****             if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
2589:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
2590:../src/wolfcrypt/src/rsa.c ****                 break;
2591:../src/wolfcrypt/src/rsa.c ****             }
2592:../src/wolfcrypt/src/rsa.c ****         #else
2593:../src/wolfcrypt/src/rsa.c ****             {
2594:../src/wolfcrypt/src/rsa.c ****             #ifdef WOLFSSL_SMALL_STACK
2595:../src/wolfcrypt/src/rsa.c ****                 mp_int* tmpa;
2596:../src/wolfcrypt/src/rsa.c ****                 mp_int* tmpb = NULL;
 4005                             		.loc 2 2596 25
 4006 019a F9 A6 01 00             		mov.L	#0, 4[r10]
2597:../src/wolfcrypt/src/rsa.c ****             #else
2598:../src/wolfcrypt/src/rsa.c ****                 mp_int tmpa[1], tmpb[1];
2599:../src/wolfcrypt/src/rsa.c ****             #endif
2600:../src/wolfcrypt/src/rsa.c ****                 int cleara = 0, clearb = 0;
 4007                             		.loc 2 2600 21
 4008 019e F9 A6 02 00             		mov.L	#0, 8[r10]
 4009                             		.loc 2 2600 33
 4010 01a2 F9 A6 03 00             		mov.L	#0, 12[r10]
2601:../src/wolfcrypt/src/rsa.c **** 
2602:../src/wolfcrypt/src/rsa.c ****             #ifdef WOLFSSL_SMALL_STACK
2603:../src/wolfcrypt/src/rsa.c ****                 tmpa = (mp_int*)XMALLOC(sizeof(mp_int) * 2,
 4011                             		.loc 2 2603 33
 4012 01a6 FB 1A 20 06             		mov.L	#0x620, r1
 4013 01aa 05 00 00 00             		bsr	_wolfSSL_Malloc
 4014 01ae E7 A1 09                		mov.L	r1, 36[r10]
2604:../src/wolfcrypt/src/rsa.c ****                         key->heap, DYNAMIC_TYPE_RSA);
2605:../src/wolfcrypt/src/rsa.c ****                 if (tmpa != NULL)
 4015                             		.loc 2 2605 20
 4016 01b1 ED A5 09                		mov.L	36[r10], r5
 4017 01b4 61 05                   		cmp	#0, r5
 4018 01b6 20 0D                   		beq	.L251
2606:../src/wolfcrypt/src/rsa.c ****                     tmpb = tmpa + 1;
 4019                             		.loc 2 2606 26
 4020 01b8 ED A5 09                		mov.L	36[r10], r5
 4021 01bb 72 55 10 03             		add	#0x310, r5
 4022 01bf E7 A5 01                		mov.L	r5, 4[r10]
 4023 01c2 0C                      		bra	.L252
 4024                             	.L251:
2607:../src/wolfcrypt/src/rsa.c ****                 else
2608:../src/wolfcrypt/src/rsa.c ****                     ret = MEMORY_E;
 4025                             		.loc 2 2608 25
 4026 01c3 F8 A6 83                		mov.L	#-125, [r10]
 4027                             	.L252:
2609:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0)
 4028                             		.loc 2 2609 20
 4029 01c6 EC A5                   		mov.L	[r10], r5
 4030 01c8 61 05                   		cmp	#0, r5
 4031 01ca 21 16                   		bne	.L253
2610:../src/wolfcrypt/src/rsa.c ****             #endif
2611:../src/wolfcrypt/src/rsa.c ****                 {
2612:../src/wolfcrypt/src/rsa.c ****                     if (mp_init(tmpa) != MP_OKAY)
 4032                             		.loc 2 2612 25
 4033 01cc ED A1 09                		mov.L	36[r10], r1
 4034 01cf 05 00 00 00             		bsr	_sp_init
 4035 01d3 EF 15                   		mov.L	r1, r5
 4036                             		.loc 2 2612 24
 4037 01d5 61 05                   		cmp	#0, r5
 4038 01d7 15                      		beq	.L254
2613:../src/wolfcrypt/src/rsa.c ****                         ret = MP_INIT_E;
 4039                             		.loc 2 2613 29
 4040 01d8 F8 A6 92                		mov.L	#-110, [r10]
 4041 01db 0D                      		bra	.L253
 4042                             	.L254:
2614:../src/wolfcrypt/src/rsa.c ****                     else
2615:../src/wolfcrypt/src/rsa.c ****                         cleara = 1;
 4043                             		.loc 2 2615 32
 4044 01dc F9 A6 02 01             		mov.L	#1, 8[r10]
 4045                             	.L253:
2616:../src/wolfcrypt/src/rsa.c ****                 }
2617:../src/wolfcrypt/src/rsa.c **** 
2618:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0) {
 4046                             		.loc 2 2618 20
 4047 01e0 EC A5                   		mov.L	[r10], r5
 4048 01e2 61 05                   		cmp	#0, r5
 4049 01e4 21 16                   		bne	.L255
2619:../src/wolfcrypt/src/rsa.c ****                     if (mp_init(tmpb) != MP_OKAY)
 4050                             		.loc 2 2619 25
 4051 01e6 ED A1 01                		mov.L	4[r10], r1
 4052 01e9 05 00 00 00             		bsr	_sp_init
 4053 01ed EF 15                   		mov.L	r1, r5
 4054                             		.loc 2 2619 24
 4055 01ef 61 05                   		cmp	#0, r5
 4056 01f1 15                      		beq	.L256
2620:../src/wolfcrypt/src/rsa.c ****                         ret = MP_INIT_E;
 4057                             		.loc 2 2620 29
 4058 01f2 F8 A6 92                		mov.L	#-110, [r10]
 4059 01f5 0D                      		bra	.L255
 4060                             	.L256:
2621:../src/wolfcrypt/src/rsa.c ****                     else
2622:../src/wolfcrypt/src/rsa.c ****                         clearb = 1;
 4061                             		.loc 2 2622 32
 4062 01f6 F9 A6 03 01             		mov.L	#1, 12[r10]
 4063                             	.L255:
2623:../src/wolfcrypt/src/rsa.c ****                 }
2624:../src/wolfcrypt/src/rsa.c **** 
2625:../src/wolfcrypt/src/rsa.c ****             #ifdef WOLFSSL_CHECK_MEM_ZERO
2626:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0) {
2627:../src/wolfcrypt/src/rsa.c ****                     mp_memzero_add("RSA Sync tmpa", tmpa);
2628:../src/wolfcrypt/src/rsa.c ****                     mp_memzero_add("RSA Sync tmpb", tmpb);
2629:../src/wolfcrypt/src/rsa.c ****                 }
2630:../src/wolfcrypt/src/rsa.c ****             #endif
2631:../src/wolfcrypt/src/rsa.c **** 
2632:../src/wolfcrypt/src/rsa.c ****                 /* tmpa = tmp^dP mod p */
2633:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0 && mp_exptmod(tmp, &key->dP, &key->p,
 4064                             		.loc 2 2633 20
 4065 01fa EC A5                   		mov.L	[r10], r5
 4066 01fc 61 05                   		cmp	#0, r5
 4067 01fe 21 22                   		bne	.L257
 4068                             		.loc 2 2633 49 discriminator 1
 4069 0200 A8 6D                   		mov.L	4[r6], r5
 4070 0202 72 52 50 0F             		add	#0xf50, r5, r2
 4071                             		.loc 2 2633 59 discriminator 1
 4072 0206 A8 6D                   		mov.L	4[r6], r5
 4073 0208 72 55 30 09             		add	#0x930, r5
 4074                             		.loc 2 2633 33 discriminator 1
 4075 020c ED A4 09                		mov.L	36[r10], r4
 4076 020f EF 53                   		mov.L	r5, r3
 4077 0211 ED A1 05                		mov.L	20[r10], r1
 4078 0214 05 00 00 00             		bsr	_sp_exptmod
 4079 0218 EF 15                   		mov.L	r1, r5
 4080                             		.loc 2 2633 30 discriminator 1
 4081 021a 61 05                   		cmp	#0, r5
 4082 021c 14                      		beq	.L257
2634:../src/wolfcrypt/src/rsa.c ****                                                                tmpa) != MP_OKAY)
2635:../src/wolfcrypt/src/rsa.c ****                     ret = MP_EXPTMOD_E;
 4083                             		.loc 2 2635 25
 4084 021d F8 A6 90                		mov.L	#-112, [r10]
 4085                             	.L257:
2636:../src/wolfcrypt/src/rsa.c **** 
2637:../src/wolfcrypt/src/rsa.c ****                 /* tmpb = tmp^dQ mod q */
2638:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0 && mp_exptmod(tmp, &key->dQ, &key->q,
 4086                             		.loc 2 2638 20
 4087 0220 EC A5                   		mov.L	[r10], r5
 4088 0222 61 05                   		cmp	#0, r5
 4089 0224 21 22                   		bne	.L258
 4090                             		.loc 2 2638 49 discriminator 1
 4091 0226 A8 6D                   		mov.L	4[r6], r5
 4092 0228 72 52 60 12             		add	#0x1260, r5, r2
 4093                             		.loc 2 2638 59 discriminator 1
 4094 022c A8 6D                   		mov.L	4[r6], r5
 4095 022e 72 55 40 0C             		add	#0xc40, r5
 4096                             		.loc 2 2638 33 discriminator 1
 4097 0232 ED A4 01                		mov.L	4[r10], r4
 4098 0235 EF 53                   		mov.L	r5, r3
 4099 0237 ED A1 05                		mov.L	20[r10], r1
 4100 023a 05 00 00 00             		bsr	_sp_exptmod
 4101 023e EF 15                   		mov.L	r1, r5
 4102                             		.loc 2 2638 30 discriminator 1
 4103 0240 61 05                   		cmp	#0, r5
 4104 0242 14                      		beq	.L258
2639:../src/wolfcrypt/src/rsa.c ****                                                                tmpb) != MP_OKAY)
2640:../src/wolfcrypt/src/rsa.c ****                     ret = MP_EXPTMOD_E;
 4105                             		.loc 2 2640 25
 4106 0243 F8 A6 90                		mov.L	#-112, [r10]
 4107                             	.L258:
2641:../src/wolfcrypt/src/rsa.c **** 
2642:../src/wolfcrypt/src/rsa.c ****                 /* tmp = (tmpa - tmpb) * qInv (mod p) */
2643:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_SP_MATH) || (defined(WOLFSSL_SP_MATH_ALL) && \
2644:../src/wolfcrypt/src/rsa.c ****                                               !defined(WOLFSSL_SP_INT_NEGATIVE))
2645:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0 && mp_submod(tmpa, tmpb, &key->p, tmp) != MP_OKAY)
 4108                             		.loc 2 2645 20
 4109 0246 EC A5                   		mov.L	[r10], r5
 4110 0248 61 05                   		cmp	#0, r5
 4111 024a 21 1F                   		bne	.L259
 4112                             		.loc 2 2645 55 discriminator 1
 4113 024c A8 6D                   		mov.L	4[r6], r5
 4114 024e 72 55 30 09             		add	#0x930, r5
 4115                             		.loc 2 2645 33 discriminator 1
 4116 0252 ED A4 05                		mov.L	20[r10], r4
 4117 0255 EF 53                   		mov.L	r5, r3
 4118 0257 ED A2 01                		mov.L	4[r10], r2
 4119 025a ED A1 09                		mov.L	36[r10], r1
 4120 025d 05 00 00 00             		bsr	_sp_submod
 4121 0261 EF 15                   		mov.L	r1, r5
 4122                             		.loc 2 2645 30 discriminator 1
 4123 0263 61 05                   		cmp	#0, r5
 4124 0265 14                      		beq	.L259
2646:../src/wolfcrypt/src/rsa.c ****                     ret = MP_SUB_E;
 4125                             		.loc 2 2646 25
 4126 0266 F8 A6 8E                		mov.L	#-114, [r10]
 4127                             	.L259:
2647:../src/wolfcrypt/src/rsa.c **** #else
2648:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0 && mp_sub(tmpa, tmpb, tmp) != MP_OKAY)
2649:../src/wolfcrypt/src/rsa.c ****                     ret = MP_SUB_E;
2650:../src/wolfcrypt/src/rsa.c **** #endif
2651:../src/wolfcrypt/src/rsa.c **** 
2652:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0 && mp_mulmod(tmp, &key->u, &key->p,
 4128                             		.loc 2 2652 20
 4129 0269 EC A5                   		mov.L	[r10], r5
 4130 026b 61 05                   		cmp	#0, r5
 4131 026d 21 22                   		bne	.L260
 4132                             		.loc 2 2652 48 discriminator 1
 4133 026f A8 6D                   		mov.L	4[r6], r5
 4134 0271 72 52 70 15             		add	#0x1570, r5, r2
 4135                             		.loc 2 2652 57 discriminator 1
 4136 0275 A8 6D                   		mov.L	4[r6], r5
 4137 0277 72 55 30 09             		add	#0x930, r5
 4138                             		.loc 2 2652 33 discriminator 1
 4139 027b ED A4 05                		mov.L	20[r10], r4
 4140 027e EF 53                   		mov.L	r5, r3
 4141 0280 ED A1 05                		mov.L	20[r10], r1
 4142 0283 05 00 00 00             		bsr	_sp_mulmod
 4143 0287 EF 15                   		mov.L	r1, r5
 4144                             		.loc 2 2652 30 discriminator 1
 4145 0289 61 05                   		cmp	#0, r5
 4146 028b 14                      		beq	.L260
2653:../src/wolfcrypt/src/rsa.c ****                                                                 tmp) != MP_OKAY)
2654:../src/wolfcrypt/src/rsa.c ****                     ret = MP_MULMOD_E;
 4147                             		.loc 2 2654 25
 4148 028c F8 A6 8B                		mov.L	#-117, [r10]
 4149                             	.L260:
2655:../src/wolfcrypt/src/rsa.c **** 
2656:../src/wolfcrypt/src/rsa.c ****                 /* tmp = tmpb + q * tmp */
2657:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0 && mp_mul(tmp, &key->q, tmp) != MP_OKAY)
 4150                             		.loc 2 2657 20
 4151 028f EC A5                   		mov.L	[r10], r5
 4152 0291 61 05                   		cmp	#0, r5
 4153 0293 21 1C                   		bne	.L261
 4154                             		.loc 2 2657 45 discriminator 1
 4155 0295 A8 6D                   		mov.L	4[r6], r5
 4156 0297 72 55 40 0C             		add	#0xc40, r5
 4157                             		.loc 2 2657 33 discriminator 1
 4158 029b ED A3 05                		mov.L	20[r10], r3
 4159 029e EF 52                   		mov.L	r5, r2
 4160 02a0 ED A1 05                		mov.L	20[r10], r1
 4161 02a3 05 00 00 00             		bsr	_sp_mul
 4162 02a7 EF 15                   		mov.L	r1, r5
 4163                             		.loc 2 2657 30 discriminator 1
 4164 02a9 61 05                   		cmp	#0, r5
 4165 02ab 14                      		beq	.L261
2658:../src/wolfcrypt/src/rsa.c ****                     ret = MP_MUL_E;
 4166                             		.loc 2 2658 25
 4167 02ac F8 A6 8C                		mov.L	#-116, [r10]
 4168                             	.L261:
2659:../src/wolfcrypt/src/rsa.c **** 
2660:../src/wolfcrypt/src/rsa.c ****                 if (ret == 0 && mp_add(tmp, tmpb, tmp) != MP_OKAY)
 4169                             		.loc 2 2660 20
 4170 02af EC A5                   		mov.L	[r10], r5
 4171 02b1 61 05                   		cmp	#0, r5
 4172 02b3 21 17                   		bne	.L262
 4173                             		.loc 2 2660 33 discriminator 1
 4174 02b5 ED A3 05                		mov.L	20[r10], r3
 4175 02b8 ED A2 01                		mov.L	4[r10], r2
 4176 02bb ED A1 05                		mov.L	20[r10], r1
 4177 02be 05 00 00 00             		bsr	_sp_add
 4178 02c2 EF 15                   		mov.L	r1, r5
 4179                             		.loc 2 2660 30 discriminator 1
 4180 02c4 61 05                   		cmp	#0, r5
 4181 02c6 14                      		beq	.L262
2661:../src/wolfcrypt/src/rsa.c ****                     ret = MP_ADD_E;
 4182                             		.loc 2 2661 25
 4183 02c7 F8 A6 8D                		mov.L	#-115, [r10]
 4184                             	.L262:
2662:../src/wolfcrypt/src/rsa.c **** 
2663:../src/wolfcrypt/src/rsa.c ****             #ifdef WOLFSSL_SMALL_STACK
2664:../src/wolfcrypt/src/rsa.c ****                 if (tmpa != NULL)
 4185                             		.loc 2 2664 20
 4186 02ca ED A5 09                		mov.L	36[r10], r5
 4187 02cd 61 05                   		cmp	#0, r5
 4188 02cf 20 2F                   		beq	.L263
2665:../src/wolfcrypt/src/rsa.c ****             #endif
2666:../src/wolfcrypt/src/rsa.c ****                 {
2667:../src/wolfcrypt/src/rsa.c ****                     if (cleara) {
 4189                             		.loc 2 2667 24
 4190 02d1 ED A5 02                		mov.L	8[r10], r5
 4191 02d4 61 05                   		cmp	#0, r5
 4192 02d6 10                      		beq	.L264
2668:../src/wolfcrypt/src/rsa.c ****                         mp_forcezero(tmpa);
 4193                             		.loc 2 2668 25
 4194 02d7 ED A1 09                		mov.L	36[r10], r1
 4195 02da 05 00 00 00             		bsr	_sp_forcezero
 4196                             	.L264:
2669:../src/wolfcrypt/src/rsa.c ****                     }
2670:../src/wolfcrypt/src/rsa.c ****                     if (clearb) {
 4197                             		.loc 2 2670 24
 4198 02de ED A5 03                		mov.L	12[r10], r5
 4199 02e1 61 05                   		cmp	#0, r5
 4200 02e3 10                      		beq	.L265
2671:../src/wolfcrypt/src/rsa.c ****                         mp_forcezero(tmpb);
 4201                             		.loc 2 2671 25
 4202 02e4 ED A1 01                		mov.L	4[r10], r1
 4203 02e7 05 00 00 00             		bsr	_sp_forcezero
 4204                             	.L265:
 4205                             	.LBB39:
2672:../src/wolfcrypt/src/rsa.c ****                     }
2673:../src/wolfcrypt/src/rsa.c ****             #ifdef WOLFSSL_SMALL_STACK
2674:../src/wolfcrypt/src/rsa.c ****                     /* tmpb is allocated after tmpa. */
2675:../src/wolfcrypt/src/rsa.c ****                     XFREE(tmpa, key->heap, DYNAMIC_TYPE_RSA);
 4206                             		.loc 2 2675 21
 4207 02eb ED A5 09                		mov.L	36[r10], r5
 4208 02ee E7 A5 0A                		mov.L	r5, 40[r10]
 4209 02f1 ED A5 0A                		mov.L	40[r10], r5
 4210 02f4 61 05                   		cmp	#0, r5
 4211 02f6 10                      		beq	.L263
 4212                             		.loc 2 2675 21 is_stmt 0 discriminator 1
 4213 02f7 ED A1 0A                		mov.L	40[r10], r1
 4214 02fa 05 00 00 00             		bsr	_wolfSSL_Free
 4215                             	.L263:
 4216                             	.LBE39:
 4217                             	.LBE38:
2676:../src/wolfcrypt/src/rsa.c ****             #elif defined(WOLFSSL_CHECK_MEM_ZERO)
2677:../src/wolfcrypt/src/rsa.c ****                     mp_memzero_check(tmpb);
2678:../src/wolfcrypt/src/rsa.c ****                     mp_memzero_check(tmpa);
2679:../src/wolfcrypt/src/rsa.c ****             #endif
2680:../src/wolfcrypt/src/rsa.c ****                 }
2681:../src/wolfcrypt/src/rsa.c ****             } /* tmpa/b scope */
2682:../src/wolfcrypt/src/rsa.c ****         #endif   /* RSA_LOW_MEM */
2683:../src/wolfcrypt/src/rsa.c **** 
2684:../src/wolfcrypt/src/rsa.c ****         #ifdef WC_RSA_BLINDING
2685:../src/wolfcrypt/src/rsa.c ****             /* unblind */
2686:../src/wolfcrypt/src/rsa.c ****             if (ret == 0 && mp_mulmod(tmp, rndi, &key->n, tmp) != MP_OKAY)
 4218                             		.loc 2 2686 16 is_stmt 1
 4219 02fe EC A5                   		mov.L	[r10], r5
 4220 0300 61 05                   		cmp	#0, r5
 4221 0302 21 46                   		bne	.L276
 4222                             		.loc 2 2686 50 discriminator 1
 4223 0304 A8 6D                   		mov.L	4[r6], r5
 4224                             		.loc 2 2686 29 discriminator 1
 4225 0306 ED A4 05                		mov.L	20[r10], r4
 4226 0309 EF 53                   		mov.L	r5, r3
 4227 030b ED A2 08                		mov.L	32[r10], r2
 4228 030e ED A1 05                		mov.L	20[r10], r1
 4229 0311 05 00 00 00             		bsr	_sp_mulmod
 4230 0315 EF 15                   		mov.L	r1, r5
 4231                             		.loc 2 2686 26 discriminator 1
 4232 0317 61 05                   		cmp	#0, r5
 4233 0319 20 2F                   		beq	.L276
2687:../src/wolfcrypt/src/rsa.c ****                 ret = MP_MULMOD_E;
 4234                             		.loc 2 2687 21
 4235 031b F8 A6 8B                		mov.L	#-117, [r10]
2688:../src/wolfcrypt/src/rsa.c ****         #endif /* WC_RSA_BLINDING */
2689:../src/wolfcrypt/src/rsa.c **** 
2690:../src/wolfcrypt/src/rsa.c ****             break;
 4236                             		.loc 2 2690 13
 4237 031e 2E 2A                   		bra	.L276
 4238                             	.L246:
2691:../src/wolfcrypt/src/rsa.c ****         }
2692:../src/wolfcrypt/src/rsa.c ****     #endif
2693:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_ENCRYPT:
2694:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_DECRYPT:
2695:../src/wolfcrypt/src/rsa.c ****             if (mp_exptmod_nct(tmp, &key->e, &key->n, tmp) != MP_OKAY)
 4239                             		.loc 2 2695 37
 4240 0320 A8 6D                   		mov.L	4[r6], r5
 4241 0322 72 55 10 03             		add	#0x310, r5
 4242                             		.loc 2 2695 46
 4243 0326 A8 6B                   		mov.L	4[r6], r3
 4244                             		.loc 2 2695 17
 4245 0328 ED A4 05                		mov.L	20[r10], r4
 4246 032b EF 52                   		mov.L	r5, r2
 4247 032d ED A1 05                		mov.L	20[r10], r1
 4248 0330 05 00 00 00             		bsr	_sp_exptmod_nct
 4249 0334 EF 15                   		mov.L	r1, r5
 4250                             		.loc 2 2695 16
 4251 0336 61 05                   		cmp	#0, r5
 4252 0338 20 13                   		beq	.L277
2696:../src/wolfcrypt/src/rsa.c ****                 ret = MP_EXPTMOD_E;
 4253                             		.loc 2 2696 21
 4254 033a F8 A6 90                		mov.L	#-112, [r10]
2697:../src/wolfcrypt/src/rsa.c ****             break;
 4255                             		.loc 2 2697 13
 4256 033d 2E 0E                   		bra	.L277
 4257                             	.L245:
2698:../src/wolfcrypt/src/rsa.c ****         default:
2699:../src/wolfcrypt/src/rsa.c ****             ret = RSA_WRONG_TYPE_E;
 4258                             		.loc 2 2699 17
 4259 033f F8 AA 7E FF             		mov.L	#-130, [r10]
2700:../src/wolfcrypt/src/rsa.c ****             break;
 4260                             		.loc 2 2700 13
 4261 0343 09                      		bra	.L244
 4262                             	.L274:
2701:../src/wolfcrypt/src/rsa.c ****         }
2702:../src/wolfcrypt/src/rsa.c ****     }
 4263                             		.loc 2 2702 5
 4264 0344 03                      		nop
 4265 0345 0F                      		bra	.L244
 4266                             	.L275:
2556:../src/wolfcrypt/src/rsa.c ****             /* rndi = 1/rnd mod n */
 4267                             		.loc 2 2556 17
 4268 0346 03                      		nop
 4269 0347 0D                      		bra	.L244
 4270                             	.L276:
2690:../src/wolfcrypt/src/rsa.c ****         }
 4271                             		.loc 2 2690 13
 4272 0348 03                      		nop
 4273 0349 2E 03                   		bra	.L244
 4274                             	.L277:
2697:../src/wolfcrypt/src/rsa.c ****         default:
 4275                             		.loc 2 2697 13
 4276 034b 03                      		nop
 4277                             		.balign 8,3,1
 4278                             	.L244:
2703:../src/wolfcrypt/src/rsa.c **** 
2704:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 4279                             		.loc 2 2704 8
 4280 034c EC A5                   		mov.L	[r10], r5
 4281 034e 61 05                   		cmp	#0, r5
 4282 0350 21 12                   		bne	.L268
2705:../src/wolfcrypt/src/rsa.c ****         if (keyLen > *outLen)
 4283                             		.loc 2 2705 22
 4284 0352 ED A5 10                		mov.L	64[r10], r5
 4285 0355 EC 55                   		mov.L	[r5], r5
 4286                             		.loc 2 2705 12
 4287 0357 ED A4 04                		mov.L	16[r10], r4
 4288 035a 47 54                   		cmp	r5, r4
 4289 035c 25 06                   		bleu	.L268
2706:../src/wolfcrypt/src/rsa.c ****             ret = RSA_BUFFER_E;
 4290                             		.loc 2 2706 17
 4291 035e F8 AA 7D FF             		mov.L	#-131, [r10]
 4292                             	.L268:
2707:../src/wolfcrypt/src/rsa.c ****     }
2708:../src/wolfcrypt/src/rsa.c **** 
2709:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 4293                             		.loc 2 2709 8
 4294 0362 EC A5                   		mov.L	[r10], r5
 4295 0364 61 05                   		cmp	#0, r5
 4296 0366 21 21                   		bne	.L269
2710:../src/wolfcrypt/src/rsa.c ****         *outLen = keyLen;
 4297                             		.loc 2 2710 17
 4298 0368 ED A5 10                		mov.L	64[r10], r5
 4299 036b ED A4 04                		mov.L	16[r10], r4
 4300 036e E3 54                   		mov.L	r4, [r5]
2711:../src/wolfcrypt/src/rsa.c ****         if (mp_to_unsigned_bin_len(tmp, out, keyLen) != MP_OKAY)
 4301                             		.loc 2 2711 13
 4302 0370 ED A5 04                		mov.L	16[r10], r5
 4303 0373 EF 53                   		mov.L	r5, r3
 4304 0375 ED A2 0F                		mov.L	60[r10], r2
 4305 0378 ED A1 05                		mov.L	20[r10], r1
 4306 037b 05 00 00 00             		bsr	_sp_to_unsigned_bin_len
 4307 037f EF 15                   		mov.L	r1, r5
 4308                             		.loc 2 2711 12
 4309 0381 61 05                   		cmp	#0, r5
 4310 0383 14                      		beq	.L269
2712:../src/wolfcrypt/src/rsa.c ****              ret = MP_TO_E;
 4311                             		.loc 2 2712 18
 4312 0384 F8 A6 8F                		mov.L	#-113, [r10]
 4313                             	.L269:
2713:../src/wolfcrypt/src/rsa.c ****     }
2714:../src/wolfcrypt/src/rsa.c **** #else
2715:../src/wolfcrypt/src/rsa.c ****     (void)type;
2716:../src/wolfcrypt/src/rsa.c ****     (void)key;
2717:../src/wolfcrypt/src/rsa.c ****     XMEMCPY(out, in, inLen);
2718:../src/wolfcrypt/src/rsa.c ****     *outLen = inLen;
2719:../src/wolfcrypt/src/rsa.c **** #endif
2720:../src/wolfcrypt/src/rsa.c **** 
2721:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(tmp);
 4314                             		.loc 2 2721 5
 4315 0387 ED A1 05                		mov.L	20[r10], r1
 4316 038a 05 00 00 00             		bsr	_sp_forcezero
 4317                             	.LBB40:
2722:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
2723:../src/wolfcrypt/src/rsa.c ****     XFREE(tmp, key->heap, DYNAMIC_TYPE_RSA);
 4318                             		.loc 2 2723 5
 4319 038e ED A5 05                		mov.L	20[r10], r5
 4320 0391 E7 A5 0B                		mov.L	r5, 44[r10]
 4321 0394 ED A5 0B                		mov.L	44[r10], r5
 4322 0397 61 05                   		cmp	#0, r5
 4323 0399 10                      		beq	.L270
 4324                             		.loc 2 2723 5 is_stmt 0 discriminator 1
 4325 039a ED A1 0B                		mov.L	44[r10], r1
 4326 039d 05 00 00 00             		bsr	_wolfSSL_Free
 4327                             	.L270:
 4328                             	.LBE40:
2724:../src/wolfcrypt/src/rsa.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
2725:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(tmp);
2726:../src/wolfcrypt/src/rsa.c **** #endif
2727:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
2728:../src/wolfcrypt/src/rsa.c ****     if (type == RSA_PRIVATE_DECRYPT || type == RSA_PRIVATE_ENCRYPT) {
 4329                             		.loc 2 2728 8 is_stmt 1
 4330 03a1 EC 65                   		mov.L	[r6], r5
 4331 03a3 61 35                   		cmp	#3, r5
 4332 03a5 17                      		beq	.L271
 4333                             		.loc 2 2728 37 discriminator 1
 4334 03a6 EC 65                   		mov.L	[r6], r5
 4335 03a8 61 25                   		cmp	#2, r5
 4336 03aa 21 10                   		bne	.L272
 4337                             	.L271:
2729:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(rndi);
 4338                             		.loc 2 2729 9
 4339 03ac ED A1 08                		mov.L	32[r10], r1
 4340 03af 05 00 00 00             		bsr	_sp_forcezero
2730:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(rnd);
 4341                             		.loc 2 2730 9
 4342 03b3 ED A1 06                		mov.L	24[r10], r1
 4343 03b6 05 00 00 00             		bsr	_sp_forcezero
 4344                             	.L272:
 4345                             	.LBB41:
2731:../src/wolfcrypt/src/rsa.c ****     }
2732:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
2733:../src/wolfcrypt/src/rsa.c ****     XFREE(rnd, key->heap, DYNAMIC_TYPE_RSA);
 4346                             		.loc 2 2733 5
 4347 03ba ED A5 06                		mov.L	24[r10], r5
 4348 03bd E7 A5 0C                		mov.L	r5, 48[r10]
 4349 03c0 ED A5 0C                		mov.L	48[r10], r5
 4350 03c3 61 05                   		cmp	#0, r5
 4351 03c5 10                      		beq	.L273
 4352                             		.loc 2 2733 5 is_stmt 0 discriminator 1
 4353 03c6 ED A1 0C                		mov.L	48[r10], r1
 4354 03c9 05 00 00 00             		bsr	_wolfSSL_Free
 4355                             	.L273:
 4356                             	.LBE41:
2734:../src/wolfcrypt/src/rsa.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
2735:../src/wolfcrypt/src/rsa.c ****     if (type == RSA_PRIVATE_DECRYPT || type == RSA_PRIVATE_ENCRYPT) {
2736:../src/wolfcrypt/src/rsa.c ****         mp_memzero_check(rnd);
2737:../src/wolfcrypt/src/rsa.c ****         mp_memzero_check(rndi);
2738:../src/wolfcrypt/src/rsa.c ****     }
2739:../src/wolfcrypt/src/rsa.c **** #endif
2740:../src/wolfcrypt/src/rsa.c **** #endif /* WC_RSA_BLINDING */
2741:../src/wolfcrypt/src/rsa.c ****     return ret;
 4357                             		.loc 2 2741 12 is_stmt 1
 4358 03cd EC A5                   		mov.L	[r10], r5
 4359 03cf 03                      		.balign 8,3,1
 4360                             	.L235:
2742:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_SP_MATH */
2743:../src/wolfcrypt/src/rsa.c **** }
 4361                             		.loc 2 2743 1
 4362 03d0 EF 51                   		mov.L	r5, r1
 4363 03d2 71 00 58                		add	#0x58, r0
 4364 03d5 7E B6                   		pop	r6
 4365 03d7 7E BA                   		pop	r10
 4366 03d9 02                      		rts
 4367                             	.LFE58:
 4369 03da 74 10 01 00 00 00       		.section C,"a",@progbits
 4370                             		.p2align 2
 4371                             	.LC19:
 4372 029c 52 53 41 5F 46 55 4E 43 		.string	"RSA_FUNCTION MP_EXPTMOD_E: memory/config problem"
 4372      54 49 4F 4E 20 4D 50 5F 
 4372      45 58 50 54 4D 4F 44 5F 
 4372      45 3A 20 6D 65 6D 6F 72 
 4372      79 2F 63 6F 6E 66 69 67 
 4373                             		.section	.text.wc_RsaFunction_ex,"ax",@progbits
 4375                             	_wc_RsaFunction_ex:
 4376                             	.LFB59:
2744:../src/wolfcrypt/src/rsa.c **** #endif /* WOLF_CRYPTO_CB_ONLY_RSA */
2745:../src/wolfcrypt/src/rsa.c **** #endif
2746:../src/wolfcrypt/src/rsa.c **** 
2747:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA)
2748:../src/wolfcrypt/src/rsa.c **** static int wc_RsaFunctionAsync(const byte* in, word32 inLen, byte* out,
2749:../src/wolfcrypt/src/rsa.c ****                           word32* outLen, int type, RsaKey* key, WC_RNG* rng)
2750:../src/wolfcrypt/src/rsa.c **** {
2751:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
2752:../src/wolfcrypt/src/rsa.c **** 
2753:../src/wolfcrypt/src/rsa.c ****     (void)rng;
2754:../src/wolfcrypt/src/rsa.c **** 
2755:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_ASYNC_CRYPT_TEST
2756:../src/wolfcrypt/src/rsa.c ****     if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_RSA_FUNC)) {
2757:../src/wolfcrypt/src/rsa.c ****         WC_ASYNC_TEST* testDev = &key->asyncDev.test;
2758:../src/wolfcrypt/src/rsa.c ****         testDev->rsaFunc.in = in;
2759:../src/wolfcrypt/src/rsa.c ****         testDev->rsaFunc.inSz = inLen;
2760:../src/wolfcrypt/src/rsa.c ****         testDev->rsaFunc.out = out;
2761:../src/wolfcrypt/src/rsa.c ****         testDev->rsaFunc.outSz = outLen;
2762:../src/wolfcrypt/src/rsa.c ****         testDev->rsaFunc.type = type;
2763:../src/wolfcrypt/src/rsa.c ****         testDev->rsaFunc.key = key;
2764:../src/wolfcrypt/src/rsa.c ****         testDev->rsaFunc.rng = rng;
2765:../src/wolfcrypt/src/rsa.c ****         return WC_PENDING_E;
2766:../src/wolfcrypt/src/rsa.c ****     }
2767:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_ASYNC_CRYPT_TEST */
2768:../src/wolfcrypt/src/rsa.c **** 
2769:../src/wolfcrypt/src/rsa.c ****     switch(type) {
2770:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
2771:../src/wolfcrypt/src/rsa.c ****     case RSA_PRIVATE_DECRYPT:
2772:../src/wolfcrypt/src/rsa.c ****     case RSA_PRIVATE_ENCRYPT:
2773:../src/wolfcrypt/src/rsa.c ****     #ifdef HAVE_CAVIUM
2774:../src/wolfcrypt/src/rsa.c ****         key->dataLen = key->n.raw.len;
2775:../src/wolfcrypt/src/rsa.c ****         ret = NitroxRsaExptMod(in, inLen,
2776:../src/wolfcrypt/src/rsa.c ****                                key->d.raw.buf, key->d.raw.len,
2777:../src/wolfcrypt/src/rsa.c ****                                key->n.raw.buf, key->n.raw.len,
2778:../src/wolfcrypt/src/rsa.c ****                                out, outLen, key);
2779:../src/wolfcrypt/src/rsa.c ****     #elif defined(HAVE_INTEL_QA)
2780:../src/wolfcrypt/src/rsa.c ****         #ifdef RSA_LOW_MEM
2781:../src/wolfcrypt/src/rsa.c ****             ret = IntelQaRsaPrivate(&key->asyncDev, in, inLen,
2782:../src/wolfcrypt/src/rsa.c ****                                     &key->d.raw, &key->n.raw,
2783:../src/wolfcrypt/src/rsa.c ****                                     out, outLen);
2784:../src/wolfcrypt/src/rsa.c ****         #else
2785:../src/wolfcrypt/src/rsa.c ****             ret = IntelQaRsaCrtPrivate(&key->asyncDev, in, inLen,
2786:../src/wolfcrypt/src/rsa.c ****                                 &key->p.raw, &key->q.raw,
2787:../src/wolfcrypt/src/rsa.c ****                                 &key->dP.raw, &key->dQ.raw,
2788:../src/wolfcrypt/src/rsa.c ****                                 &key->u.raw,
2789:../src/wolfcrypt/src/rsa.c ****                                 out, outLen);
2790:../src/wolfcrypt/src/rsa.c ****         #endif
2791:../src/wolfcrypt/src/rsa.c ****     #else /* WOLFSSL_ASYNC_CRYPT_TEST */
2792:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
2793:../src/wolfcrypt/src/rsa.c ****     #endif
2794:../src/wolfcrypt/src/rsa.c ****         break;
2795:../src/wolfcrypt/src/rsa.c **** #endif
2796:../src/wolfcrypt/src/rsa.c **** 
2797:../src/wolfcrypt/src/rsa.c ****     case RSA_PUBLIC_ENCRYPT:
2798:../src/wolfcrypt/src/rsa.c ****     case RSA_PUBLIC_DECRYPT:
2799:../src/wolfcrypt/src/rsa.c ****     #ifdef HAVE_CAVIUM
2800:../src/wolfcrypt/src/rsa.c ****         key->dataLen = key->n.raw.len;
2801:../src/wolfcrypt/src/rsa.c ****         ret = NitroxRsaExptMod(in, inLen,
2802:../src/wolfcrypt/src/rsa.c ****                                key->e.raw.buf, key->e.raw.len,
2803:../src/wolfcrypt/src/rsa.c ****                                key->n.raw.buf, key->n.raw.len,
2804:../src/wolfcrypt/src/rsa.c ****                                out, outLen, key);
2805:../src/wolfcrypt/src/rsa.c ****     #elif defined(HAVE_INTEL_QA)
2806:../src/wolfcrypt/src/rsa.c ****         ret = IntelQaRsaPublic(&key->asyncDev, in, inLen,
2807:../src/wolfcrypt/src/rsa.c ****                                &key->e.raw, &key->n.raw,
2808:../src/wolfcrypt/src/rsa.c ****                                out, outLen);
2809:../src/wolfcrypt/src/rsa.c ****     #else /* WOLFSSL_ASYNC_CRYPT_TEST */
2810:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
2811:../src/wolfcrypt/src/rsa.c ****     #endif
2812:../src/wolfcrypt/src/rsa.c ****         break;
2813:../src/wolfcrypt/src/rsa.c **** 
2814:../src/wolfcrypt/src/rsa.c ****     default:
2815:../src/wolfcrypt/src/rsa.c ****         ret = RSA_WRONG_TYPE_E;
2816:../src/wolfcrypt/src/rsa.c ****     }
2817:../src/wolfcrypt/src/rsa.c **** 
2818:../src/wolfcrypt/src/rsa.c ****     return ret;
2819:../src/wolfcrypt/src/rsa.c **** }
2820:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_RSA */
2821:../src/wolfcrypt/src/rsa.c **** 
2822:../src/wolfcrypt/src/rsa.c **** #if defined(WC_RSA_DIRECT) || defined(WC_RSA_NO_PADDING)
2823:../src/wolfcrypt/src/rsa.c **** /* Function that does the RSA operation directly with no padding.
2824:../src/wolfcrypt/src/rsa.c ****  *
2825:../src/wolfcrypt/src/rsa.c ****  * in       buffer to do operation on
2826:../src/wolfcrypt/src/rsa.c ****  * inLen    length of input buffer
2827:../src/wolfcrypt/src/rsa.c ****  * out      buffer to hold results
2828:../src/wolfcrypt/src/rsa.c ****  * outSz    gets set to size of result buffer. Should be passed in as length
2829:../src/wolfcrypt/src/rsa.c ****  *          of out buffer. If the pointer "out" is null then outSz gets set to
2830:../src/wolfcrypt/src/rsa.c ****  *          the expected buffer size needed and LENGTH_ONLY_E gets returned.
2831:../src/wolfcrypt/src/rsa.c ****  * key      RSA key to use for encrypt/decrypt
2832:../src/wolfcrypt/src/rsa.c ****  * type     if using private or public key {RSA_PUBLIC_ENCRYPT,
2833:../src/wolfcrypt/src/rsa.c ****  *          RSA_PUBLIC_DECRYPT, RSA_PRIVATE_ENCRYPT, RSA_PRIVATE_DECRYPT}
2834:../src/wolfcrypt/src/rsa.c ****  * rng      wolfSSL RNG to use if needed
2835:../src/wolfcrypt/src/rsa.c ****  *
2836:../src/wolfcrypt/src/rsa.c ****  * returns size of result on success
2837:../src/wolfcrypt/src/rsa.c ****  */
2838:../src/wolfcrypt/src/rsa.c **** int wc_RsaDirect(byte* in, word32 inLen, byte* out, word32* outSz,
2839:../src/wolfcrypt/src/rsa.c ****         RsaKey* key, int type, WC_RNG* rng)
2840:../src/wolfcrypt/src/rsa.c **** {
2841:../src/wolfcrypt/src/rsa.c ****     int ret;
2842:../src/wolfcrypt/src/rsa.c **** 
2843:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || outSz == NULL || key == NULL) {
2844:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
2845:../src/wolfcrypt/src/rsa.c ****     }
2846:../src/wolfcrypt/src/rsa.c **** 
2847:../src/wolfcrypt/src/rsa.c ****     /* sanity check on type of RSA operation */
2848:../src/wolfcrypt/src/rsa.c ****     switch (type) {
2849:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_ENCRYPT:
2850:../src/wolfcrypt/src/rsa.c ****         case RSA_PUBLIC_DECRYPT:
2851:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_ENCRYPT:
2852:../src/wolfcrypt/src/rsa.c ****         case RSA_PRIVATE_DECRYPT:
2853:../src/wolfcrypt/src/rsa.c ****             break;
2854:../src/wolfcrypt/src/rsa.c ****         default:
2855:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("Bad RSA type");
2856:../src/wolfcrypt/src/rsa.c ****             return BAD_FUNC_ARG;
2857:../src/wolfcrypt/src/rsa.c ****     }
2858:../src/wolfcrypt/src/rsa.c **** 
2859:../src/wolfcrypt/src/rsa.c ****     if ((ret = wc_RsaEncryptSize(key)) < 0) {
2860:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
2861:../src/wolfcrypt/src/rsa.c ****     }
2862:../src/wolfcrypt/src/rsa.c **** 
2863:../src/wolfcrypt/src/rsa.c ****     if (inLen != (word32)ret) {
2864:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("Bad input length. Should be RSA key size");
2865:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
2866:../src/wolfcrypt/src/rsa.c ****     }
2867:../src/wolfcrypt/src/rsa.c **** 
2868:../src/wolfcrypt/src/rsa.c ****     if (out == NULL) {
2869:../src/wolfcrypt/src/rsa.c ****         *outSz = inLen;
2870:../src/wolfcrypt/src/rsa.c ****         return LENGTH_ONLY_E;
2871:../src/wolfcrypt/src/rsa.c ****     }
2872:../src/wolfcrypt/src/rsa.c **** 
2873:../src/wolfcrypt/src/rsa.c ****     switch (key->state) {
2874:../src/wolfcrypt/src/rsa.c ****         case RSA_STATE_NONE:
2875:../src/wolfcrypt/src/rsa.c ****         case RSA_STATE_ENCRYPT_PAD:
2876:../src/wolfcrypt/src/rsa.c ****         case RSA_STATE_ENCRYPT_EXPTMOD:
2877:../src/wolfcrypt/src/rsa.c ****         case RSA_STATE_DECRYPT_EXPTMOD:
2878:../src/wolfcrypt/src/rsa.c ****         case RSA_STATE_DECRYPT_UNPAD:
2879:../src/wolfcrypt/src/rsa.c ****             key->state = (type == RSA_PRIVATE_ENCRYPT ||
2880:../src/wolfcrypt/src/rsa.c ****                     type == RSA_PUBLIC_ENCRYPT) ? RSA_STATE_ENCRYPT_EXPTMOD:
2881:../src/wolfcrypt/src/rsa.c ****                                                   RSA_STATE_DECRYPT_EXPTMOD;
2882:../src/wolfcrypt/src/rsa.c **** 
2883:../src/wolfcrypt/src/rsa.c ****             key->dataLen = *outSz;
2884:../src/wolfcrypt/src/rsa.c **** 
2885:../src/wolfcrypt/src/rsa.c ****             ret = wc_RsaFunction(in, inLen, out, &key->dataLen, type, key, rng);
2886:../src/wolfcrypt/src/rsa.c ****             if (ret >= 0 || ret == WC_PENDING_E) {
2887:../src/wolfcrypt/src/rsa.c ****                 key->state = (type == RSA_PRIVATE_ENCRYPT ||
2888:../src/wolfcrypt/src/rsa.c ****                     type == RSA_PUBLIC_ENCRYPT) ? RSA_STATE_ENCRYPT_RES:
2889:../src/wolfcrypt/src/rsa.c ****                                                   RSA_STATE_DECRYPT_RES;
2890:../src/wolfcrypt/src/rsa.c ****             }
2891:../src/wolfcrypt/src/rsa.c ****             if (ret < 0) {
2892:../src/wolfcrypt/src/rsa.c ****                 break;
2893:../src/wolfcrypt/src/rsa.c ****             }
2894:../src/wolfcrypt/src/rsa.c **** 
2895:../src/wolfcrypt/src/rsa.c ****             FALL_THROUGH;
2896:../src/wolfcrypt/src/rsa.c **** 
2897:../src/wolfcrypt/src/rsa.c ****         case RSA_STATE_ENCRYPT_RES:
2898:../src/wolfcrypt/src/rsa.c ****         case RSA_STATE_DECRYPT_RES:
2899:../src/wolfcrypt/src/rsa.c ****             ret = key->dataLen;
2900:../src/wolfcrypt/src/rsa.c ****             break;
2901:../src/wolfcrypt/src/rsa.c **** 
2902:../src/wolfcrypt/src/rsa.c ****         default:
2903:../src/wolfcrypt/src/rsa.c ****             ret = BAD_STATE_E;
2904:../src/wolfcrypt/src/rsa.c ****     }
2905:../src/wolfcrypt/src/rsa.c **** 
2906:../src/wolfcrypt/src/rsa.c ****     /* if async pending then skip cleanup*/
2907:../src/wolfcrypt/src/rsa.c ****     if (ret == WC_PENDING_E
2908:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_NONBLOCK
2909:../src/wolfcrypt/src/rsa.c ****         || ret == FP_WOULDBLOCK
2910:../src/wolfcrypt/src/rsa.c ****     #endif
2911:../src/wolfcrypt/src/rsa.c ****     ) {
2912:../src/wolfcrypt/src/rsa.c ****         return ret;
2913:../src/wolfcrypt/src/rsa.c ****     }
2914:../src/wolfcrypt/src/rsa.c **** 
2915:../src/wolfcrypt/src/rsa.c ****     key->state = RSA_STATE_NONE;
2916:../src/wolfcrypt/src/rsa.c ****     wc_RsaCleanup(key);
2917:../src/wolfcrypt/src/rsa.c **** 
2918:../src/wolfcrypt/src/rsa.c ****     return ret;
2919:../src/wolfcrypt/src/rsa.c **** }
2920:../src/wolfcrypt/src/rsa.c **** #endif /* WC_RSA_DIRECT || WC_RSA_NO_PADDING */
2921:../src/wolfcrypt/src/rsa.c **** 
2922:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_CRYPTOCELL)
2923:../src/wolfcrypt/src/rsa.c **** static int cc310_RsaPublicEncrypt(const byte* in, word32 inLen, byte* out,
2924:../src/wolfcrypt/src/rsa.c ****                             word32 outLen, RsaKey* key)
2925:../src/wolfcrypt/src/rsa.c **** {
2926:../src/wolfcrypt/src/rsa.c ****     CRYSError_t ret = 0;
2927:../src/wolfcrypt/src/rsa.c ****     CRYS_RSAPrimeData_t primeData;
2928:../src/wolfcrypt/src/rsa.c ****     int modulusSize = wc_RsaEncryptSize(key);
2929:../src/wolfcrypt/src/rsa.c **** 
2930:../src/wolfcrypt/src/rsa.c ****     /* The out buffer must be at least modulus size bytes long. */
2931:../src/wolfcrypt/src/rsa.c ****     if (outLen < modulusSize)
2932:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
2933:../src/wolfcrypt/src/rsa.c **** 
2934:../src/wolfcrypt/src/rsa.c ****     ret = CRYS_RSA_PKCS1v15_Encrypt(&wc_rndState,
2935:../src/wolfcrypt/src/rsa.c ****                                     wc_rndGenVectFunc,
2936:../src/wolfcrypt/src/rsa.c ****                                     &key->ctx.pubKey,
2937:../src/wolfcrypt/src/rsa.c ****                                     &primeData,
2938:../src/wolfcrypt/src/rsa.c ****                                     (byte*)in,
2939:../src/wolfcrypt/src/rsa.c ****                                     inLen,
2940:../src/wolfcrypt/src/rsa.c ****                                     out);
2941:../src/wolfcrypt/src/rsa.c **** 
2942:../src/wolfcrypt/src/rsa.c ****     if (ret != SA_SILIB_RET_OK){
2943:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("CRYS_RSA_PKCS1v15_Encrypt failed");
2944:../src/wolfcrypt/src/rsa.c ****         return -1;
2945:../src/wolfcrypt/src/rsa.c ****     }
2946:../src/wolfcrypt/src/rsa.c **** 
2947:../src/wolfcrypt/src/rsa.c ****     return modulusSize;
2948:../src/wolfcrypt/src/rsa.c **** }
2949:../src/wolfcrypt/src/rsa.c **** static int cc310_RsaPublicDecrypt(const byte* in, word32 inLen, byte* out,
2950:../src/wolfcrypt/src/rsa.c ****                             word32 outLen, RsaKey* key)
2951:../src/wolfcrypt/src/rsa.c **** {
2952:../src/wolfcrypt/src/rsa.c ****     CRYSError_t ret = 0;
2953:../src/wolfcrypt/src/rsa.c ****     CRYS_RSAPrimeData_t primeData;
2954:../src/wolfcrypt/src/rsa.c ****     word16 actualOutLen = outLen;
2955:../src/wolfcrypt/src/rsa.c **** 
2956:../src/wolfcrypt/src/rsa.c ****     ret = CRYS_RSA_PKCS1v15_Decrypt(&key->ctx.privKey,
2957:../src/wolfcrypt/src/rsa.c ****                                     &primeData,
2958:../src/wolfcrypt/src/rsa.c ****                                     (byte*)in,
2959:../src/wolfcrypt/src/rsa.c ****                                     inLen,
2960:../src/wolfcrypt/src/rsa.c ****                                     out,
2961:../src/wolfcrypt/src/rsa.c ****                                     &actualOutLen);
2962:../src/wolfcrypt/src/rsa.c **** 
2963:../src/wolfcrypt/src/rsa.c ****     if (ret != SA_SILIB_RET_OK){
2964:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("CRYS_RSA_PKCS1v15_Decrypt failed");
2965:../src/wolfcrypt/src/rsa.c ****         return -1;
2966:../src/wolfcrypt/src/rsa.c ****     }
2967:../src/wolfcrypt/src/rsa.c ****     return actualOutLen;
2968:../src/wolfcrypt/src/rsa.c **** }
2969:../src/wolfcrypt/src/rsa.c **** 
2970:../src/wolfcrypt/src/rsa.c **** int cc310_RsaSSL_Sign(const byte* in, word32 inLen, byte* out,
2971:../src/wolfcrypt/src/rsa.c ****                   word32 outLen, RsaKey* key, CRYS_RSA_HASH_OpMode_t mode)
2972:../src/wolfcrypt/src/rsa.c **** {
2973:../src/wolfcrypt/src/rsa.c ****     CRYSError_t ret = 0;
2974:../src/wolfcrypt/src/rsa.c ****     word16 actualOutLen = outLen*sizeof(byte);
2975:../src/wolfcrypt/src/rsa.c ****     CRYS_RSAPrivUserContext_t  contextPrivate;
2976:../src/wolfcrypt/src/rsa.c **** 
2977:../src/wolfcrypt/src/rsa.c ****     ret =  CRYS_RSA_PKCS1v15_Sign(&wc_rndState,
2978:../src/wolfcrypt/src/rsa.c ****                 wc_rndGenVectFunc,
2979:../src/wolfcrypt/src/rsa.c ****                 &contextPrivate,
2980:../src/wolfcrypt/src/rsa.c ****                 &key->ctx.privKey,
2981:../src/wolfcrypt/src/rsa.c ****                 mode,
2982:../src/wolfcrypt/src/rsa.c ****                 (byte*)in,
2983:../src/wolfcrypt/src/rsa.c ****                 inLen,
2984:../src/wolfcrypt/src/rsa.c ****                 out,
2985:../src/wolfcrypt/src/rsa.c ****                 &actualOutLen);
2986:../src/wolfcrypt/src/rsa.c **** 
2987:../src/wolfcrypt/src/rsa.c ****     if (ret != SA_SILIB_RET_OK){
2988:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("CRYS_RSA_PKCS1v15_Sign failed");
2989:../src/wolfcrypt/src/rsa.c ****         return -1;
2990:../src/wolfcrypt/src/rsa.c ****     }
2991:../src/wolfcrypt/src/rsa.c ****     return actualOutLen;
2992:../src/wolfcrypt/src/rsa.c **** }
2993:../src/wolfcrypt/src/rsa.c **** 
2994:../src/wolfcrypt/src/rsa.c **** int cc310_RsaSSL_Verify(const byte* in, word32 inLen, byte* sig,
2995:../src/wolfcrypt/src/rsa.c ****                                RsaKey* key, CRYS_RSA_HASH_OpMode_t mode)
2996:../src/wolfcrypt/src/rsa.c **** {
2997:../src/wolfcrypt/src/rsa.c ****     CRYSError_t ret = 0;
2998:../src/wolfcrypt/src/rsa.c ****     CRYS_RSAPubUserContext_t contextPub;
2999:../src/wolfcrypt/src/rsa.c **** 
3000:../src/wolfcrypt/src/rsa.c ****     /* verify the signature in the sig pointer */
3001:../src/wolfcrypt/src/rsa.c ****     ret =  CRYS_RSA_PKCS1v15_Verify(&contextPub,
3002:../src/wolfcrypt/src/rsa.c ****                 &key->ctx.pubKey,
3003:../src/wolfcrypt/src/rsa.c ****                 mode,
3004:../src/wolfcrypt/src/rsa.c ****                 (byte*)in,
3005:../src/wolfcrypt/src/rsa.c ****                 inLen,
3006:../src/wolfcrypt/src/rsa.c ****                 sig);
3007:../src/wolfcrypt/src/rsa.c **** 
3008:../src/wolfcrypt/src/rsa.c ****     if (ret != SA_SILIB_RET_OK){
3009:../src/wolfcrypt/src/rsa.c ****         WOLFSSL_MSG("CRYS_RSA_PKCS1v15_Verify failed");
3010:../src/wolfcrypt/src/rsa.c ****         return -1;
3011:../src/wolfcrypt/src/rsa.c ****     }
3012:../src/wolfcrypt/src/rsa.c **** 
3013:../src/wolfcrypt/src/rsa.c ****     return ret;
3014:../src/wolfcrypt/src/rsa.c **** }
3015:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_CRYPTOCELL */
3016:../src/wolfcrypt/src/rsa.c **** 
3017:../src/wolfcrypt/src/rsa.c **** static int wc_RsaFunction_ex(const byte* in, word32 inLen, byte* out,
3018:../src/wolfcrypt/src/rsa.c ****                              word32* outLen, int type, RsaKey* key, WC_RNG* rng,
3019:../src/wolfcrypt/src/rsa.c ****                              int checkSmallCt)
3020:../src/wolfcrypt/src/rsa.c **** {
 4377                             		.loc 2 3020 1
 4378 0000 7E AA                   		push.l	r10
 4379                             	.LCFI77:
 4380 0002 7E A6                   		push.l	r6
 4381                             	.LCFI78:
 4382 0004 71 0A D4                		add	#-44, r0, r10
 4383                             	.LCFI79:
 4384 0007 71 A0 F4                		add	#-12, r10, r0
 4385                             	.LCFI80:
 4386 000a 75 46 38                		mov.L	#56, r6
 4387 000d 4B A6                   		add	r10, r6
 4388 000f E7 A1 03                		mov.L	r1, 12[r10]
 4389 0012 E7 A2 04                		mov.L	r2, 16[r10]
 4390 0015 E7 A3 05                		mov.L	r3, 20[r10]
 4391 0018 E7 A4 06                		mov.L	r4, 24[r10]
3021:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 4392                             		.loc 2 3021 9
 4393 001b F8 A6 00                		mov.L	#0, [r10]
3022:../src/wolfcrypt/src/rsa.c ****     (void)rng;
3023:../src/wolfcrypt/src/rsa.c ****     (void)checkSmallCt;
3024:../src/wolfcrypt/src/rsa.c **** 
3025:../src/wolfcrypt/src/rsa.c ****     if (key == NULL || in == NULL || inLen == 0 || out == NULL ||
 4394                             		.loc 2 3025 8
 4395 001e A8 6D                   		mov.L	4[r6], r5
 4396 0020 61 05                   		cmp	#0, r5
 4397 0022 20 2E                   		beq	.L279
 4398                             		.loc 2 3025 21 discriminator 1
 4399 0024 ED A5 03                		mov.L	12[r10], r5
 4400 0027 61 05                   		cmp	#0, r5
 4401 0029 20 27                   		beq	.L279
 4402                             		.loc 2 3025 35 discriminator 2
 4403 002b ED A5 04                		mov.L	16[r10], r5
 4404 002e 61 05                   		cmp	#0, r5
 4405 0030 20 20                   		beq	.L279
 4406                             		.loc 2 3025 49 discriminator 3
 4407 0032 ED A5 05                		mov.L	20[r10], r5
 4408 0035 61 05                   		cmp	#0, r5
 4409 0037 20 19                   		beq	.L279
 4410                             		.loc 2 3025 64 discriminator 4
 4411 0039 ED A5 06                		mov.L	24[r10], r5
 4412 003c 61 05                   		cmp	#0, r5
 4413 003e 20 12                   		beq	.L279
3026:../src/wolfcrypt/src/rsa.c ****             outLen == NULL || *outLen == 0 || type == RSA_TYPE_UNKNOWN) {
 4414                             		.loc 2 3026 31
 4415 0040 ED A5 06                		mov.L	24[r10], r5
 4416 0043 EC 55                   		mov.L	[r5], r5
 4417                             		.loc 2 3026 28
 4418 0045 61 05                   		cmp	#0, r5
 4419 0047 11                      		beq	.L279
 4420                             		.loc 2 3026 44 discriminator 1
 4421 0048 EC 65                   		mov.L	[r6], r5
 4422 004a 75 05 FF                		cmp	#-1, r5
 4423 004d 1A                      		bne	.L280
 4424 004e EF 00                   		.balign 8,3,2
 4425                             	.L279:
3027:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 4426                             		.loc 2 3027 16
 4427 0050 FB 5A 53 FF             		mov.L	#-173, r5
 4428 0054 38 21 01                		bra	.L281
 4429                             	.L280:
3028:../src/wolfcrypt/src/rsa.c ****     }
3029:../src/wolfcrypt/src/rsa.c **** 
3030:../src/wolfcrypt/src/rsa.c **** #ifdef WOLF_CRYPTO_CB
3031:../src/wolfcrypt/src/rsa.c ****     if (key->devId != INVALID_DEVID) {
3032:../src/wolfcrypt/src/rsa.c ****         ret = wc_CryptoCb_Rsa(in, inLen, out, outLen, type, key, rng);
3033:../src/wolfcrypt/src/rsa.c ****     #ifndef WOLF_CRYPTO_CB_ONLY_RSA
3034:../src/wolfcrypt/src/rsa.c ****         if (ret != CRYPTOCB_UNAVAILABLE)
3035:../src/wolfcrypt/src/rsa.c ****             return ret;
3036:../src/wolfcrypt/src/rsa.c ****         /* fall-through when unavailable */
3037:../src/wolfcrypt/src/rsa.c ****         ret = 0; /* reset error code and try using software */
3038:../src/wolfcrypt/src/rsa.c ****     #else
3039:../src/wolfcrypt/src/rsa.c ****         return ret;
3040:../src/wolfcrypt/src/rsa.c ****     #endif
3041:../src/wolfcrypt/src/rsa.c ****     }
3042:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLF_CRYPTO_CB_ONLY_RSA
3043:../src/wolfcrypt/src/rsa.c ****     else {
3044:../src/wolfcrypt/src/rsa.c ****         return NO_VALID_DEVID;
3045:../src/wolfcrypt/src/rsa.c ****     }
3046:../src/wolfcrypt/src/rsa.c ****     #endif
3047:../src/wolfcrypt/src/rsa.c **** #endif
3048:../src/wolfcrypt/src/rsa.c **** 
3049:../src/wolfcrypt/src/rsa.c **** #ifndef WOLF_CRYPTO_CB_ONLY_RSA
3050:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3051:../src/wolfcrypt/src/rsa.c **** 
3052:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(TEST_UNPAD_CONSTANT_TIME) && \
3053:../src/wolfcrypt/src/rsa.c ****     !defined(NO_RSA_BOUNDS_CHECK)
3054:../src/wolfcrypt/src/rsa.c ****     if (type == RSA_PRIVATE_DECRYPT &&
 4430                             		.loc 2 3054 8
 4431 0057 EC 65                   		mov.L	[r6], r5
 4432 0059 61 35                   		cmp	#3, r5
 4433 005b 3B CF 00                		bne	.L282
3055:../src/wolfcrypt/src/rsa.c ****         key->state == RSA_STATE_DECRYPT_EXPTMOD) {
 4434                             		.loc 2 3055 12 discriminator 1
 4435 005e A8 6D                   		mov.L	4[r6], r5
 4436 0060 EE 55 23 06             		mov.L	6284[r5], r5
3054:../src/wolfcrypt/src/rsa.c ****         key->state == RSA_STATE_DECRYPT_EXPTMOD) {
 4437                             		.loc 2 3054 37 discriminator 1
 4438 0064 61 45                   		cmp	#4, r5
 4439 0066 3B C4 00                		bne	.L282
 4440                             	.LBB42:
3056:../src/wolfcrypt/src/rsa.c **** 
3057:../src/wolfcrypt/src/rsa.c ****         /* Check that 1 < in < n-1. (Requirement of 800-56B.) */
3058:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
3059:../src/wolfcrypt/src/rsa.c ****         mp_int* c;
3060:../src/wolfcrypt/src/rsa.c **** #else
3061:../src/wolfcrypt/src/rsa.c ****         mp_int c[1];
3062:../src/wolfcrypt/src/rsa.c **** #endif
3063:../src/wolfcrypt/src/rsa.c **** 
3064:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
3065:../src/wolfcrypt/src/rsa.c ****         c = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_RSA);
 4441                             		.loc 2 3065 22
 4442 0069 FB 1A 10 03             		mov.L	#0x310, r1
 4443 006d 05 00 00 00             		bsr	_wolfSSL_Malloc
 4444 0071 E7 A1 01                		mov.L	r1, 4[r10]
3066:../src/wolfcrypt/src/rsa.c ****         if (c == NULL)
 4445                             		.loc 2 3066 12
 4446 0074 ED A5 01                		mov.L	4[r10], r5
 4447 0077 61 05                   		cmp	#0, r5
 4448 0079 1C                      		bne	.L283
3067:../src/wolfcrypt/src/rsa.c ****             ret = MEMORY_E;
 4449                             		.loc 2 3067 17
 4450 007a F8 A6 83                		mov.L	#-125, [r10]
 4451                             	.L283:
3068:../src/wolfcrypt/src/rsa.c **** #endif
3069:../src/wolfcrypt/src/rsa.c **** 
3070:../src/wolfcrypt/src/rsa.c ****         if (ret == 0 && mp_init(c) != MP_OKAY)
 4452                             		.loc 2 3070 12
 4453 007d EC A5                   		mov.L	[r10], r5
 4454 007f 61 05                   		cmp	#0, r5
 4455 0081 21 11                   		bne	.L284
 4456                             		.loc 2 3070 25 discriminator 1
 4457 0083 ED A1 01                		mov.L	4[r10], r1
 4458 0086 05 00 00 00             		bsr	_sp_init
 4459 008a EF 15                   		mov.L	r1, r5
 4460                             		.loc 2 3070 22 discriminator 1
 4461 008c 61 05                   		cmp	#0, r5
 4462 008e 14                      		beq	.L284
3071:../src/wolfcrypt/src/rsa.c ****             ret = MP_INIT_E;
 4463                             		.loc 2 3071 17
 4464 008f F8 A6 92                		mov.L	#-110, [r10]
 4465                             	.L284:
3072:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 4466                             		.loc 2 3072 12
 4467 0092 EC A5                   		mov.L	[r10], r5
 4468 0094 61 05                   		cmp	#0, r5
 4469 0096 21 17                   		bne	.L285
3073:../src/wolfcrypt/src/rsa.c ****             if (mp_read_unsigned_bin(c, in, inLen) != 0)
 4470                             		.loc 2 3073 17
 4471 0098 ED A3 04                		mov.L	16[r10], r3
 4472 009b ED A2 03                		mov.L	12[r10], r2
 4473 009e ED A1 01                		mov.L	4[r10], r1
 4474 00a1 05 00 00 00             		bsr	_sp_read_unsigned_bin
 4475 00a5 EF 15                   		mov.L	r1, r5
 4476                             		.loc 2 3073 16
 4477 00a7 61 05                   		cmp	#0, r5
 4478 00a9 14                      		beq	.L285
3074:../src/wolfcrypt/src/rsa.c ****                 ret = MP_READ_E;
 4479                             		.loc 2 3074 21
 4480 00aa F8 A6 91                		mov.L	#-111, [r10]
 4481                             	.L285:
3075:../src/wolfcrypt/src/rsa.c ****         }
3076:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 4482                             		.loc 2 3076 12
 4483 00ad EC A5                   		mov.L	[r10], r5
 4484 00af 61 05                   		cmp	#0, r5
 4485 00b1 21 1A                   		bne	.L286
3077:../src/wolfcrypt/src/rsa.c ****             /* check c > 1 */
3078:../src/wolfcrypt/src/rsa.c ****             if (checkSmallCt && (mp_cmp_d(c, 1) != MP_GT))
 4486                             		.loc 2 3078 16
 4487 00b3 A8 ED                   		mov.L	12[r6], r5
 4488 00b5 61 05                   		cmp	#0, r5
 4489 00b7 20 14                   		beq	.L286
 4490                             		.loc 2 3078 34 discriminator 1
 4491 00b9 66 12                   		mov.L	#1, r2
 4492 00bb ED A1 01                		mov.L	4[r10], r1
 4493 00be 05 00 00 00             		bsr	_sp_cmp_d
 4494 00c2 EF 15                   		mov.L	r1, r5
 4495                             		.loc 2 3078 30 discriminator 1
 4496 00c4 61 15                   		cmp	#1, r5
 4497 00c6 15                      		beq	.L286
3079:../src/wolfcrypt/src/rsa.c ****                 ret = RSA_OUT_OF_RANGE_E;
 4498                             		.loc 2 3079 21
 4499 00c7 F8 AA 03 FF             		mov.L	#-253, [r10]
 4500                             		.balign 8,3,1
 4501                             	.L286:
3080:../src/wolfcrypt/src/rsa.c ****         }
3081:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 4502                             		.loc 2 3081 12
 4503 00cb EC A5                   		mov.L	[r10], r5
 4504 00cd 61 05                   		cmp	#0, r5
 4505 00cf 21 16                   		bne	.L287
3082:../src/wolfcrypt/src/rsa.c ****             /* add c+1 */
3083:../src/wolfcrypt/src/rsa.c ****             if (mp_add_d(c, 1, c) != MP_OKAY)
 4506                             		.loc 2 3083 17
 4507 00d1 ED A3 01                		mov.L	4[r10], r3
 4508 00d4 66 12                   		mov.L	#1, r2
 4509 00d6 ED A1 01                		mov.L	4[r10], r1
 4510 00d9 05 00 00 00             		bsr	_sp_add_d
 4511 00dd EF 15                   		mov.L	r1, r5
 4512                             		.loc 2 3083 16
 4513 00df 61 05                   		cmp	#0, r5
 4514 00e1 14                      		beq	.L287
3084:../src/wolfcrypt/src/rsa.c ****                 ret = MP_ADD_E;
 4515                             		.loc 2 3084 21
 4516 00e2 F8 A6 8D                		mov.L	#-115, [r10]
 4517                             	.L287:
3085:../src/wolfcrypt/src/rsa.c ****         }
3086:../src/wolfcrypt/src/rsa.c ****         if (ret == 0) {
 4518                             		.loc 2 3086 12
 4519 00e5 EC A5                   		mov.L	[r10], r5
 4520 00e7 61 05                   		cmp	#0, r5
 4521 00e9 21 17                   		bne	.L288
3087:../src/wolfcrypt/src/rsa.c ****             /* check c+1 < n */
3088:../src/wolfcrypt/src/rsa.c ****             if (mp_cmp(c, &key->n) != MP_LT)
 4522                             		.loc 2 3088 27
 4523 00eb A8 6D                   		mov.L	4[r6], r5
 4524                             		.loc 2 3088 17
 4525 00ed EF 52                   		mov.L	r5, r2
 4526 00ef ED A1 01                		mov.L	4[r10], r1
 4527 00f2 05 00 00 00             		bsr	_sp_cmp
 4528 00f6 EF 15                   		mov.L	r1, r5
 4529                             		.loc 2 3088 16
 4530 00f8 75 05 FF                		cmp	#-1, r5
 4531 00fb 15                      		beq	.L288
3089:../src/wolfcrypt/src/rsa.c ****                 ret = RSA_OUT_OF_RANGE_E;
 4532                             		.loc 2 3089 21
 4533 00fc F8 AA 03 FF             		mov.L	#-253, [r10]
 4534                             	.L288:
3090:../src/wolfcrypt/src/rsa.c ****         }
3091:../src/wolfcrypt/src/rsa.c ****         mp_clear(c);
 4535                             		.loc 2 3091 9
 4536 0100 ED A1 01                		mov.L	4[r10], r1
 4537 0103 05 00 00 00             		bsr	_sp_clear
3092:../src/wolfcrypt/src/rsa.c **** 
3093:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
3094:../src/wolfcrypt/src/rsa.c ****         if (c != NULL)
 4538                             		.loc 2 3094 12
 4539 0107 ED A5 01                		mov.L	4[r10], r5
 4540 010a 61 05                   		cmp	#0, r5
 4541 010c 20 15                   		beq	.L289
 4542                             	.LBB43:
3095:../src/wolfcrypt/src/rsa.c ****             XFREE(c, key->heap, DYNAMIC_TYPE_RSA);
 4543                             		.loc 2 3095 13
 4544 010e ED A5 01                		mov.L	4[r10], r5
 4545 0111 E7 A5 02                		mov.L	r5, 8[r10]
 4546 0114 ED A5 02                		mov.L	8[r10], r5
 4547 0117 61 05                   		cmp	#0, r5
 4548 0119 10                      		beq	.L289
 4549                             		.loc 2 3095 13 is_stmt 0 discriminator 1
 4550 011a ED A1 02                		mov.L	8[r10], r1
 4551 011d 05 00 00 00             		bsr	_wolfSSL_Free
 4552                             	.L289:
 4553                             	.LBE43:
3096:../src/wolfcrypt/src/rsa.c **** #endif
3097:../src/wolfcrypt/src/rsa.c **** 
3098:../src/wolfcrypt/src/rsa.c ****         if (ret != 0) {
 4554                             		.loc 2 3098 12 is_stmt 1
 4555 0121 EC A5                   		mov.L	[r10], r5
 4556 0123 61 05                   		cmp	#0, r5
 4557 0125 15                      		beq	.L282
3099:../src/wolfcrypt/src/rsa.c ****             RESTORE_VECTOR_REGISTERS();
3100:../src/wolfcrypt/src/rsa.c ****             return ret;
 4558                             		.loc 2 3100 20
 4559 0126 EC A5                   		mov.L	[r10], r5
 4560 0128 2E 4D                   		bra	.L281
 4561                             	.L282:
 4562                             	.LBE42:
3101:../src/wolfcrypt/src/rsa.c ****         }
3102:../src/wolfcrypt/src/rsa.c ****     }
3103:../src/wolfcrypt/src/rsa.c **** #endif /* !WOLFSSL_RSA_VERIFY_ONLY && !TEST_UNPAD_CONSTANT_TIME && \
3104:../src/wolfcrypt/src/rsa.c ****         * !NO_RSA_BOUNDS_CHECK */
3105:../src/wolfcrypt/src/rsa.c **** 
3106:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA)
3107:../src/wolfcrypt/src/rsa.c ****     if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_RSA &&
3108:../src/wolfcrypt/src/rsa.c ****                                                         key->n.raw.len > 0) {
3109:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaFunctionAsync(in, inLen, out, outLen, type, key, rng);
3110:../src/wolfcrypt/src/rsa.c ****     }
3111:../src/wolfcrypt/src/rsa.c ****     else
3112:../src/wolfcrypt/src/rsa.c **** #endif
3113:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_NONBLOCK
3114:../src/wolfcrypt/src/rsa.c ****     if (key->nb) {
3115:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaFunctionNonBlock(in, inLen, out, outLen, type, key);
3116:../src/wolfcrypt/src/rsa.c ****     }
3117:../src/wolfcrypt/src/rsa.c ****     else
3118:../src/wolfcrypt/src/rsa.c **** #endif
3119:../src/wolfcrypt/src/rsa.c ****     {
3120:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
 4563                             		.loc 2 3120 15
 4564 012a A8 E5                   		mov.L	8[r6], r5
 4565 012c A0 85                   		mov.L	r5, 8[r0]
 4566 012e A8 6D                   		mov.L	4[r6], r5
 4567 0130 A0 0D                   		mov.L	r5, 4[r0]
 4568 0132 EC 65                   		mov.L	[r6], r5
 4569 0134 E3 05                   		mov.L	r5, [r0]
 4570 0136 ED A4 06                		mov.L	24[r10], r4
 4571 0139 ED A3 05                		mov.L	20[r10], r3
 4572 013c ED A2 04                		mov.L	16[r10], r2
 4573 013f ED A1 03                		mov.L	12[r10], r1
 4574 0142 05 00 00 00             		bsr	_wc_RsaFunctionSync
 4575 0146 E3 A1                   		mov.L	r1, [r10]
3121:../src/wolfcrypt/src/rsa.c ****     }
3122:../src/wolfcrypt/src/rsa.c **** 
3123:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3124:../src/wolfcrypt/src/rsa.c **** 
3125:../src/wolfcrypt/src/rsa.c ****     /* handle error */
3126:../src/wolfcrypt/src/rsa.c ****     if (ret < 0 && ret != WC_PENDING_E
 4576                             		.loc 2 3126 8
 4577 0148 EC A5                   		mov.L	[r10], r5
 4578 014a 61 05                   		cmp	#0, r5
 4579 014c 28 27                   		bge	.L290
 4580                             		.loc 2 3126 17 discriminator 1
 4581 014e EC A5                   		mov.L	[r10], r5
 4582 0150 75 05 94                		cmp	#-108, r5
 4583 0153 20 20                   		beq	.L290
3127:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_NONBLOCK
3128:../src/wolfcrypt/src/rsa.c ****         && ret != FP_WOULDBLOCK
3129:../src/wolfcrypt/src/rsa.c ****     #endif
3130:../src/wolfcrypt/src/rsa.c ****     ) {
3131:../src/wolfcrypt/src/rsa.c ****         if (ret == MP_EXPTMOD_E) {
 4584                             		.loc 2 3131 12
 4585 0155 EC A5                   		mov.L	[r10], r5
 4586 0157 75 05 90                		cmp	#-112, r5
 4587 015a 21 0C                   		bne	.L291
3132:../src/wolfcrypt/src/rsa.c ****             /* This can happen due to incorrectly set FP_MAX_BITS or missing XREALLOC */
3133:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("RSA_FUNCTION MP_EXPTMOD_E: memory/config problem");
 4588                             		.loc 2 3133 13
 4589 015c FB 12 9C 02 00 00       		mov.L	#.LC19, r1
 4590 0162 05 00 00 00             		bsr	_WOLFSSL_MSG
 4591                             	.L291:
3134:../src/wolfcrypt/src/rsa.c ****         }
3135:../src/wolfcrypt/src/rsa.c **** 
3136:../src/wolfcrypt/src/rsa.c ****         key->state = RSA_STATE_NONE;
 4592                             		.loc 2 3136 20
 4593 0166 A8 6D                   		mov.L	4[r6], r5
 4594 0168 FA 56 23 06 00          		mov.L	#0, 6284[r5]
3137:../src/wolfcrypt/src/rsa.c ****         wc_RsaCleanup(key);
 4595                             		.loc 2 3137 9
 4596 016d A8 69                   		mov.L	4[r6], r1
 4597 016f 05 00 00 00             		bsr	_wc_RsaCleanup
 4598                             	.L290:
3138:../src/wolfcrypt/src/rsa.c ****     }
3139:../src/wolfcrypt/src/rsa.c ****     return ret;
 4599                             		.loc 2 3139 12
 4600 0173 EC A5                   		mov.L	[r10], r5
 4601                             	.L281:
3140:../src/wolfcrypt/src/rsa.c **** #endif /* WOLF_CRYPTO_CB_ONLY_RSA */
3141:../src/wolfcrypt/src/rsa.c **** }
 4602                             		.loc 2 3141 1
 4603 0175 EF 51                   		mov.L	r5, r1
 4604 0177 71 00 38                		add	#56, r0
 4605 017a 7E B6                   		pop	r6
 4606 017c 7E BA                   		pop	r10
 4607 017e 02                      		rts
 4608                             	.LFE59:
 4610 017f 03                      		.section	.text.wc_RsaFunction,"ax",@progbits
 4611                             		.global	_wc_RsaFunction
 4613                             	_wc_RsaFunction:
 4614                             	.LFB60:
3142:../src/wolfcrypt/src/rsa.c **** 
3143:../src/wolfcrypt/src/rsa.c **** int wc_RsaFunction(const byte* in, word32 inLen, byte* out,
3144:../src/wolfcrypt/src/rsa.c ****                           word32* outLen, int type, RsaKey* key, WC_RNG* rng)
3145:../src/wolfcrypt/src/rsa.c **** {
 4615                             		.loc 2 3145 1
 4616 0000 7E AA                   		push.l	r10
 4617                             	.LCFI81:
 4618 0002 71 0A E4                		add	#-28, r0, r10
 4619                             	.LCFI82:
 4620 0005 71 A0 F0                		add	#-16, r10, r0
 4621                             	.LCFI83:
 4622 0008 75 45 24                		mov.L	#36, r5
 4623 000b 4B A5                   		add	r10, r5
 4624 000d E3 A1                   		mov.L	r1, [r10]
 4625 000f E7 A2 01                		mov.L	r2, 4[r10]
 4626 0012 E7 A3 02                		mov.L	r3, 8[r10]
 4627 0015 E7 A4 03                		mov.L	r4, 12[r10]
3146:../src/wolfcrypt/src/rsa.c ****     /* Always check for ciphertext of 0 or 1. (Should't for OAEP decrypt.) */
3147:../src/wolfcrypt/src/rsa.c ****     return wc_RsaFunction_ex(in, inLen, out, outLen, type, key, rng, 1);
 4628                             		.loc 2 3147 12
 4629 0018 3E 03 01                		mov.L	#1, 12[r0]
 4630 001b A8 D4                   		mov.L	8[r5], r4
 4631 001d A0 84                   		mov.L	r4, 8[r0]
 4632 001f A8 5C                   		mov.L	4[r5], r4
 4633 0021 A0 0C                   		mov.L	r4, 4[r0]
 4634 0023 EC 55                   		mov.L	[r5], r5
 4635 0025 E3 05                   		mov.L	r5, [r0]
 4636 0027 ED A4 03                		mov.L	12[r10], r4
 4637 002a ED A3 02                		mov.L	8[r10], r3
 4638 002d ED A2 01                		mov.L	4[r10], r2
 4639 0030 EC A1                   		mov.L	[r10], r1
 4640 0032 05 00 00 00             		bsr	_wc_RsaFunction_ex
 4641 0036 EF 15                   		mov.L	r1, r5
3148:../src/wolfcrypt/src/rsa.c **** }
 4642                             		.loc 2 3148 1
 4643 0038 EF 51                   		mov.L	r5, r1
 4644 003a 3F AA 0C                		rtsd	#48, r10-r10
 4645                             	.LFE60:
 4647                             		.section	.text.RsaPublicEncryptEx,"ax",@progbits
 4649                             	_RsaPublicEncryptEx:
 4650                             	.LFB61:
3149:../src/wolfcrypt/src/rsa.c **** 
3150:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
3151:../src/wolfcrypt/src/rsa.c **** /* Internal Wrappers */
3152:../src/wolfcrypt/src/rsa.c **** /* Gives the option of choosing padding type
3153:../src/wolfcrypt/src/rsa.c ****    in : input to be encrypted
3154:../src/wolfcrypt/src/rsa.c ****    inLen: length of input buffer
3155:../src/wolfcrypt/src/rsa.c ****    out: encrypted output
3156:../src/wolfcrypt/src/rsa.c ****    outLen: length of encrypted output buffer
3157:../src/wolfcrypt/src/rsa.c ****    key   : wolfSSL initialized RSA key struct
3158:../src/wolfcrypt/src/rsa.c ****    rng   : wolfSSL initialized random number struct
3159:../src/wolfcrypt/src/rsa.c ****    rsa_type  : type of RSA: RSA_PUBLIC_ENCRYPT, RSA_PUBLIC_DECRYPT,
3160:../src/wolfcrypt/src/rsa.c ****         RSA_PRIVATE_ENCRYPT or RSA_PRIVATE_DECRYPT
3161:../src/wolfcrypt/src/rsa.c ****    pad_value: RSA_BLOCK_TYPE_1 or RSA_BLOCK_TYPE_2
3162:../src/wolfcrypt/src/rsa.c ****    pad_type  : type of padding: WC_RSA_PKCSV15_PAD, WC_RSA_OAEP_PAD,
3163:../src/wolfcrypt/src/rsa.c ****         WC_RSA_NO_PAD or WC_RSA_PSS_PAD
3164:../src/wolfcrypt/src/rsa.c ****    hash  : type of hash algorithm to use found in wolfssl/wolfcrypt/hash.h
3165:../src/wolfcrypt/src/rsa.c ****    mgf   : type of mask generation function to use
3166:../src/wolfcrypt/src/rsa.c ****    label : optional label
3167:../src/wolfcrypt/src/rsa.c ****    labelSz : size of optional label buffer
3168:../src/wolfcrypt/src/rsa.c ****    saltLen : Length of salt used in PSS
3169:../src/wolfcrypt/src/rsa.c ****    rng : random number generator */
3170:../src/wolfcrypt/src/rsa.c **** static int RsaPublicEncryptEx(const byte* in, word32 inLen, byte* out,
3171:../src/wolfcrypt/src/rsa.c ****                             word32 outLen, RsaKey* key, int rsa_type,
3172:../src/wolfcrypt/src/rsa.c ****                             byte pad_value, int pad_type,
3173:../src/wolfcrypt/src/rsa.c ****                             enum wc_HashType hash, int mgf,
3174:../src/wolfcrypt/src/rsa.c ****                             byte* label, word32 labelSz, int saltLen,
3175:../src/wolfcrypt/src/rsa.c ****                             WC_RNG* rng)
3176:../src/wolfcrypt/src/rsa.c **** {
 4651                             		.loc 2 3176 1
 4652 0000 6E 6B                   		pushm	r6-r11
 4653                             	.LCFI84:
 4654 0002 71 0A BC                		add	#-68, r0, r10
 4655                             	.LCFI85:
 4656 0005 71 A0 D8                		add	#-40, r10, r0
 4657                             	.LCFI86:
 4658 0008 75 46 60                		mov.L	#0x60, r6
 4659 000b 4B A6                   		add	r10, r6
 4660 000d E7 A1 03                		mov.L	r1, 12[r10]
 4661 0010 E7 A2 04                		mov.L	r2, 16[r10]
 4662 0013 E7 A3 05                		mov.L	r3, 20[r10]
 4663 0016 E7 A4 06                		mov.L	r4, 24[r10]
3177:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 4664                             		.loc 2 3177 9
 4665 0019 F8 A6 00                		mov.L	#0, [r10]
3178:../src/wolfcrypt/src/rsa.c ****     int sz;
3179:../src/wolfcrypt/src/rsa.c ****     int state;
3180:../src/wolfcrypt/src/rsa.c **** 
3181:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || inLen == 0 || out == NULL || key == NULL) {
 4666                             		.loc 2 3181 8
 4667 001c ED A5 03                		mov.L	12[r10], r5
 4668 001f 61 05                   		cmp	#0, r5
 4669 0021 20 14                   		beq	.L295
 4670                             		.loc 2 3181 20 discriminator 1
 4671 0023 ED A5 04                		mov.L	16[r10], r5
 4672 0026 61 05                   		cmp	#0, r5
 4673 0028 20 0D                   		beq	.L295
 4674                             		.loc 2 3181 34 discriminator 2
 4675 002a ED A5 05                		mov.L	20[r10], r5
 4676 002d 61 05                   		cmp	#0, r5
 4677 002f 16                      		beq	.L295
 4678                             		.loc 2 3181 49 discriminator 3
 4679 0030 EC 65                   		mov.L	[r6], r5
 4680 0032 61 05                   		cmp	#0, r5
 4681 0034 18                      		bne	.L296
 4682                             		.balign 8,3,2
 4683                             	.L295:
3182:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 4684                             		.loc 2 3182 16
 4685 0035 FB 5A 53 FF             		mov.L	#-173, r5
 4686 0039 38 41 01                		bra	.L297
 4687                             	.L296:
3183:../src/wolfcrypt/src/rsa.c ****     }
3184:../src/wolfcrypt/src/rsa.c **** 
3185:../src/wolfcrypt/src/rsa.c ****     sz = wc_RsaEncryptSize(key);
 4688                             		.loc 2 3185 10
 4689 003c EC 61                   		mov.L	[r6], r1
 4690 003e 05 00 00 00             		bsr	_wc_RsaEncryptSize
 4691 0042 E7 A1 01                		mov.L	r1, 4[r10]
3186:../src/wolfcrypt/src/rsa.c ****     if (sz > (int)outLen) {
 4692                             		.loc 2 3186 14
 4693 0045 ED A5 06                		mov.L	24[r10], r5
 4694                             		.loc 2 3186 8
 4695 0048 ED A4 01                		mov.L	4[r10], r4
 4696 004b 47 54                   		cmp	r5, r4
 4697 004d 2B 09                   		ble	.L298
3187:../src/wolfcrypt/src/rsa.c ****         return RSA_BUFFER_E;
 4698                             		.loc 2 3187 16
 4699 004f FB 5A 7D FF             		mov.L	#-131, r5
 4700 0053 38 27 01                		bra	.L297
 4701                             	.L298:
3188:../src/wolfcrypt/src/rsa.c ****     }
3189:../src/wolfcrypt/src/rsa.c **** 
3190:../src/wolfcrypt/src/rsa.c ****     if (sz < RSA_MIN_PAD_SZ || sz > (int)RSA_MAX_SIZE/8) {
 4702                             		.loc 2 3190 8
 4703 0056 ED A5 01                		mov.L	4[r10], r5
 4704 0059 61 A5                   		cmp	#10, r5
 4705 005b 2B 0B                   		ble	.L299
 4706                             		.loc 2 3190 29 discriminator 1
 4707 005d ED A5 01                		mov.L	4[r10], r5
 4708 0060 76 05 00 02             		cmp	#0x200, r5
 4709 0064 2B 09                   		ble	.L300
 4710                             	.L299:
3191:../src/wolfcrypt/src/rsa.c ****         return WC_KEY_SIZE_E;
 4711                             		.loc 2 3191 16
 4712 0066 FB 5A 16 FF             		mov.L	#-234, r5
 4713 006a 38 10 01                		bra	.L297
 4714                             	.L300:
3192:../src/wolfcrypt/src/rsa.c ****     }
3193:../src/wolfcrypt/src/rsa.c **** 
3194:../src/wolfcrypt/src/rsa.c ****     if (inLen > (word32)(sz - RSA_MIN_PAD_SZ)) {
 4715                             		.loc 2 3194 29
 4716 006d ED A5 01                		mov.L	4[r10], r5
 4717 0070 60 B5                   		sub	#11, r5
 4718                             		.loc 2 3194 8
 4719 0072 ED A4 04                		mov.L	16[r10], r4
 4720 0075 47 54                   		cmp	r5, r4
 4721 0077 25 09                   		bleu	.L301
3195:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_NO_PADDING
3196:../src/wolfcrypt/src/rsa.c ****         /* In the case that no padding is used the input length can and should
3197:../src/wolfcrypt/src/rsa.c ****          * be the same size as the RSA key. */
3198:../src/wolfcrypt/src/rsa.c ****         if (pad_type != WC_RSA_NO_PAD)
3199:../src/wolfcrypt/src/rsa.c **** #endif
3200:../src/wolfcrypt/src/rsa.c ****         return RSA_BUFFER_E;
 4722                             		.loc 2 3200 16
 4723 0079 FB 5A 7D FF             		mov.L	#-131, r5
 4724 007d 38 FD 00                		bra	.L297
 4725                             	.L301:
3201:../src/wolfcrypt/src/rsa.c ****     }
3202:../src/wolfcrypt/src/rsa.c **** 
3203:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_BIND
3204:../src/wolfcrypt/src/rsa.c ****     state = key->state;
 4726                             		.loc 2 3204 11
 4727 0080 EC 65                   		mov.L	[r6], r5
 4728 0082 EE 55 23 06             		mov.L	6284[r5], r5
 4729 0086 E7 A5 02                		mov.L	r5, 8[r10]
3205:../src/wolfcrypt/src/rsa.c **** #else
3206:../src/wolfcrypt/src/rsa.c ****     /* Bind9 shares the EVP_PKEY struct across multiple threads so let's just
3207:../src/wolfcrypt/src/rsa.c ****      * force a restart on each RsaPublicEncryptEx call for it. */
3208:../src/wolfcrypt/src/rsa.c ****     state = RSA_STATE_NONE;
3209:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_ASYNC_CRYPT
3210:../src/wolfcrypt/src/rsa.c **** #error wolfSSL does not handle building bind support with async crypto
3211:../src/wolfcrypt/src/rsa.c **** #endif
3212:../src/wolfcrypt/src/rsa.c **** #endif
3213:../src/wolfcrypt/src/rsa.c ****     switch (state) {
 4730                             		.loc 2 3213 5
 4731 0089 ED A5 02                		mov.L	8[r10], r5
 4732 008c 61 25                   		cmp	#2, r5
 4733 008e 20 7C                   		beq	.L302
 4734 0090 ED A5 02                		mov.L	8[r10], r5
 4735 0093 61 25                   		cmp	#2, r5
 4736 0095 2A 0E                   		bgt	.L303
 4737 0097 ED A5 02                		mov.L	8[r10], r5
 4738 009a 61 05                   		cmp	#0, r5
 4739 009c 28 05 38 BA 00          		blt	.L304
 4740 00a1 2E 0D                   		bra	.L312
 4741                             	.L303:
 4742 00a3 ED A5 02                		mov.L	8[r10], r5
 4743 00a6 61 35                   		cmp	#3, r5
 4744 00a8 3A A7 00                		beq	.L306
 4745 00ab 38 AD 00                		bra	.L304
 4746                             	.L312:
3214:../src/wolfcrypt/src/rsa.c ****     case RSA_STATE_NONE:
3215:../src/wolfcrypt/src/rsa.c ****     case RSA_STATE_ENCRYPT_PAD:
3216:../src/wolfcrypt/src/rsa.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA) && \
3217:../src/wolfcrypt/src/rsa.c ****             defined(HAVE_CAVIUM)
3218:../src/wolfcrypt/src/rsa.c ****         if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_RSA &&
3219:../src/wolfcrypt/src/rsa.c ****                                  pad_type != WC_RSA_PSS_PAD && key->n.raw.buf) {
3220:../src/wolfcrypt/src/rsa.c ****             /* Async operations that include padding */
3221:../src/wolfcrypt/src/rsa.c ****             if (rsa_type == RSA_PUBLIC_ENCRYPT &&
3222:../src/wolfcrypt/src/rsa.c ****                                                 pad_value == RSA_BLOCK_TYPE_2) {
3223:../src/wolfcrypt/src/rsa.c ****                 key->state = RSA_STATE_ENCRYPT_RES;
3224:../src/wolfcrypt/src/rsa.c ****                 key->dataLen = key->n.raw.len;
3225:../src/wolfcrypt/src/rsa.c ****                 return NitroxRsaPublicEncrypt(in, inLen, out, outLen, key);
3226:../src/wolfcrypt/src/rsa.c ****             }
3227:../src/wolfcrypt/src/rsa.c ****             else if (rsa_type == RSA_PRIVATE_ENCRYPT &&
3228:../src/wolfcrypt/src/rsa.c ****                                                 pad_value == RSA_BLOCK_TYPE_1) {
3229:../src/wolfcrypt/src/rsa.c ****                 key->state = RSA_STATE_ENCRYPT_RES;
3230:../src/wolfcrypt/src/rsa.c ****                 key->dataLen = key->n.raw.len;
3231:../src/wolfcrypt/src/rsa.c ****                 return NitroxRsaSSL_Sign(in, inLen, out, outLen, key);
3232:../src/wolfcrypt/src/rsa.c ****             }
3233:../src/wolfcrypt/src/rsa.c ****         }
3234:../src/wolfcrypt/src/rsa.c ****     #elif defined(WOLFSSL_CRYPTOCELL)
3235:../src/wolfcrypt/src/rsa.c ****         if (rsa_type == RSA_PUBLIC_ENCRYPT &&
3236:../src/wolfcrypt/src/rsa.c ****                                             pad_value == RSA_BLOCK_TYPE_2) {
3237:../src/wolfcrypt/src/rsa.c **** 
3238:../src/wolfcrypt/src/rsa.c ****             return cc310_RsaPublicEncrypt(in, inLen, out, outLen, key);
3239:../src/wolfcrypt/src/rsa.c ****         }
3240:../src/wolfcrypt/src/rsa.c ****         else if (rsa_type == RSA_PRIVATE_ENCRYPT &&
3241:../src/wolfcrypt/src/rsa.c ****                                          pad_value == RSA_BLOCK_TYPE_1) {
3242:../src/wolfcrypt/src/rsa.c ****             return cc310_RsaSSL_Sign(in, inLen, out, outLen, key,
3243:../src/wolfcrypt/src/rsa.c ****                                   cc310_hashModeRSA(hash, 0));
3244:../src/wolfcrypt/src/rsa.c ****         }
3245:../src/wolfcrypt/src/rsa.c ****     #endif /* WOLFSSL_CRYPTOCELL */
3246:../src/wolfcrypt/src/rsa.c **** 
3247:../src/wolfcrypt/src/rsa.c ****         key->state = RSA_STATE_ENCRYPT_PAD;
 4747                             		.loc 2 3247 20
 4748 00ae EC 65                   		mov.L	[r6], r5
 4749 00b0 FA 56 23 06 01          		mov.L	#1, 6284[r5]
3248:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaPad_ex(in, inLen, out, sz, pad_value, rng, pad_type, hash,
 4750                             		.loc 2 3248 15
 4751 00b5 ED AB 01                		mov.L	4[r10], r11
3249:../src/wolfcrypt/src/rsa.c ****                            mgf, label, labelSz, saltLen, mp_count_bits(&key->n),
 4752                             		.loc 2 3249 72
 4753 00b8 EC 65                   		mov.L	[r6], r5
3248:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaPad_ex(in, inLen, out, sz, pad_value, rng, pad_type, hash,
 4754                             		.loc 2 3248 15
 4755 00ba EF 51                   		mov.L	r5, r1
 4756 00bc 05 00 00 00             		bsr	_sp_count_bits
 4757 00c0 EF 14                   		mov.L	r1, r4
 4758 00c2 EC 65                   		mov.L	[r6], r5
 4759 00c4 EE 55 20 06             		mov.L	6272[r5], r5
 4760 00c8 A2 0D                   		mov.L	r5, 36[r0]
 4761 00ca A2 04                   		mov.L	r4, 32[r0]
 4762 00cc AA 65                   		mov.L	32[r6], r5
 4763 00ce A1 8D                   		mov.L	r5, 28[r0]
 4764 00d0 A9 ED                   		mov.L	28[r6], r5
 4765 00d2 A1 85                   		mov.L	r5, 24[r0]
 4766 00d4 A9 E5                   		mov.L	24[r6], r5
 4767 00d6 A1 0D                   		mov.L	r5, 20[r0]
 4768 00d8 A9 6D                   		mov.L	20[r6], r5
 4769 00da A1 05                   		mov.L	r5, 16[r0]
 4770 00dc A9 65                   		mov.L	16[r6], r5
 4771 00de A0 8D                   		mov.L	r5, 12[r0]
 4772 00e0 A8 ED                   		mov.L	12[r6], r5
 4773 00e2 A0 85                   		mov.L	r5, 8[r0]
 4774 00e4 AA 6D                   		mov.L	36[r6], r5
 4775 00e6 A0 0D                   		mov.L	r5, 4[r0]
 4776 00e8 8A 65                   		mov.B	8[r6], r5
 4777 00ea C3 05                   		mov.B	r5, [r0]
 4778 00ec EF B4                   		mov.L	r11, r4
 4779 00ee ED A3 05                		mov.L	20[r10], r3
 4780 00f1 ED A2 04                		mov.L	16[r10], r2
 4781 00f4 ED A1 03                		mov.L	12[r10], r1
 4782 00f7 05 00 00 00             		bsr	_wc_RsaPad_ex
 4783 00fb E3 A1                   		mov.L	r1, [r10]
3250:../src/wolfcrypt/src/rsa.c ****                            key->heap);
3251:../src/wolfcrypt/src/rsa.c ****         if (ret < 0) {
 4784                             		.loc 2 3251 12
 4785 00fd EC A5                   		mov.L	[r10], r5
 4786 00ff 61 05                   		cmp	#0, r5
 4787 0101 29 5C                   		blt	.L313
3252:../src/wolfcrypt/src/rsa.c ****             break;
3253:../src/wolfcrypt/src/rsa.c ****         }
3254:../src/wolfcrypt/src/rsa.c **** 
3255:../src/wolfcrypt/src/rsa.c ****         key->state = RSA_STATE_ENCRYPT_EXPTMOD;
 4788                             		.loc 2 3255 20
 4789 0103 EC 65                   		mov.L	[r6], r5
 4790 0105 FA 56 23 06 02          		mov.L	#2, 6284[r5]
 4791                             	.L302:
3256:../src/wolfcrypt/src/rsa.c ****         FALL_THROUGH;
3257:../src/wolfcrypt/src/rsa.c **** 
3258:../src/wolfcrypt/src/rsa.c ****     case RSA_STATE_ENCRYPT_EXPTMOD:
3259:../src/wolfcrypt/src/rsa.c **** 
3260:../src/wolfcrypt/src/rsa.c ****         key->dataLen = outLen;
 4792                             		.loc 2 3260 22
 4793 010a EC 65                   		mov.L	[r6], r5
 4794 010c ED A4 06                		mov.L	24[r10], r4
 4795 010f EB 54 24 06             		mov.L	r4, 6288[r5]
3261:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaFunction(out, sz, out, &key->dataLen, rsa_type, key, rng);
 4796                             		.loc 2 3261 15
 4797 0113 ED A2 01                		mov.L	4[r10], r2
 4798 0116 EC 65                   		mov.L	[r6], r5
 4799 0118 72 55 90 18             		add	#0x1890, r5
 4800 011c AA 6C                   		mov.L	36[r6], r4
 4801 011e A0 84                   		mov.L	r4, 8[r0]
 4802 0120 EC 64                   		mov.L	[r6], r4
 4803 0122 A0 0C                   		mov.L	r4, 4[r0]
 4804 0124 A8 6C                   		mov.L	4[r6], r4
 4805 0126 E3 04                   		mov.L	r4, [r0]
 4806 0128 EF 54                   		mov.L	r5, r4
 4807 012a ED A3 05                		mov.L	20[r10], r3
 4808 012d ED A1 05                		mov.L	20[r10], r1
 4809 0130 05 00 00 00             		bsr	_wc_RsaFunction
 4810 0134 E3 A1                   		mov.L	r1, [r10]
3262:../src/wolfcrypt/src/rsa.c **** 
3263:../src/wolfcrypt/src/rsa.c ****         if (ret >= 0 || ret == WC_PENDING_E) {
 4811                             		.loc 2 3263 12
 4812 0136 EC A5                   		mov.L	[r10], r5
 4813 0138 61 05                   		cmp	#0, r5
 4814 013a 28 08                   		bge	.L309
 4815                             		.loc 2 3263 22 discriminator 1
 4816 013c EC A5                   		mov.L	[r10], r5
 4817 013e 75 05 94                		cmp	#-108, r5
 4818 0141 18                      		bne	.L310
 4819                             	.L309:
3264:../src/wolfcrypt/src/rsa.c ****             key->state = RSA_STATE_ENCRYPT_RES;
 4820                             		.loc 2 3264 24
 4821 0142 EC 65                   		mov.L	[r6], r5
 4822 0144 FA 56 23 06 03          		mov.L	#3, 6284[r5]
 4823                             	.L310:
3265:../src/wolfcrypt/src/rsa.c ****         }
3266:../src/wolfcrypt/src/rsa.c ****         if (ret < 0) {
 4824                             		.loc 2 3266 12
 4825 0149 EC A5                   		mov.L	[r10], r5
 4826 014b 61 05                   		cmp	#0, r5
 4827 014d 29 13                   		blt	.L314
 4828                             	.L306:
3267:../src/wolfcrypt/src/rsa.c ****             break;
3268:../src/wolfcrypt/src/rsa.c ****         }
3269:../src/wolfcrypt/src/rsa.c **** 
3270:../src/wolfcrypt/src/rsa.c ****         FALL_THROUGH;
3271:../src/wolfcrypt/src/rsa.c **** 
3272:../src/wolfcrypt/src/rsa.c ****     case RSA_STATE_ENCRYPT_RES:
3273:../src/wolfcrypt/src/rsa.c ****         ret = key->dataLen;
 4829                             		.loc 2 3273 18
 4830 014f EC 65                   		mov.L	[r6], r5
 4831 0151 EE 55 24 06             		mov.L	6288[r5], r5
 4832                             		.loc 2 3273 13
 4833 0155 E3 A5                   		mov.L	r5, [r10]
3274:../src/wolfcrypt/src/rsa.c ****         break;
 4834                             		.loc 2 3274 9
 4835 0157 0A                      		bra	.L308
 4836                             	.L304:
3275:../src/wolfcrypt/src/rsa.c **** 
3276:../src/wolfcrypt/src/rsa.c ****     default:
3277:../src/wolfcrypt/src/rsa.c ****         ret = BAD_STATE_E;
 4837                             		.loc 2 3277 13
 4838 0158 F8 AA 40 FF             		mov.L	#-192, [r10]
3278:../src/wolfcrypt/src/rsa.c ****         break;
 4839                             		.loc 2 3278 9
 4840 015c 0D                      		bra	.L308
 4841                             	.L313:
3252:../src/wolfcrypt/src/rsa.c ****         }
 4842                             		.loc 2 3252 13
 4843 015d 03                      		nop
 4844 015e 2E 03                   		bra	.L308
 4845                             	.L314:
3267:../src/wolfcrypt/src/rsa.c ****         }
 4846                             		.loc 2 3267 13
 4847 0160 03                      		nop
 4848                             		.balign 8,3,1
 4849                             	.L308:
3279:../src/wolfcrypt/src/rsa.c ****     }
3280:../src/wolfcrypt/src/rsa.c **** 
3281:../src/wolfcrypt/src/rsa.c ****     /* if async pending then return and skip done cleanup below */
3282:../src/wolfcrypt/src/rsa.c ****     if (ret == WC_PENDING_E
 4850                             		.loc 2 3282 8
 4851 0161 EC A5                   		mov.L	[r10], r5
 4852 0163 75 05 94                		cmp	#-108, r5
 4853 0166 1D                      		bne	.L311
3283:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_NONBLOCK
3284:../src/wolfcrypt/src/rsa.c ****         || ret == FP_WOULDBLOCK
3285:../src/wolfcrypt/src/rsa.c ****     #endif
3286:../src/wolfcrypt/src/rsa.c ****     ) {
3287:../src/wolfcrypt/src/rsa.c ****         return ret;
 4854                             		.loc 2 3287 16
 4855 0167 EC A5                   		mov.L	[r10], r5
 4856 0169 2E 11                   		bra	.L297
 4857                             	.L311:
3288:../src/wolfcrypt/src/rsa.c ****     }
3289:../src/wolfcrypt/src/rsa.c **** 
3290:../src/wolfcrypt/src/rsa.c ****     key->state = RSA_STATE_NONE;
 4858                             		.loc 2 3290 16
 4859 016b EC 65                   		mov.L	[r6], r5
 4860 016d FA 56 23 06 00          		mov.L	#0, 6284[r5]
3291:../src/wolfcrypt/src/rsa.c ****     wc_RsaCleanup(key);
 4861                             		.loc 2 3291 5
 4862 0172 EC 61                   		mov.L	[r6], r1
 4863 0174 05 00 00 00             		bsr	_wc_RsaCleanup
3292:../src/wolfcrypt/src/rsa.c **** 
3293:../src/wolfcrypt/src/rsa.c ****     return ret;
 4864                             		.loc 2 3293 12
 4865 0178 EC A5                   		mov.L	[r10], r5
 4866                             		.balign 8,3,1
 4867                             	.L297:
3294:../src/wolfcrypt/src/rsa.c **** }
 4868                             		.loc 2 3294 1
 4869 017a EF 51                   		mov.L	r5, r1
 4870 017c 3F 6B 21                		rtsd	#132, r6-r11
 4871                             	.LFE61:
 4873 017f 03                      		.section	.text.RsaPrivateDecryptEx,"ax",@progbits
 4875                             	_RsaPrivateDecryptEx:
 4876                             	.LFB62:
3295:../src/wolfcrypt/src/rsa.c **** 
3296:../src/wolfcrypt/src/rsa.c **** #endif
3297:../src/wolfcrypt/src/rsa.c **** 
3298:../src/wolfcrypt/src/rsa.c **** /* Gives the option of choosing padding type
3299:../src/wolfcrypt/src/rsa.c ****    in : input to be decrypted
3300:../src/wolfcrypt/src/rsa.c ****    inLen: length of input buffer
3301:../src/wolfcrypt/src/rsa.c ****    out:  decrypted message
3302:../src/wolfcrypt/src/rsa.c ****    outLen: length of decrypted message in bytes
3303:../src/wolfcrypt/src/rsa.c ****    outPtr: optional inline output pointer (if provided doing inline)
3304:../src/wolfcrypt/src/rsa.c ****    key   : wolfSSL initialized RSA key struct
3305:../src/wolfcrypt/src/rsa.c ****    rsa_type  : type of RSA: RSA_PUBLIC_ENCRYPT, RSA_PUBLIC_DECRYPT,
3306:../src/wolfcrypt/src/rsa.c ****         RSA_PRIVATE_ENCRYPT or RSA_PRIVATE_DECRYPT
3307:../src/wolfcrypt/src/rsa.c ****    pad_value: RSA_BLOCK_TYPE_1 or RSA_BLOCK_TYPE_2
3308:../src/wolfcrypt/src/rsa.c ****    pad_type  : type of padding: WC_RSA_PKCSV15_PAD, WC_RSA_OAEP_PAD,
3309:../src/wolfcrypt/src/rsa.c ****         WC_RSA_NO_PAD, WC_RSA_PSS_PAD
3310:../src/wolfcrypt/src/rsa.c ****    hash  : type of hash algorithm to use found in wolfssl/wolfcrypt/hash.h
3311:../src/wolfcrypt/src/rsa.c ****    mgf   : type of mask generation function to use
3312:../src/wolfcrypt/src/rsa.c ****    label : optional label
3313:../src/wolfcrypt/src/rsa.c ****    labelSz : size of optional label buffer
3314:../src/wolfcrypt/src/rsa.c ****    saltLen : Length of salt used in PSS
3315:../src/wolfcrypt/src/rsa.c ****    rng : random number generator */
3316:../src/wolfcrypt/src/rsa.c **** static int RsaPrivateDecryptEx(const byte* in, word32 inLen, byte* out,
3317:../src/wolfcrypt/src/rsa.c ****                             word32 outLen, byte** outPtr, RsaKey* key,
3318:../src/wolfcrypt/src/rsa.c ****                             int rsa_type, byte pad_value, int pad_type,
3319:../src/wolfcrypt/src/rsa.c ****                             enum wc_HashType hash, int mgf,
3320:../src/wolfcrypt/src/rsa.c ****                             byte* label, word32 labelSz, int saltLen,
3321:../src/wolfcrypt/src/rsa.c ****                             WC_RNG* rng)
3322:../src/wolfcrypt/src/rsa.c **** {
 4877                             		.loc 2 3322 1
 4878 0000 6E 6C                   		pushm	r6-r12
 4879                             	.LCFI87:
 4880 0002 71 0A AC                		add	#-84, r0, r10
 4881                             	.LCFI88:
 4882 0005 71 A0 E0                		add	#-32, r10, r0
 4883                             	.LCFI89:
 4884 0008 75 46 74                		mov.L	#0x74, r6
 4885 000b 4B A6                   		add	r10, r6
 4886 000d E7 A1 06                		mov.L	r1, 24[r10]
 4887 0010 E7 A2 07                		mov.L	r2, 28[r10]
 4888 0013 E7 A3 08                		mov.L	r3, 32[r10]
 4889 0016 E7 A4 09                		mov.L	r4, 36[r10]
3323:../src/wolfcrypt/src/rsa.c ****     int ret = RSA_WRONG_TYPE_E;
 4890                             		.loc 2 3323 9
 4891 0019 F8 AA 7E FF             		mov.L	#-130, [r10]
3324:../src/wolfcrypt/src/rsa.c ****     byte* pad = NULL;
 4892                             		.loc 2 3324 11
 4893 001d F9 A6 05 00             		mov.L	#0, 20[r10]
3325:../src/wolfcrypt/src/rsa.c **** 
3326:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || inLen == 0 || out == NULL || key == NULL) {
 4894                             		.loc 2 3326 8
 4895 0021 ED A5 06                		mov.L	24[r10], r5
 4896 0024 61 05                   		cmp	#0, r5
 4897 0026 20 14                   		beq	.L316
 4898                             		.loc 2 3326 20 discriminator 1
 4899 0028 ED A5 07                		mov.L	28[r10], r5
 4900 002b 61 05                   		cmp	#0, r5
 4901 002d 20 0D                   		beq	.L316
 4902                             		.loc 2 3326 34 discriminator 2
 4903 002f ED A5 08                		mov.L	32[r10], r5
 4904 0032 61 05                   		cmp	#0, r5
 4905 0034 16                      		beq	.L316
 4906                             		.loc 2 3326 49 discriminator 3
 4907 0035 A8 6D                   		mov.L	4[r6], r5
 4908 0037 61 05                   		cmp	#0, r5
 4909 0039 18                      		bne	.L317
 4910                             		.balign 8,3,2
 4911                             	.L316:
3327:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 4912                             		.loc 2 3327 16
 4913 003a FB 5A 53 FF             		mov.L	#-173, r5
 4914 003e 38 57 02                		bra	.L341
 4915                             	.L317:
3328:../src/wolfcrypt/src/rsa.c ****     }
3329:../src/wolfcrypt/src/rsa.c **** 
3330:../src/wolfcrypt/src/rsa.c ****     switch (key->state) {
 4916                             		.loc 2 3330 16
 4917 0041 A8 6D                   		mov.L	4[r6], r5
 4918 0043 EE 55 23 06             		mov.L	6284[r5], r5
 4919                             		.loc 2 3330 5
 4920 0047 61 45                   		cmp	#4, r5
 4921 0049 3A 8A 00                		beq	.L319
 4922 004c 61 45                   		cmp	#4, r5
 4923 004e 2A 09                   		bgt	.L320
 4924 0050 61 05                   		cmp	#0, r5
 4925 0052 20 12                   		beq	.L321
 4926 0054 38 1F 02                		bra	.L322
 4927                             	.L320:
 4928 0057 61 55                   		cmp	#5, r5
 4929 0059 3A C8 00                		beq	.L323
 4930 005c 61 65                   		cmp	#6, r5
 4931 005e 3A 1A 02                		beq	.L342
 4932 0061 38 12 02                		bra	.L322
 4933                             	.L321:
3331:../src/wolfcrypt/src/rsa.c ****     case RSA_STATE_NONE:
3332:../src/wolfcrypt/src/rsa.c ****         key->dataLen = inLen;
 4934                             		.loc 2 3332 22
 4935 0064 A8 6D                   		mov.L	4[r6], r5
 4936 0066 ED A4 07                		mov.L	28[r10], r4
 4937 0069 EB 54 24 06             		mov.L	r4, 6288[r5]
3333:../src/wolfcrypt/src/rsa.c **** 
3334:../src/wolfcrypt/src/rsa.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA) && \
3335:../src/wolfcrypt/src/rsa.c ****             defined(HAVE_CAVIUM)
3336:../src/wolfcrypt/src/rsa.c ****         /* Async operations that include padding */
3337:../src/wolfcrypt/src/rsa.c ****         if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_RSA &&
3338:../src/wolfcrypt/src/rsa.c ****                                                    pad_type != WC_RSA_PSS_PAD) {
3339:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
3340:../src/wolfcrypt/src/rsa.c ****             if (rsa_type == RSA_PRIVATE_DECRYPT &&
3341:../src/wolfcrypt/src/rsa.c ****                                                 pad_value == RSA_BLOCK_TYPE_2) {
3342:../src/wolfcrypt/src/rsa.c ****                 key->state = RSA_STATE_DECRYPT_RES;
3343:../src/wolfcrypt/src/rsa.c ****                 key->data = NULL;
3344:../src/wolfcrypt/src/rsa.c ****                 return NitroxRsaPrivateDecrypt(in, inLen, out, &key->dataLen,
3345:../src/wolfcrypt/src/rsa.c ****                                                key);
3346:../src/wolfcrypt/src/rsa.c **** #endif
3347:../src/wolfcrypt/src/rsa.c ****             }
3348:../src/wolfcrypt/src/rsa.c ****             else if (rsa_type == RSA_PUBLIC_DECRYPT &&
3349:../src/wolfcrypt/src/rsa.c ****                                                 pad_value == RSA_BLOCK_TYPE_1) {
3350:../src/wolfcrypt/src/rsa.c ****                 key->state = RSA_STATE_DECRYPT_RES;
3351:../src/wolfcrypt/src/rsa.c ****                 key->data = NULL;
3352:../src/wolfcrypt/src/rsa.c ****                 return NitroxRsaSSL_Verify(in, inLen, out, &key->dataLen, key);
3353:../src/wolfcrypt/src/rsa.c ****             }
3354:../src/wolfcrypt/src/rsa.c ****         }
3355:../src/wolfcrypt/src/rsa.c ****     #elif defined(WOLFSSL_CRYPTOCELL)
3356:../src/wolfcrypt/src/rsa.c ****         if (rsa_type == RSA_PRIVATE_DECRYPT &&
3357:../src/wolfcrypt/src/rsa.c ****                                             pad_value == RSA_BLOCK_TYPE_2) {
3358:../src/wolfcrypt/src/rsa.c ****             ret = cc310_RsaPublicDecrypt(in, inLen, out, outLen, key);
3359:../src/wolfcrypt/src/rsa.c ****             if (outPtr != NULL)
3360:../src/wolfcrypt/src/rsa.c ****                 *outPtr = out; /* for inline */
3361:../src/wolfcrypt/src/rsa.c ****             return ret;
3362:../src/wolfcrypt/src/rsa.c ****         }
3363:../src/wolfcrypt/src/rsa.c ****         else if (rsa_type == RSA_PUBLIC_DECRYPT &&
3364:../src/wolfcrypt/src/rsa.c ****                                             pad_value == RSA_BLOCK_TYPE_1) {
3365:../src/wolfcrypt/src/rsa.c ****             return cc310_RsaSSL_Verify(in, inLen, out, key,
3366:../src/wolfcrypt/src/rsa.c ****                                        cc310_hashModeRSA(hash, 0));
3367:../src/wolfcrypt/src/rsa.c ****         }
3368:../src/wolfcrypt/src/rsa.c ****     #endif /* WOLFSSL_CRYPTOCELL */
3369:../src/wolfcrypt/src/rsa.c **** 
3370:../src/wolfcrypt/src/rsa.c **** 
3371:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
3372:../src/wolfcrypt/src/rsa.c ****     !defined(WOLFSSL_NO_MALLOC)
3373:../src/wolfcrypt/src/rsa.c ****         /* verify the tmp ptr is NULL, otherwise indicates bad state */
3374:../src/wolfcrypt/src/rsa.c ****         if (key->data != NULL) {
 4938                             		.loc 2 3374 16
 4939 006d A8 6D                   		mov.L	4[r6], r5
 4940 006f EE 55 21 06             		mov.L	6276[r5], r5
 4941                             		.loc 2 3374 12
 4942 0073 61 05                   		cmp	#0, r5
 4943 0075 10                      		beq	.L325
3375:../src/wolfcrypt/src/rsa.c ****             ret = BAD_STATE_E;
 4944                             		.loc 2 3375 17
 4945 0076 F8 AA 40 FF             		mov.L	#-192, [r10]
3376:../src/wolfcrypt/src/rsa.c ****             break;
 4946                             		.loc 2 3376 13
 4947 007a 38 02 02                		bra	.L326
 4948                             	.L325:
3377:../src/wolfcrypt/src/rsa.c ****         }
3378:../src/wolfcrypt/src/rsa.c **** 
3379:../src/wolfcrypt/src/rsa.c ****         /* if not doing this inline then allocate a buffer for it */
3380:../src/wolfcrypt/src/rsa.c ****         if (outPtr == NULL) {
 4949                             		.loc 2 3380 12
 4950 007d EC 65                   		mov.L	[r6], r5
 4951 007f 61 05                   		cmp	#0, r5
 4952 0081 21 3B                   		bne	.L327
3381:../src/wolfcrypt/src/rsa.c ****             key->data = (byte*)XMALLOC(inLen, key->heap,
 4953                             		.loc 2 3381 32
 4954 0083 ED A1 07                		mov.L	28[r10], r1
 4955 0086 05 00 00 00             		bsr	_wolfSSL_Malloc
 4956 008a EF 14                   		mov.L	r1, r4
 4957                             		.loc 2 3381 23
 4958 008c A8 6D                   		mov.L	4[r6], r5
 4959 008e EB 54 21 06             		mov.L	r4, 6276[r5]
3382:../src/wolfcrypt/src/rsa.c ****                                                       DYNAMIC_TYPE_WOLF_BIGINT);
3383:../src/wolfcrypt/src/rsa.c ****             key->dataIsAlloc = 1;
 4960                             		.loc 2 3383 30
 4961 0092 A8 6D                   		mov.L	4[r6], r5
 4962 0094 FA 54 98 18 01          		mov.B	#1, 6296[r5]
3384:../src/wolfcrypt/src/rsa.c ****             if (key->data == NULL) {
 4963                             		.loc 2 3384 20
 4964 0099 A8 6D                   		mov.L	4[r6], r5
 4965 009b EE 55 21 06             		mov.L	6276[r5], r5
 4966                             		.loc 2 3384 16
 4967 009f 61 05                   		cmp	#0, r5
 4968 00a1 1F                      		bne	.L328
3385:../src/wolfcrypt/src/rsa.c ****                 ret = MEMORY_E;
 4969                             		.loc 2 3385 21
 4970 00a2 F8 A6 83                		mov.L	#-125, [r10]
3386:../src/wolfcrypt/src/rsa.c ****                 break;
 4971                             		.loc 2 3386 17
 4972 00a5 38 D7 01                		bra	.L326
 4973                             	.L328:
3387:../src/wolfcrypt/src/rsa.c ****             }
3388:../src/wolfcrypt/src/rsa.c ****             XMEMCPY(key->data, in, inLen);
 4974                             		.loc 2 3388 13
 4975 00a8 A8 6D                   		mov.L	4[r6], r5
 4976 00aa EE 55 21 06             		mov.L	6276[r5], r5
 4977 00ae ED A3 07                		mov.L	28[r10], r3
 4978 00b1 ED A2 06                		mov.L	24[r10], r2
 4979 00b4 EF 51                   		mov.L	r5, r1
 4980 00b6 05 00 00 00             		bsr	_memcpy
 4981 00ba 2E 12                   		bra	.L329
 4982                             	.L327:
3389:../src/wolfcrypt/src/rsa.c ****         }
3390:../src/wolfcrypt/src/rsa.c ****         else {
3391:../src/wolfcrypt/src/rsa.c ****             key->dataIsAlloc = 0;
 4983                             		.loc 2 3391 30
 4984 00bc A8 6D                   		mov.L	4[r6], r5
 4985 00be FA 54 98 18 00          		mov.B	#0, 6296[r5]
3392:../src/wolfcrypt/src/rsa.c ****             key->data = out;
 4986                             		.loc 2 3392 23
 4987 00c3 A8 6D                   		mov.L	4[r6], r5
 4988 00c5 ED A4 08                		mov.L	32[r10], r4
 4989 00c8 EB 54 21 06             		mov.L	r4, 6276[r5]
 4990                             	.L329:
3393:../src/wolfcrypt/src/rsa.c ****         }
3394:../src/wolfcrypt/src/rsa.c **** #endif
3395:../src/wolfcrypt/src/rsa.c **** 
3396:../src/wolfcrypt/src/rsa.c ****         key->state = RSA_STATE_DECRYPT_EXPTMOD;
 4991                             		.loc 2 3396 20
 4992 00cc A8 6D                   		mov.L	4[r6], r5
 4993 00ce FA 56 23 06 04          		mov.L	#4, 6284[r5]
 4994                             	.L319:
3397:../src/wolfcrypt/src/rsa.c ****         FALL_THROUGH;
3398:../src/wolfcrypt/src/rsa.c **** 
3399:../src/wolfcrypt/src/rsa.c ****     case RSA_STATE_DECRYPT_EXPTMOD:
3400:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
3401:../src/wolfcrypt/src/rsa.c ****     !defined(WOLFSSL_NO_MALLOC)
3402:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaFunction_ex(key->data, inLen, key->data, &key->dataLen,
 4995                             		.loc 2 3402 36
 4996 00d3 A8 6D                   		mov.L	4[r6], r5
 4997 00d5 EE 51 21 06             		mov.L	6276[r5], r1
 4998                             		.loc 2 3402 15
 4999 00d9 A8 6D                   		mov.L	4[r6], r5
 5000 00db EE 53 21 06             		mov.L	6276[r5], r3
 5001 00df A8 6D                   		mov.L	4[r6], r5
 5002 00e1 72 54 90 18             		add	#0x1890, r5, r4
 5003 00e5 A9 65                   		mov.L	16[r6], r5
 5004 00e7 61 15                   		cmp	#1, r5
 5005 00e9 FC DB 51                		scne.L	r5
 5006 00ec 5B 55                   		movu.B	r5, r5
 5007 00ee A0 8D                   		mov.L	r5, 12[r0]
 5008 00f0 AA E5                   		mov.L	40[r6], r5
 5009 00f2 A0 85                   		mov.L	r5, 8[r0]
 5010 00f4 A8 6D                   		mov.L	4[r6], r5
 5011 00f6 A0 0D                   		mov.L	r5, 4[r0]
 5012 00f8 A8 E5                   		mov.L	8[r6], r5
 5013 00fa E3 05                   		mov.L	r5, [r0]
 5014 00fc ED A2 07                		mov.L	28[r10], r2
 5015 00ff 05 00 00 00             		bsr	_wc_RsaFunction_ex
 5016 0103 E3 A1                   		mov.L	r1, [r10]
3403:../src/wolfcrypt/src/rsa.c ****                                                    rsa_type, key, rng,
3404:../src/wolfcrypt/src/rsa.c ****                                                    pad_type != WC_RSA_OAEP_PAD);
3405:../src/wolfcrypt/src/rsa.c **** #else
3406:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaFunction_ex(in, inLen, out, &key->dataLen, rsa_type, key,
3407:../src/wolfcrypt/src/rsa.c ****                                               rng, pad_type != WC_RSA_OAEP_PAD);
3408:../src/wolfcrypt/src/rsa.c **** #endif
3409:../src/wolfcrypt/src/rsa.c **** 
3410:../src/wolfcrypt/src/rsa.c ****         if (ret >= 0 || ret == WC_PENDING_E) {
 5017                             		.loc 2 3410 12
 5018 0105 EC A5                   		mov.L	[r10], r5
 5019 0107 61 05                   		cmp	#0, r5
 5020 0109 28 08                   		bge	.L330
 5021                             		.loc 2 3410 22 discriminator 1
 5022 010b EC A5                   		mov.L	[r10], r5
 5023 010d 75 05 94                		cmp	#-108, r5
 5024 0110 18                      		bne	.L331
 5025                             	.L330:
3411:../src/wolfcrypt/src/rsa.c ****             key->state = RSA_STATE_DECRYPT_UNPAD;
 5026                             		.loc 2 3411 24
 5027 0111 A8 6D                   		mov.L	4[r6], r5
 5028 0113 FA 56 23 06 05          		mov.L	#5, 6284[r5]
 5029                             	.L331:
3412:../src/wolfcrypt/src/rsa.c ****         }
3413:../src/wolfcrypt/src/rsa.c ****         if (ret < 0) {
 5030                             		.loc 2 3413 12
 5031 0118 EC A5                   		mov.L	[r10], r5
 5032 011a 61 05                   		cmp	#0, r5
 5033 011c 28 05 38 5D 01          		blt	.L343
 5034                             	.L323:
3414:../src/wolfcrypt/src/rsa.c ****             break;
3415:../src/wolfcrypt/src/rsa.c ****         }
3416:../src/wolfcrypt/src/rsa.c **** 
3417:../src/wolfcrypt/src/rsa.c ****         FALL_THROUGH;
3418:../src/wolfcrypt/src/rsa.c **** 
3419:../src/wolfcrypt/src/rsa.c ****     case RSA_STATE_DECRYPT_UNPAD:
3420:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
3421:../src/wolfcrypt/src/rsa.c ****     !defined(WOLFSSL_NO_MALLOC)
3422:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaUnPad_ex(key->data, key->dataLen, &pad, pad_value, pad_type,
 5035                             		.loc 2 3422 15
 5036 0121 A8 6D                   		mov.L	4[r6], r5
 5037 0123 EE 5B 21 06             		mov.L	6276[r5], r11
 5038 0127 A8 6D                   		mov.L	4[r6], r5
 5039 0129 EE 5C 24 06             		mov.L	6288[r5], r12
3423:../src/wolfcrypt/src/rsa.c ****                              hash, mgf, label, labelSz, saltLen,
3424:../src/wolfcrypt/src/rsa.c ****                              mp_count_bits(&key->n), key->heap);
 5040                             		.loc 2 3424 44
 5041 012d A8 6D                   		mov.L	4[r6], r5
3422:../src/wolfcrypt/src/rsa.c ****                              hash, mgf, label, labelSz, saltLen,
 5042                             		.loc 2 3422 15
 5043 012f EF 51                   		mov.L	r5, r1
 5044 0131 05 00 00 00             		bsr	_sp_count_bits
 5045 0135 EF 14                   		mov.L	r1, r4
 5046 0137 A8 6D                   		mov.L	4[r6], r5
 5047 0139 EE 53 20 06             		mov.L	6272[r5], r3
 5048 013d 71 A5 14                		add	#20, r10, r5
 5049 0140 A1 8B                   		mov.L	r3, 28[r0]
 5050 0142 A1 84                   		mov.L	r4, 24[r0]
 5051 0144 AA 6C                   		mov.L	36[r6], r4
 5052 0146 A1 0C                   		mov.L	r4, 20[r0]
 5053 0148 AA 64                   		mov.L	32[r6], r4
 5054 014a A1 04                   		mov.L	r4, 16[r0]
 5055 014c A9 EC                   		mov.L	28[r6], r4
 5056 014e A0 8C                   		mov.L	r4, 12[r0]
 5057 0150 A9 E4                   		mov.L	24[r6], r4
 5058 0152 A0 84                   		mov.L	r4, 8[r0]
 5059 0154 A9 6C                   		mov.L	20[r6], r4
 5060 0156 A0 0C                   		mov.L	r4, 4[r0]
 5061 0158 A9 64                   		mov.L	16[r6], r4
 5062 015a E3 04                   		mov.L	r4, [r0]
 5063 015c 8B 64                   		mov.B	12[r6], r4
 5064 015e EF 53                   		mov.L	r5, r3
 5065 0160 EF C2                   		mov.L	r12, r2
 5066 0162 EF B1                   		mov.L	r11, r1
 5067 0164 05 00 00 00             		bsr	_wc_RsaUnPad_ex
 5068 0168 E3 A1                   		mov.L	r1, [r10]
3425:../src/wolfcrypt/src/rsa.c **** #else
3426:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaUnPad_ex(out, key->dataLen, &pad, pad_value, pad_type, hash,
3427:../src/wolfcrypt/src/rsa.c ****                              mgf, label, labelSz, saltLen,
3428:../src/wolfcrypt/src/rsa.c ****                              mp_count_bits(&key->n), key->heap);
3429:../src/wolfcrypt/src/rsa.c **** #endif
3430:../src/wolfcrypt/src/rsa.c ****         if (rsa_type == RSA_PUBLIC_DECRYPT && ret > (int)outLen)
 5069                             		.loc 2 3430 12
 5070 016a A8 E5                   		mov.L	8[r6], r5
 5071 016c 61 15                   		cmp	#1, r5
 5072 016e 21 12                   		bne	.L332
 5073                             		.loc 2 3430 53 discriminator 1
 5074 0170 ED A5 09                		mov.L	36[r10], r5
 5075                             		.loc 2 3430 44 discriminator 1
 5076 0173 EC A4                   		mov.L	[r10], r4
 5077 0175 47 54                   		cmp	r5, r4
 5078 0177 2B 09                   		ble	.L332
3431:../src/wolfcrypt/src/rsa.c ****             ret = RSA_BUFFER_E;
 5079                             		.loc 2 3431 17
 5080 0179 F8 AA 7D FF             		mov.L	#-131, [r10]
 5081 017d 38 EE 00                		bra	.L333
 5082                             	.L332:
3432:../src/wolfcrypt/src/rsa.c ****         else if (ret >= 0 && pad != NULL) {
 5083                             		.loc 2 3432 17
 5084 0180 EC A5                   		mov.L	[r10], r5
 5085 0182 61 05                   		cmp	#0, r5
 5086 0184 28 05 38 E5 00          		blt	.L333
 5087                             		.loc 2 3432 34 discriminator 1
 5088 0189 ED A5 05                		mov.L	20[r10], r5
 5089                             		.loc 2 3432 27 discriminator 1
 5090 018c 61 05                   		cmp	#0, r5
 5091 018e 3A DD 00                		beq	.L333
 5092                             	.LBB44:
3433:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
3434:../src/wolfcrypt/src/rsa.c ****     !defined(WOLFSSL_NO_MALLOC)
3435:../src/wolfcrypt/src/rsa.c ****             signed char c;
3436:../src/wolfcrypt/src/rsa.c **** #endif
3437:../src/wolfcrypt/src/rsa.c **** 
3438:../src/wolfcrypt/src/rsa.c ****             /* only copy output if not inline */
3439:../src/wolfcrypt/src/rsa.c ****             if (outPtr == NULL) {
 5093                             		.loc 2 3439 16
 5094 0191 EC 65                   		mov.L	[r6], r5
 5095 0193 61 05                   		cmp	#0, r5
 5096 0195 3B 9C 00                		bne	.L334
3440:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
3441:../src/wolfcrypt/src/rsa.c ****     !defined(WOLFSSL_NO_MALLOC)
3442:../src/wolfcrypt/src/rsa.c ****                 if (rsa_type == RSA_PRIVATE_DECRYPT) {
 5097                             		.loc 2 3442 20
 5098 0198 A8 E5                   		mov.L	8[r6], r5
 5099 019a 61 35                   		cmp	#3, r5
 5100 019c 3B 84 00                		bne	.L335
 5101                             	.LBB45:
3443:../src/wolfcrypt/src/rsa.c ****                     word32 i = 0;
 5102                             		.loc 2 3443 28
 5103 019f F9 A6 01 00             		mov.L	#0, 4[r10]
3444:../src/wolfcrypt/src/rsa.c ****                     word32 j;
3445:../src/wolfcrypt/src/rsa.c ****                     int start = (int)((size_t)pad - (size_t)key->data);
 5104                             		.loc 2 3445 39
 5105 01a3 ED A5 05                		mov.L	20[r10], r5
 5106 01a6 EF 54                   		mov.L	r5, r4
 5107                             		.loc 2 3445 64
 5108 01a8 A8 6D                   		mov.L	4[r6], r5
 5109 01aa EE 55 21 06             		mov.L	6276[r5], r5
 5110                             		.loc 2 3445 51
 5111 01ae FF 05 54                		sub	r5, r4, r5
 5112                             		.loc 2 3445 25
 5113 01b1 E7 A5 03                		mov.L	r5, 12[r10]
3446:../src/wolfcrypt/src/rsa.c **** 
3447:../src/wolfcrypt/src/rsa.c ****                     for (j = 0; j < key->dataLen; j++) {
 5114                             		.loc 2 3447 28
 5115 01b4 F9 A6 02 00             		mov.L	#0, 8[r10]
 5116                             		.loc 2 3447 21
 5117 01b8 2E 59                   		bra	.L336
 5118                             	.L337:
3448:../src/wolfcrypt/src/rsa.c ****                         out[i] = key->data[j];
 5119                             		.loc 2 3448 37 discriminator 3
 5120 01ba A8 6D                   		mov.L	4[r6], r5
 5121 01bc EE 55 21 06             		mov.L	6276[r5], r5
 5122                             		.loc 2 3448 43 discriminator 3
 5123 01c0 EF 54                   		mov.L	r5, r4
 5124 01c2 06 89 A4 02             		add	8[r10].L, r4
 5125                             		.loc 2 3448 28 discriminator 3
 5126 01c6 ED A5 08                		mov.L	32[r10], r5
 5127 01c9 06 89 A5 01             		add	4[r10].L, r5
 5128                             		.loc 2 3448 43 discriminator 3
 5129 01cd CC 44                   		mov.B	[r4], r4
 5130                             		.loc 2 3448 32 discriminator 3
 5131 01cf C3 54                   		mov.B	r4, [r5]
3449:../src/wolfcrypt/src/rsa.c ****                         c  = ctMaskGTE(j, start);
 5132                             		.loc 2 3449 30 discriminator 3
 5133 01d1 ED A5 02                		mov.L	8[r10], r5
 5134 01d4 ED A2 03                		mov.L	12[r10], r2
 5135 01d7 EF 51                   		mov.L	r5, r1
 5136 01d9 05 00 00 00             		bsr	_ctMaskGTE
 5137 01dd EF 15                   		mov.L	r1, r5
 5138                             		.loc 2 3449 28 discriminator 3
 5139 01df C7 A5 10                		mov.B	r5, 16[r10]
3450:../src/wolfcrypt/src/rsa.c ****                         c &= ctMaskLT(i, outLen);
 5140                             		.loc 2 3450 30 discriminator 3
 5141 01e2 ED A5 01                		mov.L	4[r10], r5
 5142 01e5 ED A4 09                		mov.L	36[r10], r4
 5143 01e8 EF 42                   		mov.L	r4, r2
 5144 01ea EF 51                   		mov.L	r5, r1
 5145 01ec 05 00 00 00             		bsr	_ctMaskLT
 5146 01f0 EF 15                   		mov.L	r1, r5
 5147                             		.loc 2 3450 27 discriminator 3
 5148 01f2 CD A4 10                		mov.B	16[r10], r4
 5149 01f5 53 45                   		and	r4, r5
 5150 01f7 C7 A5 10                		mov.B	r5, 16[r10]
3451:../src/wolfcrypt/src/rsa.c ****                         /* 0 - no add, -1 add */
3452:../src/wolfcrypt/src/rsa.c ****                         i += (word32)((byte)(-c));
 5151                             		.loc 2 3452 39 discriminator 3
 5152 01fa CD A5 10                		mov.B	16[r10], r5
 5153 01fd 7E 15                   		neg	r5
 5154                             		.loc 2 3452 30 discriminator 3
 5155 01ff 5B 55                   		movu.B	r5, r5
 5156                             		.loc 2 3452 27 discriminator 3
 5157 0201 ED A4 01                		mov.L	4[r10], r4
 5158 0204 4B 45                   		add	r4, r5
 5159 0206 E7 A5 01                		mov.L	r5, 4[r10]
3447:../src/wolfcrypt/src/rsa.c ****                         out[i] = key->data[j];
 5160                             		.loc 2 3447 52 discriminator 3
 5161 0209 ED A5 02                		mov.L	8[r10], r5
 5162 020c 62 15                   		add	#1, r5
 5163 020e E7 A5 02                		mov.L	r5, 8[r10]
 5164                             	.L336:
3447:../src/wolfcrypt/src/rsa.c ****                         out[i] = key->data[j];
 5165                             		.loc 2 3447 40 discriminator 1
 5166 0211 A8 6D                   		mov.L	4[r6], r5
 5167 0213 EE 55 24 06             		mov.L	6288[r5], r5
3447:../src/wolfcrypt/src/rsa.c ****                         out[i] = key->data[j];
 5168                             		.loc 2 3447 21 discriminator 1
 5169 0217 ED A4 02                		mov.L	8[r10], r4
 5170 021a 47 54                   		cmp	r5, r4
 5171 021c 23 9E                   		bltu	.L337
 5172 021e 2E 1A                   		bra	.L339
 5173                             	.L335:
 5174                             	.LBE45:
3453:../src/wolfcrypt/src/rsa.c ****                     }
3454:../src/wolfcrypt/src/rsa.c ****                 }
3455:../src/wolfcrypt/src/rsa.c ****                 else
3456:../src/wolfcrypt/src/rsa.c **** #endif
3457:../src/wolfcrypt/src/rsa.c ****                 {
3458:../src/wolfcrypt/src/rsa.c ****                     XMEMCPY(out, pad, ret);
 5175                             		.loc 2 3458 21
 5176 0220 ED A5 05                		mov.L	20[r10], r5
 5177 0223 EC A4                   		mov.L	[r10], r4
 5178 0225 EF 43                   		mov.L	r4, r3
 5179 0227 EF 52                   		mov.L	r5, r2
 5180 0229 ED A1 08                		mov.L	32[r10], r1
 5181 022c 05 00 00 00             		bsr	_memcpy
 5182 0230 08                      		bra	.L339
 5183                             	.L334:
3459:../src/wolfcrypt/src/rsa.c ****                 }
3460:../src/wolfcrypt/src/rsa.c ****             }
3461:../src/wolfcrypt/src/rsa.c ****             else
3462:../src/wolfcrypt/src/rsa.c ****                 *outPtr = pad;
 5184                             		.loc 2 3462 25
 5185 0231 ED A4 05                		mov.L	20[r10], r4
 5186 0234 EC 65                   		mov.L	[r6], r5
 5187 0236 E3 54                   		mov.L	r4, [r5]
 5188                             	.L339:
3463:../src/wolfcrypt/src/rsa.c **** 
3464:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_VERIFY_ONLY)
3465:../src/wolfcrypt/src/rsa.c ****             ret = ctMaskSelInt(ctMaskLTE(ret, outLen), ret, RSA_BUFFER_E);
 5189                             		.loc 2 3465 19
 5190 0238 ED A5 09                		mov.L	36[r10], r5
 5191 023b EF 52                   		mov.L	r5, r2
 5192 023d EC A1                   		mov.L	[r10], r1
 5193 023f 05 00 00 00             		bsr	_ctMaskLTE
 5194 0243 EF 15                   		mov.L	r1, r5
 5195 0245 FB 3A 7D FF             		mov.L	#-131, r3
 5196 0249 EC A2                   		mov.L	[r10], r2
 5197 024b CF 51                   		mov.B	r5, r1
 5198 024d 05 00 00 00             		bsr	_ctMaskSelInt
 5199 0251 E3 A1                   		mov.L	r1, [r10]
3466:../src/wolfcrypt/src/rsa.c ****     #ifndef WOLFSSL_RSA_DECRYPT_TO_0_LEN
3467:../src/wolfcrypt/src/rsa.c ****             ret = ctMaskSelInt(ctMaskNotEq(ret, 0), ret, RSA_BUFFER_E);
 5200                             		.loc 2 3467 19
 5201 0253 66 02                   		mov.L	#0, r2
 5202 0255 EC A1                   		mov.L	[r10], r1
 5203 0257 05 00 00 00             		bsr	_ctMaskNotEq
 5204 025b EF 15                   		mov.L	r1, r5
 5205 025d FB 3A 7D FF             		mov.L	#-131, r3
 5206 0261 EC A2                   		mov.L	[r10], r2
 5207 0263 CF 51                   		mov.B	r5, r1
 5208 0265 05 00 00 00             		bsr	_ctMaskSelInt
 5209 0269 E3 A1                   		mov.L	r1, [r10]
 5210                             		.balign 8,3,1
 5211                             	.L333:
 5212                             	.LBE44:
3468:../src/wolfcrypt/src/rsa.c ****     #endif
3469:../src/wolfcrypt/src/rsa.c **** #else
3470:../src/wolfcrypt/src/rsa.c ****             if (outLen < (word32)ret)
3471:../src/wolfcrypt/src/rsa.c ****                 ret = RSA_BUFFER_E;
3472:../src/wolfcrypt/src/rsa.c **** #endif
3473:../src/wolfcrypt/src/rsa.c ****         }
3474:../src/wolfcrypt/src/rsa.c **** 
3475:../src/wolfcrypt/src/rsa.c ****         key->state = RSA_STATE_DECRYPT_RES;
 5213                             		.loc 2 3475 20
 5214 026b A8 6D                   		mov.L	4[r6], r5
 5215 026d FA 56 23 06 06          		mov.L	#6, 6284[r5]
3476:../src/wolfcrypt/src/rsa.c ****         FALL_THROUGH;
3477:../src/wolfcrypt/src/rsa.c **** 
3478:../src/wolfcrypt/src/rsa.c ****     case RSA_STATE_DECRYPT_RES:
3479:../src/wolfcrypt/src/rsa.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA) && \
3480:../src/wolfcrypt/src/rsa.c ****             defined(HAVE_CAVIUM)
3481:../src/wolfcrypt/src/rsa.c ****         if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_RSA &&
3482:../src/wolfcrypt/src/rsa.c ****                                                    pad_type != WC_RSA_PSS_PAD) {
3483:../src/wolfcrypt/src/rsa.c ****             ret = key->asyncDev.event.ret;
3484:../src/wolfcrypt/src/rsa.c ****             if (ret >= 0) {
3485:../src/wolfcrypt/src/rsa.c ****                 /* convert result */
3486:../src/wolfcrypt/src/rsa.c ****                 byte* dataLen = (byte*)&key->dataLen;
3487:../src/wolfcrypt/src/rsa.c ****                 ret = (dataLen[0] << 8) | (dataLen[1]);
3488:../src/wolfcrypt/src/rsa.c **** 
3489:../src/wolfcrypt/src/rsa.c ****                 if (outPtr)
3490:../src/wolfcrypt/src/rsa.c ****                     *outPtr = in;
3491:../src/wolfcrypt/src/rsa.c ****             }
3492:../src/wolfcrypt/src/rsa.c ****         }
3493:../src/wolfcrypt/src/rsa.c ****     #endif
3494:../src/wolfcrypt/src/rsa.c ****         break;
 5216                             		.loc 2 3494 9
 5217 0272 0E                      		bra	.L342
 5218                             	.L322:
3495:../src/wolfcrypt/src/rsa.c **** 
3496:../src/wolfcrypt/src/rsa.c ****     default:
3497:../src/wolfcrypt/src/rsa.c ****         ret = BAD_STATE_E;
 5219                             		.loc 2 3497 13
 5220 0273 F8 AA 40 FF             		mov.L	#-192, [r10]
3498:../src/wolfcrypt/src/rsa.c ****         break;
 5221                             		.loc 2 3498 9
 5222 0277 0D                      		bra	.L326
 5223                             	.L342:
3494:../src/wolfcrypt/src/rsa.c **** 
 5224                             		.loc 2 3494 9
 5225 0278 03                      		nop
 5226 0279 2E 03                   		bra	.L326
 5227                             	.L343:
3414:../src/wolfcrypt/src/rsa.c ****         }
 5228                             		.loc 2 3414 13
 5229 027b 03                      		nop
 5230                             		.balign 8,3,1
 5231                             	.L326:
3499:../src/wolfcrypt/src/rsa.c ****     }
3500:../src/wolfcrypt/src/rsa.c **** 
3501:../src/wolfcrypt/src/rsa.c ****     /* if async pending then return and skip done cleanup below */
3502:../src/wolfcrypt/src/rsa.c ****     if (ret == WC_PENDING_E
 5232                             		.loc 2 3502 8
 5233 027c EC A5                   		mov.L	[r10], r5
 5234 027e 75 05 94                		cmp	#-108, r5
 5235 0281 1D                      		bne	.L340
3503:../src/wolfcrypt/src/rsa.c ****     #ifdef WC_RSA_NONBLOCK
3504:../src/wolfcrypt/src/rsa.c ****         || ret == FP_WOULDBLOCK
3505:../src/wolfcrypt/src/rsa.c ****     #endif
3506:../src/wolfcrypt/src/rsa.c ****     ) {
3507:../src/wolfcrypt/src/rsa.c ****         return ret;
 5236                             		.loc 2 3507 16
 5237 0282 EC A5                   		mov.L	[r10], r5
 5238 0284 2E 11                   		bra	.L341
 5239                             	.L340:
3508:../src/wolfcrypt/src/rsa.c ****     }
3509:../src/wolfcrypt/src/rsa.c **** 
3510:../src/wolfcrypt/src/rsa.c ****     key->state = RSA_STATE_NONE;
 5240                             		.loc 2 3510 16
 5241 0286 A8 6D                   		mov.L	4[r6], r5
 5242 0288 FA 56 23 06 00          		mov.L	#0, 6284[r5]
3511:../src/wolfcrypt/src/rsa.c ****     wc_RsaCleanup(key);
 5243                             		.loc 2 3511 5
 5244 028d A8 69                   		mov.L	4[r6], r1
 5245 028f 05 00 00 00             		bsr	_wc_RsaCleanup
3512:../src/wolfcrypt/src/rsa.c **** 
3513:../src/wolfcrypt/src/rsa.c ****     return ret;
 5246                             		.loc 2 3513 12
 5247 0293 EC A5                   		mov.L	[r10], r5
 5248                             	.L341:
3514:../src/wolfcrypt/src/rsa.c **** }
 5249                             		.loc 2 3514 1 discriminator 2
 5250 0295 EF 51                   		mov.L	r5, r1
 5251 0297 3F 6C 24                		rtsd	#144, r6-r12
 5252                             	.LFE62:
 5254 029a 74 10 01 00 00 00       		.section	.text.wc_RsaPublicEncrypt,"ax",@progbits
 5255                             		.global	_wc_RsaPublicEncrypt
 5257                             	_wc_RsaPublicEncrypt:
 5258                             	.LFB63:
3515:../src/wolfcrypt/src/rsa.c **** 
3516:../src/wolfcrypt/src/rsa.c **** 
3517:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
3518:../src/wolfcrypt/src/rsa.c **** /* Public RSA Functions */
3519:../src/wolfcrypt/src/rsa.c **** int wc_RsaPublicEncrypt(const byte* in, word32 inLen, byte* out, word32 outLen,
3520:../src/wolfcrypt/src/rsa.c ****                                                      RsaKey* key, WC_RNG* rng)
3521:../src/wolfcrypt/src/rsa.c **** {
 5259                             		.loc 2 3521 1
 5260 0000 7E AA                   		push.l	r10
 5261                             	.LCFI90:
 5262 0002 71 0A E4                		add	#-28, r0, r10
 5263                             	.LCFI91:
 5264 0005 71 A0 D8                		add	#-40, r10, r0
 5265                             	.LCFI92:
 5266 0008 75 45 24                		mov.L	#36, r5
 5267 000b 4B A5                   		add	r10, r5
 5268 000d E7 A1 01                		mov.L	r1, 4[r10]
 5269 0010 E7 A2 02                		mov.L	r2, 8[r10]
 5270 0013 E7 A3 03                		mov.L	r3, 12[r10]
 5271 0016 E7 A4 04                		mov.L	r4, 16[r10]
3522:../src/wolfcrypt/src/rsa.c ****     int ret;
3523:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3524:../src/wolfcrypt/src/rsa.c ****     ret = RsaPublicEncryptEx(in, inLen, out, outLen, key,
 5272                             		.loc 2 3524 11
 5273 0019 A8 5C                   		mov.L	4[r5], r4
 5274 001b A2 0C                   		mov.L	r4, 36[r0]
 5275 001d 3E 08 00                		mov.L	#0, 32[r0]
 5276 0020 3E 07 00                		mov.L	#0, 28[r0]
 5277 0023 3E 06 00                		mov.L	#0, 24[r0]
 5278 0026 3E 05 00                		mov.L	#0, 20[r0]
 5279 0029 3E 04 00                		mov.L	#0, 16[r0]
 5280 002c 3E 03 00                		mov.L	#0, 12[r0]
 5281 002f 3C 08 02                		mov.B	#2, 8[r0]
 5282 0032 3E 01 00                		mov.L	#0, 4[r0]
 5283 0035 EC 55                   		mov.L	[r5], r5
 5284 0037 E3 05                   		mov.L	r5, [r0]
 5285 0039 ED A4 04                		mov.L	16[r10], r4
 5286 003c ED A3 03                		mov.L	12[r10], r3
 5287 003f ED A2 02                		mov.L	8[r10], r2
 5288 0042 ED A1 01                		mov.L	4[r10], r1
 5289 0045 05 00 00 00             		bsr	_RsaPublicEncryptEx
 5290 0049 E3 A1                   		mov.L	r1, [r10]
3525:../src/wolfcrypt/src/rsa.c ****         RSA_PUBLIC_ENCRYPT, RSA_BLOCK_TYPE_2, WC_RSA_PKCSV15_PAD,
3526:../src/wolfcrypt/src/rsa.c ****         WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
3527:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3528:../src/wolfcrypt/src/rsa.c ****     return ret;
 5291                             		.loc 2 3528 12
 5292 004b EC A5                   		mov.L	[r10], r5
3529:../src/wolfcrypt/src/rsa.c **** }
 5293                             		.loc 2 3529 1
 5294 004d EF 51                   		mov.L	r5, r1
 5295 004f 3F AA 12                		rtsd	#72, r10-r10
 5296                             	.LFE63:
 5298                             		.section	.text.wc_RsaPublicEncrypt_ex,"ax",@progbits
 5299                             		.global	_wc_RsaPublicEncrypt_ex
 5301                             	_wc_RsaPublicEncrypt_ex:
 5302                             	.LFB64:
3530:../src/wolfcrypt/src/rsa.c **** 
3531:../src/wolfcrypt/src/rsa.c **** 
3532:../src/wolfcrypt/src/rsa.c **** #if !defined(WC_NO_RSA_OAEP) || defined(WC_RSA_NO_PADDING)
3533:../src/wolfcrypt/src/rsa.c **** int wc_RsaPublicEncrypt_ex(const byte* in, word32 inLen, byte* out,
3534:../src/wolfcrypt/src/rsa.c ****                     word32 outLen, RsaKey* key, WC_RNG* rng, int type,
3535:../src/wolfcrypt/src/rsa.c ****                     enum wc_HashType hash, int mgf, byte* label,
3536:../src/wolfcrypt/src/rsa.c ****                     word32 labelSz)
3537:../src/wolfcrypt/src/rsa.c **** {
 5303                             		.loc 2 3537 1
 5304 0000 7E AA                   		push.l	r10
 5305                             	.LCFI93:
 5306 0002 71 0A D0                		add	#-48, r0, r10
 5307                             	.LCFI94:
 5308 0005 71 A0 D8                		add	#-40, r10, r0
 5309                             	.LCFI95:
 5310 0008 75 45 38                		mov.L	#56, r5
 5311 000b 4B A5                   		add	r10, r5
 5312 000d E7 A1 01                		mov.L	r1, 4[r10]
 5313 0010 E7 A2 02                		mov.L	r2, 8[r10]
 5314 0013 E7 A3 03                		mov.L	r3, 12[r10]
 5315 0016 E7 A4 04                		mov.L	r4, 16[r10]
3538:../src/wolfcrypt/src/rsa.c ****     int ret;
3539:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3540:../src/wolfcrypt/src/rsa.c ****     ret = RsaPublicEncryptEx(in, inLen, out, outLen, key, RSA_PUBLIC_ENCRYPT,
 5316                             		.loc 2 3540 11
 5317 0019 A8 5C                   		mov.L	4[r5], r4
 5318 001b A2 0C                   		mov.L	r4, 36[r0]
 5319 001d 3E 08 00                		mov.L	#0, 32[r0]
 5320 0020 A9 D4                   		mov.L	24[r5], r4
 5321 0022 A1 8C                   		mov.L	r4, 28[r0]
 5322 0024 A9 5C                   		mov.L	20[r5], r4
 5323 0026 A1 84                   		mov.L	r4, 24[r0]
 5324 0028 A9 54                   		mov.L	16[r5], r4
 5325 002a A1 0C                   		mov.L	r4, 20[r0]
 5326 002c A8 DC                   		mov.L	12[r5], r4
 5327 002e A1 04                   		mov.L	r4, 16[r0]
 5328 0030 A8 D4                   		mov.L	8[r5], r4
 5329 0032 A0 8C                   		mov.L	r4, 12[r0]
 5330 0034 3C 08 02                		mov.B	#2, 8[r0]
 5331 0037 3E 01 00                		mov.L	#0, 4[r0]
 5332 003a EC 55                   		mov.L	[r5], r5
 5333 003c E3 05                   		mov.L	r5, [r0]
 5334 003e ED A4 04                		mov.L	16[r10], r4
 5335 0041 ED A3 03                		mov.L	12[r10], r3
 5336 0044 ED A2 02                		mov.L	8[r10], r2
 5337 0047 ED A1 01                		mov.L	4[r10], r1
 5338 004a 05 00 00 00             		bsr	_RsaPublicEncryptEx
 5339 004e E3 A1                   		mov.L	r1, [r10]
3541:../src/wolfcrypt/src/rsa.c ****         RSA_BLOCK_TYPE_2, type, hash, mgf, label, labelSz, 0, rng);
3542:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3543:../src/wolfcrypt/src/rsa.c ****     return ret;
 5340                             		.loc 2 3543 12
 5341 0050 EC A5                   		mov.L	[r10], r5
3544:../src/wolfcrypt/src/rsa.c **** }
 5342                             		.loc 2 3544 1
 5343 0052 EF 51                   		mov.L	r5, r1
 5344 0054 3F AA 17                		rtsd	#92, r10-r10
 5345                             	.LFE64:
 5347                             		.section	.text.wc_RsaPrivateDecryptInline,"ax",@progbits
 5348                             		.global	_wc_RsaPrivateDecryptInline
 5350                             	_wc_RsaPrivateDecryptInline:
 5351                             	.LFB65:
3545:../src/wolfcrypt/src/rsa.c **** #endif /* WC_NO_RSA_OAEP */
3546:../src/wolfcrypt/src/rsa.c **** #endif
3547:../src/wolfcrypt/src/rsa.c **** 
3548:../src/wolfcrypt/src/rsa.c **** 
3549:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
3550:../src/wolfcrypt/src/rsa.c **** int wc_RsaPrivateDecryptInline(byte* in, word32 inLen, byte** out, RsaKey* key)
3551:../src/wolfcrypt/src/rsa.c **** {
 5352                             		.loc 2 3551 1
 5353 0000 7E AA                   		push.l	r10
 5354                             	.LCFI96:
 5355 0002 71 0A E8                		add	#-24, r0, r10
 5356                             	.LCFI97:
 5357 0005 71 A0 D4                		add	#-44, r10, r0
 5358                             	.LCFI98:
 5359 0008 E7 A1 02                		mov.L	r1, 8[r10]
 5360 000b E7 A2 03                		mov.L	r2, 12[r10]
 5361 000e E7 A3 04                		mov.L	r3, 16[r10]
 5362 0011 E7 A4 05                		mov.L	r4, 20[r10]
3552:../src/wolfcrypt/src/rsa.c ****     WC_RNG* rng;
3553:../src/wolfcrypt/src/rsa.c ****     int ret;
3554:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
3555:../src/wolfcrypt/src/rsa.c ****     rng = key->rng;
 5363                             		.loc 2 3555 9
 5364 0014 ED A5 05                		mov.L	20[r10], r5
 5365 0017 EE 55 25 06             		mov.L	6292[r5], r5
 5366 001b E3 A5                   		mov.L	r5, [r10]
3556:../src/wolfcrypt/src/rsa.c **** #else
3557:../src/wolfcrypt/src/rsa.c ****     rng = NULL;
3558:../src/wolfcrypt/src/rsa.c **** #endif
3559:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3560:../src/wolfcrypt/src/rsa.c ****     ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 5367                             		.loc 2 3560 11
 5368 001d EC A5                   		mov.L	[r10], r5
 5369 001f A2 85                   		mov.L	r5, 40[r0]
 5370 0021 3E 09 00                		mov.L	#0, 36[r0]
 5371 0024 3E 08 00                		mov.L	#0, 32[r0]
 5372 0027 3E 07 00                		mov.L	#0, 28[r0]
 5373 002a 3E 06 00                		mov.L	#0, 24[r0]
 5374 002d 3E 05 00                		mov.L	#0, 20[r0]
 5375 0030 3E 04 00                		mov.L	#0, 16[r0]
 5376 0033 3C 0C 02                		mov.B	#2, 12[r0]
 5377 0036 3E 02 03                		mov.L	#3, 8[r0]
 5378 0039 ED A5 05                		mov.L	20[r10], r5
 5379 003c A0 0D                   		mov.L	r5, 4[r0]
 5380 003e ED A5 04                		mov.L	16[r10], r5
 5381 0041 E3 05                   		mov.L	r5, [r0]
 5382 0043 ED A4 03                		mov.L	12[r10], r4
 5383 0046 ED A3 02                		mov.L	8[r10], r3
 5384 0049 ED A2 03                		mov.L	12[r10], r2
 5385 004c ED A1 02                		mov.L	8[r10], r1
 5386 004f 05 00 00 00             		bsr	_RsaPrivateDecryptEx
 5387 0053 E7 A1 01                		mov.L	r1, 4[r10]
3561:../src/wolfcrypt/src/rsa.c ****         RSA_PRIVATE_DECRYPT, RSA_BLOCK_TYPE_2, WC_RSA_PKCSV15_PAD,
3562:../src/wolfcrypt/src/rsa.c ****         WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
3563:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3564:../src/wolfcrypt/src/rsa.c ****     return ret;
 5388                             		.loc 2 3564 12
 5389 0056 ED A5 01                		mov.L	4[r10], r5
3565:../src/wolfcrypt/src/rsa.c **** }
 5390                             		.loc 2 3565 1
 5391 0059 EF 51                   		mov.L	r5, r1
 5392 005b 3F AA 12                		rtsd	#72, r10-r10
 5393                             	.LFE65:
 5395                             		.section	.text.wc_RsaPrivateDecryptInline_ex,"ax",@progbits
 5396                             		.global	_wc_RsaPrivateDecryptInline_ex
 5398                             	_wc_RsaPrivateDecryptInline_ex:
 5399                             	.LFB66:
3566:../src/wolfcrypt/src/rsa.c **** 
3567:../src/wolfcrypt/src/rsa.c **** 
3568:../src/wolfcrypt/src/rsa.c **** #ifndef WC_NO_RSA_OAEP
3569:../src/wolfcrypt/src/rsa.c **** int wc_RsaPrivateDecryptInline_ex(byte* in, word32 inLen, byte** out,
3570:../src/wolfcrypt/src/rsa.c ****                                   RsaKey* key, int type, enum wc_HashType hash,
3571:../src/wolfcrypt/src/rsa.c ****                                   int mgf, byte* label, word32 labelSz)
3572:../src/wolfcrypt/src/rsa.c **** {
 5400                             		.loc 2 3572 1
 5401 0000 7E AA                   		push.l	r10
 5402                             	.LCFI99:
 5403 0002 71 0A D4                		add	#-44, r0, r10
 5404                             	.LCFI100:
 5405 0005 71 A0 D4                		add	#-44, r10, r0
 5406                             	.LCFI101:
 5407 0008 75 45 34                		mov.L	#52, r5
 5408 000b 4B A5                   		add	r10, r5
 5409 000d E7 A1 02                		mov.L	r1, 8[r10]
 5410 0010 E7 A2 03                		mov.L	r2, 12[r10]
 5411 0013 E7 A3 04                		mov.L	r3, 16[r10]
 5412 0016 E7 A4 05                		mov.L	r4, 20[r10]
3573:../src/wolfcrypt/src/rsa.c ****     WC_RNG* rng;
3574:../src/wolfcrypt/src/rsa.c ****     int ret;
3575:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
3576:../src/wolfcrypt/src/rsa.c ****     rng = key->rng;
 5413                             		.loc 2 3576 9
 5414 0019 ED A4 05                		mov.L	20[r10], r4
 5415 001c EE 44 25 06             		mov.L	6292[r4], r4
 5416 0020 E3 A4                   		mov.L	r4, [r10]
3577:../src/wolfcrypt/src/rsa.c **** #else
3578:../src/wolfcrypt/src/rsa.c ****     rng = NULL;
3579:../src/wolfcrypt/src/rsa.c **** #endif
3580:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3581:../src/wolfcrypt/src/rsa.c ****     ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 5417                             		.loc 2 3581 11
 5418 0022 EC A4                   		mov.L	[r10], r4
 5419 0024 A2 84                   		mov.L	r4, 40[r0]
 5420 0026 3E 09 00                		mov.L	#0, 36[r0]
 5421 0029 A9 54                   		mov.L	16[r5], r4
 5422 002b A2 04                   		mov.L	r4, 32[r0]
 5423 002d A8 DC                   		mov.L	12[r5], r4
 5424 002f A1 8C                   		mov.L	r4, 28[r0]
 5425 0031 A8 D4                   		mov.L	8[r5], r4
 5426 0033 A1 84                   		mov.L	r4, 24[r0]
 5427 0035 A8 5C                   		mov.L	4[r5], r4
 5428 0037 A1 0C                   		mov.L	r4, 20[r0]
 5429 0039 EC 55                   		mov.L	[r5], r5
 5430 003b A1 05                   		mov.L	r5, 16[r0]
 5431 003d 3C 0C 02                		mov.B	#2, 12[r0]
 5432 0040 3E 02 03                		mov.L	#3, 8[r0]
 5433 0043 ED A5 05                		mov.L	20[r10], r5
 5434 0046 A0 0D                   		mov.L	r5, 4[r0]
 5435 0048 ED A5 04                		mov.L	16[r10], r5
 5436 004b E3 05                   		mov.L	r5, [r0]
 5437 004d ED A4 03                		mov.L	12[r10], r4
 5438 0050 ED A3 02                		mov.L	8[r10], r3
 5439 0053 ED A2 03                		mov.L	12[r10], r2
 5440 0056 ED A1 02                		mov.L	8[r10], r1
 5441 0059 05 00 00 00             		bsr	_RsaPrivateDecryptEx
 5442 005d E7 A1 01                		mov.L	r1, 4[r10]
3582:../src/wolfcrypt/src/rsa.c ****         RSA_PRIVATE_DECRYPT, RSA_BLOCK_TYPE_2, type, hash,
3583:../src/wolfcrypt/src/rsa.c ****         mgf, label, labelSz, 0, rng);
3584:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3585:../src/wolfcrypt/src/rsa.c ****     return ret;
 5443                             		.loc 2 3585 12
 5444 0060 ED A5 01                		mov.L	4[r10], r5
3586:../src/wolfcrypt/src/rsa.c **** }
 5445                             		.loc 2 3586 1
 5446 0063 EF 51                   		mov.L	r5, r1
 5447 0065 3F AA 17                		rtsd	#92, r10-r10
 5448                             	.LFE66:
 5450                             		.section	.text.wc_RsaPrivateDecrypt,"ax",@progbits
 5451                             		.global	_wc_RsaPrivateDecrypt
 5453                             	_wc_RsaPrivateDecrypt:
 5454                             	.LFB67:
3587:../src/wolfcrypt/src/rsa.c **** #endif /* WC_NO_RSA_OAEP */
3588:../src/wolfcrypt/src/rsa.c **** 
3589:../src/wolfcrypt/src/rsa.c **** 
3590:../src/wolfcrypt/src/rsa.c **** int wc_RsaPrivateDecrypt(const byte* in, word32 inLen, byte* out,
3591:../src/wolfcrypt/src/rsa.c ****                                                  word32 outLen, RsaKey* key)
3592:../src/wolfcrypt/src/rsa.c **** {
 5455                             		.loc 2 3592 1
 5456 0000 7E AA                   		push.l	r10
 5457                             	.LCFI102:
 5458 0002 71 0A E4                		add	#-28, r0, r10
 5459                             	.LCFI103:
 5460 0005 71 A0 D4                		add	#-44, r10, r0
 5461                             	.LCFI104:
 5462 0008 75 45 24                		mov.L	#36, r5
 5463 000b 4B A5                   		add	r10, r5
 5464 000d E7 A1 02                		mov.L	r1, 8[r10]
 5465 0010 E7 A2 03                		mov.L	r2, 12[r10]
 5466 0013 E7 A3 04                		mov.L	r3, 16[r10]
 5467 0016 E7 A4 05                		mov.L	r4, 20[r10]
3593:../src/wolfcrypt/src/rsa.c ****     WC_RNG* rng;
3594:../src/wolfcrypt/src/rsa.c ****     int ret;
3595:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
3596:../src/wolfcrypt/src/rsa.c ****     rng = key->rng;
 5468                             		.loc 2 3596 9
 5469 0019 EC 54                   		mov.L	[r5], r4
 5470 001b EE 44 25 06             		mov.L	6292[r4], r4
 5471 001f E3 A4                   		mov.L	r4, [r10]
3597:../src/wolfcrypt/src/rsa.c **** #else
3598:../src/wolfcrypt/src/rsa.c ****     rng = NULL;
3599:../src/wolfcrypt/src/rsa.c **** #endif
3600:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3601:../src/wolfcrypt/src/rsa.c ****     ret = RsaPrivateDecryptEx(in, inLen, out, outLen, NULL, key,
 5472                             		.loc 2 3601 11
 5473 0021 EC A4                   		mov.L	[r10], r4
 5474 0023 A2 84                   		mov.L	r4, 40[r0]
 5475 0025 3E 09 00                		mov.L	#0, 36[r0]
 5476 0028 3E 08 00                		mov.L	#0, 32[r0]
 5477 002b 3E 07 00                		mov.L	#0, 28[r0]
 5478 002e 3E 06 00                		mov.L	#0, 24[r0]
 5479 0031 3E 05 00                		mov.L	#0, 20[r0]
 5480 0034 3E 04 00                		mov.L	#0, 16[r0]
 5481 0037 3C 0C 02                		mov.B	#2, 12[r0]
 5482 003a 3E 02 03                		mov.L	#3, 8[r0]
 5483 003d EC 55                   		mov.L	[r5], r5
 5484 003f A0 0D                   		mov.L	r5, 4[r0]
 5485 0041 F8 06 00                		mov.L	#0, [r0]
 5486 0044 ED A4 05                		mov.L	20[r10], r4
 5487 0047 ED A3 04                		mov.L	16[r10], r3
 5488 004a ED A2 03                		mov.L	12[r10], r2
 5489 004d ED A1 02                		mov.L	8[r10], r1
 5490 0050 05 00 00 00             		bsr	_RsaPrivateDecryptEx
 5491 0054 E7 A1 01                		mov.L	r1, 4[r10]
3602:../src/wolfcrypt/src/rsa.c ****         RSA_PRIVATE_DECRYPT, RSA_BLOCK_TYPE_2, WC_RSA_PKCSV15_PAD,
3603:../src/wolfcrypt/src/rsa.c ****         WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
3604:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3605:../src/wolfcrypt/src/rsa.c ****     return ret;
 5492                             		.loc 2 3605 12
 5493 0057 ED A5 01                		mov.L	4[r10], r5
3606:../src/wolfcrypt/src/rsa.c **** }
 5494                             		.loc 2 3606 1
 5495 005a EF 51                   		mov.L	r5, r1
 5496 005c 3F AA 13                		rtsd	#76, r10-r10
 5497                             	.LFE67:
 5499                             		.section	.text.wc_RsaPrivateDecrypt_ex,"ax",@progbits
 5500                             		.global	_wc_RsaPrivateDecrypt_ex
 5502                             	_wc_RsaPrivateDecrypt_ex:
 5503                             	.LFB68:
3607:../src/wolfcrypt/src/rsa.c **** 
3608:../src/wolfcrypt/src/rsa.c **** #if !defined(WC_NO_RSA_OAEP) || defined(WC_RSA_NO_PADDING)
3609:../src/wolfcrypt/src/rsa.c **** int wc_RsaPrivateDecrypt_ex(const byte* in, word32 inLen, byte* out,
3610:../src/wolfcrypt/src/rsa.c ****                             word32 outLen, RsaKey* key, int type,
3611:../src/wolfcrypt/src/rsa.c ****                             enum wc_HashType hash, int mgf, byte* label,
3612:../src/wolfcrypt/src/rsa.c ****                             word32 labelSz)
3613:../src/wolfcrypt/src/rsa.c **** {
 5504                             		.loc 2 3613 1
 5505 0000 7E AA                   		push.l	r10
 5506                             	.LCFI105:
 5507 0002 71 0A D0                		add	#-48, r0, r10
 5508                             	.LCFI106:
 5509 0005 71 A0 D4                		add	#-44, r10, r0
 5510                             	.LCFI107:
 5511 0008 75 45 38                		mov.L	#56, r5
 5512 000b 4B A5                   		add	r10, r5
 5513 000d E7 A1 02                		mov.L	r1, 8[r10]
 5514 0010 E7 A2 03                		mov.L	r2, 12[r10]
 5515 0013 E7 A3 04                		mov.L	r3, 16[r10]
 5516 0016 E7 A4 05                		mov.L	r4, 20[r10]
3614:../src/wolfcrypt/src/rsa.c ****     WC_RNG* rng;
3615:../src/wolfcrypt/src/rsa.c ****     int ret;
3616:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
3617:../src/wolfcrypt/src/rsa.c ****     rng = key->rng;
 5517                             		.loc 2 3617 9
 5518 0019 EC 54                   		mov.L	[r5], r4
 5519 001b EE 44 25 06             		mov.L	6292[r4], r4
 5520 001f E3 A4                   		mov.L	r4, [r10]
3618:../src/wolfcrypt/src/rsa.c **** #else
3619:../src/wolfcrypt/src/rsa.c ****     rng = NULL;
3620:../src/wolfcrypt/src/rsa.c **** #endif
3621:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3622:../src/wolfcrypt/src/rsa.c ****     ret = RsaPrivateDecryptEx(in, inLen, out, outLen, NULL, key,
 5521                             		.loc 2 3622 11
 5522 0021 EC A4                   		mov.L	[r10], r4
 5523 0023 A2 84                   		mov.L	r4, 40[r0]
 5524 0025 3E 09 00                		mov.L	#0, 36[r0]
 5525 0028 A9 5C                   		mov.L	20[r5], r4
 5526 002a A2 04                   		mov.L	r4, 32[r0]
 5527 002c A9 54                   		mov.L	16[r5], r4
 5528 002e A1 8C                   		mov.L	r4, 28[r0]
 5529 0030 A8 DC                   		mov.L	12[r5], r4
 5530 0032 A1 84                   		mov.L	r4, 24[r0]
 5531 0034 A8 D4                   		mov.L	8[r5], r4
 5532 0036 A1 0C                   		mov.L	r4, 20[r0]
 5533 0038 A8 5C                   		mov.L	4[r5], r4
 5534 003a A1 04                   		mov.L	r4, 16[r0]
 5535 003c 3C 0C 02                		mov.B	#2, 12[r0]
 5536 003f 3E 02 03                		mov.L	#3, 8[r0]
 5537 0042 EC 55                   		mov.L	[r5], r5
 5538 0044 A0 0D                   		mov.L	r5, 4[r0]
 5539 0046 F8 06 00                		mov.L	#0, [r0]
 5540 0049 ED A4 05                		mov.L	20[r10], r4
 5541 004c ED A3 04                		mov.L	16[r10], r3
 5542 004f ED A2 03                		mov.L	12[r10], r2
 5543 0052 ED A1 02                		mov.L	8[r10], r1
 5544 0055 05 00 00 00             		bsr	_RsaPrivateDecryptEx
 5545 0059 E7 A1 01                		mov.L	r1, 4[r10]
3623:../src/wolfcrypt/src/rsa.c ****         RSA_PRIVATE_DECRYPT, RSA_BLOCK_TYPE_2, type, hash, mgf, label,
3624:../src/wolfcrypt/src/rsa.c ****         labelSz, 0, rng);
3625:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3626:../src/wolfcrypt/src/rsa.c ****     return ret;
 5546                             		.loc 2 3626 12
 5547 005c ED A5 01                		mov.L	4[r10], r5
3627:../src/wolfcrypt/src/rsa.c **** }
 5548                             		.loc 2 3627 1
 5549 005f EF 51                   		mov.L	r5, r1
 5550 0061 3F AA 18                		rtsd	#96, r10-r10
 5551                             	.LFE68:
 5553                             		.section	.text.wc_RsaSSL_VerifyInline,"ax",@progbits
 5554                             		.global	_wc_RsaSSL_VerifyInline
 5556                             	_wc_RsaSSL_VerifyInline:
 5557                             	.LFB69:
3628:../src/wolfcrypt/src/rsa.c **** #endif /* WC_NO_RSA_OAEP || WC_RSA_NO_PADDING */
3629:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_RSA_PUBLIC_ONLY */
3630:../src/wolfcrypt/src/rsa.c **** 
3631:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_CRYPTOCELL)
3632:../src/wolfcrypt/src/rsa.c **** int wc_RsaSSL_VerifyInline(byte* in, word32 inLen, byte** out, RsaKey* key)
3633:../src/wolfcrypt/src/rsa.c **** {
 5558                             		.loc 2 3633 1
 5559 0000 7E AA                   		push.l	r10
 5560                             	.LCFI108:
 5561 0002 71 0A E8                		add	#-24, r0, r10
 5562                             	.LCFI109:
 5563 0005 71 A0 D4                		add	#-44, r10, r0
 5564                             	.LCFI110:
 5565 0008 E7 A1 02                		mov.L	r1, 8[r10]
 5566 000b E7 A2 03                		mov.L	r2, 12[r10]
 5567 000e E7 A3 04                		mov.L	r3, 16[r10]
 5568 0011 E7 A4 05                		mov.L	r4, 20[r10]
3634:../src/wolfcrypt/src/rsa.c ****     WC_RNG* rng;
3635:../src/wolfcrypt/src/rsa.c ****     int ret;
3636:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
3637:../src/wolfcrypt/src/rsa.c ****     rng = key->rng;
 5569                             		.loc 2 3637 9
 5570 0014 ED A5 05                		mov.L	20[r10], r5
 5571 0017 EE 55 25 06             		mov.L	6292[r5], r5
 5572 001b E3 A5                   		mov.L	r5, [r10]
3638:../src/wolfcrypt/src/rsa.c **** #else
3639:../src/wolfcrypt/src/rsa.c ****     rng = NULL;
3640:../src/wolfcrypt/src/rsa.c **** #endif
3641:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3642:../src/wolfcrypt/src/rsa.c ****     ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 5573                             		.loc 2 3642 11
 5574 001d EC A5                   		mov.L	[r10], r5
 5575 001f A2 85                   		mov.L	r5, 40[r0]
 5576 0021 3E 09 00                		mov.L	#0, 36[r0]
 5577 0024 3E 08 00                		mov.L	#0, 32[r0]
 5578 0027 3E 07 00                		mov.L	#0, 28[r0]
 5579 002a 3E 06 00                		mov.L	#0, 24[r0]
 5580 002d 3E 05 00                		mov.L	#0, 20[r0]
 5581 0030 3E 04 00                		mov.L	#0, 16[r0]
 5582 0033 3C 0C 01                		mov.B	#1, 12[r0]
 5583 0036 3E 02 01                		mov.L	#1, 8[r0]
 5584 0039 ED A5 05                		mov.L	20[r10], r5
 5585 003c A0 0D                   		mov.L	r5, 4[r0]
 5586 003e ED A5 04                		mov.L	16[r10], r5
 5587 0041 E3 05                   		mov.L	r5, [r0]
 5588 0043 ED A4 03                		mov.L	12[r10], r4
 5589 0046 ED A3 02                		mov.L	8[r10], r3
 5590 0049 ED A2 03                		mov.L	12[r10], r2
 5591 004c ED A1 02                		mov.L	8[r10], r1
 5592 004f 05 00 00 00             		bsr	_RsaPrivateDecryptEx
 5593 0053 E7 A1 01                		mov.L	r1, 4[r10]
3643:../src/wolfcrypt/src/rsa.c ****         RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PKCSV15_PAD,
3644:../src/wolfcrypt/src/rsa.c ****         WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
3645:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3646:../src/wolfcrypt/src/rsa.c ****     return ret;
 5594                             		.loc 2 3646 12
 5595 0056 ED A5 01                		mov.L	4[r10], r5
3647:../src/wolfcrypt/src/rsa.c **** }
 5596                             		.loc 2 3647 1
 5597 0059 EF 51                   		mov.L	r5, r1
 5598 005b 3F AA 12                		rtsd	#72, r10-r10
 5599                             	.LFE69:
 5601                             		.section	.text.wc_RsaSSL_Verify,"ax",@progbits
 5602                             		.global	_wc_RsaSSL_Verify
 5604                             	_wc_RsaSSL_Verify:
 5605                             	.LFB70:
3648:../src/wolfcrypt/src/rsa.c **** #endif
3649:../src/wolfcrypt/src/rsa.c **** 
3650:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
3651:../src/wolfcrypt/src/rsa.c **** int wc_RsaSSL_Verify(const byte* in, word32 inLen, byte* out, word32 outLen,
3652:../src/wolfcrypt/src/rsa.c ****                                                                  RsaKey* key)
3653:../src/wolfcrypt/src/rsa.c **** {
 5606                             		.loc 2 3653 1
 5607 0000 7E AA                   		push.l	r10
 5608                             	.LCFI111:
 5609 0002 71 0A EC                		add	#-20, r0, r10
 5610                             	.LCFI112:
 5611 0005 71 A0 F8                		add	#-8, r10, r0
 5612                             	.LCFI113:
 5613 0008 75 45 1C                		mov.L	#28, r5
 5614 000b 4B A5                   		add	r10, r5
 5615 000d E3 A1                   		mov.L	r1, [r10]
 5616 000f E7 A2 01                		mov.L	r2, 4[r10]
 5617 0012 E7 A3 02                		mov.L	r3, 8[r10]
 5618 0015 E7 A4 03                		mov.L	r4, 12[r10]
3654:../src/wolfcrypt/src/rsa.c ****     return wc_RsaSSL_Verify_ex(in, inLen, out, outLen, key, WC_RSA_PKCSV15_PAD);
 5619                             		.loc 2 3654 12
 5620 0018 3E 01 00                		mov.L	#0, 4[r0]
 5621 001b EC 55                   		mov.L	[r5], r5
 5622 001d E3 05                   		mov.L	r5, [r0]
 5623 001f ED A4 03                		mov.L	12[r10], r4
 5624 0022 ED A3 02                		mov.L	8[r10], r3
 5625 0025 ED A2 01                		mov.L	4[r10], r2
 5626 0028 EC A1                   		mov.L	[r10], r1
 5627 002a 05 00 00 00             		bsr	_wc_RsaSSL_Verify_ex
 5628 002e EF 15                   		mov.L	r1, r5
3655:../src/wolfcrypt/src/rsa.c **** }
 5629                             		.loc 2 3655 1
 5630 0030 EF 51                   		mov.L	r5, r1
 5631 0032 3F AA 08                		rtsd	#32, r10-r10
 5632                             	.LFE70:
 5634                             		.section	.text.wc_RsaSSL_Verify_ex,"ax",@progbits
 5635                             		.global	_wc_RsaSSL_Verify_ex
 5637                             	_wc_RsaSSL_Verify_ex:
 5638                             	.LFB71:
3656:../src/wolfcrypt/src/rsa.c **** 
3657:../src/wolfcrypt/src/rsa.c **** int  wc_RsaSSL_Verify_ex(const byte* in, word32 inLen, byte* out, word32 outLen,
3658:../src/wolfcrypt/src/rsa.c ****                          RsaKey* key, int pad_type)
3659:../src/wolfcrypt/src/rsa.c **** {
 5639                             		.loc 2 3659 1
 5640 0000 7E AA                   		push.l	r10
 5641                             	.LCFI114:
 5642 0002 71 0A E4                		add	#-28, r0, r10
 5643                             	.LCFI115:
 5644 0005 71 A0 F4                		add	#-12, r10, r0
 5645                             	.LCFI116:
 5646 0008 75 45 24                		mov.L	#36, r5
 5647 000b 4B A5                   		add	r10, r5
 5648 000d E7 A1 01                		mov.L	r1, 4[r10]
 5649 0010 E7 A2 02                		mov.L	r2, 8[r10]
 5650 0013 E7 A3 03                		mov.L	r3, 12[r10]
 5651 0016 E7 A4 04                		mov.L	r4, 16[r10]
3660:../src/wolfcrypt/src/rsa.c ****     int ret;
3661:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3662:../src/wolfcrypt/src/rsa.c ****     ret = wc_RsaSSL_Verify_ex2(in, inLen, out, outLen, key, pad_type,
 5652                             		.loc 2 3662 11
 5653 0019 3E 02 00                		mov.L	#0, 8[r0]
 5654 001c A8 5C                   		mov.L	4[r5], r4
 5655 001e A0 0C                   		mov.L	r4, 4[r0]
 5656 0020 EC 55                   		mov.L	[r5], r5
 5657 0022 E3 05                   		mov.L	r5, [r0]
 5658 0024 ED A4 04                		mov.L	16[r10], r4
 5659 0027 ED A3 03                		mov.L	12[r10], r3
 5660 002a ED A2 02                		mov.L	8[r10], r2
 5661 002d ED A1 01                		mov.L	4[r10], r1
 5662 0030 05 00 00 00             		bsr	_wc_RsaSSL_Verify_ex2
 5663 0034 E3 A1                   		mov.L	r1, [r10]
3663:../src/wolfcrypt/src/rsa.c ****             WC_HASH_TYPE_NONE);
3664:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3665:../src/wolfcrypt/src/rsa.c ****     return ret;
 5664                             		.loc 2 3665 12
 5665 0036 EC A5                   		mov.L	[r10], r5
3666:../src/wolfcrypt/src/rsa.c **** }
 5666                             		.loc 2 3666 1
 5667 0038 EF 51                   		mov.L	r5, r1
 5668 003a 3F AA 0B                		rtsd	#44, r10-r10
 5669                             	.LFE71:
 5671                             		.section	.text.wc_RsaSSL_Verify_ex2,"ax",@progbits
 5672                             		.global	_wc_RsaSSL_Verify_ex2
 5674                             	_wc_RsaSSL_Verify_ex2:
 5675                             	.LFB72:
3667:../src/wolfcrypt/src/rsa.c **** 
3668:../src/wolfcrypt/src/rsa.c **** int  wc_RsaSSL_Verify_ex2(const byte* in, word32 inLen, byte* out, word32 outLen,
3669:../src/wolfcrypt/src/rsa.c ****                          RsaKey* key, int pad_type, enum wc_HashType hash)
3670:../src/wolfcrypt/src/rsa.c **** {
 5676                             		.loc 2 3670 1
 5677 0000 7E AA                   		push.l	r10
 5678                             	.LCFI117:
 5679 0002 7E A6                   		push.l	r6
 5680                             	.LCFI118:
 5681 0004 71 0A DC                		add	#-36, r0, r10
 5682                             	.LCFI119:
 5683 0007 71 A0 D4                		add	#-44, r10, r0
 5684                             	.LCFI120:
 5685 000a 75 46 30                		mov.L	#48, r6
 5686 000d 4B A6                   		add	r10, r6
 5687 000f E7 A1 02                		mov.L	r1, 8[r10]
 5688 0012 E7 A2 03                		mov.L	r2, 12[r10]
 5689 0015 E7 A3 04                		mov.L	r3, 16[r10]
 5690 0018 E7 A4 05                		mov.L	r4, 20[r10]
3671:../src/wolfcrypt/src/rsa.c ****     WC_RNG* rng;
3672:../src/wolfcrypt/src/rsa.c ****     int ret;
3673:../src/wolfcrypt/src/rsa.c **** 
3674:../src/wolfcrypt/src/rsa.c ****     if (key == NULL) {
 5691                             		.loc 2 3674 8
 5692 001b EC 65                   		mov.L	[r6], r5
 5693 001d 61 05                   		cmp	#0, r5
 5694 001f 1F                      		bne	.L363
3675:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 5695                             		.loc 2 3675 16
 5696 0020 FB 5A 53 FF             		mov.L	#-173, r5
 5697 0024 2E 4D                   		bra	.L364
 5698                             	.L363:
3676:../src/wolfcrypt/src/rsa.c ****     }
3677:../src/wolfcrypt/src/rsa.c **** 
3678:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
3679:../src/wolfcrypt/src/rsa.c ****     rng = key->rng;
 5699                             		.loc 2 3679 9
 5700 0026 EC 65                   		mov.L	[r6], r5
 5701 0028 EE 55 25 06             		mov.L	6292[r5], r5
 5702 002c E3 A5                   		mov.L	r5, [r10]
3680:../src/wolfcrypt/src/rsa.c **** #else
3681:../src/wolfcrypt/src/rsa.c ****     rng = NULL;
3682:../src/wolfcrypt/src/rsa.c **** #endif
3683:../src/wolfcrypt/src/rsa.c **** 
3684:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3685:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
3686:../src/wolfcrypt/src/rsa.c ****     ret = RsaPrivateDecryptEx(in, inLen, out, outLen, NULL, key,
 5703                             		.loc 2 3686 11
 5704 002e A8 E1                   		mov.L	8[r6], r1
 5705 0030 05 00 00 00             		bsr	_wc_hash2mgf
 5706 0034 EF 15                   		mov.L	r1, r5
 5707 0036 EC A4                   		mov.L	[r10], r4
 5708 0038 A2 84                   		mov.L	r4, 40[r0]
 5709 003a F9 06 09 FF             		mov.L	#-1, 36[r0]
 5710 003e 3E 08 00                		mov.L	#0, 32[r0]
 5711 0041 3E 07 00                		mov.L	#0, 28[r0]
 5712 0044 A1 85                   		mov.L	r5, 24[r0]
 5713 0046 A8 E5                   		mov.L	8[r6], r5
 5714 0048 A1 0D                   		mov.L	r5, 20[r0]
 5715 004a A8 6D                   		mov.L	4[r6], r5
 5716 004c A1 05                   		mov.L	r5, 16[r0]
 5717 004e 3C 0C 01                		mov.B	#1, 12[r0]
 5718 0051 3E 02 01                		mov.L	#1, 8[r0]
 5719 0054 EC 65                   		mov.L	[r6], r5
 5720 0056 A0 0D                   		mov.L	r5, 4[r0]
 5721 0058 F8 06 00                		mov.L	#0, [r0]
 5722 005b ED A4 05                		mov.L	20[r10], r4
 5723 005e ED A3 04                		mov.L	16[r10], r3
 5724 0061 ED A2 03                		mov.L	12[r10], r2
 5725 0064 ED A1 02                		mov.L	8[r10], r1
 5726 0067 05 00 00 00             		bsr	_RsaPrivateDecryptEx
 5727 006b E7 A1 01                		mov.L	r1, 4[r10]
3687:../src/wolfcrypt/src/rsa.c ****         RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, pad_type,
3688:../src/wolfcrypt/src/rsa.c ****         hash, wc_hash2mgf(hash), NULL, 0, RSA_PSS_SALT_LEN_DEFAULT, rng);
3689:../src/wolfcrypt/src/rsa.c **** #else
3690:../src/wolfcrypt/src/rsa.c ****     ret = RsaPrivateDecryptEx(in, inLen, out, outLen, NULL, key,
3691:../src/wolfcrypt/src/rsa.c ****         RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, pad_type,
3692:../src/wolfcrypt/src/rsa.c ****         hash, wc_hash2mgf(hash), NULL, 0, RSA_PSS_SALT_LEN_DISCOVER, rng);
3693:../src/wolfcrypt/src/rsa.c **** #endif
3694:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3695:../src/wolfcrypt/src/rsa.c ****     return ret;
 5728                             		.loc 2 3695 12
 5729 006e ED A5 01                		mov.L	4[r10], r5
 5730                             	.L364:
3696:../src/wolfcrypt/src/rsa.c **** }
 5731                             		.loc 2 3696 1
 5732 0071 EF 51                   		mov.L	r5, r1
 5733 0073 71 00 50                		add	#0x50, r0
 5734 0076 7E B6                   		pop	r6
 5735 0078 7E BA                   		pop	r10
 5736 007a 02                      		rts
 5737                             	.LFE72:
 5739                             		.section	.text.wc_RsaPSS_VerifyInline,"ax",@progbits
 5740                             		.global	_wc_RsaPSS_VerifyInline
 5742                             	_wc_RsaPSS_VerifyInline:
 5743                             	.LFB73:
3697:../src/wolfcrypt/src/rsa.c **** #endif
3698:../src/wolfcrypt/src/rsa.c **** 
3699:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_PSS
3700:../src/wolfcrypt/src/rsa.c **** /* Verify the message signed with RSA-PSS.
3701:../src/wolfcrypt/src/rsa.c ****  * The input buffer is reused for the output buffer.
3702:../src/wolfcrypt/src/rsa.c ****  * Salt length is equal to hash length.
3703:../src/wolfcrypt/src/rsa.c ****  *
3704:../src/wolfcrypt/src/rsa.c ****  * in     Buffer holding encrypted data.
3705:../src/wolfcrypt/src/rsa.c ****  * inLen  Length of data in buffer.
3706:../src/wolfcrypt/src/rsa.c ****  * out    Pointer to address containing the PSS data.
3707:../src/wolfcrypt/src/rsa.c ****  * hash   Hash algorithm.
3708:../src/wolfcrypt/src/rsa.c ****  * mgf    Mask generation function.
3709:../src/wolfcrypt/src/rsa.c ****  * key    Public RSA key.
3710:../src/wolfcrypt/src/rsa.c ****  * returns the length of the PSS data on success and negative indicates failure.
3711:../src/wolfcrypt/src/rsa.c ****  */
3712:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_VerifyInline(byte* in, word32 inLen, byte** out,
3713:../src/wolfcrypt/src/rsa.c ****                            enum wc_HashType hash, int mgf, RsaKey* key)
3714:../src/wolfcrypt/src/rsa.c **** {
 5744                             		.loc 2 3714 1
 5745 0000 7E AA                   		push.l	r10
 5746                             	.LCFI121:
 5747 0002 71 0A E8                		add	#-24, r0, r10
 5748                             	.LCFI122:
 5749 0005 71 A0 F4                		add	#-12, r10, r0
 5750                             	.LCFI123:
 5751 0008 75 45 20                		mov.L	#32, r5
 5752 000b 4B A5                   		add	r10, r5
 5753 000d E3 A1                   		mov.L	r1, [r10]
 5754 000f E7 A2 01                		mov.L	r2, 4[r10]
 5755 0012 E7 A3 02                		mov.L	r3, 8[r10]
 5756 0015 E7 A4 03                		mov.L	r4, 12[r10]
3715:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
3716:../src/wolfcrypt/src/rsa.c ****     return wc_RsaPSS_VerifyInline_ex(in, inLen, out, hash, mgf,
 5757                             		.loc 2 3716 12
 5758 0018 A8 5C                   		mov.L	4[r5], r4
 5759 001a A0 84                   		mov.L	r4, 8[r0]
 5760 001c F9 06 01 FF             		mov.L	#-1, 4[r0]
 5761 0020 EC 55                   		mov.L	[r5], r5
 5762 0022 E3 05                   		mov.L	r5, [r0]
 5763 0024 ED A4 03                		mov.L	12[r10], r4
 5764 0027 ED A3 02                		mov.L	8[r10], r3
 5765 002a ED A2 01                		mov.L	4[r10], r2
 5766 002d EC A1                   		mov.L	[r10], r1
 5767 002f 05 00 00 00             		bsr	_wc_RsaPSS_VerifyInline_ex
 5768 0033 EF 15                   		mov.L	r1, r5
3717:../src/wolfcrypt/src/rsa.c ****                                                  RSA_PSS_SALT_LEN_DEFAULT, key);
3718:../src/wolfcrypt/src/rsa.c **** #else
3719:../src/wolfcrypt/src/rsa.c ****     return wc_RsaPSS_VerifyInline_ex(in, inLen, out, hash, mgf,
3720:../src/wolfcrypt/src/rsa.c ****                                                 RSA_PSS_SALT_LEN_DISCOVER, key);
3721:../src/wolfcrypt/src/rsa.c **** #endif
3722:../src/wolfcrypt/src/rsa.c **** }
 5769                             		.loc 2 3722 1
 5770 0035 EF 51                   		mov.L	r5, r1
 5771 0037 3F AA 0A                		rtsd	#40, r10-r10
 5772                             	.LFE73:
 5774                             		.section	.text.wc_RsaPSS_VerifyInline_ex,"ax",@progbits
 5775                             		.global	_wc_RsaPSS_VerifyInline_ex
 5777                             	_wc_RsaPSS_VerifyInline_ex:
 5778                             	.LFB74:
3723:../src/wolfcrypt/src/rsa.c **** 
3724:../src/wolfcrypt/src/rsa.c **** /* Verify the message signed with RSA-PSS.
3725:../src/wolfcrypt/src/rsa.c ****  * The input buffer is reused for the output buffer.
3726:../src/wolfcrypt/src/rsa.c ****  *
3727:../src/wolfcrypt/src/rsa.c ****  * in       Buffer holding encrypted data.
3728:../src/wolfcrypt/src/rsa.c ****  * inLen    Length of data in buffer.
3729:../src/wolfcrypt/src/rsa.c ****  * out      Pointer to address containing the PSS data.
3730:../src/wolfcrypt/src/rsa.c ****  * hash     Hash algorithm.
3731:../src/wolfcrypt/src/rsa.c ****  * mgf      Mask generation function.
3732:../src/wolfcrypt/src/rsa.c ****  * key      Public RSA key.
3733:../src/wolfcrypt/src/rsa.c ****  * saltLen  Length of salt used. RSA_PSS_SALT_LEN_DEFAULT (-1) indicates salt
3734:../src/wolfcrypt/src/rsa.c ****  *          length is the same as the hash length. RSA_PSS_SALT_LEN_DISCOVER
3735:../src/wolfcrypt/src/rsa.c ****  *          indicates salt length is determined from the data.
3736:../src/wolfcrypt/src/rsa.c ****  * returns the length of the PSS data on success and negative indicates failure.
3737:../src/wolfcrypt/src/rsa.c ****  */
3738:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_VerifyInline_ex(byte* in, word32 inLen, byte** out,
3739:../src/wolfcrypt/src/rsa.c ****                               enum wc_HashType hash, int mgf, int saltLen,
3740:../src/wolfcrypt/src/rsa.c ****                               RsaKey* key)
3741:../src/wolfcrypt/src/rsa.c **** {
 5779                             		.loc 2 3741 1
 5780 0000 7E AA                   		push.l	r10
 5781                             	.LCFI124:
 5782 0002 71 0A DC                		add	#-36, r0, r10
 5783                             	.LCFI125:
 5784 0005 71 A0 D4                		add	#-44, r10, r0
 5785                             	.LCFI126:
 5786 0008 75 45 2C                		mov.L	#44, r5
 5787 000b 4B A5                   		add	r10, r5
 5788 000d E7 A1 02                		mov.L	r1, 8[r10]
 5789 0010 E7 A2 03                		mov.L	r2, 12[r10]
 5790 0013 E7 A3 04                		mov.L	r3, 16[r10]
 5791 0016 E7 A4 05                		mov.L	r4, 20[r10]
3742:../src/wolfcrypt/src/rsa.c ****     WC_RNG* rng;
3743:../src/wolfcrypt/src/rsa.c ****     int ret;
3744:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
3745:../src/wolfcrypt/src/rsa.c ****     rng = key->rng;
 5792                             		.loc 2 3745 9
 5793 0019 A8 D4                   		mov.L	8[r5], r4
 5794 001b EE 44 25 06             		mov.L	6292[r4], r4
 5795 001f E3 A4                   		mov.L	r4, [r10]
3746:../src/wolfcrypt/src/rsa.c **** #else
3747:../src/wolfcrypt/src/rsa.c ****     rng = NULL;
3748:../src/wolfcrypt/src/rsa.c **** #endif
3749:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3750:../src/wolfcrypt/src/rsa.c ****     ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 5796                             		.loc 2 3750 11
 5797 0021 EC A4                   		mov.L	[r10], r4
 5798 0023 A2 84                   		mov.L	r4, 40[r0]
 5799 0025 A8 5C                   		mov.L	4[r5], r4
 5800 0027 A2 0C                   		mov.L	r4, 36[r0]
 5801 0029 3E 08 00                		mov.L	#0, 32[r0]
 5802 002c 3E 07 00                		mov.L	#0, 28[r0]
 5803 002f EC 54                   		mov.L	[r5], r4
 5804 0031 A1 84                   		mov.L	r4, 24[r0]
 5805 0033 ED A4 05                		mov.L	20[r10], r4
 5806 0036 A1 0C                   		mov.L	r4, 20[r0]
 5807 0038 3E 04 02                		mov.L	#2, 16[r0]
 5808 003b 3C 0C 01                		mov.B	#1, 12[r0]
 5809 003e 3E 02 01                		mov.L	#1, 8[r0]
 5810 0041 A8 D5                   		mov.L	8[r5], r5
 5811 0043 A0 0D                   		mov.L	r5, 4[r0]
 5812 0045 ED A5 04                		mov.L	16[r10], r5
 5813 0048 E3 05                   		mov.L	r5, [r0]
 5814 004a ED A4 03                		mov.L	12[r10], r4
 5815 004d ED A3 02                		mov.L	8[r10], r3
 5816 0050 ED A2 03                		mov.L	12[r10], r2
 5817 0053 ED A1 02                		mov.L	8[r10], r1
 5818 0056 05 00 00 00             		bsr	_RsaPrivateDecryptEx
 5819 005a E7 A1 01                		mov.L	r1, 4[r10]
3751:../src/wolfcrypt/src/rsa.c ****         RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PSS_PAD,
3752:../src/wolfcrypt/src/rsa.c ****         hash, mgf, NULL, 0, saltLen, rng);
3753:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3754:../src/wolfcrypt/src/rsa.c ****     return ret;
 5820                             		.loc 2 3754 12
 5821 005d ED A5 01                		mov.L	4[r10], r5
3755:../src/wolfcrypt/src/rsa.c **** }
 5822                             		.loc 2 3755 1
 5823 0060 EF 51                   		mov.L	r5, r1
 5824 0062 3F AA 15                		rtsd	#84, r10-r10
 5825                             	.LFE74:
 5827                             		.section	.text.wc_RsaPSS_Verify,"ax",@progbits
 5828                             		.global	_wc_RsaPSS_Verify
 5830                             	_wc_RsaPSS_Verify:
 5831                             	.LFB75:
3756:../src/wolfcrypt/src/rsa.c **** 
3757:../src/wolfcrypt/src/rsa.c **** /* Verify the message signed with RSA-PSS.
3758:../src/wolfcrypt/src/rsa.c ****  * Salt length is equal to hash length.
3759:../src/wolfcrypt/src/rsa.c ****  *
3760:../src/wolfcrypt/src/rsa.c ****  * in     Buffer holding encrypted data.
3761:../src/wolfcrypt/src/rsa.c ****  * inLen  Length of data in buffer.
3762:../src/wolfcrypt/src/rsa.c ****  * out    Pointer to address containing the PSS data.
3763:../src/wolfcrypt/src/rsa.c ****  * hash   Hash algorithm.
3764:../src/wolfcrypt/src/rsa.c ****  * mgf    Mask generation function.
3765:../src/wolfcrypt/src/rsa.c ****  * key    Public RSA key.
3766:../src/wolfcrypt/src/rsa.c ****  * returns the length of the PSS data on success and negative indicates failure.
3767:../src/wolfcrypt/src/rsa.c ****  */
3768:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_Verify(byte* in, word32 inLen, byte* out, word32 outLen,
3769:../src/wolfcrypt/src/rsa.c ****                      enum wc_HashType hash, int mgf, RsaKey* key)
3770:../src/wolfcrypt/src/rsa.c **** {
 5832                             		.loc 2 3770 1
 5833 0000 7E AA                   		push.l	r10
 5834                             	.LCFI127:
 5835 0002 71 0A E4                		add	#-28, r0, r10
 5836                             	.LCFI128:
 5837 0005 71 A0 F0                		add	#-16, r10, r0
 5838                             	.LCFI129:
 5839 0008 75 45 24                		mov.L	#36, r5
 5840 000b 4B A5                   		add	r10, r5
 5841 000d E3 A1                   		mov.L	r1, [r10]
 5842 000f E7 A2 01                		mov.L	r2, 4[r10]
 5843 0012 E7 A3 02                		mov.L	r3, 8[r10]
 5844 0015 E7 A4 03                		mov.L	r4, 12[r10]
3771:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
3772:../src/wolfcrypt/src/rsa.c ****     return wc_RsaPSS_Verify_ex(in, inLen, out, outLen, hash, mgf,
 5845                             		.loc 2 3772 12
 5846 0018 A8 D4                   		mov.L	8[r5], r4
 5847 001a A0 8C                   		mov.L	r4, 12[r0]
 5848 001c F9 06 02 FF             		mov.L	#-1, 8[r0]
 5849 0020 A8 5C                   		mov.L	4[r5], r4
 5850 0022 A0 0C                   		mov.L	r4, 4[r0]
 5851 0024 EC 55                   		mov.L	[r5], r5
 5852 0026 E3 05                   		mov.L	r5, [r0]
 5853 0028 ED A4 03                		mov.L	12[r10], r4
 5854 002b ED A3 02                		mov.L	8[r10], r3
 5855 002e ED A2 01                		mov.L	4[r10], r2
 5856 0031 EC A1                   		mov.L	[r10], r1
 5857 0033 05 00 00 00             		bsr	_wc_RsaPSS_Verify_ex
 5858 0037 EF 15                   		mov.L	r1, r5
3773:../src/wolfcrypt/src/rsa.c ****                                                  RSA_PSS_SALT_LEN_DEFAULT, key);
3774:../src/wolfcrypt/src/rsa.c **** #else
3775:../src/wolfcrypt/src/rsa.c ****     return wc_RsaPSS_Verify_ex(in, inLen, out, outLen, hash, mgf,
3776:../src/wolfcrypt/src/rsa.c ****                                                 RSA_PSS_SALT_LEN_DISCOVER, key);
3777:../src/wolfcrypt/src/rsa.c **** #endif
3778:../src/wolfcrypt/src/rsa.c **** }
 5859                             		.loc 2 3778 1
 5860 0039 EF 51                   		mov.L	r5, r1
 5861 003b 3F AA 0C                		rtsd	#48, r10-r10
 5862                             	.LFE75:
 5864                             		.section	.text.wc_RsaPSS_Verify_ex,"ax",@progbits
 5865                             		.global	_wc_RsaPSS_Verify_ex
 5867                             	_wc_RsaPSS_Verify_ex:
 5868                             	.LFB76:
3779:../src/wolfcrypt/src/rsa.c **** 
3780:../src/wolfcrypt/src/rsa.c **** /* Verify the message signed with RSA-PSS.
3781:../src/wolfcrypt/src/rsa.c ****  *
3782:../src/wolfcrypt/src/rsa.c ****  * in       Buffer holding encrypted data.
3783:../src/wolfcrypt/src/rsa.c ****  * inLen    Length of data in buffer.
3784:../src/wolfcrypt/src/rsa.c ****  * out      Pointer to address containing the PSS data.
3785:../src/wolfcrypt/src/rsa.c ****  * hash     Hash algorithm.
3786:../src/wolfcrypt/src/rsa.c ****  * mgf      Mask generation function.
3787:../src/wolfcrypt/src/rsa.c ****  * key      Public RSA key.
3788:../src/wolfcrypt/src/rsa.c ****  * saltLen  Length of salt used. RSA_PSS_SALT_LEN_DEFAULT (-1) indicates salt
3789:../src/wolfcrypt/src/rsa.c ****  *          length is the same as the hash length. RSA_PSS_SALT_LEN_DISCOVER
3790:../src/wolfcrypt/src/rsa.c ****  *          indicates salt length is determined from the data.
3791:../src/wolfcrypt/src/rsa.c ****  * returns the length of the PSS data on success and negative indicates failure.
3792:../src/wolfcrypt/src/rsa.c ****  */
3793:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_Verify_ex(byte* in, word32 inLen, byte* out, word32 outLen,
3794:../src/wolfcrypt/src/rsa.c ****                         enum wc_HashType hash, int mgf, int saltLen,
3795:../src/wolfcrypt/src/rsa.c ****                         RsaKey* key)
3796:../src/wolfcrypt/src/rsa.c **** {
 5869                             		.loc 2 3796 1
 5870 0000 7E AA                   		push.l	r10
 5871                             	.LCFI130:
 5872 0002 71 0A D8                		add	#-40, r0, r10
 5873                             	.LCFI131:
 5874 0005 71 A0 D4                		add	#-44, r10, r0
 5875                             	.LCFI132:
 5876 0008 75 45 30                		mov.L	#48, r5
 5877 000b 4B A5                   		add	r10, r5
 5878 000d E7 A1 02                		mov.L	r1, 8[r10]
 5879 0010 E7 A2 03                		mov.L	r2, 12[r10]
 5880 0013 E7 A3 04                		mov.L	r3, 16[r10]
 5881 0016 E7 A4 05                		mov.L	r4, 20[r10]
3797:../src/wolfcrypt/src/rsa.c ****     WC_RNG* rng;
3798:../src/wolfcrypt/src/rsa.c ****     int ret;
3799:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
3800:../src/wolfcrypt/src/rsa.c ****     rng = key->rng;
 5882                             		.loc 2 3800 9
 5883 0019 A8 DC                   		mov.L	12[r5], r4
 5884 001b EE 44 25 06             		mov.L	6292[r4], r4
 5885 001f E3 A4                   		mov.L	r4, [r10]
3801:../src/wolfcrypt/src/rsa.c **** #else
3802:../src/wolfcrypt/src/rsa.c ****     rng = NULL;
3803:../src/wolfcrypt/src/rsa.c **** #endif
3804:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
3805:../src/wolfcrypt/src/rsa.c ****     ret = RsaPrivateDecryptEx(in, inLen, out, outLen, NULL, key,
 5886                             		.loc 2 3805 11
 5887 0021 EC A4                   		mov.L	[r10], r4
 5888 0023 A2 84                   		mov.L	r4, 40[r0]
 5889 0025 A8 D4                   		mov.L	8[r5], r4
 5890 0027 A2 0C                   		mov.L	r4, 36[r0]
 5891 0029 3E 08 00                		mov.L	#0, 32[r0]
 5892 002c 3E 07 00                		mov.L	#0, 28[r0]
 5893 002f A8 5C                   		mov.L	4[r5], r4
 5894 0031 A1 84                   		mov.L	r4, 24[r0]
 5895 0033 EC 54                   		mov.L	[r5], r4
 5896 0035 A1 0C                   		mov.L	r4, 20[r0]
 5897 0037 3E 04 02                		mov.L	#2, 16[r0]
 5898 003a 3C 0C 01                		mov.B	#1, 12[r0]
 5899 003d 3E 02 01                		mov.L	#1, 8[r0]
 5900 0040 A8 DD                   		mov.L	12[r5], r5
 5901 0042 A0 0D                   		mov.L	r5, 4[r0]
 5902 0044 F8 06 00                		mov.L	#0, [r0]
 5903 0047 ED A4 05                		mov.L	20[r10], r4
 5904 004a ED A3 04                		mov.L	16[r10], r3
 5905 004d ED A2 03                		mov.L	12[r10], r2
 5906 0050 ED A1 02                		mov.L	8[r10], r1
 5907 0053 05 00 00 00             		bsr	_RsaPrivateDecryptEx
 5908 0057 E7 A1 01                		mov.L	r1, 4[r10]
3806:../src/wolfcrypt/src/rsa.c ****         RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PSS_PAD,
3807:../src/wolfcrypt/src/rsa.c ****         hash, mgf, NULL, 0, saltLen, rng);
3808:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
3809:../src/wolfcrypt/src/rsa.c ****     return ret;
 5909                             		.loc 2 3809 12
 5910 005a ED A5 01                		mov.L	4[r10], r5
3810:../src/wolfcrypt/src/rsa.c **** }
 5911                             		.loc 2 3810 1
 5912 005d EF 51                   		mov.L	r5, r1
 5913 005f 3F AA 16                		rtsd	#88, r10-r10
 5914                             	.LFE76:
 5916                             		.section	.text.wc_RsaPSS_CheckPadding,"ax",@progbits
 5917                             		.global	_wc_RsaPSS_CheckPadding
 5919                             	_wc_RsaPSS_CheckPadding:
 5920                             	.LFB77:
3811:../src/wolfcrypt/src/rsa.c **** 
3812:../src/wolfcrypt/src/rsa.c **** 
3813:../src/wolfcrypt/src/rsa.c **** /* Checks the PSS data to ensure that the signature matches.
3814:../src/wolfcrypt/src/rsa.c ****  * Salt length is equal to hash length.
3815:../src/wolfcrypt/src/rsa.c ****  *
3816:../src/wolfcrypt/src/rsa.c ****  * in        Hash of the data that is being verified.
3817:../src/wolfcrypt/src/rsa.c ****  * inSz      Length of hash.
3818:../src/wolfcrypt/src/rsa.c ****  * sig       Buffer holding PSS data.
3819:../src/wolfcrypt/src/rsa.c ****  * sigSz     Size of PSS data.
3820:../src/wolfcrypt/src/rsa.c ****  * hashType  Hash algorithm.
3821:../src/wolfcrypt/src/rsa.c ****  * returns BAD_PADDING_E when the PSS data is invalid, BAD_FUNC_ARG when
3822:../src/wolfcrypt/src/rsa.c ****  * NULL is passed in to in or sig or inSz is not the same as the hash
3823:../src/wolfcrypt/src/rsa.c ****  * algorithm length and 0 on success.
3824:../src/wolfcrypt/src/rsa.c ****  */
3825:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_CheckPadding(const byte* in, word32 inSz, byte* sig,
3826:../src/wolfcrypt/src/rsa.c ****                            word32 sigSz, enum wc_HashType hashType)
3827:../src/wolfcrypt/src/rsa.c **** {
 5921                             		.loc 2 3827 1
 5922 0000 7E AA                   		push.l	r10
 5923                             	.LCFI133:
 5924 0002 71 0A EC                		add	#-20, r0, r10
 5925                             	.LCFI134:
 5926 0005 71 A0 F4                		add	#-12, r10, r0
 5927                             	.LCFI135:
 5928 0008 75 45 1C                		mov.L	#28, r5
 5929 000b 4B A5                   		add	r10, r5
 5930 000d E3 A1                   		mov.L	r1, [r10]
 5931 000f E7 A2 01                		mov.L	r2, 4[r10]
 5932 0012 E7 A3 02                		mov.L	r3, 8[r10]
 5933 0015 E7 A4 03                		mov.L	r4, 12[r10]
3828:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
3829:../src/wolfcrypt/src/rsa.c ****     return wc_RsaPSS_CheckPadding_ex(in, inSz, sig, sigSz, hashType, RSA_PSS_SALT_LEN_DEFAULT, 0);
 5934                             		.loc 2 3829 12
 5935 0018 3E 02 00                		mov.L	#0, 8[r0]
 5936 001b F9 06 01 FF             		mov.L	#-1, 4[r0]
 5937 001f EC 55                   		mov.L	[r5], r5
 5938 0021 E3 05                   		mov.L	r5, [r0]
 5939 0023 ED A4 03                		mov.L	12[r10], r4
 5940 0026 ED A3 02                		mov.L	8[r10], r3
 5941 0029 ED A2 01                		mov.L	4[r10], r2
 5942 002c EC A1                   		mov.L	[r10], r1
 5943 002e 05 00 00 00             		bsr	_wc_RsaPSS_CheckPadding_ex
 5944 0032 EF 15                   		mov.L	r1, r5
3830:../src/wolfcrypt/src/rsa.c **** #else
3831:../src/wolfcrypt/src/rsa.c ****     return wc_RsaPSS_CheckPadding_ex(in, inSz, sig, sigSz, hashType, RSA_PSS_SALT_LEN_DISCOVER, 0);
3832:../src/wolfcrypt/src/rsa.c **** #endif
3833:../src/wolfcrypt/src/rsa.c **** }
 5945                             		.loc 2 3833 1
 5946 0034 EF 51                   		mov.L	r5, r1
 5947 0036 3F AA 09                		rtsd	#36, r10-r10
 5948                             	.LFE77:
 5950                             		.section C,"a",@progbits
 5951 02cd 00 00 00                		.p2align 2
 5952                             	.LC20:
 5953 02d0 52 73 61 50 53 53 5F 43 		.string	"RsaPSS_CheckPadding: Padding Error"
 5953      68 65 63 6B 50 61 64 64 
 5953      69 6E 67 3A 20 50 61 64 
 5953      64 69 6E 67 20 45 72 72 
 5953      6F 72 00 
 5954 02f3 00                      		.section	.text.wc_RsaPSS_CheckPadding_ex2,"ax",@progbits
 5955                             		.global	_wc_RsaPSS_CheckPadding_ex2
 5957                             	_wc_RsaPSS_CheckPadding_ex2:
 5958                             	.LFB78:
3834:../src/wolfcrypt/src/rsa.c **** 
3835:../src/wolfcrypt/src/rsa.c **** /* Checks the PSS data to ensure that the signature matches.
3836:../src/wolfcrypt/src/rsa.c ****  *
3837:../src/wolfcrypt/src/rsa.c ****  * in        Hash of the data that is being verified.
3838:../src/wolfcrypt/src/rsa.c ****  * inSz      Length of hash.
3839:../src/wolfcrypt/src/rsa.c ****  * sig       Buffer holding PSS data.
3840:../src/wolfcrypt/src/rsa.c ****  * sigSz     Size of PSS data.
3841:../src/wolfcrypt/src/rsa.c ****  * hashType  Hash algorithm.
3842:../src/wolfcrypt/src/rsa.c ****  * saltLen   Length of salt used. RSA_PSS_SALT_LEN_DEFAULT (-1) indicates salt
3843:../src/wolfcrypt/src/rsa.c ****  *           length is the same as the hash length. RSA_PSS_SALT_LEN_DISCOVER
3844:../src/wolfcrypt/src/rsa.c ****  *           indicates salt length is determined from the data.
3845:../src/wolfcrypt/src/rsa.c ****  * bits      Can be used to calculate salt size in FIPS case
3846:../src/wolfcrypt/src/rsa.c ****  * returns BAD_PADDING_E when the PSS data is invalid, BAD_FUNC_ARG when
3847:../src/wolfcrypt/src/rsa.c ****  * NULL is passed in to in or sig or inSz is not the same as the hash
3848:../src/wolfcrypt/src/rsa.c ****  * algorithm length and 0 on success.
3849:../src/wolfcrypt/src/rsa.c ****  */
3850:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_CheckPadding_ex2(const byte* in, word32 inSz, byte* sig,
3851:../src/wolfcrypt/src/rsa.c ****                                word32 sigSz, enum wc_HashType hashType,
3852:../src/wolfcrypt/src/rsa.c ****                                int saltLen, int bits, void* heap)
3853:../src/wolfcrypt/src/rsa.c **** {
 5959                             		.loc 2 3853 1
 5960 0000 7E AA                   		push.l	r10
 5961                             	.LCFI136:
 5962 0002 7E A6                   		push.l	r6
 5963                             	.LCFI137:
 5964 0004 72 0A 50 FF             		add	#-176, r0, r10
 5965                             	.LCFI138:
 5966 0008 71 A0 FC                		add	#-4, r10, r0
 5967                             	.LCFI139:
 5968 000b 75 46 BC                		mov.L	#0xbc, r6
 5969 000e 4B A6                   		add	r10, r6
 5970 0010 E7 A1 24                		mov.L	r1, 144[r10]
 5971 0013 E7 A2 25                		mov.L	r2, 148[r10]
 5972 0016 E7 A3 26                		mov.L	r3, 152[r10]
 5973 0019 E7 A4 27                		mov.L	r4, 156[r10]
3854:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 5974                             		.loc 2 3854 9
 5975 001c F8 A6 00                		mov.L	#0, [r10]
3855:../src/wolfcrypt/src/rsa.c ****     byte sigCheckBuf[WC_MAX_DIGEST_SIZE*2 + RSA_PSS_PAD_SZ];
3856:../src/wolfcrypt/src/rsa.c ****     byte *sigCheck = sigCheckBuf;
 5976                             		.loc 2 3856 11
 5977 001f 71 A5 08                		add	#8, r10, r5
 5978 0022 E7 A5 01                		mov.L	r5, 4[r10]
3857:../src/wolfcrypt/src/rsa.c **** 
3858:../src/wolfcrypt/src/rsa.c ****     (void)bits;
3859:../src/wolfcrypt/src/rsa.c **** 
3860:../src/wolfcrypt/src/rsa.c ****     if (in == NULL || sig == NULL ||
 5979                             		.loc 2 3860 8
 5980 0025 ED A5 24                		mov.L	144[r10], r5
 5981 0028 61 05                   		cmp	#0, r5
 5982 002a 20 17                   		beq	.L376
 5983                             		.loc 2 3860 20 discriminator 1
 5984 002c ED A5 26                		mov.L	152[r10], r5
 5985 002f 61 05                   		cmp	#0, r5
 5986 0031 20 10                   		beq	.L376
3861:../src/wolfcrypt/src/rsa.c ****                                inSz != (word32)wc_HashGetDigestSize(hashType)) {
 5987                             		.loc 2 3861 48 discriminator 2
 5988 0033 EC 61                   		mov.L	[r6], r1
 5989 0035 05 00 00 00             		bsr	_wc_HashGetDigestSize
 5990 0039 EF 15                   		mov.L	r1, r5
3860:../src/wolfcrypt/src/rsa.c ****                                inSz != (word32)wc_HashGetDigestSize(hashType)) {
 5991                             		.loc 2 3860 35 discriminator 2
 5992 003b ED A4 25                		mov.L	148[r10], r4
 5993 003e 47 54                   		cmp	r5, r4
 5994 0040 15                      		beq	.L377
 5995                             	.L376:
3862:../src/wolfcrypt/src/rsa.c ****         ret = BAD_FUNC_ARG;
 5996                             		.loc 2 3862 13
 5997 0041 F8 AA 53 FF             		mov.L	#-173, [r10]
 5998                             	.L377:
3863:../src/wolfcrypt/src/rsa.c ****     }
3864:../src/wolfcrypt/src/rsa.c **** 
3865:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 5999                             		.loc 2 3865 8
 6000 0045 EC A5                   		mov.L	[r10], r5
 6001 0047 61 05                   		cmp	#0, r5
 6002 0049 21 3D                   		bne	.L378
3866:../src/wolfcrypt/src/rsa.c ****         if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 6003                             		.loc 2 3866 12
 6004 004b A8 6D                   		mov.L	4[r6], r5
 6005 004d 75 05 FF                		cmp	#-1, r5
 6006 0050 21 1C                   		bne	.L379
3867:../src/wolfcrypt/src/rsa.c ****             saltLen = inSz;
 6007                             		.loc 2 3867 21
 6008 0052 ED A5 25                		mov.L	148[r10], r5
 6009 0055 A0 6D                   		mov.L	r5, 4[r6]
3868:../src/wolfcrypt/src/rsa.c ****             #ifdef WOLFSSL_SHA512
3869:../src/wolfcrypt/src/rsa.c ****                 /* See FIPS 186-4 section 5.5 item (e). */
3870:../src/wolfcrypt/src/rsa.c ****                 if (bits == 1024 && inSz == WC_SHA512_DIGEST_SIZE) {
 6010                             		.loc 2 3870 20
 6011 0057 A8 E5                   		mov.L	8[r6], r5
 6012 0059 76 05 00 04             		cmp	#0x400, r5
 6013 005d 21 29                   		bne	.L378
 6014                             		.loc 2 3870 34 discriminator 1
 6015 005f ED A5 25                		mov.L	148[r10], r5
 6016 0062 75 55 40                		cmp	#0x40, r5
 6017 0065 21 21                   		bne	.L378
3871:../src/wolfcrypt/src/rsa.c ****                     saltLen = RSA_PSS_SALT_MAX_SZ;
 6018                             		.loc 2 3871 29
 6019 0067 3E 61 3E                		mov.L	#62, 4[r6]
 6020 006a 2E 1C                   		bra	.L378
 6021                             	.L379:
3872:../src/wolfcrypt/src/rsa.c ****                 }
3873:../src/wolfcrypt/src/rsa.c ****             #endif
3874:../src/wolfcrypt/src/rsa.c ****         }
3875:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_LONG_SALT
3876:../src/wolfcrypt/src/rsa.c ****         else if (saltLen > (int)inSz) {
 6022                             		.loc 2 3876 28
 6023 006c ED A5 25                		mov.L	148[r10], r5
 6024                             		.loc 2 3876 17
 6025 006f A8 6C                   		mov.L	4[r6], r4
 6026 0071 47 54                   		cmp	r5, r4
 6027 0073 2B 08                   		ble	.L381
3877:../src/wolfcrypt/src/rsa.c ****             ret = PSS_SALTLEN_E;
 6028                             		.loc 2 3877 17
 6029 0075 F8 AA 06 FF             		mov.L	#-250, [r10]
 6030 0079 2E 0D                   		bra	.L378
 6031                             	.L381:
3878:../src/wolfcrypt/src/rsa.c ****         }
3879:../src/wolfcrypt/src/rsa.c **** #endif
3880:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
3881:../src/wolfcrypt/src/rsa.c ****         else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {
 6032                             		.loc 2 3881 17
 6033 007b A8 6D                   		mov.L	4[r6], r5
 6034 007d 75 05 FF                		cmp	#-1, r5
 6035 0080 28 06                   		bge	.L378
3882:../src/wolfcrypt/src/rsa.c ****             ret = PSS_SALTLEN_E;
 6036                             		.loc 2 3882 17
 6037 0082 F8 AA 06 FF             		mov.L	#-250, [r10]
 6038                             		.balign 8,3,1
 6039                             	.L378:
3883:../src/wolfcrypt/src/rsa.c ****         }
3884:../src/wolfcrypt/src/rsa.c **** #else
3885:../src/wolfcrypt/src/rsa.c ****         else if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {
3886:../src/wolfcrypt/src/rsa.c ****             saltLen = sigSz - inSz;
3887:../src/wolfcrypt/src/rsa.c ****             if (saltLen < 0) {
3888:../src/wolfcrypt/src/rsa.c ****                 ret = PSS_SALTLEN_E;
3889:../src/wolfcrypt/src/rsa.c ****             }
3890:../src/wolfcrypt/src/rsa.c ****         }
3891:../src/wolfcrypt/src/rsa.c ****         else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER) {
3892:../src/wolfcrypt/src/rsa.c ****             ret = PSS_SALTLEN_E;
3893:../src/wolfcrypt/src/rsa.c ****         }
3894:../src/wolfcrypt/src/rsa.c **** #endif
3895:../src/wolfcrypt/src/rsa.c ****     }
3896:../src/wolfcrypt/src/rsa.c **** 
3897:../src/wolfcrypt/src/rsa.c ****     /* Sig = Salt | Exp Hash */
3898:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 6040                             		.loc 2 3898 8
 6041 0086 EC A5                   		mov.L	[r10], r5
 6042 0088 61 05                   		cmp	#0, r5
 6043 008a 21 12                   		bne	.L382
3899:../src/wolfcrypt/src/rsa.c ****         if (sigSz != inSz + saltLen) {
 6044                             		.loc 2 3899 27
 6045 008c A8 6D                   		mov.L	4[r6], r5
 6046 008e 06 89 A5 25             		add	148[r10].L, r5
 6047                             		.loc 2 3899 12
 6048 0092 ED A4 27                		mov.L	156[r10], r4
 6049 0095 47 54                   		cmp	r5, r4
 6050 0097 15                      		beq	.L382
3900:../src/wolfcrypt/src/rsa.c ****             ret = PSS_SALTLEN_E;
 6051                             		.loc 2 3900 17
 6052 0098 F8 AA 06 FF             		mov.L	#-250, [r10]
 6053                             	.L382:
3901:../src/wolfcrypt/src/rsa.c ****         }
3902:../src/wolfcrypt/src/rsa.c ****     }
3903:../src/wolfcrypt/src/rsa.c **** 
3904:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_PSS_LONG_SALT
3905:../src/wolfcrypt/src/rsa.c ****     /* if long salt is larger then default maximum buffer then allocate a buffer */
3906:../src/wolfcrypt/src/rsa.c ****     if (ret == 0 && sizeof(sigCheckBuf) < (RSA_PSS_PAD_SZ + inSz + saltLen)) {
3907:../src/wolfcrypt/src/rsa.c ****         sigCheck = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inSz + saltLen, heap,
3908:../src/wolfcrypt/src/rsa.c ****                                                        DYNAMIC_TYPE_RSA_BUFFER);
3909:../src/wolfcrypt/src/rsa.c ****         if (sigCheck == NULL) {
3910:../src/wolfcrypt/src/rsa.c ****             ret = MEMORY_E;
3911:../src/wolfcrypt/src/rsa.c ****         }
3912:../src/wolfcrypt/src/rsa.c ****     }
3913:../src/wolfcrypt/src/rsa.c **** #endif
3914:../src/wolfcrypt/src/rsa.c **** 
3915:../src/wolfcrypt/src/rsa.c ****     /* Exp Hash = HASH(8 * 0x00 | Message Hash | Salt) */
3916:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 6054                             		.loc 2 3916 8
 6055 009c EC A5                   		mov.L	[r10], r5
 6056 009e 61 05                   		cmp	#0, r5
 6057 00a0 21 52                   		bne	.L383
3917:../src/wolfcrypt/src/rsa.c ****         XMEMSET(sigCheck, 0, RSA_PSS_PAD_SZ);
 6058                             		.loc 2 3917 9
 6059 00a2 66 83                   		mov.L	#8, r3
 6060 00a4 66 02                   		mov.L	#0, r2
 6061 00a6 ED A1 01                		mov.L	4[r10], r1
 6062 00a9 05 00 00 00             		bsr	_memset
3918:../src/wolfcrypt/src/rsa.c ****         XMEMCPY(sigCheck + RSA_PSS_PAD_SZ, in, inSz);
 6063                             		.loc 2 3918 9
 6064 00ad ED A5 01                		mov.L	4[r10], r5
 6065 00b0 62 85                   		add	#8, r5
 6066 00b2 ED A3 25                		mov.L	148[r10], r3
 6067 00b5 ED A2 24                		mov.L	144[r10], r2
 6068 00b8 EF 51                   		mov.L	r5, r1
 6069 00ba 05 00 00 00             		bsr	_memcpy
3919:../src/wolfcrypt/src/rsa.c ****         XMEMCPY(sigCheck + RSA_PSS_PAD_SZ + inSz, sig, saltLen);
 6070                             		.loc 2 3919 9
 6071 00be ED A5 25                		mov.L	148[r10], r5
 6072 00c1 62 85                   		add	#8, r5
 6073 00c3 ED A4 01                		mov.L	4[r10], r4
 6074 00c6 4B 45                   		add	r4, r5
 6075 00c8 A8 6C                   		mov.L	4[r6], r4
 6076 00ca EF 43                   		mov.L	r4, r3
 6077 00cc ED A2 26                		mov.L	152[r10], r2
 6078 00cf EF 51                   		mov.L	r5, r1
 6079 00d1 05 00 00 00             		bsr	_memcpy
3920:../src/wolfcrypt/src/rsa.c ****         ret = wc_Hash(hashType, sigCheck, RSA_PSS_PAD_SZ + inSz + saltLen,
 6080                             		.loc 2 3920 65
 6081 00d5 A8 6D                   		mov.L	4[r6], r5
 6082 00d7 06 89 A5 25             		add	148[r10].L, r5
 6083                             		.loc 2 3920 15
 6084 00db 62 85                   		add	#8, r5
 6085 00dd ED A4 25                		mov.L	148[r10], r4
 6086 00e0 E3 04                   		mov.L	r4, [r0]
 6087 00e2 ED A4 01                		mov.L	4[r10], r4
 6088 00e5 EF 53                   		mov.L	r5, r3
 6089 00e7 ED A2 01                		mov.L	4[r10], r2
 6090 00ea EC 61                   		mov.L	[r6], r1
 6091 00ec 05 00 00 00             		bsr	_wc_Hash
 6092 00f0 E3 A1                   		mov.L	r1, [r10]
 6093                             	.L383:
3921:../src/wolfcrypt/src/rsa.c ****                       sigCheck, inSz);
3922:../src/wolfcrypt/src/rsa.c ****     }
3923:../src/wolfcrypt/src/rsa.c ****     if (ret == 0) {
 6094                             		.loc 2 3923 8
 6095 00f2 EC A5                   		mov.L	[r10], r5
 6096 00f4 61 05                   		cmp	#0, r5
 6097 00f6 21 29                   		bne	.L384
3924:../src/wolfcrypt/src/rsa.c ****         if (XMEMCMP(sigCheck, sig + saltLen, inSz) != 0) {
 6098                             		.loc 2 3924 13
 6099 00f8 A8 6D                   		mov.L	4[r6], r5
 6100 00fa ED A4 26                		mov.L	152[r10], r4
 6101 00fd 4B 45                   		add	r4, r5
 6102 00ff ED A3 25                		mov.L	148[r10], r3
 6103 0102 EF 52                   		mov.L	r5, r2
 6104 0104 ED A1 01                		mov.L	4[r10], r1
 6105 0107 05 00 00 00             		bsr	_memcmp
 6106 010b EF 15                   		mov.L	r1, r5
 6107                             		.loc 2 3924 12
 6108 010d 61 05                   		cmp	#0, r5
 6109 010f 20 10                   		beq	.L384
3925:../src/wolfcrypt/src/rsa.c ****             WOLFSSL_MSG("RsaPSS_CheckPadding: Padding Error");
 6110                             		.loc 2 3925 13
 6111 0111 FB 12 D0 02 00 00       		mov.L	#.LC20, r1
 6112 0117 05 00 00 00             		bsr	_WOLFSSL_MSG
3926:../src/wolfcrypt/src/rsa.c ****             ret = BAD_PADDING_E;
 6113                             		.loc 2 3926 17
 6114 011b F8 AA 3F FF             		mov.L	#-193, [r10]
 6115                             	.L384:
3927:../src/wolfcrypt/src/rsa.c ****         }
3928:../src/wolfcrypt/src/rsa.c ****     }
3929:../src/wolfcrypt/src/rsa.c **** 
3930:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_PSS_LONG_SALT
3931:../src/wolfcrypt/src/rsa.c ****     if (sigCheck != NULL && sigCheck != sigCheckBuf) {
3932:../src/wolfcrypt/src/rsa.c ****         XFREE(sigCheck, heap, DYNAMIC_TYPE_RSA_BUFFER);
3933:../src/wolfcrypt/src/rsa.c ****     }
3934:../src/wolfcrypt/src/rsa.c **** #endif
3935:../src/wolfcrypt/src/rsa.c **** 
3936:../src/wolfcrypt/src/rsa.c ****     (void)heap; /* unused if memory is disabled */
3937:../src/wolfcrypt/src/rsa.c ****     return ret;
 6116                             		.loc 2 3937 12
 6117 011f EC A5                   		mov.L	[r10], r5
3938:../src/wolfcrypt/src/rsa.c **** }
 6118                             		.loc 2 3938 1
 6119 0121 EF 51                   		mov.L	r5, r1
 6120 0123 72 00 B4 00             		add	#0xb4, r0
 6121 0127 7E B6                   		pop	r6
 6122 0129 7E BA                   		pop	r10
 6123 012b 02                      		rts
 6124                             	.LFE78:
 6126 012c 76 10 01 00             		.section	.text.wc_RsaPSS_CheckPadding_ex,"ax",@progbits
 6127                             		.global	_wc_RsaPSS_CheckPadding_ex
 6129                             	_wc_RsaPSS_CheckPadding_ex:
 6130                             	.LFB79:
3939:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_CheckPadding_ex(const byte* in, word32 inSz, byte* sig,
3940:../src/wolfcrypt/src/rsa.c ****                                word32 sigSz, enum wc_HashType hashType,
3941:../src/wolfcrypt/src/rsa.c ****                                int saltLen, int bits)
3942:../src/wolfcrypt/src/rsa.c **** {
 6131                             		.loc 2 3942 1
 6132 0000 7E AA                   		push.l	r10
 6133                             	.LCFI140:
 6134 0002 71 0A E4                		add	#-28, r0, r10
 6135                             	.LCFI141:
 6136 0005 71 A0 F0                		add	#-16, r10, r0
 6137                             	.LCFI142:
 6138 0008 75 45 24                		mov.L	#36, r5
 6139 000b 4B A5                   		add	r10, r5
 6140 000d E3 A1                   		mov.L	r1, [r10]
 6141 000f E7 A2 01                		mov.L	r2, 4[r10]
 6142 0012 E7 A3 02                		mov.L	r3, 8[r10]
 6143 0015 E7 A4 03                		mov.L	r4, 12[r10]
3943:../src/wolfcrypt/src/rsa.c ****     return wc_RsaPSS_CheckPadding_ex2(in, inSz, sig, sigSz, hashType, saltLen,
 6144                             		.loc 2 3943 12
 6145 0018 3E 03 00                		mov.L	#0, 12[r0]
 6146 001b A8 D4                   		mov.L	8[r5], r4
 6147 001d A0 84                   		mov.L	r4, 8[r0]
 6148 001f A8 5C                   		mov.L	4[r5], r4
 6149 0021 A0 0C                   		mov.L	r4, 4[r0]
 6150 0023 EC 55                   		mov.L	[r5], r5
 6151 0025 E3 05                   		mov.L	r5, [r0]
 6152 0027 ED A4 03                		mov.L	12[r10], r4
 6153 002a ED A3 02                		mov.L	8[r10], r3
 6154 002d ED A2 01                		mov.L	4[r10], r2
 6155 0030 EC A1                   		mov.L	[r10], r1
 6156 0032 05 00 00 00             		bsr	_wc_RsaPSS_CheckPadding_ex2
 6157 0036 EF 15                   		mov.L	r1, r5
3944:../src/wolfcrypt/src/rsa.c ****         bits, NULL);
3945:../src/wolfcrypt/src/rsa.c **** }
 6158                             		.loc 2 3945 1
 6159 0038 EF 51                   		mov.L	r5, r1
 6160 003a 3F AA 0C                		rtsd	#48, r10-r10
 6161                             	.LFE79:
 6163                             		.section	.text.wc_RsaPSS_VerifyCheckInline,"ax",@progbits
 6164                             		.global	_wc_RsaPSS_VerifyCheckInline
 6166                             	_wc_RsaPSS_VerifyCheckInline:
 6167                             	.LFB80:
3946:../src/wolfcrypt/src/rsa.c **** 
3947:../src/wolfcrypt/src/rsa.c **** 
3948:../src/wolfcrypt/src/rsa.c **** /* Verify the message signed with RSA-PSS.
3949:../src/wolfcrypt/src/rsa.c ****  * The input buffer is reused for the output buffer.
3950:../src/wolfcrypt/src/rsa.c ****  * Salt length is equal to hash length.
3951:../src/wolfcrypt/src/rsa.c ****  *
3952:../src/wolfcrypt/src/rsa.c ****  * in     Buffer holding encrypted data.
3953:../src/wolfcrypt/src/rsa.c ****  * inLen  Length of data in buffer.
3954:../src/wolfcrypt/src/rsa.c ****  * out    Pointer to address containing the PSS data.
3955:../src/wolfcrypt/src/rsa.c ****  * digest Hash of the data that is being verified.
3956:../src/wolfcrypt/src/rsa.c ****  * digestLen Length of hash.
3957:../src/wolfcrypt/src/rsa.c ****  * hash   Hash algorithm.
3958:../src/wolfcrypt/src/rsa.c ****  * mgf    Mask generation function.
3959:../src/wolfcrypt/src/rsa.c ****  * key    Public RSA key.
3960:../src/wolfcrypt/src/rsa.c ****  * returns the length of the PSS data on success and negative indicates failure.
3961:../src/wolfcrypt/src/rsa.c ****  */
3962:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_VerifyCheckInline(byte* in, word32 inLen, byte** out,
3963:../src/wolfcrypt/src/rsa.c ****                            const byte* digest, word32 digestLen,
3964:../src/wolfcrypt/src/rsa.c ****                            enum wc_HashType hash, int mgf, RsaKey* key)
3965:../src/wolfcrypt/src/rsa.c **** {
 6168                             		.loc 2 3965 1
 6169 0000 7E AA                   		push.l	r10
 6170                             	.LCFI143:
 6171 0002 7E A6                   		push.l	r6
 6172                             	.LCFI144:
 6173 0004 71 0A CC                		add	#-52, r0, r10
 6174                             	.LCFI145:
 6175 0007 71 A0 F4                		add	#-12, r10, r0
 6176                             	.LCFI146:
 6177 000a 75 46 40                		mov.L	#0x40, r6
 6178 000d 4B A6                   		add	r10, r6
 6179 000f E7 A1 05                		mov.L	r1, 20[r10]
 6180 0012 E7 A2 06                		mov.L	r2, 24[r10]
 6181 0015 E7 A3 07                		mov.L	r3, 28[r10]
 6182 0018 E7 A4 08                		mov.L	r4, 32[r10]
3966:../src/wolfcrypt/src/rsa.c ****     int ret = 0, verify, saltLen, hLen, bits = 0;
 6183                             		.loc 2 3966 9
 6184 001b F8 A6 00                		mov.L	#0, [r10]
 6185                             		.loc 2 3966 41
 6186 001e F9 A6 02 00             		mov.L	#0, 8[r10]
3967:../src/wolfcrypt/src/rsa.c **** 
3968:../src/wolfcrypt/src/rsa.c ****     hLen = wc_HashGetDigestSize(hash);
 6187                             		.loc 2 3968 12
 6188 0022 A8 69                   		mov.L	4[r6], r1
 6189 0024 05 00 00 00             		bsr	_wc_HashGetDigestSize
 6190 0028 E7 A1 03                		mov.L	r1, 12[r10]
3969:../src/wolfcrypt/src/rsa.c ****     if (hLen < 0)
 6191                             		.loc 2 3969 8
 6192 002b ED A5 03                		mov.L	12[r10], r5
 6193 002e 61 05                   		cmp	#0, r5
 6194 0030 28 09                   		bge	.L389
3970:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 6195                             		.loc 2 3970 16
 6196 0032 FB 5A 53 FF             		mov.L	#-173, r5
 6197 0036 38 8B 00                		bra	.L390
 6198                             	.L389:
3971:../src/wolfcrypt/src/rsa.c ****     if ((word32)hLen != digestLen)
 6199                             		.loc 2 3971 22
 6200 0039 EC 65                   		mov.L	[r6], r5
 6201                             		.loc 2 3971 8
 6202 003b ED A4 03                		mov.L	12[r10], r4
 6203 003e 47 54                   		cmp	r5, r4
 6204 0040 17                      		beq	.L391
3972:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 6205                             		.loc 2 3972 16
 6206 0041 FB 5A 53 FF             		mov.L	#-173, r5
 6207 0045 2E 7C                   		bra	.L390
 6208                             	.L391:
3973:../src/wolfcrypt/src/rsa.c **** 
3974:../src/wolfcrypt/src/rsa.c ****     saltLen = hLen;
 6209                             		.loc 2 3974 13
 6210 0047 ED A5 03                		mov.L	12[r10], r5
 6211 004a E7 A5 01                		mov.L	r5, 4[r10]
3975:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_SHA512
3976:../src/wolfcrypt/src/rsa.c ****         /* See FIPS 186-4 section 5.5 item (e). */
3977:../src/wolfcrypt/src/rsa.c ****         bits = mp_count_bits(&key->n);
 6212                             		.loc 2 3977 30
 6213 004d A8 ED                   		mov.L	12[r6], r5
 6214                             		.loc 2 3977 16
 6215 004f EF 51                   		mov.L	r5, r1
 6216 0051 05 00 00 00             		bsr	_sp_count_bits
 6217 0055 E7 A1 02                		mov.L	r1, 8[r10]
3978:../src/wolfcrypt/src/rsa.c ****         if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE)
 6218                             		.loc 2 3978 12
 6219 0058 ED A5 02                		mov.L	8[r10], r5
 6220 005b 76 05 00 04             		cmp	#0x400, r5
 6221 005f 21 0D                   		bne	.L392
 6222                             		.loc 2 3978 26 discriminator 1
 6223 0061 ED A5 03                		mov.L	12[r10], r5
 6224 0064 75 55 40                		cmp	#0x40, r5
 6225 0067 1D                      		bne	.L392
3979:../src/wolfcrypt/src/rsa.c ****             saltLen = RSA_PSS_SALT_MAX_SZ;
 6226                             		.loc 2 3979 21
 6227 0068 F9 A6 01 3E             		mov.L	#62, 4[r10]
 6228                             	.L392:
3980:../src/wolfcrypt/src/rsa.c ****     #endif
3981:../src/wolfcrypt/src/rsa.c **** 
3982:../src/wolfcrypt/src/rsa.c ****     verify = wc_RsaPSS_VerifyInline_ex(in, inLen, out, hash, mgf, saltLen, key);
 6229                             		.loc 2 3982 14
 6230 006c A8 ED                   		mov.L	12[r6], r5
 6231 006e A0 85                   		mov.L	r5, 8[r0]
 6232 0070 ED A5 01                		mov.L	4[r10], r5
 6233 0073 A0 0D                   		mov.L	r5, 4[r0]
 6234 0075 A8 E5                   		mov.L	8[r6], r5
 6235 0077 E3 05                   		mov.L	r5, [r0]
 6236 0079 A8 6C                   		mov.L	4[r6], r4
 6237 007b ED A3 07                		mov.L	28[r10], r3
 6238 007e ED A2 06                		mov.L	24[r10], r2
 6239 0081 ED A1 05                		mov.L	20[r10], r1
 6240 0084 05 00 00 00             		bsr	_wc_RsaPSS_VerifyInline_ex
 6241 0088 E7 A1 04                		mov.L	r1, 16[r10]
3983:../src/wolfcrypt/src/rsa.c ****     if (verify > 0)
 6242                             		.loc 2 3983 8
 6243 008b ED A5 04                		mov.L	16[r10], r5
 6244 008e 61 05                   		cmp	#0, r5
 6245 0090 2B 25                   		ble	.L393
3984:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaPSS_CheckPadding_ex(digest, digestLen, *out, verify,
 6246                             		.loc 2 3984 15
 6247 0092 ED A5 07                		mov.L	28[r10], r5
 6248 0095 EC 55                   		mov.L	[r5], r5
 6249 0097 ED A4 04                		mov.L	16[r10], r4
 6250 009a ED A3 02                		mov.L	8[r10], r3
 6251 009d A0 83                   		mov.L	r3, 8[r0]
 6252 009f ED A3 01                		mov.L	4[r10], r3
 6253 00a2 A0 0B                   		mov.L	r3, 4[r0]
 6254 00a4 A8 6B                   		mov.L	4[r6], r3
 6255 00a6 E3 03                   		mov.L	r3, [r0]
 6256 00a8 EF 53                   		mov.L	r5, r3
 6257 00aa EC 62                   		mov.L	[r6], r2
 6258 00ac ED A1 08                		mov.L	32[r10], r1
 6259 00af 05 00 00 00             		bsr	_wc_RsaPSS_CheckPadding_ex
 6260 00b3 E3 A1                   		mov.L	r1, [r10]
 6261                             	.L393:
3985:../src/wolfcrypt/src/rsa.c ****                                         hash, saltLen, bits);
3986:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 6262                             		.loc 2 3986 8
 6263 00b5 EC A5                   		mov.L	[r10], r5
 6264 00b7 61 05                   		cmp	#0, r5
 6265 00b9 1E                      		bne	.L394
3987:../src/wolfcrypt/src/rsa.c ****         ret = verify;
 6266                             		.loc 2 3987 13
 6267 00ba ED A5 04                		mov.L	16[r10], r5
 6268 00bd E3 A5                   		mov.L	r5, [r10]
 6269                             	.L394:
3988:../src/wolfcrypt/src/rsa.c **** 
3989:../src/wolfcrypt/src/rsa.c ****     return ret;
 6270                             		.loc 2 3989 12
 6271 00bf EC A5                   		mov.L	[r10], r5
 6272                             	.L390:
3990:../src/wolfcrypt/src/rsa.c **** }
 6273                             		.loc 2 3990 1
 6274 00c1 EF 51                   		mov.L	r5, r1
 6275 00c3 71 00 40                		add	#0x40, r0
 6276 00c6 7E B6                   		pop	r6
 6277 00c8 7E BA                   		pop	r10
 6278 00ca 02                      		rts
 6279                             	.LFE80:
 6281                             		.section	.text.wc_RsaPSS_VerifyCheck,"ax",@progbits
 6282                             		.global	_wc_RsaPSS_VerifyCheck
 6284                             	_wc_RsaPSS_VerifyCheck:
 6285                             	.LFB81:
3991:../src/wolfcrypt/src/rsa.c **** 
3992:../src/wolfcrypt/src/rsa.c **** 
3993:../src/wolfcrypt/src/rsa.c **** /* Verify the message signed with RSA-PSS.
3994:../src/wolfcrypt/src/rsa.c ****  * Salt length is equal to hash length.
3995:../src/wolfcrypt/src/rsa.c ****  *
3996:../src/wolfcrypt/src/rsa.c ****  * in     Buffer holding encrypted data.
3997:../src/wolfcrypt/src/rsa.c ****  * inLen  Length of data in buffer.
3998:../src/wolfcrypt/src/rsa.c ****  * out    Pointer to address containing the PSS data.
3999:../src/wolfcrypt/src/rsa.c ****  * outLen Length of the output.
4000:../src/wolfcrypt/src/rsa.c ****  * digest Hash of the data that is being verified.
4001:../src/wolfcrypt/src/rsa.c ****  * digestLen Length of hash.
4002:../src/wolfcrypt/src/rsa.c ****  * hash   Hash algorithm.
4003:../src/wolfcrypt/src/rsa.c ****  * mgf    Mask generation function.
4004:../src/wolfcrypt/src/rsa.c ****  * key    Public RSA key.
4005:../src/wolfcrypt/src/rsa.c ****  * returns the length of the PSS data on success and negative indicates failure.
4006:../src/wolfcrypt/src/rsa.c ****  */
4007:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_VerifyCheck(byte* in, word32 inLen, byte* out, word32 outLen,
4008:../src/wolfcrypt/src/rsa.c ****                           const byte* digest, word32 digestLen,
4009:../src/wolfcrypt/src/rsa.c ****                           enum wc_HashType hash, int mgf,
4010:../src/wolfcrypt/src/rsa.c ****                           RsaKey* key)
4011:../src/wolfcrypt/src/rsa.c **** {
 6286                             		.loc 2 4011 1
 6287 0000 7E AA                   		push.l	r10
 6288                             	.LCFI147:
 6289 0002 7E A6                   		push.l	r6
 6290                             	.LCFI148:
 6291 0004 71 0A C8                		add	#-56, r0, r10
 6292                             	.LCFI149:
 6293 0007 71 A0 F0                		add	#-16, r10, r0
 6294                             	.LCFI150:
 6295 000a 75 46 44                		mov.L	#0x44, r6
 6296 000d 4B A6                   		add	r10, r6
 6297 000f E7 A1 05                		mov.L	r1, 20[r10]
 6298 0012 E7 A2 06                		mov.L	r2, 24[r10]
 6299 0015 E7 A3 07                		mov.L	r3, 28[r10]
 6300 0018 E7 A4 08                		mov.L	r4, 32[r10]
4012:../src/wolfcrypt/src/rsa.c ****     int ret = 0, verify, saltLen, hLen, bits = 0;
 6301                             		.loc 2 4012 9
 6302 001b F8 A6 00                		mov.L	#0, [r10]
 6303                             		.loc 2 4012 41
 6304 001e F9 A6 02 00             		mov.L	#0, 8[r10]
4013:../src/wolfcrypt/src/rsa.c **** 
4014:../src/wolfcrypt/src/rsa.c ****     hLen = wc_HashGetDigestSize(hash);
 6305                             		.loc 2 4014 12
 6306 0022 A8 E1                   		mov.L	8[r6], r1
 6307 0024 05 00 00 00             		bsr	_wc_HashGetDigestSize
 6308 0028 E7 A1 03                		mov.L	r1, 12[r10]
4015:../src/wolfcrypt/src/rsa.c ****     if (hLen < 0)
 6309                             		.loc 2 4015 8
 6310 002b ED A5 03                		mov.L	12[r10], r5
 6311 002e 61 05                   		cmp	#0, r5
 6312 0030 28 08                   		bge	.L396
4016:../src/wolfcrypt/src/rsa.c ****         return hLen;
 6313                             		.loc 2 4016 16
 6314 0032 ED A5 03                		mov.L	12[r10], r5
 6315 0035 38 8D 00                		bra	.L397
 6316                             	.L396:
4017:../src/wolfcrypt/src/rsa.c ****     if ((word32)hLen != digestLen)
 6317                             		.loc 2 4017 22
 6318 0038 A8 6D                   		mov.L	4[r6], r5
 6319                             		.loc 2 4017 8
 6320 003a ED A4 03                		mov.L	12[r10], r4
 6321 003d 47 54                   		cmp	r5, r4
 6322 003f 17                      		beq	.L398
4018:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 6323                             		.loc 2 4018 16
 6324 0040 FB 5A 53 FF             		mov.L	#-173, r5
 6325 0044 2E 7E                   		bra	.L397
 6326                             	.L398:
4019:../src/wolfcrypt/src/rsa.c **** 
4020:../src/wolfcrypt/src/rsa.c ****     saltLen = hLen;
 6327                             		.loc 2 4020 13
 6328 0046 ED A5 03                		mov.L	12[r10], r5
 6329 0049 E7 A5 01                		mov.L	r5, 4[r10]
4021:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_SHA512
4022:../src/wolfcrypt/src/rsa.c ****         /* See FIPS 186-4 section 5.5 item (e). */
4023:../src/wolfcrypt/src/rsa.c ****         bits = mp_count_bits(&key->n);
 6330                             		.loc 2 4023 30
 6331 004c A9 65                   		mov.L	16[r6], r5
 6332                             		.loc 2 4023 16
 6333 004e EF 51                   		mov.L	r5, r1
 6334 0050 05 00 00 00             		bsr	_sp_count_bits
 6335 0054 E7 A1 02                		mov.L	r1, 8[r10]
4024:../src/wolfcrypt/src/rsa.c ****         if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE)
 6336                             		.loc 2 4024 12
 6337 0057 ED A5 02                		mov.L	8[r10], r5
 6338 005a 76 05 00 04             		cmp	#0x400, r5
 6339 005e 21 0D                   		bne	.L399
 6340                             		.loc 2 4024 26 discriminator 1
 6341 0060 ED A5 03                		mov.L	12[r10], r5
 6342 0063 75 55 40                		cmp	#0x40, r5
 6343 0066 1D                      		bne	.L399
4025:../src/wolfcrypt/src/rsa.c ****             saltLen = RSA_PSS_SALT_MAX_SZ;
 6344                             		.loc 2 4025 21
 6345 0067 F9 A6 01 3E             		mov.L	#62, 4[r10]
 6346                             	.L399:
4026:../src/wolfcrypt/src/rsa.c ****     #endif
4027:../src/wolfcrypt/src/rsa.c **** 
4028:../src/wolfcrypt/src/rsa.c ****     verify = wc_RsaPSS_Verify_ex(in, inLen, out, outLen, hash,
 6347                             		.loc 2 4028 14
 6348 006b A9 65                   		mov.L	16[r6], r5
 6349 006d A0 8D                   		mov.L	r5, 12[r0]
 6350 006f ED A5 01                		mov.L	4[r10], r5
 6351 0072 A0 85                   		mov.L	r5, 8[r0]
 6352 0074 A8 ED                   		mov.L	12[r6], r5
 6353 0076 A0 0D                   		mov.L	r5, 4[r0]
 6354 0078 A8 E5                   		mov.L	8[r6], r5
 6355 007a E3 05                   		mov.L	r5, [r0]
 6356 007c ED A4 08                		mov.L	32[r10], r4
 6357 007f ED A3 07                		mov.L	28[r10], r3
 6358 0082 ED A2 06                		mov.L	24[r10], r2
 6359 0085 ED A1 05                		mov.L	20[r10], r1
 6360 0088 05 00 00 00             		bsr	_wc_RsaPSS_Verify_ex
 6361 008c E7 A1 04                		mov.L	r1, 16[r10]
4029:../src/wolfcrypt/src/rsa.c ****                                  mgf, saltLen, key);
4030:../src/wolfcrypt/src/rsa.c ****     if (verify > 0)
 6362                             		.loc 2 4030 8
 6363 008f ED A5 04                		mov.L	16[r10], r5
 6364 0092 61 05                   		cmp	#0, r5
 6365 0094 2B 22                   		ble	.L400
4031:../src/wolfcrypt/src/rsa.c ****         ret = wc_RsaPSS_CheckPadding_ex(digest, digestLen, out, verify,
 6366                             		.loc 2 4031 15
 6367 0096 ED A5 04                		mov.L	16[r10], r5
 6368 0099 ED A4 02                		mov.L	8[r10], r4
 6369 009c A0 84                   		mov.L	r4, 8[r0]
 6370 009e ED A4 01                		mov.L	4[r10], r4
 6371 00a1 A0 0C                   		mov.L	r4, 4[r0]
 6372 00a3 A8 E4                   		mov.L	8[r6], r4
 6373 00a5 E3 04                   		mov.L	r4, [r0]
 6374 00a7 EF 54                   		mov.L	r5, r4
 6375 00a9 ED A3 07                		mov.L	28[r10], r3
 6376 00ac A8 6A                   		mov.L	4[r6], r2
 6377 00ae EC 61                   		mov.L	[r6], r1
 6378 00b0 05 00 00 00             		bsr	_wc_RsaPSS_CheckPadding_ex
 6379 00b4 E3 A1                   		mov.L	r1, [r10]
 6380                             	.L400:
4032:../src/wolfcrypt/src/rsa.c ****                                         hash, saltLen, bits);
4033:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 6381                             		.loc 2 4033 8
 6382 00b6 EC A5                   		mov.L	[r10], r5
 6383 00b8 61 05                   		cmp	#0, r5
 6384 00ba 1E                      		bne	.L401
4034:../src/wolfcrypt/src/rsa.c ****         ret = verify;
 6385                             		.loc 2 4034 13
 6386 00bb ED A5 04                		mov.L	16[r10], r5
 6387 00be E3 A5                   		mov.L	r5, [r10]
 6388                             	.L401:
4035:../src/wolfcrypt/src/rsa.c **** 
4036:../src/wolfcrypt/src/rsa.c ****     return ret;
 6389                             		.loc 2 4036 12
 6390 00c0 EC A5                   		mov.L	[r10], r5
 6391                             	.L397:
4037:../src/wolfcrypt/src/rsa.c **** }
 6392                             		.loc 2 4037 1
 6393 00c2 EF 51                   		mov.L	r5, r1
 6394 00c4 71 00 48                		add	#0x48, r0
 6395 00c7 7E B6                   		pop	r6
 6396 00c9 7E BA                   		pop	r10
 6397 00cb 02                      		rts
 6398                             	.LFE81:
 6400                             		.section	.text.wc_RsaSSL_Sign,"ax",@progbits
 6401                             		.global	_wc_RsaSSL_Sign
 6403                             	_wc_RsaSSL_Sign:
 6404                             	.LFB82:
4038:../src/wolfcrypt/src/rsa.c **** 
4039:../src/wolfcrypt/src/rsa.c **** #endif
4040:../src/wolfcrypt/src/rsa.c **** 
4041:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
4042:../src/wolfcrypt/src/rsa.c **** int wc_RsaSSL_Sign(const byte* in, word32 inLen, byte* out, word32 outLen,
4043:../src/wolfcrypt/src/rsa.c ****                                                    RsaKey* key, WC_RNG* rng)
4044:../src/wolfcrypt/src/rsa.c **** {
 6405                             		.loc 2 4044 1
 6406 0000 7E AA                   		push.l	r10
 6407                             	.LCFI151:
 6408 0002 71 0A E4                		add	#-28, r0, r10
 6409                             	.LCFI152:
 6410 0005 71 A0 D8                		add	#-40, r10, r0
 6411                             	.LCFI153:
 6412 0008 75 45 24                		mov.L	#36, r5
 6413 000b 4B A5                   		add	r10, r5
 6414 000d E7 A1 01                		mov.L	r1, 4[r10]
 6415 0010 E7 A2 02                		mov.L	r2, 8[r10]
 6416 0013 E7 A3 03                		mov.L	r3, 12[r10]
 6417 0016 E7 A4 04                		mov.L	r4, 16[r10]
4045:../src/wolfcrypt/src/rsa.c ****     int ret;
4046:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
4047:../src/wolfcrypt/src/rsa.c ****     ret = RsaPublicEncryptEx(in, inLen, out, outLen, key,
 6418                             		.loc 2 4047 11
 6419 0019 A8 5C                   		mov.L	4[r5], r4
 6420 001b A2 0C                   		mov.L	r4, 36[r0]
 6421 001d 3E 08 00                		mov.L	#0, 32[r0]
 6422 0020 3E 07 00                		mov.L	#0, 28[r0]
 6423 0023 3E 06 00                		mov.L	#0, 24[r0]
 6424 0026 3E 05 00                		mov.L	#0, 20[r0]
 6425 0029 3E 04 00                		mov.L	#0, 16[r0]
 6426 002c 3E 03 00                		mov.L	#0, 12[r0]
 6427 002f 3C 08 01                		mov.B	#1, 8[r0]
 6428 0032 3E 01 02                		mov.L	#2, 4[r0]
 6429 0035 EC 55                   		mov.L	[r5], r5
 6430 0037 E3 05                   		mov.L	r5, [r0]
 6431 0039 ED A4 04                		mov.L	16[r10], r4
 6432 003c ED A3 03                		mov.L	12[r10], r3
 6433 003f ED A2 02                		mov.L	8[r10], r2
 6434 0042 ED A1 01                		mov.L	4[r10], r1
 6435 0045 05 00 00 00             		bsr	_RsaPublicEncryptEx
 6436 0049 E3 A1                   		mov.L	r1, [r10]
4048:../src/wolfcrypt/src/rsa.c ****         RSA_PRIVATE_ENCRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PKCSV15_PAD,
4049:../src/wolfcrypt/src/rsa.c ****         WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
4050:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
4051:../src/wolfcrypt/src/rsa.c ****     return ret;
 6437                             		.loc 2 4051 12
 6438 004b EC A5                   		mov.L	[r10], r5
4052:../src/wolfcrypt/src/rsa.c **** }
 6439                             		.loc 2 4052 1
 6440 004d EF 51                   		mov.L	r5, r1
 6441 004f 3F AA 12                		rtsd	#72, r10-r10
 6442                             	.LFE82:
 6444                             		.section	.text.wc_RsaPSS_Sign,"ax",@progbits
 6445                             		.global	_wc_RsaPSS_Sign
 6447                             	_wc_RsaPSS_Sign:
 6448                             	.LFB83:
4053:../src/wolfcrypt/src/rsa.c **** 
4054:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_PSS
4055:../src/wolfcrypt/src/rsa.c **** /* Sign the hash of a message using RSA-PSS.
4056:../src/wolfcrypt/src/rsa.c ****  * Salt length is equal to hash length.
4057:../src/wolfcrypt/src/rsa.c ****  *
4058:../src/wolfcrypt/src/rsa.c ****  * in      Buffer holding hash of message.
4059:../src/wolfcrypt/src/rsa.c ****  * inLen   Length of data in buffer (hash length).
4060:../src/wolfcrypt/src/rsa.c ****  * out     Buffer to write encrypted signature into.
4061:../src/wolfcrypt/src/rsa.c ****  * outLen  Size of buffer to write to.
4062:../src/wolfcrypt/src/rsa.c ****  * hash    Hash algorithm.
4063:../src/wolfcrypt/src/rsa.c ****  * mgf     Mask generation function.
4064:../src/wolfcrypt/src/rsa.c ****  * key     Public RSA key.
4065:../src/wolfcrypt/src/rsa.c ****  * rng     Random number generator.
4066:../src/wolfcrypt/src/rsa.c ****  * returns the length of the encrypted signature on success, a negative value
4067:../src/wolfcrypt/src/rsa.c ****  * indicates failure.
4068:../src/wolfcrypt/src/rsa.c ****  */
4069:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_Sign(const byte* in, word32 inLen, byte* out, word32 outLen,
4070:../src/wolfcrypt/src/rsa.c ****                        enum wc_HashType hash, int mgf, RsaKey* key, WC_RNG* rng)
4071:../src/wolfcrypt/src/rsa.c **** {
 6449                             		.loc 2 4071 1
 6450 0000 7E AA                   		push.l	r10
 6451                             	.LCFI154:
 6452 0002 71 0A E0                		add	#-32, r0, r10
 6453                             	.LCFI155:
 6454 0005 71 A0 EC                		add	#-20, r10, r0
 6455                             	.LCFI156:
 6456 0008 75 45 28                		mov.L	#40, r5
 6457 000b 4B A5                   		add	r10, r5
 6458 000d E3 A1                   		mov.L	r1, [r10]
 6459 000f E7 A2 01                		mov.L	r2, 4[r10]
 6460 0012 E7 A3 02                		mov.L	r3, 8[r10]
 6461 0015 E7 A4 03                		mov.L	r4, 12[r10]
4072:../src/wolfcrypt/src/rsa.c ****     return wc_RsaPSS_Sign_ex(in, inLen, out, outLen, hash, mgf,
 6462                             		.loc 2 4072 12
 6463 0018 A8 DC                   		mov.L	12[r5], r4
 6464 001a A1 04                   		mov.L	r4, 16[r0]
 6465 001c A8 D4                   		mov.L	8[r5], r4
 6466 001e A0 8C                   		mov.L	r4, 12[r0]
 6467 0020 F9 06 02 FF             		mov.L	#-1, 8[r0]
 6468 0024 A8 5C                   		mov.L	4[r5], r4
 6469 0026 A0 0C                   		mov.L	r4, 4[r0]
 6470 0028 EC 55                   		mov.L	[r5], r5
 6471 002a E3 05                   		mov.L	r5, [r0]
 6472 002c ED A4 03                		mov.L	12[r10], r4
 6473 002f ED A3 02                		mov.L	8[r10], r3
 6474 0032 ED A2 01                		mov.L	4[r10], r2
 6475 0035 EC A1                   		mov.L	[r10], r1
 6476 0037 05 00 00 00             		bsr	_wc_RsaPSS_Sign_ex
 6477 003b EF 15                   		mov.L	r1, r5
4073:../src/wolfcrypt/src/rsa.c ****                                             RSA_PSS_SALT_LEN_DEFAULT, key, rng);
4074:../src/wolfcrypt/src/rsa.c **** }
 6478                             		.loc 2 4074 1
 6479 003d EF 51                   		mov.L	r5, r1
 6480 003f 3F AA 0E                		rtsd	#56, r10-r10
 6481                             	.LFE83:
 6483                             		.section	.text.wc_RsaPSS_Sign_ex,"ax",@progbits
 6484                             		.global	_wc_RsaPSS_Sign_ex
 6486                             	_wc_RsaPSS_Sign_ex:
 6487                             	.LFB84:
4075:../src/wolfcrypt/src/rsa.c **** 
4076:../src/wolfcrypt/src/rsa.c **** /* Sign the hash of a message using RSA-PSS.
4077:../src/wolfcrypt/src/rsa.c ****  *
4078:../src/wolfcrypt/src/rsa.c ****  * in       Buffer holding hash of message.
4079:../src/wolfcrypt/src/rsa.c ****  * inLen    Length of data in buffer (hash length).
4080:../src/wolfcrypt/src/rsa.c ****  * out      Buffer to write encrypted signature into.
4081:../src/wolfcrypt/src/rsa.c ****  * outLen   Size of buffer to write to.
4082:../src/wolfcrypt/src/rsa.c ****  * hash     Hash algorithm.
4083:../src/wolfcrypt/src/rsa.c ****  * mgf      Mask generation function.
4084:../src/wolfcrypt/src/rsa.c ****  * saltLen  Length of salt used. RSA_PSS_SALT_LEN_DEFAULT (-1) indicates salt
4085:../src/wolfcrypt/src/rsa.c ****  *          length is the same as the hash length. RSA_PSS_SALT_LEN_DISCOVER
4086:../src/wolfcrypt/src/rsa.c ****  *          indicates salt length is determined from the data.
4087:../src/wolfcrypt/src/rsa.c ****  * key      Public RSA key.
4088:../src/wolfcrypt/src/rsa.c ****  * rng      Random number generator.
4089:../src/wolfcrypt/src/rsa.c ****  * returns the length of the encrypted signature on success, a negative value
4090:../src/wolfcrypt/src/rsa.c ****  * indicates failure.
4091:../src/wolfcrypt/src/rsa.c ****  */
4092:../src/wolfcrypt/src/rsa.c **** int wc_RsaPSS_Sign_ex(const byte* in, word32 inLen, byte* out, word32 outLen,
4093:../src/wolfcrypt/src/rsa.c ****                       enum wc_HashType hash, int mgf, int saltLen, RsaKey* key,
4094:../src/wolfcrypt/src/rsa.c ****                       WC_RNG* rng)
4095:../src/wolfcrypt/src/rsa.c **** {
 6488                             		.loc 2 4095 1
 6489 0000 7E AA                   		push.l	r10
 6490                             	.LCFI157:
 6491 0002 71 0A D8                		add	#-40, r0, r10
 6492                             	.LCFI158:
 6493 0005 71 A0 D8                		add	#-40, r10, r0
 6494                             	.LCFI159:
 6495 0008 75 45 30                		mov.L	#48, r5
 6496 000b 4B A5                   		add	r10, r5
 6497 000d E7 A1 01                		mov.L	r1, 4[r10]
 6498 0010 E7 A2 02                		mov.L	r2, 8[r10]
 6499 0013 E7 A3 03                		mov.L	r3, 12[r10]
 6500 0016 E7 A4 04                		mov.L	r4, 16[r10]
4096:../src/wolfcrypt/src/rsa.c ****     int ret;
4097:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
4098:../src/wolfcrypt/src/rsa.c ****     ret = RsaPublicEncryptEx(in, inLen, out, outLen, key,
 6501                             		.loc 2 4098 11
 6502 0019 A9 54                   		mov.L	16[r5], r4
 6503 001b A2 0C                   		mov.L	r4, 36[r0]
 6504 001d A8 D4                   		mov.L	8[r5], r4
 6505 001f A2 04                   		mov.L	r4, 32[r0]
 6506 0021 3E 07 00                		mov.L	#0, 28[r0]
 6507 0024 3E 06 00                		mov.L	#0, 24[r0]
 6508 0027 A8 5C                   		mov.L	4[r5], r4
 6509 0029 A1 0C                   		mov.L	r4, 20[r0]
 6510 002b EC 54                   		mov.L	[r5], r4
 6511 002d A1 04                   		mov.L	r4, 16[r0]
 6512 002f 3E 03 02                		mov.L	#2, 12[r0]
 6513 0032 3C 08 01                		mov.B	#1, 8[r0]
 6514 0035 3E 01 02                		mov.L	#2, 4[r0]
 6515 0038 A8 DD                   		mov.L	12[r5], r5
 6516 003a E3 05                   		mov.L	r5, [r0]
 6517 003c ED A4 04                		mov.L	16[r10], r4
 6518 003f ED A3 03                		mov.L	12[r10], r3
 6519 0042 ED A2 02                		mov.L	8[r10], r2
 6520 0045 ED A1 01                		mov.L	4[r10], r1
 6521 0048 05 00 00 00             		bsr	_RsaPublicEncryptEx
 6522 004c E3 A1                   		mov.L	r1, [r10]
4099:../src/wolfcrypt/src/rsa.c ****         RSA_PRIVATE_ENCRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PSS_PAD,
4100:../src/wolfcrypt/src/rsa.c ****         hash, mgf, NULL, 0, saltLen, rng);
4101:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
4102:../src/wolfcrypt/src/rsa.c ****     return ret;
 6523                             		.loc 2 4102 12
 6524 004e EC A5                   		mov.L	[r10], r5
4103:../src/wolfcrypt/src/rsa.c **** }
 6525                             		.loc 2 4103 1
 6526 0050 EF 51                   		mov.L	r5, r1
 6527 0052 3F AA 15                		rtsd	#84, r10-r10
 6528                             	.LFE84:
 6530                             		.section	.text.wc_RsaEncryptSize,"ax",@progbits
 6531                             		.global	_wc_RsaEncryptSize
 6533                             	_wc_RsaEncryptSize:
 6534                             	.LFB85:
4104:../src/wolfcrypt/src/rsa.c **** #endif
4105:../src/wolfcrypt/src/rsa.c **** #endif
4106:../src/wolfcrypt/src/rsa.c **** 
4107:../src/wolfcrypt/src/rsa.c **** int wc_RsaEncryptSize(const RsaKey* key)
4108:../src/wolfcrypt/src/rsa.c **** {
 6535                             		.loc 2 4108 1
 6536 0000 7E AA                   		push.l	r10
 6537                             	.LCFI160:
 6538 0002 71 0A F8                		add	#-8, r0, r10
 6539                             	.LCFI161:
 6540 0005 EF A0                   		mov.L	r10, r0
 6541 0007 E7 A1 01                		mov.L	r1, 4[r10]
4109:../src/wolfcrypt/src/rsa.c ****     int ret;
4110:../src/wolfcrypt/src/rsa.c **** 
4111:../src/wolfcrypt/src/rsa.c ****     if (key == NULL) {
 6542                             		.loc 2 4111 8
 6543 000a ED A5 01                		mov.L	4[r10], r5
 6544 000d 61 05                   		cmp	#0, r5
 6545 000f 1F                      		bne	.L409
4112:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 6546                             		.loc 2 4112 16
 6547 0010 FB 5A 53 FF             		mov.L	#-173, r5
 6548 0014 2E 0F                   		bra	.L410
 6549                             	.L409:
4113:../src/wolfcrypt/src/rsa.c ****     }
4114:../src/wolfcrypt/src/rsa.c **** 
4115:../src/wolfcrypt/src/rsa.c ****     ret = mp_unsigned_bin_size(&key->n);
 6550                             		.loc 2 4115 32
 6551 0016 ED A5 01                		mov.L	4[r10], r5
 6552                             		.loc 2 4115 11
 6553 0019 EF 51                   		mov.L	r5, r1
 6554 001b 05 00 00 00             		bsr	_sp_unsigned_bin_size
 6555 001f E3 A1                   		mov.L	r1, [r10]
4116:../src/wolfcrypt/src/rsa.c **** 
4117:../src/wolfcrypt/src/rsa.c **** #ifdef WOLF_CRYPTO_CB
4118:../src/wolfcrypt/src/rsa.c ****     if (ret == 0 && key->devId != INVALID_DEVID) {
4119:../src/wolfcrypt/src/rsa.c ****         ret = 2048/8; /* hardware handles, use 2048-bit as default */
4120:../src/wolfcrypt/src/rsa.c ****     }
4121:../src/wolfcrypt/src/rsa.c **** #endif
4122:../src/wolfcrypt/src/rsa.c **** 
4123:../src/wolfcrypt/src/rsa.c ****     return ret;
 6556                             		.loc 2 4123 12
 6557 0021 EC A5                   		mov.L	[r10], r5
 6558                             	.L410:
4124:../src/wolfcrypt/src/rsa.c **** }
 6559                             		.loc 2 4124 1
 6560 0023 EF 51                   		mov.L	r5, r1
 6561 0025 3F AA 03                		rtsd	#12, r10-r10
 6562                             	.LFE85:
 6564                             		.section	.text.wc_RsaFlattenPublicKey,"ax",@progbits
 6565                             		.global	_wc_RsaFlattenPublicKey
 6567                             	_wc_RsaFlattenPublicKey:
 6568                             	.LFB86:
4125:../src/wolfcrypt/src/rsa.c **** 
4126:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
4127:../src/wolfcrypt/src/rsa.c **** /* flatten RsaKey structure into individual elements (e, n) */
4128:../src/wolfcrypt/src/rsa.c **** int wc_RsaFlattenPublicKey(RsaKey* key, byte* e, word32* eSz, byte* n,
4129:../src/wolfcrypt/src/rsa.c ****                                                                    word32* nSz)
4130:../src/wolfcrypt/src/rsa.c **** {
 6569                             		.loc 2 4130 1
 6570 0000 7E AA                   		push.l	r10
 6571                             	.LCFI162:
 6572 0002 7E A6                   		push.l	r6
 6573                             	.LCFI163:
 6574 0004 71 0A E4                		add	#-28, r0, r10
 6575                             	.LCFI164:
 6576 0007 EF A0                   		mov.L	r10, r0
 6577 0009 75 46 28                		mov.L	#40, r6
 6578 000c 4B A6                   		add	r10, r6
 6579 000e E7 A1 02                		mov.L	r1, 8[r10]
 6580 0011 E7 A2 03                		mov.L	r2, 12[r10]
 6581 0014 E7 A3 04                		mov.L	r3, 16[r10]
 6582 0017 E7 A4 05                		mov.L	r4, 20[r10]
4131:../src/wolfcrypt/src/rsa.c ****     int sz, ret;
4132:../src/wolfcrypt/src/rsa.c **** 
4133:../src/wolfcrypt/src/rsa.c ****     if (key == NULL || e == NULL || eSz == NULL || n == NULL || nSz == NULL) {
 6583                             		.loc 2 4133 8
 6584 001a ED A5 02                		mov.L	8[r10], r5
 6585 001d 61 05                   		cmp	#0, r5
 6586 001f 20 1B                   		beq	.L412
 6587                             		.loc 2 4133 21 discriminator 1
 6588 0021 ED A5 03                		mov.L	12[r10], r5
 6589 0024 61 05                   		cmp	#0, r5
 6590 0026 20 14                   		beq	.L412
 6591                             		.loc 2 4133 34 discriminator 2
 6592 0028 ED A5 04                		mov.L	16[r10], r5
 6593 002b 61 05                   		cmp	#0, r5
 6594 002d 20 0D                   		beq	.L412
 6595                             		.loc 2 4133 49 discriminator 3
 6596 002f ED A5 05                		mov.L	20[r10], r5
 6597 0032 61 05                   		cmp	#0, r5
 6598 0034 16                      		beq	.L412
 6599                             		.loc 2 4133 62 discriminator 4
 6600 0035 EC 65                   		mov.L	[r6], r5
 6601 0037 61 05                   		cmp	#0, r5
 6602 0039 18                      		bne	.L413
 6603                             		.balign 8,3,2
 6604                             	.L412:
4134:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 6605                             		.loc 2 4134 16
 6606 003a FB 5A 53 FF             		mov.L	#-173, r5
 6607 003e 38 82 00                		bra	.L414
 6608                             	.L413:
4135:../src/wolfcrypt/src/rsa.c ****     }
4136:../src/wolfcrypt/src/rsa.c **** 
4137:../src/wolfcrypt/src/rsa.c ****     sz = mp_unsigned_bin_size(&key->e);
 6609                             		.loc 2 4137 31
 6610 0041 ED A5 02                		mov.L	8[r10], r5
 6611 0044 72 55 10 03             		add	#0x310, r5
 6612                             		.loc 2 4137 10
 6613 0048 EF 51                   		mov.L	r5, r1
 6614 004a 05 00 00 00             		bsr	_sp_unsigned_bin_size
 6615 004e E3 A1                   		mov.L	r1, [r10]
4138:../src/wolfcrypt/src/rsa.c ****     if ((word32)sz > *eSz)
 6616                             		.loc 2 4138 22
 6617 0050 ED A5 04                		mov.L	16[r10], r5
 6618 0053 EC 54                   		mov.L	[r5], r4
 6619                             		.loc 2 4138 20
 6620 0055 EC A5                   		mov.L	[r10], r5
 6621                             		.loc 2 4138 8
 6622 0057 47 54                   		cmp	r5, r4
 6623 0059 22 08                   		bgeu	.L415
4139:../src/wolfcrypt/src/rsa.c ****         return RSA_BUFFER_E;
 6624                             		.loc 2 4139 16
 6625 005b FB 5A 7D FF             		mov.L	#-131, r5
 6626 005f 2E 61                   		bra	.L414
 6627                             	.L415:
4140:../src/wolfcrypt/src/rsa.c ****     ret = mp_to_unsigned_bin(&key->e, e);
 6628                             		.loc 2 4140 30
 6629 0061 ED A5 02                		mov.L	8[r10], r5
 6630 0064 72 55 10 03             		add	#0x310, r5
 6631                             		.loc 2 4140 11
 6632 0068 ED A2 03                		mov.L	12[r10], r2
 6633 006b EF 51                   		mov.L	r5, r1
 6634 006d 05 00 00 00             		bsr	_sp_to_unsigned_bin
 6635 0071 E7 A1 01                		mov.L	r1, 4[r10]
4141:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY)
 6636                             		.loc 2 4141 8
 6637 0074 ED A5 01                		mov.L	4[r10], r5
 6638 0077 61 05                   		cmp	#0, r5
 6639 0079 16                      		beq	.L416
4142:../src/wolfcrypt/src/rsa.c ****         return ret;
 6640                             		.loc 2 4142 16
 6641 007a ED A5 01                		mov.L	4[r10], r5
 6642 007d 2E 43                   		bra	.L414
 6643                             	.L416:
4143:../src/wolfcrypt/src/rsa.c ****     *eSz = (word32)sz;
 6644                             		.loc 2 4143 12
 6645 007f EC A4                   		mov.L	[r10], r4
 6646                             		.loc 2 4143 10
 6647 0081 ED A5 04                		mov.L	16[r10], r5
 6648 0084 E3 54                   		mov.L	r4, [r5]
4144:../src/wolfcrypt/src/rsa.c **** 
4145:../src/wolfcrypt/src/rsa.c ****     sz = wc_RsaEncryptSize(key);
 6649                             		.loc 2 4145 10
 6650 0086 ED A1 02                		mov.L	8[r10], r1
 6651 0089 05 00 00 00             		bsr	_wc_RsaEncryptSize
 6652 008d E3 A1                   		mov.L	r1, [r10]
4146:../src/wolfcrypt/src/rsa.c ****     if ((word32)sz > *nSz)
 6653                             		.loc 2 4146 22
 6654 008f EC 65                   		mov.L	[r6], r5
 6655 0091 EC 54                   		mov.L	[r5], r4
 6656                             		.loc 2 4146 20
 6657 0093 EC A5                   		mov.L	[r10], r5
 6658                             		.loc 2 4146 8
 6659 0095 47 54                   		cmp	r5, r4
 6660 0097 22 08                   		bgeu	.L417
4147:../src/wolfcrypt/src/rsa.c ****         return RSA_BUFFER_E;
 6661                             		.loc 2 4147 16
 6662 0099 FB 5A 7D FF             		mov.L	#-131, r5
 6663 009d 2E 23                   		bra	.L414
 6664                             	.L417:
4148:../src/wolfcrypt/src/rsa.c ****     ret = mp_to_unsigned_bin(&key->n, n);
 6665                             		.loc 2 4148 30
 6666 009f ED A5 02                		mov.L	8[r10], r5
 6667                             		.loc 2 4148 11
 6668 00a2 ED A2 05                		mov.L	20[r10], r2
 6669 00a5 EF 51                   		mov.L	r5, r1
 6670 00a7 05 00 00 00             		bsr	_sp_to_unsigned_bin
 6671 00ab E7 A1 01                		mov.L	r1, 4[r10]
4149:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY)
 6672                             		.loc 2 4149 8
 6673 00ae ED A5 01                		mov.L	4[r10], r5
 6674 00b1 61 05                   		cmp	#0, r5
 6675 00b3 15                      		beq	.L418
4150:../src/wolfcrypt/src/rsa.c ****         return ret;
 6676                             		.loc 2 4150 16
 6677 00b4 ED A5 01                		mov.L	4[r10], r5
 6678 00b7 09                      		bra	.L414
 6679                             	.L418:
4151:../src/wolfcrypt/src/rsa.c ****     *nSz = (word32)sz;
 6680                             		.loc 2 4151 12
 6681 00b8 EC A4                   		mov.L	[r10], r4
 6682                             		.loc 2 4151 10
 6683 00ba EC 65                   		mov.L	[r6], r5
 6684 00bc E3 54                   		mov.L	r4, [r5]
4152:../src/wolfcrypt/src/rsa.c **** 
4153:../src/wolfcrypt/src/rsa.c ****     return 0;
 6685                             		.loc 2 4153 12
 6686 00be 66 05                   		mov.L	#0, r5
 6687                             		.balign 8,3,1
 6688                             	.L414:
4154:../src/wolfcrypt/src/rsa.c **** }
 6689                             		.loc 2 4154 1
 6690 00c0 EF 51                   		mov.L	r5, r1
 6691 00c2 71 00 1C                		add	#28, r0
 6692 00c5 7E B6                   		pop	r6
 6693 00c7 7E BA                   		pop	r10
 6694 00c9 02                      		rts
 6695                             	.LFE86:
 6697 00ca 74 10 01 00 00 00       		.section	.text.RsaGetValue,"ax",@progbits
 6699                             	_RsaGetValue:
 6700                             	.LFB87:
4155:../src/wolfcrypt/src/rsa.c **** #endif
4156:../src/wolfcrypt/src/rsa.c **** 
4157:../src/wolfcrypt/src/rsa.c **** #endif /* HAVE_FIPS */
4158:../src/wolfcrypt/src/rsa.c **** 
4159:../src/wolfcrypt/src/rsa.c **** 
4160:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_VERIFY_ONLY
4161:../src/wolfcrypt/src/rsa.c **** static int RsaGetValue(mp_int* in, byte* out, word32* outSz)
4162:../src/wolfcrypt/src/rsa.c **** {
 6701                             		.loc 2 4162 1
 6702 0000 7E AA                   		push.l	r10
 6703                             	.LCFI165:
 6704 0002 71 0A EC                		add	#-20, r0, r10
 6705                             	.LCFI166:
 6706 0005 EF A0                   		mov.L	r10, r0
 6707 0007 E7 A1 02                		mov.L	r1, 8[r10]
 6708 000a E7 A2 03                		mov.L	r2, 12[r10]
 6709 000d E7 A3 04                		mov.L	r3, 16[r10]
4163:../src/wolfcrypt/src/rsa.c ****     word32 sz;
4164:../src/wolfcrypt/src/rsa.c ****     int ret = 0;
 6710                             		.loc 2 4164 9
 6711 0010 F8 A6 00                		mov.L	#0, [r10]
4165:../src/wolfcrypt/src/rsa.c **** 
4166:../src/wolfcrypt/src/rsa.c ****     /* Parameters ensured by calling function. */
4167:../src/wolfcrypt/src/rsa.c **** 
4168:../src/wolfcrypt/src/rsa.c ****     sz = (word32)mp_unsigned_bin_size(in);
 6712                             		.loc 2 4168 18
 6713 0013 ED A1 02                		mov.L	8[r10], r1
 6714 0016 05 00 00 00             		bsr	_sp_unsigned_bin_size
 6715 001a EF 15                   		mov.L	r1, r5
 6716                             		.loc 2 4168 8
 6717 001c E7 A5 01                		mov.L	r5, 4[r10]
4169:../src/wolfcrypt/src/rsa.c ****     if (sz > *outSz)
 6718                             		.loc 2 4169 14
 6719 001f ED A5 04                		mov.L	16[r10], r5
 6720 0022 EC 55                   		mov.L	[r5], r5
 6721                             		.loc 2 4169 8
 6722 0024 ED A4 01                		mov.L	4[r10], r4
 6723 0027 47 54                   		cmp	r5, r4
 6724 0029 25 06                   		bleu	.L420
4170:../src/wolfcrypt/src/rsa.c ****         ret = RSA_BUFFER_E;
 6725                             		.loc 2 4170 13
 6726 002b F8 AA 7D FF             		mov.L	#-131, [r10]
 6727                             	.L420:
4171:../src/wolfcrypt/src/rsa.c **** 
4172:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 6728                             		.loc 2 4172 8
 6729 002f EC A5                   		mov.L	[r10], r5
 6730 0031 61 05                   		cmp	#0, r5
 6731 0033 21 0E                   		bne	.L421
4173:../src/wolfcrypt/src/rsa.c ****         ret = mp_to_unsigned_bin(in, out);
 6732                             		.loc 2 4173 15
 6733 0035 ED A2 03                		mov.L	12[r10], r2
 6734 0038 ED A1 02                		mov.L	8[r10], r1
 6735 003b 05 00 00 00             		bsr	_sp_to_unsigned_bin
 6736 003f E3 A1                   		mov.L	r1, [r10]
 6737                             	.L421:
4174:../src/wolfcrypt/src/rsa.c **** 
4175:../src/wolfcrypt/src/rsa.c ****     if (ret == MP_OKAY)
 6738                             		.loc 2 4175 8
 6739 0041 EC A5                   		mov.L	[r10], r5
 6740 0043 61 05                   		cmp	#0, r5
 6741 0045 19                      		bne	.L422
4176:../src/wolfcrypt/src/rsa.c ****         *outSz = sz;
 6742                             		.loc 2 4176 16
 6743 0046 ED A5 04                		mov.L	16[r10], r5
 6744 0049 ED A4 01                		mov.L	4[r10], r4
 6745 004c E3 54                   		mov.L	r4, [r5]
 6746                             	.L422:
4177:../src/wolfcrypt/src/rsa.c **** 
4178:../src/wolfcrypt/src/rsa.c ****     return ret;
 6747                             		.loc 2 4178 12
 6748 004e EC A5                   		mov.L	[r10], r5
4179:../src/wolfcrypt/src/rsa.c **** }
 6749                             		.loc 2 4179 1
 6750 0050 EF 51                   		mov.L	r5, r1
 6751 0052 3F AA 06                		rtsd	#24, r10-r10
 6752                             	.LFE87:
 6754                             		.section	.text.wc_RsaExportKey,"ax",@progbits
 6755                             		.global	_wc_RsaExportKey
 6757                             	_wc_RsaExportKey:
 6758                             	.LFB88:
4180:../src/wolfcrypt/src/rsa.c **** 
4181:../src/wolfcrypt/src/rsa.c **** 
4182:../src/wolfcrypt/src/rsa.c **** int wc_RsaExportKey(RsaKey* key,
4183:../src/wolfcrypt/src/rsa.c ****                     byte* e, word32* eSz, byte* n, word32* nSz,
4184:../src/wolfcrypt/src/rsa.c ****                     byte* d, word32* dSz, byte* p, word32* pSz,
4185:../src/wolfcrypt/src/rsa.c ****                     byte* q, word32* qSz)
4186:../src/wolfcrypt/src/rsa.c **** {
 6759                             		.loc 2 4186 1
 6760 0000 7E AA                   		push.l	r10
 6761                             	.LCFI167:
 6762 0002 7E A6                   		push.l	r6
 6763                             	.LCFI168:
 6764 0004 71 0A D0                		add	#-48, r0, r10
 6765                             	.LCFI169:
 6766 0007 EF A0                   		mov.L	r10, r0
 6767 0009 75 46 3C                		mov.L	#60, r6
 6768 000c 4B A6                   		add	r10, r6
 6769 000e E7 A1 01                		mov.L	r1, 4[r10]
 6770 0011 E7 A2 02                		mov.L	r2, 8[r10]
 6771 0014 E7 A3 03                		mov.L	r3, 12[r10]
 6772 0017 E7 A4 04                		mov.L	r4, 16[r10]
4187:../src/wolfcrypt/src/rsa.c ****     int ret = BAD_FUNC_ARG;
 6773                             		.loc 2 4187 9
 6774 001a F8 AA 53 FF             		mov.L	#-173, [r10]
4188:../src/wolfcrypt/src/rsa.c **** 
4189:../src/wolfcrypt/src/rsa.c ****     if (key && e && eSz && n && nSz && d && dSz && p && pSz && q && qSz)
 6775                             		.loc 2 4189 8
 6776 001e ED A5 01                		mov.L	4[r10], r5
 6777 0021 61 05                   		cmp	#0, r5
 6778 0023 20 42                   		beq	.L425
 6779                             		.loc 2 4189 13 discriminator 1
 6780 0025 ED A5 02                		mov.L	8[r10], r5
 6781 0028 61 05                   		cmp	#0, r5
 6782 002a 20 3B                   		beq	.L425
 6783                             		.loc 2 4189 18 discriminator 2
 6784 002c ED A5 03                		mov.L	12[r10], r5
 6785 002f 61 05                   		cmp	#0, r5
 6786 0031 20 34                   		beq	.L425
 6787                             		.loc 2 4189 25 discriminator 3
 6788 0033 ED A5 04                		mov.L	16[r10], r5
 6789 0036 61 05                   		cmp	#0, r5
 6790 0038 20 2D                   		beq	.L425
 6791                             		.loc 2 4189 30 discriminator 4
 6792 003a EC 65                   		mov.L	[r6], r5
 6793 003c 61 05                   		cmp	#0, r5
 6794 003e 20 27                   		beq	.L425
 6795                             		.loc 2 4189 37 discriminator 5
 6796 0040 A8 6D                   		mov.L	4[r6], r5
 6797 0042 61 05                   		cmp	#0, r5
 6798 0044 20 21                   		beq	.L425
 6799                             		.loc 2 4189 42 discriminator 6
 6800 0046 A8 E5                   		mov.L	8[r6], r5
 6801 0048 61 05                   		cmp	#0, r5
 6802 004a 20 1B                   		beq	.L425
 6803                             		.loc 2 4189 49 discriminator 7
 6804 004c A8 ED                   		mov.L	12[r6], r5
 6805 004e 61 05                   		cmp	#0, r5
 6806 0050 20 15                   		beq	.L425
 6807                             		.loc 2 4189 54 discriminator 8
 6808 0052 A9 65                   		mov.L	16[r6], r5
 6809 0054 61 05                   		cmp	#0, r5
 6810 0056 20 0F                   		beq	.L425
 6811                             		.loc 2 4189 61 discriminator 9
 6812 0058 A9 6D                   		mov.L	20[r6], r5
 6813 005a 61 05                   		cmp	#0, r5
 6814 005c 11                      		beq	.L425
 6815                             		.loc 2 4189 66 discriminator 10
 6816 005d A9 E5                   		mov.L	24[r6], r5
 6817 005f 61 05                   		cmp	#0, r5
 6818 0061 14                      		beq	.L425
4190:../src/wolfcrypt/src/rsa.c ****         ret = 0;
 6819                             		.loc 2 4190 13
 6820 0062 F8 A6 00                		mov.L	#0, [r10]
 6821                             		.balign 8,3,1
 6822                             	.L425:
4191:../src/wolfcrypt/src/rsa.c **** 
4192:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 6823                             		.loc 2 4192 8
 6824 0065 EC A5                   		mov.L	[r10], r5
 6825 0067 61 05                   		cmp	#0, r5
 6826 0069 21 17                   		bne	.L426
4193:../src/wolfcrypt/src/rsa.c ****         ret = RsaGetValue(&key->e, e, eSz);
 6827                             		.loc 2 4193 15
 6828 006b ED A5 01                		mov.L	4[r10], r5
 6829 006e 72 55 10 03             		add	#0x310, r5
 6830 0072 ED A3 03                		mov.L	12[r10], r3
 6831 0075 ED A2 02                		mov.L	8[r10], r2
 6832 0078 EF 51                   		mov.L	r5, r1
 6833 007a 05 00 00 00             		bsr	_RsaGetValue
 6834 007e E3 A1                   		mov.L	r1, [r10]
 6835                             	.L426:
4194:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 6836                             		.loc 2 4194 8
 6837 0080 EC A5                   		mov.L	[r10], r5
 6838 0082 61 05                   		cmp	#0, r5
 6839 0084 21 12                   		bne	.L427
4195:../src/wolfcrypt/src/rsa.c ****         ret = RsaGetValue(&key->n, n, nSz);
 6840                             		.loc 2 4195 15
 6841 0086 ED A5 01                		mov.L	4[r10], r5
 6842 0089 EC 63                   		mov.L	[r6], r3
 6843 008b ED A2 04                		mov.L	16[r10], r2
 6844 008e EF 51                   		mov.L	r5, r1
 6845 0090 05 00 00 00             		bsr	_RsaGetValue
 6846 0094 E3 A1                   		mov.L	r1, [r10]
 6847                             	.L427:
4196:../src/wolfcrypt/src/rsa.c **** #ifndef WOLFSSL_RSA_PUBLIC_ONLY
4197:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 6848                             		.loc 2 4197 8
 6849 0096 EC A5                   		mov.L	[r10], r5
 6850 0098 61 05                   		cmp	#0, r5
 6851 009a 21 15                   		bne	.L428
4198:../src/wolfcrypt/src/rsa.c ****         ret = RsaGetValue(&key->d, d, dSz);
 6852                             		.loc 2 4198 15
 6853 009c ED A5 01                		mov.L	4[r10], r5
 6854 009f 72 55 20 06             		add	#0x620, r5
 6855 00a3 A8 E3                   		mov.L	8[r6], r3
 6856 00a5 A8 6A                   		mov.L	4[r6], r2
 6857 00a7 EF 51                   		mov.L	r5, r1
 6858 00a9 05 00 00 00             		bsr	_RsaGetValue
 6859 00ad E3 A1                   		mov.L	r1, [r10]
 6860                             	.L428:
4199:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 6861                             		.loc 2 4199 8
 6862 00af EC A5                   		mov.L	[r10], r5
 6863 00b1 61 05                   		cmp	#0, r5
 6864 00b3 21 15                   		bne	.L429
4200:../src/wolfcrypt/src/rsa.c ****         ret = RsaGetValue(&key->p, p, pSz);
 6865                             		.loc 2 4200 15
 6866 00b5 ED A5 01                		mov.L	4[r10], r5
 6867 00b8 72 55 30 09             		add	#0x930, r5
 6868 00bc A9 63                   		mov.L	16[r6], r3
 6869 00be A8 EA                   		mov.L	12[r6], r2
 6870 00c0 EF 51                   		mov.L	r5, r1
 6871 00c2 05 00 00 00             		bsr	_RsaGetValue
 6872 00c6 E3 A1                   		mov.L	r1, [r10]
 6873                             	.L429:
4201:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
 6874                             		.loc 2 4201 8
 6875 00c8 EC A5                   		mov.L	[r10], r5
 6876 00ca 61 05                   		cmp	#0, r5
 6877 00cc 21 15                   		bne	.L430
4202:../src/wolfcrypt/src/rsa.c ****         ret = RsaGetValue(&key->q, q, qSz);
 6878                             		.loc 2 4202 15
 6879 00ce ED A5 01                		mov.L	4[r10], r5
 6880 00d1 72 55 40 0C             		add	#0xc40, r5
 6881 00d5 A9 E3                   		mov.L	24[r6], r3
 6882 00d7 A9 6A                   		mov.L	20[r6], r2
 6883 00d9 EF 51                   		mov.L	r5, r1
 6884 00db 05 00 00 00             		bsr	_RsaGetValue
 6885 00df E3 A1                   		mov.L	r1, [r10]
 6886                             	.L430:
4203:../src/wolfcrypt/src/rsa.c **** #else
4204:../src/wolfcrypt/src/rsa.c ****     /* no private parts to key */
4205:../src/wolfcrypt/src/rsa.c ****     if (d == NULL || p == NULL || q == NULL || dSz == NULL || pSz == NULL
4206:../src/wolfcrypt/src/rsa.c ****             || qSz == NULL) {
4207:../src/wolfcrypt/src/rsa.c ****         ret = BAD_FUNC_ARG;
4208:../src/wolfcrypt/src/rsa.c ****     }
4209:../src/wolfcrypt/src/rsa.c ****     else {
4210:../src/wolfcrypt/src/rsa.c ****         *dSz = 0;
4211:../src/wolfcrypt/src/rsa.c ****         *pSz = 0;
4212:../src/wolfcrypt/src/rsa.c ****         *qSz = 0;
4213:../src/wolfcrypt/src/rsa.c ****     }
4214:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_RSA_PUBLIC_ONLY */
4215:../src/wolfcrypt/src/rsa.c **** 
4216:../src/wolfcrypt/src/rsa.c ****     return ret;
 6887                             		.loc 2 4216 12
 6888 00e1 EC A5                   		mov.L	[r10], r5
4217:../src/wolfcrypt/src/rsa.c **** }
 6889                             		.loc 2 4217 1
 6890 00e3 EF 51                   		mov.L	r5, r1
 6891 00e5 71 00 30                		add	#48, r0
 6892 00e8 7E B6                   		pop	r6
 6893 00ea 7E BA                   		pop	r10
 6894 00ec 02                      		rts
 6895                             	.LFE88:
 6897 00ed FC 13 00                		.section	.text.wc_RsaSetRNG,"ax",@progbits
 6898                             		.global	_wc_RsaSetRNG
 6900                             	_wc_RsaSetRNG:
 6901                             	.LFB89:
4218:../src/wolfcrypt/src/rsa.c **** #endif
4219:../src/wolfcrypt/src/rsa.c **** 
4220:../src/wolfcrypt/src/rsa.c **** 
4221:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_KEY_GEN
4222:../src/wolfcrypt/src/rsa.c **** 
4223:../src/wolfcrypt/src/rsa.c **** /* Check that |p-q| > 2^((size/2)-100) */
4224:../src/wolfcrypt/src/rsa.c **** static int wc_CompareDiffPQ(mp_int* p, mp_int* q, int size)
4225:../src/wolfcrypt/src/rsa.c **** {
4226:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4227:../src/wolfcrypt/src/rsa.c ****     mp_int *c = NULL, *d = NULL;
4228:../src/wolfcrypt/src/rsa.c **** #else
4229:../src/wolfcrypt/src/rsa.c ****     mp_int c[1], d[1];
4230:../src/wolfcrypt/src/rsa.c **** #endif
4231:../src/wolfcrypt/src/rsa.c ****     int ret;
4232:../src/wolfcrypt/src/rsa.c **** 
4233:../src/wolfcrypt/src/rsa.c ****     if (p == NULL || q == NULL)
4234:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
4235:../src/wolfcrypt/src/rsa.c **** 
4236:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4237:../src/wolfcrypt/src/rsa.c ****     if (((c = (mp_int *)XMALLOC(sizeof(*c), NULL, DYNAMIC_TYPE_WOLF_BIGINT)) == NULL) ||
4238:../src/wolfcrypt/src/rsa.c ****         ((d = (mp_int *)XMALLOC(sizeof(*d), NULL, DYNAMIC_TYPE_WOLF_BIGINT)) == NULL))
4239:../src/wolfcrypt/src/rsa.c ****         ret = MEMORY_E;
4240:../src/wolfcrypt/src/rsa.c ****     else
4241:../src/wolfcrypt/src/rsa.c ****         ret = 0;
4242:../src/wolfcrypt/src/rsa.c **** 
4243:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
4244:../src/wolfcrypt/src/rsa.c **** #endif
4245:../src/wolfcrypt/src/rsa.c ****         ret = mp_init_multi(c, d, NULL, NULL, NULL, NULL);
4246:../src/wolfcrypt/src/rsa.c **** 
4247:../src/wolfcrypt/src/rsa.c ****     /* c = 2^((size/2)-100) */
4248:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
4249:../src/wolfcrypt/src/rsa.c ****         ret = mp_2expt(c, (size/2)-100);
4250:../src/wolfcrypt/src/rsa.c **** 
4251:../src/wolfcrypt/src/rsa.c ****     /* d = |p-q| */
4252:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
4253:../src/wolfcrypt/src/rsa.c ****         ret = mp_sub(p, q, d);
4254:../src/wolfcrypt/src/rsa.c **** 
4255:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
4256:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
4257:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("Comare PQ d", d);
4258:../src/wolfcrypt/src/rsa.c **** #endif
4259:../src/wolfcrypt/src/rsa.c **** 
4260:../src/wolfcrypt/src/rsa.c **** #if !defined(WOLFSSL_SP_MATH) && (!defined(WOLFSSL_SP_MATH_ALL) || \
4261:../src/wolfcrypt/src/rsa.c ****                                                defined(WOLFSSL_SP_INT_NEGATIVE))
4262:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
4263:../src/wolfcrypt/src/rsa.c ****         ret = mp_abs(d, d);
4264:../src/wolfcrypt/src/rsa.c **** #endif
4265:../src/wolfcrypt/src/rsa.c **** 
4266:../src/wolfcrypt/src/rsa.c ****     /* compare */
4267:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
4268:../src/wolfcrypt/src/rsa.c ****         ret = mp_cmp(d, c);
4269:../src/wolfcrypt/src/rsa.c **** 
4270:../src/wolfcrypt/src/rsa.c ****     if (ret == MP_GT)
4271:../src/wolfcrypt/src/rsa.c ****         ret = MP_OKAY;
4272:../src/wolfcrypt/src/rsa.c **** 
4273:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4274:../src/wolfcrypt/src/rsa.c ****     if (d != NULL) {
4275:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(d);
4276:../src/wolfcrypt/src/rsa.c ****         XFREE(d, NULL, DYNAMIC_TYPE_WOLF_BIGINT);
4277:../src/wolfcrypt/src/rsa.c ****     }
4278:../src/wolfcrypt/src/rsa.c ****     if (c != NULL) {
4279:../src/wolfcrypt/src/rsa.c ****         mp_clear(c);
4280:../src/wolfcrypt/src/rsa.c ****         XFREE(c, NULL, DYNAMIC_TYPE_WOLF_BIGINT);
4281:../src/wolfcrypt/src/rsa.c ****     }
4282:../src/wolfcrypt/src/rsa.c **** #else
4283:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(d);
4284:../src/wolfcrypt/src/rsa.c ****     mp_clear(c);
4285:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
4286:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(d);
4287:../src/wolfcrypt/src/rsa.c **** #endif
4288:../src/wolfcrypt/src/rsa.c **** #endif
4289:../src/wolfcrypt/src/rsa.c **** 
4290:../src/wolfcrypt/src/rsa.c ****     return ret;
4291:../src/wolfcrypt/src/rsa.c **** }
4292:../src/wolfcrypt/src/rsa.c **** 
4293:../src/wolfcrypt/src/rsa.c **** 
4294:../src/wolfcrypt/src/rsa.c **** /* The lower_bound value is floor(2^(0.5) * 2^((nlen/2)-1)) where nlen is 4096.
4295:../src/wolfcrypt/src/rsa.c ****  * This number was calculated using a small test tool written with a common
4296:../src/wolfcrypt/src/rsa.c ****  * large number math library. Other values of nlen may be checked with a subset
4297:../src/wolfcrypt/src/rsa.c ****  * of lower_bound. */
4298:../src/wolfcrypt/src/rsa.c **** static const byte lower_bound[] = {
4299:../src/wolfcrypt/src/rsa.c ****     0xB5, 0x04, 0xF3, 0x33, 0xF9, 0xDE, 0x64, 0x84,
4300:../src/wolfcrypt/src/rsa.c ****     0x59, 0x7D, 0x89, 0xB3, 0x75, 0x4A, 0xBE, 0x9F,
4301:../src/wolfcrypt/src/rsa.c ****     0x1D, 0x6F, 0x60, 0xBA, 0x89, 0x3B, 0xA8, 0x4C,
4302:../src/wolfcrypt/src/rsa.c ****     0xED, 0x17, 0xAC, 0x85, 0x83, 0x33, 0x99, 0x15,
4303:../src/wolfcrypt/src/rsa.c **** /* 512 */
4304:../src/wolfcrypt/src/rsa.c ****     0x4A, 0xFC, 0x83, 0x04, 0x3A, 0xB8, 0xA2, 0xC3,
4305:../src/wolfcrypt/src/rsa.c ****     0xA8, 0xB1, 0xFE, 0x6F, 0xDC, 0x83, 0xDB, 0x39,
4306:../src/wolfcrypt/src/rsa.c ****     0x0F, 0x74, 0xA8, 0x5E, 0x43, 0x9C, 0x7B, 0x4A,
4307:../src/wolfcrypt/src/rsa.c ****     0x78, 0x04, 0x87, 0x36, 0x3D, 0xFA, 0x27, 0x68,
4308:../src/wolfcrypt/src/rsa.c **** /* 1024 */
4309:../src/wolfcrypt/src/rsa.c ****     0xD2, 0x20, 0x2E, 0x87, 0x42, 0xAF, 0x1F, 0x4E,
4310:../src/wolfcrypt/src/rsa.c ****     0x53, 0x05, 0x9C, 0x60, 0x11, 0xBC, 0x33, 0x7B,
4311:../src/wolfcrypt/src/rsa.c ****     0xCA, 0xB1, 0xBC, 0x91, 0x16, 0x88, 0x45, 0x8A,
4312:../src/wolfcrypt/src/rsa.c ****     0x46, 0x0A, 0xBC, 0x72, 0x2F, 0x7C, 0x4E, 0x33,
4313:../src/wolfcrypt/src/rsa.c ****     0xC6, 0xD5, 0xA8, 0xA3, 0x8B, 0xB7, 0xE9, 0xDC,
4314:../src/wolfcrypt/src/rsa.c ****     0xCB, 0x2A, 0x63, 0x43, 0x31, 0xF3, 0xC8, 0x4D,
4315:../src/wolfcrypt/src/rsa.c ****     0xF5, 0x2F, 0x12, 0x0F, 0x83, 0x6E, 0x58, 0x2E,
4316:../src/wolfcrypt/src/rsa.c ****     0xEA, 0xA4, 0xA0, 0x89, 0x90, 0x40, 0xCA, 0x4A,
4317:../src/wolfcrypt/src/rsa.c **** /* 2048 */
4318:../src/wolfcrypt/src/rsa.c ****     0x81, 0x39, 0x4A, 0xB6, 0xD8, 0xFD, 0x0E, 0xFD,
4319:../src/wolfcrypt/src/rsa.c ****     0xF4, 0xD3, 0xA0, 0x2C, 0xEB, 0xC9, 0x3E, 0x0C,
4320:../src/wolfcrypt/src/rsa.c ****     0x42, 0x64, 0xDA, 0xBC, 0xD5, 0x28, 0xB6, 0x51,
4321:../src/wolfcrypt/src/rsa.c ****     0xB8, 0xCF, 0x34, 0x1B, 0x6F, 0x82, 0x36, 0xC7,
4322:../src/wolfcrypt/src/rsa.c ****     0x01, 0x04, 0xDC, 0x01, 0xFE, 0x32, 0x35, 0x2F,
4323:../src/wolfcrypt/src/rsa.c ****     0x33, 0x2A, 0x5E, 0x9F, 0x7B, 0xDA, 0x1E, 0xBF,
4324:../src/wolfcrypt/src/rsa.c ****     0xF6, 0xA1, 0xBE, 0x3F, 0xCA, 0x22, 0x13, 0x07,
4325:../src/wolfcrypt/src/rsa.c ****     0xDE, 0xA0, 0x62, 0x41, 0xF7, 0xAA, 0x81, 0xC2,
4326:../src/wolfcrypt/src/rsa.c **** /* 3072 */
4327:../src/wolfcrypt/src/rsa.c ****     0xC1, 0xFC, 0xBD, 0xDE, 0xA2, 0xF7, 0xDC, 0x33,
4328:../src/wolfcrypt/src/rsa.c ****     0x18, 0x83, 0x8A, 0x2E, 0xAF, 0xF5, 0xF3, 0xB2,
4329:../src/wolfcrypt/src/rsa.c ****     0xD2, 0x4F, 0x4A, 0x76, 0x3F, 0xAC, 0xB8, 0x82,
4330:../src/wolfcrypt/src/rsa.c ****     0xFD, 0xFE, 0x17, 0x0F, 0xD3, 0xB1, 0xF7, 0x80,
4331:../src/wolfcrypt/src/rsa.c ****     0xF9, 0xAC, 0xCE, 0x41, 0x79, 0x7F, 0x28, 0x05,
4332:../src/wolfcrypt/src/rsa.c ****     0xC2, 0x46, 0x78, 0x5E, 0x92, 0x95, 0x70, 0x23,
4333:../src/wolfcrypt/src/rsa.c ****     0x5F, 0xCF, 0x8F, 0x7B, 0xCA, 0x3E, 0xA3, 0x3B,
4334:../src/wolfcrypt/src/rsa.c ****     0x4D, 0x7C, 0x60, 0xA5, 0xE6, 0x33, 0xE3, 0xE1
4335:../src/wolfcrypt/src/rsa.c **** /* 4096 */
4336:../src/wolfcrypt/src/rsa.c **** };
4337:../src/wolfcrypt/src/rsa.c **** 
4338:../src/wolfcrypt/src/rsa.c **** 
4339:../src/wolfcrypt/src/rsa.c **** /* returns 1 on key size ok and 0 if not ok */
4340:../src/wolfcrypt/src/rsa.c **** static WC_INLINE int RsaSizeCheck(int size)
4341:../src/wolfcrypt/src/rsa.c **** {
4342:../src/wolfcrypt/src/rsa.c ****     if (size < RSA_MIN_SIZE || size > RSA_MAX_SIZE) {
4343:../src/wolfcrypt/src/rsa.c ****         return 0;
4344:../src/wolfcrypt/src/rsa.c ****     }
4345:../src/wolfcrypt/src/rsa.c **** 
4346:../src/wolfcrypt/src/rsa.c **** #ifdef HAVE_FIPS
4347:../src/wolfcrypt/src/rsa.c ****     /* Key size requirements for CAVP */
4348:../src/wolfcrypt/src/rsa.c ****     switch (size) {
4349:../src/wolfcrypt/src/rsa.c ****         case 1024:
4350:../src/wolfcrypt/src/rsa.c ****         case 2048:
4351:../src/wolfcrypt/src/rsa.c ****         case 3072:
4352:../src/wolfcrypt/src/rsa.c ****         case 4096:
4353:../src/wolfcrypt/src/rsa.c ****             return 1;
4354:../src/wolfcrypt/src/rsa.c ****     }
4355:../src/wolfcrypt/src/rsa.c **** 
4356:../src/wolfcrypt/src/rsa.c ****     return 0;
4357:../src/wolfcrypt/src/rsa.c **** #else
4358:../src/wolfcrypt/src/rsa.c ****     return 1; /* allow unusual key sizes in non FIPS mode */
4359:../src/wolfcrypt/src/rsa.c **** #endif /* HAVE_FIPS */
4360:../src/wolfcrypt/src/rsa.c **** }
4361:../src/wolfcrypt/src/rsa.c **** 
4362:../src/wolfcrypt/src/rsa.c **** 
4363:../src/wolfcrypt/src/rsa.c **** static int _CheckProbablePrime(mp_int* p, mp_int* q, mp_int* e, int nlen,
4364:../src/wolfcrypt/src/rsa.c ****                                     int* isPrime, WC_RNG* rng)
4365:../src/wolfcrypt/src/rsa.c **** {
4366:../src/wolfcrypt/src/rsa.c ****     int ret;
4367:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4368:../src/wolfcrypt/src/rsa.c ****     mp_int *tmp1 = NULL, *tmp2 = NULL;
4369:../src/wolfcrypt/src/rsa.c **** #else
4370:../src/wolfcrypt/src/rsa.c ****     mp_int tmp1[1], tmp2[2];
4371:../src/wolfcrypt/src/rsa.c **** #endif
4372:../src/wolfcrypt/src/rsa.c ****     mp_int* prime;
4373:../src/wolfcrypt/src/rsa.c **** 
4374:../src/wolfcrypt/src/rsa.c ****     if (p == NULL || e == NULL || isPrime == NULL)
4375:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
4376:../src/wolfcrypt/src/rsa.c **** 
4377:../src/wolfcrypt/src/rsa.c ****     if (!RsaSizeCheck(nlen))
4378:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
4379:../src/wolfcrypt/src/rsa.c **** 
4380:../src/wolfcrypt/src/rsa.c ****     *isPrime = MP_NO;
4381:../src/wolfcrypt/src/rsa.c **** 
4382:../src/wolfcrypt/src/rsa.c ****     if (q != NULL) {
4383:../src/wolfcrypt/src/rsa.c ****         /* 5.4 - check that |p-q| <= (2^(1/2))(2^((nlen/2)-1)) */
4384:../src/wolfcrypt/src/rsa.c ****         ret = wc_CompareDiffPQ(p, q, nlen);
4385:../src/wolfcrypt/src/rsa.c ****         if (ret != MP_OKAY) goto notOkay;
4386:../src/wolfcrypt/src/rsa.c ****         prime = q;
4387:../src/wolfcrypt/src/rsa.c ****     }
4388:../src/wolfcrypt/src/rsa.c ****     else
4389:../src/wolfcrypt/src/rsa.c ****         prime = p;
4390:../src/wolfcrypt/src/rsa.c **** 
4391:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4392:../src/wolfcrypt/src/rsa.c ****     if (((tmp1 = (mp_int *)XMALLOC(sizeof(*tmp1), NULL, DYNAMIC_TYPE_WOLF_BIGINT)) == NULL) ||
4393:../src/wolfcrypt/src/rsa.c ****         ((tmp2 = (mp_int *)XMALLOC(sizeof(*tmp2), NULL, DYNAMIC_TYPE_WOLF_BIGINT)) == NULL)) {
4394:../src/wolfcrypt/src/rsa.c ****         ret = MEMORY_E;
4395:../src/wolfcrypt/src/rsa.c ****         goto notOkay;
4396:../src/wolfcrypt/src/rsa.c ****     }
4397:../src/wolfcrypt/src/rsa.c **** #endif
4398:../src/wolfcrypt/src/rsa.c **** 
4399:../src/wolfcrypt/src/rsa.c ****     ret = mp_init_multi(tmp1, tmp2, NULL, NULL, NULL, NULL);
4400:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY) goto notOkay;
4401:../src/wolfcrypt/src/rsa.c **** 
4402:../src/wolfcrypt/src/rsa.c ****     /* 4.4,5.5 - Check that prime >= (2^(1/2))(2^((nlen/2)-1))
4403:../src/wolfcrypt/src/rsa.c ****      *           This is a comparison against lowerBound */
4404:../src/wolfcrypt/src/rsa.c ****     ret = mp_read_unsigned_bin(tmp1, lower_bound, nlen/16);
4405:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY) goto notOkay;
4406:../src/wolfcrypt/src/rsa.c ****     ret = mp_cmp(prime, tmp1);
4407:../src/wolfcrypt/src/rsa.c ****     if (ret == MP_LT) goto exit;
4408:../src/wolfcrypt/src/rsa.c **** 
4409:../src/wolfcrypt/src/rsa.c ****     /* 4.5,5.6 - Check that GCD(p-1, e) == 1 */
4410:../src/wolfcrypt/src/rsa.c ****     ret = mp_sub_d(prime, 1, tmp1);  /* tmp1 = prime-1 */
4411:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY) goto notOkay;
4412:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
4413:../src/wolfcrypt/src/rsa.c ****     mp_memzero_add("Check Probable Prime tmp1", tmp1);
4414:../src/wolfcrypt/src/rsa.c **** #endif
4415:../src/wolfcrypt/src/rsa.c ****     ret = mp_gcd(tmp1, e, tmp2);  /* tmp2 = gcd(prime-1, e) */
4416:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY) goto notOkay;
4417:../src/wolfcrypt/src/rsa.c ****     ret = mp_cmp_d(tmp2, 1);
4418:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_EQ) goto exit; /* e divides p-1 */
4419:../src/wolfcrypt/src/rsa.c **** 
4420:../src/wolfcrypt/src/rsa.c ****     /* 4.5.1,5.6.1 - Check primality of p with 8 rounds of M-R.
4421:../src/wolfcrypt/src/rsa.c ****      * mp_prime_is_prime_ex() performs test divisions against the first 256
4422:../src/wolfcrypt/src/rsa.c ****      * prime numbers. After that it performs 8 rounds of M-R using random
4423:../src/wolfcrypt/src/rsa.c ****      * bases between 2 and n-2.
4424:../src/wolfcrypt/src/rsa.c ****      * mp_prime_is_prime() performs the same test divisions and then does
4425:../src/wolfcrypt/src/rsa.c ****      * M-R with the first 8 primes. Both functions set isPrime as a
4426:../src/wolfcrypt/src/rsa.c ****      * side-effect. */
4427:../src/wolfcrypt/src/rsa.c ****     if (rng != NULL)
4428:../src/wolfcrypt/src/rsa.c ****         ret = mp_prime_is_prime_ex(prime, 8, isPrime, rng);
4429:../src/wolfcrypt/src/rsa.c ****     else
4430:../src/wolfcrypt/src/rsa.c ****         ret = mp_prime_is_prime(prime, 8, isPrime);
4431:../src/wolfcrypt/src/rsa.c ****     if (ret != MP_OKAY) goto notOkay;
4432:../src/wolfcrypt/src/rsa.c **** 
4433:../src/wolfcrypt/src/rsa.c **** exit:
4434:../src/wolfcrypt/src/rsa.c ****     ret = MP_OKAY;
4435:../src/wolfcrypt/src/rsa.c **** 
4436:../src/wolfcrypt/src/rsa.c **** notOkay:
4437:../src/wolfcrypt/src/rsa.c **** 
4438:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4439:../src/wolfcrypt/src/rsa.c ****     if (tmp1 != NULL) {
4440:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(tmp1);
4441:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp1, NULL, DYNAMIC_TYPE_WOLF_BIGINT);
4442:../src/wolfcrypt/src/rsa.c ****     }
4443:../src/wolfcrypt/src/rsa.c ****     if (tmp2 != NULL) {
4444:../src/wolfcrypt/src/rsa.c ****         mp_clear(tmp2);
4445:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp2, NULL, DYNAMIC_TYPE_WOLF_BIGINT);
4446:../src/wolfcrypt/src/rsa.c ****     }
4447:../src/wolfcrypt/src/rsa.c **** #else
4448:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(tmp1);
4449:../src/wolfcrypt/src/rsa.c ****     mp_clear(tmp2);
4450:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
4451:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(tmp1);
4452:../src/wolfcrypt/src/rsa.c **** #endif
4453:../src/wolfcrypt/src/rsa.c **** #endif
4454:../src/wolfcrypt/src/rsa.c **** 
4455:../src/wolfcrypt/src/rsa.c ****     return ret;
4456:../src/wolfcrypt/src/rsa.c **** }
4457:../src/wolfcrypt/src/rsa.c **** 
4458:../src/wolfcrypt/src/rsa.c **** 
4459:../src/wolfcrypt/src/rsa.c **** int wc_CheckProbablePrime_ex(const byte* pRaw, word32 pRawSz,
4460:../src/wolfcrypt/src/rsa.c ****                           const byte* qRaw, word32 qRawSz,
4461:../src/wolfcrypt/src/rsa.c ****                           const byte* eRaw, word32 eRawSz,
4462:../src/wolfcrypt/src/rsa.c ****                           int nlen, int* isPrime, WC_RNG* rng)
4463:../src/wolfcrypt/src/rsa.c **** {
4464:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4465:../src/wolfcrypt/src/rsa.c ****     mp_int *p = NULL, *q = NULL, *e = NULL;
4466:../src/wolfcrypt/src/rsa.c **** #else
4467:../src/wolfcrypt/src/rsa.c ****     mp_int p[1], q[1], e[1];
4468:../src/wolfcrypt/src/rsa.c **** #endif
4469:../src/wolfcrypt/src/rsa.c ****     mp_int* Q = NULL;
4470:../src/wolfcrypt/src/rsa.c ****     int ret;
4471:../src/wolfcrypt/src/rsa.c **** 
4472:../src/wolfcrypt/src/rsa.c ****     if (pRaw == NULL || pRawSz == 0 ||
4473:../src/wolfcrypt/src/rsa.c ****         eRaw == NULL || eRawSz == 0 ||
4474:../src/wolfcrypt/src/rsa.c ****         isPrime == NULL) {
4475:../src/wolfcrypt/src/rsa.c **** 
4476:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
4477:../src/wolfcrypt/src/rsa.c ****     }
4478:../src/wolfcrypt/src/rsa.c **** 
4479:../src/wolfcrypt/src/rsa.c ****     if ((qRaw != NULL && qRawSz == 0) || (qRaw == NULL && qRawSz != 0))
4480:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
4481:../src/wolfcrypt/src/rsa.c **** 
4482:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4483:../src/wolfcrypt/src/rsa.c **** 
4484:../src/wolfcrypt/src/rsa.c ****     if (((p = (mp_int *)XMALLOC(sizeof(*p), NULL, DYNAMIC_TYPE_RSA_BUFFER)) == NULL) ||
4485:../src/wolfcrypt/src/rsa.c ****         ((q = (mp_int *)XMALLOC(sizeof(*q), NULL, DYNAMIC_TYPE_RSA_BUFFER)) == NULL) ||
4486:../src/wolfcrypt/src/rsa.c ****         ((e = (mp_int *)XMALLOC(sizeof(*e), NULL, DYNAMIC_TYPE_RSA_BUFFER)) == NULL))
4487:../src/wolfcrypt/src/rsa.c ****         ret = MEMORY_E;
4488:../src/wolfcrypt/src/rsa.c ****     else
4489:../src/wolfcrypt/src/rsa.c ****         ret = 0;
4490:../src/wolfcrypt/src/rsa.c ****     if (ret == 0)
4491:../src/wolfcrypt/src/rsa.c **** #endif
4492:../src/wolfcrypt/src/rsa.c ****         ret = mp_init_multi(p, q, e, NULL, NULL, NULL);
4493:../src/wolfcrypt/src/rsa.c **** 
4494:../src/wolfcrypt/src/rsa.c ****     if (ret == MP_OKAY)
4495:../src/wolfcrypt/src/rsa.c ****         ret = mp_read_unsigned_bin(p, pRaw, pRawSz);
4496:../src/wolfcrypt/src/rsa.c **** 
4497:../src/wolfcrypt/src/rsa.c ****     if (ret == MP_OKAY) {
4498:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_CHECK_MEM_ZERO
4499:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("wc_CheckProbablePrime_ex p", p);
4500:../src/wolfcrypt/src/rsa.c ****     #endif
4501:../src/wolfcrypt/src/rsa.c ****         if (qRaw != NULL) {
4502:../src/wolfcrypt/src/rsa.c ****             ret = mp_read_unsigned_bin(q, qRaw, qRawSz);
4503:../src/wolfcrypt/src/rsa.c ****             if (ret == MP_OKAY) {
4504:../src/wolfcrypt/src/rsa.c ****             #ifdef WOLFSSL_CHECK_MEM_ZERO
4505:../src/wolfcrypt/src/rsa.c ****                 mp_memzero_add("wc_CheckProbablePrime_ex q", q);
4506:../src/wolfcrypt/src/rsa.c ****             #endif
4507:../src/wolfcrypt/src/rsa.c ****                 Q = q;
4508:../src/wolfcrypt/src/rsa.c ****             }
4509:../src/wolfcrypt/src/rsa.c ****         }
4510:../src/wolfcrypt/src/rsa.c ****     }
4511:../src/wolfcrypt/src/rsa.c **** 
4512:../src/wolfcrypt/src/rsa.c ****     if (ret == MP_OKAY)
4513:../src/wolfcrypt/src/rsa.c ****         ret = mp_read_unsigned_bin(e, eRaw, eRawSz);
4514:../src/wolfcrypt/src/rsa.c **** 
4515:../src/wolfcrypt/src/rsa.c ****     if (ret == MP_OKAY) {
4516:../src/wolfcrypt/src/rsa.c ****         SAVE_VECTOR_REGISTERS(ret = _svr_ret;);
4517:../src/wolfcrypt/src/rsa.c **** 
4518:../src/wolfcrypt/src/rsa.c ****         if (ret == MP_OKAY)
4519:../src/wolfcrypt/src/rsa.c ****             ret = _CheckProbablePrime(p, Q, e, nlen, isPrime, rng);
4520:../src/wolfcrypt/src/rsa.c **** 
4521:../src/wolfcrypt/src/rsa.c ****         RESTORE_VECTOR_REGISTERS();
4522:../src/wolfcrypt/src/rsa.c ****     }
4523:../src/wolfcrypt/src/rsa.c **** 
4524:../src/wolfcrypt/src/rsa.c ****     ret = (ret == MP_OKAY) ? 0 : PRIME_GEN_E;
4525:../src/wolfcrypt/src/rsa.c **** 
4526:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4527:../src/wolfcrypt/src/rsa.c ****     if (p != NULL) {
4528:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(p);
4529:../src/wolfcrypt/src/rsa.c ****         XFREE(p, NULL, DYNAMIC_TYPE_RSA_BUFFER);
4530:../src/wolfcrypt/src/rsa.c ****     }
4531:../src/wolfcrypt/src/rsa.c ****     if (q != NULL) {
4532:../src/wolfcrypt/src/rsa.c ****         mp_forcezero(q);
4533:../src/wolfcrypt/src/rsa.c ****         XFREE(q, NULL, DYNAMIC_TYPE_RSA_BUFFER);
4534:../src/wolfcrypt/src/rsa.c ****     }
4535:../src/wolfcrypt/src/rsa.c ****     if (e != NULL) {
4536:../src/wolfcrypt/src/rsa.c ****         mp_clear(e);
4537:../src/wolfcrypt/src/rsa.c ****         XFREE(e, NULL, DYNAMIC_TYPE_RSA_BUFFER);
4538:../src/wolfcrypt/src/rsa.c ****     }
4539:../src/wolfcrypt/src/rsa.c **** #else
4540:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(p);
4541:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(q);
4542:../src/wolfcrypt/src/rsa.c ****     mp_clear(e);
4543:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
4544:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(p);
4545:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(q);
4546:../src/wolfcrypt/src/rsa.c **** #endif
4547:../src/wolfcrypt/src/rsa.c **** #endif
4548:../src/wolfcrypt/src/rsa.c **** 
4549:../src/wolfcrypt/src/rsa.c ****     return ret;
4550:../src/wolfcrypt/src/rsa.c **** }
4551:../src/wolfcrypt/src/rsa.c **** 
4552:../src/wolfcrypt/src/rsa.c **** 
4553:../src/wolfcrypt/src/rsa.c **** int wc_CheckProbablePrime(const byte* pRaw, word32 pRawSz,
4554:../src/wolfcrypt/src/rsa.c ****                           const byte* qRaw, word32 qRawSz,
4555:../src/wolfcrypt/src/rsa.c ****                           const byte* eRaw, word32 eRawSz,
4556:../src/wolfcrypt/src/rsa.c ****                           int nlen, int* isPrime)
4557:../src/wolfcrypt/src/rsa.c **** {
4558:../src/wolfcrypt/src/rsa.c ****     return wc_CheckProbablePrime_ex(pRaw, pRawSz, qRaw, qRawSz,
4559:../src/wolfcrypt/src/rsa.c ****                           eRaw, eRawSz, nlen, isPrime, NULL);
4560:../src/wolfcrypt/src/rsa.c **** }
4561:../src/wolfcrypt/src/rsa.c **** 
4562:../src/wolfcrypt/src/rsa.c **** #if !defined(HAVE_FIPS) || (defined(HAVE_FIPS) && \
4563:../src/wolfcrypt/src/rsa.c ****         defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2))
4564:../src/wolfcrypt/src/rsa.c **** /* Make an RSA key for size bits, with e specified, 65537 is a good e */
4565:../src/wolfcrypt/src/rsa.c **** int wc_MakeRsaKey(RsaKey* key, int size, long e, WC_RNG* rng)
4566:../src/wolfcrypt/src/rsa.c **** {
4567:../src/wolfcrypt/src/rsa.c **** #ifndef WC_NO_RNG
4568:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4569:../src/wolfcrypt/src/rsa.c ****     mp_int *p = NULL;
4570:../src/wolfcrypt/src/rsa.c ****     mp_int *q = NULL;
4571:../src/wolfcrypt/src/rsa.c ****     mp_int *tmp1 = NULL;
4572:../src/wolfcrypt/src/rsa.c ****     mp_int *tmp2 = NULL;
4573:../src/wolfcrypt/src/rsa.c ****     mp_int *tmp3 = NULL;
4574:../src/wolfcrypt/src/rsa.c **** #else
4575:../src/wolfcrypt/src/rsa.c ****     mp_int p_buf, *p = &p_buf;
4576:../src/wolfcrypt/src/rsa.c ****     mp_int q_buf, *q = &q_buf;
4577:../src/wolfcrypt/src/rsa.c ****     mp_int tmp1_buf, *tmp1 = &tmp1_buf;
4578:../src/wolfcrypt/src/rsa.c ****     mp_int tmp2_buf, *tmp2 = &tmp2_buf;
4579:../src/wolfcrypt/src/rsa.c ****     mp_int tmp3_buf, *tmp3 = &tmp3_buf;
4580:../src/wolfcrypt/src/rsa.c **** #endif
4581:../src/wolfcrypt/src/rsa.c ****     int err, i, failCount, primeSz, isPrime = 0;
4582:../src/wolfcrypt/src/rsa.c ****     byte* buf = NULL;
4583:../src/wolfcrypt/src/rsa.c **** 
4584:../src/wolfcrypt/src/rsa.c ****     if (key == NULL || rng == NULL) {
4585:../src/wolfcrypt/src/rsa.c ****         err = BAD_FUNC_ARG;
4586:../src/wolfcrypt/src/rsa.c ****         goto out;
4587:../src/wolfcrypt/src/rsa.c ****     }
4588:../src/wolfcrypt/src/rsa.c **** 
4589:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4590:../src/wolfcrypt/src/rsa.c ****     p = (mp_int *)XMALLOC(sizeof *p, key->heap, DYNAMIC_TYPE_RSA);
4591:../src/wolfcrypt/src/rsa.c ****     q = (mp_int *)XMALLOC(sizeof *q, key->heap, DYNAMIC_TYPE_RSA);
4592:../src/wolfcrypt/src/rsa.c ****     tmp1 = (mp_int *)XMALLOC(sizeof *tmp1, key->heap, DYNAMIC_TYPE_RSA);
4593:../src/wolfcrypt/src/rsa.c ****     tmp2 = (mp_int *)XMALLOC(sizeof *tmp2, key->heap, DYNAMIC_TYPE_RSA);
4594:../src/wolfcrypt/src/rsa.c ****     tmp3 = (mp_int *)XMALLOC(sizeof *tmp3, key->heap, DYNAMIC_TYPE_RSA);
4595:../src/wolfcrypt/src/rsa.c **** 
4596:../src/wolfcrypt/src/rsa.c ****     if ((p == NULL) ||
4597:../src/wolfcrypt/src/rsa.c ****         (q == NULL) ||
4598:../src/wolfcrypt/src/rsa.c ****         (tmp1 == NULL) ||
4599:../src/wolfcrypt/src/rsa.c ****         (tmp2 == NULL) ||
4600:../src/wolfcrypt/src/rsa.c ****         (tmp3 == NULL)) {
4601:../src/wolfcrypt/src/rsa.c ****       err = MEMORY_E;
4602:../src/wolfcrypt/src/rsa.c ****       goto out;
4603:../src/wolfcrypt/src/rsa.c ****     }
4604:../src/wolfcrypt/src/rsa.c **** #endif
4605:../src/wolfcrypt/src/rsa.c **** 
4606:../src/wolfcrypt/src/rsa.c ****     if (!RsaSizeCheck(size)) {
4607:../src/wolfcrypt/src/rsa.c ****         err = BAD_FUNC_ARG;
4608:../src/wolfcrypt/src/rsa.c ****         goto out;
4609:../src/wolfcrypt/src/rsa.c ****     }
4610:../src/wolfcrypt/src/rsa.c **** 
4611:../src/wolfcrypt/src/rsa.c ****     if (e < 3 || (e & 1) == 0) {
4612:../src/wolfcrypt/src/rsa.c ****         err = BAD_FUNC_ARG;
4613:../src/wolfcrypt/src/rsa.c ****         goto out;
4614:../src/wolfcrypt/src/rsa.c ****     }
4615:../src/wolfcrypt/src/rsa.c **** 
4616:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_CRYPTOCELL)
4617:../src/wolfcrypt/src/rsa.c **** 
4618:../src/wolfcrypt/src/rsa.c ****     err = cc310_RSA_GenerateKeyPair(key, size, e);
4619:../src/wolfcrypt/src/rsa.c ****     goto out;
4620:../src/wolfcrypt/src/rsa.c **** 
4621:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_CRYPTOCELL */
4622:../src/wolfcrypt/src/rsa.c **** 
4623:../src/wolfcrypt/src/rsa.c **** #ifdef WOLF_CRYPTO_CB
4624:../src/wolfcrypt/src/rsa.c ****     if (key->devId != INVALID_DEVID) {
4625:../src/wolfcrypt/src/rsa.c ****         err = wc_CryptoCb_MakeRsaKey(key, size, e, rng);
4626:../src/wolfcrypt/src/rsa.c ****     #ifndef WOLF_CRYPTO_CB_ONLY_RSA
4627:../src/wolfcrypt/src/rsa.c ****         if (err != CRYPTOCB_UNAVAILABLE)
4628:../src/wolfcrypt/src/rsa.c ****             goto out;
4629:../src/wolfcrypt/src/rsa.c ****         /* fall-through when unavailable */
4630:../src/wolfcrypt/src/rsa.c ****     #else
4631:../src/wolfcrypt/src/rsa.c ****         goto out;
4632:../src/wolfcrypt/src/rsa.c ****     #endif
4633:../src/wolfcrypt/src/rsa.c ****     }
4634:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLF_CRYPTO_CB_ONLY_RSA
4635:../src/wolfcrypt/src/rsa.c ****     else {
4636:../src/wolfcrypt/src/rsa.c ****         err = NO_VALID_DEVID;
4637:../src/wolfcrypt/src/rsa.c ****         goto out;
4638:../src/wolfcrypt/src/rsa.c ****     }
4639:../src/wolfcrypt/src/rsa.c ****     #endif
4640:../src/wolfcrypt/src/rsa.c **** #endif
4641:../src/wolfcrypt/src/rsa.c **** 
4642:../src/wolfcrypt/src/rsa.c **** #ifndef WOLF_CRYPTO_CB_ONLY_RSA
4643:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA) && \
4644:../src/wolfcrypt/src/rsa.c ****     defined(WC_ASYNC_ENABLE_RSA_KEYGEN)
4645:../src/wolfcrypt/src/rsa.c ****     if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_RSA) {
4646:../src/wolfcrypt/src/rsa.c ****     #ifdef HAVE_CAVIUM
4647:../src/wolfcrypt/src/rsa.c ****         /* TODO: Not implemented */
4648:../src/wolfcrypt/src/rsa.c ****     #elif defined(HAVE_INTEL_QA)
4649:../src/wolfcrypt/src/rsa.c ****         err = IntelQaRsaKeyGen(&key->asyncDev, key, size, e, rng);
4650:../src/wolfcrypt/src/rsa.c ****         goto out;
4651:../src/wolfcrypt/src/rsa.c ****     #else
4652:../src/wolfcrypt/src/rsa.c ****         if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_RSA_MAKE)) {
4653:../src/wolfcrypt/src/rsa.c ****             WC_ASYNC_TEST* testDev = &key->asyncDev.test;
4654:../src/wolfcrypt/src/rsa.c ****             testDev->rsaMake.rng = rng;
4655:../src/wolfcrypt/src/rsa.c ****             testDev->rsaMake.key = key;
4656:../src/wolfcrypt/src/rsa.c ****             testDev->rsaMake.size = size;
4657:../src/wolfcrypt/src/rsa.c ****             testDev->rsaMake.e = e;
4658:../src/wolfcrypt/src/rsa.c ****             err = WC_PENDING_E;
4659:../src/wolfcrypt/src/rsa.c ****             goto out;
4660:../src/wolfcrypt/src/rsa.c ****         }
4661:../src/wolfcrypt/src/rsa.c ****     #endif
4662:../src/wolfcrypt/src/rsa.c ****     }
4663:../src/wolfcrypt/src/rsa.c **** #endif
4664:../src/wolfcrypt/src/rsa.c **** 
4665:../src/wolfcrypt/src/rsa.c ****     err = mp_init_multi(p, q, tmp1, tmp2, tmp3, NULL);
4666:../src/wolfcrypt/src/rsa.c **** 
4667:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4668:../src/wolfcrypt/src/rsa.c ****         err = mp_set_int(tmp3, e);
4669:../src/wolfcrypt/src/rsa.c **** 
4670:../src/wolfcrypt/src/rsa.c ****     /* The failCount value comes from NIST FIPS 186-4, section B.3.3,
4671:../src/wolfcrypt/src/rsa.c ****      * process steps 4.7 and 5.8. */
4672:../src/wolfcrypt/src/rsa.c ****     failCount = 5 * (size / 2);
4673:../src/wolfcrypt/src/rsa.c ****     primeSz = size / 16; /* size is the size of n in bits.
4674:../src/wolfcrypt/src/rsa.c ****                             primeSz is in bytes. */
4675:../src/wolfcrypt/src/rsa.c **** 
4676:../src/wolfcrypt/src/rsa.c ****     /* allocate buffer to work with */
4677:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY) {
4678:../src/wolfcrypt/src/rsa.c ****         buf = (byte*)XMALLOC(primeSz, key->heap, DYNAMIC_TYPE_RSA);
4679:../src/wolfcrypt/src/rsa.c ****         if (buf == NULL)
4680:../src/wolfcrypt/src/rsa.c ****             err = MEMORY_E;
4681:../src/wolfcrypt/src/rsa.c ****     }
4682:../src/wolfcrypt/src/rsa.c **** 
4683:../src/wolfcrypt/src/rsa.c ****     SAVE_VECTOR_REGISTERS(err = _svr_ret;);
4684:../src/wolfcrypt/src/rsa.c **** 
4685:../src/wolfcrypt/src/rsa.c ****     /* make p */
4686:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY) {
4687:../src/wolfcrypt/src/rsa.c ****     #ifdef WOLFSSL_CHECK_MEM_ZERO
4688:../src/wolfcrypt/src/rsa.c ****         wc_MemZero_Add("RSA gen buf", buf, primeSz);
4689:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("RSA gen p", p);
4690:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("RSA gen q", q);
4691:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("RSA gen tmp1", tmp1);
4692:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("RSA gen tmp2", tmp2);
4693:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("RSA gen tmp3", tmp3);
4694:../src/wolfcrypt/src/rsa.c ****     #endif
4695:../src/wolfcrypt/src/rsa.c ****         isPrime = 0;
4696:../src/wolfcrypt/src/rsa.c ****         i = 0;
4697:../src/wolfcrypt/src/rsa.c ****         do {
4698:../src/wolfcrypt/src/rsa.c **** #ifdef SHOW_GEN
4699:../src/wolfcrypt/src/rsa.c ****             printf(".");
4700:../src/wolfcrypt/src/rsa.c ****             fflush(stdout);
4701:../src/wolfcrypt/src/rsa.c **** #endif
4702:../src/wolfcrypt/src/rsa.c ****             /* generate value */
4703:../src/wolfcrypt/src/rsa.c ****             err = wc_RNG_GenerateBlock(rng, buf, primeSz);
4704:../src/wolfcrypt/src/rsa.c ****             if (err == 0) {
4705:../src/wolfcrypt/src/rsa.c ****                 /* prime lower bound has the MSB set, set it in candidate */
4706:../src/wolfcrypt/src/rsa.c ****                 buf[0] |= 0x80;
4707:../src/wolfcrypt/src/rsa.c ****                 /* make candidate odd */
4708:../src/wolfcrypt/src/rsa.c ****                 buf[primeSz-1] |= 0x01;
4709:../src/wolfcrypt/src/rsa.c ****                 /* load value */
4710:../src/wolfcrypt/src/rsa.c ****                 err = mp_read_unsigned_bin(p, buf, primeSz);
4711:../src/wolfcrypt/src/rsa.c ****             }
4712:../src/wolfcrypt/src/rsa.c **** 
4713:../src/wolfcrypt/src/rsa.c ****             if (err == MP_OKAY)
4714:../src/wolfcrypt/src/rsa.c ****                 err = _CheckProbablePrime(p, NULL, tmp3, size, &isPrime, rng);
4715:../src/wolfcrypt/src/rsa.c **** 
4716:../src/wolfcrypt/src/rsa.c **** #ifdef HAVE_FIPS
4717:../src/wolfcrypt/src/rsa.c ****             i++;
4718:../src/wolfcrypt/src/rsa.c **** #else
4719:../src/wolfcrypt/src/rsa.c ****             /* Keep the old retry behavior in non-FIPS build. */
4720:../src/wolfcrypt/src/rsa.c ****             (void)i;
4721:../src/wolfcrypt/src/rsa.c **** #endif
4722:../src/wolfcrypt/src/rsa.c ****         } while (err == MP_OKAY && !isPrime && i < failCount);
4723:../src/wolfcrypt/src/rsa.c ****     }
4724:../src/wolfcrypt/src/rsa.c **** 
4725:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY && !isPrime)
4726:../src/wolfcrypt/src/rsa.c ****         err = PRIME_GEN_E;
4727:../src/wolfcrypt/src/rsa.c **** 
4728:../src/wolfcrypt/src/rsa.c ****     /* make q */
4729:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY) {
4730:../src/wolfcrypt/src/rsa.c ****         isPrime = 0;
4731:../src/wolfcrypt/src/rsa.c ****         i = 0;
4732:../src/wolfcrypt/src/rsa.c ****         do {
4733:../src/wolfcrypt/src/rsa.c **** #ifdef SHOW_GEN
4734:../src/wolfcrypt/src/rsa.c ****             printf(".");
4735:../src/wolfcrypt/src/rsa.c ****             fflush(stdout);
4736:../src/wolfcrypt/src/rsa.c **** #endif
4737:../src/wolfcrypt/src/rsa.c ****             /* generate value */
4738:../src/wolfcrypt/src/rsa.c ****             err = wc_RNG_GenerateBlock(rng, buf, primeSz);
4739:../src/wolfcrypt/src/rsa.c ****             if (err == 0) {
4740:../src/wolfcrypt/src/rsa.c ****                 /* prime lower bound has the MSB set, set it in candidate */
4741:../src/wolfcrypt/src/rsa.c ****                 buf[0] |= 0x80;
4742:../src/wolfcrypt/src/rsa.c ****                 /* make candidate odd */
4743:../src/wolfcrypt/src/rsa.c ****                 buf[primeSz-1] |= 0x01;
4744:../src/wolfcrypt/src/rsa.c ****                 /* load value */
4745:../src/wolfcrypt/src/rsa.c ****                 err = mp_read_unsigned_bin(q, buf, primeSz);
4746:../src/wolfcrypt/src/rsa.c ****             }
4747:../src/wolfcrypt/src/rsa.c **** 
4748:../src/wolfcrypt/src/rsa.c ****             if (err == MP_OKAY)
4749:../src/wolfcrypt/src/rsa.c ****                 err = _CheckProbablePrime(p, q, tmp3, size, &isPrime, rng);
4750:../src/wolfcrypt/src/rsa.c **** 
4751:../src/wolfcrypt/src/rsa.c **** #ifndef WC_RSA_NO_FERMAT_CHECK
4752:../src/wolfcrypt/src/rsa.c ****             if (err == MP_OKAY && isPrime) {
4753:../src/wolfcrypt/src/rsa.c ****                 /* Fermat's Factorization works when difference between p and q
4754:../src/wolfcrypt/src/rsa.c ****                  * is less than (conservatively):
4755:../src/wolfcrypt/src/rsa.c ****                  *     n^(1/4) + 32
4756:../src/wolfcrypt/src/rsa.c ****                  *  ~= 2^(bit count of n)^(1/4) + 32)
4757:../src/wolfcrypt/src/rsa.c ****                  *   = 2^((bit count of n)/4 + 32)
4758:../src/wolfcrypt/src/rsa.c ****                  */
4759:../src/wolfcrypt/src/rsa.c ****                 err = mp_sub(p, q, tmp1);
4760:../src/wolfcrypt/src/rsa.c ****                 if (err == MP_OKAY && mp_count_bits(tmp1) <= (size / 4) + 32) {
4761:../src/wolfcrypt/src/rsa.c ****                     isPrime = 0;
4762:../src/wolfcrypt/src/rsa.c ****                 }
4763:../src/wolfcrypt/src/rsa.c ****             }
4764:../src/wolfcrypt/src/rsa.c **** #endif
4765:../src/wolfcrypt/src/rsa.c **** 
4766:../src/wolfcrypt/src/rsa.c **** #ifdef HAVE_FIPS
4767:../src/wolfcrypt/src/rsa.c ****             i++;
4768:../src/wolfcrypt/src/rsa.c **** #else
4769:../src/wolfcrypt/src/rsa.c ****             /* Keep the old retry behavior in non-FIPS build. */
4770:../src/wolfcrypt/src/rsa.c ****             (void)i;
4771:../src/wolfcrypt/src/rsa.c **** #endif
4772:../src/wolfcrypt/src/rsa.c ****         } while (err == MP_OKAY && !isPrime && i < failCount);
4773:../src/wolfcrypt/src/rsa.c ****     }
4774:../src/wolfcrypt/src/rsa.c **** 
4775:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY && !isPrime)
4776:../src/wolfcrypt/src/rsa.c ****         err = PRIME_GEN_E;
4777:../src/wolfcrypt/src/rsa.c **** 
4778:../src/wolfcrypt/src/rsa.c ****     if (buf) {
4779:../src/wolfcrypt/src/rsa.c ****         ForceZero(buf, primeSz);
4780:../src/wolfcrypt/src/rsa.c ****         XFREE(buf, key->heap, DYNAMIC_TYPE_RSA);
4781:../src/wolfcrypt/src/rsa.c ****     }
4782:../src/wolfcrypt/src/rsa.c **** 
4783:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY && mp_cmp(p, q) < 0) {
4784:../src/wolfcrypt/src/rsa.c ****         err = mp_copy(p, tmp1);
4785:../src/wolfcrypt/src/rsa.c ****         if (err == MP_OKAY)
4786:../src/wolfcrypt/src/rsa.c ****             err = mp_copy(q, p);
4787:../src/wolfcrypt/src/rsa.c ****         if (err == MP_OKAY)
4788:../src/wolfcrypt/src/rsa.c ****             mp_copy(tmp1, q);
4789:../src/wolfcrypt/src/rsa.c ****     }
4790:../src/wolfcrypt/src/rsa.c **** 
4791:../src/wolfcrypt/src/rsa.c ****     /* Setup RsaKey buffers */
4792:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4793:../src/wolfcrypt/src/rsa.c ****         err = mp_init_multi(&key->n, &key->e, &key->d, &key->p, &key->q, NULL);
4794:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4795:../src/wolfcrypt/src/rsa.c ****         err = mp_init_multi(&key->dP, &key->dQ, &key->u, NULL, NULL, NULL);
4796:../src/wolfcrypt/src/rsa.c **** 
4797:../src/wolfcrypt/src/rsa.c ****     /* Software Key Calculation */
4798:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* tmp1 = p-1 */
4799:../src/wolfcrypt/src/rsa.c ****         err = mp_sub_d(p, 1, tmp1);
4800:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* tmp2 = q-1 */
4801:../src/wolfcrypt/src/rsa.c ****         err = mp_sub_d(q, 1, tmp2);
4802:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
4803:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* tmp3 = order of n */
4804:../src/wolfcrypt/src/rsa.c ****         err = mp_mul(tmp1, tmp2, tmp3);
4805:../src/wolfcrypt/src/rsa.c **** #else
4806:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* tmp3 = lcm(p-1, q-1), last loop */
4807:../src/wolfcrypt/src/rsa.c ****         err = mp_lcm(tmp1, tmp2, tmp3);
4808:../src/wolfcrypt/src/rsa.c **** #endif
4809:../src/wolfcrypt/src/rsa.c ****     /* make key */
4810:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* key->e = e */
4811:../src/wolfcrypt/src/rsa.c ****         err = mp_set_int(&key->e, (mp_digit)e);
4812:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
4813:../src/wolfcrypt/src/rsa.c ****     /* Blind the inverse operation with a value that is invertable */
4814:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY) {
4815:../src/wolfcrypt/src/rsa.c ****         do {
4816:../src/wolfcrypt/src/rsa.c ****             err = mp_rand(&key->p, get_digit_count(tmp3), rng);
4817:../src/wolfcrypt/src/rsa.c ****             if (err == MP_OKAY)
4818:../src/wolfcrypt/src/rsa.c ****                 err = mp_set_bit(&key->p, 0);
4819:../src/wolfcrypt/src/rsa.c ****             if (err == MP_OKAY)
4820:../src/wolfcrypt/src/rsa.c ****                 err = mp_set_bit(&key->p, size - 1);
4821:../src/wolfcrypt/src/rsa.c ****             if (err == MP_OKAY)
4822:../src/wolfcrypt/src/rsa.c ****                 err = mp_gcd(&key->p, tmp3, &key->q);
4823:../src/wolfcrypt/src/rsa.c ****         }
4824:../src/wolfcrypt/src/rsa.c ****         while ((err == MP_OKAY) && !mp_isone(&key->q));
4825:../src/wolfcrypt/src/rsa.c ****     }
4826:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4827:../src/wolfcrypt/src/rsa.c ****         err = mp_mul_d(&key->p, (mp_digit)e, &key->e);
4828:../src/wolfcrypt/src/rsa.c **** #endif
4829:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* key->d = 1/e mod lcm(p-1, q-1) */
4830:../src/wolfcrypt/src/rsa.c ****         err = mp_invmod(&key->e, tmp3, &key->d);
4831:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
4832:../src/wolfcrypt/src/rsa.c ****     /* Take off blinding from d and reset e */
4833:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4834:../src/wolfcrypt/src/rsa.c ****         err = mp_mulmod(&key->d, &key->p, tmp3, &key->d);
4835:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4836:../src/wolfcrypt/src/rsa.c ****         err = mp_set_int(&key->e, (mp_digit)e);
4837:../src/wolfcrypt/src/rsa.c **** #endif
4838:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* key->n = pq */
4839:../src/wolfcrypt/src/rsa.c ****         err = mp_mul(p, q, &key->n);
4840:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* key->dP = d mod(p-1) */
4841:../src/wolfcrypt/src/rsa.c ****         err = mp_mod(&key->d, tmp1, &key->dP);
4842:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* key->dQ = d mod(q-1) */
4843:../src/wolfcrypt/src/rsa.c ****         err = mp_mod(&key->d, tmp2, &key->dQ);
4844:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_MP_INVMOD_CONSTANT_TIME
4845:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* key->u = 1/q mod p */
4846:../src/wolfcrypt/src/rsa.c ****         err = mp_invmod(q, p, &key->u);
4847:../src/wolfcrypt/src/rsa.c **** #else
4848:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4849:../src/wolfcrypt/src/rsa.c ****         err = mp_sub_d(p, 2, tmp3);
4850:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)                /* key->u = 1/q mod p = q^p-2 mod p */
4851:../src/wolfcrypt/src/rsa.c ****         err = mp_exptmod(q, tmp3, p, &key->u);
4852:../src/wolfcrypt/src/rsa.c **** #endif
4853:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4854:../src/wolfcrypt/src/rsa.c ****         err = mp_copy(p, &key->p);
4855:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4856:../src/wolfcrypt/src/rsa.c ****         err = mp_copy(q, &key->q);
4857:../src/wolfcrypt/src/rsa.c **** 
4858:../src/wolfcrypt/src/rsa.c **** #ifdef HAVE_WOLF_BIGINT
4859:../src/wolfcrypt/src/rsa.c ****     /* make sure raw unsigned bin version is available */
4860:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4861:../src/wolfcrypt/src/rsa.c ****          err = wc_mp_to_bigint(&key->n, &key->n.raw);
4862:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4863:../src/wolfcrypt/src/rsa.c ****          err = wc_mp_to_bigint(&key->e, &key->e.raw);
4864:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4865:../src/wolfcrypt/src/rsa.c ****          err = wc_mp_to_bigint(&key->d, &key->d.raw);
4866:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4867:../src/wolfcrypt/src/rsa.c ****          err = wc_mp_to_bigint(&key->p, &key->p.raw);
4868:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4869:../src/wolfcrypt/src/rsa.c ****          err = wc_mp_to_bigint(&key->q, &key->q.raw);
4870:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4871:../src/wolfcrypt/src/rsa.c ****          err = wc_mp_to_bigint(&key->dP, &key->dP.raw);
4872:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4873:../src/wolfcrypt/src/rsa.c ****          err = wc_mp_to_bigint(&key->dQ, &key->dQ.raw);
4874:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4875:../src/wolfcrypt/src/rsa.c ****          err = wc_mp_to_bigint(&key->u, &key->u.raw);
4876:../src/wolfcrypt/src/rsa.c **** #endif
4877:../src/wolfcrypt/src/rsa.c **** 
4878:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY)
4879:../src/wolfcrypt/src/rsa.c ****         key->type = RSA_PRIVATE;
4880:../src/wolfcrypt/src/rsa.c **** 
4881:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
4882:../src/wolfcrypt/src/rsa.c ****     if (err == MP_OKAY) {
4883:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("Make RSA key d", &key->d);
4884:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("Make RSA key p", &key->p);
4885:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("Make RSA key q", &key->q);
4886:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("Make RSA key dP", &key->dP);
4887:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("Make RSA key dQ", &key->dQ);
4888:../src/wolfcrypt/src/rsa.c ****         mp_memzero_add("Make RSA key u", &key->u);
4889:../src/wolfcrypt/src/rsa.c ****     }
4890:../src/wolfcrypt/src/rsa.c **** #endif
4891:../src/wolfcrypt/src/rsa.c **** 
4892:../src/wolfcrypt/src/rsa.c ****     RESTORE_VECTOR_REGISTERS();
4893:../src/wolfcrypt/src/rsa.c **** 
4894:../src/wolfcrypt/src/rsa.c ****     /* Last value p - 1. */
4895:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(tmp1);
4896:../src/wolfcrypt/src/rsa.c ****     /* Last value q - 1. */
4897:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(tmp2);
4898:../src/wolfcrypt/src/rsa.c ****     /* Last value p - 2. */
4899:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(tmp3);
4900:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(p);
4901:../src/wolfcrypt/src/rsa.c ****     mp_forcezero(q);
4902:../src/wolfcrypt/src/rsa.c **** 
4903:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_RSA_KEY_CHECK
4904:../src/wolfcrypt/src/rsa.c ****     /* Perform the pair-wise consistency test on the new key. */
4905:../src/wolfcrypt/src/rsa.c ****     if (err == 0)
4906:../src/wolfcrypt/src/rsa.c ****         err = _ifc_pairwise_consistency_test(key, rng);
4907:../src/wolfcrypt/src/rsa.c **** #endif
4908:../src/wolfcrypt/src/rsa.c **** 
4909:../src/wolfcrypt/src/rsa.c ****     if (err != 0) {
4910:../src/wolfcrypt/src/rsa.c ****         wc_FreeRsaKey(key);
4911:../src/wolfcrypt/src/rsa.c ****         goto out;
4912:../src/wolfcrypt/src/rsa.c ****     }
4913:../src/wolfcrypt/src/rsa.c **** 
4914:../src/wolfcrypt/src/rsa.c **** #if defined(WOLFSSL_XILINX_CRYPT) || defined(WOLFSSL_CRYPTOCELL)
4915:../src/wolfcrypt/src/rsa.c ****     if (wc_InitRsaHw(key) != 0) {
4916:../src/wolfcrypt/src/rsa.c ****         return BAD_STATE_E;
4917:../src/wolfcrypt/src/rsa.c ****     }
4918:../src/wolfcrypt/src/rsa.c **** #endif
4919:../src/wolfcrypt/src/rsa.c **** 
4920:../src/wolfcrypt/src/rsa.c ****     err = 0;
4921:../src/wolfcrypt/src/rsa.c **** #endif /* WOLF_CRYPTO_CB_ONLY_RSA */
4922:../src/wolfcrypt/src/rsa.c ****   out:
4923:../src/wolfcrypt/src/rsa.c **** 
4924:../src/wolfcrypt/src/rsa.c **** #ifdef WOLFSSL_SMALL_STACK
4925:../src/wolfcrypt/src/rsa.c ****     if (p)
4926:../src/wolfcrypt/src/rsa.c ****         XFREE(p, key->heap, DYNAMIC_TYPE_RSA);
4927:../src/wolfcrypt/src/rsa.c ****     if (q)
4928:../src/wolfcrypt/src/rsa.c ****         XFREE(q, key->heap, DYNAMIC_TYPE_RSA);
4929:../src/wolfcrypt/src/rsa.c ****     if (tmp1)
4930:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp1, key->heap, DYNAMIC_TYPE_RSA);
4931:../src/wolfcrypt/src/rsa.c ****     if (tmp2)
4932:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp2, key->heap, DYNAMIC_TYPE_RSA);
4933:../src/wolfcrypt/src/rsa.c ****     if (tmp3)
4934:../src/wolfcrypt/src/rsa.c ****         XFREE(tmp3, key->heap, DYNAMIC_TYPE_RSA);
4935:../src/wolfcrypt/src/rsa.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
4936:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(p);
4937:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(q);
4938:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(tmp1);
4939:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(tmp2);
4940:../src/wolfcrypt/src/rsa.c ****     mp_memzero_check(tmp3);
4941:../src/wolfcrypt/src/rsa.c **** #endif
4942:../src/wolfcrypt/src/rsa.c **** 
4943:../src/wolfcrypt/src/rsa.c ****     return err;
4944:../src/wolfcrypt/src/rsa.c **** 
4945:../src/wolfcrypt/src/rsa.c **** #else
4946:../src/wolfcrypt/src/rsa.c ****     return NOT_COMPILED_IN;
4947:../src/wolfcrypt/src/rsa.c **** #endif
4948:../src/wolfcrypt/src/rsa.c **** }
4949:../src/wolfcrypt/src/rsa.c **** #endif /* !FIPS || FIPS_VER >= 2 */
4950:../src/wolfcrypt/src/rsa.c **** #endif /* WOLFSSL_KEY_GEN */
4951:../src/wolfcrypt/src/rsa.c **** 
4952:../src/wolfcrypt/src/rsa.c **** 
4953:../src/wolfcrypt/src/rsa.c **** #ifdef WC_RSA_BLINDING
4954:../src/wolfcrypt/src/rsa.c **** int wc_RsaSetRNG(RsaKey* key, WC_RNG* rng)
4955:../src/wolfcrypt/src/rsa.c **** {
 6902                             		.loc 2 4955 1
 6903 0000 7E AA                   		push.l	r10
 6904                             	.LCFI170:
 6905 0002 71 0A F8                		add	#-8, r0, r10
 6906                             	.LCFI171:
 6907 0005 EF A0                   		mov.L	r10, r0
 6908 0007 E3 A1                   		mov.L	r1, [r10]
 6909 0009 E7 A2 01                		mov.L	r2, 4[r10]
4956:../src/wolfcrypt/src/rsa.c ****     if (key == NULL || rng == NULL)
 6910                             		.loc 2 4956 8
 6911 000c EC A5                   		mov.L	[r10], r5
 6912 000e 61 05                   		cmp	#0, r5
 6913 0010 17                      		beq	.L433
 6914                             		.loc 2 4956 21 discriminator 1
 6915 0011 ED A5 01                		mov.L	4[r10], r5
 6916 0014 61 05                   		cmp	#0, r5
 6917 0016 1F                      		bne	.L434
 6918                             	.L433:
4957:../src/wolfcrypt/src/rsa.c ****         return BAD_FUNC_ARG;
 6919                             		.loc 2 4957 16
 6920 0017 FB 5A 53 FF             		mov.L	#-173, r5
 6921 001b 2E 0D                   		bra	.L435
 6922                             	.L434:
4958:../src/wolfcrypt/src/rsa.c **** 
4959:../src/wolfcrypt/src/rsa.c ****     key->rng = rng;
 6923                             		.loc 2 4959 14
 6924 001d EC A5                   		mov.L	[r10], r5
 6925 001f ED A4 01                		mov.L	4[r10], r4
 6926 0022 EB 54 25 06             		mov.L	r4, 6292[r5]
4960:../src/wolfcrypt/src/rsa.c **** 
4961:../src/wolfcrypt/src/rsa.c ****     return 0;
 6927                             		.loc 2 4961 12
 6928 0026 66 05                   		mov.L	#0, r5
 6929                             	.L435:
4962:../src/wolfcrypt/src/rsa.c **** }
 6930                             		.loc 2 4962 1
 6931 0028 EF 51                   		mov.L	r5, r1
 6932 002a 3F AA 03                		rtsd	#12, r10-r10
 6933                             	.LFE89:
 8400                             	.Letext0:
 8401                             		.file 3 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\lib\\gcc\\rx-
 8402                             		.file 4 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 8403                             		.file 5 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 8404                             		.file 6 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 8405                             		.file 7 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 8406                             		.file 8 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/types.h"
 8407                             		.file 9 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 8408                             		.file 10 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\incl
 8409                             		.file 11 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/error-crypt.h"
 8410                             		.file 12 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sp_int.h"
 8411                             		.file 13 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/random.h"
 8412                             		.file 14 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/wolfmath.h"
 8413                             		.file 15 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha512.h"
 8414                             		.file 16 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/rsa.h"
