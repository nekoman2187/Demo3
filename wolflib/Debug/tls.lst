   1                             		.file	"tls.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.section	.rodata.c25519_base_x,"a"
   7                             	_c25519_base_x:
   8 0000 09                      		.byte	9
   9 0001 00 00 00 00 00 00 00 00 		.zero	31
   9      00 00 00 00 00 00 00 00 
   9      00 00 00 00 00 00 00 00 
   9      00 00 00 00 00 00 00 
  10                             		.section	.rodata.f25519_zero,"a"
  13                             	_f25519_zero:
  14 0000 00 00 00 00 00 00 00 00 		.zero	32
  14      00 00 00 00 00 00 00 00 
  14      00 00 00 00 00 00 00 00 
  14      00 00 00 00 00 00 00 00 
  15                             		.section	.rodata.f25519_one,"a"
  18                             	_f25519_one:
  19 0000 01                      		.byte	1
  20 0001 00 00 00 00 00 00 00 00 		.zero	31
  20      00 00 00 00 00 00 00 00 
  20      00 00 00 00 00 00 00 00 
  20      00 00 00 00 00 00 00 
  21                             		.section	.rodata.fprime_zero,"a"
  24                             	_fprime_zero:
  25 0000 00 00 00 00 00 00 00 00 		.zero	32
  25      00 00 00 00 00 00 00 00 
  25      00 00 00 00 00 00 00 00 
  25      00 00 00 00 00 00 00 00 
  26                             		.section	.rodata.fprime_one,"a"
  29                             	_fprime_one:
  30 0000 01                      		.byte	1
  31 0001 00 00 00 00 00 00 00 00 		.zero	31
  31      00 00 00 00 00 00 00 00 
  31      00 00 00 00 00 00 00 00 
  31      00 00 00 00 00 00 00 
  32                             		.section	.rodata.client,"a"
  35                             	_client:
  36 0000 43                      		.byte	0x43
  37 0001 4C                      		.byte	0x4c
  38 0002 4E                      		.byte	0x4e
  39 0003 54                      		.byte	0x54
  40 0004 00                      		.byte	0
  41                             		.section	.rodata.server,"a"
  44                             	_server:
  45 0000 53                      		.byte	0x53
  46 0001 52                      		.byte	0x52
  47 0002 56                      		.byte	0x56
  48 0003 52                      		.byte	0x52
  49 0004 00                      		.byte	0
  50                             		.section	.rodata.tls_client,"a"
  53                             	_tls_client:
  54 0000 63 6C 69 65 6E 74 20 66 		.string	"client finished"
  54      69 6E 69 73 68 65 64 00 
  55                             		.section	.rodata.tls_server,"a"
  58                             	_tls_server:
  59 0000 73 65 72 76 65 72 20 66 		.string	"server finished"
  59      69 6E 69 73 68 65 64 00 
  60                             		.section	.text.ForceZero,"ax",@progbits
  62                             	_ForceZero:
  63                             	.LFB13:
  64                             		.file 1 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfcrypt/src/misc.c"
   1:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* misc.c
   2:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   3:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   5:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * This file is part of wolfSSL.
   6:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   7:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * it under the terms of the GNU General Public License as published by
   9:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * (at your option) any later version.
  11:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  12:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * GNU General Public License for more details.
  16:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  17:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * You should have received a copy of the GNU General Public License
  18:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * along with this program; if not, write to the Free Software
  19:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  21:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /*
  22:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  23:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** DESCRIPTION
  24:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** This module implements the arithmetic-shift right, left, byte swapping, XOR,
  25:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** masking and clearing memory logic.
  26:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  27:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** */
  28:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef HAVE_CONFIG_H
  29:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <config.h>
  30:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  31:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  32:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/settings.h>
  33:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  34:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLF_CRYPT_MISC_C
  35:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #define WOLF_CRYPT_MISC_C
  36:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  37:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/misc.h>
  38:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  39:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* inlining these functions is a huge speed increase and a small size decrease,
  40:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    because the functions are smaller than function call setup/cleanup, e.g.,
  41:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    md5 benchmark is twice as fast with inline.  If you don't want it, then
  42:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    define NO_INLINE and compile this file into wolfssl, otherwise it's used as
  43:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    a source header
  44:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  45:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  46:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef NO_INLINE
  47:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC
  48:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  49:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC static
  50:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  51:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  52:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Check for if compiling misc.c when not needed. */
  53:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if !defined(WOLFSSL_MISC_INCLUDED) && !defined(NO_INLINE)
  54:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_IGNORE_FILE_WARN
  55:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #warning misc.c does not need to be compiled when using inline (NO_INLINE not defined)
  56:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
  57:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  58:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  59:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  60:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  61:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__ICCARM__)
  62:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <intrinsics.h>
  63:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  64:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  65:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  66:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef INTEL_INTRINSICS
  67:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  68:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <stdlib.h>      /* get intrinsic definitions */
  69:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  70:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* for non visual studio probably need no long version, 32 bit only
  71:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****      * i.e., _rotl and _rotr */
  72:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #pragma intrinsic(_lrotl, _lrotr)
  73:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  74:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  75:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  76:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotl(x, y) : x;
  77:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  78:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  79:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
  80:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  81:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotr(x, y) : x;
  82:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  83:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  84:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
  85:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  86:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <builtin.h>      /* get intrinsic definitions */
  87:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  88:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if !defined(NO_INLINE)
  89:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  90:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotlFixed(x, y) _builtin_rotl(x, y)
  91:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  92:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotrFixed(x, y) _builtin_rotr(x, y)
  93:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  94:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #else /* create real function */
  95:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  96:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  97:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  98:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotl(x, y);
  99:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 100:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 101:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 102:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 103:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotr(x, y);
 104:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 105:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 106:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 107:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 108:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else /* generic */
 109:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value. */
 110:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 111:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
 112:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 113:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x << y) | (x >> (sizeof(y) * 8 - y));
 114:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 115:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 116:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value. */
 117:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 118:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 119:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x >> y) | (x << (sizeof(y) * 8 - y));
 120:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 121:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 122:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 123:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 124:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef WC_RC2
 125:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 126:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value */
 127:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotlFixed16(word16 x, word16 y)
 128:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 129:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 130:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 131:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 132:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 133:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value */
 134:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotrFixed16(word16 x, word16 y)
 135:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 136:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 137:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 138:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 139:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WC_RC2 */
 140:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 141:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of 32-bit word value. */
 142:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__CCRX__) && !defined(NO_INLINE) /* shortest version for CC-RX */
 143:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define ByteReverseWord32(value) _builtin_revl(value)
 144:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 145:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word32 ByteReverseWord32(word32 value)
 146:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 147:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef PPC_INTRINSICS
 148:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* PPC: load reverse indexed instruction */
 149:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__lwbrx(&value,0);
 150:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__ICCARM__)
 151:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__REV(value);
 152:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(KEIL_INTRINSICS)
 153:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__rev(value);
 154:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
 155:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)_builtin_revl(value);
 156:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLF_ALLOW_BUILTIN) && \
 157:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 158:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__builtin_bswap32(value);
 159:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 160:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       defined(__aarch64__)
 161:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 162:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV32 %0, %0  \n"
 163:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 164:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 165:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 166:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 167:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 168:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       (defined(__thumb__) || defined(__arm__))
 169:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 170:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV %0, %0  \n"
 171:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 172:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 173:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 174:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 175:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(FAST_ROTATE)
 176:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 5 instructions with rotate instruction, 9 without */
 177:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (rotrFixed(value, 8U) & 0xff00ff00) |
 178:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****            (rotlFixed(value, 8U) & 0x00ff00ff);
 179:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 180:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 6 instructions with rotate instruction, 8 without */
 181:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 182:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed(value, 16U);
 183:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 184:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 185:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* __CCRX__ */
 186:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of words array of a given count. */
 187:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords(word32* out, const word32* in,
 188:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                     word32 byteCount)
 189:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 190:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word32), i;
 191:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 192:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 193:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord32(in[i]);
 194:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 195:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 196:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 197:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WORD64_AVAILABLE) && !defined(WOLFSSL_NO_WORD64_OPS)
 198:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 199:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 200:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotlFixed64(word64 x, word64 y)
 201:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 202:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 203:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 204:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 205:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 206:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotrFixed64(word64 x, word64 y)
 207:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 208:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 209:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 210:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 211:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 212:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 ByteReverseWord64(word64 value)
 213:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 214:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WOLF_ALLOW_BUILTIN) && defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 215:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)__builtin_bswap64(value);
 216:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFCRYPT_SLOW_WORD64)
 217:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)((word64)ByteReverseWord32((word32) value)) << 32 |
 218:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         (word64)ByteReverseWord32((word32)(value   >> 32));
 219:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 220:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) |
 221:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
 222:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) |
 223:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
 224:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed64(value, 32U);
 225:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 226:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 227:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 228:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 229:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords64(word64* out, const word64* in,
 230:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                       word32 byteCount)
 231:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 232:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word64), i;
 233:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 234:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 235:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord64(in[i]);
 236:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 237:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 238:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 239:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WORD64_AVAILABLE && !WOLFSSL_NO_WORD64_OPS */
 240:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 241:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_XOR_OPS
 242:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 243:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 244:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWordsOut(wolfssl_word* r, const wolfssl_word* a,
 245:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                      const wolfssl_word* b, word32 n)
 246:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 247:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 248:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 249:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] = a[i] ^ b[i];
 250:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 251:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 252:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 253:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 254:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 255:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbufout(void*out, const void* buf, const void* mask,
 256:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                    word32 count)
 257:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 258:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)out | (wc_ptr_t)buf | (wc_ptr_t)mask | count) %
 259:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                          WOLFSSL_WORD_SIZE == 0)
 260:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWordsOut( (wolfssl_word*)out, (wolfssl_word*)buf,
 261:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                      (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 262:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 263:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 264:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       o = (byte*)out;
 265:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 266:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 267:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 268:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) o[i] = b[i] ^ m[i];
 269:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 270:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 271:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 272:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 273:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 274:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWords(wolfssl_word* r, const wolfssl_word* a, word32 n)
 275:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 276:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 277:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 278:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] ^= a[i];
 279:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 280:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 281:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 282:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 283:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 284:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbuf(void* buf, const void* mask, word32 count)
 285:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 286:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)buf | (wc_ptr_t)mask | count) % WOLFSSL_WORD_SIZE == 0)
 287:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWords( (wolfssl_word*)buf,
 288:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                   (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 289:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 290:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 291:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 292:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 293:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 294:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) b[i] ^= m[i];
 295:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 296:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 297:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 298:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 299:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_FORCE_ZERO
 300:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine fills the first len bytes of the memory area pointed by mem
 301:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    with zeros. It ensures compiler optimizations doesn't skip it  */
 302:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
 303:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
  65                             		.loc 1 303 1
  66 0000 7E AA                   		push.l	r10
  67                             	.LCFI0:
  68 0002 71 0A F4                		add	#-12, r0, r10
  69                             	.LCFI1:
  70 0005 EF A0                   		mov.L	r10, r0
  71 0007 E7 A1 01                		mov.L	r1, 4[r10]
  72 000a E7 A2 02                		mov.L	r2, 8[r10]
 304:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile byte* z = (volatile byte*)mem;
  73                             		.loc 1 304 20
  74 000d ED A5 01                		mov.L	4[r10], r5
  75 0010 E3 A5                   		mov.L	r5, [r10]
 305:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 306:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if (defined(WOLFSSL_X86_64_BUILD) || defined(WOLFSSL_AARCH64_BUILD)) \
 307:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****             && defined(WORD64_AVAILABLE)
 308:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile word64* w;
 309:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_UNALIGNED_64BIT_ACCESS
 310:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 l = (sizeof(word64) - ((size_t)z & (sizeof(word64)-1))) &
 311:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                              (sizeof(word64)-1);
 312:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 313:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         if (len < l) l = len;
 314:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         len -= l;
 315:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         while (l--) *z++ = 0;
 316:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 317:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
 318:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         *w++ = 0;
 319:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     z = (volatile byte*)w;
 320:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 321:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 322:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     while (len--) *z++ = 0;
  76                             		.loc 1 322 11
  77 0012 2E 0C                   		bra	.L2
  78                             	.L3:
  79                             		.loc 1 322 21 discriminator 2
  80 0014 EC A5                   		mov.L	[r10], r5
  81 0016 71 54 01                		add	#1, r5, r4
  82 0019 E3 A4                   		mov.L	r4, [r10]
  83                             		.loc 1 322 24 discriminator 2
  84 001b F8 54 00                		mov.B	#0, [r5]
  85                             	.L2:
  86                             		.loc 1 322 15 discriminator 1
  87 001e ED A5 02                		mov.L	8[r10], r5
  88 0021 71 54 FF                		add	#-1, r5, r4
  89 0024 E7 A4 02                		mov.L	r4, 8[r10]
  90                             		.loc 1 322 11 discriminator 1
  91 0027 61 05                   		cmp	#0, r5
  92 0029 21 EB                   		bne	.L3
 323:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
  93                             		.loc 1 323 1
  94 002b 03                      		nop
  95 002c 3F AA 04                		rtsd	#16, r10-r10
  96                             	.LFE13:
  98                             		.section	.text.c16toa,"ax",@progbits
 100                             	_c16toa:
 101                             	.LFB18:
 324:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 325:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 326:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 327:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_CONST_CMP
 328:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* check all length bytes for equality, return 0 on success */
 329:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ConstantCompare(const byte* a, const byte* b, int length)
 330:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 331:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int i;
 332:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int compareSum = 0;
 333:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 334:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < length; i++) {
 335:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         compareSum |= a[i] ^ b[i];
 336:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 337:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 338:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return compareSum;
 339:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 340:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 341:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 342:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 343:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_HAVE_MIN
 344:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WOLFSSL_HAVE_MIN
 345:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
 346:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #define min min
 347:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 348:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* returns the smaller of a and b */
 349:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 min(word32 a, word32 b)
 350:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 351:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return a > b ? b : a;
 352:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 353:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* !WOLFSSL_HAVE_MIN */
 354:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 355:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_HAVE_MAX
 356:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WOLFSSL_HAVE_MAX
 357:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if defined(HAVE_FIPS) && !defined(max) /* so ifdef check passes */
 358:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #define max max
 359:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 360:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 max(word32 a, word32 b)
 361:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 362:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return a > b ? a : b;
 363:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 364:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* !WOLFSSL_HAVE_MAX */
 365:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 366:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_INT_ENCODE
 367:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* converts a 32 bit integer to 24 bit */
 368:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void c32to24(word32 in, word24 out)
 369:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 370:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[0] = (in >> 16) & 0xff;
 371:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[1] = (in >>  8) & 0xff;
 372:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[2] =  in & 0xff;
 373:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 374:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 375:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert 16 bit integer to opaque */
 376:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void c16toa(word16 wc_u16, byte* c)
 377:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 102                             		.loc 1 377 1
 103 0000 7E AA                   		push.l	r10
 104                             	.LCFI2:
 105 0002 71 0A F8                		add	#-8, r0, r10
 106                             	.LCFI3:
 107 0005 EF A0                   		mov.L	r10, r0
 108 0007 D3 A1                   		mov.W	r1, [r10]
 109 0009 E7 A2 01                		mov.L	r2, 4[r10]
 378:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[0] = (wc_u16 >> 8) & 0xff;
 110                             		.loc 1 378 10
 111 000c 5C A5                   		movu.W	[r10], r5
 112 000e 68 85                   		shlr	#8, r5
 113 0010 CF 54                   		mov.B	r5, r4
 114 0012 ED A5 01                		mov.L	4[r10], r5
 115 0015 C3 54                   		mov.B	r4, [r5]
 379:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[1] =  wc_u16 & 0xff;
 116                             		.loc 1 379 6
 117 0017 ED A5 01                		mov.L	4[r10], r5
 118 001a 62 15                   		add	#1, r5
 119                             		.loc 1 379 10
 120 001c DC A4                   		mov.W	[r10], r4
 121 001e C3 54                   		mov.B	r4, [r5]
 380:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 122                             		.loc 1 380 1
 123 0020 03                      		nop
 124 0021 3F AA 03                		rtsd	#12, r10-r10
 125                             	.LFE18:
 127                             		.section	.text.c32toa,"ax",@progbits
 129                             	_c32toa:
 130                             	.LFB19:
 381:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 382:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert 32 bit integer to opaque */
 383:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void c32toa(word32 wc_u32, byte* c)
 384:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 131                             		.loc 1 384 1
 132 0000 7E AA                   		push.l	r10
 133                             	.LCFI4:
 134 0002 71 0A F8                		add	#-8, r0, r10
 135                             	.LCFI5:
 136 0005 EF A0                   		mov.L	r10, r0
 137 0007 E3 A1                   		mov.L	r1, [r10]
 138 0009 E7 A2 01                		mov.L	r2, 4[r10]
 385:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[0] = (wc_u32 >> 24) & 0xff;
 139                             		.loc 1 385 27
 140 000c EC A5                   		mov.L	[r10], r5
 141 000e 69 85                   		shlr	#24, r5
 142                             		.loc 1 385 10
 143 0010 CF 54                   		mov.B	r5, r4
 144 0012 ED A5 01                		mov.L	4[r10], r5
 145 0015 C3 54                   		mov.B	r4, [r5]
 386:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[1] = (wc_u32 >> 16) & 0xff;
 146                             		.loc 1 386 20
 147 0017 EC A5                   		mov.L	[r10], r5
 148 0019 FD 90 54                		shlr	#16, r5, r4
 149                             		.loc 1 386 6
 150 001c ED A5 01                		mov.L	4[r10], r5
 151 001f 62 15                   		add	#1, r5
 152                             		.loc 1 386 10
 153 0021 C3 54                   		mov.B	r4, [r5]
 387:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[2] = (wc_u32 >>  8) & 0xff;
 154                             		.loc 1 387 20
 155 0023 EC A5                   		mov.L	[r10], r5
 156 0025 FD 88 54                		shlr	#8, r5, r4
 157                             		.loc 1 387 6
 158 0028 ED A5 01                		mov.L	4[r10], r5
 159 002b 62 25                   		add	#2, r5
 160                             		.loc 1 387 10
 161 002d C3 54                   		mov.B	r4, [r5]
 388:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     c[3] =  wc_u32 & 0xff;
 162                             		.loc 1 388 6
 163 002f ED A5 01                		mov.L	4[r10], r5
 164 0032 62 35                   		add	#3, r5
 165                             		.loc 1 388 10
 166 0034 EC A4                   		mov.L	[r10], r4
 167 0036 C3 54                   		mov.B	r4, [r5]
 389:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 168                             		.loc 1 389 1
 169 0038 03                      		nop
 170 0039 3F AA 03                		rtsd	#12, r10-r10
 171                             	.LFE19:
 173                             		.section	.text.ato16,"ax",@progbits
 175                             	_ato16:
 176                             	.LFB22:
 390:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 391:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 392:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_INT_DECODE
 393:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert a 24 bit integer into a 32 bit one */
 394:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void c24to32(const word24 wc_u24, word32* wc_u32)
 395:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 396:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     *wc_u32 = ((word32)wc_u24[0] << 16) | (wc_u24[1] << 8) | wc_u24[2];
 397:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 398:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 399:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 400:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert opaque to 24 bit integer */
 401:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ato24(const byte* c, word32* wc_u24)
 402:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 403:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     *wc_u24 = ((word32)c[0] << 16) | (c[1] << 8) | c[2];
 404:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 405:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 406:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert opaque to 16 bit integer */
 407:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ato16(const byte* c, word16* wc_u16)
 408:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 177                             		.loc 1 408 1
 178 0000 7E AA                   		push.l	r10
 179                             	.LCFI6:
 180 0002 71 0A F8                		add	#-8, r0, r10
 181                             	.LCFI7:
 182 0005 EF A0                   		mov.L	r10, r0
 183 0007 E3 A1                   		mov.L	r1, [r10]
 184 0009 E7 A2 01                		mov.L	r2, 4[r10]
 409:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     *wc_u16 = (word16) ((c[0] << 8) | (c[1]));
 185                             		.loc 1 409 27
 186 000c EC A5                   		mov.L	[r10], r5
 187 000e CC 55                   		mov.B	[r5], r5
 188 0010 5B 55                   		movu.B	r5, r5
 189                             		.loc 1 409 31
 190 0012 6C 85                   		shll	#8, r5
 191                             		.loc 1 409 37
 192 0014 DF 54                   		mov.W	r5, r4
 193                             		.loc 1 409 41
 194 0016 EC A5                   		mov.L	[r10], r5
 195 0018 62 15                   		add	#1, r5
 196 001a CC 55                   		mov.B	[r5], r5
 197 001c 5B 55                   		movu.B	r5, r5
 198                             		.loc 1 409 37
 199 001e 57 45                   		or	r4, r5
 200                             		.loc 1 409 15
 201 0020 DF 54                   		mov.W	r5, r4
 202                             		.loc 1 409 13
 203 0022 ED A5 01                		mov.L	4[r10], r5
 204 0025 D3 54                   		mov.W	r4, [r5]
 410:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 205                             		.loc 1 410 1
 206 0027 03                      		nop
 207 0028 3F AA 03                		rtsd	#12, r10-r10
 208                             	.LFE22:
 210                             		.section	.text.ctMaskGT,"ax",@progbits
 212                             	_ctMaskGT:
 213                             	.LFB28:
 411:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 412:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* convert opaque to 32 bit integer */
 413:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ato32(const byte* c, word32* wc_u32)
 414:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 415:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     *wc_u32 = ((word32)c[0] << 24) | ((word32)c[1] << 16) | (c[2] << 8) | c[3];
 416:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 417:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 418:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 419:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word32 btoi(byte b)
 420:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 421:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)(b - 0x30);
 422:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 423:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 424:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 425:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE signed char HexCharToByte(char ch)
 426:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 427:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     signed char ret = (signed char)ch;
 428:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (ret >= '0' && ret <= '9')
 429:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ret -= '0';
 430:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else if (ret >= 'A' && ret <= 'F')
 431:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ret -= 'A' - 10;
 432:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else if (ret >= 'a' && ret <= 'f')
 433:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ret -= 'a' - 10;
 434:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else
 435:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ret = -1; /* error case - return code must be signed */
 436:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return ret;
 437:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 438:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 439:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE char ByteToHex(byte in)
 440:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 441:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     static const char kHexChar[] = { '0', '1', '2', '3', '4', '5', '6', '7',
 442:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                      '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
 443:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (char)(kHexChar[in & 0xF]);
 444:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 445:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 446:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ByteToHexStr(byte in, char* out)
 447:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 448:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (out == NULL)
 449:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return -1;
 450:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 451:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[0] = ByteToHex(in >> 4);
 452:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     out[1] = ByteToHex(in & 0xf);
 453:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return 0;
 454:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 455:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 456:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_CT_OPS
 457:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a > b. */
 458:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskGT(int a, int b)
 459:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 214                             		.loc 1 459 1
 215 0000 7E AA                   		push.l	r10
 216                             	.LCFI8:
 217 0002 71 0A F8                		add	#-8, r0, r10
 218                             	.LCFI9:
 219 0005 EF A0                   		mov.L	r10, r0
 220 0007 E3 A1                   		mov.L	r1, [r10]
 221 0009 E7 A2 01                		mov.L	r2, 4[r10]
 460:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((((word32)a - b - 1) >> 31) - 1);
 222                             		.loc 1 460 21
 223 000c EC A4                   		mov.L	[r10], r4
 224                             		.loc 1 460 31
 225 000e ED A5 01                		mov.L	4[r10], r5
 226 0011 FF 05 54                		sub	r5, r4, r5
 227                             		.loc 1 460 35
 228 0014 60 15                   		sub	#1, r5
 229                             		.loc 1 460 40
 230 0016 69 F5                   		shlr	#31, r5
 231                             		.loc 1 460 12
 232 0018 60 15                   		sub	#1, r5
 233 001a 5B 55                   		movu.B	r5, r5
 461:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 234                             		.loc 1 461 1
 235 001c EF 51                   		mov.L	r5, r1
 236 001e 3F AA 03                		rtsd	#12, r10-r10
 237                             	.LFE28:
 239                             		.section	.text.ctMaskLT,"ax",@progbits
 241                             	_ctMaskLT:
 242                             	.LFB31:
 462:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 463:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a >= b. */
 464:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskGTE(int a, int b)
 465:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 466:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((((word32)a - b    ) >> 31) - 1);
 467:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 468:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 469:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a >= b. */
 470:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ctMaskIntGTE(int a, int b)
 471:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 472:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (int)((((word32)a - b    ) >> 31) - 1);
 473:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 474:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 475:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a < b. */
 476:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskLT(int a, int b)
 477:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 243                             		.loc 1 477 1
 244 0000 7E AA                   		push.l	r10
 245                             	.LCFI10:
 246 0002 71 0A F8                		add	#-8, r0, r10
 247                             	.LCFI11:
 248 0005 EF A0                   		mov.L	r10, r0
 249 0007 E3 A1                   		mov.L	r1, [r10]
 250 0009 E7 A2 01                		mov.L	r2, 4[r10]
 478:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((((word32)b - a - 1) >> 31) - 1);
 251                             		.loc 1 478 21
 252 000c ED A4 01                		mov.L	4[r10], r4
 253                             		.loc 1 478 31
 254 000f EC A5                   		mov.L	[r10], r5
 255 0011 FF 05 54                		sub	r5, r4, r5
 256                             		.loc 1 478 35
 257 0014 60 15                   		sub	#1, r5
 258                             		.loc 1 478 40
 259 0016 69 F5                   		shlr	#31, r5
 260                             		.loc 1 478 12
 261 0018 60 15                   		sub	#1, r5
 262 001a 5B 55                   		movu.B	r5, r5
 479:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 263                             		.loc 1 479 1
 264 001c EF 51                   		mov.L	r5, r1
 265 001e 3F AA 03                		rtsd	#12, r10-r10
 266                             	.LFE31:
 268                             		.section	.text.ctMaskEq,"ax",@progbits
 270                             	_ctMaskEq:
 271                             	.LFB33:
 480:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 481:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a <= b. */
 482:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskLTE(int a, int b)
 483:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 484:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((((word32)b - a    ) >> 31) - 1);
 485:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 486:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 487:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a == b. */
 488:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskEq(int a, int b)
 489:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 272                             		.loc 1 489 1
 273 0000 7E AA                   		push.l	r10
 274                             	.LCFI12:
 275 0002 7E A6                   		push.l	r6
 276                             	.LCFI13:
 277 0004 71 0A F8                		add	#-8, r0, r10
 278                             	.LCFI14:
 279 0007 EF A0                   		mov.L	r10, r0
 280 0009 E3 A1                   		mov.L	r1, [r10]
 281 000b E7 A2 01                		mov.L	r2, 4[r10]
 490:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)(~ctMaskGT(a, b)) & (byte)(~ctMaskLT(a, b));
 282                             		.loc 1 490 20
 283 000e ED A2 01                		mov.L	4[r10], r2
 284 0011 EC A1                   		mov.L	[r10], r1
 285 0013 05 00 00 00             		bsr	_ctMaskGT
 286 0017 EF 15                   		mov.L	r1, r5
 287 0019 CF 56                   		mov.B	r5, r6
 288                             		.loc 1 490 46
 289 001b ED A2 01                		mov.L	4[r10], r2
 290 001e EC A1                   		mov.L	[r10], r1
 291 0020 05 00 00 00             		bsr	_ctMaskLT
 292 0024 EF 15                   		mov.L	r1, r5
 293                             		.loc 1 490 36
 294 0026 57 65                   		or	r6, r5
 295 0028 7E 05                   		not	r5
 296 002a 5B 55                   		movu.B	r5, r5
 491:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 297                             		.loc 1 491 1
 298 002c EF 51                   		mov.L	r5, r1
 299 002e 62 80                   		add	#8, r0
 300 0030 7E B6                   		pop	r6
 301 0032 7E BA                   		pop	r10
 302 0034 02                      		rts
 303                             	.LFE33:
 305                             		.section	.text.ctMaskSel,"ax",@progbits
 307                             	_ctMaskSel:
 308                             	.LFB40:
 492:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 493:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a > b */
 494:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16GT(int a, int b)
 495:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 496:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)((((word32)a - b - 1) >> 31) - 1);
 497:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 498:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 499:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a >= b */
 500:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16GTE(int a, int b)
 501:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 502:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)((((word32)a - b    ) >> 31) - 1);
 503:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 504:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 505:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a < b. */
 506:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16LT(int a, int b)
 507:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 508:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)((((word32)b - a - 1) >> 31) - 1);
 509:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 510:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 511:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a <= b. */
 512:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16LTE(int a, int b)
 513:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 514:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)((((word32)b - a    ) >> 31) - 1);
 515:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 516:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 517:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - sets 16 bit integer mask when a == b. */
 518:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 ctMask16Eq(int a, int b)
 519:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 520:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word16)(~ctMask16GT(a, b)) & (word16)(~ctMask16LT(a, b));
 521:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 522:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 523:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - mask set when a != b. */
 524:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskNotEq(int a, int b)
 525:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 526:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)ctMaskGT(a, b) | (byte)ctMaskLT(a, b);
 527:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 528:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 529:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - select a when mask is set and b otherwise. */
 530:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctMaskSel(byte m, byte a, byte b)
 531:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 309                             		.loc 1 531 1
 310 0000 7E AA                   		push.l	r10
 311                             	.LCFI15:
 312 0002 71 0A FC                		add	#-4, r0, r10
 313                             	.LCFI16:
 314 0005 EF A0                   		mov.L	r10, r0
 315 0007 C3 A1                   		mov.B	r1, [r10]
 316 0009 C7 A2 01                		mov.B	r2, 1[r10]
 317 000c C7 A3 02                		mov.B	r3, 2[r10]
 532:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)((b & ((byte)~(word32)m)) | (a & m));
 318                             		.loc 1 532 25
 319 000f CC A5                   		mov.B	[r10], r5
 320 0011 7E 05                   		not	r5
 321                             		.loc 1 532 12
 322 0013 CD A4 02                		mov.B	2[r10], r4
 323 0016 53 45                   		and	r4, r5
 324 0018 CF 54                   		mov.B	r5, r4
 325 001a CD A3 01                		mov.B	1[r10], r3
 326 001d CC A5                   		mov.B	[r10], r5
 327 001f 53 35                   		and	r3, r5
 328 0021 57 45                   		or	r4, r5
 329 0023 5B 55                   		movu.B	r5, r5
 533:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 330                             		.loc 1 533 1
 331 0025 EF 51                   		mov.L	r5, r1
 332 0027 3F AA 02                		rtsd	#8, r10-r10
 333                             	.LFE40:
 335                             		.section	.text.ctSetLTE,"ax",@progbits
 337                             	_ctSetLTE:
 338                             	.LFB42:
 534:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 535:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - select integer a when mask is set and integer b otherwise. */
 536:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ctMaskSelInt(byte m, int a, int b)
 537:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 538:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (b & (~(signed int)(signed char)m)) |
 539:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****            (a & ( (signed int)(signed char)m));
 540:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 541:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 542:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Constant time - bit set when a <= b. */
 543:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE byte ctSetLTE(int a, int b)
 544:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 339                             		.loc 1 544 1
 340 0000 7E AA                   		push.l	r10
 341                             	.LCFI17:
 342 0002 71 0A F8                		add	#-8, r0, r10
 343                             	.LCFI18:
 344 0005 EF A0                   		mov.L	r10, r0
 345 0007 E3 A1                   		mov.L	r1, [r10]
 346 0009 E7 A2 01                		mov.L	r2, 4[r10]
 545:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (byte)(((word32)a - b - 1) >> 31);
 347                             		.loc 1 545 20
 348 000c EC A4                   		mov.L	[r10], r4
 349                             		.loc 1 545 30
 350 000e ED A5 01                		mov.L	4[r10], r5
 351 0011 FF 05 54                		sub	r5, r4, r5
 352                             		.loc 1 545 34
 353 0014 60 15                   		sub	#1, r5
 354                             		.loc 1 545 39
 355 0016 69 F5                   		shlr	#31, r5
 356                             		.loc 1 545 12
 357 0018 5B 55                   		movu.B	r5, r5
 546:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 358                             		.loc 1 546 1
 359 001a EF 51                   		mov.L	r5, r1
 360 001c 3F AA 03                		rtsd	#12, r10-r10
 361                             	.LFE42:
 363                             		.section	.text.BuildTlsHandshakeHash,"ax",@progbits
 364                             		.global	_BuildTlsHandshakeHash
 366                             	_BuildTlsHandshakeHash:
 367                             	.LFB43:
 368                             		.file 2 "../src/src/tls.c"
   1:../src/src/tls.c **** /* tls.c
   2:../src/src/tls.c ****  *
   3:../src/src/tls.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:../src/src/tls.c ****  *
   5:../src/src/tls.c ****  * This file is part of wolfSSL.
   6:../src/src/tls.c ****  *
   7:../src/src/tls.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:../src/src/tls.c ****  * it under the terms of the GNU General Public License as published by
   9:../src/src/tls.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:../src/src/tls.c ****  * (at your option) any later version.
  11:../src/src/tls.c ****  *
  12:../src/src/tls.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:../src/src/tls.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../src/src/tls.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../src/src/tls.c ****  * GNU General Public License for more details.
  16:../src/src/tls.c ****  *
  17:../src/src/tls.c ****  * You should have received a copy of the GNU General Public License
  18:../src/src/tls.c ****  * along with this program; if not, write to the Free Software
  19:../src/src/tls.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:../src/src/tls.c ****  */
  21:../src/src/tls.c **** 
  22:../src/src/tls.c **** 
  23:../src/src/tls.c **** 
  24:../src/src/tls.c **** #ifdef HAVE_CONFIG_H
  25:../src/src/tls.c ****     #include <config.h>
  26:../src/src/tls.c **** #endif
  27:../src/src/tls.c **** 
  28:../src/src/tls.c **** #include <wolfssl/wolfcrypt/settings.h>
  29:../src/src/tls.c **** 
  30:../src/src/tls.c **** #ifndef WOLFCRYPT_ONLY
  31:../src/src/tls.c **** 
  32:../src/src/tls.c **** #include <wolfssl/ssl.h>
  33:../src/src/tls.c **** #include <wolfssl/internal.h>
  34:../src/src/tls.c **** #include <wolfssl/error-ssl.h>
  35:../src/src/tls.c **** #include <wolfssl/wolfcrypt/hash.h>
  36:../src/src/tls.c **** #include <wolfssl/wolfcrypt/hmac.h>
  37:../src/src/tls.c **** #include <wolfssl/wolfcrypt/kdf.h>
  38:../src/src/tls.c **** #ifdef NO_INLINE
  39:../src/src/tls.c ****     #include <wolfssl/wolfcrypt/misc.h>
  40:../src/src/tls.c **** #else
  41:../src/src/tls.c ****     #define WOLFSSL_MISC_INCLUDED
  42:../src/src/tls.c ****     #include <wolfcrypt/src/misc.c>
  43:../src/src/tls.c **** #endif
  44:../src/src/tls.c **** 
  45:../src/src/tls.c **** #ifdef HAVE_CURVE25519
  46:../src/src/tls.c ****     #include <wolfssl/wolfcrypt/curve25519.h>
  47:../src/src/tls.c **** #endif
  48:../src/src/tls.c **** #ifdef HAVE_CURVE448
  49:../src/src/tls.c ****     #include <wolfssl/wolfcrypt/curve448.h>
  50:../src/src/tls.c **** #endif
  51:../src/src/tls.c **** #ifdef HAVE_PQC
  52:../src/src/tls.c **** #ifdef HAVE_LIBOQS
  53:../src/src/tls.c ****     #include <oqs/kem.h>
  54:../src/src/tls.c **** #elif defined(HAVE_PQM4)
  55:../src/src/tls.c ****     #include "api_kyber.h"
  56:../src/src/tls.c ****     #define PQM4_PUBLIC_KEY_LENGTH    CRYPTO_PUBLICKEYBYTES
  57:../src/src/tls.c ****     #define PQM4_PRIVATE_KEY_LENGTH   CRYPTO_SECRETKEYBYTES
  58:../src/src/tls.c ****     #define PQM4_SHARED_SECRET_LENGTH CRYPTO_BYTES
  59:../src/src/tls.c ****     #define PQM4_CIPHERTEXT_LENGTH    CRYPTO_CIPHERTEXTBYTES
  60:../src/src/tls.c **** #endif
  61:../src/src/tls.c **** #endif
  62:../src/src/tls.c **** 
  63:../src/src/tls.c **** #if defined(WOLFSSL_RENESAS_TSIP_TLS)
  64:../src/src/tls.c ****     #include <wolfssl/wolfcrypt/port/Renesas/renesas-tsip-crypt.h>
  65:../src/src/tls.c **** #endif
  66:../src/src/tls.c **** 
  67:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_SUPPORTED_CURVES)
  68:../src/src/tls.c **** static int TLSX_KeyShare_IsSupported(int namedGroup);
  69:../src/src/tls.c **** static void TLSX_KeyShare_FreeAll(KeyShareEntry* list, void* heap);
  70:../src/src/tls.c **** #endif
  71:../src/src/tls.c **** 
  72:../src/src/tls.c **** #ifdef HAVE_SUPPORTED_CURVES
  73:../src/src/tls.c **** static int TLSX_PopulateSupportedGroups(WOLFSSL* ssl, TLSX** extensions);
  74:../src/src/tls.c **** #endif
  75:../src/src/tls.c **** 
  76:../src/src/tls.c **** #ifndef NO_TLS
  77:../src/src/tls.c **** 
  78:../src/src/tls.c **** /* Digest enable checks */
  79:../src/src/tls.c **** #ifdef NO_OLD_TLS /* TLS 1.2 only */
  80:../src/src/tls.c ****     #if defined(NO_SHA256) && !defined(WOLFSSL_SHA384) && \
  81:../src/src/tls.c ****             !defined(WOLFSSL_SHA512)
  82:../src/src/tls.c ****         #error Must have SHA256, SHA384 or SHA512 enabled for TLS 1.2
  83:../src/src/tls.c ****     #endif
  84:../src/src/tls.c **** #else  /* TLS 1.1 or older */
  85:../src/src/tls.c ****     #if defined(NO_MD5) && defined(NO_SHA)
  86:../src/src/tls.c ****         #error Must have SHA1 and MD5 enabled for old TLS
  87:../src/src/tls.c ****     #endif
  88:../src/src/tls.c **** #endif
  89:../src/src/tls.c **** 
  90:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
  91:../src/src/tls.c ****     #if !defined(NO_DH) && \
  92:../src/src/tls.c ****         !defined(HAVE_FFDHE_2048) && !defined(HAVE_FFDHE_3072) && \
  93:../src/src/tls.c ****         !defined(HAVE_FFDHE_4096) && !defined(HAVE_FFDHE_6144) && \
  94:../src/src/tls.c ****         !defined(HAVE_FFDHE_8192)
  95:../src/src/tls.c ****         #error Please configure your TLS 1.3 DH key size using either: HAVE_FFDHE_2048, HAVE_FFDHE_
  96:../src/src/tls.c ****     #endif
  97:../src/src/tls.c ****     #if !defined(NO_RSA) && !defined(WC_RSA_PSS)
  98:../src/src/tls.c ****         #error The build option WC_RSA_PSS is required for TLS 1.3 with RSA
  99:../src/src/tls.c ****     #endif
 100:../src/src/tls.c ****     #ifndef HAVE_TLS_EXTENSIONS
 101:../src/src/tls.c ****         #ifndef _MSC_VER
 102:../src/src/tls.c ****             #error "The build option HAVE_TLS_EXTENSIONS is required for TLS 1.3"
 103:../src/src/tls.c ****         #else
 104:../src/src/tls.c ****             #pragma message("Error: The build option HAVE_TLS_EXTENSIONS is required for TLS 1.3")
 105:../src/src/tls.c ****         #endif
 106:../src/src/tls.c ****     #endif
 107:../src/src/tls.c **** #endif
 108:../src/src/tls.c **** 
 109:../src/src/tls.c **** /* Warn if secrets logging is enabled */
 110:../src/src/tls.c **** #if defined(SHOW_SECRETS) || defined(WOLFSSL_SSLKEYLOGFILE)
 111:../src/src/tls.c ****     #ifndef _MSC_VER
 112:../src/src/tls.c ****         #warning The SHOW_SECRETS and WOLFSSL_SSLKEYLOGFILE options should only be used for debuggi
 113:../src/src/tls.c ****     #else
 114:../src/src/tls.c ****         #pragma message("Warning: The SHOW_SECRETS and WOLFSSL_SSLKEYLOGFILE options should only be
 115:../src/src/tls.c ****     #endif
 116:../src/src/tls.c **** #endif
 117:../src/src/tls.c **** 
 118:../src/src/tls.c **** /* Optional Pre-Master-Secret logging for Wireshark */
 119:../src/src/tls.c **** #if !defined(NO_FILESYSTEM) && defined(WOLFSSL_SSLKEYLOGFILE)
 120:../src/src/tls.c **** #ifndef WOLFSSL_SSLKEYLOGFILE_OUTPUT
 121:../src/src/tls.c ****     #define WOLFSSL_SSLKEYLOGFILE_OUTPUT "sslkeylog.log"
 122:../src/src/tls.c **** #endif
 123:../src/src/tls.c **** #endif
 124:../src/src/tls.c **** 
 125:../src/src/tls.c **** #ifndef WOLFSSL_NO_TLS12
 126:../src/src/tls.c **** 
 127:../src/src/tls.c **** #ifdef WOLFSSL_SHA384
 128:../src/src/tls.c ****     #define HSHASH_SZ WC_SHA384_DIGEST_SIZE
 129:../src/src/tls.c **** #else
 130:../src/src/tls.c ****     #define HSHASH_SZ FINISHED_SZ
 131:../src/src/tls.c **** #endif
 132:../src/src/tls.c **** 
 133:../src/src/tls.c **** int BuildTlsHandshakeHash(WOLFSSL* ssl, byte* hash, word32* hashLen)
 134:../src/src/tls.c **** {
 369                             		.loc 2 134 1
 370 0000 7E AA                   		push.l	r10
 371                             	.LCFI19:
 372 0002 71 0A EC                		add	#-20, r0, r10
 373                             	.LCFI20:
 374 0005 EF A0                   		mov.L	r10, r0
 375 0007 E7 A1 02                		mov.L	r1, 8[r10]
 376 000a E7 A2 03                		mov.L	r2, 12[r10]
 377 000d E7 A3 04                		mov.L	r3, 16[r10]
 135:../src/src/tls.c ****     int ret = 0;
 378                             		.loc 2 135 9
 379 0010 F8 A6 00                		mov.L	#0, [r10]
 136:../src/src/tls.c ****     word32 hashSz = FINISHED_SZ;
 380                             		.loc 2 136 12
 381 0013 F9 A6 01 24             		mov.L	#36, 4[r10]
 137:../src/src/tls.c **** 
 138:../src/src/tls.c ****     if (ssl == NULL || hash == NULL || hashLen == NULL || *hashLen < HSHASH_SZ)
 382                             		.loc 2 138 8
 383 0017 ED A5 02                		mov.L	8[r10], r5
 384 001a 61 05                   		cmp	#0, r5
 385 001c 20 1C                   		beq	.L18
 386                             		.loc 2 138 21 discriminator 1
 387 001e ED A5 03                		mov.L	12[r10], r5
 388 0021 61 05                   		cmp	#0, r5
 389 0023 20 15                   		beq	.L18
 390                             		.loc 2 138 37 discriminator 2
 391 0025 ED A5 04                		mov.L	16[r10], r5
 392 0028 61 05                   		cmp	#0, r5
 393 002a 20 0E                   		beq	.L18
 394                             		.loc 2 138 59 discriminator 3
 395 002c ED A5 04                		mov.L	16[r10], r5
 396 002f EC 55                   		mov.L	[r5], r5
 397                             		.loc 2 138 56 discriminator 3
 398 0031 75 55 2F                		cmp	#47, r5
 399 0034 24 0B                   		bgtu	.L19
 400 0036 EF 00                   		.balign 8,3,2
 401                             	.L18:
 139:../src/src/tls.c ****         return BAD_FUNC_ARG;
 402                             		.loc 2 139 16
 403 0038 FB 5A 53 FF             		mov.L	#-173, r5
 404 003c 38 BF 00                		bra	.L20
 405                             	.L19:
 140:../src/src/tls.c **** 
 141:../src/src/tls.c ****     /* for constant timing perform these even if error */
 142:../src/src/tls.c **** #ifndef NO_OLD_TLS
 143:../src/src/tls.c ****     ret |= wc_Md5GetHash(&ssl->hsHashes->hashMd5, hash);
 406                             		.loc 2 143 30
 407 003f ED A5 02                		mov.L	8[r10], r5
 408 0042 A8 DD                   		mov.L	12[r5], r5
 409                             		.loc 2 143 12
 410 0044 72 55 CC 01             		add	#0x1cc, r5
 411 0048 ED A2 03                		mov.L	12[r10], r2
 412 004b EF 51                   		mov.L	r5, r1
 413 004d 05 00 00 00             		bsr	_wc_Md5GetHash
 414 0051 EF 15                   		mov.L	r1, r5
 415                             		.loc 2 143 9
 416 0053 EC A4                   		mov.L	[r10], r4
 417 0055 57 45                   		or	r4, r5
 418 0057 E3 A5                   		mov.L	r5, [r10]
 144:../src/src/tls.c ****     ret |= wc_ShaGetHash(&ssl->hsHashes->hashSha, &hash[WC_MD5_DIGEST_SIZE]);
 419                             		.loc 2 144 30
 420 0059 ED A5 02                		mov.L	8[r10], r5
 421 005c A8 DD                   		mov.L	12[r5], r5
 422                             		.loc 2 144 12
 423 005e 72 54 68 01             		add	#0x168, r5, r4
 424 0062 ED A5 03                		mov.L	12[r10], r5
 425 0065 71 55 10                		add	#16, r5
 426 0068 EF 52                   		mov.L	r5, r2
 427 006a EF 41                   		mov.L	r4, r1
 428 006c 05 00 00 00             		bsr	_wc_ShaGetHash
 429 0070 EF 15                   		mov.L	r1, r5
 430                             		.loc 2 144 9
 431 0072 EC A4                   		mov.L	[r10], r4
 432 0074 57 45                   		or	r4, r5
 433 0076 E3 A5                   		mov.L	r5, [r10]
 145:../src/src/tls.c **** #endif
 146:../src/src/tls.c **** 
 147:../src/src/tls.c ****     if (IsAtLeastTLSv1_2(ssl)) {
 434                             		.loc 2 147 9
 435 0078 ED A1 02                		mov.L	8[r10], r1
 436 007b 05 00 00 00             		bsr	_IsAtLeastTLSv1_2
 437 007f EF 15                   		mov.L	r1, r5
 438                             		.loc 2 147 8
 439 0081 61 05                   		cmp	#0, r5
 440 0083 20 65                   		beq	.L21
 148:../src/src/tls.c **** #ifndef NO_SHA256
 149:../src/src/tls.c ****         if (ssl->specs.mac_algorithm <= sha256_mac ||
 441                             		.loc 2 149 23
 442 0085 ED A5 02                		mov.L	8[r10], r5
 443 0088 CE 55 6E 01             		mov.B	366[r5], r5
 444                             		.loc 2 149 12
 445 008c 5B 55                   		movu.B	r5, r5
 446 008e 61 45                   		cmp	#4, r5
 447 0090 25 0F                   		bleu	.L22
 150:../src/src/tls.c ****             ssl->specs.mac_algorithm == blake2b_mac) {
 448                             		.loc 2 150 23 discriminator 1
 449 0092 ED A5 02                		mov.L	8[r10], r5
 450 0095 CE 55 6E 01             		mov.B	366[r5], r5
 149:../src/src/tls.c ****             ssl->specs.mac_algorithm == blake2b_mac) {
 451                             		.loc 2 149 52 discriminator 1
 452 0099 5B 55                   		movu.B	r5, r5
 453 009b 61 85                   		cmp	#8, r5
 454 009d 21 20                   		bne	.L23
 455                             	.L22:
 151:../src/src/tls.c ****             ret |= wc_Sha256GetHash(&ssl->hsHashes->hashSha256, hash);
 456                             		.loc 2 151 41
 457 009f ED A5 02                		mov.L	8[r10], r5
 458 00a2 A8 DD                   		mov.L	12[r5], r5
 459                             		.loc 2 151 20
 460 00a4 72 55 2C 02             		add	#0x22c, r5
 461 00a8 ED A2 03                		mov.L	12[r10], r2
 462 00ab EF 51                   		mov.L	r5, r1
 463 00ad 05 00 00 00             		bsr	_wc_Sha256GetHash
 464 00b1 EF 15                   		mov.L	r1, r5
 465                             		.loc 2 151 17
 466 00b3 EC A4                   		mov.L	[r10], r4
 467 00b5 57 45                   		or	r4, r5
 468 00b7 E3 A5                   		mov.L	r5, [r10]
 152:../src/src/tls.c ****             hashSz = WC_SHA256_DIGEST_SIZE;
 469                             		.loc 2 152 20
 470 00b9 F9 A6 01 20             		mov.L	#32, 4[r10]
 471                             	.L23:
 153:../src/src/tls.c ****         }
 154:../src/src/tls.c **** #endif
 155:../src/src/tls.c **** #ifdef WOLFSSL_SHA384
 156:../src/src/tls.c ****         if (ssl->specs.mac_algorithm == sha384_mac) {
 472                             		.loc 2 156 23
 473 00bd ED A5 02                		mov.L	8[r10], r5
 474 00c0 CE 55 6E 01             		mov.B	366[r5], r5
 475                             		.loc 2 156 12
 476 00c4 5B 55                   		movu.B	r5, r5
 477 00c6 61 55                   		cmp	#5, r5
 478 00c8 21 20                   		bne	.L21
 157:../src/src/tls.c ****             ret |= wc_Sha384GetHash(&ssl->hsHashes->hashSha384, hash);
 479                             		.loc 2 157 41
 480 00ca ED A5 02                		mov.L	8[r10], r5
 481 00cd A8 DD                   		mov.L	12[r5], r5
 482                             		.loc 2 157 20
 483 00cf 72 55 9C 02             		add	#0x29c, r5
 484 00d3 ED A2 03                		mov.L	12[r10], r2
 485 00d6 EF 51                   		mov.L	r5, r1
 486 00d8 05 00 00 00             		bsr	_wc_Sha384GetHash
 487 00dc EF 15                   		mov.L	r1, r5
 488                             		.loc 2 157 17
 489 00de EC A4                   		mov.L	[r10], r4
 490 00e0 57 45                   		or	r4, r5
 491 00e2 E3 A5                   		mov.L	r5, [r10]
 158:../src/src/tls.c ****             hashSz = WC_SHA384_DIGEST_SIZE;
 492                             		.loc 2 158 20
 493 00e4 F9 A6 01 30             		mov.L	#48, 4[r10]
 494                             	.L21:
 159:../src/src/tls.c ****         }
 160:../src/src/tls.c **** #endif
 161:../src/src/tls.c ****     }
 162:../src/src/tls.c **** 
 163:../src/src/tls.c ****     *hashLen = hashSz;
 495                             		.loc 2 163 14
 496 00e8 ED A5 04                		mov.L	16[r10], r5
 497 00eb ED A4 01                		mov.L	4[r10], r4
 498 00ee E3 54                   		mov.L	r4, [r5]
 164:../src/src/tls.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
 165:../src/src/tls.c ****      wc_MemZero_Add("TLS handshake hash", hash, hashSz);
 166:../src/src/tls.c **** #endif
 167:../src/src/tls.c **** 
 168:../src/src/tls.c ****     if (ret != 0)
 499                             		.loc 2 168 8
 500 00f0 EC A5                   		mov.L	[r10], r5
 501 00f2 61 05                   		cmp	#0, r5
 502 00f4 15                      		beq	.L24
 169:../src/src/tls.c ****         ret = BUILD_MSG_ERROR;
 503                             		.loc 2 169 13
 504 00f5 F8 AA C0 FE             		mov.L	#-320, [r10]
 505                             	.L24:
 170:../src/src/tls.c **** 
 171:../src/src/tls.c ****     return ret;
 506                             		.loc 2 171 12
 507 00f9 EC A5                   		mov.L	[r10], r5
 508                             	.L20:
 172:../src/src/tls.c **** }
 509                             		.loc 2 172 1
 510 00fb EF 51                   		mov.L	r5, r1
 511 00fd 3F AA 06                		rtsd	#24, r10-r10
 512                             	.LFE43:
 514                             		.section C,"a",@progbits
 515                             		.p2align 2
 516                             	.LC0:
 517 0000 55 6E 65 78 70 65 63 74 		.string	"Unexpected sender value"
 517      65 64 20 73 65 6E 64 65 
 517      72 20 76 61 6C 75 65 00 
 518                             		.section	.text.BuildTlsFinished,"ax",@progbits
 519                             		.global	_BuildTlsFinished
 521                             	_BuildTlsFinished:
 522                             	.LFB44:
 173:../src/src/tls.c **** 
 174:../src/src/tls.c **** 
 175:../src/src/tls.c **** int BuildTlsFinished(WOLFSSL* ssl, Hashes* hashes, const byte* sender)
 176:../src/src/tls.c **** {
 523                             		.loc 2 176 1
 524 0000 6E 6B                   		pushm	r6-r11
 525                             	.LCFI21:
 526 0002 71 0A B8                		add	#-72, r0, r10
 527                             	.LCFI22:
 528 0005 71 A0 E0                		add	#-32, r10, r0
 529                             	.LCFI23:
 530 0008 E7 A1 0F                		mov.L	r1, 60[r10]
 531 000b E7 A2 10                		mov.L	r2, 64[r10]
 532 000e E7 A3 11                		mov.L	r3, 68[r10]
 177:../src/src/tls.c ****     int ret;
 178:../src/src/tls.c ****     const byte* side = NULL;
 533                             		.loc 2 178 17
 534 0011 F9 A6 01 00             		mov.L	#0, 4[r10]
 179:../src/src/tls.c ****     word32 hashSz = HSHASH_SZ;
 535                             		.loc 2 179 12
 536 0015 F9 A6 02 30             		mov.L	#48, 8[r10]
 180:../src/src/tls.c **** #if !defined(WOLFSSL_ASYNC_CRYPT) || defined(WC_ASYNC_NO_HASH)
 181:../src/src/tls.c ****     byte handshake_hash[HSHASH_SZ];
 182:../src/src/tls.c **** #else
 183:../src/src/tls.c ****     WC_DECLARE_VAR(handshake_hash, byte, HSHASH_SZ, ssl->heap);
 184:../src/src/tls.c ****     if (handshake_hash == NULL)
 185:../src/src/tls.c ****         return MEMORY_E;
 186:../src/src/tls.c **** #endif
 187:../src/src/tls.c **** 
 188:../src/src/tls.c ****     ret = BuildTlsHandshakeHash(ssl, handshake_hash, &hashSz);
 537                             		.loc 2 188 11
 538 0019 71 A4 08                		add	#8, r10, r4
 539 001c 71 A5 0C                		add	#12, r10, r5
 540 001f EF 43                   		mov.L	r4, r3
 541 0021 EF 52                   		mov.L	r5, r2
 542 0023 ED A1 0F                		mov.L	60[r10], r1
 543 0026 05 00 00 00             		bsr	_BuildTlsHandshakeHash
 544 002a E3 A1                   		mov.L	r1, [r10]
 189:../src/src/tls.c ****     if (ret == 0) {
 545                             		.loc 2 189 8
 546 002c EC A5                   		mov.L	[r10], r5
 547 002e 61 05                   		cmp	#0, r5
 548 0030 21 4A                   		bne	.L26
 190:../src/src/tls.c ****         if (XSTRNCMP((const char*)sender, (const char*)client,
 549                             		.loc 2 190 13
 550 0032 66 43                   		mov.L	#4, r3
 551 0034 FB 22 00 00 00 00       		mov.L	#_client, r2
 552 003a ED A1 11                		mov.L	68[r10], r1
 553 003d 05 00 00 00             		bsr	_strncmp
 554 0041 EF 15                   		mov.L	r1, r5
 555                             		.loc 2 190 12
 556 0043 61 05                   		cmp	#0, r5
 557 0045 1A                      		bne	.L27
 191:../src/src/tls.c ****                                                           SIZEOF_SENDER) == 0) {
 192:../src/src/tls.c ****             side = tls_client;
 558                             		.loc 2 192 18
 559 0046 F9 A2 01 00 00 00 00    		mov.L	#_tls_client, 4[r10]
 560 004d 2E 2D                   		bra	.L26
 561                             	.L27:
 193:../src/src/tls.c ****         }
 194:../src/src/tls.c ****         else if (XSTRNCMP((const char*)sender, (const char*)server,
 562                             		.loc 2 194 18
 563 004f 66 43                   		mov.L	#4, r3
 564 0051 FB 22 00 00 00 00       		mov.L	#_server, r2
 565 0057 ED A1 11                		mov.L	68[r10], r1
 566 005a 05 00 00 00             		bsr	_strncmp
 567 005e EF 15                   		mov.L	r1, r5
 568                             		.loc 2 194 17
 569 0060 61 05                   		cmp	#0, r5
 570 0062 1A                      		bne	.L28
 195:../src/src/tls.c ****                                                           SIZEOF_SENDER) == 0) {
 196:../src/src/tls.c ****             side = tls_server;
 571                             		.loc 2 196 18
 572 0063 F9 A2 01 00 00 00 00    		mov.L	#_tls_server, 4[r10]
 573 006a 2E 10                   		bra	.L26
 574                             	.L28:
 197:../src/src/tls.c ****         }
 198:../src/src/tls.c ****         else {
 199:../src/src/tls.c ****             ret = BAD_FUNC_ARG;
 575                             		.loc 2 199 17
 576 006c F8 AA 53 FF             		mov.L	#-173, [r10]
 200:../src/src/tls.c ****             WOLFSSL_MSG("Unexpected sender value");
 577                             		.loc 2 200 13
 578 0070 FB 12 00 00 00 00       		mov.L	#.LC0, r1
 579 0076 05 00 00 00             		bsr	_WOLFSSL_MSG
 580                             		.balign 8,3,1
 581                             	.L26:
 201:../src/src/tls.c ****         }
 202:../src/src/tls.c ****     }
 203:../src/src/tls.c **** 
 204:../src/src/tls.c ****     if (ret == 0) {
 582                             		.loc 2 204 8
 583 007a EC A5                   		mov.L	[r10], r5
 584 007c 61 05                   		cmp	#0, r5
 585 007e 21 61                   		bne	.L29
 205:../src/src/tls.c **** #ifdef WOLFSSL_HAVE_PRF
 206:../src/src/tls.c **** #if !defined(NO_CERTS) && defined(HAVE_PK_CALLBACKS)
 207:../src/src/tls.c ****         if (ssl->ctx->TlsFinishedCb) {
 208:../src/src/tls.c ****             void* ctx = wolfSSL_GetTlsFinishedCtx(ssl);
 209:../src/src/tls.c ****             ret = ssl->ctx->TlsFinishedCb(ssl, side, handshake_hash,
 210:../src/src/tls.c ****                                         (byte*)hashes, ctx);
 211:../src/src/tls.c ****         }
 212:../src/src/tls.c ****         if (!ssl->ctx->TlsFinishedCb || ret == PROTOCOLCB_UNAVAILABLE)
 213:../src/src/tls.c **** #endif
 214:../src/src/tls.c ****         {
 215:../src/src/tls.c ****             PRIVATE_KEY_UNLOCK();
 216:../src/src/tls.c ****             ret = wc_PRF_TLS((byte*)hashes, TLS_FINISHED_SZ,
 217:../src/src/tls.c ****                     ssl->arrays->masterSecret,
 586                             		.loc 2 217 24
 587 0080 ED A5 0F                		mov.L	60[r10], r5
 588 0083 A8 D5                   		mov.L	8[r5], r5
 589                             		.loc 2 217 32
 590 0085 72 56 BB 01             		add	#0x1bb, r5, r6
 216:../src/src/tls.c ****                     ssl->arrays->masterSecret,
 591                             		.loc 2 216 19
 592 0089 ED AB 02                		mov.L	8[r10], r11
 593 008c ED A1 0F                		mov.L	60[r10], r1
 594 008f 05 00 00 00             		bsr	_IsAtLeastTLSv1_2
 595 0093 EF 13                   		mov.L	r1, r3
 218:../src/src/tls.c ****                    SECRET_LEN, side, FINISHED_LABEL_SZ, handshake_hash, hashSz,
 219:../src/src/tls.c ****                    IsAtLeastTLSv1_2(ssl), ssl->specs.mac_algorithm,
 596                             		.loc 2 219 53
 597 0095 ED A5 0F                		mov.L	60[r10], r5
 598 0098 CE 55 6E 01             		mov.B	366[r5], r5
 216:../src/src/tls.c ****                     ssl->arrays->masterSecret,
 599                             		.loc 2 216 19
 600 009c 5B 54                   		movu.B	r5, r4
 601 009e ED A5 0F                		mov.L	60[r10], r5
 602 00a1 AA 5A                   		mov.L	36[r5], r2
 603 00a3 ED A5 0F                		mov.L	60[r10], r5
 604 00a6 ED 55 BE                		mov.L	760[r5], r5
 605 00a9 A1 8D                   		mov.L	r5, 28[r0]
 606 00ab A1 82                   		mov.L	r2, 24[r0]
 607 00ad A1 0C                   		mov.L	r4, 20[r0]
 608 00af A1 03                   		mov.L	r3, 16[r0]
 609 00b1 E7 0B 03                		mov.L	r11, 12[r0]
 610 00b4 71 A5 0C                		add	#12, r10, r5
 611 00b7 A0 85                   		mov.L	r5, 8[r0]
 612 00b9 3E 01 0F                		mov.L	#15, 4[r0]
 613 00bc ED A5 01                		mov.L	4[r10], r5
 614 00bf E3 05                   		mov.L	r5, [r0]
 615 00c1 75 44 30                		mov.L	#48, r4
 616 00c4 EF 63                   		mov.L	r6, r3
 617 00c6 66 C2                   		mov.L	#12, r2
 618 00c8 ED A1 10                		mov.L	64[r10], r1
 619 00cb 05 00 00 00             		bsr	_wc_PRF_TLS
 620 00cf E3 A1                   		mov.L	r1, [r10]
 220:../src/src/tls.c ****                    ssl->heap, ssl->devId);
 221:../src/src/tls.c ****             PRIVATE_KEY_LOCK();
 222:../src/src/tls.c ****         }
 223:../src/src/tls.c ****         ForceZero(handshake_hash, hashSz);
 621                             		.loc 2 223 9
 622 00d1 ED A4 02                		mov.L	8[r10], r4
 623 00d4 71 A5 0C                		add	#12, r10, r5
 624 00d7 EF 42                   		mov.L	r4, r2
 625 00d9 EF 51                   		mov.L	r5, r1
 626 00db 05 00 00 00             		bsr	_ForceZero
 627                             	.L29:
 224:../src/src/tls.c **** #else
 225:../src/src/tls.c ****         /* Pseudo random function must be enabled in the configuration. */
 226:../src/src/tls.c ****         ret = PRF_MISSING;
 227:../src/src/tls.c ****         WOLFSSL_MSG("Pseudo-random function is not enabled");
 228:../src/src/tls.c **** 
 229:../src/src/tls.c ****         (void)side;
 230:../src/src/tls.c ****         (void)hashes;
 231:../src/src/tls.c **** #endif
 232:../src/src/tls.c ****     }
 233:../src/src/tls.c **** 
 234:../src/src/tls.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && !defined(WC_ASYNC_NO_HASH)
 235:../src/src/tls.c ****     WC_FREE_VAR(handshake_hash, ssl->heap);
 236:../src/src/tls.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
 237:../src/src/tls.c ****     wc_MemZero_Check(handshake_hash, HSHASH_SZ);
 238:../src/src/tls.c **** #endif
 239:../src/src/tls.c **** 
 240:../src/src/tls.c ****     return ret;
 628                             		.loc 2 240 12
 629 00df EC A5                   		mov.L	[r10], r5
 241:../src/src/tls.c **** }
 630                             		.loc 2 241 1
 631 00e1 EF 51                   		mov.L	r5, r1
 632 00e3 3F 6B 20                		rtsd	#128, r6-r11
 633                             	.LFE44:
 635 00e6 EF 00                   		.section	.text.MakeTLSv1_1,"ax",@progbits
 636                             		.global	_MakeTLSv1_1
 638                             	_MakeTLSv1_1:
 639                             	.LFB45:
 242:../src/src/tls.c **** 
 243:../src/src/tls.c **** #endif /* !WOLFSSL_NO_TLS12 */
 244:../src/src/tls.c **** 
 245:../src/src/tls.c **** #ifndef NO_OLD_TLS
 246:../src/src/tls.c **** 
 247:../src/src/tls.c **** #ifdef WOLFSSL_ALLOW_TLSV10
 248:../src/src/tls.c **** ProtocolVersion MakeTLSv1(void)
 249:../src/src/tls.c **** {
 250:../src/src/tls.c ****     ProtocolVersion pv;
 251:../src/src/tls.c ****     pv.major = SSLv3_MAJOR;
 252:../src/src/tls.c ****     pv.minor = TLSv1_MINOR;
 253:../src/src/tls.c **** 
 254:../src/src/tls.c ****     return pv;
 255:../src/src/tls.c **** }
 256:../src/src/tls.c **** #endif /* WOLFSSL_ALLOW_TLSV10 */
 257:../src/src/tls.c **** 
 258:../src/src/tls.c **** 
 259:../src/src/tls.c **** ProtocolVersion MakeTLSv1_1(void)
 260:../src/src/tls.c **** {
 640                             		.loc 2 260 1
 641 0000 7E AA                   		push.l	r10
 642                             	.LCFI24:
 643 0002 71 0A FC                		add	#-4, r0, r10
 644                             	.LCFI25:
 645 0005 EF A0                   		mov.L	r10, r0
 646 0007 EF F5                   		mov.L	r15, r5
 261:../src/src/tls.c ****     ProtocolVersion pv;
 262:../src/src/tls.c ****     pv.major = SSLv3_MAJOR;
 647                             		.loc 2 262 14
 648 0009 F8 A4 03                		mov.B	#3, [r10]
 263:../src/src/tls.c ****     pv.minor = TLSv1_1_MINOR;
 649                             		.loc 2 263 14
 650 000c F9 A4 01 02             		mov.B	#2, 1[r10]
 264:../src/src/tls.c **** 
 265:../src/src/tls.c ****     return pv;
 651                             		.loc 2 265 12
 652 0010 DC A4                   		mov.W	[r10], r4
 653 0012 D3 54                   		mov.W	r4, [r5]
 266:../src/src/tls.c **** }
 654                             		.loc 2 266 1
 655 0014 EF 51                   		mov.L	r5, r1
 656 0016 3F AA 02                		rtsd	#8, r10-r10
 657                             	.LFE45:
 659                             		.section	.text.MakeTLSv1_2,"ax",@progbits
 660                             		.global	_MakeTLSv1_2
 662                             	_MakeTLSv1_2:
 663                             	.LFB46:
 267:../src/src/tls.c **** 
 268:../src/src/tls.c **** #endif /* !NO_OLD_TLS */
 269:../src/src/tls.c **** 
 270:../src/src/tls.c **** 
 271:../src/src/tls.c **** #ifndef WOLFSSL_NO_TLS12
 272:../src/src/tls.c **** 
 273:../src/src/tls.c **** ProtocolVersion MakeTLSv1_2(void)
 274:../src/src/tls.c **** {
 664                             		.loc 2 274 1
 665 0000 7E AA                   		push.l	r10
 666                             	.LCFI26:
 667 0002 71 0A FC                		add	#-4, r0, r10
 668                             	.LCFI27:
 669 0005 EF A0                   		mov.L	r10, r0
 670 0007 EF F5                   		mov.L	r15, r5
 275:../src/src/tls.c ****     ProtocolVersion pv;
 276:../src/src/tls.c ****     pv.major = SSLv3_MAJOR;
 671                             		.loc 2 276 14
 672 0009 F8 A4 03                		mov.B	#3, [r10]
 277:../src/src/tls.c ****     pv.minor = TLSv1_2_MINOR;
 673                             		.loc 2 277 14
 674 000c F9 A4 01 03             		mov.B	#3, 1[r10]
 278:../src/src/tls.c **** 
 279:../src/src/tls.c ****     return pv;
 675                             		.loc 2 279 12
 676 0010 DC A4                   		mov.W	[r10], r4
 677 0012 D3 54                   		mov.W	r4, [r5]
 280:../src/src/tls.c **** }
 678                             		.loc 2 280 1
 679 0014 EF 51                   		mov.L	r5, r1
 680 0016 3F AA 02                		rtsd	#8, r10-r10
 681                             	.LFE46:
 683                             		.section	.rodata.master_label,"a"
 686                             	_master_label:
 687 0000 6D 61 73 74 65 72 20 73 		.string	"master secret"
 687      65 63 72 65 74 00 
 688                             		.section	.rodata.key_label,"a"
 691                             	_key_label:
 692 0000 6B 65 79 20 65 78 70 61 		.string	"key expansion"
 692      6E 73 69 6F 6E 00 
 693                             		.section	.text._DeriveTlsKeys,"ax",@progbits
 695                             	__DeriveTlsKeys:
 696                             	.LFB47:
 281:../src/src/tls.c **** 
 282:../src/src/tls.c **** #endif /* !WOLFSSL_NO_TLS12 */
 283:../src/src/tls.c **** 
 284:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
 285:../src/src/tls.c **** /* The TLS v1.3 protocol version.
 286:../src/src/tls.c ****  *
 287:../src/src/tls.c ****  * returns the protocol version data for TLS v1.3.
 288:../src/src/tls.c ****  */
 289:../src/src/tls.c **** ProtocolVersion MakeTLSv1_3(void)
 290:../src/src/tls.c **** {
 291:../src/src/tls.c ****     ProtocolVersion pv;
 292:../src/src/tls.c ****     pv.major = SSLv3_MAJOR;
 293:../src/src/tls.c ****     pv.minor = TLSv1_3_MINOR;
 294:../src/src/tls.c **** 
 295:../src/src/tls.c ****     return pv;
 296:../src/src/tls.c **** }
 297:../src/src/tls.c **** #endif
 298:../src/src/tls.c **** 
 299:../src/src/tls.c **** #ifndef WOLFSSL_NO_TLS12
 300:../src/src/tls.c **** 
 301:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
 302:../src/src/tls.c **** static const byte ext_master_label[EXT_MASTER_LABEL_SZ + 1] =
 303:../src/src/tls.c ****                                                       "extended master secret";
 304:../src/src/tls.c **** #endif
 305:../src/src/tls.c **** static const byte master_label[MASTER_LABEL_SZ + 1] = "master secret";
 306:../src/src/tls.c **** static const byte key_label   [KEY_LABEL_SZ + 1]    = "key expansion";
 307:../src/src/tls.c **** 
 308:../src/src/tls.c **** static int _DeriveTlsKeys(byte* key_dig, word32 key_dig_len,
 309:../src/src/tls.c ****                          const byte* ms, word32 msLen,
 310:../src/src/tls.c ****                          const byte* sr, const byte* cr,
 311:../src/src/tls.c ****                          int tls1_2, int hash_type,
 312:../src/src/tls.c ****                          void* heap, int devId)
 313:../src/src/tls.c **** {
 697                             		.loc 2 313 1
 698 0000 7E AA                   		push.l	r10
 699                             	.LCFI28:
 700 0002 7E A6                   		push.l	r6
 701                             	.LCFI29:
 702 0004 71 0A 94                		add	#-108, r0, r10
 703                             	.LCFI30:
 704 0007 71 A0 E0                		add	#-32, r10, r0
 705                             	.LCFI31:
 706 000a 75 46 78                		mov.L	#0x78, r6
 707 000d 4B A6                   		add	r10, r6
 708 000f E7 A1 11                		mov.L	r1, 68[r10]
 709 0012 E7 A2 12                		mov.L	r2, 72[r10]
 710 0015 E7 A3 13                		mov.L	r3, 76[r10]
 711 0018 E7 A4 14                		mov.L	r4, 80[r10]
 314:../src/src/tls.c ****     int ret;
 315:../src/src/tls.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && !defined(WC_ASYNC_NO_HASH)
 316:../src/src/tls.c ****     WC_DECLARE_VAR(seed, byte, SEED_LEN, heap);
 317:../src/src/tls.c ****     if (seed == NULL)
 318:../src/src/tls.c ****         return MEMORY_E;
 319:../src/src/tls.c **** #else
 320:../src/src/tls.c ****     byte seed[SEED_LEN];
 321:../src/src/tls.c **** #endif
 322:../src/src/tls.c **** 
 323:../src/src/tls.c ****     XMEMCPY(seed,           sr, RAN_LEN);
 712                             		.loc 2 323 5
 713 001b 71 A5 04                		add	#4, r10, r5
 714 001e 75 43 20                		mov.L	#32, r3
 715 0021 EC 62                   		mov.L	[r6], r2
 716 0023 EF 51                   		mov.L	r5, r1
 717 0025 05 00 00 00             		bsr	_memcpy
 324:../src/src/tls.c ****     XMEMCPY(seed + RAN_LEN, cr, RAN_LEN);
 718                             		.loc 2 324 5
 719 0029 71 A5 04                		add	#4, r10, r5
 720 002c 71 55 20                		add	#32, r5
 721 002f 75 43 20                		mov.L	#32, r3
 722 0032 A8 6A                   		mov.L	4[r6], r2
 723 0034 EF 51                   		mov.L	r5, r1
 724 0036 05 00 00 00             		bsr	_memcpy
 325:../src/src/tls.c **** 
 326:../src/src/tls.c **** #ifdef WOLFSSL_HAVE_PRF
 327:../src/src/tls.c ****     PRIVATE_KEY_UNLOCK();
 328:../src/src/tls.c ****     ret = wc_PRF_TLS(key_dig, key_dig_len, ms, msLen, key_label, KEY_LABEL_SZ,
 725                             		.loc 2 328 11
 726 003a A9 6D                   		mov.L	20[r6], r5
 727 003c A1 8D                   		mov.L	r5, 28[r0]
 728 003e A9 65                   		mov.L	16[r6], r5
 729 0040 A1 85                   		mov.L	r5, 24[r0]
 730 0042 A8 ED                   		mov.L	12[r6], r5
 731 0044 A1 0D                   		mov.L	r5, 20[r0]
 732 0046 A8 E5                   		mov.L	8[r6], r5
 733 0048 A1 05                   		mov.L	r5, 16[r0]
 734 004a 3E 03 40                		mov.L	#0x40, 12[r0]
 735 004d 71 A5 04                		add	#4, r10, r5
 736 0050 A0 85                   		mov.L	r5, 8[r0]
 737 0052 3E 01 0D                		mov.L	#13, 4[r0]
 738 0055 F8 02 00 00 00 00       		mov.L	#_key_label, [r0]
 739 005b ED A4 14                		mov.L	80[r10], r4
 740 005e ED A3 13                		mov.L	76[r10], r3
 741 0061 ED A2 12                		mov.L	72[r10], r2
 742 0064 ED A1 11                		mov.L	68[r10], r1
 743 0067 05 00 00 00             		bsr	_wc_PRF_TLS
 744 006b E3 A1                   		mov.L	r1, [r10]
 329:../src/src/tls.c ****                seed, SEED_LEN, tls1_2, hash_type, heap, devId);
 330:../src/src/tls.c ****     PRIVATE_KEY_LOCK();
 331:../src/src/tls.c **** #else
 332:../src/src/tls.c ****     /* Pseudo random function must be enabled in the configuration. */
 333:../src/src/tls.c ****     ret = PRF_MISSING;
 334:../src/src/tls.c ****     WOLFSSL_MSG("Pseudo-random function is not enabled");
 335:../src/src/tls.c **** 
 336:../src/src/tls.c ****     (void)key_dig;
 337:../src/src/tls.c ****     (void)key_dig_len;
 338:../src/src/tls.c ****     (void)ms;
 339:../src/src/tls.c ****     (void)msLen;
 340:../src/src/tls.c ****     (void)tls1_2;
 341:../src/src/tls.c ****     (void)hash_type;
 342:../src/src/tls.c ****     (void)heap;
 343:../src/src/tls.c ****     (void)devId;
 344:../src/src/tls.c ****     (void)key_label;
 345:../src/src/tls.c ****     (void)master_label;
 346:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
 347:../src/src/tls.c ****     (void)ext_master_label;
 348:../src/src/tls.c **** #endif
 349:../src/src/tls.c **** #endif
 350:../src/src/tls.c **** 
 351:../src/src/tls.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && !defined(WC_ASYNC_NO_HASH)
 352:../src/src/tls.c ****     WC_FREE_VAR(seed, heap);
 353:../src/src/tls.c **** #endif
 354:../src/src/tls.c **** 
 355:../src/src/tls.c ****     return ret;
 745                             		.loc 2 355 12
 746 006d EC A5                   		mov.L	[r10], r5
 356:../src/src/tls.c **** }
 747                             		.loc 2 356 1
 748 006f EF 51                   		mov.L	r5, r1
 749 0071 72 00 8C 00             		add	#0x8c, r0
 750 0075 7E B6                   		pop	r6
 751 0077 7E BA                   		pop	r10
 752 0079 02                      		rts
 753                             	.LFE47:
 755                             		.section	.text.wolfSSL_DeriveTlsKeys,"ax",@progbits
 756                             		.global	_wolfSSL_DeriveTlsKeys
 758                             	_wolfSSL_DeriveTlsKeys:
 759                             	.LFB48:
 357:../src/src/tls.c **** 
 358:../src/src/tls.c **** /* External facing wrapper so user can call as well, 0 on success */
 359:../src/src/tls.c **** int wolfSSL_DeriveTlsKeys(byte* key_dig, word32 key_dig_len,
 360:../src/src/tls.c ****                          const byte* ms, word32 msLen,
 361:../src/src/tls.c ****                          const byte* sr, const byte* cr,
 362:../src/src/tls.c ****                          int tls1_2, int hash_type)
 363:../src/src/tls.c **** {
 760                             		.loc 2 363 1
 761 0000 7E AA                   		push.l	r10
 762                             	.LCFI32:
 763 0002 71 0A E0                		add	#-32, r0, r10
 764                             	.LCFI33:
 765 0005 71 A0 E8                		add	#-24, r10, r0
 766                             	.LCFI34:
 767 0008 75 45 28                		mov.L	#40, r5
 768 000b 4B A5                   		add	r10, r5
 769 000d E3 A1                   		mov.L	r1, [r10]
 770 000f E7 A2 01                		mov.L	r2, 4[r10]
 771 0012 E7 A3 02                		mov.L	r3, 8[r10]
 772 0015 E7 A4 03                		mov.L	r4, 12[r10]
 364:../src/src/tls.c ****     return _DeriveTlsKeys(key_dig, key_dig_len, ms, msLen, sr, cr, tls1_2,
 773                             		.loc 2 364 12
 774 0018 F9 06 05 FE             		mov.L	#-2, 20[r0]
 775 001c 3E 04 00                		mov.L	#0, 16[r0]
 776 001f A8 DC                   		mov.L	12[r5], r4
 777 0021 A0 8C                   		mov.L	r4, 12[r0]
 778 0023 A8 D4                   		mov.L	8[r5], r4
 779 0025 A0 84                   		mov.L	r4, 8[r0]
 780 0027 A8 5C                   		mov.L	4[r5], r4
 781 0029 A0 0C                   		mov.L	r4, 4[r0]
 782 002b EC 55                   		mov.L	[r5], r5
 783 002d E3 05                   		mov.L	r5, [r0]
 784 002f ED A4 03                		mov.L	12[r10], r4
 785 0032 ED A3 02                		mov.L	8[r10], r3
 786 0035 ED A2 01                		mov.L	4[r10], r2
 787 0038 EC A1                   		mov.L	[r10], r1
 788 003a 05 00 00 00             		bsr	__DeriveTlsKeys
 789 003e EF 15                   		mov.L	r1, r5
 365:../src/src/tls.c ****         hash_type, NULL, INVALID_DEVID);
 366:../src/src/tls.c **** }
 790                             		.loc 2 366 1
 791 0040 EF 51                   		mov.L	r5, r1
 792 0042 3F AA 0F                		rtsd	#60, r10-r10
 793                             	.LFE48:
 795                             		.section	.text.DeriveTlsKeys,"ax",@progbits
 796                             		.global	_DeriveTlsKeys
 798                             	_DeriveTlsKeys:
 799                             	.LFB49:
 367:../src/src/tls.c **** 
 368:../src/src/tls.c **** 
 369:../src/src/tls.c **** int DeriveTlsKeys(WOLFSSL* ssl)
 370:../src/src/tls.c **** {
 800                             		.loc 2 370 1
 801 0000 6E 6C                   		pushm	r6-r12
 802                             	.LCFI35:
 803 0002 71 0A EC                		add	#-20, r0, r10
 804                             	.LCFI36:
 805 0005 71 A0 E8                		add	#-24, r10, r0
 806                             	.LCFI37:
 807 0008 E7 A1 04                		mov.L	r1, 16[r10]
 371:../src/src/tls.c ****     int   ret;
 372:../src/src/tls.c ****     int   key_dig_len = 2 * ssl->specs.hash_size +
 808                             		.loc 2 372 39
 809 000b ED A5 04                		mov.L	16[r10], r5
 810 000e CE 55 71 01             		mov.B	369[r5], r5
 811 0012 5B 54                   		movu.B	r5, r4
 373:../src/src/tls.c ****                         2 * ssl->specs.key_size  +
 812                             		.loc 2 373 39
 813 0014 ED A5 04                		mov.L	16[r10], r5
 814 0017 DD 55 B2                		mov.W	356[r5], r5
 815 001a 5F 55                   		movu.W	r5, r5
 372:../src/src/tls.c ****                         2 * ssl->specs.key_size  +
 816                             		.loc 2 372 50
 817 001c 4B 54                   		add	r5, r4
 374:../src/src/tls.c ****                         2 * ssl->specs.iv_size;
 818                             		.loc 2 374 39
 819 001e ED A5 04                		mov.L	16[r10], r5
 820 0021 DD 55 B3                		mov.W	358[r5], r5
 821 0024 5F 55                   		movu.W	r5, r5
 373:../src/src/tls.c ****                         2 * ssl->specs.key_size  +
 822                             		.loc 2 373 50
 823 0026 4B 45                   		add	r4, r5
 372:../src/src/tls.c ****                         2 * ssl->specs.key_size  +
 824                             		.loc 2 372 11
 825 0028 4B 55                   		add	r5, r5
 826 002a E7 A5 01                		mov.L	r5, 4[r10]
 375:../src/src/tls.c **** #ifdef WOLFSSL_SMALL_STACK
 376:../src/src/tls.c ****     byte* key_dig;
 377:../src/src/tls.c **** #else
 378:../src/src/tls.c ****     byte  key_dig[MAX_PRF_DIG];
 379:../src/src/tls.c **** #endif
 380:../src/src/tls.c **** 
 381:../src/src/tls.c **** #ifdef WOLFSSL_SMALL_STACK
 382:../src/src/tls.c ****     key_dig = (byte*)XMALLOC(MAX_PRF_DIG, ssl->heap, DYNAMIC_TYPE_DIGEST);
 827                             		.loc 2 382 22
 828 002d 75 41 E0                		mov.L	#0xe0, r1
 829 0030 05 00 00 00             		bsr	_wolfSSL_Malloc
 830 0034 E7 A1 02                		mov.L	r1, 8[r10]
 383:../src/src/tls.c ****     if (key_dig == NULL) {
 831                             		.loc 2 383 8
 832 0037 ED A5 02                		mov.L	8[r10], r5
 833 003a 61 05                   		cmp	#0, r5
 834 003c 1F                      		bne	.L40
 384:../src/src/tls.c ****         return MEMORY_E;
 835                             		.loc 2 384 16
 836 003d FB 56 83                		mov.L	#-125, r5
 837 0040 38 84 00                		bra	.L41
 838                             	.L40:
 385:../src/src/tls.c ****     }
 386:../src/src/tls.c **** #endif
 387:../src/src/tls.c **** #if !defined(NO_CERTS) && defined(HAVE_PK_CALLBACKS)
 388:../src/src/tls.c ****         ret = PROTOCOLCB_UNAVAILABLE;
 389:../src/src/tls.c ****         if (ssl->ctx->GenSessionKeyCb) {
 390:../src/src/tls.c ****             void* ctx = wolfSSL_GetGenSessionKeyCtx(ssl);
 391:../src/src/tls.c ****             ret = ssl->ctx->GenSessionKeyCb(ssl, ctx);
 392:../src/src/tls.c ****         }
 393:../src/src/tls.c ****         if (!ssl->ctx->GenSessionKeyCb || ret == PROTOCOLCB_UNAVAILABLE)
 394:../src/src/tls.c **** #endif
 395:../src/src/tls.c ****         ret = _DeriveTlsKeys(key_dig, key_dig_len,
 839                             		.loc 2 395 15
 840 0043 ED A9 01                		mov.L	4[r10], r9
 396:../src/src/tls.c ****                          ssl->arrays->masterSecret, SECRET_LEN,
 841                             		.loc 2 396 29
 842 0046 ED A5 04                		mov.L	16[r10], r5
 843 0049 A8 D5                   		mov.L	8[r5], r5
 844                             		.loc 2 396 37
 845 004b 72 56 BB 01             		add	#0x1bb, r5, r6
 397:../src/src/tls.c ****                          ssl->arrays->serverRandom, ssl->arrays->clientRandom,
 846                             		.loc 2 397 29
 847 004f ED A5 04                		mov.L	16[r10], r5
 848 0052 A8 D5                   		mov.L	8[r5], r5
 849                             		.loc 2 397 37
 850 0054 72 5B 7A 01             		add	#0x17a, r5, r11
 851                             		.loc 2 397 56
 852 0058 ED A5 04                		mov.L	16[r10], r5
 853 005b A8 D5                   		mov.L	8[r5], r5
 854                             		.loc 2 397 64
 855 005d 72 5C 5A 01             		add	#0x15a, r5, r12
 395:../src/src/tls.c ****                          ssl->arrays->masterSecret, SECRET_LEN,
 856                             		.loc 2 395 15
 857 0061 ED A1 04                		mov.L	16[r10], r1
 858 0064 05 00 00 00             		bsr	_IsAtLeastTLSv1_2
 859 0068 EF 13                   		mov.L	r1, r3
 398:../src/src/tls.c ****                          IsAtLeastTLSv1_2(ssl), ssl->specs.mac_algorithm,
 860                             		.loc 2 398 59
 861 006a ED A5 04                		mov.L	16[r10], r5
 862 006d CE 55 6E 01             		mov.B	366[r5], r5
 395:../src/src/tls.c ****                          ssl->arrays->masterSecret, SECRET_LEN,
 863                             		.loc 2 395 15
 864 0071 5B 54                   		movu.B	r5, r4
 865 0073 ED A5 04                		mov.L	16[r10], r5
 866 0076 AA 5A                   		mov.L	36[r5], r2
 867 0078 ED A5 04                		mov.L	16[r10], r5
 868 007b ED 55 BE                		mov.L	760[r5], r5
 869 007e A1 0D                   		mov.L	r5, 20[r0]
 870 0080 A1 02                   		mov.L	r2, 16[r0]
 871 0082 A0 8C                   		mov.L	r4, 12[r0]
 872 0084 A0 83                   		mov.L	r3, 8[r0]
 873 0086 E7 0C 01                		mov.L	r12, 4[r0]
 874 0089 E3 0B                   		mov.L	r11, [r0]
 875 008b 75 44 30                		mov.L	#48, r4
 876 008e EF 63                   		mov.L	r6, r3
 877 0090 EF 92                   		mov.L	r9, r2
 878 0092 ED A1 02                		mov.L	8[r10], r1
 879 0095 05 00 00 00             		bsr	__DeriveTlsKeys
 880 0099 E3 A1                   		mov.L	r1, [r10]
 399:../src/src/tls.c ****                          ssl->heap, ssl->devId);
 400:../src/src/tls.c ****     if (ret == 0)
 881                             		.loc 2 400 8
 882 009b EC A5                   		mov.L	[r10], r5
 883 009d 61 05                   		cmp	#0, r5
 884 009f 21 10                   		bne	.L42
 401:../src/src/tls.c ****         ret = StoreKeys(ssl, key_dig, PROVISION_CLIENT_SERVER);
 885                             		.loc 2 401 15
 886 00a1 66 33                   		mov.L	#3, r3
 887 00a3 ED A2 02                		mov.L	8[r10], r2
 888 00a6 ED A1 04                		mov.L	16[r10], r1
 889 00a9 05 00 00 00             		bsr	_StoreKeys
 890 00ad E3 A1                   		mov.L	r1, [r10]
 891                             	.L42:
 892                             	.LBB2:
 402:../src/src/tls.c **** 
 403:../src/src/tls.c **** #ifdef WOLFSSL_SMALL_STACK
 404:../src/src/tls.c ****     XFREE(key_dig, ssl->heap, DYNAMIC_TYPE_DIGEST);
 893                             		.loc 2 404 5
 894 00af ED A5 02                		mov.L	8[r10], r5
 895 00b2 E7 A5 03                		mov.L	r5, 12[r10]
 896 00b5 ED A5 03                		mov.L	12[r10], r5
 897 00b8 61 05                   		cmp	#0, r5
 898 00ba 10                      		beq	.L43
 899                             		.loc 2 404 5 is_stmt 0 discriminator 1
 900 00bb ED A1 03                		mov.L	12[r10], r1
 901 00be 05 00 00 00             		bsr	_wolfSSL_Free
 902                             	.L43:
 903                             	.LBE2:
 405:../src/src/tls.c **** #endif
 406:../src/src/tls.c **** 
 407:../src/src/tls.c ****     return ret;
 904                             		.loc 2 407 12 is_stmt 1
 905 00c2 EC A5                   		mov.L	[r10], r5
 906                             	.L41:
 408:../src/src/tls.c **** }
 907                             		.loc 2 408 1
 908 00c4 EF 51                   		mov.L	r5, r1
 909 00c6 3F 6C 12                		rtsd	#72, r6-r12
 910                             	.LFE49:
 912                             		.section	.text._MakeTlsMasterSecret,"ax",@progbits
 914                             	__MakeTlsMasterSecret:
 915                             	.LFB50:
 409:../src/src/tls.c **** 
 410:../src/src/tls.c **** static int _MakeTlsMasterSecret(byte* ms, word32 msLen,
 411:../src/src/tls.c ****                                const byte* pms, word32 pmsLen,
 412:../src/src/tls.c ****                                const byte* cr, const byte* sr,
 413:../src/src/tls.c ****                                int tls1_2, int hash_type,
 414:../src/src/tls.c ****                                void* heap, int devId)
 415:../src/src/tls.c **** {
 916                             		.loc 2 415 1
 917 0000 7E AA                   		push.l	r10
 918                             	.LCFI38:
 919 0002 7E A6                   		push.l	r6
 920                             	.LCFI39:
 921 0004 71 0A 94                		add	#-108, r0, r10
 922                             	.LCFI40:
 923 0007 71 A0 E0                		add	#-32, r10, r0
 924                             	.LCFI41:
 925 000a 75 46 78                		mov.L	#0x78, r6
 926 000d 4B A6                   		add	r10, r6
 927 000f E7 A1 11                		mov.L	r1, 68[r10]
 928 0012 E7 A2 12                		mov.L	r2, 72[r10]
 929 0015 E7 A3 13                		mov.L	r3, 76[r10]
 930 0018 E7 A4 14                		mov.L	r4, 80[r10]
 416:../src/src/tls.c ****     int ret;
 417:../src/src/tls.c **** #if !defined(WOLFSSL_ASYNC_CRYPT) || defined(WC_ASYNC_NO_HASH)
 418:../src/src/tls.c ****     byte seed[SEED_LEN];
 419:../src/src/tls.c **** #else
 420:../src/src/tls.c ****     WC_DECLARE_VAR(seed, byte, SEED_LEN, heap);
 421:../src/src/tls.c ****     if (seed == NULL)
 422:../src/src/tls.c ****         return MEMORY_E;
 423:../src/src/tls.c **** #endif
 424:../src/src/tls.c **** 
 425:../src/src/tls.c ****     XMEMCPY(seed,           cr, RAN_LEN);
 931                             		.loc 2 425 5
 932 001b 71 A5 04                		add	#4, r10, r5
 933 001e 75 43 20                		mov.L	#32, r3
 934 0021 EC 62                   		mov.L	[r6], r2
 935 0023 EF 51                   		mov.L	r5, r1
 936 0025 05 00 00 00             		bsr	_memcpy
 426:../src/src/tls.c ****     XMEMCPY(seed + RAN_LEN, sr, RAN_LEN);
 937                             		.loc 2 426 5
 938 0029 71 A5 04                		add	#4, r10, r5
 939 002c 71 55 20                		add	#32, r5
 940 002f 75 43 20                		mov.L	#32, r3
 941 0032 A8 6A                   		mov.L	4[r6], r2
 942 0034 EF 51                   		mov.L	r5, r1
 943 0036 05 00 00 00             		bsr	_memcpy
 427:../src/src/tls.c **** 
 428:../src/src/tls.c **** #ifdef WOLFSSL_HAVE_PRF
 429:../src/src/tls.c ****     PRIVATE_KEY_UNLOCK();
 430:../src/src/tls.c ****     ret = wc_PRF_TLS(ms, msLen, pms, pmsLen, master_label, MASTER_LABEL_SZ,
 944                             		.loc 2 430 11
 945 003a A9 6D                   		mov.L	20[r6], r5
 946 003c A1 8D                   		mov.L	r5, 28[r0]
 947 003e A9 65                   		mov.L	16[r6], r5
 948 0040 A1 85                   		mov.L	r5, 24[r0]
 949 0042 A8 ED                   		mov.L	12[r6], r5
 950 0044 A1 0D                   		mov.L	r5, 20[r0]
 951 0046 A8 E5                   		mov.L	8[r6], r5
 952 0048 A1 05                   		mov.L	r5, 16[r0]
 953 004a 3E 03 40                		mov.L	#0x40, 12[r0]
 954 004d 71 A5 04                		add	#4, r10, r5
 955 0050 A0 85                   		mov.L	r5, 8[r0]
 956 0052 3E 01 0D                		mov.L	#13, 4[r0]
 957 0055 F8 02 00 00 00 00       		mov.L	#_master_label, [r0]
 958 005b ED A4 14                		mov.L	80[r10], r4
 959 005e ED A3 13                		mov.L	76[r10], r3
 960 0061 ED A2 12                		mov.L	72[r10], r2
 961 0064 ED A1 11                		mov.L	68[r10], r1
 962 0067 05 00 00 00             		bsr	_wc_PRF_TLS
 963 006b E3 A1                   		mov.L	r1, [r10]
 431:../src/src/tls.c ****                seed, SEED_LEN, tls1_2, hash_type, heap, devId);
 432:../src/src/tls.c ****     PRIVATE_KEY_LOCK();
 433:../src/src/tls.c **** #else
 434:../src/src/tls.c ****     /* Pseudo random function must be enabled in the configuration. */
 435:../src/src/tls.c ****     ret = PRF_MISSING;
 436:../src/src/tls.c ****     WOLFSSL_MSG("Pseudo-random function is not enabled");
 437:../src/src/tls.c **** 
 438:../src/src/tls.c ****     (void)ms;
 439:../src/src/tls.c ****     (void)msLen;
 440:../src/src/tls.c ****     (void)pms;
 441:../src/src/tls.c ****     (void)pmsLen;
 442:../src/src/tls.c ****     (void)tls1_2;
 443:../src/src/tls.c ****     (void)hash_type;
 444:../src/src/tls.c ****     (void)heap;
 445:../src/src/tls.c ****     (void)devId;
 446:../src/src/tls.c **** #endif
 447:../src/src/tls.c **** 
 448:../src/src/tls.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && !defined(WC_ASYNC_NO_HASH)
 449:../src/src/tls.c ****     WC_FREE_VAR(seed, heap);
 450:../src/src/tls.c **** #endif
 451:../src/src/tls.c **** 
 452:../src/src/tls.c ****     return ret;
 964                             		.loc 2 452 12
 965 006d EC A5                   		mov.L	[r10], r5
 453:../src/src/tls.c **** }
 966                             		.loc 2 453 1
 967 006f EF 51                   		mov.L	r5, r1
 968 0071 72 00 8C 00             		add	#0x8c, r0
 969 0075 7E B6                   		pop	r6
 970 0077 7E BA                   		pop	r10
 971 0079 02                      		rts
 972                             	.LFE50:
 974                             		.section	.text.wolfSSL_MakeTlsMasterSecret,"ax",@progbits
 975                             		.global	_wolfSSL_MakeTlsMasterSecret
 977                             	_wolfSSL_MakeTlsMasterSecret:
 978                             	.LFB51:
 454:../src/src/tls.c **** 
 455:../src/src/tls.c **** /* External facing wrapper so user can call as well, 0 on success */
 456:../src/src/tls.c **** int wolfSSL_MakeTlsMasterSecret(byte* ms, word32 msLen,
 457:../src/src/tls.c ****                                const byte* pms, word32 pmsLen,
 458:../src/src/tls.c ****                                const byte* cr, const byte* sr,
 459:../src/src/tls.c ****                                int tls1_2, int hash_type)
 460:../src/src/tls.c **** {
 979                             		.loc 2 460 1
 980 0000 7E AA                   		push.l	r10
 981                             	.LCFI42:
 982 0002 71 0A E0                		add	#-32, r0, r10
 983                             	.LCFI43:
 984 0005 71 A0 E8                		add	#-24, r10, r0
 985                             	.LCFI44:
 986 0008 75 45 28                		mov.L	#40, r5
 987 000b 4B A5                   		add	r10, r5
 988 000d E3 A1                   		mov.L	r1, [r10]
 989 000f E7 A2 01                		mov.L	r2, 4[r10]
 990 0012 E7 A3 02                		mov.L	r3, 8[r10]
 991 0015 E7 A4 03                		mov.L	r4, 12[r10]
 461:../src/src/tls.c ****     return _MakeTlsMasterSecret(ms, msLen, pms, pmsLen, cr, sr, tls1_2,
 992                             		.loc 2 461 12
 993 0018 F9 06 05 FE             		mov.L	#-2, 20[r0]
 994 001c 3E 04 00                		mov.L	#0, 16[r0]
 995 001f A8 DC                   		mov.L	12[r5], r4
 996 0021 A0 8C                   		mov.L	r4, 12[r0]
 997 0023 A8 D4                   		mov.L	8[r5], r4
 998 0025 A0 84                   		mov.L	r4, 8[r0]
 999 0027 A8 5C                   		mov.L	4[r5], r4
 1000 0029 A0 0C                   		mov.L	r4, 4[r0]
 1001 002b EC 55                   		mov.L	[r5], r5
 1002 002d E3 05                   		mov.L	r5, [r0]
 1003 002f ED A4 03                		mov.L	12[r10], r4
 1004 0032 ED A3 02                		mov.L	8[r10], r3
 1005 0035 ED A2 01                		mov.L	4[r10], r2
 1006 0038 EC A1                   		mov.L	[r10], r1
 1007 003a 05 00 00 00             		bsr	__MakeTlsMasterSecret
 1008 003e EF 15                   		mov.L	r1, r5
 462:../src/src/tls.c ****         hash_type, NULL, INVALID_DEVID);
 463:../src/src/tls.c **** }
 1009                             		.loc 2 463 1
 1010 0040 EF 51                   		mov.L	r5, r1
 1011 0042 3F AA 0F                		rtsd	#60, r10-r10
 1012                             	.LFE51:
 1014                             		.section	.text.MakeTlsMasterSecret,"ax",@progbits
 1015                             		.global	_MakeTlsMasterSecret
 1017                             	_MakeTlsMasterSecret:
 1018                             	.LFB52:
 464:../src/src/tls.c **** 
 465:../src/src/tls.c **** 
 466:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
 467:../src/src/tls.c **** 
 468:../src/src/tls.c **** static int _MakeTlsExtendedMasterSecret(byte* ms, word32 msLen,
 469:../src/src/tls.c ****                                         const byte* pms, word32 pmsLen,
 470:../src/src/tls.c ****                                         const byte* sHash, word32 sHashLen,
 471:../src/src/tls.c ****                                         int tls1_2, int hash_type,
 472:../src/src/tls.c ****                                         void* heap, int devId)
 473:../src/src/tls.c **** {
 474:../src/src/tls.c ****     int ret;
 475:../src/src/tls.c **** 
 476:../src/src/tls.c **** #ifdef WOLFSSL_HAVE_PRF
 477:../src/src/tls.c ****     PRIVATE_KEY_UNLOCK();
 478:../src/src/tls.c ****     ret = wc_PRF_TLS(ms, msLen, pms, pmsLen, ext_master_label, EXT_MASTER_LABEL_SZ,
 479:../src/src/tls.c ****                sHash, sHashLen, tls1_2, hash_type, heap, devId);
 480:../src/src/tls.c ****     PRIVATE_KEY_LOCK();
 481:../src/src/tls.c **** #else
 482:../src/src/tls.c ****     /* Pseudo random function must be enabled in the configuration. */
 483:../src/src/tls.c ****     ret = PRF_MISSING;
 484:../src/src/tls.c ****     WOLFSSL_MSG("Pseudo-random function is not enabled");
 485:../src/src/tls.c **** 
 486:../src/src/tls.c ****     (void)ms;
 487:../src/src/tls.c ****     (void)msLen;
 488:../src/src/tls.c ****     (void)pms;
 489:../src/src/tls.c ****     (void)pmsLen;
 490:../src/src/tls.c ****     (void)sHash;
 491:../src/src/tls.c ****     (void)sHashLen;
 492:../src/src/tls.c ****     (void)tls1_2;
 493:../src/src/tls.c ****     (void)hash_type;
 494:../src/src/tls.c ****     (void)heap;
 495:../src/src/tls.c ****     (void)devId;
 496:../src/src/tls.c **** #endif
 497:../src/src/tls.c ****     return ret;
 498:../src/src/tls.c **** }
 499:../src/src/tls.c **** 
 500:../src/src/tls.c **** /* External facing wrapper so user can call as well, 0 on success */
 501:../src/src/tls.c **** int wolfSSL_MakeTlsExtendedMasterSecret(byte* ms, word32 msLen,
 502:../src/src/tls.c ****                                         const byte* pms, word32 pmsLen,
 503:../src/src/tls.c ****                                         const byte* sHash, word32 sHashLen,
 504:../src/src/tls.c ****                                         int tls1_2, int hash_type)
 505:../src/src/tls.c **** {
 506:../src/src/tls.c ****     return _MakeTlsExtendedMasterSecret(ms, msLen, pms, pmsLen, sHash, sHashLen,
 507:../src/src/tls.c ****         tls1_2, hash_type, NULL, INVALID_DEVID);
 508:../src/src/tls.c **** }
 509:../src/src/tls.c **** 
 510:../src/src/tls.c **** #endif /* HAVE_EXTENDED_MASTER */
 511:../src/src/tls.c **** 
 512:../src/src/tls.c **** 
 513:../src/src/tls.c **** int MakeTlsMasterSecret(WOLFSSL* ssl)
 514:../src/src/tls.c **** {
 1019                             		.loc 2 514 1
 1020 0000 6E 6C                   		pushm	r6-r12
 1021                             	.LCFI45:
 1022 0002 71 0A F8                		add	#-8, r0, r10
 1023                             	.LCFI46:
 1024 0005 71 A0 E8                		add	#-24, r10, r0
 1025                             	.LCFI47:
 1026 0008 E7 A1 01                		mov.L	r1, 4[r10]
 515:../src/src/tls.c ****     int ret;
 516:../src/src/tls.c **** 
 517:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
 518:../src/src/tls.c ****     if (ssl->options.haveEMS) {
 519:../src/src/tls.c ****         word32 hashSz = HSHASH_SZ;
 520:../src/src/tls.c ****     #ifdef WOLFSSL_SMALL_STACK
 521:../src/src/tls.c ****         byte* handshake_hash = (byte*)XMALLOC(HSHASH_SZ, ssl->heap,
 522:../src/src/tls.c ****                                               DYNAMIC_TYPE_DIGEST);
 523:../src/src/tls.c ****         if (handshake_hash == NULL)
 524:../src/src/tls.c ****             return MEMORY_E;
 525:../src/src/tls.c ****     #else
 526:../src/src/tls.c ****         byte handshake_hash[HSHASH_SZ];
 527:../src/src/tls.c ****     #endif
 528:../src/src/tls.c **** 
 529:../src/src/tls.c ****         ret = BuildTlsHandshakeHash(ssl, handshake_hash, &hashSz);
 530:../src/src/tls.c ****         if (ret == 0) {
 531:../src/src/tls.c ****             ret = _MakeTlsExtendedMasterSecret(
 532:../src/src/tls.c ****                 ssl->arrays->masterSecret, SECRET_LEN,
 533:../src/src/tls.c ****                 ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz,
 534:../src/src/tls.c ****                 handshake_hash, hashSz,
 535:../src/src/tls.c ****                 IsAtLeastTLSv1_2(ssl), ssl->specs.mac_algorithm,
 536:../src/src/tls.c ****                 ssl->heap, ssl->devId);
 537:../src/src/tls.c ****             ForceZero(handshake_hash, hashSz);
 538:../src/src/tls.c ****         }
 539:../src/src/tls.c **** 
 540:../src/src/tls.c ****     #ifdef WOLFSSL_SMALL_STACK
 541:../src/src/tls.c ****         XFREE(handshake_hash, ssl->heap, DYNAMIC_TYPE_DIGEST);
 542:../src/src/tls.c ****     #elif defined(WOLFSSL_CHECK_MEM_ZERO)
 543:../src/src/tls.c ****         wc_MemZero_Check(handshake_hash, HSHASH_SZ);
 544:../src/src/tls.c ****     #endif
 545:../src/src/tls.c ****     }
 546:../src/src/tls.c ****     else
 547:../src/src/tls.c **** #endif /* HAVE_EXTENDED_MASTER */
 548:../src/src/tls.c ****     {
 549:../src/src/tls.c **** 
 550:../src/src/tls.c **** #if !defined(NO_CERTS) && defined(HAVE_PK_CALLBACKS)
 551:../src/src/tls.c ****         ret = PROTOCOLCB_UNAVAILABLE;
 552:../src/src/tls.c ****         if (ssl->ctx->GenMasterCb) {
 553:../src/src/tls.c ****             void* ctx = wolfSSL_GetGenMasterSecretCtx(ssl);
 554:../src/src/tls.c ****             ret = ssl->ctx->GenMasterCb(ssl, ctx);
 555:../src/src/tls.c ****         }
 556:../src/src/tls.c ****         if (!ssl->ctx->GenMasterCb || ret == PROTOCOLCB_UNAVAILABLE)
 557:../src/src/tls.c **** #endif
 558:../src/src/tls.c ****         ret = _MakeTlsMasterSecret(ssl->arrays->masterSecret, SECRET_LEN,
 1027                             		.loc 2 558 39
 1028 000b ED A5 01                		mov.L	4[r10], r5
 1029 000e A8 D5                   		mov.L	8[r5], r5
 1030                             		.loc 2 558 47
 1031 0010 72 56 BB 01             		add	#0x1bb, r5, r6
 559:../src/src/tls.c ****               ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz,
 1032                             		.loc 2 559 18
 1033 0014 ED A5 01                		mov.L	4[r10], r5
 1034 0017 A8 D5                   		mov.L	8[r5], r5
 1035                             		.loc 2 559 26
 1036 0019 ED 59 01                		mov.L	4[r5], r9
 1037                             		.loc 2 559 48
 1038 001c ED A5 01                		mov.L	4[r10], r5
 1039 001f A8 D5                   		mov.L	8[r5], r5
 558:../src/src/tls.c ****               ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz,
 1040                             		.loc 2 558 15
 1041 0021 ED 58 02                		mov.L	8[r5], r8
 560:../src/src/tls.c ****               ssl->arrays->clientRandom, ssl->arrays->serverRandom,
 1042                             		.loc 2 560 18
 1043 0024 ED A5 01                		mov.L	4[r10], r5
 1044 0027 A8 D5                   		mov.L	8[r5], r5
 1045                             		.loc 2 560 26
 1046 0029 72 5B 5A 01             		add	#0x15a, r5, r11
 1047                             		.loc 2 560 45
 1048 002d ED A5 01                		mov.L	4[r10], r5
 1049 0030 A8 D5                   		mov.L	8[r5], r5
 1050                             		.loc 2 560 53
 1051 0032 72 5C 7A 01             		add	#0x17a, r5, r12
 558:../src/src/tls.c ****               ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz,
 1052                             		.loc 2 558 15
 1053 0036 ED A1 01                		mov.L	4[r10], r1
 1054 0039 05 00 00 00             		bsr	_IsAtLeastTLSv1_2
 1055 003d EF 13                   		mov.L	r1, r3
 561:../src/src/tls.c ****               IsAtLeastTLSv1_2(ssl), ssl->specs.mac_algorithm,
 1056                             		.loc 2 561 48
 1057 003f ED A5 01                		mov.L	4[r10], r5
 1058 0042 CE 55 6E 01             		mov.B	366[r5], r5
 558:../src/src/tls.c ****               ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz,
 1059                             		.loc 2 558 15
 1060 0046 5B 54                   		movu.B	r5, r4
 1061 0048 ED A5 01                		mov.L	4[r10], r5
 1062 004b AA 5A                   		mov.L	36[r5], r2
 1063 004d ED A5 01                		mov.L	4[r10], r5
 1064 0050 ED 55 BE                		mov.L	760[r5], r5
 1065 0053 A1 0D                   		mov.L	r5, 20[r0]
 1066 0055 A1 02                   		mov.L	r2, 16[r0]
 1067 0057 A0 8C                   		mov.L	r4, 12[r0]
 1068 0059 A0 83                   		mov.L	r3, 8[r0]
 1069 005b E7 0C 01                		mov.L	r12, 4[r0]
 1070 005e E3 0B                   		mov.L	r11, [r0]
 1071 0060 EF 84                   		mov.L	r8, r4
 1072 0062 EF 93                   		mov.L	r9, r3
 1073 0064 75 42 30                		mov.L	#48, r2
 1074 0067 EF 61                   		mov.L	r6, r1
 1075 0069 05 00 00 00             		bsr	__MakeTlsMasterSecret
 1076 006d E3 A1                   		mov.L	r1, [r10]
 562:../src/src/tls.c ****               ssl->heap, ssl->devId);
 563:../src/src/tls.c ****     }
 564:../src/src/tls.c ****     if (ret == 0) {
 1077                             		.loc 2 564 8
 1078 006f EC A5                   		mov.L	[r10], r5
 1079 0071 61 05                   		cmp	#0, r5
 1080 0073 1A                      		bne	.L49
 565:../src/src/tls.c ****     #ifdef SHOW_SECRETS
 566:../src/src/tls.c ****         /* Wireshark Pre-Master-Secret Format:
 567:../src/src/tls.c ****          *  CLIENT_RANDOM <clientrandom> <mastersecret>
 568:../src/src/tls.c ****          */
 569:../src/src/tls.c ****         const char* CLIENT_RANDOM_LABEL = "CLIENT_RANDOM";
 570:../src/src/tls.c ****         int i, pmsPos = 0;
 571:../src/src/tls.c ****         char pmsBuf[13 + 1 + 64 + 1 + 96 + 1 + 1];
 572:../src/src/tls.c **** 
 573:../src/src/tls.c ****         XSNPRINTF(&pmsBuf[pmsPos], sizeof(pmsBuf) - pmsPos, "%s ",
 574:../src/src/tls.c ****             CLIENT_RANDOM_LABEL);
 575:../src/src/tls.c ****         pmsPos += XSTRLEN(CLIENT_RANDOM_LABEL) + 1;
 576:../src/src/tls.c ****         for (i = 0; i < RAN_LEN; i++) {
 577:../src/src/tls.c ****             XSNPRINTF(&pmsBuf[pmsPos], sizeof(pmsBuf) - pmsPos, "%02x",
 578:../src/src/tls.c ****                 ssl->arrays->clientRandom[i]);
 579:../src/src/tls.c ****             pmsPos += 2;
 580:../src/src/tls.c ****         }
 581:../src/src/tls.c ****         XSNPRINTF(&pmsBuf[pmsPos], sizeof(pmsBuf) - pmsPos, " ");
 582:../src/src/tls.c ****         pmsPos += 1;
 583:../src/src/tls.c ****         for (i = 0; i < SECRET_LEN; i++) {
 584:../src/src/tls.c ****             XSNPRINTF(&pmsBuf[pmsPos], sizeof(pmsBuf) - pmsPos, "%02x",
 585:../src/src/tls.c ****                 ssl->arrays->masterSecret[i]);
 586:../src/src/tls.c ****             pmsPos += 2;
 587:../src/src/tls.c ****         }
 588:../src/src/tls.c ****         XSNPRINTF(&pmsBuf[pmsPos], sizeof(pmsBuf) - pmsPos, "\n");
 589:../src/src/tls.c ****         pmsPos += 1;
 590:../src/src/tls.c **** 
 591:../src/src/tls.c ****         /* print master secret */
 592:../src/src/tls.c ****         puts(pmsBuf);
 593:../src/src/tls.c **** 
 594:../src/src/tls.c ****         #if !defined(NO_FILESYSTEM) && defined(WOLFSSL_SSLKEYLOGFILE)
 595:../src/src/tls.c ****         {
 596:../src/src/tls.c ****             FILE* f = XFOPEN(WOLFSSL_SSLKEYLOGFILE_OUTPUT, "a");
 597:../src/src/tls.c ****             if (f != XBADFILE) {
 598:../src/src/tls.c ****                 XFWRITE(pmsBuf, 1, pmsPos, f);
 599:../src/src/tls.c ****                 XFCLOSE(f);
 600:../src/src/tls.c ****             }
 601:../src/src/tls.c ****         }
 602:../src/src/tls.c ****         #endif
 603:../src/src/tls.c ****     #endif /* SHOW_SECRETS */
 604:../src/src/tls.c **** 
 605:../src/src/tls.c ****         ret = DeriveTlsKeys(ssl);
 1081                             		.loc 2 605 15
 1082 0074 ED A1 01                		mov.L	4[r10], r1
 1083 0077 05 00 00 00             		bsr	_DeriveTlsKeys
 1084 007b E3 A1                   		mov.L	r1, [r10]
 1085                             	.L49:
 606:../src/src/tls.c ****     }
 607:../src/src/tls.c **** 
 608:../src/src/tls.c ****     return ret;
 1086                             		.loc 2 608 12
 1087 007d EC A5                   		mov.L	[r10], r5
 609:../src/src/tls.c **** }
 1088                             		.loc 2 609 1
 1089 007f EF 51                   		mov.L	r5, r1
 1090 0081 3F 6C 0F                		rtsd	#60, r6-r12
 1091                             	.LFE52:
 1093                             		.section	.text.wolfSSL_make_eap_keys,"ax",@progbits
 1094                             		.global	_wolfSSL_make_eap_keys
 1096                             	_wolfSSL_make_eap_keys:
 1097                             	.LFB53:
 610:../src/src/tls.c **** 
 611:../src/src/tls.c **** 
 612:../src/src/tls.c **** /* Used by EAP-TLS and EAP-TTLS to derive keying material from
 613:../src/src/tls.c ****  * the master_secret. */
 614:../src/src/tls.c **** int wolfSSL_make_eap_keys(WOLFSSL* ssl, void* msk, unsigned int len,
 615:../src/src/tls.c ****                                                               const char* label)
 616:../src/src/tls.c **** {
 1098                             		.loc 2 616 1
 1099 0000 6E 6B                   		pushm	r6-r11
 1100                             	.LCFI48:
 1101 0002 71 0A E4                		add	#-28, r0, r10
 1102                             	.LCFI49:
 1103 0005 71 A0 E0                		add	#-32, r10, r0
 1104                             	.LCFI50:
 1105 0008 E7 A1 03                		mov.L	r1, 12[r10]
 1106 000b E7 A2 04                		mov.L	r2, 16[r10]
 1107 000e E7 A3 05                		mov.L	r3, 20[r10]
 1108 0011 E7 A4 06                		mov.L	r4, 24[r10]
 617:../src/src/tls.c ****     int   ret;
 618:../src/src/tls.c **** #ifdef WOLFSSL_SMALL_STACK
 619:../src/src/tls.c ****     byte* seed;
 620:../src/src/tls.c **** #else
 621:../src/src/tls.c ****     byte  seed[SEED_LEN];
 622:../src/src/tls.c **** #endif
 623:../src/src/tls.c **** 
 624:../src/src/tls.c **** #ifdef WOLFSSL_SMALL_STACK
 625:../src/src/tls.c ****     seed = (byte*)XMALLOC(SEED_LEN, ssl->heap, DYNAMIC_TYPE_SEED);
 1109                             		.loc 2 625 19
 1110 0014 75 41 40                		mov.L	#0x40, r1
 1111 0017 05 00 00 00             		bsr	_wolfSSL_Malloc
 1112 001b E3 A1                   		mov.L	r1, [r10]
 626:../src/src/tls.c ****     if (seed == NULL)
 1113                             		.loc 2 626 8
 1114 001d EC A5                   		mov.L	[r10], r5
 1115 001f 61 05                   		cmp	#0, r5
 1116 0021 1F                      		bne	.L52
 627:../src/src/tls.c ****         return MEMORY_E;
 1117                             		.loc 2 627 16
 1118 0022 FB 56 83                		mov.L	#-125, r5
 1119 0025 38 9D 00                		bra	.L53
 1120                             	.L52:
 628:../src/src/tls.c **** #endif
 629:../src/src/tls.c **** 
 630:../src/src/tls.c ****     /*
 631:../src/src/tls.c ****      * As per RFC-5281, the order of the client and server randoms is reversed
 632:../src/src/tls.c ****      * from that used by the TLS protocol to derive keys.
 633:../src/src/tls.c ****      */
 634:../src/src/tls.c ****     XMEMCPY(seed,           ssl->arrays->clientRandom, RAN_LEN);
 1121                             		.loc 2 634 5
 1122 0028 ED A5 03                		mov.L	12[r10], r5
 1123 002b A8 D5                   		mov.L	8[r5], r5
 1124 002d 72 55 5A 01             		add	#0x15a, r5
 1125 0031 75 43 20                		mov.L	#32, r3
 1126 0034 EF 52                   		mov.L	r5, r2
 1127 0036 EC A1                   		mov.L	[r10], r1
 1128 0038 05 00 00 00             		bsr	_memcpy
 635:../src/src/tls.c ****     XMEMCPY(seed + RAN_LEN, ssl->arrays->serverRandom, RAN_LEN);
 1129                             		.loc 2 635 5
 1130 003c EC A5                   		mov.L	[r10], r5
 1131 003e 71 54 20                		add	#32, r5, r4
 1132 0041 ED A5 03                		mov.L	12[r10], r5
 1133 0044 A8 D5                   		mov.L	8[r5], r5
 1134 0046 72 55 7A 01             		add	#0x17a, r5
 1135 004a 75 43 20                		mov.L	#32, r3
 1136 004d EF 52                   		mov.L	r5, r2
 1137 004f EF 41                   		mov.L	r4, r1
 1138 0051 05 00 00 00             		bsr	_memcpy
 636:../src/src/tls.c **** 
 637:../src/src/tls.c **** #ifdef WOLFSSL_HAVE_PRF
 638:../src/src/tls.c ****     PRIVATE_KEY_UNLOCK();
 639:../src/src/tls.c ****     ret = wc_PRF_TLS((byte*)msk, len, ssl->arrays->masterSecret, SECRET_LEN,
 1139                             		.loc 2 639 42
 1140 0055 ED A5 03                		mov.L	12[r10], r5
 1141 0058 A8 D5                   		mov.L	8[r5], r5
 1142                             		.loc 2 639 50
 1143 005a 72 56 BB 01             		add	#0x1bb, r5, r6
 640:../src/src/tls.c ****               (const byte *)label, (word32)XSTRLEN(label), seed, SEED_LEN,
 1144                             		.loc 2 640 44
 1145 005e ED A1 06                		mov.L	24[r10], r1
 1146 0061 05 00 00 00             		bsr	_strlen
 1147 0065 EF 1B                   		mov.L	r1, r11
 639:../src/src/tls.c ****               (const byte *)label, (word32)XSTRLEN(label), seed, SEED_LEN,
 1148                             		.loc 2 639 11
 1149 0067 ED A1 03                		mov.L	12[r10], r1
 1150 006a 05 00 00 00             		bsr	_IsAtLeastTLSv1_2
 1151 006e EF 13                   		mov.L	r1, r3
 641:../src/src/tls.c ****               IsAtLeastTLSv1_2(ssl), ssl->specs.mac_algorithm,
 1152                             		.loc 2 641 48
 1153 0070 ED A5 03                		mov.L	12[r10], r5
 1154 0073 CE 55 6E 01             		mov.B	366[r5], r5
 639:../src/src/tls.c ****               (const byte *)label, (word32)XSTRLEN(label), seed, SEED_LEN,
 1155                             		.loc 2 639 11
 1156 0077 5B 54                   		movu.B	r5, r4
 1157 0079 ED A5 03                		mov.L	12[r10], r5
 1158 007c AA 5A                   		mov.L	36[r5], r2
 1159 007e ED A5 03                		mov.L	12[r10], r5
 1160 0081 ED 55 BE                		mov.L	760[r5], r5
 1161 0084 A1 8D                   		mov.L	r5, 28[r0]
 1162 0086 A1 82                   		mov.L	r2, 24[r0]
 1163 0088 A1 0C                   		mov.L	r4, 20[r0]
 1164 008a A1 03                   		mov.L	r3, 16[r0]
 1165 008c 3E 03 40                		mov.L	#0x40, 12[r0]
 1166 008f EC A5                   		mov.L	[r10], r5
 1167 0091 A0 85                   		mov.L	r5, 8[r0]
 1168 0093 E7 0B 01                		mov.L	r11, 4[r0]
 1169 0096 ED A5 06                		mov.L	24[r10], r5
 1170 0099 E3 05                   		mov.L	r5, [r0]
 1171 009b 75 44 30                		mov.L	#48, r4
 1172 009e EF 63                   		mov.L	r6, r3
 1173 00a0 ED A2 05                		mov.L	20[r10], r2
 1174 00a3 ED A1 04                		mov.L	16[r10], r1
 1175 00a6 05 00 00 00             		bsr	_wc_PRF_TLS
 1176 00aa E7 A1 01                		mov.L	r1, 4[r10]
 1177                             	.LBB3:
 642:../src/src/tls.c ****               ssl->heap, ssl->devId);
 643:../src/src/tls.c ****     PRIVATE_KEY_LOCK();
 644:../src/src/tls.c **** #else
 645:../src/src/tls.c ****     /* Pseudo random function must be enabled in the configuration. */
 646:../src/src/tls.c ****     ret = PRF_MISSING;
 647:../src/src/tls.c ****     WOLFSSL_MSG("Pseudo-random function is not enabled");
 648:../src/src/tls.c **** 
 649:../src/src/tls.c ****     (void)msk;
 650:../src/src/tls.c ****     (void)len;
 651:../src/src/tls.c ****     (void)label;
 652:../src/src/tls.c **** #endif
 653:../src/src/tls.c **** 
 654:../src/src/tls.c **** #ifdef WOLFSSL_SMALL_STACK
 655:../src/src/tls.c ****     XFREE(seed, ssl->heap, DYNAMIC_TYPE_SEED);
 1178                             		.loc 2 655 5
 1179 00ad EC A5                   		mov.L	[r10], r5
 1180 00af E7 A5 02                		mov.L	r5, 8[r10]
 1181 00b2 ED A5 02                		mov.L	8[r10], r5
 1182 00b5 61 05                   		cmp	#0, r5
 1183 00b7 10                      		beq	.L54
 1184                             		.loc 2 655 5 is_stmt 0 discriminator 1
 1185 00b8 ED A1 02                		mov.L	8[r10], r1
 1186 00bb 05 00 00 00             		bsr	_wolfSSL_Free
 1187                             	.L54:
 1188                             	.LBE3:
 656:../src/src/tls.c **** #endif
 657:../src/src/tls.c **** 
 658:../src/src/tls.c ****     return ret;
 1189                             		.loc 2 658 12 is_stmt 1
 1190 00bf ED A5 01                		mov.L	4[r10], r5
 1191                             	.L53:
 659:../src/src/tls.c **** }
 1192                             		.loc 2 659 1
 1193 00c2 EF 51                   		mov.L	r5, r1
 1194 00c4 3F 6B 15                		rtsd	#84, r6-r11
 1195                             	.LFE53:
 1197                             		.section	.text.wolfSSL_GetHmacType,"ax",@progbits
 1198                             		.global	_wolfSSL_GetHmacType
 1200                             	_wolfSSL_GetHmacType:
 1201                             	.LFB54:
 660:../src/src/tls.c **** 
 661:../src/src/tls.c **** 
 662:../src/src/tls.c **** /* return HMAC digest type in wolfSSL format */
 663:../src/src/tls.c **** int wolfSSL_GetHmacType(WOLFSSL* ssl)
 664:../src/src/tls.c **** {
 1202                             		.loc 2 664 1
 1203 0000 7E AA                   		push.l	r10
 1204                             	.LCFI51:
 1205 0002 71 0A FC                		add	#-4, r0, r10
 1206                             	.LCFI52:
 1207 0005 EF A0                   		mov.L	r10, r0
 1208 0007 E3 A1                   		mov.L	r1, [r10]
 665:../src/src/tls.c ****     if (ssl == NULL)
 1209                             		.loc 2 665 8
 1210 0009 EC A5                   		mov.L	[r10], r5
 1211 000b 61 05                   		cmp	#0, r5
 1212 000d 1F                      		bne	.L56
 666:../src/src/tls.c ****         return BAD_FUNC_ARG;
 1213                             		.loc 2 666 16
 1214 000e FB 5A 53 FF             		mov.L	#-173, r5
 1215 0012 2E 30                   		bra	.L57
 1216                             	.L56:
 667:../src/src/tls.c **** 
 668:../src/src/tls.c ****     switch (ssl->specs.mac_algorithm) {
 1217                             		.loc 2 668 23
 1218 0014 EC A5                   		mov.L	[r10], r5
 1219 0016 CE 55 6E 01             		mov.B	366[r5], r5
 1220 001a 5B 55                   		movu.B	r5, r5
 1221                             		.loc 2 668 5
 1222 001c 61 25                   		cmp	#2, r5
 1223 001e 20 1E                   		beq	.L58
 1224 0020 61 25                   		cmp	#2, r5
 1225 0022 2A 08                   		bgt	.L59
 1226 0024 61 15                   		cmp	#1, r5
 1227 0026 20 0C                   		beq	.L60
 1228 0028 2E 17                   		bra	.L61
 1229                             	.L59:
 1230 002a 61 45                   		cmp	#4, r5
 1231 002c 12                      		beq	.L62
 1232 002d 61 55                   		cmp	#5, r5
 1233 002f 12                      		beq	.L63
 1234 0030 2E 0F                   		bra	.L61
 1235                             	.L60:
 669:../src/src/tls.c ****         #ifndef NO_MD5
 670:../src/src/tls.c ****         case md5_mac:
 671:../src/src/tls.c ****         {
 672:../src/src/tls.c ****             return WC_MD5;
 1236                             		.loc 2 672 20
 1237 0032 66 35                   		mov.L	#3, r5
 1238 0034 2E 0E                   		bra	.L57
 1239                             	.L62:
 673:../src/src/tls.c ****         }
 674:../src/src/tls.c ****         #endif
 675:../src/src/tls.c ****         #ifndef NO_SHA256
 676:../src/src/tls.c ****         case sha256_mac:
 677:../src/src/tls.c ****         {
 678:../src/src/tls.c ****             return WC_SHA256;
 1240                             		.loc 2 678 20
 1241 0036 66 65                   		mov.L	#6, r5
 1242 0038 0A                      		bra	.L57
 1243                             	.L63:
 679:../src/src/tls.c ****         }
 680:../src/src/tls.c ****         #endif
 681:../src/src/tls.c ****         #ifdef WOLFSSL_SHA384
 682:../src/src/tls.c ****         case sha384_mac:
 683:../src/src/tls.c ****         {
 684:../src/src/tls.c ****             return WC_SHA384;
 1244                             		.loc 2 684 20
 1245 0039 66 75                   		mov.L	#7, r5
 1246 003b 0F                      		bra	.L57
 1247                             	.L58:
 685:../src/src/tls.c ****         }
 686:../src/src/tls.c **** 
 687:../src/src/tls.c ****         #endif
 688:../src/src/tls.c ****         #ifndef NO_SHA
 689:../src/src/tls.c ****         case sha_mac:
 690:../src/src/tls.c ****         {
 691:../src/src/tls.c ****             return WC_SHA;
 1248                             		.loc 2 691 20
 1249 003c 66 45                   		mov.L	#4, r5
 1250 003e 0C                      		bra	.L57
 1251                             	.L61:
 692:../src/src/tls.c ****         }
 693:../src/src/tls.c ****         #endif
 694:../src/src/tls.c ****         #ifdef HAVE_BLAKE2
 695:../src/src/tls.c ****         case blake2b_mac:
 696:../src/src/tls.c ****         {
 697:../src/src/tls.c ****             return BLAKE2B_ID;
 698:../src/src/tls.c ****         }
 699:../src/src/tls.c ****         #endif
 700:../src/src/tls.c ****         default:
 701:../src/src/tls.c ****         {
 702:../src/src/tls.c ****             return WOLFSSL_FATAL_ERROR;
 1252                             		.loc 2 702 20
 1253 003f FB 56 FF                		mov.L	#-1, r5
 1254                             		.balign 8,3,1
 1255                             	.L57:
 703:../src/src/tls.c ****         }
 704:../src/src/tls.c ****     }
 705:../src/src/tls.c **** }
 1256                             		.loc 2 705 1
 1257 0042 EF 51                   		mov.L	r5, r1
 1258 0044 3F AA 02                		rtsd	#8, r10-r10
 1259                             	.LFE54:
 1261 0047 03                      		.section	.text.wolfSSL_SetTlsHmacInner,"ax",@progbits
 1262                             		.global	_wolfSSL_SetTlsHmacInner
 1264                             	_wolfSSL_SetTlsHmacInner:
 1265                             	.LFB55:
 706:../src/src/tls.c **** 
 707:../src/src/tls.c **** 
 708:../src/src/tls.c **** int wolfSSL_SetTlsHmacInner(WOLFSSL* ssl, byte* inner, word32 sz, int content,
 709:../src/src/tls.c ****                            int verify)
 710:../src/src/tls.c **** {
 1266                             		.loc 2 710 1
 1267 0000 7E AA                   		push.l	r10
 1268                             	.LCFI53:
 1269 0002 7E A6                   		push.l	r6
 1270                             	.LCFI54:
 1271 0004 71 0A EC                		add	#-20, r0, r10
 1272                             	.LCFI55:
 1273 0007 EF A0                   		mov.L	r10, r0
 1274 0009 75 46 20                		mov.L	#32, r6
 1275 000c 4B A6                   		add	r10, r6
 1276 000e E3 A1                   		mov.L	r1, [r10]
 1277 0010 E7 A2 01                		mov.L	r2, 4[r10]
 1278 0013 E7 A3 02                		mov.L	r3, 8[r10]
 1279 0016 E7 A4 03                		mov.L	r4, 12[r10]
 711:../src/src/tls.c ****     if (ssl == NULL || inner == NULL)
 1280                             		.loc 2 711 8
 1281 0019 EC A5                   		mov.L	[r10], r5
 1282 001b 61 05                   		cmp	#0, r5
 1283 001d 17                      		beq	.L65
 1284                             		.loc 2 711 21 discriminator 1
 1285 001e ED A5 01                		mov.L	4[r10], r5
 1286 0021 61 05                   		cmp	#0, r5
 1287 0023 1F                      		bne	.L66
 1288                             	.L65:
 712:../src/src/tls.c ****         return BAD_FUNC_ARG;
 1289                             		.loc 2 712 16
 1290 0024 FB 5A 53 FF             		mov.L	#-173, r5
 1291 0028 2E 50                   		bra	.L67
 1292                             	.L66:
 713:../src/src/tls.c **** 
 714:../src/src/tls.c ****     XMEMSET(inner, 0, WOLFSSL_TLS_HMAC_INNER_SZ);
 1293                             		.loc 2 714 5
 1294 002a 66 D3                   		mov.L	#13, r3
 1295 002c 66 02                   		mov.L	#0, r2
 1296 002e ED A1 01                		mov.L	4[r10], r1
 1297 0031 05 00 00 00             		bsr	_memset
 715:../src/src/tls.c **** 
 716:../src/src/tls.c ****     WriteSEQ(ssl, verify, inner);
 1298                             		.loc 2 716 5
 1299 0035 ED A3 01                		mov.L	4[r10], r3
 1300 0038 EC 62                   		mov.L	[r6], r2
 1301 003a EC A1                   		mov.L	[r10], r1
 1302 003c 05 00 00 00             		bsr	_WriteSEQ
 717:../src/src/tls.c ****     inner[SEQ_SZ] = (byte)content;
 1303                             		.loc 2 717 10
 1304 0040 ED A5 01                		mov.L	4[r10], r5
 1305 0043 62 85                   		add	#8, r5
 1306                             		.loc 2 717 21
 1307 0045 ED A4 03                		mov.L	12[r10], r4
 1308                             		.loc 2 717 19
 1309 0048 C3 54                   		mov.B	r4, [r5]
 718:../src/src/tls.c ****     inner[SEQ_SZ + ENUM_LEN]            = ssl->version.major;
 1310                             		.loc 2 718 10
 1311 004a ED A5 01                		mov.L	4[r10], r5
 1312 004d 62 95                   		add	#9, r5
 1313                             		.loc 2 718 55
 1314 004f EC A4                   		mov.L	[r10], r4
 1315 0051 CE 44 60 01             		mov.B	352[r4], r4
 1316                             		.loc 2 718 41
 1317 0055 C3 54                   		mov.B	r4, [r5]
 719:../src/src/tls.c ****     inner[SEQ_SZ + ENUM_LEN + ENUM_LEN] = ssl->version.minor;
 1318                             		.loc 2 719 10
 1319 0057 ED A5 01                		mov.L	4[r10], r5
 1320 005a 62 A5                   		add	#10, r5
 1321                             		.loc 2 719 55
 1322 005c EC A4                   		mov.L	[r10], r4
 1323 005e CE 44 61 01             		mov.B	353[r4], r4
 1324                             		.loc 2 719 41
 1325 0062 C3 54                   		mov.B	r4, [r5]
 720:../src/src/tls.c ****     c16toa((word16)sz, inner + SEQ_SZ + ENUM_LEN + VERSION_SZ);
 1326                             		.loc 2 720 5
 1327 0064 ED A5 02                		mov.L	8[r10], r5
 1328 0067 DF 54                   		mov.W	r5, r4
 1329 0069 ED A5 01                		mov.L	4[r10], r5
 1330 006c 62 B5                   		add	#11, r5
 1331 006e EF 52                   		mov.L	r5, r2
 1332 0070 DF 41                   		mov.W	r4, r1
 1333 0072 05 00 00 00             		bsr	_c16toa
 721:../src/src/tls.c **** 
 722:../src/src/tls.c ****     return 0;
 1334                             		.loc 2 722 12
 1335 0076 66 05                   		mov.L	#0, r5
 1336                             	.L67:
 723:../src/src/tls.c **** }
 1337                             		.loc 2 723 1
 1338 0078 EF 51                   		mov.L	r5, r1
 1339 007a 71 00 14                		add	#20, r0
 1340 007d 7E B6                   		pop	r6
 1341 007f 7E BA                   		pop	r10
 1342 0081 02                      		rts
 1343                             	.LFE55:
 1345                             		.section	.text.Hmac_HashUpdate,"ax",@progbits
 1347                             	_Hmac_HashUpdate:
 1348                             	.LFB56:
 724:../src/src/tls.c **** 
 725:../src/src/tls.c **** 
 726:../src/src/tls.c **** #ifndef WOLFSSL_AEAD_ONLY
 727:../src/src/tls.c **** #if !defined(WOLFSSL_NO_HASH_RAW) && !defined(HAVE_FIPS) && \
 728:../src/src/tls.c ****     !defined(HAVE_SELFTEST)
 729:../src/src/tls.c **** 
 730:../src/src/tls.c **** /* Update the hash in the HMAC.
 731:../src/src/tls.c ****  *
 732:../src/src/tls.c ****  * hmac  HMAC object.
 733:../src/src/tls.c ****  * data  Data to be hashed.
 734:../src/src/tls.c ****  * sz    Size of data to hash.
 735:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
 736:../src/src/tls.c ****  */
 737:../src/src/tls.c **** static int Hmac_HashUpdate(Hmac* hmac, const byte* data, word32 sz)
 738:../src/src/tls.c **** {
 1349                             		.loc 2 738 1
 1350 0000 7E AA                   		push.l	r10
 1351                             	.LCFI56:
 1352 0002 71 0A F0                		add	#-16, r0, r10
 1353                             	.LCFI57:
 1354 0005 EF A0                   		mov.L	r10, r0
 1355 0007 E7 A1 01                		mov.L	r1, 4[r10]
 1356 000a E7 A2 02                		mov.L	r2, 8[r10]
 1357 000d E7 A3 03                		mov.L	r3, 12[r10]
 739:../src/src/tls.c ****     int ret = BAD_FUNC_ARG;
 1358                             		.loc 2 739 9
 1359 0010 F8 AA 53 FF             		mov.L	#-173, [r10]
 740:../src/src/tls.c **** 
 741:../src/src/tls.c ****     switch (hmac->macType) {
 1360                             		.loc 2 741 17
 1361 0014 ED A5 01                		mov.L	4[r10], r5
 1362 0017 CE 55 1C 02             		mov.B	540[r5], r5
 1363 001b 5B 55                   		movu.B	r5, r5
 1364                             		.loc 2 741 5
 1365 001d 61 65                   		cmp	#6, r5
 1366 001f 20 29                   		beq	.L69
 1367 0021 61 65                   		cmp	#6, r5
 1368 0023 2A 08                   		bgt	.L70
 1369 0025 61 45                   		cmp	#4, r5
 1370 0027 20 0E                   		beq	.L71
 742:../src/src/tls.c ****     #ifndef NO_SHA
 743:../src/src/tls.c ****         case WC_SHA:
 744:../src/src/tls.c ****             ret = wc_ShaUpdate(&hmac->hash.sha, data, sz);
 745:../src/src/tls.c ****             break;
 746:../src/src/tls.c ****     #endif /* !NO_SHA */
 747:../src/src/tls.c **** 
 748:../src/src/tls.c ****     #ifndef NO_SHA256
 749:../src/src/tls.c ****         case WC_SHA256:
 750:../src/src/tls.c ****             ret = wc_Sha256Update(&hmac->hash.sha256, data, sz);
 751:../src/src/tls.c ****             break;
 752:../src/src/tls.c ****     #endif /* !NO_SHA256 */
 753:../src/src/tls.c **** 
 754:../src/src/tls.c ****     #ifdef WOLFSSL_SHA384
 755:../src/src/tls.c ****         case WC_SHA384:
 756:../src/src/tls.c ****             ret = wc_Sha384Update(&hmac->hash.sha384, data, sz);
 757:../src/src/tls.c ****             break;
 758:../src/src/tls.c ****     #endif /* WOLFSSL_SHA384 */
 759:../src/src/tls.c **** 
 760:../src/src/tls.c ****     #ifdef WOLFSSL_SHA512
 761:../src/src/tls.c ****         case WC_SHA512:
 762:../src/src/tls.c ****             ret = wc_Sha512Update(&hmac->hash.sha512, data, sz);
 763:../src/src/tls.c ****             break;
 764:../src/src/tls.c ****     #endif /* WOLFSSL_SHA512 */
 765:../src/src/tls.c **** 
 766:../src/src/tls.c ****         default:
 767:../src/src/tls.c ****             break;
 1371                             		.loc 2 767 13
 1372 0029 2E 57                   		bra	.L75
 1373                             	.L70:
 741:../src/src/tls.c ****     #ifndef NO_SHA
 1374                             		.loc 2 741 5
 1375 002b 61 75                   		cmp	#7, r5
 1376 002d 20 2E                   		beq	.L73
 1377 002f 61 85                   		cmp	#8, r5
 1378 0031 20 3D                   		beq	.L74
 1379                             		.loc 2 767 13
 1380 0033 2E 4D                   		bra	.L75
 1381                             	.L71:
 744:../src/src/tls.c ****             break;
 1382                             		.loc 2 744 19
 1383 0035 ED A5 01                		mov.L	4[r10], r5
 1384 0038 ED A3 03                		mov.L	12[r10], r3
 1385 003b ED A2 02                		mov.L	8[r10], r2
 1386 003e EF 51                   		mov.L	r5, r1
 1387 0040 05 00 00 00             		bsr	_wc_ShaUpdate
 1388 0044 E3 A1                   		mov.L	r1, [r10]
 745:../src/src/tls.c ****     #endif /* !NO_SHA */
 1389                             		.loc 2 745 13
 1390 0046 2E 3A                   		bra	.L75
 1391                             	.L69:
 750:../src/src/tls.c ****             break;
 1392                             		.loc 2 750 19
 1393 0048 ED A5 01                		mov.L	4[r10], r5
 1394 004b ED A3 03                		mov.L	12[r10], r3
 1395 004e ED A2 02                		mov.L	8[r10], r2
 1396 0051 EF 51                   		mov.L	r5, r1
 1397 0053 05 00 00 00             		bsr	_wc_Sha256Update
 1398 0057 E3 A1                   		mov.L	r1, [r10]
 751:../src/src/tls.c ****     #endif /* !NO_SHA256 */
 1399                             		.loc 2 751 13
 1400 0059 2E 27                   		bra	.L75
 1401                             	.L73:
 756:../src/src/tls.c ****             break;
 1402                             		.loc 2 756 19
 1403 005b ED A5 01                		mov.L	4[r10], r5
 1404 005e ED A3 03                		mov.L	12[r10], r3
 1405 0061 ED A2 02                		mov.L	8[r10], r2
 1406 0064 EF 51                   		mov.L	r5, r1
 1407 0066 05 00 00 00             		bsr	_wc_Sha384Update
 1408 006a E3 A1                   		mov.L	r1, [r10]
 757:../src/src/tls.c ****     #endif /* WOLFSSL_SHA384 */
 1409                             		.loc 2 757 13
 1410 006c 2E 14                   		bra	.L75
 1411                             	.L74:
 762:../src/src/tls.c ****             break;
 1412                             		.loc 2 762 19
 1413 006e ED A5 01                		mov.L	4[r10], r5
 1414 0071 ED A3 03                		mov.L	12[r10], r3
 1415 0074 ED A2 02                		mov.L	8[r10], r2
 1416 0077 EF 51                   		mov.L	r5, r1
 1417 0079 05 00 00 00             		bsr	_wc_Sha512Update
 1418 007d E3 A1                   		mov.L	r1, [r10]
 763:../src/src/tls.c ****     #endif /* WOLFSSL_SHA512 */
 1419                             		.loc 2 763 13
 1420 007f 03                      		nop
 1421                             		.balign 8,3,1
 1422                             	.L75:
 768:../src/src/tls.c ****     }
 769:../src/src/tls.c **** 
 770:../src/src/tls.c ****     return ret;
 1423                             		.loc 2 770 12
 1424 0080 EC A5                   		mov.L	[r10], r5
 771:../src/src/tls.c **** }
 1425                             		.loc 2 771 1
 1426 0082 EF 51                   		mov.L	r5, r1
 1427 0084 3F AA 05                		rtsd	#20, r10-r10
 1428                             	.LFE56:
 1430 0087 03                      		.section	.text.Hmac_HashFinalRaw,"ax",@progbits
 1432                             	_Hmac_HashFinalRaw:
 1433                             	.LFB57:
 772:../src/src/tls.c **** 
 773:../src/src/tls.c **** /* Finalize the hash but don't put the EOC, padding or length in.
 774:../src/src/tls.c ****  *
 775:../src/src/tls.c ****  * hmac  HMAC object.
 776:../src/src/tls.c ****  * hash  Hash result.
 777:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
 778:../src/src/tls.c ****  */
 779:../src/src/tls.c **** static int Hmac_HashFinalRaw(Hmac* hmac, unsigned char* hash)
 780:../src/src/tls.c **** {
 1434                             		.loc 2 780 1
 1435 0000 7E AA                   		push.l	r10
 1436                             	.LCFI58:
 1437 0002 71 0A F4                		add	#-12, r0, r10
 1438                             	.LCFI59:
 1439 0005 EF A0                   		mov.L	r10, r0
 1440 0007 E7 A1 01                		mov.L	r1, 4[r10]
 1441 000a E7 A2 02                		mov.L	r2, 8[r10]
 781:../src/src/tls.c ****     int ret = BAD_FUNC_ARG;
 1442                             		.loc 2 781 9
 1443 000d F8 AA 53 FF             		mov.L	#-173, [r10]
 782:../src/src/tls.c **** 
 783:../src/src/tls.c ****     switch (hmac->macType) {
 1444                             		.loc 2 783 17
 1445 0011 ED A5 01                		mov.L	4[r10], r5
 1446 0014 CE 55 1C 02             		mov.B	540[r5], r5
 1447 0018 5B 55                   		movu.B	r5, r5
 1448                             		.loc 2 783 5
 1449 001a 61 65                   		cmp	#6, r5
 1450 001c 20 26                   		beq	.L78
 1451 001e 61 65                   		cmp	#6, r5
 1452 0020 2A 08                   		bgt	.L79
 1453 0022 61 45                   		cmp	#4, r5
 1454 0024 20 0E                   		beq	.L80
 784:../src/src/tls.c ****     #ifndef NO_SHA
 785:../src/src/tls.c ****         case WC_SHA:
 786:../src/src/tls.c ****             ret = wc_ShaFinalRaw(&hmac->hash.sha, hash);
 787:../src/src/tls.c ****             break;
 788:../src/src/tls.c ****     #endif /* !NO_SHA */
 789:../src/src/tls.c **** 
 790:../src/src/tls.c ****     #ifndef NO_SHA256
 791:../src/src/tls.c ****         case WC_SHA256:
 792:../src/src/tls.c ****             ret = wc_Sha256FinalRaw(&hmac->hash.sha256, hash);
 793:../src/src/tls.c ****             break;
 794:../src/src/tls.c ****     #endif /* !NO_SHA256 */
 795:../src/src/tls.c **** 
 796:../src/src/tls.c ****     #ifdef WOLFSSL_SHA384
 797:../src/src/tls.c ****         case WC_SHA384:
 798:../src/src/tls.c ****             ret = wc_Sha384FinalRaw(&hmac->hash.sha384, hash);
 799:../src/src/tls.c ****             break;
 800:../src/src/tls.c ****     #endif /* WOLFSSL_SHA384 */
 801:../src/src/tls.c **** 
 802:../src/src/tls.c ****     #ifdef WOLFSSL_SHA512
 803:../src/src/tls.c ****         case WC_SHA512:
 804:../src/src/tls.c ****             ret = wc_Sha512FinalRaw(&hmac->hash.sha512, hash);
 805:../src/src/tls.c ****             break;
 806:../src/src/tls.c ****     #endif /* WOLFSSL_SHA512 */
 807:../src/src/tls.c **** 
 808:../src/src/tls.c ****         default:
 809:../src/src/tls.c ****             break;
 1455                             		.loc 2 809 13
 1456 0026 2E 4B                   		bra	.L84
 1457                             	.L79:
 783:../src/src/tls.c ****     #ifndef NO_SHA
 1458                             		.loc 2 783 5
 1459 0028 61 75                   		cmp	#7, r5
 1460 002a 20 28                   		beq	.L82
 1461 002c 61 85                   		cmp	#8, r5
 1462 002e 20 34                   		beq	.L83
 1463                             		.loc 2 809 13
 1464 0030 2E 41                   		bra	.L84
 1465                             	.L80:
 786:../src/src/tls.c ****             break;
 1466                             		.loc 2 786 19
 1467 0032 ED A5 01                		mov.L	4[r10], r5
 1468 0035 ED A2 02                		mov.L	8[r10], r2
 1469 0038 EF 51                   		mov.L	r5, r1
 1470 003a 05 00 00 00             		bsr	_wc_ShaFinalRaw
 1471 003e E3 A1                   		mov.L	r1, [r10]
 787:../src/src/tls.c ****     #endif /* !NO_SHA */
 1472                             		.loc 2 787 13
 1473 0040 2E 31                   		bra	.L84
 1474                             	.L78:
 792:../src/src/tls.c ****             break;
 1475                             		.loc 2 792 19
 1476 0042 ED A5 01                		mov.L	4[r10], r5
 1477 0045 ED A2 02                		mov.L	8[r10], r2
 1478 0048 EF 51                   		mov.L	r5, r1
 1479 004a 05 00 00 00             		bsr	_wc_Sha256FinalRaw
 1480 004e E3 A1                   		mov.L	r1, [r10]
 793:../src/src/tls.c ****     #endif /* !NO_SHA256 */
 1481                             		.loc 2 793 13
 1482 0050 2E 21                   		bra	.L84
 1483                             	.L82:
 798:../src/src/tls.c ****             break;
 1484                             		.loc 2 798 19
 1485 0052 ED A5 01                		mov.L	4[r10], r5
 1486 0055 ED A2 02                		mov.L	8[r10], r2
 1487 0058 EF 51                   		mov.L	r5, r1
 1488 005a 05 00 00 00             		bsr	_wc_Sha384FinalRaw
 1489 005e E3 A1                   		mov.L	r1, [r10]
 799:../src/src/tls.c ****     #endif /* WOLFSSL_SHA384 */
 1490                             		.loc 2 799 13
 1491 0060 2E 11                   		bra	.L84
 1492                             	.L83:
 804:../src/src/tls.c ****             break;
 1493                             		.loc 2 804 19
 1494 0062 ED A5 01                		mov.L	4[r10], r5
 1495 0065 ED A2 02                		mov.L	8[r10], r2
 1496 0068 EF 51                   		mov.L	r5, r1
 1497 006a 05 00 00 00             		bsr	_wc_Sha512FinalRaw
 1498 006e E3 A1                   		mov.L	r1, [r10]
 805:../src/src/tls.c ****     #endif /* WOLFSSL_SHA512 */
 1499                             		.loc 2 805 13
 1500 0070 03                      		nop
 1501                             		.balign 8,3,1
 1502                             	.L84:
 810:../src/src/tls.c ****     }
 811:../src/src/tls.c **** 
 812:../src/src/tls.c ****     return ret;
 1503                             		.loc 2 812 12
 1504 0071 EC A5                   		mov.L	[r10], r5
 813:../src/src/tls.c **** }
 1505                             		.loc 2 813 1
 1506 0073 EF 51                   		mov.L	r5, r1
 1507 0075 3F AA 04                		rtsd	#16, r10-r10
 1508                             	.LFE57:
 1510                             		.section	.text.Hmac_OuterHash,"ax",@progbits
 1512                             	_Hmac_OuterHash:
 1513                             	.LFB58:
 814:../src/src/tls.c **** 
 815:../src/src/tls.c **** /* Finalize the HMAC by performing outer hash.
 816:../src/src/tls.c ****  *
 817:../src/src/tls.c ****  * hmac  HMAC object.
 818:../src/src/tls.c ****  * mac   MAC result.
 819:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
 820:../src/src/tls.c ****  */
 821:../src/src/tls.c **** static int Hmac_OuterHash(Hmac* hmac, unsigned char* mac)
 822:../src/src/tls.c **** {
 1514                             		.loc 2 822 1
 1515 0000 7E AA                   		push.l	r10
 1516                             	.LCFI60:
 1517 0002 72 0A 10 FF             		add	#-240, r0, r10
 1518                             	.LCFI61:
 1519 0006 EF A0                   		mov.L	r10, r0
 1520 0008 E7 A1 3A                		mov.L	r1, 232[r10]
 1521 000b E7 A2 3B                		mov.L	r2, 236[r10]
 823:../src/src/tls.c ****     int ret = BAD_FUNC_ARG;
 1522                             		.loc 2 823 9
 1523 000e F8 AA 53 FF             		mov.L	#-173, [r10]
 824:../src/src/tls.c ****     wc_HashAlg hash;
 825:../src/src/tls.c ****     enum wc_HashType hashType = (enum wc_HashType)hmac->macType;
 1524                             		.loc 2 825 55
 1525 0012 ED A5 3A                		mov.L	232[r10], r5
 1526 0015 CE 55 1C 02             		mov.B	540[r5], r5
 1527                             		.loc 2 825 22
 1528 0019 5B 55                   		movu.B	r5, r5
 1529 001b E7 A5 01                		mov.L	r5, 4[r10]
 826:../src/src/tls.c ****     int digestSz = wc_HashGetDigestSize(hashType);
 1530                             		.loc 2 826 20
 1531 001e ED A1 01                		mov.L	4[r10], r1
 1532 0021 05 00 00 00             		bsr	_wc_HashGetDigestSize
 1533 0025 E7 A1 02                		mov.L	r1, 8[r10]
 827:../src/src/tls.c ****     int blockSz = wc_HashGetBlockSize(hashType);
 1534                             		.loc 2 827 19
 1535 0028 ED A1 01                		mov.L	4[r10], r1
 1536 002b 05 00 00 00             		bsr	_wc_HashGetBlockSize
 1537 002f E7 A1 03                		mov.L	r1, 12[r10]
 828:../src/src/tls.c **** 
 829:../src/src/tls.c ****     if ((digestSz >= 0) && (blockSz >= 0)) {
 1538                             		.loc 2 829 8
 1539 0032 ED A5 02                		mov.L	8[r10], r5
 1540 0035 61 05                   		cmp	#0, r5
 1541 0037 29 17                   		blt	.L87
 1542                             		.loc 2 829 25 discriminator 1
 1543 0039 ED A5 03                		mov.L	12[r10], r5
 1544 003c 61 05                   		cmp	#0, r5
 1545 003e 29 10                   		blt	.L87
 830:../src/src/tls.c ****         ret = wc_HashInit(&hash, hashType);
 1546                             		.loc 2 830 15
 1547 0040 71 A5 10                		add	#16, r10, r5
 1548 0043 ED A2 01                		mov.L	4[r10], r2
 1549 0046 EF 51                   		mov.L	r5, r1
 1550 0048 05 00 00 00             		bsr	_wc_HashInit
 1551 004c E3 A1                   		mov.L	r1, [r10]
 1552                             	.L87:
 831:../src/src/tls.c ****     }
 832:../src/src/tls.c ****     if (ret == 0) {
 1553                             		.loc 2 832 8
 1554 004e EC A5                   		mov.L	[r10], r5
 1555 0050 61 05                   		cmp	#0, r5
 1556 0052 21 5B                   		bne	.L88
 833:../src/src/tls.c ****         ret = wc_HashUpdate(&hash, hashType, (byte*)hmac->opad,
 1557                             		.loc 2 833 53
 1558 0054 ED A5 3A                		mov.L	232[r10], r5
 1559 0057 72 53 58 01             		add	#0x158, r5, r3
 1560                             		.loc 2 833 15
 1561 005b ED A4 03                		mov.L	12[r10], r4
 1562 005e 71 A5 10                		add	#16, r10, r5
 1563 0061 ED A2 01                		mov.L	4[r10], r2
 1564 0064 EF 51                   		mov.L	r5, r1
 1565 0066 05 00 00 00             		bsr	_wc_HashUpdate
 1566 006a E3 A1                   		mov.L	r1, [r10]
 834:../src/src/tls.c ****             blockSz);
 835:../src/src/tls.c ****         if (ret == 0)
 1567                             		.loc 2 835 12
 1568 006c EC A5                   		mov.L	[r10], r5
 1569 006e 61 05                   		cmp	#0, r5
 1570 0070 21 1A                   		bne	.L89
 836:../src/src/tls.c ****             ret = wc_HashUpdate(&hash, hashType, (byte*)hmac->innerHash,
 1571                             		.loc 2 836 57
 1572 0072 ED A5 3A                		mov.L	232[r10], r5
 1573 0075 72 53 D8 01             		add	#0x1d8, r5, r3
 1574                             		.loc 2 836 19
 1575 0079 ED A4 02                		mov.L	8[r10], r4
 1576 007c 71 A5 10                		add	#16, r10, r5
 1577 007f ED A2 01                		mov.L	4[r10], r2
 1578 0082 EF 51                   		mov.L	r5, r1
 1579 0084 05 00 00 00             		bsr	_wc_HashUpdate
 1580 0088 E3 A1                   		mov.L	r1, [r10]
 1581                             	.L89:
 837:../src/src/tls.c ****                 digestSz);
 838:../src/src/tls.c ****         if (ret == 0)
 1582                             		.loc 2 838 12
 1583 008a EC A5                   		mov.L	[r10], r5
 1584 008c 61 05                   		cmp	#0, r5
 1585 008e 21 13                   		bne	.L90
 839:../src/src/tls.c ****             ret = wc_HashFinal(&hash, hashType, mac);
 1586                             		.loc 2 839 19
 1587 0090 71 A5 10                		add	#16, r10, r5
 1588 0093 ED A3 3B                		mov.L	236[r10], r3
 1589 0096 ED A2 01                		mov.L	4[r10], r2
 1590 0099 EF 51                   		mov.L	r5, r1
 1591 009b 05 00 00 00             		bsr	_wc_HashFinal
 1592 009f E3 A1                   		mov.L	r1, [r10]
 1593                             	.L90:
 840:../src/src/tls.c ****         wc_HashFree(&hash, hashType);
 1594                             		.loc 2 840 9
 1595 00a1 71 A5 10                		add	#16, r10, r5
 1596 00a4 ED A2 01                		mov.L	4[r10], r2
 1597 00a7 EF 51                   		mov.L	r5, r1
 1598 00a9 05 00 00 00             		bsr	_wc_HashFree
 1599                             	.L88:
 841:../src/src/tls.c ****     }
 842:../src/src/tls.c **** 
 843:../src/src/tls.c ****     return ret;
 1600                             		.loc 2 843 12
 1601 00ad EC A5                   		mov.L	[r10], r5
 844:../src/src/tls.c **** }
 1602                             		.loc 2 844 1
 1603 00af EF 51                   		mov.L	r5, r1
 1604 00b1 3F AA 3D                		rtsd	#244, r10-r10
 1605                             	.LFE58:
 1607                             		.section	.text.Hmac_UpdateFinal_CT,"ax",@progbits
 1609                             	_Hmac_UpdateFinal_CT:
 1610                             	.LFB59:
 845:../src/src/tls.c **** 
 846:../src/src/tls.c **** /* Calculate the HMAC of the header + message data.
 847:../src/src/tls.c ****  * Constant time implementation using wc_Sha*FinalRaw().
 848:../src/src/tls.c ****  *
 849:../src/src/tls.c ****  * hmac    HMAC object.
 850:../src/src/tls.c ****  * digest  MAC result.
 851:../src/src/tls.c ****  * in      Message data.
 852:../src/src/tls.c ****  * sz      Size of the message data.
 853:../src/src/tls.c ****  * header  Constructed record header with length of handshake data.
 854:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
 855:../src/src/tls.c ****  */
 856:../src/src/tls.c **** static int Hmac_UpdateFinal_CT(Hmac* hmac, byte* digest, const byte* in,
 857:../src/src/tls.c ****                                word32 sz, int macLen, byte* header)
 858:../src/src/tls.c **** {
 1611                             		.loc 2 858 1
 1612 0000 6E 6A                   		pushm	r6-r10
 1613                             	.LCFI62:
 1614 0002 72 0A 10 FF             		add	#-240, r0, r10
 1615                             	.LCFI63:
 1616 0006 EF A0                   		mov.L	r10, r0
 1617 0008 FB 6A 08 01             		mov.L	#0x108, r6
 1618 000c 4B A6                   		add	r10, r6
 1619 000e E7 A1 36                		mov.L	r1, 216[r10]
 1620 0011 E7 A2 37                		mov.L	r2, 220[r10]
 1621 0014 E7 A3 38                		mov.L	r3, 224[r10]
 1622 0017 E7 A4 39                		mov.L	r4, 228[r10]
 859:../src/src/tls.c ****     byte         lenBytes[8];
 860:../src/src/tls.c ****     int          i, j;
 861:../src/src/tls.c ****     unsigned int k;
 862:../src/src/tls.c ****     int          blockBits, blockMask;
 863:../src/src/tls.c ****     int          lastBlockLen, extraLen, eocIndex;
 864:../src/src/tls.c ****     int          blocks, safeBlocks, lenBlock, eocBlock;
 865:../src/src/tls.c ****     unsigned int maxLen;
 866:../src/src/tls.c ****     int          blockSz, padSz;
 867:../src/src/tls.c ****     int          ret;
 868:../src/src/tls.c ****     word32       realLen;
 869:../src/src/tls.c ****     byte         extraBlock;
 870:../src/src/tls.c **** 
 871:../src/src/tls.c ****     switch (hmac->macType) {
 1623                             		.loc 2 871 17
 1624 001a ED A5 36                		mov.L	216[r10], r5
 1625 001d CE 55 1C 02             		mov.B	540[r5], r5
 1626 0021 5B 55                   		movu.B	r5, r5
 1627                             		.loc 2 871 5
 1628 0023 61 65                   		cmp	#6, r5
 1629 0025 20 24                   		beq	.L93
 1630 0027 61 65                   		cmp	#6, r5
 1631 0029 2A 08                   		bgt	.L94
 1632 002b 61 45                   		cmp	#4, r5
 1633 002d 20 0E                   		beq	.L95
 1634 002f 2E 45                   		bra	.L96
 1635                             	.L94:
 1636 0031 61 75                   		cmp	#7, r5
 1637 0033 20 24                   		beq	.L97
 1638 0035 61 85                   		cmp	#8, r5
 1639 0037 20 2F                   		beq	.L98
 1640 0039 2E 3B                   		bra	.L96
 1641                             	.L95:
 872:../src/src/tls.c ****     #ifndef NO_SHA
 873:../src/src/tls.c ****         case WC_SHA:
 874:../src/src/tls.c ****             blockSz = WC_SHA_BLOCK_SIZE;
 1642                             		.loc 2 874 21
 1643 003b F9 A6 05 40             		mov.L	#0x40, 20[r10]
 875:../src/src/tls.c ****             blockBits = 6;
 1644                             		.loc 2 875 23
 1645 003f F9 A6 03 06             		mov.L	#6, 12[r10]
 876:../src/src/tls.c ****             padSz = WC_SHA_BLOCK_SIZE - WC_SHA_PAD_SIZE + 1;
 1646                             		.loc 2 876 19
 1647 0043 F9 A6 06 09             		mov.L	#9, 24[r10]
 877:../src/src/tls.c ****             break;
 1648                             		.loc 2 877 13
 1649 0047 2E 34                   		bra	.L99
 1650                             	.L93:
 878:../src/src/tls.c ****     #endif /* !NO_SHA */
 879:../src/src/tls.c **** 
 880:../src/src/tls.c ****     #ifndef NO_SHA256
 881:../src/src/tls.c ****         case WC_SHA256:
 882:../src/src/tls.c ****             blockSz = WC_SHA256_BLOCK_SIZE;
 1651                             		.loc 2 882 21
 1652 0049 F9 A6 05 40             		mov.L	#0x40, 20[r10]
 883:../src/src/tls.c ****             blockBits = 6;
 1653                             		.loc 2 883 23
 1654 004d F9 A6 03 06             		mov.L	#6, 12[r10]
 884:../src/src/tls.c ****             padSz = WC_SHA256_BLOCK_SIZE - WC_SHA256_PAD_SIZE + 1;
 1655                             		.loc 2 884 19
 1656 0051 F9 A6 06 09             		mov.L	#9, 24[r10]
 885:../src/src/tls.c ****             break;
 1657                             		.loc 2 885 13
 1658 0055 2E 26                   		bra	.L99
 1659                             	.L97:
 886:../src/src/tls.c ****     #endif /* !NO_SHA256 */
 887:../src/src/tls.c **** 
 888:../src/src/tls.c ****     #ifdef WOLFSSL_SHA384
 889:../src/src/tls.c ****         case WC_SHA384:
 890:../src/src/tls.c ****             blockSz = WC_SHA384_BLOCK_SIZE;
 1660                             		.loc 2 890 21
 1661 0057 F9 AA 05 80 00          		mov.L	#0x80, 20[r10]
 891:../src/src/tls.c ****             blockBits = 7;
 1662                             		.loc 2 891 23
 1663 005c F9 A6 03 07             		mov.L	#7, 12[r10]
 892:../src/src/tls.c ****             padSz = WC_SHA384_BLOCK_SIZE - WC_SHA384_PAD_SIZE + 1;
 1664                             		.loc 2 892 19
 1665 0060 F9 A6 06 11             		mov.L	#17, 24[r10]
 893:../src/src/tls.c ****             break;
 1666                             		.loc 2 893 13
 1667 0064 2E 17                   		bra	.L99
 1668                             	.L98:
 894:../src/src/tls.c ****     #endif /* WOLFSSL_SHA384 */
 895:../src/src/tls.c **** 
 896:../src/src/tls.c ****     #ifdef WOLFSSL_SHA512
 897:../src/src/tls.c ****         case WC_SHA512:
 898:../src/src/tls.c ****             blockSz = WC_SHA512_BLOCK_SIZE;
 1669                             		.loc 2 898 21
 1670 0066 F9 AA 05 80 00          		mov.L	#0x80, 20[r10]
 899:../src/src/tls.c ****             blockBits = 7;
 1671                             		.loc 2 899 23
 1672 006b F9 A6 03 07             		mov.L	#7, 12[r10]
 900:../src/src/tls.c ****             padSz = WC_SHA512_BLOCK_SIZE - WC_SHA512_PAD_SIZE + 1;
 1673                             		.loc 2 900 19
 1674 006f F9 A6 06 11             		mov.L	#17, 24[r10]
 901:../src/src/tls.c ****             break;
 1675                             		.loc 2 901 13
 1676 0073 08                      		bra	.L99
 1677                             	.L96:
 902:../src/src/tls.c ****     #endif /* WOLFSSL_SHA512 */
 903:../src/src/tls.c **** 
 904:../src/src/tls.c ****         default:
 905:../src/src/tls.c ****             return BAD_FUNC_ARG;
 1678                             		.loc 2 905 20
 1679 0074 FB 5A 53 FF             		mov.L	#-173, r5
 1680 0078 38 32 03                		bra	.L117
 1681                             	.L99:
 906:../src/src/tls.c ****     }
 907:../src/src/tls.c ****     blockMask = blockSz - 1;
 1682                             		.loc 2 907 15
 1683 007b ED A5 05                		mov.L	20[r10], r5
 1684 007e 60 15                   		sub	#1, r5
 1685 0080 E7 A5 08                		mov.L	r5, 32[r10]
 908:../src/src/tls.c **** 
 909:../src/src/tls.c ****     /* Size of data to HMAC if padding length byte is zero. */
 910:../src/src/tls.c ****     maxLen = WOLFSSL_TLS_HMAC_INNER_SZ + sz - 1 - macLen;
 1686                             		.loc 2 910 49
 1687 0083 EC 65                   		mov.L	[r6], r5
 1688 0085 ED A4 39                		mov.L	228[r10], r4
 1689 0088 FF 05 54                		sub	r5, r4, r5
 1690                             		.loc 2 910 12
 1691 008b 62 C5                   		add	#12, r5
 1692 008d E7 A5 09                		mov.L	r5, 36[r10]
 911:../src/src/tls.c ****     /* Complete data (including padding) has block for EOC and/or length. */
 912:../src/src/tls.c ****     extraBlock = ctSetLTE((maxLen + padSz) & blockMask, padSz);
 1693                             		.loc 2 912 35
 1694 0090 ED A5 06                		mov.L	24[r10], r5
 1695 0093 06 89 A5 09             		add	36[r10].L, r5
 1696                             		.loc 2 912 44
 1697 0097 ED A4 08                		mov.L	32[r10], r4
 1698 009a 53 45                   		and	r4, r5
 1699                             		.loc 2 912 18
 1700 009c ED A2 06                		mov.L	24[r10], r2
 1701 009f EF 51                   		mov.L	r5, r1
 1702 00a1 05 00 00 00             		bsr	_ctSetLTE
 1703 00a5 EF 15                   		mov.L	r1, r5
 1704 00a7 C7 A5 28                		mov.B	r5, 40[r10]
 913:../src/src/tls.c ****     /* Total number of blocks for data including padding. */
 914:../src/src/tls.c ****     blocks = ((maxLen + blockSz - 1) >> blockBits) + extraBlock;
 1705                             		.loc 2 914 23
 1706 00aa ED A5 05                		mov.L	20[r10], r5
 1707 00ad 06 89 A5 09             		add	36[r10].L, r5
 1708                             		.loc 2 914 33
 1709 00b1 60 15                   		sub	#1, r5
 1710                             		.loc 2 914 38
 1711 00b3 ED A4 03                		mov.L	12[r10], r4
 1712 00b6 EF 57                   		mov.L	r5, r7
 1713 00b8 FD 60 47                		shlr	r4, r7
 1714 00bb EF 74                   		mov.L	r7, r4
 1715                             		.loc 2 914 52
 1716 00bd 59 A5 28                		movu.B	40[r10], r5
 1717 00c0 4B 45                   		add	r4, r5
 1718                             		.loc 2 914 12
 1719 00c2 E7 A5 0B                		mov.L	r5, 44[r10]
 915:../src/src/tls.c ****     /* Up to last 6 blocks can be hashed safely. */
 916:../src/src/tls.c ****     safeBlocks = blocks - 6;
 1720                             		.loc 2 916 16
 1721 00c5 ED A5 0B                		mov.L	44[r10], r5
 1722 00c8 60 65                   		sub	#6, r5
 1723 00ca E7 A5 04                		mov.L	r5, 16[r10]
 917:../src/src/tls.c **** 
 918:../src/src/tls.c ****     /* Length of message data. */
 919:../src/src/tls.c ****     realLen = maxLen - in[sz - 1];
 1724                             		.loc 2 919 26
 1725 00cd ED A5 39                		mov.L	228[r10], r5
 1726 00d0 60 15                   		sub	#1, r5
 1727 00d2 ED A4 38                		mov.L	224[r10], r4
 1728 00d5 4B 45                   		add	r4, r5
 1729 00d7 CC 55                   		mov.B	[r5], r5
 1730 00d9 5B 55                   		movu.B	r5, r5
 1731                             		.loc 2 919 13
 1732 00db ED A4 09                		mov.L	36[r10], r4
 1733 00de FF 05 54                		sub	r5, r4, r5
 1734 00e1 E7 A5 0C                		mov.L	r5, 48[r10]
 920:../src/src/tls.c ****     /* Number of message bytes in last block. */
 921:../src/src/tls.c ****     lastBlockLen = realLen & blockMask;
 1735                             		.loc 2 921 28
 1736 00e4 ED A4 08                		mov.L	32[r10], r4
 1737 00e7 ED A5 0C                		mov.L	48[r10], r5
 1738 00ea 53 45                   		and	r4, r5
 1739                             		.loc 2 921 18
 1740 00ec E7 A5 0D                		mov.L	r5, 52[r10]
 922:../src/src/tls.c ****     /* Number of padding bytes in last block. */
 923:../src/src/tls.c ****     extraLen = ((blockSz * 2 - padSz - lastBlockLen) & blockMask) + 1;
 1741                             		.loc 2 923 26
 1742 00ef ED A5 05                		mov.L	20[r10], r5
 1743 00f2 4B 55                   		add	r5, r5
 1744 00f4 EF 54                   		mov.L	r5, r4
 1745                             		.loc 2 923 30
 1746 00f6 ED A5 06                		mov.L	24[r10], r5
 1747 00f9 FF 05 54                		sub	r5, r4, r5
 1748                             		.loc 2 923 38
 1749 00fc ED A4 0D                		mov.L	52[r10], r4
 1750 00ff 43 45                   		sub	r4, r5
 1751                             		.loc 2 923 54
 1752 0101 ED A4 08                		mov.L	32[r10], r4
 1753 0104 53 45                   		and	r4, r5
 1754                             		.loc 2 923 14
 1755 0106 62 15                   		add	#1, r5
 1756 0108 E7 A5 0E                		mov.L	r5, 56[r10]
 924:../src/src/tls.c ****     /* Number of blocks to create for hash. */
 925:../src/src/tls.c ****     lenBlock = (realLen + extraLen) >> blockBits;
 1757                             		.loc 2 925 25
 1758 010b ED A5 0E                		mov.L	56[r10], r5
 1759 010e 06 89 A5 0C             		add	48[r10].L, r5
 1760                             		.loc 2 925 37
 1761 0112 ED A4 03                		mov.L	12[r10], r4
 1762 0115 FD 60 45                		shlr	r4, r5
 1763                             		.loc 2 925 14
 1764 0118 E7 A5 0F                		mov.L	r5, 60[r10]
 926:../src/src/tls.c ****     /* Block containing EOC byte. */
 927:../src/src/tls.c ****     eocBlock = realLen >> blockBits;
 1765                             		.loc 2 927 24
 1766 011b ED A4 0C                		mov.L	48[r10], r4
 1767 011e ED A5 03                		mov.L	12[r10], r5
 1768 0121 EF 47                   		mov.L	r4, r7
 1769 0123 FD 60 57                		shlr	r5, r7
 1770 0126 EF 75                   		mov.L	r7, r5
 1771                             		.loc 2 927 14
 1772 0128 E7 A5 10                		mov.L	r5, 64[r10]
 928:../src/src/tls.c ****     /* Index of EOC byte in block. */
 929:../src/src/tls.c ****     eocIndex = realLen & blockMask;
 1773                             		.loc 2 929 24
 1774 012b ED A4 08                		mov.L	32[r10], r4
 1775 012e ED A5 0C                		mov.L	48[r10], r5
 1776 0131 53 45                   		and	r4, r5
 1777                             		.loc 2 929 14
 1778 0133 E7 A5 11                		mov.L	r5, 68[r10]
 930:../src/src/tls.c **** 
 931:../src/src/tls.c ****     /* Add length of hmac's ipad to total length. */
 932:../src/src/tls.c ****     realLen += blockSz;
 1779                             		.loc 2 932 13
 1780 0136 ED A5 05                		mov.L	20[r10], r5
 1781 0139 ED A4 0C                		mov.L	48[r10], r4
 1782 013c 4B 45                   		add	r4, r5
 1783 013e E7 A5 0C                		mov.L	r5, 48[r10]
 933:../src/src/tls.c ****     /* Length as bits - 8 bytes bigendian. */
 934:../src/src/tls.c ****     c32toa(realLen >> ((sizeof(word32) * 8) - 3), lenBytes);
 1784                             		.loc 2 934 5
 1785 0141 ED A5 0C                		mov.L	48[r10], r5
 1786 0144 69 D5                   		shlr	#29, r5
 1787 0146 71 A4 50                		add	#0x50, r10, r4
 1788 0149 EF 42                   		mov.L	r4, r2
 1789 014b EF 51                   		mov.L	r5, r1
 1790 014d 05 00 00 00             		bsr	_c32toa
 935:../src/src/tls.c ****     c32toa(realLen << 3, lenBytes + sizeof(word32));
 1791                             		.loc 2 935 5
 1792 0151 ED A5 0C                		mov.L	48[r10], r5
 1793 0154 FD C3 54                		shll	#3, r5, r4
 1794 0157 71 A5 50                		add	#0x50, r10, r5
 1795 015a 62 45                   		add	#4, r5
 1796 015c EF 52                   		mov.L	r5, r2
 1797 015e EF 41                   		mov.L	r4, r1
 1798 0160 05 00 00 00             		bsr	_c32toa
 936:../src/src/tls.c **** 
 937:../src/src/tls.c ****     ret = Hmac_HashUpdate(hmac, (unsigned char*)hmac->ipad, blockSz);
 1799                             		.loc 2 937 49
 1800 0164 ED A5 36                		mov.L	216[r10], r5
 1801 0167 72 55 D8 00             		add	#0xd8, r5
 1802                             		.loc 2 937 11
 1803 016b ED A4 05                		mov.L	20[r10], r4
 1804 016e EF 43                   		mov.L	r4, r3
 1805 0170 EF 52                   		mov.L	r5, r2
 1806 0172 ED A1 36                		mov.L	216[r10], r1
 1807 0175 05 00 00 00             		bsr	_Hmac_HashUpdate
 1808 0179 E7 A1 12                		mov.L	r1, 72[r10]
 938:../src/src/tls.c ****     if (ret != 0)
 1809                             		.loc 2 938 8
 1810 017c ED A5 12                		mov.L	72[r10], r5
 1811 017f 61 05                   		cmp	#0, r5
 1812 0181 17                      		beq	.L101
 939:../src/src/tls.c ****         return ret;
 1813                             		.loc 2 939 16
 1814 0182 ED A5 12                		mov.L	72[r10], r5
 1815 0185 38 25 02                		bra	.L117
 1816                             	.L101:
 940:../src/src/tls.c **** 
 941:../src/src/tls.c ****     XMEMSET(hmac->innerHash, 0, macLen);
 1817                             		.loc 2 941 5
 1818 0188 ED A5 36                		mov.L	216[r10], r5
 1819 018b 72 55 D8 01             		add	#0x1d8, r5
 1820 018f EC 64                   		mov.L	[r6], r4
 1821 0191 EF 43                   		mov.L	r4, r3
 1822 0193 66 02                   		mov.L	#0, r2
 1823 0195 EF 51                   		mov.L	r5, r1
 1824 0197 05 00 00 00             		bsr	_memset
 942:../src/src/tls.c **** 
 943:../src/src/tls.c ****     if (safeBlocks > 0) {
 1825                             		.loc 2 943 8
 1826 019b ED A5 04                		mov.L	16[r10], r5
 1827 019e 61 05                   		cmp	#0, r5
 1828 01a0 2B 42                   		ble	.L102
 944:../src/src/tls.c ****         ret = Hmac_HashUpdate(hmac, header, WOLFSSL_TLS_HMAC_INNER_SZ);
 1829                             		.loc 2 944 15
 1830 01a2 66 D3                   		mov.L	#13, r3
 1831 01a4 A8 6A                   		mov.L	4[r6], r2
 1832 01a6 ED A1 36                		mov.L	216[r10], r1
 1833 01a9 05 00 00 00             		bsr	_Hmac_HashUpdate
 1834 01ad E7 A1 12                		mov.L	r1, 72[r10]
 945:../src/src/tls.c ****         if (ret != 0)
 1835                             		.loc 2 945 12
 1836 01b0 ED A5 12                		mov.L	72[r10], r5
 1837 01b3 61 05                   		cmp	#0, r5
 1838 01b5 17                      		beq	.L103
 946:../src/src/tls.c ****             return ret;
 1839                             		.loc 2 946 20
 1840 01b6 ED A5 12                		mov.L	72[r10], r5
 1841 01b9 38 F1 01                		bra	.L117
 1842                             	.L103:
 947:../src/src/tls.c ****         ret = Hmac_HashUpdate(hmac, in, safeBlocks * blockSz -
 1843                             		.loc 2 947 52
 1844 01bc ED A4 04                		mov.L	16[r10], r4
 1845 01bf ED A5 05                		mov.L	20[r10], r5
 1846 01c2 4F 45                   		mul	r4, r5
 1847                             		.loc 2 947 62
 1848 01c4 60 D5                   		sub	#13, r5
 1849                             		.loc 2 947 15
 1850 01c6 EF 53                   		mov.L	r5, r3
 1851 01c8 ED A2 38                		mov.L	224[r10], r2
 1852 01cb ED A1 36                		mov.L	216[r10], r1
 1853 01ce 05 00 00 00             		bsr	_Hmac_HashUpdate
 1854 01d2 E7 A1 12                		mov.L	r1, 72[r10]
 948:../src/src/tls.c ****                                                      WOLFSSL_TLS_HMAC_INNER_SZ);
 949:../src/src/tls.c ****         if (ret != 0)
 1855                             		.loc 2 949 12
 1856 01d5 ED A5 12                		mov.L	72[r10], r5
 1857 01d8 61 05                   		cmp	#0, r5
 1858 01da 20 0C                   		beq	.L104
 950:../src/src/tls.c ****             return ret;
 1859                             		.loc 2 950 20
 1860 01dc ED A5 12                		mov.L	72[r10], r5
 1861 01df 38 CB 01                		bra	.L117
 1862                             	.L102:
 951:../src/src/tls.c ****     }
 952:../src/src/tls.c ****     else
 953:../src/src/tls.c ****         safeBlocks = 0;
 1863                             		.loc 2 953 20
 1864 01e2 F9 A6 04 00             		mov.L	#0, 16[r10]
 1865                             	.L104:
 954:../src/src/tls.c **** 
 955:../src/src/tls.c ****     XMEMSET(digest, 0, macLen);
 1866                             		.loc 2 955 5
 1867 01e6 EC 65                   		mov.L	[r6], r5
 1868 01e8 EF 53                   		mov.L	r5, r3
 1869 01ea 66 02                   		mov.L	#0, r2
 1870 01ec ED A1 37                		mov.L	220[r10], r1
 1871 01ef 05 00 00 00             		bsr	_memset
 956:../src/src/tls.c ****     k = safeBlocks * blockSz;
 1872                             		.loc 2 956 20
 1873 01f3 ED A4 04                		mov.L	16[r10], r4
 1874 01f6 ED A5 05                		mov.L	20[r10], r5
 1875 01f9 4F 45                   		mul	r4, r5
 1876                             		.loc 2 956 7
 1877 01fb E7 A5 02                		mov.L	r5, 8[r10]
 957:../src/src/tls.c ****     for (i = safeBlocks; i < blocks; i++) {
 1878                             		.loc 2 957 12
 1879 01fe ED A5 04                		mov.L	16[r10], r5
 1880 0201 E3 A5                   		mov.L	r5, [r10]
 1881                             		.loc 2 957 5
 1882 0203 38 8B 01                		bra	.L105
 1883                             	.L116:
 1884                             	.LBB4:
 958:../src/src/tls.c ****         unsigned char hashBlock[WC_MAX_BLOCK_SIZE];
 959:../src/src/tls.c ****         unsigned char isEocBlock = ctMaskEq(i, eocBlock);
 1885                             		.loc 2 959 36
 1886 0206 ED A2 10                		mov.L	64[r10], r2
 1887 0209 EC A1                   		mov.L	[r10], r1
 1888 020b 05 00 00 00             		bsr	_ctMaskEq
 1889 020f EF 15                   		mov.L	r1, r5
 1890 0211 C7 A5 4C                		mov.B	r5, 76[r10]
 960:../src/src/tls.c ****         unsigned char isOutBlock = ctMaskEq(i, lenBlock);
 1891                             		.loc 2 960 36
 1892 0214 ED A2 0F                		mov.L	60[r10], r2
 1893 0217 EC A1                   		mov.L	[r10], r1
 1894 0219 05 00 00 00             		bsr	_ctMaskEq
 1895 021d EF 15                   		mov.L	r1, r5
 1896 021f C7 A5 4D                		mov.B	r5, 77[r10]
 961:../src/src/tls.c **** 
 962:../src/src/tls.c ****         for (j = 0; j < blockSz; j++) {
 1897                             		.loc 2 962 16
 1898 0222 F9 A6 01 00             		mov.L	#0, 4[r10]
 1899                             		.loc 2 962 9
 1900 0226 38 D6 00                		bra	.L106
 1901                             	.L110:
 1902                             	.LBB5:
 963:../src/src/tls.c ****             unsigned char atEoc = ctMaskEq(j, eocIndex) & isEocBlock;
 1903                             		.loc 2 963 35
 1904 0229 ED A2 11                		mov.L	68[r10], r2
 1905 022c ED A1 01                		mov.L	4[r10], r1
 1906 022f 05 00 00 00             		bsr	_ctMaskEq
 1907 0233 EF 15                   		mov.L	r1, r5
 1908                             		.loc 2 963 27
 1909 0235 CD A4 4C                		mov.B	76[r10], r4
 1910 0238 53 45                   		and	r4, r5
 1911 023a C7 A5 4E                		mov.B	r5, 78[r10]
 964:../src/src/tls.c ****             unsigned char pastEoc = ctMaskGT(j, eocIndex) & isEocBlock;
 1912                             		.loc 2 964 37
 1913 023d ED A2 11                		mov.L	68[r10], r2
 1914 0240 ED A1 01                		mov.L	4[r10], r1
 1915 0243 05 00 00 00             		bsr	_ctMaskGT
 1916 0247 EF 15                   		mov.L	r1, r5
 1917                             		.loc 2 964 27
 1918 0249 CD A4 4C                		mov.B	76[r10], r4
 1919 024c 53 45                   		and	r4, r5
 1920 024e C7 A5 4F                		mov.B	r5, 79[r10]
 965:../src/src/tls.c ****             unsigned char b = 0;
 1921                             		.loc 2 965 27
 1922 0251 F9 A4 1C 00             		mov.B	#0, 28[r10]
 966:../src/src/tls.c **** 
 967:../src/src/tls.c ****             if (k < WOLFSSL_TLS_HMAC_INNER_SZ)
 1923                             		.loc 2 967 16
 1924 0255 ED A5 02                		mov.L	8[r10], r5
 1925 0258 61 C5                   		cmp	#12, r5
 1926 025a 24 0F                   		bgtu	.L107
 968:../src/src/tls.c ****                 b = header[k];
 1927                             		.loc 2 968 27
 1928 025c A8 6D                   		mov.L	4[r6], r5
 1929 025e 06 89 A5 02             		add	8[r10].L, r5
 1930                             		.loc 2 968 19
 1931 0262 CC 55                   		mov.B	[r5], r5
 1932 0264 C7 A5 1C                		mov.B	r5, 28[r10]
 1933 0267 2E 1B                   		bra	.L108
 1934                             	.L107:
 969:../src/src/tls.c ****             else if (k < maxLen)
 1935                             		.loc 2 969 21
 1936 0269 ED A4 02                		mov.L	8[r10], r4
 1937 026c ED A5 09                		mov.L	36[r10], r5
 1938 026f 47 54                   		cmp	r5, r4
 1939 0271 22 11                   		bgeu	.L108
 970:../src/src/tls.c ****                 b = in[k - WOLFSSL_TLS_HMAC_INNER_SZ];
 1940                             		.loc 2 970 23
 1941 0273 ED A5 02                		mov.L	8[r10], r5
 1942 0276 60 D5                   		sub	#13, r5
 1943 0278 ED A4 38                		mov.L	224[r10], r4
 1944 027b 4B 45                   		add	r4, r5
 1945                             		.loc 2 970 19
 1946 027d CC 55                   		mov.B	[r5], r5
 1947 027f C7 A5 1C                		mov.B	r5, 28[r10]
 1948                             	.L108:
 971:../src/src/tls.c ****             k++;
 1949                             		.loc 2 971 14
 1950 0282 ED A5 02                		mov.L	8[r10], r5
 1951 0285 62 15                   		add	#1, r5
 1952 0287 E7 A5 02                		mov.L	r5, 8[r10]
 972:../src/src/tls.c **** 
 973:../src/src/tls.c ****             b = ctMaskSel(atEoc, 0x80, b);
 1953                             		.loc 2 973 17
 1954 028a CD A3 1C                		mov.B	28[r10], r3
 1955 028d FB 26 80                		mov	#-128, r2
 1956 0290 CD A1 4E                		mov.B	78[r10], r1
 1957 0293 05 00 00 00             		bsr	_ctMaskSel
 1958 0297 EF 15                   		mov.L	r1, r5
 1959 0299 C7 A5 1C                		mov.B	r5, 28[r10]
 974:../src/src/tls.c ****             b &= (unsigned char)~(word32)pastEoc;
 1960                             		.loc 2 974 18
 1961 029c CD A5 4F                		mov.B	79[r10], r5
 1962 029f 7E 05                   		not	r5
 1963                             		.loc 2 974 15
 1964 02a1 CD A4 1C                		mov.B	28[r10], r4
 1965 02a4 53 45                   		and	r4, r5
 1966 02a6 C7 A5 1C                		mov.B	r5, 28[r10]
 975:../src/src/tls.c ****             b &= ((unsigned char)~(word32)isOutBlock) | isEocBlock;
 1967                             		.loc 2 975 19
 1968 02a9 CD A5 4D                		mov.B	77[r10], r5
 1969 02ac 7E 05                   		not	r5
 1970                             		.loc 2 975 15
 1971 02ae CD A4 4C                		mov.B	76[r10], r4
 1972 02b1 57 45                   		or	r4, r5
 1973 02b3 CD A4 1C                		mov.B	28[r10], r4
 1974 02b6 53 45                   		and	r4, r5
 1975 02b8 C7 A5 1C                		mov.B	r5, 28[r10]
 976:../src/src/tls.c **** 
 977:../src/src/tls.c ****             if (j >= blockSz - 8) {
 1976                             		.loc 2 977 30
 1977 02bb ED A5 05                		mov.L	20[r10], r5
 1978 02be 60 85                   		sub	#8, r5
 1979                             		.loc 2 977 16
 1980 02c0 ED A4 01                		mov.L	4[r10], r4
 1981 02c3 47 54                   		cmp	r5, r4
 1982 02c5 29 23                   		blt	.L109
 978:../src/src/tls.c ****                 b = ctMaskSel(isOutBlock, lenBytes[j - (blockSz - 8)], b);
 1983                             		.loc 2 978 65
 1984 02c7 ED A5 05                		mov.L	20[r10], r5
 1985 02ca 60 85                   		sub	#8, r5
 1986                             		.loc 2 978 54
 1987 02cc ED A4 01                		mov.L	4[r10], r4
 1988 02cf FF 05 54                		sub	r5, r4, r5
 1989                             		.loc 2 978 21
 1990 02d2 4B A5                   		add	r10, r5
 1991 02d4 CD 55 50                		mov.B	80[r5], r5
 1992 02d7 CD A3 1C                		mov.B	28[r10], r3
 1993 02da CF 52                   		mov.B	r5, r2
 1994 02dc CD A1 4D                		mov.B	77[r10], r1
 1995 02df 05 00 00 00             		bsr	_ctMaskSel
 1996 02e3 EF 15                   		mov.L	r1, r5
 1997 02e5 C7 A5 1C                		mov.B	r5, 28[r10]
 1998                             	.L109:
 979:../src/src/tls.c ****             }
 980:../src/src/tls.c **** 
 981:../src/src/tls.c ****             hashBlock[j] = b;
 1999                             		.loc 2 981 26 discriminator 2
 2000 02e8 71 A5 58                		add	#0x58, r10, r5
 2001 02eb 06 89 A5 01             		add	4[r10].L, r5
 2002 02ef CD A4 1C                		mov.B	28[r10], r4
 2003 02f2 C3 54                   		mov.B	r4, [r5]
 2004                             	.LBE5:
 962:../src/src/tls.c ****             unsigned char atEoc = ctMaskEq(j, eocIndex) & isEocBlock;
 2005                             		.loc 2 962 35 discriminator 2
 2006 02f4 ED A5 01                		mov.L	4[r10], r5
 2007 02f7 62 15                   		add	#1, r5
 2008 02f9 E7 A5 01                		mov.L	r5, 4[r10]
 2009                             	.L106:
 962:../src/src/tls.c ****             unsigned char atEoc = ctMaskEq(j, eocIndex) & isEocBlock;
 2010                             		.loc 2 962 9 discriminator 1
 2011 02fc ED A4 01                		mov.L	4[r10], r4
 2012 02ff ED A5 05                		mov.L	20[r10], r5
 2013 0302 47 54                   		cmp	r5, r4
 2014 0304 28 05 38 23 FF          		blt	.L110
 982:../src/src/tls.c ****         }
 983:../src/src/tls.c **** 
 984:../src/src/tls.c ****         ret = Hmac_HashUpdate(hmac, hashBlock, blockSz);
 2015                             		.loc 2 984 15
 2016 0309 ED A4 05                		mov.L	20[r10], r4
 2017 030c 71 A5 58                		add	#0x58, r10, r5
 2018 030f EF 43                   		mov.L	r4, r3
 2019 0311 EF 52                   		mov.L	r5, r2
 2020 0313 ED A1 36                		mov.L	216[r10], r1
 2021 0316 05 00 00 00             		bsr	_Hmac_HashUpdate
 2022 031a E7 A1 12                		mov.L	r1, 72[r10]
 985:../src/src/tls.c ****         if (ret != 0)
 2023                             		.loc 2 985 12
 2024 031d ED A5 12                		mov.L	72[r10], r5
 2025 0320 61 05                   		cmp	#0, r5
 2026 0322 17                      		beq	.L111
 986:../src/src/tls.c ****             return ret;
 2027                             		.loc 2 986 20
 2028 0323 ED A5 12                		mov.L	72[r10], r5
 2029 0326 38 84 00                		bra	.L117
 2030                             	.L111:
 987:../src/src/tls.c ****         ret = Hmac_HashFinalRaw(hmac, hashBlock);
 2031                             		.loc 2 987 15
 2032 0329 71 A5 58                		add	#0x58, r10, r5
 2033 032c EF 52                   		mov.L	r5, r2
 2034 032e ED A1 36                		mov.L	216[r10], r1
 2035 0331 05 00 00 00             		bsr	_Hmac_HashFinalRaw
 2036 0335 E7 A1 12                		mov.L	r1, 72[r10]
 988:../src/src/tls.c ****         if (ret != 0)
 2037                             		.loc 2 988 12
 2038 0338 ED A5 12                		mov.L	72[r10], r5
 2039 033b 61 05                   		cmp	#0, r5
 2040 033d 16                      		beq	.L113
 989:../src/src/tls.c ****             return ret;
 2041                             		.loc 2 989 20
 2042 033e ED A5 12                		mov.L	72[r10], r5
 2043 0341 2E 69                   		bra	.L117
 2044                             	.L113:
 990:../src/src/tls.c ****         for (j = 0; j < macLen; j++)
 2045                             		.loc 2 990 16
 2046 0343 F9 A6 01 00             		mov.L	#0, 4[r10]
 2047                             		.loc 2 990 9
 2048 0347 2E 38                   		bra	.L114
 2049                             	.L115:
 991:../src/src/tls.c ****             ((unsigned char*)hmac->innerHash)[j] |= hashBlock[j] & isOutBlock;
 2050                             		.loc 2 991 30 discriminator 3
 2051 0349 ED A5 36                		mov.L	216[r10], r5
 2052 034c 72 55 D8 01             		add	#0x1d8, r5
 2053                             		.loc 2 991 50 discriminator 3
 2054 0350 ED A4 01                		mov.L	4[r10], r4
 2055 0353 4B 45                   		add	r4, r5
 2056 0355 CC 53                   		mov.B	[r5], r3
 2057                             		.loc 2 991 62 discriminator 3
 2058 0357 71 A5 58                		add	#0x58, r10, r5
 2059 035a 06 89 A5 01             		add	4[r10].L, r5
 2060 035e CC 55                   		mov.B	[r5], r5
 2061                             		.loc 2 991 50 discriminator 3
 2062 0360 CD A4 4D                		mov.B	77[r10], r4
 2063 0363 53 45                   		and	r4, r5
 2064 0365 CF 54                   		mov.B	r5, r4
 2065                             		.loc 2 991 30 discriminator 3
 2066 0367 ED A5 36                		mov.L	216[r10], r5
 2067 036a 72 55 D8 01             		add	#0x1d8, r5
 2068                             		.loc 2 991 50 discriminator 3
 2069 036e ED A2 01                		mov.L	4[r10], r2
 2070 0371 4B 25                   		add	r2, r5
 2071 0373 57 34                   		or	r3, r4
 2072 0375 C3 54                   		mov.B	r4, [r5]
 990:../src/src/tls.c ****         for (j = 0; j < macLen; j++)
 2073                             		.loc 2 990 34 discriminator 3
 2074 0377 ED A5 01                		mov.L	4[r10], r5
 2075 037a 62 15                   		add	#1, r5
 2076 037c E7 A5 01                		mov.L	r5, 4[r10]
 2077                             	.L114:
 990:../src/src/tls.c ****         for (j = 0; j < macLen; j++)
 2078                             		.loc 2 990 9 discriminator 1
 2079 037f ED A4 01                		mov.L	4[r10], r4
 2080 0382 EC 65                   		mov.L	[r6], r5
 2081 0384 47 54                   		cmp	r5, r4
 2082 0386 29 C3                   		blt	.L115
 2083                             	.LBE4:
 957:../src/src/tls.c ****         unsigned char hashBlock[WC_MAX_BLOCK_SIZE];
 2084                             		.loc 2 957 39
 2085 0388 EC A5                   		mov.L	[r10], r5
 2086 038a 62 15                   		add	#1, r5
 2087 038c E3 A5                   		mov.L	r5, [r10]
 2088                             	.L105:
 957:../src/src/tls.c ****         unsigned char hashBlock[WC_MAX_BLOCK_SIZE];
 2089                             		.loc 2 957 5 discriminator 1
 2090 038e EC A4                   		mov.L	[r10], r4
 2091 0390 ED A5 0B                		mov.L	44[r10], r5
 2092 0393 47 54                   		cmp	r5, r4
 2093 0395 28 05 38 6F FE          		blt	.L116
 992:../src/src/tls.c ****     }
 993:../src/src/tls.c **** 
 994:../src/src/tls.c ****     ret = Hmac_OuterHash(hmac, digest);
 2094                             		.loc 2 994 11
 2095 039a ED A2 37                		mov.L	220[r10], r2
 2096 039d ED A1 36                		mov.L	216[r10], r1
 2097 03a0 05 00 00 00             		bsr	_Hmac_OuterHash
 2098 03a4 E7 A1 12                		mov.L	r1, 72[r10]
 995:../src/src/tls.c **** 
 996:../src/src/tls.c ****     return ret;
 2099                             		.loc 2 996 12
 2100 03a7 ED A5 12                		mov.L	72[r10], r5
 2101                             		.balign 8,3,1
 2102                             	.L117:
 997:../src/src/tls.c **** }
 2103                             		.loc 2 997 1 discriminator 1
 2104 03aa EF 51                   		mov.L	r5, r1
 2105 03ac 3F 6A 41                		rtsd	#260, r6-r10
 2106                             	.LFE59:
 2108 03af 03                      		.section	.text.TLS_hmac,"ax",@progbits
 2109                             		.global	_TLS_hmac
 2111                             	_TLS_hmac:
 2112                             	.LFB60:
 998:../src/src/tls.c **** 
 999:../src/src/tls.c **** #endif
1000:../src/src/tls.c **** 
1001:../src/src/tls.c **** #if defined(WOLFSSL_NO_HASH_RAW) || defined(HAVE_FIPS) || \
1002:../src/src/tls.c ****     defined(HAVE_SELFTEST) || defined(HAVE_BLAKE2)
1003:../src/src/tls.c **** 
1004:../src/src/tls.c **** /* Calculate the HMAC of the header + message data.
1005:../src/src/tls.c ****  * Constant time implementation using normal hashing operations.
1006:../src/src/tls.c ****  * Update-Final need to be constant time.
1007:../src/src/tls.c ****  *
1008:../src/src/tls.c ****  * hmac    HMAC object.
1009:../src/src/tls.c ****  * digest  MAC result.
1010:../src/src/tls.c ****  * in      Message data.
1011:../src/src/tls.c ****  * sz      Size of the message data.
1012:../src/src/tls.c ****  * header  Constructed record header with length of handshake data.
1013:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
1014:../src/src/tls.c ****  */
1015:../src/src/tls.c **** static int Hmac_UpdateFinal(Hmac* hmac, byte* digest, const byte* in,
1016:../src/src/tls.c ****                             word32 sz, byte* header)
1017:../src/src/tls.c **** {
1018:../src/src/tls.c ****     byte       dummy[WC_MAX_BLOCK_SIZE] = {0};
1019:../src/src/tls.c ****     int        ret;
1020:../src/src/tls.c ****     word32     msgSz, blockSz, macSz, padSz, maxSz, realSz;
1021:../src/src/tls.c ****     word32     currSz, offset = 0;
1022:../src/src/tls.c ****     int        msgBlocks, blocks, blockBits;
1023:../src/src/tls.c ****     int        i;
1024:../src/src/tls.c **** 
1025:../src/src/tls.c ****     switch (hmac->macType) {
1026:../src/src/tls.c ****     #ifndef NO_SHA
1027:../src/src/tls.c ****         case WC_SHA:
1028:../src/src/tls.c ****             blockSz = WC_SHA_BLOCK_SIZE;
1029:../src/src/tls.c ****             blockBits = 6;
1030:../src/src/tls.c ****             macSz = WC_SHA_DIGEST_SIZE;
1031:../src/src/tls.c ****             padSz = WC_SHA_BLOCK_SIZE - WC_SHA_PAD_SIZE + 1;
1032:../src/src/tls.c ****             break;
1033:../src/src/tls.c ****     #endif /* !NO_SHA */
1034:../src/src/tls.c **** 
1035:../src/src/tls.c ****     #ifndef NO_SHA256
1036:../src/src/tls.c ****         case WC_SHA256:
1037:../src/src/tls.c ****             blockSz = WC_SHA256_BLOCK_SIZE;
1038:../src/src/tls.c ****             blockBits = 6;
1039:../src/src/tls.c ****             macSz = WC_SHA256_DIGEST_SIZE;
1040:../src/src/tls.c ****             padSz = WC_SHA256_BLOCK_SIZE - WC_SHA256_PAD_SIZE + 1;
1041:../src/src/tls.c ****             break;
1042:../src/src/tls.c ****     #endif /* !NO_SHA256 */
1043:../src/src/tls.c **** 
1044:../src/src/tls.c ****     #ifdef WOLFSSL_SHA384
1045:../src/src/tls.c ****         case WC_SHA384:
1046:../src/src/tls.c ****             blockSz = WC_SHA384_BLOCK_SIZE;
1047:../src/src/tls.c ****             blockBits = 7;
1048:../src/src/tls.c ****             macSz = WC_SHA384_DIGEST_SIZE;
1049:../src/src/tls.c ****             padSz = WC_SHA384_BLOCK_SIZE - WC_SHA384_PAD_SIZE + 1;
1050:../src/src/tls.c ****             break;
1051:../src/src/tls.c ****     #endif /* WOLFSSL_SHA384 */
1052:../src/src/tls.c **** 
1053:../src/src/tls.c ****     #ifdef WOLFSSL_SHA512
1054:../src/src/tls.c ****         case WC_SHA512:
1055:../src/src/tls.c ****             blockSz = WC_SHA512_BLOCK_SIZE;
1056:../src/src/tls.c ****             blockBits = 7;
1057:../src/src/tls.c ****             macSz = WC_SHA512_DIGEST_SIZE;
1058:../src/src/tls.c ****             padSz = WC_SHA512_BLOCK_SIZE - WC_SHA512_PAD_SIZE + 1;
1059:../src/src/tls.c ****             break;
1060:../src/src/tls.c ****     #endif /* WOLFSSL_SHA512 */
1061:../src/src/tls.c **** 
1062:../src/src/tls.c ****     #ifdef HAVE_BLAKE2
1063:../src/src/tls.c ****         case WC_HASH_TYPE_BLAKE2B:
1064:../src/src/tls.c ****             blockSz = BLAKE2B_BLOCKBYTES;
1065:../src/src/tls.c ****             blockBits = 7;
1066:../src/src/tls.c ****             macSz = BLAKE2B_256;
1067:../src/src/tls.c ****             padSz = 0;
1068:../src/src/tls.c ****             break;
1069:../src/src/tls.c ****     #endif /* HAVE_BLAKE2 */
1070:../src/src/tls.c **** 
1071:../src/src/tls.c ****         default:
1072:../src/src/tls.c ****             return BAD_FUNC_ARG;
1073:../src/src/tls.c ****     }
1074:../src/src/tls.c **** 
1075:../src/src/tls.c ****     msgSz = sz - (1 + in[sz - 1] + macSz);
1076:../src/src/tls.c ****     /* Make negative result 0 */
1077:../src/src/tls.c ****     msgSz &= ~(0 - (msgSz >> 31));
1078:../src/src/tls.c ****     realSz = WOLFSSL_TLS_HMAC_INNER_SZ + msgSz;
1079:../src/src/tls.c ****     maxSz = WOLFSSL_TLS_HMAC_INNER_SZ + (sz - 1) - macSz;
1080:../src/src/tls.c **** 
1081:../src/src/tls.c ****     /* Calculate #blocks processed in HMAC for max and real data. */
1082:../src/src/tls.c ****     blocks      = maxSz >> blockBits;
1083:../src/src/tls.c ****     blocks     += ((maxSz + padSz) % blockSz) < padSz;
1084:../src/src/tls.c ****     msgBlocks   = realSz >> blockBits;
1085:../src/src/tls.c ****     /* #Extra blocks to process. */
1086:../src/src/tls.c ****     blocks -= msgBlocks + ((((realSz + padSz) % blockSz) < padSz) ? 1 : 0);
1087:../src/src/tls.c ****     /* Calculate whole blocks. */
1088:../src/src/tls.c ****     msgBlocks--;
1089:../src/src/tls.c **** 
1090:../src/src/tls.c ****     ret = wc_HmacUpdate(hmac, header, WOLFSSL_TLS_HMAC_INNER_SZ);
1091:../src/src/tls.c ****     if (ret == 0) {
1092:../src/src/tls.c ****         /* Fill the rest of the block with any available data. */
1093:../src/src/tls.c ****         currSz = ctMaskLT(msgSz, blockSz) & msgSz;
1094:../src/src/tls.c ****         currSz |= ctMaskGTE(msgSz, blockSz) & blockSz;
1095:../src/src/tls.c ****         currSz -= WOLFSSL_TLS_HMAC_INNER_SZ;
1096:../src/src/tls.c ****         currSz &= ~(0 - (currSz >> 31));
1097:../src/src/tls.c ****         ret = wc_HmacUpdate(hmac, in, currSz);
1098:../src/src/tls.c ****         offset = currSz;
1099:../src/src/tls.c ****     }
1100:../src/src/tls.c ****     if (ret == 0) {
1101:../src/src/tls.c ****         /* Do the hash operations on a block basis. */
1102:../src/src/tls.c ****         for (i = 0; i < msgBlocks; i++, offset += blockSz) {
1103:../src/src/tls.c ****             ret = wc_HmacUpdate(hmac, in + offset, blockSz);
1104:../src/src/tls.c ****             if (ret != 0)
1105:../src/src/tls.c ****                 break;
1106:../src/src/tls.c ****         }
1107:../src/src/tls.c ****     }
1108:../src/src/tls.c ****     if (ret == 0)
1109:../src/src/tls.c ****         ret = wc_HmacUpdate(hmac, in + offset, msgSz - offset);
1110:../src/src/tls.c ****     if (ret == 0)
1111:../src/src/tls.c ****         ret = wc_HmacFinal(hmac, digest);
1112:../src/src/tls.c ****     if (ret == 0) {
1113:../src/src/tls.c ****         /* Do the dummy hash operations. Do at least one. */
1114:../src/src/tls.c ****         for (i = 0; i < blocks + 1; i++) {
1115:../src/src/tls.c ****             ret = wc_HmacUpdate(hmac, dummy, blockSz);
1116:../src/src/tls.c ****             if (ret != 0)
1117:../src/src/tls.c ****                 break;
1118:../src/src/tls.c ****         }
1119:../src/src/tls.c ****     }
1120:../src/src/tls.c **** 
1121:../src/src/tls.c ****     return ret;
1122:../src/src/tls.c **** }
1123:../src/src/tls.c **** 
1124:../src/src/tls.c **** #endif
1125:../src/src/tls.c **** 
1126:../src/src/tls.c **** int TLS_hmac(WOLFSSL* ssl, byte* digest, const byte* in, word32 sz, int padSz,
1127:../src/src/tls.c ****              int content, int verify, int epochOrder)
1128:../src/src/tls.c **** {
 2113                             		.loc 2 1128 1
 2114 0000 7E AA                   		push.l	r10
 2115                             	.LCFI64:
 2116 0002 7E A6                   		push.l	r6
 2117                             	.LCFI65:
 2118 0004 72 0A A4 FD             		add	#-604, r0, r10
 2119                             	.LCFI66:
 2120 0008 71 A0 F8                		add	#-8, r10, r0
 2121                             	.LCFI67:
 2122 000b FB 6A 68 02             		mov.L	#0x268, r6
 2123 000f 4B A6                   		add	r10, r6
 2124 0011 E7 A1 8F                		mov.L	r1, 572[r10]
 2125 0014 E7 A2 90                		mov.L	r2, 576[r10]
 2126 0017 E7 A3 91                		mov.L	r3, 580[r10]
 2127 001a E7 A4 92                		mov.L	r4, 584[r10]
1129:../src/src/tls.c ****     Hmac   hmac;
1130:../src/src/tls.c ****     byte   myInner[WOLFSSL_TLS_HMAC_INNER_SZ];
1131:../src/src/tls.c ****     int    ret = 0;
 2128                             		.loc 2 1131 12
 2129 001d F8 A6 00                		mov.L	#0, [r10]
1132:../src/src/tls.c ****     const byte* macSecret = NULL;
 2130                             		.loc 2 1132 17
 2131 0020 F9 A6 01 00             		mov.L	#0, 4[r10]
1133:../src/src/tls.c ****     word32 hashSz = 0;
 2132                             		.loc 2 1133 12
 2133 0024 F9 A6 02 00             		mov.L	#0, 8[r10]
1134:../src/src/tls.c **** 
1135:../src/src/tls.c ****     if (ssl == NULL)
 2134                             		.loc 2 1135 8
 2135 0028 ED A5 8F                		mov.L	572[r10], r5
 2136 002b 61 05                   		cmp	#0, r5
 2137 002d 18                      		bne	.L119
1136:../src/src/tls.c ****         return BAD_FUNC_ARG;
 2138                             		.loc 2 1136 16
 2139 002e FB 5A 53 FF             		mov.L	#-173, r5
 2140 0032 38 21 01                		bra	.L127
 2141                             	.L119:
1137:../src/src/tls.c **** 
1138:../src/src/tls.c **** #ifdef HAVE_TRUNCATED_HMAC
1139:../src/src/tls.c ****     hashSz = ssl->truncated_hmac ? (byte)TRUNCATED_HMAC_SZ
1140:../src/src/tls.c ****                                         : ssl->specs.hash_size;
1141:../src/src/tls.c **** #else
1142:../src/src/tls.c ****     hashSz = ssl->specs.hash_size;
 2142                             		.loc 2 1142 24
 2143 0035 ED A5 8F                		mov.L	572[r10], r5
 2144 0038 CE 55 71 01             		mov.B	369[r5], r5
 2145                             		.loc 2 1142 12
 2146 003c 5B 55                   		movu.B	r5, r5
 2147 003e E7 A5 02                		mov.L	r5, 8[r10]
1143:../src/src/tls.c **** #endif
1144:../src/src/tls.c **** 
1145:../src/src/tls.c **** #ifdef HAVE_FUZZER
1146:../src/src/tls.c ****     /* Fuzz "in" buffer with sz to be used in HMAC algorithm */
1147:../src/src/tls.c ****     if (ssl->fuzzerCb) {
1148:../src/src/tls.c ****         if (verify && padSz >= 0) {
1149:../src/src/tls.c ****             ssl->fuzzerCb(ssl, in, sz + hashSz + padSz + 1, FUZZ_HMAC,
1150:../src/src/tls.c ****                           ssl->fuzzerCtx);
1151:../src/src/tls.c ****         }
1152:../src/src/tls.c ****         else {
1153:../src/src/tls.c ****             ssl->fuzzerCb(ssl, in, sz, FUZZ_HMAC, ssl->fuzzerCtx);
1154:../src/src/tls.c ****         }
1155:../src/src/tls.c ****     }
1156:../src/src/tls.c **** #endif
1157:../src/src/tls.c **** 
1158:../src/src/tls.c ****     if (!ssl->options.dtls)
 2148                             		.loc 2 1158 9
 2149 0041 ED A5 8F                		mov.L	572[r10], r5
 2150 0044 ED 55 A7                		mov.L	668[r5], r5
 2151 0047 77 25 00 00 04          		and	#0x40000, r5
 2152                             		.loc 2 1158 8
 2153 004c 61 05                   		cmp	#0, r5
 2154 004e 21 1A                   		bne	.L121
1159:../src/src/tls.c ****         wolfSSL_SetTlsHmacInner(ssl, myInner, sz, content, verify);
 2155                             		.loc 2 1159 9
 2156 0050 72 A5 2C 02             		add	#0x22c, r10, r5
 2157 0054 A8 E4                   		mov.L	8[r6], r4
 2158 0056 E3 04                   		mov.L	r4, [r0]
 2159 0058 A8 6C                   		mov.L	4[r6], r4
 2160 005a ED A3 92                		mov.L	584[r10], r3
 2161 005d EF 52                   		mov.L	r5, r2
 2162 005f ED A1 8F                		mov.L	572[r10], r1
 2163 0062 05 00 00 00             		bsr	_wolfSSL_SetTlsHmacInner
 2164 0066 2E 18                   		bra	.L122
 2165                             	.L121:
1160:../src/src/tls.c ****     else
1161:../src/src/tls.c ****         wolfSSL_SetTlsHmacInner(ssl, myInner, sz, content, epochOrder);
 2166                             		.loc 2 1161 9
 2167 0068 72 A5 2C 02             		add	#0x22c, r10, r5
 2168 006c A8 EC                   		mov.L	12[r6], r4
 2169 006e E3 04                   		mov.L	r4, [r0]
 2170 0070 A8 6C                   		mov.L	4[r6], r4
 2171 0072 ED A3 92                		mov.L	584[r10], r3
 2172 0075 EF 52                   		mov.L	r5, r2
 2173 0077 ED A1 8F                		mov.L	572[r10], r1
 2174 007a 05 00 00 00             		bsr	_wolfSSL_SetTlsHmacInner
 2175                             	.L122:
1162:../src/src/tls.c **** 
1163:../src/src/tls.c ****     ret = wc_HmacInit(&hmac, ssl->heap, ssl->devId);
 2176                             		.loc 2 1163 11
 2177 007e ED A5 8F                		mov.L	572[r10], r5
 2178 0081 AA 5C                   		mov.L	36[r5], r4
 2179 0083 ED A5 8F                		mov.L	572[r10], r5
 2180 0086 ED 53 BE                		mov.L	760[r5], r3
 2181 0089 71 A5 0C                		add	#12, r10, r5
 2182 008c EF 42                   		mov.L	r4, r2
 2183 008e EF 51                   		mov.L	r5, r1
 2184 0090 05 00 00 00             		bsr	_wc_HmacInit
 2185 0094 E3 A1                   		mov.L	r1, [r10]
1164:../src/src/tls.c ****     if (ret != 0)
 2186                             		.loc 2 1164 8
 2187 0096 EC A5                   		mov.L	[r10], r5
 2188 0098 61 05                   		cmp	#0, r5
 2189 009a 16                      		beq	.L123
1165:../src/src/tls.c ****         return ret;
 2190                             		.loc 2 1165 16
 2191 009b EC A5                   		mov.L	[r10], r5
 2192 009d 38 B6 00                		bra	.L127
 2193                             	.L123:
1166:../src/src/tls.c **** 
1167:../src/src/tls.c **** 
1168:../src/src/tls.c **** #ifdef WOLFSSL_DTLS
1169:../src/src/tls.c ****     if (ssl->options.dtls)
1170:../src/src/tls.c ****         macSecret = wolfSSL_GetDtlsMacSecret(ssl, verify, epochOrder);
1171:../src/src/tls.c ****     else
1172:../src/src/tls.c ****         macSecret = wolfSSL_GetMacSecret(ssl, verify);
1173:../src/src/tls.c **** #else
1174:../src/src/tls.c ****     macSecret = wolfSSL_GetMacSecret(ssl, verify);
 2194                             		.loc 2 1174 17
 2195 00a0 A8 E2                   		mov.L	8[r6], r2
 2196 00a2 ED A1 8F                		mov.L	572[r10], r1
 2197 00a5 05 00 00 00             		bsr	_wolfSSL_GetMacSecret
 2198 00a9 E7 A1 01                		mov.L	r1, 4[r10]
1175:../src/src/tls.c **** #endif
1176:../src/src/tls.c ****     ret = wc_HmacSetKey(&hmac, wolfSSL_GetHmacType(ssl),
 2199                             		.loc 2 1176 11
 2200 00ac ED A1 8F                		mov.L	572[r10], r1
 2201 00af 05 00 00 00             		bsr	_wolfSSL_GetHmacType
 2202 00b3 EF 12                   		mov.L	r1, r2
1177:../src/src/tls.c ****                                               macSecret,
1178:../src/src/tls.c ****                                               ssl->specs.hash_size);
 2203                             		.loc 2 1178 57
 2204 00b5 ED A5 8F                		mov.L	572[r10], r5
 2205 00b8 CE 55 71 01             		mov.B	369[r5], r5
1176:../src/src/tls.c ****                                               macSecret,
 2206                             		.loc 2 1176 11
 2207 00bc 5B 54                   		movu.B	r5, r4
 2208 00be 71 A5 0C                		add	#12, r10, r5
 2209 00c1 ED A3 01                		mov.L	4[r10], r3
 2210 00c4 EF 51                   		mov.L	r5, r1
 2211 00c6 05 00 00 00             		bsr	_wc_HmacSetKey
 2212 00ca E3 A1                   		mov.L	r1, [r10]
1179:../src/src/tls.c **** 
1180:../src/src/tls.c ****     if (ret == 0) {
 2213                             		.loc 2 1180 8
 2214 00cc EC A5                   		mov.L	[r10], r5
 2215 00ce 61 05                   		cmp	#0, r5
 2216 00d0 21 78                   		bne	.L124
1181:../src/src/tls.c ****         /* Constant time verification required. */
1182:../src/src/tls.c ****         if (verify && padSz >= 0) {
 2217                             		.loc 2 1182 12
 2218 00d2 A8 E5                   		mov.L	8[r6], r5
 2219 00d4 61 05                   		cmp	#0, r5
 2220 00d6 20 34                   		beq	.L125
 2221                             		.loc 2 1182 20 discriminator 1
 2222 00d8 EC 65                   		mov.L	[r6], r5
 2223 00da 61 05                   		cmp	#0, r5
 2224 00dc 29 2E                   		blt	.L125
1183:../src/src/tls.c **** #if !defined(WOLFSSL_NO_HASH_RAW) && !defined(HAVE_FIPS) && \
1184:../src/src/tls.c ****     !defined(HAVE_SELFTEST)
1185:../src/src/tls.c ****     #ifdef HAVE_BLAKE2
1186:../src/src/tls.c ****             if (wolfSSL_GetHmacType(ssl) == WC_HASH_TYPE_BLAKE2B) {
1187:../src/src/tls.c ****                 ret = Hmac_UpdateFinal(&hmac, digest, in,
1188:../src/src/tls.c ****                                               sz + hashSz + padSz + 1, myInner);
1189:../src/src/tls.c ****             }
1190:../src/src/tls.c ****             else
1191:../src/src/tls.c ****     #endif
1192:../src/src/tls.c ****             {
1193:../src/src/tls.c ****                 ret = Hmac_UpdateFinal_CT(&hmac, digest, in,
1194:../src/src/tls.c ****                                       sz + hashSz + padSz + 1, hashSz, myInner);
 2225                             		.loc 2 1194 42
 2226 00de ED A5 92                		mov.L	584[r10], r5
 2227 00e1 06 89 A5 02             		add	8[r10].L, r5
 2228                             		.loc 2 1194 51
 2229 00e5 EC 64                   		mov.L	[r6], r4
 2230 00e7 4B 45                   		add	r4, r5
1193:../src/src/tls.c ****                                       sz + hashSz + padSz + 1, hashSz, myInner);
 2231                             		.loc 2 1193 23
 2232 00e9 71 54 01                		add	#1, r5, r4
 2233 00ec ED A2 02                		mov.L	8[r10], r2
 2234 00ef 71 A5 0C                		add	#12, r10, r5
 2235 00f2 72 A3 2C 02             		add	#0x22c, r10, r3
 2236 00f6 A0 0B                   		mov.L	r3, 4[r0]
 2237 00f8 E3 02                   		mov.L	r2, [r0]
 2238 00fa ED A3 91                		mov.L	580[r10], r3
 2239 00fd ED A2 90                		mov.L	576[r10], r2
 2240 0100 EF 51                   		mov.L	r5, r1
 2241 0102 05 00 00 00             		bsr	_Hmac_UpdateFinal_CT
 2242 0106 E3 A1                   		mov.L	r1, [r10]
1193:../src/src/tls.c ****                                       sz + hashSz + padSz + 1, hashSz, myInner);
 2243                             		.loc 2 1193 21
 2244 0108 2E 40                   		bra	.L124
 2245                             	.L125:
1195:../src/src/tls.c ****             }
1196:../src/src/tls.c **** #else
1197:../src/src/tls.c ****             ret = Hmac_UpdateFinal(&hmac, digest, in, sz + hashSz + padSz + 1,
1198:../src/src/tls.c ****                                                                        myInner);
1199:../src/src/tls.c **** #endif
1200:../src/src/tls.c ****         }
1201:../src/src/tls.c ****         else {
1202:../src/src/tls.c ****             ret = wc_HmacUpdate(&hmac, myInner, sizeof(myInner));
 2246                             		.loc 2 1202 19
 2247 010a 72 A4 2C 02             		add	#0x22c, r10, r4
 2248 010e 71 A5 0C                		add	#12, r10, r5
 2249 0111 66 D3                   		mov.L	#13, r3
 2250 0113 EF 42                   		mov.L	r4, r2
 2251 0115 EF 51                   		mov.L	r5, r1
 2252 0117 05 00 00 00             		bsr	_wc_HmacUpdate
 2253 011b E3 A1                   		mov.L	r1, [r10]
1203:../src/src/tls.c ****             if (ret == 0)
 2254                             		.loc 2 1203 16
 2255 011d EC A5                   		mov.L	[r10], r5
 2256 011f 61 05                   		cmp	#0, r5
 2257 0121 21 13                   		bne	.L126
1204:../src/src/tls.c ****                 ret = wc_HmacUpdate(&hmac, in, sz);                /* content */
 2258                             		.loc 2 1204 23
 2259 0123 71 A5 0C                		add	#12, r10, r5
 2260 0126 ED A3 92                		mov.L	584[r10], r3
 2261 0129 ED A2 91                		mov.L	580[r10], r2
 2262 012c EF 51                   		mov.L	r5, r1
 2263 012e 05 00 00 00             		bsr	_wc_HmacUpdate
 2264 0132 E3 A1                   		mov.L	r1, [r10]
 2265                             	.L126:
1205:../src/src/tls.c ****             if (ret == 0)
 2266                             		.loc 2 1205 16
 2267 0134 EC A5                   		mov.L	[r10], r5
 2268 0136 61 05                   		cmp	#0, r5
 2269 0138 21 10                   		bne	.L124
1206:../src/src/tls.c ****                 ret = wc_HmacFinal(&hmac, digest);
 2270                             		.loc 2 1206 23
 2271 013a 71 A5 0C                		add	#12, r10, r5
 2272 013d ED A2 90                		mov.L	576[r10], r2
 2273 0140 EF 51                   		mov.L	r5, r1
 2274 0142 05 00 00 00             		bsr	_wc_HmacFinal
 2275 0146 E3 A1                   		mov.L	r1, [r10]
 2276                             		.balign 8,3,2
 2277                             	.L124:
1207:../src/src/tls.c ****         }
1208:../src/src/tls.c ****     }
1209:../src/src/tls.c **** 
1210:../src/src/tls.c ****     wc_HmacFree(&hmac);
 2278                             		.loc 2 1210 5
 2279 0148 71 A5 0C                		add	#12, r10, r5
 2280 014b EF 51                   		mov.L	r5, r1
 2281 014d 05 00 00 00             		bsr	_wc_HmacFree
1211:../src/src/tls.c **** 
1212:../src/src/tls.c ****     return ret;
 2282                             		.loc 2 1212 12
 2283 0151 EC A5                   		mov.L	[r10], r5
 2284                             	.L127:
1213:../src/src/tls.c **** }
 2285                             		.loc 2 1213 1 discriminator 1
 2286 0153 EF 51                   		mov.L	r5, r1
 2287 0155 72 00 64 02             		add	#0x264, r0
 2288 0159 7E B6                   		pop	r6
 2289 015b 7E BA                   		pop	r10
 2290 015d 02                      		rts
 2291                             	.LFE60:
 2293 015e EF 00                   		.section C,"a",@progbits
 2294                             		.p2align 2
 2295                             	.LC1:
 2296 0018 23 23 23 20 54 4C 53 58 		.string	"### TLSX semaphore collision or overflow detected!"
 2296      20 73 65 6D 61 70 68 6F 
 2296      72 65 20 63 6F 6C 6C 69 
 2296      73 69 6F 6E 20 6F 72 20 
 2296      6F 76 65 72 66 6C 6F 77 
 2297                             		.section	.text.TLSX_ToSemaphore,"ax",@progbits
 2299                             	_TLSX_ToSemaphore:
 2300                             	.LFB61:
1214:../src/src/tls.c **** #endif /* WOLFSSL_AEAD_ONLY */
1215:../src/src/tls.c **** 
1216:../src/src/tls.c **** #endif /* !WOLFSSL_NO_TLS12 */
1217:../src/src/tls.c **** 
1218:../src/src/tls.c **** #ifdef HAVE_TLS_EXTENSIONS
1219:../src/src/tls.c **** 
1220:../src/src/tls.c **** /**
1221:../src/src/tls.c ****  * The TLSX semaphore is used to calculate the size of the extensions to be sent
1222:../src/src/tls.c ****  * from one peer to another.
1223:../src/src/tls.c ****  */
1224:../src/src/tls.c **** 
1225:../src/src/tls.c **** /** Supports up to 64 flags. Increase as needed. */
1226:../src/src/tls.c **** #define SEMAPHORE_SIZE 8
1227:../src/src/tls.c **** 
1228:../src/src/tls.c **** /**
1229:../src/src/tls.c ****  * Converts the extension type (id) to an index in the semaphore.
1230:../src/src/tls.c ****  *
1231:../src/src/tls.c ****  * Official reference for TLS extension types:
1232:../src/src/tls.c ****  *   http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xml
1233:../src/src/tls.c ****  *
1234:../src/src/tls.c ****  * Motivation:
1235:../src/src/tls.c ****  *   Previously, we used the extension type itself as the index of that
1236:../src/src/tls.c ****  *   extension in the semaphore as the extension types were declared
1237:../src/src/tls.c ****  *   sequentially, but maintain a semaphore as big as the number of available
1238:../src/src/tls.c ****  *   extensions is no longer an option since the release of renegotiation_info.
1239:../src/src/tls.c ****  *
1240:../src/src/tls.c ****  * How to update:
1241:../src/src/tls.c ****  *   Assign extension types that extrapolate the number of available semaphores
1242:../src/src/tls.c ****  *   to the first available index going backwards in the semaphore array.
1243:../src/src/tls.c ****  *   When adding a new extension type that don't extrapolate the number of
1244:../src/src/tls.c ****  *   available semaphores, check for a possible collision with with a
1245:../src/src/tls.c ****  *   'remapped' extension type.
1246:../src/src/tls.c ****  */
1247:../src/src/tls.c **** static WC_INLINE word16 TLSX_ToSemaphore(word16 type)
1248:../src/src/tls.c **** {
 2301                             		.loc 2 1248 1
 2302 0000 7E AA                   		push.l	r10
 2303                             	.LCFI68:
 2304 0002 71 0A FC                		add	#-4, r0, r10
 2305                             	.LCFI69:
 2306 0005 EF A0                   		mov.L	r10, r0
 2307 0007 D3 A1                   		mov.W	r1, [r10]
1249:../src/src/tls.c ****     switch (type) {
 2308                             		.loc 2 1249 5
 2309 0009 5C A5                   		movu.W	[r10], r5
 2310 000b 77 05 01 FF 00          		cmp	#0xff01, r5
 2311 0010 1E                      		bne	.L129
1250:../src/src/tls.c **** 
1251:../src/src/tls.c ****         case TLSX_RENEGOTIATION_INFO: /* 0xFF01 */
1252:../src/src/tls.c ****             return 63;
 2312                             		.loc 2 1252 20
 2313 0011 75 45 3F                		mov	#63, r5
 2314 0014 2E 15                   		bra	.L130
 2315                             	.L129:
1253:../src/src/tls.c **** 
1254:../src/src/tls.c ****         default:
1255:../src/src/tls.c ****             if (type > 62) {
 2316                             		.loc 2 1255 16
 2317 0016 5C A5                   		movu.W	[r10], r5
 2318 0018 75 55 3E                		cmp	#62, r5
 2319 001b 25 0C                   		bleu	.L131
1256:../src/src/tls.c ****                 /* This message SHOULD only happens during the adding of
1257:../src/src/tls.c ****                    new TLS extensions in which its IANA number overflows
1258:../src/src/tls.c ****                    the current semaphore's range, or if its number already
1259:../src/src/tls.c ****                    is assigned to be used by another extension.
1260:../src/src/tls.c ****                    Use this check value for the new extension and decrement
1261:../src/src/tls.c ****                    the check value by one. */
1262:../src/src/tls.c ****                 WOLFSSL_MSG("### TLSX semaphore collision or overflow detected!");
 2320                             		.loc 2 1262 17
 2321 001d FB 12 18 00 00 00       		mov.L	#.LC1, r1
 2322 0023 05 00 00 00             		bsr	_WOLFSSL_MSG
 2323                             	.L131:
1263:../src/src/tls.c ****             }
1264:../src/src/tls.c ****     }
1265:../src/src/tls.c **** 
1266:../src/src/tls.c ****     return type;
 2324                             		.loc 2 1266 12
 2325 0027 DC A5                   		mov.W	[r10], r5
 2326                             	.L130:
 2327 0029 5F 55                   		movu.W	r5, r5
1267:../src/src/tls.c **** }
 2328                             		.loc 2 1267 1
 2329 002b EF 51                   		mov.L	r5, r1
 2330 002d 3F AA 02                		rtsd	#8, r10-r10
 2331                             	.LFE61:
 2333                             		.section	.text.TLSX_New,"ax",@progbits
 2335                             	_TLSX_New:
 2336                             	.LFB62:
1268:../src/src/tls.c **** 
1269:../src/src/tls.c **** /** Checks if a specific light (tls extension) is not set in the semaphore. */
1270:../src/src/tls.c **** #define IS_OFF(semaphore, light) \
1271:../src/src/tls.c ****     (!(((semaphore)[(light) / 8] &  (byte) (0x01 << ((light) % 8)))))
1272:../src/src/tls.c **** 
1273:../src/src/tls.c **** /** Turn on a specific light (tls extension) in the semaphore. */
1274:../src/src/tls.c **** /* the semaphore marks the extensions already written to the message */
1275:../src/src/tls.c **** #define TURN_ON(semaphore, light) \
1276:../src/src/tls.c ****     ((semaphore)[(light) / 8] |= (byte) (0x01 << ((light) % 8)))
1277:../src/src/tls.c **** 
1278:../src/src/tls.c **** /** Turn off a specific light (tls extension) in the semaphore. */
1279:../src/src/tls.c **** #define TURN_OFF(semaphore, light) \
1280:../src/src/tls.c ****     ((semaphore)[(light) / 8] &= (byte) ~(0x01 << ((light) % 8)))
1281:../src/src/tls.c **** 
1282:../src/src/tls.c **** /** Creates a new extension. */
1283:../src/src/tls.c **** static TLSX* TLSX_New(TLSX_Type type, const void* data, void* heap)
1284:../src/src/tls.c **** {
 2337                             		.loc 2 1284 1
 2338 0000 7E AA                   		push.l	r10
 2339                             	.LCFI70:
 2340 0002 71 0A F0                		add	#-16, r0, r10
 2341                             	.LCFI71:
 2342 0005 EF A0                   		mov.L	r10, r0
 2343 0007 E7 A1 01                		mov.L	r1, 4[r10]
 2344 000a E7 A2 02                		mov.L	r2, 8[r10]
 2345 000d E7 A3 03                		mov.L	r3, 12[r10]
1285:../src/src/tls.c ****     TLSX* extension = (TLSX*)XMALLOC(sizeof(TLSX), heap, DYNAMIC_TYPE_TLSX);
 2346                             		.loc 2 1285 30
 2347 0010 75 41 14                		mov.L	#20, r1
 2348 0013 05 00 00 00             		bsr	_wolfSSL_Malloc
 2349 0017 E3 A1                   		mov.L	r1, [r10]
1286:../src/src/tls.c **** 
1287:../src/src/tls.c ****     (void)heap;
1288:../src/src/tls.c **** 
1289:../src/src/tls.c ****     if (extension) {
 2350                             		.loc 2 1289 8
 2351 0019 EC A5                   		mov.L	[r10], r5
 2352 001b 61 05                   		cmp	#0, r5
 2353 001d 20 1A                   		beq	.L133
1290:../src/src/tls.c ****         extension->type = type;
 2354                             		.loc 2 1290 25
 2355 001f EC A5                   		mov.L	[r10], r5
 2356 0021 ED A4 01                		mov.L	4[r10], r4
 2357 0024 E3 54                   		mov.L	r4, [r5]
1291:../src/src/tls.c ****         extension->data = (void*)data;
 2358                             		.loc 2 1291 25
 2359 0026 EC A5                   		mov.L	[r10], r5
 2360 0028 ED A4 02                		mov.L	8[r10], r4
 2361 002b A0 5C                   		mov.L	r4, 4[r5]
1292:../src/src/tls.c ****         extension->resp = 0;
 2362                             		.loc 2 1292 25
 2363 002d EC A5                   		mov.L	[r10], r5
 2364 002f 3C 5C 00                		mov.B	#0, 12[r5]
1293:../src/src/tls.c ****         extension->next = NULL;
 2365                             		.loc 2 1293 25
 2366 0032 EC A5                   		mov.L	[r10], r5
 2367 0034 3E 54 00                		mov.L	#0, 16[r5]
 2368                             	.L133:
1294:../src/src/tls.c ****     }
1295:../src/src/tls.c **** 
1296:../src/src/tls.c ****     return extension;
 2369                             		.loc 2 1296 12
 2370 0037 EC A5                   		mov.L	[r10], r5
1297:../src/src/tls.c **** }
 2371                             		.loc 2 1297 1
 2372 0039 EF 51                   		mov.L	r5, r1
 2373 003b 3F AA 05                		rtsd	#20, r10-r10
 2374                             	.LFE62:
 2376                             		.section	.text.TLSX_Push,"ax",@progbits
 2378                             	_TLSX_Push:
 2379                             	.LFB63:
1298:../src/src/tls.c **** 
1299:../src/src/tls.c **** /**
1300:../src/src/tls.c ****  * Creates a new extension and pushes it to the provided list.
1301:../src/src/tls.c ****  * Checks for duplicate extensions, keeps the newest.
1302:../src/src/tls.c ****  */
1303:../src/src/tls.c **** static int TLSX_Push(TLSX** list, TLSX_Type type, const void* data, void* heap)
1304:../src/src/tls.c **** {
 2380                             		.loc 2 1304 1
 2381 0000 7E AA                   		push.l	r10
 2382                             	.LCFI72:
 2383 0002 71 0A E8                		add	#-24, r0, r10
 2384                             	.LCFI73:
 2385 0005 EF A0                   		mov.L	r10, r0
 2386 0007 E7 A1 02                		mov.L	r1, 8[r10]
 2387 000a E7 A2 03                		mov.L	r2, 12[r10]
 2388 000d E7 A3 04                		mov.L	r3, 16[r10]
 2389 0010 E7 A4 05                		mov.L	r4, 20[r10]
1305:../src/src/tls.c ****     TLSX* extension = TLSX_New(type, data, heap);
 2390                             		.loc 2 1305 23
 2391 0013 ED A3 05                		mov.L	20[r10], r3
 2392 0016 ED A2 04                		mov.L	16[r10], r2
 2393 0019 ED A1 03                		mov.L	12[r10], r1
 2394 001c 05 00 00 00             		bsr	_TLSX_New
 2395 0020 E3 A1                   		mov.L	r1, [r10]
1306:../src/src/tls.c **** 
1307:../src/src/tls.c ****     if (extension == NULL)
 2396                             		.loc 2 1307 8
 2397 0022 EC A5                   		mov.L	[r10], r5
 2398 0024 61 05                   		cmp	#0, r5
 2399 0026 1E                      		bne	.L136
1308:../src/src/tls.c ****         return MEMORY_E;
 2400                             		.loc 2 1308 16
 2401 0027 FB 56 83                		mov.L	#-125, r5
 2402 002a 2E 57                   		bra	.L137
 2403                             	.L136:
1309:../src/src/tls.c **** 
1310:../src/src/tls.c ****     /* pushes the new extension on the list. */
1311:../src/src/tls.c ****     extension->next = *list;
 2404                             		.loc 2 1311 23
 2405 002c ED A5 02                		mov.L	8[r10], r5
 2406 002f EC 54                   		mov.L	[r5], r4
 2407                             		.loc 2 1311 21
 2408 0031 EC A5                   		mov.L	[r10], r5
 2409 0033 A1 54                   		mov.L	r4, 16[r5]
1312:../src/src/tls.c ****     *list = extension;
 2410                             		.loc 2 1312 11
 2411 0035 ED A5 02                		mov.L	8[r10], r5
 2412 0038 EC A4                   		mov.L	[r10], r4
 2413 003a E3 54                   		mov.L	r4, [r5]
 2414                             	.L140:
1313:../src/src/tls.c **** 
1314:../src/src/tls.c ****     /* remove duplicate extensions, there should be only one of each type. */
1315:../src/src/tls.c ****     do {
1316:../src/src/tls.c ****         if (extension->next && extension->next->type == type) {
 2415                             		.loc 2 1316 22
 2416 003c EC A5                   		mov.L	[r10], r5
 2417 003e A9 55                   		mov.L	16[r5], r5
 2418                             		.loc 2 1316 12
 2419 0040 61 05                   		cmp	#0, r5
 2420 0042 20 31                   		beq	.L138
 2421                             		.loc 2 1316 41 discriminator 1
 2422 0044 EC A5                   		mov.L	[r10], r5
 2423 0046 A9 55                   		mov.L	16[r5], r5
 2424                             		.loc 2 1316 47 discriminator 1
 2425 0048 EC 55                   		mov.L	[r5], r5
 2426                             		.loc 2 1316 29 discriminator 1
 2427 004a ED A4 03                		mov.L	12[r10], r4
 2428 004d 47 54                   		cmp	r5, r4
 2429 004f 21 24                   		bne	.L138
 2430                             	.LBB6:
1317:../src/src/tls.c ****             TLSX *next = extension->next;
 2431                             		.loc 2 1317 19
 2432 0051 EC A5                   		mov.L	[r10], r5
 2433 0053 A9 55                   		mov.L	16[r5], r5
 2434 0055 E7 A5 01                		mov.L	r5, 4[r10]
1318:../src/src/tls.c **** 
1319:../src/src/tls.c ****             extension->next = next->next;
 2435                             		.loc 2 1319 35
 2436 0058 ED A5 01                		mov.L	4[r10], r5
 2437 005b A9 54                   		mov.L	16[r5], r4
 2438                             		.loc 2 1319 29
 2439 005d EC A5                   		mov.L	[r10], r5
 2440 005f A1 54                   		mov.L	r4, 16[r5]
1320:../src/src/tls.c ****             next->next = NULL;
 2441                             		.loc 2 1320 24
 2442 0061 ED A5 01                		mov.L	4[r10], r5
 2443 0064 3E 54 00                		mov.L	#0, 16[r5]
1321:../src/src/tls.c **** 
1322:../src/src/tls.c ****             TLSX_FreeAll(next, heap);
 2444                             		.loc 2 1322 13
 2445 0067 ED A2 05                		mov.L	20[r10], r2
 2446 006a ED A1 01                		mov.L	4[r10], r1
 2447 006d 05 00 00 00             		bsr	_TLSX_FreeAll
1323:../src/src/tls.c **** 
1324:../src/src/tls.c ****             /* there is no way to occur more than
1325:../src/src/tls.c ****              * two extensions of the same type.
1326:../src/src/tls.c ****              */
1327:../src/src/tls.c ****             break;
 2448                             		.loc 2 1327 13
 2449 0071 2E 0E                   		bra	.L139
 2450                             	.L138:
 2451                             	.LBE6:
1328:../src/src/tls.c ****         }
1329:../src/src/tls.c ****     } while ((extension = extension->next));
 2452                             		.loc 2 1329 25
 2453 0073 EC A5                   		mov.L	[r10], r5
 2454 0075 A9 55                   		mov.L	16[r5], r5
 2455 0077 E3 A5                   		mov.L	r5, [r10]
 2456                             		.loc 2 1329 5
 2457 0079 EC A5                   		mov.L	[r10], r5
 2458 007b 61 05                   		cmp	#0, r5
 2459 007d 21 BF                   		bne	.L140
 2460                             	.L139:
1330:../src/src/tls.c **** 
1331:../src/src/tls.c ****     return 0;
 2461                             		.loc 2 1331 12
 2462 007f 66 05                   		mov.L	#0, r5
 2463                             	.L137:
1332:../src/src/tls.c **** }
 2464                             		.loc 2 1332 1
 2465 0081 EF 51                   		mov.L	r5, r1
 2466 0083 3F AA 07                		rtsd	#28, r10-r10
 2467                             	.LFE63:
 2469                             		.section	.text.TLSX_CheckUnsupportedExtension,"ax",@progbits
 2470                             		.global	_TLSX_CheckUnsupportedExtension
 2472                             	_TLSX_CheckUnsupportedExtension:
 2473                             	.LFB64:
1333:../src/src/tls.c **** 
1334:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
1335:../src/src/tls.c **** 
1336:../src/src/tls.c **** /**
1337:../src/src/tls.c ****  * Creates a new extension and prepend it to the provided list.
1338:../src/src/tls.c ****  * Checks for duplicate extensions, keeps the newest.
1339:../src/src/tls.c ****  */
1340:../src/src/tls.c **** static int TLSX_Prepend(TLSX** list, TLSX_Type type, void* data, void* heap)
1341:../src/src/tls.c **** {
1342:../src/src/tls.c ****     TLSX* extension = TLSX_New(type, data, heap);
1343:../src/src/tls.c ****     TLSX* curr = *list;
1344:../src/src/tls.c **** 
1345:../src/src/tls.c ****     if (extension == NULL)
1346:../src/src/tls.c ****         return MEMORY_E;
1347:../src/src/tls.c **** 
1348:../src/src/tls.c ****     /* remove duplicate extensions, there should be only one of each type. */
1349:../src/src/tls.c ****     while (curr && curr->next) {
1350:../src/src/tls.c ****         if (curr->next->type == type) {
1351:../src/src/tls.c ****             TLSX *next = curr->next;
1352:../src/src/tls.c **** 
1353:../src/src/tls.c ****             curr->next = next->next;
1354:../src/src/tls.c ****             next->next = NULL;
1355:../src/src/tls.c **** 
1356:../src/src/tls.c ****             TLSX_FreeAll(next, heap);
1357:../src/src/tls.c ****         }
1358:../src/src/tls.c ****         curr = curr->next;
1359:../src/src/tls.c ****     }
1360:../src/src/tls.c **** 
1361:../src/src/tls.c ****     if (curr)
1362:../src/src/tls.c ****         curr->next = extension;
1363:../src/src/tls.c ****     else
1364:../src/src/tls.c ****         *list = extension;
1365:../src/src/tls.c **** 
1366:../src/src/tls.c ****     return 0;
1367:../src/src/tls.c **** }
1368:../src/src/tls.c **** 
1369:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 */
1370:../src/src/tls.c **** 
1371:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
1372:../src/src/tls.c **** 
1373:../src/src/tls.c **** int TLSX_CheckUnsupportedExtension(WOLFSSL* ssl, TLSX_Type type);
1374:../src/src/tls.c **** 
1375:../src/src/tls.c **** int TLSX_CheckUnsupportedExtension(WOLFSSL* ssl, TLSX_Type type)
1376:../src/src/tls.c **** {
 2474                             		.loc 2 1376 1
 2475 0000 7E AA                   		push.l	r10
 2476                             	.LCFI74:
 2477 0002 71 0A F4                		add	#-12, r0, r10
 2478                             	.LCFI75:
 2479 0005 EF A0                   		mov.L	r10, r0
 2480 0007 E7 A1 01                		mov.L	r1, 4[r10]
 2481 000a E7 A2 02                		mov.L	r2, 8[r10]
1377:../src/src/tls.c ****     TLSX *extension = TLSX_Find(ssl->extensions, type);
 2482                             		.loc 2 1377 23
 2483 000d ED A5 01                		mov.L	4[r10], r5
 2484 0010 ED 55 BF                		mov.L	764[r5], r5
 2485 0013 ED A2 02                		mov.L	8[r10], r2
 2486 0016 EF 51                   		mov.L	r5, r1
 2487 0018 05 00 00 00             		bsr	_TLSX_Find
 2488 001c E3 A1                   		mov.L	r1, [r10]
1378:../src/src/tls.c **** 
1379:../src/src/tls.c ****     if (!extension)
 2489                             		.loc 2 1379 8
 2490 001e EC A5                   		mov.L	[r10], r5
 2491 0020 61 05                   		cmp	#0, r5
 2492 0022 21 15                   		bne	.L142
1380:../src/src/tls.c ****         extension = TLSX_Find(ssl->ctx->extensions, type);
 2493                             		.loc 2 1380 34
 2494 0024 ED A5 01                		mov.L	4[r10], r5
 2495 0027 EC 55                   		mov.L	[r5], r5
 2496                             		.loc 2 1380 21
 2497 0029 ED 55 49                		mov.L	292[r5], r5
 2498 002c ED A2 02                		mov.L	8[r10], r2
 2499 002f EF 51                   		mov.L	r5, r1
 2500 0031 05 00 00 00             		bsr	_TLSX_Find
 2501 0035 E3 A1                   		mov.L	r1, [r10]
 2502                             	.L142:
1381:../src/src/tls.c **** 
1382:../src/src/tls.c ****     return extension == NULL;
 2503                             		.loc 2 1382 22
 2504 0037 EC A5                   		mov.L	[r10], r5
 2505 0039 61 05                   		cmp	#0, r5
 2506 003b FC DB 50                		sceq.L	r5
 2507 003e 5B 55                   		movu.B	r5, r5
1383:../src/src/tls.c **** }
 2508                             		.loc 2 1383 1
 2509 0040 EF 51                   		mov.L	r5, r1
 2510 0042 3F AA 04                		rtsd	#16, r10-r10
 2511                             	.LFE64:
 2513                             		.section	.text.TLSX_HandleUnsupportedExtension,"ax",@progbits
 2514                             		.global	_TLSX_HandleUnsupportedExtension
 2516                             	_TLSX_HandleUnsupportedExtension:
 2517                             	.LFB65:
1384:../src/src/tls.c **** 
1385:../src/src/tls.c **** int TLSX_HandleUnsupportedExtension(WOLFSSL* ssl);
1386:../src/src/tls.c **** 
1387:../src/src/tls.c **** int TLSX_HandleUnsupportedExtension(WOLFSSL* ssl)
1388:../src/src/tls.c **** {
 2518                             		.loc 2 1388 1
 2519 0000 7E AA                   		push.l	r10
 2520                             	.LCFI76:
 2521 0002 71 0A FC                		add	#-4, r0, r10
 2522                             	.LCFI77:
 2523 0005 EF A0                   		mov.L	r10, r0
 2524 0007 E3 A1                   		mov.L	r1, [r10]
1389:../src/src/tls.c ****     SendAlert(ssl, alert_fatal, unsupported_extension);
 2525                             		.loc 2 1389 5
 2526 0009 75 43 6E                		mov.L	#0x6e, r3
 2527 000c 66 22                   		mov.L	#2, r2
 2528 000e EC A1                   		mov.L	[r10], r1
 2529 0010 05 00 00 00             		bsr	_SendAlert
1390:../src/src/tls.c ****     return UNSUPPORTED_EXTENSION;
 2530                             		.loc 2 1390 12
 2531 0014 FB 5A 53 FE             		mov.L	#-429, r5
1391:../src/src/tls.c **** }
 2532                             		.loc 2 1391 1
 2533 0018 EF 51                   		mov.L	r5, r1
 2534 001a 3F AA 02                		rtsd	#8, r10-r10
 2535                             	.LFE65:
 2537                             		.section	.text.TLSX_SetResponse,"ax",@progbits
 2538                             		.global	_TLSX_SetResponse
 2540                             	_TLSX_SetResponse:
 2541                             	.LFB66:
1392:../src/src/tls.c **** 
1393:../src/src/tls.c **** #else
1394:../src/src/tls.c **** 
1395:../src/src/tls.c **** #define TLSX_CheckUnsupportedExtension(ssl, type) 0
1396:../src/src/tls.c **** #define TLSX_HandleUnsupportedExtension(ssl) 0
1397:../src/src/tls.c **** 
1398:../src/src/tls.c **** #endif
1399:../src/src/tls.c **** 
1400:../src/src/tls.c **** /** Mark an extension to be sent back to the client. */
1401:../src/src/tls.c **** void TLSX_SetResponse(WOLFSSL* ssl, TLSX_Type type);
1402:../src/src/tls.c **** 
1403:../src/src/tls.c **** void TLSX_SetResponse(WOLFSSL* ssl, TLSX_Type type)
1404:../src/src/tls.c **** {
 2542                             		.loc 2 1404 1
 2543 0000 7E AA                   		push.l	r10
 2544                             	.LCFI78:
 2545 0002 71 0A F4                		add	#-12, r0, r10
 2546                             	.LCFI79:
 2547 0005 EF A0                   		mov.L	r10, r0
 2548 0007 E7 A1 01                		mov.L	r1, 4[r10]
 2549 000a E7 A2 02                		mov.L	r2, 8[r10]
1405:../src/src/tls.c ****     TLSX *extension = TLSX_Find(ssl->extensions, type);
 2550                             		.loc 2 1405 23
 2551 000d ED A5 01                		mov.L	4[r10], r5
 2552 0010 ED 55 BF                		mov.L	764[r5], r5
 2553 0013 ED A2 02                		mov.L	8[r10], r2
 2554 0016 EF 51                   		mov.L	r5, r1
 2555 0018 05 00 00 00             		bsr	_TLSX_Find
 2556 001c E3 A1                   		mov.L	r1, [r10]
1406:../src/src/tls.c **** 
1407:../src/src/tls.c ****     if (extension)
 2557                             		.loc 2 1407 8
 2558 001e EC A5                   		mov.L	[r10], r5
 2559 0020 61 05                   		cmp	#0, r5
 2560 0022 16                      		beq	.L148
1408:../src/src/tls.c ****         extension->resp = 1;
 2561                             		.loc 2 1408 25
 2562 0023 EC A5                   		mov.L	[r10], r5
 2563 0025 3C 5C 01                		mov.B	#1, 12[r5]
 2564                             	.L148:
1409:../src/src/tls.c **** }
 2565                             		.loc 2 1409 1
 2566 0028 03                      		nop
 2567 0029 3F AA 04                		rtsd	#16, r10-r10
 2568                             	.LFE66:
 2570                             		.section	.text.TLSX_CSR_Free,"ax",@progbits
 2572                             	_TLSX_CSR_Free:
 2573                             	.LFB67:
1410:../src/src/tls.c **** 
1411:../src/src/tls.c **** /******************************************************************************/
1412:../src/src/tls.c **** /* Application-Layer Protocol Negotiation                                     */
1413:../src/src/tls.c **** /******************************************************************************/
1414:../src/src/tls.c **** 
1415:../src/src/tls.c **** #ifdef HAVE_ALPN
1416:../src/src/tls.c **** /** Creates a new ALPN object, providing protocol name to use. */
1417:../src/src/tls.c **** static ALPN* TLSX_ALPN_New(char *protocol_name, word16 protocol_nameSz,
1418:../src/src/tls.c ****                                                                      void* heap)
1419:../src/src/tls.c **** {
1420:../src/src/tls.c ****     ALPN *alpn;
1421:../src/src/tls.c **** 
1422:../src/src/tls.c ****     WOLFSSL_ENTER("TLSX_ALPN_New");
1423:../src/src/tls.c **** 
1424:../src/src/tls.c ****     if (protocol_name == NULL ||
1425:../src/src/tls.c ****         protocol_nameSz > WOLFSSL_MAX_ALPN_PROTO_NAME_LEN) {
1426:../src/src/tls.c ****         WOLFSSL_MSG("Invalid arguments");
1427:../src/src/tls.c ****         return NULL;
1428:../src/src/tls.c ****     }
1429:../src/src/tls.c **** 
1430:../src/src/tls.c ****     alpn = (ALPN*)XMALLOC(sizeof(ALPN), heap, DYNAMIC_TYPE_TLSX);
1431:../src/src/tls.c ****     if (alpn == NULL) {
1432:../src/src/tls.c ****         WOLFSSL_MSG("Memory failure");
1433:../src/src/tls.c ****         return NULL;
1434:../src/src/tls.c ****     }
1435:../src/src/tls.c **** 
1436:../src/src/tls.c ****     alpn->next = NULL;
1437:../src/src/tls.c ****     alpn->negotiated = 0;
1438:../src/src/tls.c ****     alpn->options = 0;
1439:../src/src/tls.c **** 
1440:../src/src/tls.c ****     alpn->protocol_name = (char*)XMALLOC(protocol_nameSz + 1,
1441:../src/src/tls.c ****                                          heap, DYNAMIC_TYPE_TLSX);
1442:../src/src/tls.c ****     if (alpn->protocol_name == NULL) {
1443:../src/src/tls.c ****         WOLFSSL_MSG("Memory failure");
1444:../src/src/tls.c ****         XFREE(alpn, heap, DYNAMIC_TYPE_TLSX);
1445:../src/src/tls.c ****         return NULL;
1446:../src/src/tls.c ****     }
1447:../src/src/tls.c **** 
1448:../src/src/tls.c ****     XMEMCPY(alpn->protocol_name, protocol_name, protocol_nameSz);
1449:../src/src/tls.c ****     alpn->protocol_name[protocol_nameSz] = 0;
1450:../src/src/tls.c **** 
1451:../src/src/tls.c ****     (void)heap;
1452:../src/src/tls.c **** 
1453:../src/src/tls.c ****     return alpn;
1454:../src/src/tls.c **** }
1455:../src/src/tls.c **** 
1456:../src/src/tls.c **** /** Releases an ALPN object. */
1457:../src/src/tls.c **** static void TLSX_ALPN_Free(ALPN *alpn, void* heap)
1458:../src/src/tls.c **** {
1459:../src/src/tls.c ****     (void)heap;
1460:../src/src/tls.c **** 
1461:../src/src/tls.c ****     if (alpn == NULL)
1462:../src/src/tls.c ****         return;
1463:../src/src/tls.c **** 
1464:../src/src/tls.c ****     XFREE(alpn->protocol_name, heap, DYNAMIC_TYPE_TLSX);
1465:../src/src/tls.c ****     XFREE(alpn, heap, DYNAMIC_TYPE_TLSX);
1466:../src/src/tls.c **** }
1467:../src/src/tls.c **** 
1468:../src/src/tls.c **** /** Releases all ALPN objects in the provided list. */
1469:../src/src/tls.c **** static void TLSX_ALPN_FreeAll(ALPN *list, void* heap)
1470:../src/src/tls.c **** {
1471:../src/src/tls.c ****     ALPN* alpn;
1472:../src/src/tls.c **** 
1473:../src/src/tls.c ****     while ((alpn = list)) {
1474:../src/src/tls.c ****         list = alpn->next;
1475:../src/src/tls.c ****         TLSX_ALPN_Free(alpn, heap);
1476:../src/src/tls.c ****     }
1477:../src/src/tls.c **** }
1478:../src/src/tls.c **** 
1479:../src/src/tls.c **** /** Tells the buffered size of the ALPN objects in a list. */
1480:../src/src/tls.c **** static word16 TLSX_ALPN_GetSize(ALPN *list)
1481:../src/src/tls.c **** {
1482:../src/src/tls.c ****     ALPN* alpn;
1483:../src/src/tls.c ****     word16 length = OPAQUE16_LEN; /* list length */
1484:../src/src/tls.c **** 
1485:../src/src/tls.c ****     while ((alpn = list)) {
1486:../src/src/tls.c ****         list = alpn->next;
1487:../src/src/tls.c **** 
1488:../src/src/tls.c ****         length++; /* protocol name length is on one byte */
1489:../src/src/tls.c ****         length += (word16)XSTRLEN(alpn->protocol_name);
1490:../src/src/tls.c ****     }
1491:../src/src/tls.c **** 
1492:../src/src/tls.c ****     return length;
1493:../src/src/tls.c **** }
1494:../src/src/tls.c **** 
1495:../src/src/tls.c **** /** Writes the ALPN objects of a list in a buffer. */
1496:../src/src/tls.c **** static word16 TLSX_ALPN_Write(ALPN *list, byte *output)
1497:../src/src/tls.c **** {
1498:../src/src/tls.c ****     ALPN* alpn;
1499:../src/src/tls.c ****     word16 length = 0;
1500:../src/src/tls.c ****     word16 offset = OPAQUE16_LEN; /* list length offset */
1501:../src/src/tls.c **** 
1502:../src/src/tls.c ****     while ((alpn = list)) {
1503:../src/src/tls.c ****         list = alpn->next;
1504:../src/src/tls.c **** 
1505:../src/src/tls.c ****         length = (word16)XSTRLEN(alpn->protocol_name);
1506:../src/src/tls.c **** 
1507:../src/src/tls.c ****         /* protocol name length */
1508:../src/src/tls.c ****         output[offset++] = (byte)length;
1509:../src/src/tls.c **** 
1510:../src/src/tls.c ****         /* protocol name value */
1511:../src/src/tls.c ****         XMEMCPY(output + offset, alpn->protocol_name, length);
1512:../src/src/tls.c **** 
1513:../src/src/tls.c ****         offset += length;
1514:../src/src/tls.c ****     }
1515:../src/src/tls.c **** 
1516:../src/src/tls.c ****     /* writing list length */
1517:../src/src/tls.c ****     c16toa(offset - OPAQUE16_LEN, output);
1518:../src/src/tls.c **** 
1519:../src/src/tls.c ****     return offset;
1520:../src/src/tls.c **** }
1521:../src/src/tls.c **** 
1522:../src/src/tls.c **** /** Finds a protocol name in the provided ALPN list */
1523:../src/src/tls.c **** static ALPN* TLSX_ALPN_Find(ALPN *list, char *protocol_name, word16 size)
1524:../src/src/tls.c **** {
1525:../src/src/tls.c ****     ALPN *alpn;
1526:../src/src/tls.c **** 
1527:../src/src/tls.c ****     if (list == NULL || protocol_name == NULL)
1528:../src/src/tls.c ****         return NULL;
1529:../src/src/tls.c **** 
1530:../src/src/tls.c ****     alpn = list;
1531:../src/src/tls.c ****     while (alpn != NULL && (
1532:../src/src/tls.c ****            (word16)XSTRLEN(alpn->protocol_name) != size ||
1533:../src/src/tls.c ****            XSTRNCMP(alpn->protocol_name, protocol_name, size)))
1534:../src/src/tls.c ****         alpn = alpn->next;
1535:../src/src/tls.c **** 
1536:../src/src/tls.c ****     return alpn;
1537:../src/src/tls.c **** }
1538:../src/src/tls.c **** 
1539:../src/src/tls.c **** /** Set the ALPN matching client and server requirements */
1540:../src/src/tls.c **** static int TLSX_SetALPN(TLSX** extensions, const void* data, word16 size,
1541:../src/src/tls.c ****                                                                      void* heap)
1542:../src/src/tls.c **** {
1543:../src/src/tls.c ****     ALPN *alpn;
1544:../src/src/tls.c ****     int  ret;
1545:../src/src/tls.c **** 
1546:../src/src/tls.c ****     if (extensions == NULL || data == NULL)
1547:../src/src/tls.c ****         return BAD_FUNC_ARG;
1548:../src/src/tls.c **** 
1549:../src/src/tls.c ****     alpn = TLSX_ALPN_New((char *)data, size, heap);
1550:../src/src/tls.c ****     if (alpn == NULL) {
1551:../src/src/tls.c ****         WOLFSSL_MSG("Memory failure");
1552:../src/src/tls.c ****         return MEMORY_E;
1553:../src/src/tls.c ****     }
1554:../src/src/tls.c **** 
1555:../src/src/tls.c ****     alpn->negotiated = 1;
1556:../src/src/tls.c **** 
1557:../src/src/tls.c ****     ret = TLSX_Push(extensions, TLSX_APPLICATION_LAYER_PROTOCOL, (void*)alpn,
1558:../src/src/tls.c ****                                                                           heap);
1559:../src/src/tls.c ****     if (ret != 0) {
1560:../src/src/tls.c ****         TLSX_ALPN_Free(alpn, heap);
1561:../src/src/tls.c ****         return ret;
1562:../src/src/tls.c ****     }
1563:../src/src/tls.c **** 
1564:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
1565:../src/src/tls.c **** }
1566:../src/src/tls.c **** 
1567:../src/src/tls.c **** /** Parses a buffer of ALPN extensions and set the first one matching
1568:../src/src/tls.c ****  * client and server requirements */
1569:../src/src/tls.c **** static int TLSX_ALPN_ParseAndSet(WOLFSSL *ssl, const byte *input, word16 length,
1570:../src/src/tls.c ****                                  byte isRequest)
1571:../src/src/tls.c **** {
1572:../src/src/tls.c ****     word16  size = 0, offset = 0, idx = 0;
1573:../src/src/tls.c ****     int     r = BUFFER_ERROR;
1574:../src/src/tls.c ****     byte    match = 0;
1575:../src/src/tls.c ****     TLSX    *extension;
1576:../src/src/tls.c ****     ALPN    *alpn = NULL, *list;
1577:../src/src/tls.c **** 
1578:../src/src/tls.c ****     if (OPAQUE16_LEN > length)
1579:../src/src/tls.c ****         return BUFFER_ERROR;
1580:../src/src/tls.c **** 
1581:../src/src/tls.c ****     ato16(input, &size);
1582:../src/src/tls.c ****     offset += OPAQUE16_LEN;
1583:../src/src/tls.c **** 
1584:../src/src/tls.c ****     if (size == 0)
1585:../src/src/tls.c ****         return BUFFER_ERROR;
1586:../src/src/tls.c **** 
1587:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_APPLICATION_LAYER_PROTOCOL);
1588:../src/src/tls.c ****     if (extension == NULL)
1589:../src/src/tls.c ****         extension = TLSX_Find(ssl->ctx->extensions,
1590:../src/src/tls.c ****                               TLSX_APPLICATION_LAYER_PROTOCOL);
1591:../src/src/tls.c **** 
1592:../src/src/tls.c **** #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)
1593:../src/src/tls.c ****     if (ssl->alpnSelect != NULL && ssl->options.side == WOLFSSL_SERVER_END) {
1594:../src/src/tls.c ****         const byte* out;
1595:../src/src/tls.c ****         unsigned char outLen;
1596:../src/src/tls.c **** 
1597:../src/src/tls.c ****         if (ssl->alpnSelect(ssl, &out, &outLen, input + offset, size,
1598:../src/src/tls.c ****                             ssl->alpnSelectArg) == 0) {
1599:../src/src/tls.c ****             WOLFSSL_MSG("ALPN protocol match");
1600:../src/src/tls.c ****             /* clears out all current ALPN extensions set */
1601:../src/src/tls.c ****             TLSX_Remove(&ssl->extensions, TLSX_APPLICATION_LAYER_PROTOCOL, ssl->heap);
1602:../src/src/tls.c ****             extension = NULL;
1603:../src/src/tls.c ****             if (TLSX_UseALPN(&ssl->extensions, (char*)out, outLen, 0, ssl->heap)
1604:../src/src/tls.c ****                                                            == WOLFSSL_SUCCESS) {
1605:../src/src/tls.c ****                 extension = TLSX_Find(ssl->extensions,
1606:../src/src/tls.c ****                                       TLSX_APPLICATION_LAYER_PROTOCOL);
1607:../src/src/tls.c ****             }
1608:../src/src/tls.c ****         }
1609:../src/src/tls.c ****     }
1610:../src/src/tls.c **** #endif
1611:../src/src/tls.c **** 
1612:../src/src/tls.c ****     if (extension == NULL || extension->data == NULL) {
1613:../src/src/tls.c ****         return isRequest ? 0
1614:../src/src/tls.c ****                          : TLSX_HandleUnsupportedExtension(ssl);
1615:../src/src/tls.c ****     }
1616:../src/src/tls.c **** 
1617:../src/src/tls.c ****     /* validating alpn list length */
1618:../src/src/tls.c ****     if (length != OPAQUE16_LEN + size)
1619:../src/src/tls.c ****         return BUFFER_ERROR;
1620:../src/src/tls.c **** 
1621:../src/src/tls.c ****     list = (ALPN*)extension->data;
1622:../src/src/tls.c **** 
1623:../src/src/tls.c ****     /* keep the list sent by client */
1624:../src/src/tls.c ****     if (isRequest) {
1625:../src/src/tls.c ****         if (ssl->alpn_client_list != NULL)
1626:../src/src/tls.c ****             XFREE(ssl->alpn_client_list, ssl->heap, DYNAMIC_TYPE_ALPN);
1627:../src/src/tls.c **** 
1628:../src/src/tls.c ****         ssl->alpn_client_list = (char *)XMALLOC(size, ssl->heap,
1629:../src/src/tls.c ****                                                 DYNAMIC_TYPE_ALPN);
1630:../src/src/tls.c ****         if (ssl->alpn_client_list == NULL)
1631:../src/src/tls.c ****             return MEMORY_ERROR;
1632:../src/src/tls.c ****     }
1633:../src/src/tls.c **** 
1634:../src/src/tls.c ****     for (size = 0; offset < length; offset += size) {
1635:../src/src/tls.c **** 
1636:../src/src/tls.c ****         size = input[offset++];
1637:../src/src/tls.c ****         if (offset + size > length || size == 0)
1638:../src/src/tls.c ****             return BUFFER_ERROR;
1639:../src/src/tls.c **** 
1640:../src/src/tls.c ****         if (isRequest) {
1641:../src/src/tls.c ****             XMEMCPY(ssl->alpn_client_list+idx, (char*)input + offset, size);
1642:../src/src/tls.c ****             idx += size;
1643:../src/src/tls.c ****             ssl->alpn_client_list[idx++] = ',';
1644:../src/src/tls.c ****         }
1645:../src/src/tls.c **** 
1646:../src/src/tls.c ****         if (!match) {
1647:../src/src/tls.c ****             alpn = TLSX_ALPN_Find(list, (char*)input + offset, size);
1648:../src/src/tls.c ****             if (alpn != NULL) {
1649:../src/src/tls.c ****                 WOLFSSL_MSG("ALPN protocol match");
1650:../src/src/tls.c ****                 match = 1;
1651:../src/src/tls.c **** 
1652:../src/src/tls.c ****                 /* skip reading other values if not required */
1653:../src/src/tls.c ****                 if (!isRequest)
1654:../src/src/tls.c ****                     break;
1655:../src/src/tls.c ****             }
1656:../src/src/tls.c ****         }
1657:../src/src/tls.c ****     }
1658:../src/src/tls.c **** 
1659:../src/src/tls.c ****     if (isRequest)
1660:../src/src/tls.c ****         ssl->alpn_client_list[idx-1] = 0;
1661:../src/src/tls.c **** 
1662:../src/src/tls.c ****     if (!match) {
1663:../src/src/tls.c ****         WOLFSSL_MSG("No ALPN protocol match");
1664:../src/src/tls.c **** 
1665:../src/src/tls.c ****         /* do nothing if no protocol match between client and server and option
1666:../src/src/tls.c ****          is set to continue (like OpenSSL) */
1667:../src/src/tls.c ****         if (list->options & WOLFSSL_ALPN_CONTINUE_ON_MISMATCH) {
1668:../src/src/tls.c ****             WOLFSSL_MSG("Continue on mismatch");
1669:../src/src/tls.c ****             return 0;
1670:../src/src/tls.c ****         }
1671:../src/src/tls.c **** 
1672:../src/src/tls.c ****         SendAlert(ssl, alert_fatal, no_application_protocol);
1673:../src/src/tls.c ****         return UNKNOWN_ALPN_PROTOCOL_NAME_E;
1674:../src/src/tls.c ****     }
1675:../src/src/tls.c **** 
1676:../src/src/tls.c ****     /* set the matching negotiated protocol */
1677:../src/src/tls.c ****     r = TLSX_SetALPN(&ssl->extensions,
1678:../src/src/tls.c ****                      alpn->protocol_name,
1679:../src/src/tls.c ****                      (word16)XSTRLEN(alpn->protocol_name),
1680:../src/src/tls.c ****                      ssl->heap);
1681:../src/src/tls.c ****     if (r != WOLFSSL_SUCCESS) {
1682:../src/src/tls.c ****         WOLFSSL_MSG("TLSX_UseALPN failed");
1683:../src/src/tls.c ****         return BUFFER_ERROR;
1684:../src/src/tls.c ****     }
1685:../src/src/tls.c **** 
1686:../src/src/tls.c ****     /* reply to ALPN extension sent from client */
1687:../src/src/tls.c ****     if (isRequest) {
1688:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
1689:../src/src/tls.c ****         TLSX_SetResponse(ssl, TLSX_APPLICATION_LAYER_PROTOCOL);
1690:../src/src/tls.c **** #endif
1691:../src/src/tls.c ****     }
1692:../src/src/tls.c **** 
1693:../src/src/tls.c ****     return 0;
1694:../src/src/tls.c **** }
1695:../src/src/tls.c **** 
1696:../src/src/tls.c **** /** Add a protocol name to the list of accepted usable ones */
1697:../src/src/tls.c **** int TLSX_UseALPN(TLSX** extensions, const void* data, word16 size, byte options,
1698:../src/src/tls.c ****                                                                      void* heap)
1699:../src/src/tls.c **** {
1700:../src/src/tls.c ****     ALPN *alpn;
1701:../src/src/tls.c ****     TLSX *extension;
1702:../src/src/tls.c ****     int  ret;
1703:../src/src/tls.c **** 
1704:../src/src/tls.c ****     if (extensions == NULL || data == NULL)
1705:../src/src/tls.c ****         return BAD_FUNC_ARG;
1706:../src/src/tls.c **** 
1707:../src/src/tls.c ****     alpn = TLSX_ALPN_New((char *)data, size, heap);
1708:../src/src/tls.c ****     if (alpn == NULL) {
1709:../src/src/tls.c ****         WOLFSSL_MSG("Memory failure");
1710:../src/src/tls.c ****         return MEMORY_E;
1711:../src/src/tls.c ****     }
1712:../src/src/tls.c **** 
1713:../src/src/tls.c ****     /* Set Options of ALPN */
1714:../src/src/tls.c ****     alpn->options = options;
1715:../src/src/tls.c **** 
1716:../src/src/tls.c ****     extension = TLSX_Find(*extensions, TLSX_APPLICATION_LAYER_PROTOCOL);
1717:../src/src/tls.c ****     if (extension == NULL) {
1718:../src/src/tls.c ****         ret = TLSX_Push(extensions, TLSX_APPLICATION_LAYER_PROTOCOL,
1719:../src/src/tls.c ****                                                              (void*)alpn, heap);
1720:../src/src/tls.c ****         if (ret != 0) {
1721:../src/src/tls.c ****             TLSX_ALPN_Free(alpn, heap);
1722:../src/src/tls.c ****             return ret;
1723:../src/src/tls.c ****         }
1724:../src/src/tls.c ****     }
1725:../src/src/tls.c ****     else {
1726:../src/src/tls.c ****         /* push new ALPN object to extension data. */
1727:../src/src/tls.c ****         alpn->next = (ALPN*)extension->data;
1728:../src/src/tls.c ****         extension->data = (void*)alpn;
1729:../src/src/tls.c ****     }
1730:../src/src/tls.c **** 
1731:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
1732:../src/src/tls.c **** }
1733:../src/src/tls.c **** 
1734:../src/src/tls.c **** /** Get the protocol name set by the server */
1735:../src/src/tls.c **** int TLSX_ALPN_GetRequest(TLSX* extensions, void** data, word16 *dataSz)
1736:../src/src/tls.c **** {
1737:../src/src/tls.c ****     TLSX *extension;
1738:../src/src/tls.c ****     ALPN *alpn;
1739:../src/src/tls.c **** 
1740:../src/src/tls.c ****     if (extensions == NULL || data == NULL || dataSz == NULL)
1741:../src/src/tls.c ****         return BAD_FUNC_ARG;
1742:../src/src/tls.c **** 
1743:../src/src/tls.c ****     extension = TLSX_Find(extensions, TLSX_APPLICATION_LAYER_PROTOCOL);
1744:../src/src/tls.c ****     if (extension == NULL) {
1745:../src/src/tls.c ****         WOLFSSL_MSG("TLS extension not found");
1746:../src/src/tls.c ****         return WOLFSSL_ALPN_NOT_FOUND;
1747:../src/src/tls.c ****     }
1748:../src/src/tls.c **** 
1749:../src/src/tls.c ****     alpn = (ALPN *)extension->data;
1750:../src/src/tls.c ****     if (alpn == NULL) {
1751:../src/src/tls.c ****         WOLFSSL_MSG("ALPN extension not found");
1752:../src/src/tls.c ****         *data = NULL;
1753:../src/src/tls.c ****         *dataSz = 0;
1754:../src/src/tls.c ****         return WOLFSSL_FATAL_ERROR;
1755:../src/src/tls.c ****     }
1756:../src/src/tls.c **** 
1757:../src/src/tls.c ****     if (alpn->negotiated != 1) {
1758:../src/src/tls.c **** 
1759:../src/src/tls.c ****         /* consider as an error */
1760:../src/src/tls.c ****         if (alpn->options & WOLFSSL_ALPN_FAILED_ON_MISMATCH) {
1761:../src/src/tls.c ****             WOLFSSL_MSG("No protocol match with peer -> Failed");
1762:../src/src/tls.c ****             return WOLFSSL_FATAL_ERROR;
1763:../src/src/tls.c ****         }
1764:../src/src/tls.c **** 
1765:../src/src/tls.c ****         /* continue without negotiated protocol */
1766:../src/src/tls.c ****         WOLFSSL_MSG("No protocol match with peer -> Continue");
1767:../src/src/tls.c ****         return WOLFSSL_ALPN_NOT_FOUND;
1768:../src/src/tls.c ****     }
1769:../src/src/tls.c **** 
1770:../src/src/tls.c ****     if (alpn->next != NULL) {
1771:../src/src/tls.c ****         WOLFSSL_MSG("Only one protocol name must be accepted");
1772:../src/src/tls.c ****         return WOLFSSL_FATAL_ERROR;
1773:../src/src/tls.c ****     }
1774:../src/src/tls.c **** 
1775:../src/src/tls.c ****     *data = alpn->protocol_name;
1776:../src/src/tls.c ****     *dataSz = (word16)XSTRLEN((char*)*data);
1777:../src/src/tls.c **** 
1778:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
1779:../src/src/tls.c **** }
1780:../src/src/tls.c **** 
1781:../src/src/tls.c **** #define ALPN_FREE_ALL     TLSX_ALPN_FreeAll
1782:../src/src/tls.c **** #define ALPN_GET_SIZE     TLSX_ALPN_GetSize
1783:../src/src/tls.c **** #define ALPN_WRITE        TLSX_ALPN_Write
1784:../src/src/tls.c **** #define ALPN_PARSE        TLSX_ALPN_ParseAndSet
1785:../src/src/tls.c **** 
1786:../src/src/tls.c **** #else /* HAVE_ALPN */
1787:../src/src/tls.c **** 
1788:../src/src/tls.c **** #define ALPN_FREE_ALL(list, heap)
1789:../src/src/tls.c **** #define ALPN_GET_SIZE(list)     0
1790:../src/src/tls.c **** #define ALPN_WRITE(a, b)        0
1791:../src/src/tls.c **** #define ALPN_PARSE(a, b, c, d)  0
1792:../src/src/tls.c **** 
1793:../src/src/tls.c **** #endif /* HAVE_ALPN */
1794:../src/src/tls.c **** 
1795:../src/src/tls.c **** /******************************************************************************/
1796:../src/src/tls.c **** /* Server Name Indication                                                     */
1797:../src/src/tls.c **** /******************************************************************************/
1798:../src/src/tls.c **** 
1799:../src/src/tls.c **** #ifdef HAVE_SNI
1800:../src/src/tls.c **** 
1801:../src/src/tls.c **** /** Creates a new SNI object. */
1802:../src/src/tls.c **** static SNI* TLSX_SNI_New(byte type, const void* data, word16 size, void* heap)
1803:../src/src/tls.c **** {
1804:../src/src/tls.c ****     SNI* sni = (SNI*)XMALLOC(sizeof(SNI), heap, DYNAMIC_TYPE_TLSX);
1805:../src/src/tls.c **** 
1806:../src/src/tls.c ****     (void)heap;
1807:../src/src/tls.c **** 
1808:../src/src/tls.c ****     if (sni) {
1809:../src/src/tls.c ****         sni->type = type;
1810:../src/src/tls.c ****         sni->next = NULL;
1811:../src/src/tls.c **** 
1812:../src/src/tls.c ****     #ifndef NO_WOLFSSL_SERVER
1813:../src/src/tls.c ****         sni->options = 0;
1814:../src/src/tls.c ****         sni->status  = WOLFSSL_SNI_NO_MATCH;
1815:../src/src/tls.c ****     #endif
1816:../src/src/tls.c **** 
1817:../src/src/tls.c ****         switch (sni->type) {
1818:../src/src/tls.c ****             case WOLFSSL_SNI_HOST_NAME:
1819:../src/src/tls.c ****                 sni->data.host_name = (char*)XMALLOC(size + 1, heap,
1820:../src/src/tls.c ****                                                      DYNAMIC_TYPE_TLSX);
1821:../src/src/tls.c ****                 if (sni->data.host_name) {
1822:../src/src/tls.c ****                     XSTRNCPY(sni->data.host_name, (const char*)data, size);
1823:../src/src/tls.c ****                     sni->data.host_name[size] = '\0';
1824:../src/src/tls.c ****                 } else {
1825:../src/src/tls.c ****                     XFREE(sni, heap, DYNAMIC_TYPE_TLSX);
1826:../src/src/tls.c ****                     sni = NULL;
1827:../src/src/tls.c ****                 }
1828:../src/src/tls.c ****             break;
1829:../src/src/tls.c **** 
1830:../src/src/tls.c ****             default: /* invalid type */
1831:../src/src/tls.c ****                 XFREE(sni, heap, DYNAMIC_TYPE_TLSX);
1832:../src/src/tls.c ****                 sni = NULL;
1833:../src/src/tls.c ****         }
1834:../src/src/tls.c ****     }
1835:../src/src/tls.c **** 
1836:../src/src/tls.c ****     return sni;
1837:../src/src/tls.c **** }
1838:../src/src/tls.c **** 
1839:../src/src/tls.c **** /** Releases a SNI object. */
1840:../src/src/tls.c **** static void TLSX_SNI_Free(SNI* sni, void* heap)
1841:../src/src/tls.c **** {
1842:../src/src/tls.c ****     if (sni) {
1843:../src/src/tls.c ****         switch (sni->type) {
1844:../src/src/tls.c ****             case WOLFSSL_SNI_HOST_NAME:
1845:../src/src/tls.c ****                 XFREE(sni->data.host_name, heap, DYNAMIC_TYPE_TLSX);
1846:../src/src/tls.c ****             break;
1847:../src/src/tls.c ****         }
1848:../src/src/tls.c **** 
1849:../src/src/tls.c ****         XFREE(sni, heap, DYNAMIC_TYPE_TLSX);
1850:../src/src/tls.c ****     }
1851:../src/src/tls.c ****     (void)heap;
1852:../src/src/tls.c **** }
1853:../src/src/tls.c **** 
1854:../src/src/tls.c **** /** Releases all SNI objects in the provided list. */
1855:../src/src/tls.c **** static void TLSX_SNI_FreeAll(SNI* list, void* heap)
1856:../src/src/tls.c **** {
1857:../src/src/tls.c ****     SNI* sni;
1858:../src/src/tls.c **** 
1859:../src/src/tls.c ****     while ((sni = list)) {
1860:../src/src/tls.c ****         list = sni->next;
1861:../src/src/tls.c ****         TLSX_SNI_Free(sni, heap);
1862:../src/src/tls.c ****     }
1863:../src/src/tls.c **** }
1864:../src/src/tls.c **** 
1865:../src/src/tls.c **** /** Tells the buffered size of the SNI objects in a list. */
1866:../src/src/tls.c **** static word16 TLSX_SNI_GetSize(SNI* list)
1867:../src/src/tls.c **** {
1868:../src/src/tls.c ****     SNI* sni;
1869:../src/src/tls.c ****     word16 length = OPAQUE16_LEN; /* list length */
1870:../src/src/tls.c **** 
1871:../src/src/tls.c ****     while ((sni = list)) {
1872:../src/src/tls.c ****         list = sni->next;
1873:../src/src/tls.c **** 
1874:../src/src/tls.c ****         length += ENUM_LEN + OPAQUE16_LEN; /* sni type + sni length */
1875:../src/src/tls.c **** 
1876:../src/src/tls.c ****         switch (sni->type) {
1877:../src/src/tls.c ****             case WOLFSSL_SNI_HOST_NAME:
1878:../src/src/tls.c ****                 length += (word16)XSTRLEN((char*)sni->data.host_name);
1879:../src/src/tls.c ****             break;
1880:../src/src/tls.c ****         }
1881:../src/src/tls.c ****     }
1882:../src/src/tls.c **** 
1883:../src/src/tls.c ****     return length;
1884:../src/src/tls.c **** }
1885:../src/src/tls.c **** 
1886:../src/src/tls.c **** /** Writes the SNI objects of a list in a buffer. */
1887:../src/src/tls.c **** static word16 TLSX_SNI_Write(SNI* list, byte* output)
1888:../src/src/tls.c **** {
1889:../src/src/tls.c ****     SNI* sni;
1890:../src/src/tls.c ****     word16 length = 0;
1891:../src/src/tls.c ****     word16 offset = OPAQUE16_LEN; /* list length offset */
1892:../src/src/tls.c **** 
1893:../src/src/tls.c ****     while ((sni = list)) {
1894:../src/src/tls.c ****         list = sni->next;
1895:../src/src/tls.c **** 
1896:../src/src/tls.c ****         output[offset++] = sni->type; /* sni type */
1897:../src/src/tls.c **** 
1898:../src/src/tls.c ****         switch (sni->type) {
1899:../src/src/tls.c ****             case WOLFSSL_SNI_HOST_NAME:
1900:../src/src/tls.c ****                 length = (word16)XSTRLEN((char*)sni->data.host_name);
1901:../src/src/tls.c **** 
1902:../src/src/tls.c ****                 c16toa(length, output + offset); /* sni length */
1903:../src/src/tls.c ****                 offset += OPAQUE16_LEN;
1904:../src/src/tls.c **** 
1905:../src/src/tls.c ****                 XMEMCPY(output + offset, sni->data.host_name, length);
1906:../src/src/tls.c **** 
1907:../src/src/tls.c ****                 offset += length;
1908:../src/src/tls.c ****             break;
1909:../src/src/tls.c ****         }
1910:../src/src/tls.c ****     }
1911:../src/src/tls.c **** 
1912:../src/src/tls.c ****     c16toa(offset - OPAQUE16_LEN, output); /* writing list length */
1913:../src/src/tls.c **** 
1914:../src/src/tls.c ****     return offset;
1915:../src/src/tls.c **** }
1916:../src/src/tls.c **** 
1917:../src/src/tls.c **** /** Finds a SNI object in the provided list. */
1918:../src/src/tls.c **** static SNI* TLSX_SNI_Find(SNI *list, byte type)
1919:../src/src/tls.c **** {
1920:../src/src/tls.c ****     SNI* sni = list;
1921:../src/src/tls.c **** 
1922:../src/src/tls.c ****     while (sni && sni->type != type)
1923:../src/src/tls.c ****         sni = sni->next;
1924:../src/src/tls.c **** 
1925:../src/src/tls.c ****     return sni;
1926:../src/src/tls.c **** }
1927:../src/src/tls.c **** 
1928:../src/src/tls.c **** #if (!defined(NO_WOLFSSL_CLIENT) || !defined(NO_WOLFSSL_SERVER))
1929:../src/src/tls.c **** /** Sets the status of a SNI object. */
1930:../src/src/tls.c **** static void TLSX_SNI_SetStatus(TLSX* extensions, byte type, byte status)
1931:../src/src/tls.c **** {
1932:../src/src/tls.c ****     TLSX* extension = TLSX_Find(extensions, TLSX_SERVER_NAME);
1933:../src/src/tls.c ****     SNI* sni = TLSX_SNI_Find(extension ? (SNI*)extension->data : NULL, type);
1934:../src/src/tls.c **** 
1935:../src/src/tls.c ****     if (sni)
1936:../src/src/tls.c ****         sni->status = status;
1937:../src/src/tls.c **** }
1938:../src/src/tls.c **** #endif
1939:../src/src/tls.c **** 
1940:../src/src/tls.c **** /** Gets the status of a SNI object. */
1941:../src/src/tls.c **** byte TLSX_SNI_Status(TLSX* extensions, byte type)
1942:../src/src/tls.c **** {
1943:../src/src/tls.c ****     TLSX* extension = TLSX_Find(extensions, TLSX_SERVER_NAME);
1944:../src/src/tls.c ****     SNI* sni = TLSX_SNI_Find(extension ? (SNI*)extension->data : NULL, type);
1945:../src/src/tls.c **** 
1946:../src/src/tls.c ****     if (sni)
1947:../src/src/tls.c ****         return sni->status;
1948:../src/src/tls.c **** 
1949:../src/src/tls.c ****     return 0;
1950:../src/src/tls.c **** }
1951:../src/src/tls.c **** 
1952:../src/src/tls.c **** /** Parses a buffer of SNI extensions. */
1953:../src/src/tls.c **** static int TLSX_SNI_Parse(WOLFSSL* ssl, const byte* input, word16 length,
1954:../src/src/tls.c ****                           byte isRequest)
1955:../src/src/tls.c **** {
1956:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
1957:../src/src/tls.c ****     word16 size = 0;
1958:../src/src/tls.c ****     word16 offset = 0;
1959:../src/src/tls.c ****     int cacheOnly = 0;
1960:../src/src/tls.c ****     SNI *sni = NULL;
1961:../src/src/tls.c ****     byte type;
1962:../src/src/tls.c ****     int matchStat;
1963:../src/src/tls.c ****     byte matched;
1964:../src/src/tls.c **** #endif
1965:../src/src/tls.c **** 
1966:../src/src/tls.c ****     TLSX *extension = TLSX_Find(ssl->extensions, TLSX_SERVER_NAME);
1967:../src/src/tls.c **** 
1968:../src/src/tls.c ****     if (!extension)
1969:../src/src/tls.c ****         extension = TLSX_Find(ssl->ctx->extensions, TLSX_SERVER_NAME);
1970:../src/src/tls.c **** 
1971:../src/src/tls.c ****     if (!isRequest) {
1972:../src/src/tls.c ****         #ifndef NO_WOLFSSL_CLIENT
1973:../src/src/tls.c ****             if (!extension || !extension->data)
1974:../src/src/tls.c ****                 return TLSX_HandleUnsupportedExtension(ssl);
1975:../src/src/tls.c **** 
1976:../src/src/tls.c ****             if (length > 0)
1977:../src/src/tls.c ****                 return BUFFER_ERROR; /* SNI response MUST be empty. */
1978:../src/src/tls.c **** 
1979:../src/src/tls.c ****             /* This call enables wolfSSL_SNI_GetRequest() to be called in the
1980:../src/src/tls.c ****              * client side to fetch the used SNI. It will only work if the SNI
1981:../src/src/tls.c ****              * was set at the SSL object level. Right now we only support one
1982:../src/src/tls.c ****              * name type, WOLFSSL_SNI_HOST_NAME, but in the future, the
1983:../src/src/tls.c ****              * inclusion of other name types will turn this method inaccurate,
1984:../src/src/tls.c ****              * as the extension response doesn't contains information of which
1985:../src/src/tls.c ****              * name was accepted.
1986:../src/src/tls.c ****              */
1987:../src/src/tls.c ****             TLSX_SNI_SetStatus(ssl->extensions, WOLFSSL_SNI_HOST_NAME,
1988:../src/src/tls.c ****                                                         WOLFSSL_SNI_REAL_MATCH);
1989:../src/src/tls.c **** 
1990:../src/src/tls.c ****             return 0;
1991:../src/src/tls.c ****         #endif
1992:../src/src/tls.c ****     }
1993:../src/src/tls.c **** 
1994:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
1995:../src/src/tls.c ****     if (!extension || !extension->data) {
1996:../src/src/tls.c ****         /* This will keep SNI even though TLSX_UseSNI has not been called.
1997:../src/src/tls.c ****          * Enable it so that the received sni is available to functions
1998:../src/src/tls.c ****          * that use a custom callback when SNI is received.
1999:../src/src/tls.c ****          */
2000:../src/src/tls.c ****     #ifdef WOLFSSL_ALWAYS_KEEP_SNI
2001:../src/src/tls.c ****         cacheOnly = 1;
2002:../src/src/tls.c ****     #endif
2003:../src/src/tls.c ****         if (ssl->ctx->sniRecvCb) {
2004:../src/src/tls.c ****             cacheOnly = 1;
2005:../src/src/tls.c ****         }
2006:../src/src/tls.c **** 
2007:../src/src/tls.c ****         if (cacheOnly) {
2008:../src/src/tls.c ****             WOLFSSL_MSG("Forcing SSL object to store SNI parameter");
2009:../src/src/tls.c ****         }
2010:../src/src/tls.c ****         else {
2011:../src/src/tls.c ****             /* Skipping, SNI not enabled at server side. */
2012:../src/src/tls.c ****             return 0;
2013:../src/src/tls.c ****         }
2014:../src/src/tls.c ****     }
2015:../src/src/tls.c **** 
2016:../src/src/tls.c ****     if (OPAQUE16_LEN > length)
2017:../src/src/tls.c ****         return BUFFER_ERROR;
2018:../src/src/tls.c **** 
2019:../src/src/tls.c ****     ato16(input, &size);
2020:../src/src/tls.c ****     offset += OPAQUE16_LEN;
2021:../src/src/tls.c **** 
2022:../src/src/tls.c ****     /* validating sni list length */
2023:../src/src/tls.c ****     if (length != OPAQUE16_LEN + size || size == 0)
2024:../src/src/tls.c ****         return BUFFER_ERROR;
2025:../src/src/tls.c **** 
2026:../src/src/tls.c ****     /* SNI was badly specified and only one type is now recognized and allowed.
2027:../src/src/tls.c ****      * Only one SNI value per type (RFC6066), so, no loop. */
2028:../src/src/tls.c ****     type = input[offset++];
2029:../src/src/tls.c ****     if (type != WOLFSSL_SNI_HOST_NAME)
2030:../src/src/tls.c ****         return BUFFER_ERROR;
2031:../src/src/tls.c **** 
2032:../src/src/tls.c ****     if (offset + OPAQUE16_LEN > length)
2033:../src/src/tls.c ****         return BUFFER_ERROR;
2034:../src/src/tls.c ****     ato16(input + offset, &size);
2035:../src/src/tls.c ****     offset += OPAQUE16_LEN;
2036:../src/src/tls.c **** 
2037:../src/src/tls.c ****     if (offset + size != length || size == 0)
2038:../src/src/tls.c ****         return BUFFER_ERROR;
2039:../src/src/tls.c **** 
2040:../src/src/tls.c ****     if (!cacheOnly && !(sni = TLSX_SNI_Find((SNI*)extension->data, type)))
2041:../src/src/tls.c ****         return 0; /* not using this type of SNI. */
2042:../src/src/tls.c **** 
2043:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
2044:../src/src/tls.c ****     /* Don't process the second ClientHello SNI extension if there
2045:../src/src/tls.c ****      * was problems with the first.
2046:../src/src/tls.c ****      */
2047:../src/src/tls.c ****     if (!cacheOnly && sni->status != 0)
2048:../src/src/tls.c ****         return 0;
2049:../src/src/tls.c **** #endif
2050:../src/src/tls.c ****     matched = cacheOnly || (XSTRLEN(sni->data.host_name) == size &&
2051:../src/src/tls.c ****          XSTRNCMP(sni->data.host_name, (const char*)input + offset, size) == 0);
2052:../src/src/tls.c **** 
2053:../src/src/tls.c ****     if (matched || sni->options & WOLFSSL_SNI_ANSWER_ON_MISMATCH) {
2054:../src/src/tls.c ****         int r = TLSX_UseSNI(&ssl->extensions, type, input + offset, size,
2055:../src/src/tls.c ****                                                                      ssl->heap);
2056:../src/src/tls.c ****         if (r != WOLFSSL_SUCCESS)
2057:../src/src/tls.c ****             return r; /* throws error. */
2058:../src/src/tls.c **** 
2059:../src/src/tls.c ****         if (cacheOnly) {
2060:../src/src/tls.c ****             WOLFSSL_MSG("Forcing storage of SNI, Fake match");
2061:../src/src/tls.c ****             matchStat = WOLFSSL_SNI_FORCE_KEEP;
2062:../src/src/tls.c ****         }
2063:../src/src/tls.c ****         else if (matched) {
2064:../src/src/tls.c ****             WOLFSSL_MSG("SNI did match!");
2065:../src/src/tls.c ****             matchStat = WOLFSSL_SNI_REAL_MATCH;
2066:../src/src/tls.c ****         }
2067:../src/src/tls.c ****         else {
2068:../src/src/tls.c ****             WOLFSSL_MSG("fake SNI match from ANSWER_ON_MISMATCH");
2069:../src/src/tls.c ****             matchStat = WOLFSSL_SNI_FAKE_MATCH;
2070:../src/src/tls.c ****         }
2071:../src/src/tls.c **** 
2072:../src/src/tls.c ****         TLSX_SNI_SetStatus(ssl->extensions, type, (byte)matchStat);
2073:../src/src/tls.c **** 
2074:../src/src/tls.c ****         if (!cacheOnly)
2075:../src/src/tls.c ****             TLSX_SetResponse(ssl, TLSX_SERVER_NAME);
2076:../src/src/tls.c ****     }
2077:../src/src/tls.c ****     else if (!(sni->options & WOLFSSL_SNI_CONTINUE_ON_MISMATCH)) {
2078:../src/src/tls.c ****         SendAlert(ssl, alert_fatal, unrecognized_name);
2079:../src/src/tls.c **** 
2080:../src/src/tls.c ****         return UNKNOWN_SNI_HOST_NAME_E;
2081:../src/src/tls.c ****     }
2082:../src/src/tls.c **** #else
2083:../src/src/tls.c ****     (void)input;
2084:../src/src/tls.c **** #endif
2085:../src/src/tls.c **** 
2086:../src/src/tls.c **** #if defined(NO_WOLFSSL_CLIENT) && defined(NO_WOLFSSL_SERVER)
2087:../src/src/tls.c ****     (void)length;
2088:../src/src/tls.c **** #endif
2089:../src/src/tls.c **** 
2090:../src/src/tls.c ****     return 0;
2091:../src/src/tls.c **** }
2092:../src/src/tls.c **** 
2093:../src/src/tls.c **** static int TLSX_SNI_VerifyParse(WOLFSSL* ssl,  byte isRequest)
2094:../src/src/tls.c **** {
2095:../src/src/tls.c ****     (void)ssl;
2096:../src/src/tls.c **** 
2097:../src/src/tls.c ****     if (isRequest) {
2098:../src/src/tls.c ****     #ifndef NO_WOLFSSL_SERVER
2099:../src/src/tls.c ****         TLSX* ctx_ext = TLSX_Find(ssl->ctx->extensions, TLSX_SERVER_NAME);
2100:../src/src/tls.c ****         TLSX* ssl_ext = TLSX_Find(ssl->extensions,      TLSX_SERVER_NAME);
2101:../src/src/tls.c ****         SNI* ctx_sni = ctx_ext ? (SNI*)ctx_ext->data : NULL;
2102:../src/src/tls.c ****         SNI* ssl_sni = ssl_ext ? (SNI*)ssl_ext->data : NULL;
2103:../src/src/tls.c ****         SNI* sni = NULL;
2104:../src/src/tls.c **** 
2105:../src/src/tls.c ****         for (; ctx_sni; ctx_sni = ctx_sni->next) {
2106:../src/src/tls.c ****             if (ctx_sni->options & WOLFSSL_SNI_ABORT_ON_ABSENCE) {
2107:../src/src/tls.c ****                 sni = TLSX_SNI_Find(ssl_sni, ctx_sni->type);
2108:../src/src/tls.c **** 
2109:../src/src/tls.c ****                 if (sni) {
2110:../src/src/tls.c ****                     if (sni->status != WOLFSSL_SNI_NO_MATCH)
2111:../src/src/tls.c ****                         continue;
2112:../src/src/tls.c **** 
2113:../src/src/tls.c ****                     /* if ssl level overrides ctx level, it is ok. */
2114:../src/src/tls.c ****                     if ((sni->options & WOLFSSL_SNI_ABORT_ON_ABSENCE) == 0)
2115:../src/src/tls.c ****                         continue;
2116:../src/src/tls.c ****                 }
2117:../src/src/tls.c **** 
2118:../src/src/tls.c ****                 SendAlert(ssl, alert_fatal, handshake_failure);
2119:../src/src/tls.c ****                 return SNI_ABSENT_ERROR;
2120:../src/src/tls.c ****             }
2121:../src/src/tls.c ****         }
2122:../src/src/tls.c **** 
2123:../src/src/tls.c ****         for (; ssl_sni; ssl_sni = ssl_sni->next) {
2124:../src/src/tls.c ****             if (ssl_sni->options & WOLFSSL_SNI_ABORT_ON_ABSENCE) {
2125:../src/src/tls.c ****                 if (ssl_sni->status != WOLFSSL_SNI_NO_MATCH)
2126:../src/src/tls.c ****                     continue;
2127:../src/src/tls.c **** 
2128:../src/src/tls.c ****                 SendAlert(ssl, alert_fatal, handshake_failure);
2129:../src/src/tls.c ****                 return SNI_ABSENT_ERROR;
2130:../src/src/tls.c ****             }
2131:../src/src/tls.c ****         }
2132:../src/src/tls.c ****     #endif /* NO_WOLFSSL_SERVER */
2133:../src/src/tls.c ****     }
2134:../src/src/tls.c **** 
2135:../src/src/tls.c ****     return 0;
2136:../src/src/tls.c **** }
2137:../src/src/tls.c **** 
2138:../src/src/tls.c **** int TLSX_UseSNI(TLSX** extensions, byte type, const void* data, word16 size,
2139:../src/src/tls.c ****                                                                      void* heap)
2140:../src/src/tls.c **** {
2141:../src/src/tls.c ****     TLSX* extension;
2142:../src/src/tls.c ****     SNI* sni = NULL;
2143:../src/src/tls.c **** 
2144:../src/src/tls.c ****     if (extensions == NULL || data == NULL)
2145:../src/src/tls.c ****         return BAD_FUNC_ARG;
2146:../src/src/tls.c **** 
2147:../src/src/tls.c ****     if ((sni = TLSX_SNI_New(type, data, size, heap)) == NULL)
2148:../src/src/tls.c ****         return MEMORY_E;
2149:../src/src/tls.c **** 
2150:../src/src/tls.c ****     extension = TLSX_Find(*extensions, TLSX_SERVER_NAME);
2151:../src/src/tls.c ****     if (!extension) {
2152:../src/src/tls.c ****         int ret = TLSX_Push(extensions, TLSX_SERVER_NAME, (void*)sni, heap);
2153:../src/src/tls.c **** 
2154:../src/src/tls.c ****         if (ret != 0) {
2155:../src/src/tls.c ****             TLSX_SNI_Free(sni, heap);
2156:../src/src/tls.c ****             return ret;
2157:../src/src/tls.c ****         }
2158:../src/src/tls.c ****     }
2159:../src/src/tls.c ****     else {
2160:../src/src/tls.c ****         /* push new SNI object to extension data. */
2161:../src/src/tls.c ****         sni->next = (SNI*)extension->data;
2162:../src/src/tls.c ****         extension->data = (void*)sni;
2163:../src/src/tls.c **** 
2164:../src/src/tls.c ****         /* remove duplicate SNI, there should be only one of each type. */
2165:../src/src/tls.c ****         do {
2166:../src/src/tls.c ****             if (sni->next && sni->next->type == type) {
2167:../src/src/tls.c ****                 SNI* next = sni->next;
2168:../src/src/tls.c **** 
2169:../src/src/tls.c ****                 sni->next = next->next;
2170:../src/src/tls.c ****                 TLSX_SNI_Free(next, heap);
2171:../src/src/tls.c **** 
2172:../src/src/tls.c ****                 /* there is no way to occur more than
2173:../src/src/tls.c ****                  * two SNIs of the same type.
2174:../src/src/tls.c ****                  */
2175:../src/src/tls.c ****                 break;
2176:../src/src/tls.c ****             }
2177:../src/src/tls.c ****         } while ((sni = sni->next));
2178:../src/src/tls.c ****     }
2179:../src/src/tls.c **** 
2180:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
2181:../src/src/tls.c **** }
2182:../src/src/tls.c **** 
2183:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
2184:../src/src/tls.c **** 
2185:../src/src/tls.c **** /** Tells the SNI requested by the client. */
2186:../src/src/tls.c **** word16 TLSX_SNI_GetRequest(TLSX* extensions, byte type, void** data)
2187:../src/src/tls.c **** {
2188:../src/src/tls.c ****     TLSX* extension = TLSX_Find(extensions, TLSX_SERVER_NAME);
2189:../src/src/tls.c ****     SNI* sni = TLSX_SNI_Find(extension ? (SNI*)extension->data : NULL, type);
2190:../src/src/tls.c **** 
2191:../src/src/tls.c ****     if (sni && sni->status != WOLFSSL_SNI_NO_MATCH) {
2192:../src/src/tls.c ****         switch (sni->type) {
2193:../src/src/tls.c ****             case WOLFSSL_SNI_HOST_NAME:
2194:../src/src/tls.c ****                 if (data) {
2195:../src/src/tls.c ****                     *data = sni->data.host_name;
2196:../src/src/tls.c ****                     return (word16)XSTRLEN((char*)*data);
2197:../src/src/tls.c ****                 }
2198:../src/src/tls.c ****         }
2199:../src/src/tls.c ****     }
2200:../src/src/tls.c **** 
2201:../src/src/tls.c ****     return 0;
2202:../src/src/tls.c **** }
2203:../src/src/tls.c **** 
2204:../src/src/tls.c **** /** Sets the options for a SNI object. */
2205:../src/src/tls.c **** void TLSX_SNI_SetOptions(TLSX* extensions, byte type, byte options)
2206:../src/src/tls.c **** {
2207:../src/src/tls.c ****     TLSX* extension = TLSX_Find(extensions, TLSX_SERVER_NAME);
2208:../src/src/tls.c ****     SNI* sni = TLSX_SNI_Find(extension ? (SNI*)extension->data : NULL, type);
2209:../src/src/tls.c **** 
2210:../src/src/tls.c ****     if (sni)
2211:../src/src/tls.c ****         sni->options = options;
2212:../src/src/tls.c **** }
2213:../src/src/tls.c **** 
2214:../src/src/tls.c **** /** Retrieves a SNI request from a client hello buffer. */
2215:../src/src/tls.c **** int TLSX_SNI_GetFromBuffer(const byte* clientHello, word32 helloSz,
2216:../src/src/tls.c ****                            byte type, byte* sni, word32* inOutSz)
2217:../src/src/tls.c **** {
2218:../src/src/tls.c ****     word32 offset = 0;
2219:../src/src/tls.c ****     word32 len32 = 0;
2220:../src/src/tls.c ****     word16 len16 = 0;
2221:../src/src/tls.c **** 
2222:../src/src/tls.c ****     if (helloSz < RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ + CLIENT_HELLO_FIRST)
2223:../src/src/tls.c ****         return INCOMPLETE_DATA;
2224:../src/src/tls.c **** 
2225:../src/src/tls.c ****     /* TLS record header */
2226:../src/src/tls.c ****     if ((enum ContentType) clientHello[offset++] != handshake) {
2227:../src/src/tls.c **** 
2228:../src/src/tls.c ****         /* checking for SSLv2.0 client hello according to: */
2229:../src/src/tls.c ****         /* http://tools.ietf.org/html/rfc4346#appendix-E.1 */
2230:../src/src/tls.c ****         if ((enum HandShakeType) clientHello[++offset] == client_hello) {
2231:../src/src/tls.c ****             offset += ENUM_LEN + VERSION_SZ; /* skip version */
2232:../src/src/tls.c **** 
2233:../src/src/tls.c ****             ato16(clientHello + offset, &len16);
2234:../src/src/tls.c ****             offset += OPAQUE16_LEN;
2235:../src/src/tls.c **** 
2236:../src/src/tls.c ****             if (len16 % 3) /* cipher_spec_length must be multiple of 3 */
2237:../src/src/tls.c ****                 return BUFFER_ERROR;
2238:../src/src/tls.c **** 
2239:../src/src/tls.c ****             ato16(clientHello + offset, &len16);
2240:../src/src/tls.c ****             /* Returning SNI_UNSUPPORTED do not increment offset here */
2241:../src/src/tls.c **** 
2242:../src/src/tls.c ****             if (len16 != 0) /* session_id_length must be 0 */
2243:../src/src/tls.c ****                 return BUFFER_ERROR;
2244:../src/src/tls.c **** 
2245:../src/src/tls.c ****             return SNI_UNSUPPORTED;
2246:../src/src/tls.c ****         }
2247:../src/src/tls.c **** 
2248:../src/src/tls.c ****         return BUFFER_ERROR;
2249:../src/src/tls.c ****     }
2250:../src/src/tls.c **** 
2251:../src/src/tls.c ****     if (clientHello[offset++] != SSLv3_MAJOR)
2252:../src/src/tls.c ****         return BUFFER_ERROR;
2253:../src/src/tls.c **** 
2254:../src/src/tls.c ****     if (clientHello[offset++] < TLSv1_MINOR)
2255:../src/src/tls.c ****         return SNI_UNSUPPORTED;
2256:../src/src/tls.c **** 
2257:../src/src/tls.c ****     ato16(clientHello + offset, &len16);
2258:../src/src/tls.c ****     offset += OPAQUE16_LEN;
2259:../src/src/tls.c **** 
2260:../src/src/tls.c ****     if (offset + len16 > helloSz)
2261:../src/src/tls.c ****         return INCOMPLETE_DATA;
2262:../src/src/tls.c **** 
2263:../src/src/tls.c ****     /* Handshake header */
2264:../src/src/tls.c ****     if ((enum HandShakeType) clientHello[offset] != client_hello)
2265:../src/src/tls.c ****         return BUFFER_ERROR;
2266:../src/src/tls.c **** 
2267:../src/src/tls.c ****     c24to32(clientHello + offset + 1, &len32);
2268:../src/src/tls.c ****     offset += HANDSHAKE_HEADER_SZ;
2269:../src/src/tls.c **** 
2270:../src/src/tls.c ****     if (offset + len32 > helloSz)
2271:../src/src/tls.c ****         return BUFFER_ERROR;
2272:../src/src/tls.c **** 
2273:../src/src/tls.c ****     /* client hello */
2274:../src/src/tls.c ****     offset += VERSION_SZ + RAN_LEN; /* version, random */
2275:../src/src/tls.c **** 
2276:../src/src/tls.c ****     if (helloSz < offset + clientHello[offset])
2277:../src/src/tls.c ****         return BUFFER_ERROR;
2278:../src/src/tls.c **** 
2279:../src/src/tls.c ****     offset += ENUM_LEN + clientHello[offset]; /* skip session id */
2280:../src/src/tls.c **** 
2281:../src/src/tls.c ****     /* cypher suites */
2282:../src/src/tls.c ****     if (helloSz < offset + OPAQUE16_LEN)
2283:../src/src/tls.c ****         return BUFFER_ERROR;
2284:../src/src/tls.c **** 
2285:../src/src/tls.c ****     ato16(clientHello + offset, &len16);
2286:../src/src/tls.c ****     offset += OPAQUE16_LEN;
2287:../src/src/tls.c **** 
2288:../src/src/tls.c ****     if (helloSz < offset + len16)
2289:../src/src/tls.c ****         return BUFFER_ERROR;
2290:../src/src/tls.c **** 
2291:../src/src/tls.c ****     offset += len16; /* skip cypher suites */
2292:../src/src/tls.c **** 
2293:../src/src/tls.c ****     /* compression methods */
2294:../src/src/tls.c ****     if (helloSz < offset + 1)
2295:../src/src/tls.c ****         return BUFFER_ERROR;
2296:../src/src/tls.c **** 
2297:../src/src/tls.c ****     if (helloSz < offset + clientHello[offset])
2298:../src/src/tls.c ****         return BUFFER_ERROR;
2299:../src/src/tls.c **** 
2300:../src/src/tls.c ****     offset += ENUM_LEN + clientHello[offset]; /* skip compression methods */
2301:../src/src/tls.c **** 
2302:../src/src/tls.c ****     /* extensions */
2303:../src/src/tls.c ****     if (helloSz < offset + OPAQUE16_LEN)
2304:../src/src/tls.c ****         return 0; /* no extensions in client hello. */
2305:../src/src/tls.c **** 
2306:../src/src/tls.c ****     ato16(clientHello + offset, &len16);
2307:../src/src/tls.c ****     offset += OPAQUE16_LEN;
2308:../src/src/tls.c **** 
2309:../src/src/tls.c ****     if (helloSz < offset + len16)
2310:../src/src/tls.c ****         return BUFFER_ERROR;
2311:../src/src/tls.c **** 
2312:../src/src/tls.c ****     while (len16 >= OPAQUE16_LEN + OPAQUE16_LEN) {
2313:../src/src/tls.c ****         word16 extType;
2314:../src/src/tls.c ****         word16 extLen;
2315:../src/src/tls.c **** 
2316:../src/src/tls.c ****         ato16(clientHello + offset, &extType);
2317:../src/src/tls.c ****         offset += OPAQUE16_LEN;
2318:../src/src/tls.c **** 
2319:../src/src/tls.c ****         ato16(clientHello + offset, &extLen);
2320:../src/src/tls.c ****         offset += OPAQUE16_LEN;
2321:../src/src/tls.c **** 
2322:../src/src/tls.c ****         if (helloSz < offset + extLen)
2323:../src/src/tls.c ****             return BUFFER_ERROR;
2324:../src/src/tls.c **** 
2325:../src/src/tls.c ****         if (extType != TLSX_SERVER_NAME) {
2326:../src/src/tls.c ****             offset += extLen; /* skip extension */
2327:../src/src/tls.c ****         } else {
2328:../src/src/tls.c ****             word16 listLen;
2329:../src/src/tls.c **** 
2330:../src/src/tls.c ****             ato16(clientHello + offset, &listLen);
2331:../src/src/tls.c ****             offset += OPAQUE16_LEN;
2332:../src/src/tls.c **** 
2333:../src/src/tls.c ****             if (helloSz < offset + listLen)
2334:../src/src/tls.c ****                 return BUFFER_ERROR;
2335:../src/src/tls.c **** 
2336:../src/src/tls.c ****             while (listLen > ENUM_LEN + OPAQUE16_LEN) {
2337:../src/src/tls.c ****                 byte   sniType = clientHello[offset++];
2338:../src/src/tls.c ****                 word16 sniLen;
2339:../src/src/tls.c **** 
2340:../src/src/tls.c ****                 ato16(clientHello + offset, &sniLen);
2341:../src/src/tls.c ****                 offset += OPAQUE16_LEN;
2342:../src/src/tls.c **** 
2343:../src/src/tls.c ****                 if (helloSz < offset + sniLen)
2344:../src/src/tls.c ****                     return BUFFER_ERROR;
2345:../src/src/tls.c **** 
2346:../src/src/tls.c ****                 if (sniType != type) {
2347:../src/src/tls.c ****                     offset  += sniLen;
2348:../src/src/tls.c ****                     listLen -= min(ENUM_LEN + OPAQUE16_LEN + sniLen, listLen);
2349:../src/src/tls.c ****                     continue;
2350:../src/src/tls.c ****                 }
2351:../src/src/tls.c **** 
2352:../src/src/tls.c ****                 *inOutSz = min(sniLen, *inOutSz);
2353:../src/src/tls.c ****                 XMEMCPY(sni, clientHello + offset, *inOutSz);
2354:../src/src/tls.c **** 
2355:../src/src/tls.c ****                 return WOLFSSL_SUCCESS;
2356:../src/src/tls.c ****             }
2357:../src/src/tls.c ****         }
2358:../src/src/tls.c **** 
2359:../src/src/tls.c ****         len16 -= min(2 * OPAQUE16_LEN + extLen, len16);
2360:../src/src/tls.c ****     }
2361:../src/src/tls.c **** 
2362:../src/src/tls.c ****     return len16 ? BUFFER_ERROR : 0;
2363:../src/src/tls.c **** }
2364:../src/src/tls.c **** 
2365:../src/src/tls.c **** #endif
2366:../src/src/tls.c **** 
2367:../src/src/tls.c **** #define SNI_FREE_ALL     TLSX_SNI_FreeAll
2368:../src/src/tls.c **** #define SNI_GET_SIZE     TLSX_SNI_GetSize
2369:../src/src/tls.c **** #define SNI_WRITE        TLSX_SNI_Write
2370:../src/src/tls.c **** #define SNI_PARSE        TLSX_SNI_Parse
2371:../src/src/tls.c **** #define SNI_VERIFY_PARSE TLSX_SNI_VerifyParse
2372:../src/src/tls.c **** 
2373:../src/src/tls.c **** #else
2374:../src/src/tls.c **** 
2375:../src/src/tls.c **** #define SNI_FREE_ALL(list, heap)
2376:../src/src/tls.c **** #define SNI_GET_SIZE(list)     0
2377:../src/src/tls.c **** #define SNI_WRITE(a, b)        0
2378:../src/src/tls.c **** #define SNI_PARSE(a, b, c, d)  0
2379:../src/src/tls.c **** #define SNI_VERIFY_PARSE(a, b) 0
2380:../src/src/tls.c **** 
2381:../src/src/tls.c **** #endif /* HAVE_SNI */
2382:../src/src/tls.c **** 
2383:../src/src/tls.c **** /******************************************************************************/
2384:../src/src/tls.c **** /* Trusted CA Key Indication                                                  */
2385:../src/src/tls.c **** /******************************************************************************/
2386:../src/src/tls.c **** 
2387:../src/src/tls.c **** #ifdef HAVE_TRUSTED_CA
2388:../src/src/tls.c **** 
2389:../src/src/tls.c **** /** Creates a new TCA object. */
2390:../src/src/tls.c **** static TCA* TLSX_TCA_New(byte type, const byte* id, word16 idSz, void* heap)
2391:../src/src/tls.c **** {
2392:../src/src/tls.c ****     TCA* tca = (TCA*)XMALLOC(sizeof(TCA), heap, DYNAMIC_TYPE_TLSX);
2393:../src/src/tls.c **** 
2394:../src/src/tls.c ****     if (tca) {
2395:../src/src/tls.c ****         XMEMSET(tca, 0, sizeof(TCA));
2396:../src/src/tls.c ****         tca->type = type;
2397:../src/src/tls.c **** 
2398:../src/src/tls.c ****         switch (type) {
2399:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_PRE_AGREED:
2400:../src/src/tls.c ****                 break;
2401:../src/src/tls.c **** 
2402:../src/src/tls.c ****             #ifndef NO_SHA
2403:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_KEY_SHA1:
2404:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_CERT_SHA1:
2405:../src/src/tls.c ****                 if (idSz == WC_SHA_DIGEST_SIZE &&
2406:../src/src/tls.c ****                         (tca->id =
2407:../src/src/tls.c ****                             (byte*)XMALLOC(idSz, heap, DYNAMIC_TYPE_TLSX))) {
2408:../src/src/tls.c ****                     XMEMCPY(tca->id, id, idSz);
2409:../src/src/tls.c ****                     tca->idSz = idSz;
2410:../src/src/tls.c ****                 }
2411:../src/src/tls.c ****                 else {
2412:../src/src/tls.c ****                     XFREE(tca, heap, DYNAMIC_TYPE_TLSX);
2413:../src/src/tls.c ****                     tca = NULL;
2414:../src/src/tls.c ****                 }
2415:../src/src/tls.c ****                 break;
2416:../src/src/tls.c ****             #endif
2417:../src/src/tls.c **** 
2418:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_X509_NAME:
2419:../src/src/tls.c ****                 if (idSz > 0 &&
2420:../src/src/tls.c ****                         (tca->id =
2421:../src/src/tls.c ****                             (byte*)XMALLOC(idSz, heap, DYNAMIC_TYPE_TLSX))) {
2422:../src/src/tls.c ****                     XMEMCPY(tca->id, id, idSz);
2423:../src/src/tls.c ****                     tca->idSz = idSz;
2424:../src/src/tls.c ****                 }
2425:../src/src/tls.c ****                 else {
2426:../src/src/tls.c ****                     XFREE(tca, heap, DYNAMIC_TYPE_TLSX);
2427:../src/src/tls.c ****                     tca = NULL;
2428:../src/src/tls.c ****                 }
2429:../src/src/tls.c ****                 break;
2430:../src/src/tls.c **** 
2431:../src/src/tls.c ****             default: /* invalid type */
2432:../src/src/tls.c ****                 XFREE(tca, heap, DYNAMIC_TYPE_TLSX);
2433:../src/src/tls.c ****                 tca = NULL;
2434:../src/src/tls.c ****         }
2435:../src/src/tls.c ****     }
2436:../src/src/tls.c **** 
2437:../src/src/tls.c ****     (void)heap;
2438:../src/src/tls.c **** 
2439:../src/src/tls.c ****     return tca;
2440:../src/src/tls.c **** }
2441:../src/src/tls.c **** 
2442:../src/src/tls.c **** /** Releases a TCA object. */
2443:../src/src/tls.c **** static void TLSX_TCA_Free(TCA* tca, void* heap)
2444:../src/src/tls.c **** {
2445:../src/src/tls.c ****     (void)heap;
2446:../src/src/tls.c **** 
2447:../src/src/tls.c ****     if (tca) {
2448:../src/src/tls.c ****         if (tca->id)
2449:../src/src/tls.c ****             XFREE(tca->id, heap, DYNAMIC_TYPE_TLSX);
2450:../src/src/tls.c ****         XFREE(tca, heap, DYNAMIC_TYPE_TLSX);
2451:../src/src/tls.c ****     }
2452:../src/src/tls.c **** }
2453:../src/src/tls.c **** 
2454:../src/src/tls.c **** /** Releases all TCA objects in the provided list. */
2455:../src/src/tls.c **** static void TLSX_TCA_FreeAll(TCA* list, void* heap)
2456:../src/src/tls.c **** {
2457:../src/src/tls.c ****     TCA* tca;
2458:../src/src/tls.c **** 
2459:../src/src/tls.c ****     while ((tca = list)) {
2460:../src/src/tls.c ****         list = tca->next;
2461:../src/src/tls.c ****         TLSX_TCA_Free(tca, heap);
2462:../src/src/tls.c ****     }
2463:../src/src/tls.c **** }
2464:../src/src/tls.c **** 
2465:../src/src/tls.c **** /** Tells the buffered size of the TCA objects in a list. */
2466:../src/src/tls.c **** static word16 TLSX_TCA_GetSize(TCA* list)
2467:../src/src/tls.c **** {
2468:../src/src/tls.c ****     TCA* tca;
2469:../src/src/tls.c ****     word16 length = OPAQUE16_LEN; /* list length */
2470:../src/src/tls.c **** 
2471:../src/src/tls.c ****     while ((tca = list)) {
2472:../src/src/tls.c ****         list = tca->next;
2473:../src/src/tls.c **** 
2474:../src/src/tls.c ****         length += ENUM_LEN; /* tca type */
2475:../src/src/tls.c **** 
2476:../src/src/tls.c ****         switch (tca->type) {
2477:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_PRE_AGREED:
2478:../src/src/tls.c ****                 break;
2479:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_KEY_SHA1:
2480:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_CERT_SHA1:
2481:../src/src/tls.c ****                 length += tca->idSz;
2482:../src/src/tls.c ****                 break;
2483:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_X509_NAME:
2484:../src/src/tls.c ****                 length += OPAQUE16_LEN + tca->idSz;
2485:../src/src/tls.c ****                 break;
2486:../src/src/tls.c ****         }
2487:../src/src/tls.c ****     }
2488:../src/src/tls.c **** 
2489:../src/src/tls.c ****     return length;
2490:../src/src/tls.c **** }
2491:../src/src/tls.c **** 
2492:../src/src/tls.c **** /** Writes the TCA objects of a list in a buffer. */
2493:../src/src/tls.c **** static word16 TLSX_TCA_Write(TCA* list, byte* output)
2494:../src/src/tls.c **** {
2495:../src/src/tls.c ****     TCA* tca;
2496:../src/src/tls.c ****     word16 offset = OPAQUE16_LEN; /* list length offset */
2497:../src/src/tls.c **** 
2498:../src/src/tls.c ****     while ((tca = list)) {
2499:../src/src/tls.c ****         list = tca->next;
2500:../src/src/tls.c **** 
2501:../src/src/tls.c ****         output[offset++] = tca->type; /* tca type */
2502:../src/src/tls.c **** 
2503:../src/src/tls.c ****         switch (tca->type) {
2504:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_PRE_AGREED:
2505:../src/src/tls.c ****                 break;
2506:../src/src/tls.c ****             #ifndef NO_SHA
2507:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_KEY_SHA1:
2508:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_CERT_SHA1:
2509:../src/src/tls.c ****                 if (tca->id != NULL) {
2510:../src/src/tls.c ****                     XMEMCPY(output + offset, tca->id, tca->idSz);
2511:../src/src/tls.c ****                     offset += tca->idSz;
2512:../src/src/tls.c ****                 }
2513:../src/src/tls.c ****                 else {
2514:../src/src/tls.c ****                     /* ID missing. Set to an empty string. */
2515:../src/src/tls.c ****                     c16toa(0, output + offset);
2516:../src/src/tls.c ****                     offset += OPAQUE16_LEN;
2517:../src/src/tls.c ****                 }
2518:../src/src/tls.c ****                 break;
2519:../src/src/tls.c ****             #endif
2520:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_X509_NAME:
2521:../src/src/tls.c ****                 if (tca->id != NULL) {
2522:../src/src/tls.c ****                     c16toa(tca->idSz, output + offset); /* tca length */
2523:../src/src/tls.c ****                     offset += OPAQUE16_LEN;
2524:../src/src/tls.c ****                     XMEMCPY(output + offset, tca->id, tca->idSz);
2525:../src/src/tls.c ****                     offset += tca->idSz;
2526:../src/src/tls.c ****                 }
2527:../src/src/tls.c ****                 else {
2528:../src/src/tls.c ****                     /* ID missing. Set to an empty string. */
2529:../src/src/tls.c ****                     c16toa(0, output + offset);
2530:../src/src/tls.c ****                     offset += OPAQUE16_LEN;
2531:../src/src/tls.c ****                 }
2532:../src/src/tls.c ****                 break;
2533:../src/src/tls.c ****             default:
2534:../src/src/tls.c ****                 /* ID unknown. Set to an empty string. */
2535:../src/src/tls.c ****                 c16toa(0, output + offset);
2536:../src/src/tls.c ****                 offset += OPAQUE16_LEN;
2537:../src/src/tls.c ****         }
2538:../src/src/tls.c ****     }
2539:../src/src/tls.c **** 
2540:../src/src/tls.c ****     c16toa(offset - OPAQUE16_LEN, output); /* writing list length */
2541:../src/src/tls.c **** 
2542:../src/src/tls.c ****     return offset;
2543:../src/src/tls.c **** }
2544:../src/src/tls.c **** 
2545:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
2546:../src/src/tls.c **** static TCA* TLSX_TCA_Find(TCA *list, byte type, const byte* id, word16 idSz)
2547:../src/src/tls.c **** {
2548:../src/src/tls.c ****     TCA* tca = list;
2549:../src/src/tls.c **** 
2550:../src/src/tls.c ****     while (tca && tca->type != type && type != WOLFSSL_TRUSTED_CA_PRE_AGREED &&
2551:../src/src/tls.c ****            idSz != tca->idSz && !XMEMCMP(id, tca->id, idSz))
2552:../src/src/tls.c ****         tca = tca->next;
2553:../src/src/tls.c **** 
2554:../src/src/tls.c ****     return tca;
2555:../src/src/tls.c **** }
2556:../src/src/tls.c **** #endif /* NO_WOLFSSL_SERVER */
2557:../src/src/tls.c **** 
2558:../src/src/tls.c **** /** Parses a buffer of TCA extensions. */
2559:../src/src/tls.c **** static int TLSX_TCA_Parse(WOLFSSL* ssl, const byte* input, word16 length,
2560:../src/src/tls.c ****                           byte isRequest)
2561:../src/src/tls.c **** {
2562:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
2563:../src/src/tls.c ****     word16 size = 0;
2564:../src/src/tls.c ****     word16 offset = 0;
2565:../src/src/tls.c **** #endif
2566:../src/src/tls.c **** 
2567:../src/src/tls.c ****     TLSX *extension = TLSX_Find(ssl->extensions, TLSX_TRUSTED_CA_KEYS);
2568:../src/src/tls.c **** 
2569:../src/src/tls.c ****     if (!extension)
2570:../src/src/tls.c ****         extension = TLSX_Find(ssl->ctx->extensions, TLSX_TRUSTED_CA_KEYS);
2571:../src/src/tls.c **** 
2572:../src/src/tls.c ****     if (!isRequest) {
2573:../src/src/tls.c ****         #ifndef NO_WOLFSSL_CLIENT
2574:../src/src/tls.c ****             if (!extension || !extension->data)
2575:../src/src/tls.c ****                 return TLSX_HandleUnsupportedExtension(ssl);
2576:../src/src/tls.c **** 
2577:../src/src/tls.c ****             if (length > 0)
2578:../src/src/tls.c ****                 return BUFFER_ERROR; /* TCA response MUST be empty. */
2579:../src/src/tls.c **** 
2580:../src/src/tls.c ****             /* Set the flag that we're good for keys */
2581:../src/src/tls.c ****             TLSX_SetResponse(ssl, TLSX_TRUSTED_CA_KEYS);
2582:../src/src/tls.c **** 
2583:../src/src/tls.c ****             return 0;
2584:../src/src/tls.c ****         #endif
2585:../src/src/tls.c ****     }
2586:../src/src/tls.c **** 
2587:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
2588:../src/src/tls.c ****     if (!extension || !extension->data) {
2589:../src/src/tls.c ****         /* Skipping, TCA not enabled at server side. */
2590:../src/src/tls.c ****         return 0;
2591:../src/src/tls.c ****     }
2592:../src/src/tls.c **** 
2593:../src/src/tls.c ****     if (OPAQUE16_LEN > length)
2594:../src/src/tls.c ****         return BUFFER_ERROR;
2595:../src/src/tls.c **** 
2596:../src/src/tls.c ****     ato16(input, &size);
2597:../src/src/tls.c ****     offset += OPAQUE16_LEN;
2598:../src/src/tls.c **** 
2599:../src/src/tls.c ****     /* validating tca list length */
2600:../src/src/tls.c ****     if (length != OPAQUE16_LEN + size)
2601:../src/src/tls.c ****         return BUFFER_ERROR;
2602:../src/src/tls.c **** 
2603:../src/src/tls.c ****     for (size = 0; offset < length; offset += size) {
2604:../src/src/tls.c ****         TCA *tca = NULL;
2605:../src/src/tls.c ****         byte type;
2606:../src/src/tls.c ****         const byte* id = NULL;
2607:../src/src/tls.c ****         word16 idSz = 0;
2608:../src/src/tls.c **** 
2609:../src/src/tls.c ****         if (offset + ENUM_LEN > length)
2610:../src/src/tls.c ****             return BUFFER_ERROR;
2611:../src/src/tls.c **** 
2612:../src/src/tls.c ****         type = input[offset++];
2613:../src/src/tls.c **** 
2614:../src/src/tls.c ****         switch (type) {
2615:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_PRE_AGREED:
2616:../src/src/tls.c ****                 break;
2617:../src/src/tls.c ****             #ifndef NO_SHA
2618:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_KEY_SHA1:
2619:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_CERT_SHA1:
2620:../src/src/tls.c ****                 if (offset + WC_SHA_DIGEST_SIZE > length)
2621:../src/src/tls.c ****                     return BUFFER_ERROR;
2622:../src/src/tls.c ****                 idSz = WC_SHA_DIGEST_SIZE;
2623:../src/src/tls.c ****                 id = input + offset;
2624:../src/src/tls.c ****                 offset += idSz;
2625:../src/src/tls.c ****                 break;
2626:../src/src/tls.c ****             #endif
2627:../src/src/tls.c ****             case WOLFSSL_TRUSTED_CA_X509_NAME:
2628:../src/src/tls.c ****                 if (offset + OPAQUE16_LEN > length)
2629:../src/src/tls.c ****                     return BUFFER_ERROR;
2630:../src/src/tls.c ****                 ato16(input + offset, &idSz);
2631:../src/src/tls.c ****                 offset += OPAQUE16_LEN;
2632:../src/src/tls.c ****                 if ((offset > length) || (idSz > length - offset))
2633:../src/src/tls.c ****                     return BUFFER_ERROR;
2634:../src/src/tls.c ****                 id = input + offset;
2635:../src/src/tls.c ****                 offset += idSz;
2636:../src/src/tls.c ****                 break;
2637:../src/src/tls.c ****             default:
2638:../src/src/tls.c ****                 return TCA_INVALID_ID_TYPE;
2639:../src/src/tls.c ****         }
2640:../src/src/tls.c **** 
2641:../src/src/tls.c ****         /* Find the type/ID in the TCA list. */
2642:../src/src/tls.c ****         tca = TLSX_TCA_Find((TCA*)extension->data, type, id, idSz);
2643:../src/src/tls.c ****         if (tca != NULL) {
2644:../src/src/tls.c ****             /* Found it. Set the response flag and break out of the loop. */
2645:../src/src/tls.c ****             TLSX_SetResponse(ssl, TLSX_TRUSTED_CA_KEYS);
2646:../src/src/tls.c ****             break;
2647:../src/src/tls.c ****         }
2648:../src/src/tls.c ****     }
2649:../src/src/tls.c **** #else
2650:../src/src/tls.c ****     (void)input;
2651:../src/src/tls.c **** #endif
2652:../src/src/tls.c **** 
2653:../src/src/tls.c ****     return 0;
2654:../src/src/tls.c **** }
2655:../src/src/tls.c **** 
2656:../src/src/tls.c **** /* Checks to see if the server sent a response for the TCA. */
2657:../src/src/tls.c **** static int TLSX_TCA_VerifyParse(WOLFSSL* ssl, byte isRequest)
2658:../src/src/tls.c **** {
2659:../src/src/tls.c ****     (void)ssl;
2660:../src/src/tls.c **** 
2661:../src/src/tls.c ****     if (!isRequest) {
2662:../src/src/tls.c ****     #ifndef NO_WOLFSSL_CLIENT
2663:../src/src/tls.c ****         TLSX* extension = TLSX_Find(ssl->extensions, TLSX_TRUSTED_CA_KEYS);
2664:../src/src/tls.c **** 
2665:../src/src/tls.c ****         if (extension && !extension->resp) {
2666:../src/src/tls.c ****             SendAlert(ssl, alert_fatal, handshake_failure);
2667:../src/src/tls.c ****             return TCA_ABSENT_ERROR;
2668:../src/src/tls.c ****         }
2669:../src/src/tls.c ****     #endif /* NO_WOLFSSL_CLIENT */
2670:../src/src/tls.c ****     }
2671:../src/src/tls.c **** 
2672:../src/src/tls.c ****     return 0;
2673:../src/src/tls.c **** }
2674:../src/src/tls.c **** 
2675:../src/src/tls.c **** int TLSX_UseTrustedCA(TLSX** extensions, byte type,
2676:../src/src/tls.c ****                     const byte* id, word16 idSz, void* heap)
2677:../src/src/tls.c **** {
2678:../src/src/tls.c ****     TLSX* extension;
2679:../src/src/tls.c ****     TCA* tca = NULL;
2680:../src/src/tls.c **** 
2681:../src/src/tls.c ****     if (extensions == NULL)
2682:../src/src/tls.c ****         return BAD_FUNC_ARG;
2683:../src/src/tls.c **** 
2684:../src/src/tls.c ****     if ((tca = TLSX_TCA_New(type, id, idSz, heap)) == NULL)
2685:../src/src/tls.c ****         return MEMORY_E;
2686:../src/src/tls.c **** 
2687:../src/src/tls.c ****     extension = TLSX_Find(*extensions, TLSX_TRUSTED_CA_KEYS);
2688:../src/src/tls.c ****     if (!extension) {
2689:../src/src/tls.c ****         int ret = TLSX_Push(extensions, TLSX_TRUSTED_CA_KEYS, (void*)tca, heap);
2690:../src/src/tls.c **** 
2691:../src/src/tls.c ****         if (ret != 0) {
2692:../src/src/tls.c ****             TLSX_TCA_Free(tca, heap);
2693:../src/src/tls.c ****             return ret;
2694:../src/src/tls.c ****         }
2695:../src/src/tls.c ****     }
2696:../src/src/tls.c ****     else {
2697:../src/src/tls.c ****         /* push new TCA object to extension data. */
2698:../src/src/tls.c ****         tca->next = (TCA*)extension->data;
2699:../src/src/tls.c ****         extension->data = (void*)tca;
2700:../src/src/tls.c ****     }
2701:../src/src/tls.c **** 
2702:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
2703:../src/src/tls.c **** }
2704:../src/src/tls.c **** 
2705:../src/src/tls.c **** #define TCA_FREE_ALL     TLSX_TCA_FreeAll
2706:../src/src/tls.c **** #define TCA_GET_SIZE     TLSX_TCA_GetSize
2707:../src/src/tls.c **** #define TCA_WRITE        TLSX_TCA_Write
2708:../src/src/tls.c **** #define TCA_PARSE        TLSX_TCA_Parse
2709:../src/src/tls.c **** #define TCA_VERIFY_PARSE TLSX_TCA_VerifyParse
2710:../src/src/tls.c **** 
2711:../src/src/tls.c **** #else /* HAVE_TRUSTED_CA */
2712:../src/src/tls.c **** 
2713:../src/src/tls.c **** #define TCA_FREE_ALL(list, heap)
2714:../src/src/tls.c **** #define TCA_GET_SIZE(list)     0
2715:../src/src/tls.c **** #define TCA_WRITE(a, b)        0
2716:../src/src/tls.c **** #define TCA_PARSE(a, b, c, d)  0
2717:../src/src/tls.c **** #define TCA_VERIFY_PARSE(a, b) 0
2718:../src/src/tls.c **** 
2719:../src/src/tls.c **** #endif /* HAVE_TRUSTED_CA */
2720:../src/src/tls.c **** 
2721:../src/src/tls.c **** /******************************************************************************/
2722:../src/src/tls.c **** /* Max Fragment Length Negotiation                                            */
2723:../src/src/tls.c **** /******************************************************************************/
2724:../src/src/tls.c **** 
2725:../src/src/tls.c **** #ifdef HAVE_MAX_FRAGMENT
2726:../src/src/tls.c **** 
2727:../src/src/tls.c **** static word16 TLSX_MFL_Write(byte* data, byte* output)
2728:../src/src/tls.c **** {
2729:../src/src/tls.c ****     output[0] = data[0];
2730:../src/src/tls.c **** 
2731:../src/src/tls.c ****     return ENUM_LEN;
2732:../src/src/tls.c **** }
2733:../src/src/tls.c **** 
2734:../src/src/tls.c **** static int TLSX_MFL_Parse(WOLFSSL* ssl, const byte* input, word16 length,
2735:../src/src/tls.c ****                           byte isRequest)
2736:../src/src/tls.c **** {
2737:../src/src/tls.c ****     if (length != ENUM_LEN)
2738:../src/src/tls.c ****         return BUFFER_ERROR;
2739:../src/src/tls.c **** 
2740:../src/src/tls.c **** #ifdef WOLFSSL_OLD_UNSUPPORTED_EXTENSION
2741:../src/src/tls.c ****     (void) isRequest;
2742:../src/src/tls.c **** #else
2743:../src/src/tls.c ****     if (!isRequest)
2744:../src/src/tls.c ****         if (TLSX_CheckUnsupportedExtension(ssl, TLSX_MAX_FRAGMENT_LENGTH))
2745:../src/src/tls.c ****             return TLSX_HandleUnsupportedExtension(ssl);
2746:../src/src/tls.c **** #endif
2747:../src/src/tls.c **** 
2748:../src/src/tls.c ****     switch (*input) {
2749:../src/src/tls.c ****         case WOLFSSL_MFL_2_8 : ssl->max_fragment =  256; break;
2750:../src/src/tls.c ****         case WOLFSSL_MFL_2_9 : ssl->max_fragment =  512; break;
2751:../src/src/tls.c ****         case WOLFSSL_MFL_2_10: ssl->max_fragment = 1024; break;
2752:../src/src/tls.c ****         case WOLFSSL_MFL_2_11: ssl->max_fragment = 2048; break;
2753:../src/src/tls.c ****         case WOLFSSL_MFL_2_12: ssl->max_fragment = 4096; break;
2754:../src/src/tls.c ****         case WOLFSSL_MFL_2_13: ssl->max_fragment = 8192; break;
2755:../src/src/tls.c **** 
2756:../src/src/tls.c ****         default:
2757:../src/src/tls.c ****             SendAlert(ssl, alert_fatal, illegal_parameter);
2758:../src/src/tls.c **** 
2759:../src/src/tls.c ****             return UNKNOWN_MAX_FRAG_LEN_E;
2760:../src/src/tls.c ****     }
2761:../src/src/tls.c **** 
2762:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
2763:../src/src/tls.c ****     if (isRequest) {
2764:../src/src/tls.c ****         int ret = TLSX_UseMaxFragment(&ssl->extensions, *input, ssl->heap);
2765:../src/src/tls.c **** 
2766:../src/src/tls.c ****         if (ret != WOLFSSL_SUCCESS)
2767:../src/src/tls.c ****             return ret; /* throw error */
2768:../src/src/tls.c **** 
2769:../src/src/tls.c ****         TLSX_SetResponse(ssl, TLSX_MAX_FRAGMENT_LENGTH);
2770:../src/src/tls.c ****     }
2771:../src/src/tls.c **** #endif
2772:../src/src/tls.c **** 
2773:../src/src/tls.c ****     return 0;
2774:../src/src/tls.c **** }
2775:../src/src/tls.c **** 
2776:../src/src/tls.c **** int TLSX_UseMaxFragment(TLSX** extensions, byte mfl, void* heap)
2777:../src/src/tls.c **** {
2778:../src/src/tls.c ****     byte* data = NULL;
2779:../src/src/tls.c ****     int ret = 0;
2780:../src/src/tls.c **** 
2781:../src/src/tls.c ****     if (extensions == NULL || mfl < WOLFSSL_MFL_MIN || mfl > WOLFSSL_MFL_MAX)
2782:../src/src/tls.c ****         return BAD_FUNC_ARG;
2783:../src/src/tls.c **** 
2784:../src/src/tls.c ****     data = (byte*)XMALLOC(ENUM_LEN, heap, DYNAMIC_TYPE_TLSX);
2785:../src/src/tls.c ****     if (data == NULL)
2786:../src/src/tls.c ****         return MEMORY_E;
2787:../src/src/tls.c **** 
2788:../src/src/tls.c ****     data[0] = mfl;
2789:../src/src/tls.c **** 
2790:../src/src/tls.c ****     ret = TLSX_Push(extensions, TLSX_MAX_FRAGMENT_LENGTH, data, heap);
2791:../src/src/tls.c ****     if (ret != 0) {
2792:../src/src/tls.c ****         XFREE(data, heap, DYNAMIC_TYPE_TLSX);
2793:../src/src/tls.c ****         return ret;
2794:../src/src/tls.c ****     }
2795:../src/src/tls.c **** 
2796:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
2797:../src/src/tls.c **** }
2798:../src/src/tls.c **** 
2799:../src/src/tls.c **** 
2800:../src/src/tls.c **** #define MFL_FREE_ALL(data, heap) XFREE(data, (heap), DYNAMIC_TYPE_TLSX)
2801:../src/src/tls.c **** #define MFL_GET_SIZE(data) ENUM_LEN
2802:../src/src/tls.c **** #define MFL_WRITE          TLSX_MFL_Write
2803:../src/src/tls.c **** #define MFL_PARSE          TLSX_MFL_Parse
2804:../src/src/tls.c **** 
2805:../src/src/tls.c **** #else
2806:../src/src/tls.c **** 
2807:../src/src/tls.c **** #define MFL_FREE_ALL(a, b)
2808:../src/src/tls.c **** #define MFL_GET_SIZE(a)       0
2809:../src/src/tls.c **** #define MFL_WRITE(a, b)       0
2810:../src/src/tls.c **** #define MFL_PARSE(a, b, c, d) 0
2811:../src/src/tls.c **** 
2812:../src/src/tls.c **** #endif /* HAVE_MAX_FRAGMENT */
2813:../src/src/tls.c **** 
2814:../src/src/tls.c **** /******************************************************************************/
2815:../src/src/tls.c **** /* Truncated HMAC                                                             */
2816:../src/src/tls.c **** /******************************************************************************/
2817:../src/src/tls.c **** 
2818:../src/src/tls.c **** #ifdef HAVE_TRUNCATED_HMAC
2819:../src/src/tls.c **** 
2820:../src/src/tls.c **** static int TLSX_THM_Parse(WOLFSSL* ssl, const byte* input, word16 length,
2821:../src/src/tls.c ****                           byte isRequest)
2822:../src/src/tls.c **** {
2823:../src/src/tls.c ****     if (length != 0 || input == NULL)
2824:../src/src/tls.c ****         return BUFFER_ERROR;
2825:../src/src/tls.c **** 
2826:../src/src/tls.c ****     if (!isRequest) {
2827:../src/src/tls.c ****     #ifndef WOLFSSL_OLD_UNSUPPORTED_EXTENSION
2828:../src/src/tls.c ****         if (TLSX_CheckUnsupportedExtension(ssl, TLSX_TRUNCATED_HMAC))
2829:../src/src/tls.c ****             return TLSX_HandleUnsupportedExtension(ssl);
2830:../src/src/tls.c ****     #endif
2831:../src/src/tls.c ****     }
2832:../src/src/tls.c ****     else {
2833:../src/src/tls.c ****         #ifndef NO_WOLFSSL_SERVER
2834:../src/src/tls.c ****             int ret = TLSX_UseTruncatedHMAC(&ssl->extensions, ssl->heap);
2835:../src/src/tls.c **** 
2836:../src/src/tls.c ****             if (ret != WOLFSSL_SUCCESS)
2837:../src/src/tls.c ****                 return ret; /* throw error */
2838:../src/src/tls.c **** 
2839:../src/src/tls.c ****             TLSX_SetResponse(ssl, TLSX_TRUNCATED_HMAC);
2840:../src/src/tls.c ****         #endif
2841:../src/src/tls.c ****     }
2842:../src/src/tls.c **** 
2843:../src/src/tls.c ****     ssl->truncated_hmac = 1;
2844:../src/src/tls.c **** 
2845:../src/src/tls.c ****     return 0;
2846:../src/src/tls.c **** }
2847:../src/src/tls.c **** 
2848:../src/src/tls.c **** int TLSX_UseTruncatedHMAC(TLSX** extensions, void* heap)
2849:../src/src/tls.c **** {
2850:../src/src/tls.c ****     int ret = 0;
2851:../src/src/tls.c **** 
2852:../src/src/tls.c ****     if (extensions == NULL)
2853:../src/src/tls.c ****         return BAD_FUNC_ARG;
2854:../src/src/tls.c **** 
2855:../src/src/tls.c ****     ret = TLSX_Push(extensions, TLSX_TRUNCATED_HMAC, NULL, heap);
2856:../src/src/tls.c ****     if (ret != 0)
2857:../src/src/tls.c ****         return ret;
2858:../src/src/tls.c **** 
2859:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
2860:../src/src/tls.c **** }
2861:../src/src/tls.c **** 
2862:../src/src/tls.c **** #define THM_PARSE TLSX_THM_Parse
2863:../src/src/tls.c **** 
2864:../src/src/tls.c **** #else
2865:../src/src/tls.c **** 
2866:../src/src/tls.c **** #define THM_PARSE(a, b, c, d) 0
2867:../src/src/tls.c **** 
2868:../src/src/tls.c **** #endif /* HAVE_TRUNCATED_HMAC */
2869:../src/src/tls.c **** 
2870:../src/src/tls.c **** /******************************************************************************/
2871:../src/src/tls.c **** /* Certificate Status Request                                                 */
2872:../src/src/tls.c **** /******************************************************************************/
2873:../src/src/tls.c **** 
2874:../src/src/tls.c **** #ifdef HAVE_CERTIFICATE_STATUS_REQUEST
2875:../src/src/tls.c **** 
2876:../src/src/tls.c **** static void TLSX_CSR_Free(CertificateStatusRequest* csr, void* heap)
2877:../src/src/tls.c **** {
 2574                             		.loc 2 2877 1
 2575 0000 7E AA                   		push.l	r10
 2576                             	.LCFI80:
 2577 0002 71 0A F4                		add	#-12, r0, r10
 2578                             	.LCFI81:
 2579 0005 EF A0                   		mov.L	r10, r0
 2580 0007 E7 A1 01                		mov.L	r1, 4[r10]
 2581 000a E7 A2 02                		mov.L	r2, 8[r10]
2878:../src/src/tls.c ****     switch (csr->status_type) {
 2582                             		.loc 2 2878 16
 2583 000d ED A5 01                		mov.L	4[r10], r5
 2584 0010 CC 55                   		mov.B	[r5], r5
 2585 0012 5B 55                   		movu.B	r5, r5
 2586                             		.loc 2 2878 5
 2587 0014 61 15                   		cmp	#1, r5
 2588 0016 21 0E                   		bne	.L150
2879:../src/src/tls.c ****         case WOLFSSL_CSR_OCSP:
2880:../src/src/tls.c ****             FreeOcspRequest(&csr->request.ocsp);
 2589                             		.loc 2 2880 13
 2590 0018 ED A5 01                		mov.L	4[r10], r5
 2591 001b 62 85                   		add	#8, r5
 2592 001d EF 51                   		mov.L	r5, r1
 2593 001f 05 00 00 00             		bsr	_FreeOcspRequest
2881:../src/src/tls.c ****         break;
 2594                             		.loc 2 2881 9
 2595 0023 03                      		nop
 2596                             	.L150:
 2597                             	.LBB7:
2882:../src/src/tls.c ****     }
2883:../src/src/tls.c **** 
2884:../src/src/tls.c ****     XFREE(csr, heap, DYNAMIC_TYPE_TLSX);
 2598                             		.loc 2 2884 5
 2599 0024 ED A5 01                		mov.L	4[r10], r5
 2600 0027 E3 A5                   		mov.L	r5, [r10]
 2601 0029 EC A5                   		mov.L	[r10], r5
 2602 002b 61 05                   		cmp	#0, r5
 2603 002d 17                      		beq	.L152
 2604                             		.loc 2 2884 5 is_stmt 0 discriminator 1
 2605 002e EC A1                   		mov.L	[r10], r1
 2606 0030 05 00 00 00             		bsr	_wolfSSL_Free
 2607                             	.L152:
 2608                             	.LBE7:
2885:../src/src/tls.c ****     (void)heap;
2886:../src/src/tls.c **** }
 2609                             		.loc 2 2886 1 is_stmt 1
 2610 0034 03                      		nop
 2611 0035 3F AA 04                		rtsd	#16, r10-r10
 2612                             	.LFE67:
 2614                             		.section	.text.TLSX_CSR_GetSize,"ax",@progbits
 2616                             	_TLSX_CSR_GetSize:
 2617                             	.LFB68:
2887:../src/src/tls.c **** 
2888:../src/src/tls.c **** static word16 TLSX_CSR_GetSize(CertificateStatusRequest* csr, byte isRequest)
2889:../src/src/tls.c **** {
 2618                             		.loc 2 2889 1
 2619 0000 7E AA                   		push.l	r10
 2620                             	.LCFI82:
 2621 0002 71 0A F4                		add	#-12, r0, r10
 2622                             	.LCFI83:
 2623 0005 EF A0                   		mov.L	r10, r0
 2624 0007 E7 A1 01                		mov.L	r1, 4[r10]
 2625 000a C7 A2 08                		mov.B	r2, 8[r10]
2890:../src/src/tls.c ****     word16 size = 0;
 2626                             		.loc 2 2890 12
 2627 000d F8 A5 00                		mov.W	#0, [r10]
2891:../src/src/tls.c **** 
2892:../src/src/tls.c ****     /* shut up compiler warnings */
2893:../src/src/tls.c ****     (void) csr; (void) isRequest;
2894:../src/src/tls.c **** 
2895:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
2896:../src/src/tls.c ****     if (isRequest) {
 2628                             		.loc 2 2896 8
 2629 0010 59 A5 08                		movu.B	8[r10], r5
 2630 0013 61 05                   		cmp	#0, r5
 2631 0015 20 24                   		beq	.L157
2897:../src/src/tls.c ****         switch (csr->status_type) {
 2632                             		.loc 2 2897 20
 2633 0017 ED A5 01                		mov.L	4[r10], r5
 2634 001a CC 55                   		mov.B	[r5], r5
 2635 001c 5B 55                   		movu.B	r5, r5
 2636                             		.loc 2 2897 9
 2637 001e 61 15                   		cmp	#1, r5
 2638 0020 21 1D                   		bne	.L154
2898:../src/src/tls.c ****             case WOLFSSL_CSR_OCSP:
2899:../src/src/tls.c ****                 size += ENUM_LEN + 2 * OPAQUE16_LEN;
 2639                             		.loc 2 2899 22
 2640 0022 DC A5                   		mov.W	[r10], r5
 2641 0024 62 55                   		add	#5, r5
 2642 0026 D3 A5                   		mov.W	r5, [r10]
2900:../src/src/tls.c **** 
2901:../src/src/tls.c ****                 if (csr->request.ocsp.nonceSz)
 2643                             		.loc 2 2901 38
 2644 0028 ED A5 01                		mov.L	4[r10], r5
 2645 002b AD 55                   		mov.L	80[r5], r5
 2646                             		.loc 2 2901 20
 2647 002d 61 05                   		cmp	#0, r5
 2648 002f 20 0D                   		beq	.L158
2902:../src/src/tls.c ****                     size += OCSP_NONCE_EXT_SZ;
 2649                             		.loc 2 2902 26
 2650 0031 DC A5                   		mov.W	[r10], r5
 2651 0033 71 55 23                		add	#35, r5
 2652 0036 D3 A5                   		mov.W	r5, [r10]
2903:../src/src/tls.c ****             break;
 2653                             		.loc 2 2903 13
 2654 0038 0C                      		bra	.L158
 2655                             	.L157:
2904:../src/src/tls.c ****         }
2905:../src/src/tls.c ****     }
 2656                             		.loc 2 2905 5
 2657 0039 03                      		nop
 2658 003a 2E 03                   		bra	.L154
 2659                             	.L158:
2903:../src/src/tls.c ****             break;
 2660                             		.loc 2 2903 13
 2661 003c 03                      		nop
 2662                             	.L154:
2906:../src/src/tls.c **** #endif
2907:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && !defined(NO_WOLFSSL_SERVER)
2908:../src/src/tls.c ****     if (!isRequest && csr->ssl->options.tls1_3)
2909:../src/src/tls.c ****         return OPAQUE8_LEN + OPAQUE24_LEN + csr->response.length;
2910:../src/src/tls.c **** #endif
2911:../src/src/tls.c **** 
2912:../src/src/tls.c ****     return size;
 2663                             		.loc 2 2912 12
 2664 003d DC A5                   		mov.W	[r10], r5
 2665 003f 5F 55                   		movu.W	r5, r5
2913:../src/src/tls.c **** }
 2666                             		.loc 2 2913 1
 2667 0041 EF 51                   		mov.L	r5, r1
 2668 0043 3F AA 04                		rtsd	#16, r10-r10
 2669                             	.LFE68:
 2671                             		.section	.text.TLSX_CSR_Write,"ax",@progbits
 2673                             	_TLSX_CSR_Write:
 2674                             	.LFB69:
2914:../src/src/tls.c **** 
2915:../src/src/tls.c **** static word16 TLSX_CSR_Write(CertificateStatusRequest* csr, byte* output,
2916:../src/src/tls.c ****                                                                  byte isRequest)
2917:../src/src/tls.c **** {
 2675                             		.loc 2 2917 1
 2676 0000 7E AA                   		push.l	r10
 2677                             	.LCFI84:
 2678 0002 71 0A F0                		add	#-16, r0, r10
 2679                             	.LCFI85:
 2680 0005 EF A0                   		mov.L	r10, r0
 2681 0007 E7 A1 01                		mov.L	r1, 4[r10]
 2682 000a E7 A2 02                		mov.L	r2, 8[r10]
 2683 000d C7 A3 0C                		mov.B	r3, 12[r10]
2918:../src/src/tls.c ****     /* shut up compiler warnings */
2919:../src/src/tls.c ****     (void) csr; (void) output; (void) isRequest;
2920:../src/src/tls.c **** 
2921:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
2922:../src/src/tls.c ****     if (isRequest) {
 2684                             		.loc 2 2922 8
 2685 0010 59 A5 0C                		movu.B	12[r10], r5
 2686 0013 61 05                   		cmp	#0, r5
 2687 0015 3A 84 00                		beq	.L160
 2688                             	.LBB8:
2923:../src/src/tls.c ****         word16 offset = 0;
 2689                             		.loc 2 2923 16
 2690 0018 F8 A5 00                		mov.W	#0, [r10]
2924:../src/src/tls.c ****         word16 length = 0;
 2691                             		.loc 2 2924 16
 2692 001b F9 A5 01 00             		mov.W	#0, 2[r10]
2925:../src/src/tls.c **** 
2926:../src/src/tls.c ****         /* type */
2927:../src/src/tls.c ****         output[offset++] = csr->status_type;
 2693                             		.loc 2 2927 22
 2694 001f DC A5                   		mov.W	[r10], r5
 2695 0021 71 54 01                		add	#1, r5, r4
 2696 0024 D3 A4                   		mov.W	r4, [r10]
 2697 0026 5F 55                   		movu.W	r5, r5
 2698                             		.loc 2 2927 15
 2699 0028 ED A4 02                		mov.L	8[r10], r4
 2700 002b 4B 45                   		add	r4, r5
 2701                             		.loc 2 2927 31
 2702 002d ED A4 01                		mov.L	4[r10], r4
 2703 0030 CC 44                   		mov.B	[r4], r4
 2704                             		.loc 2 2927 26
 2705 0032 C3 54                   		mov.B	r4, [r5]
2928:../src/src/tls.c **** 
2929:../src/src/tls.c ****         switch (csr->status_type) {
 2706                             		.loc 2 2929 20
 2707 0034 ED A5 01                		mov.L	4[r10], r5
 2708 0037 CC 55                   		mov.B	[r5], r5
 2709 0039 5B 55                   		movu.B	r5, r5
 2710                             		.loc 2 2929 9
 2711 003b 61 15                   		cmp	#1, r5
 2712 003d 21 59                   		bne	.L161
2930:../src/src/tls.c ****             case WOLFSSL_CSR_OCSP:
2931:../src/src/tls.c ****                 /* responder id list */
2932:../src/src/tls.c ****                 c16toa(0, output + offset);
 2713                             		.loc 2 2932 17
 2714 003f 5C A5                   		movu.W	[r10], r5
 2715 0041 ED A4 02                		mov.L	8[r10], r4
 2716 0044 4B 45                   		add	r4, r5
 2717 0046 EF 52                   		mov.L	r5, r2
 2718 0048 66 01                   		mov	#0, r1
 2719 004a 05 00 00 00             		bsr	_c16toa
2933:../src/src/tls.c ****                 offset += OPAQUE16_LEN;
 2720                             		.loc 2 2933 24
 2721 004e DC A5                   		mov.W	[r10], r5
 2722 0050 62 25                   		add	#2, r5
 2723 0052 D3 A5                   		mov.W	r5, [r10]
2934:../src/src/tls.c **** 
2935:../src/src/tls.c ****                 /* request extensions */
2936:../src/src/tls.c ****                 if (csr->request.ocsp.nonceSz)
 2724                             		.loc 2 2936 38
 2725 0054 ED A5 01                		mov.L	4[r10], r5
 2726 0057 AD 55                   		mov.L	80[r5], r5
 2727                             		.loc 2 2936 20
 2728 0059 61 05                   		cmp	#0, r5
 2729 005b 20 1F                   		beq	.L162
2937:../src/src/tls.c ****                     length = (word16)EncodeOcspRequestExtensions(
 2730                             		.loc 2 2937 38
 2731 005d ED A5 01                		mov.L	4[r10], r5
 2732 0060 71 51 08                		add	#8, r5, r1
2938:../src/src/tls.c ****                                                  &csr->request.ocsp,
2939:../src/src/tls.c ****                                                  output + offset + OPAQUE16_LEN,
 2733                             		.loc 2 2939 66
 2734 0063 5C A5                   		movu.W	[r10], r5
 2735 0065 62 25                   		add	#2, r5
2937:../src/src/tls.c ****                     length = (word16)EncodeOcspRequestExtensions(
 2736                             		.loc 2 2937 38
 2737 0067 ED A4 02                		mov.L	8[r10], r4
 2738 006a 4B 45                   		add	r4, r5
 2739 006c 75 43 23                		mov.L	#35, r3
 2740 006f EF 52                   		mov.L	r5, r2
 2741 0071 05 00 00 00             		bsr	_EncodeOcspRequestExtensions
 2742 0075 EF 15                   		mov.L	r1, r5
2937:../src/src/tls.c ****                     length = (word16)EncodeOcspRequestExtensions(
 2743                             		.loc 2 2937 28
 2744 0077 D7 A5 01                		mov.W	r5, 2[r10]
 2745                             	.L162:
2940:../src/src/tls.c ****                                                  OCSP_NONCE_EXT_SZ);
2941:../src/src/tls.c **** 
2942:../src/src/tls.c ****                 c16toa(length, output + offset);
 2746                             		.loc 2 2942 17
 2747 007a 5C A5                   		movu.W	[r10], r5
 2748 007c ED A4 02                		mov.L	8[r10], r4
 2749 007f 4B 45                   		add	r4, r5
 2750 0081 EF 52                   		mov.L	r5, r2
 2751 0083 DD A1 01                		mov.W	2[r10], r1
 2752 0086 05 00 00 00             		bsr	_c16toa
2943:../src/src/tls.c ****                 offset += OPAQUE16_LEN + length;
 2753                             		.loc 2 2943 24
 2754 008a DD A4 01                		mov.W	2[r10], r4
 2755 008d DC A5                   		mov.W	[r10], r5
 2756 008f 4B 45                   		add	r4, r5
 2757 0091 62 25                   		add	#2, r5
 2758 0093 D3 A5                   		mov.W	r5, [r10]
2944:../src/src/tls.c **** 
2945:../src/src/tls.c ****             break;
 2759                             		.loc 2 2945 13
 2760 0095 03                      		nop
 2761                             	.L161:
2946:../src/src/tls.c ****         }
2947:../src/src/tls.c **** 
2948:../src/src/tls.c ****         return offset;
 2762                             		.loc 2 2948 16
 2763 0096 DC A5                   		mov.W	[r10], r5
 2764 0098 0B                      		bra	.L163
 2765                             	.L160:
 2766                             	.LBE8:
2949:../src/src/tls.c ****     }
2950:../src/src/tls.c **** #endif
2951:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && !defined(NO_WOLFSSL_SERVER)
2952:../src/src/tls.c ****     if (!isRequest && csr->ssl->options.tls1_3) {
2953:../src/src/tls.c ****         word16 offset = 0;
2954:../src/src/tls.c ****         output[offset++] = csr->status_type;
2955:../src/src/tls.c ****         c32to24(csr->response.length, output + offset);
2956:../src/src/tls.c ****         offset += OPAQUE24_LEN;
2957:../src/src/tls.c ****         XMEMCPY(output + offset, csr->response.buffer, csr->response.length);
2958:../src/src/tls.c ****         offset += csr->response.length;
2959:../src/src/tls.c ****         return offset;
2960:../src/src/tls.c ****     }
2961:../src/src/tls.c **** #endif
2962:../src/src/tls.c **** 
2963:../src/src/tls.c ****     return 0;
 2767                             		.loc 2 2963 12
 2768 0099 66 05                   		mov	#0, r5
 2769                             	.L163:
 2770 009b 5F 55                   		movu.W	r5, r5
2964:../src/src/tls.c **** }
 2771                             		.loc 2 2964 1
 2772 009d EF 51                   		mov.L	r5, r1
 2773 009f 3F AA 05                		rtsd	#20, r10-r10
 2774                             	.LFE69:
 2776                             		.section	.text.TLSX_CSR_Parse,"ax",@progbits
 2778                             	_TLSX_CSR_Parse:
 2779                             	.LFB70:
2965:../src/src/tls.c **** 
2966:../src/src/tls.c **** static int TLSX_CSR_Parse(WOLFSSL* ssl, const byte* input, word16 length,
2967:../src/src/tls.c ****                           byte isRequest)
2968:../src/src/tls.c **** {
 2780                             		.loc 2 2968 1
 2781 0000 7E AA                   		push.l	r10
 2782                             	.LCFI86:
 2783 0002 71 0A DC                		add	#-36, r0, r10
 2784                             	.LCFI87:
 2785 0005 71 A0 F8                		add	#-8, r10, r0
 2786                             	.LCFI88:
 2787 0008 E7 A1 06                		mov.L	r1, 24[r10]
 2788 000b E7 A2 07                		mov.L	r2, 28[r10]
 2789 000e D7 A3 10                		mov.W	r3, 32[r10]
 2790 0011 C7 A4 22                		mov.B	r4, 34[r10]
2969:../src/src/tls.c ****     int ret;
2970:../src/src/tls.c **** #if !defined(NO_WOLFSSL_SERVER)
2971:../src/src/tls.c ****     byte status_type;
2972:../src/src/tls.c ****     word16 size = 0;
 2791                             		.loc 2 2972 12
 2792 0014 F9 A5 0B 00             		mov.W	#0, 22[r10]
2973:../src/src/tls.c **** #if defined(WOLFSSL_TLS13)
2974:../src/src/tls.c ****     DecodedCert* cert;
2975:../src/src/tls.c **** #endif
2976:../src/src/tls.c **** #endif
2977:../src/src/tls.c **** 
2978:../src/src/tls.c **** #if !defined(NO_WOLFSSL_CLIENT) || !defined(NO_WOLFSSL_SERVER) \
2979:../src/src/tls.c ****     && defined(WOLFSSL_TLS13)
2980:../src/src/tls.c ****     OcspRequest* request;
2981:../src/src/tls.c ****     TLSX* extension;
2982:../src/src/tls.c ****     CertificateStatusRequest* csr;
2983:../src/src/tls.c **** #endif
2984:../src/src/tls.c **** 
2985:../src/src/tls.c **** #if !defined(NO_WOLFSSL_CLIENT) && defined(WOLFSSL_TLS13) \
2986:../src/src/tls.c ****  || !defined(NO_WOLFSSL_SERVER)
2987:../src/src/tls.c ****     word32 offset = 0;
 2793                             		.loc 2 2987 12
 2794 0018 F8 A6 00                		mov.L	#0, [r10]
2988:../src/src/tls.c **** #endif
2989:../src/src/tls.c **** 
2990:../src/src/tls.c **** #if !defined(NO_WOLFSSL_CLIENT) && defined(WOLFSSL_TLS13)
2991:../src/src/tls.c ****     word32 resp_length;
2992:../src/src/tls.c **** #endif
2993:../src/src/tls.c **** 
2994:../src/src/tls.c ****     /* shut up compiler warnings */
2995:../src/src/tls.c ****     (void) ssl; (void) input;
2996:../src/src/tls.c **** 
2997:../src/src/tls.c ****     if (!isRequest) {
 2795                             		.loc 2 2997 8
 2796 001b 59 A5 22                		movu.B	34[r10], r5
 2797 001e 61 05                   		cmp	#0, r5
 2798 0020 3B 06 01                		bne	.L165
2998:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
2999:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_STATUS_REQUEST);
 2799                             		.loc 2 2999 21
 2800 0023 ED A5 06                		mov.L	24[r10], r5
 2801 0026 ED 55 BF                		mov.L	764[r5], r5
 2802 0029 66 52                   		mov.L	#5, r2
 2803 002b EF 51                   		mov.L	r5, r1
 2804 002d 05 00 00 00             		bsr	_TLSX_Find
 2805 0031 E7 A1 01                		mov.L	r1, 4[r10]
3000:../src/src/tls.c ****         csr = extension ? (CertificateStatusRequest*)extension->data : NULL;
 2806                             		.loc 2 3000 70
 2807 0034 ED A5 01                		mov.L	4[r10], r5
 2808 0037 61 05                   		cmp	#0, r5
 2809 0039 17                      		beq	.L166
 2810                             		.loc 2 3000 70 is_stmt 0 discriminator 1
 2811 003a ED A5 01                		mov.L	4[r10], r5
 2812 003d A8 5D                   		mov.L	4[r5], r5
 2813 003f 0B                      		bra	.L167
 2814                             	.L166:
 2815                             		.loc 2 3000 70 discriminator 2
 2816 0040 66 05                   		mov.L	#0, r5
 2817                             	.L167:
 2818                             		.loc 2 3000 13 is_stmt 1 discriminator 4
 2819 0042 E7 A5 02                		mov.L	r5, 8[r10]
3001:../src/src/tls.c **** 
3002:../src/src/tls.c ****         if (!csr) {
 2820                             		.loc 2 3002 12 discriminator 4
 2821 0045 ED A5 02                		mov.L	8[r10], r5
 2822 0048 61 05                   		cmp	#0, r5
 2823 004a 3B BE 00                		bne	.L187
3003:../src/src/tls.c ****             /* look at context level */
3004:../src/src/tls.c ****             extension = TLSX_Find(ssl->ctx->extensions, TLSX_STATUS_REQUEST);
 2824                             		.loc 2 3004 38
 2825 004d ED A5 06                		mov.L	24[r10], r5
 2826 0050 EC 55                   		mov.L	[r5], r5
 2827                             		.loc 2 3004 25
 2828 0052 ED 55 49                		mov.L	292[r5], r5
 2829 0055 66 52                   		mov.L	#5, r2
 2830 0057 EF 51                   		mov.L	r5, r1
 2831 0059 05 00 00 00             		bsr	_TLSX_Find
 2832 005d E7 A1 01                		mov.L	r1, 4[r10]
3005:../src/src/tls.c ****             csr = extension ? (CertificateStatusRequest*)extension->data : NULL;
 2833                             		.loc 2 3005 74
 2834 0060 ED A5 01                		mov.L	4[r10], r5
 2835 0063 61 05                   		cmp	#0, r5
 2836 0065 17                      		beq	.L169
 2837                             		.loc 2 3005 74 is_stmt 0 discriminator 1
 2838 0066 ED A5 01                		mov.L	4[r10], r5
 2839 0069 A8 5D                   		mov.L	4[r5], r5
 2840 006b 0B                      		bra	.L170
 2841                             	.L169:
 2842                             		.loc 2 3005 74 discriminator 2
 2843 006c 66 05                   		mov.L	#0, r5
 2844                             	.L170:
 2845                             		.loc 2 3005 17 is_stmt 1 discriminator 4
 2846 006e E7 A5 02                		mov.L	r5, 8[r10]
3006:../src/src/tls.c **** 
3007:../src/src/tls.c ****             if (!csr) /* unexpected extension */
 2847                             		.loc 2 3007 16 discriminator 4
 2848 0071 ED A5 02                		mov.L	8[r10], r5
 2849 0074 61 05                   		cmp	#0, r5
 2850 0076 21 0E                   		bne	.L171
3008:../src/src/tls.c ****                 return TLSX_HandleUnsupportedExtension(ssl);
 2851                             		.loc 2 3008 24
 2852 0078 ED A1 06                		mov.L	24[r10], r1
 2853 007b 05 00 00 00             		bsr	_TLSX_HandleUnsupportedExtension
 2854 007f EF 15                   		mov.L	r1, r5
 2855 0081 38 A1 01                		bra	.L186
 2856                             	.L171:
3009:../src/src/tls.c **** 
3010:../src/src/tls.c ****             /* enable extension at ssl level */
3011:../src/src/tls.c ****             ret = TLSX_UseCertificateStatusRequest(&ssl->extensions,
 2857                             		.loc 2 3011 19
 2858 0084 ED A5 06                		mov.L	24[r10], r5
 2859 0087 72 51 FC 02             		add	#0x2fc, r5, r1
 2860 008b ED A5 02                		mov.L	8[r10], r5
 2861 008e CC 52                   		mov.B	[r5], r2
 2862 0090 ED A5 02                		mov.L	8[r10], r5
 2863 0093 88 5B                   		mov.B	1[r5], r3
 2864 0095 ED A5 06                		mov.L	24[r10], r5
 2865 0098 AA 5C                   		mov.L	36[r5], r4
 2866 009a ED A5 06                		mov.L	24[r10], r5
 2867 009d ED 55 BE                		mov.L	760[r5], r5
 2868 00a0 A0 0D                   		mov.L	r5, 4[r0]
 2869 00a2 E3 04                   		mov.L	r4, [r0]
 2870 00a4 ED A4 06                		mov.L	24[r10], r4
 2871 00a7 05 00 00 00             		bsr	_TLSX_UseCertificateStatusRequest
 2872 00ab E7 A1 03                		mov.L	r1, 12[r10]
3012:../src/src/tls.c ****                                      csr->status_type, csr->options, ssl,
3013:../src/src/tls.c ****                                      ssl->heap, ssl->devId);
3014:../src/src/tls.c ****             if (ret != WOLFSSL_SUCCESS)
 2873                             		.loc 2 3014 16
 2874 00ae ED A5 03                		mov.L	12[r10], r5
 2875 00b1 61 15                   		cmp	#1, r5
 2876 00b3 17                      		beq	.L173
3015:../src/src/tls.c ****                 return ret;
 2877                             		.loc 2 3015 24
 2878 00b4 ED A5 03                		mov.L	12[r10], r5
 2879 00b7 38 6B 01                		bra	.L186
 2880                             	.L173:
3016:../src/src/tls.c **** 
3017:../src/src/tls.c ****             switch (csr->status_type) {
 2881                             		.loc 2 3017 24
 2882 00ba ED A5 02                		mov.L	8[r10], r5
 2883 00bd CC 55                   		mov.B	[r5], r5
 2884 00bf 5B 55                   		movu.B	r5, r5
 2885                             		.loc 2 3017 13
 2886 00c1 61 15                   		cmp	#1, r5
 2887 00c3 21 49                   		bne	.L168
3018:../src/src/tls.c ****                 case WOLFSSL_CSR_OCSP:
3019:../src/src/tls.c ****                     /* propagate nonce */
3020:../src/src/tls.c ****                     if (csr->request.ocsp.nonceSz) {
 2888                             		.loc 2 3020 42
 2889 00c5 ED A5 02                		mov.L	8[r10], r5
 2890 00c8 AD 55                   		mov.L	80[r5], r5
 2891                             		.loc 2 3020 24
 2892 00ca 61 05                   		cmp	#0, r5
 2893 00cc 20 3F                   		beq	.L188
3021:../src/src/tls.c ****                         request =
3022:../src/src/tls.c ****                             (OcspRequest*)TLSX_CSR_GetRequest(ssl->extensions);
 2894                             		.loc 2 3022 43
 2895 00ce ED A5 06                		mov.L	24[r10], r5
 2896 00d1 ED 55 BF                		mov.L	764[r5], r5
 2897 00d4 EF 51                   		mov.L	r5, r1
 2898 00d6 05 00 00 00             		bsr	_TLSX_CSR_GetRequest
 2899 00da E7 A1 04                		mov.L	r1, 16[r10]
3023:../src/src/tls.c **** 
3024:../src/src/tls.c ****                         if (request) {
 2900                             		.loc 2 3024 28
 2901 00dd ED A5 04                		mov.L	16[r10], r5
 2902 00e0 61 05                   		cmp	#0, r5
 2903 00e2 20 29                   		beq	.L188
3025:../src/src/tls.c ****                             XMEMCPY(request->nonce, csr->request.ocsp.nonce,
 2904                             		.loc 2 3025 29
 2905 00e4 ED A5 04                		mov.L	16[r10], r5
 2906 00e7 71 54 38                		add	#56, r5, r4
 2907 00ea ED A5 02                		mov.L	8[r10], r5
 2908 00ed 71 52 40                		add	#0x40, r5, r2
 2909 00f0 ED A5 02                		mov.L	8[r10], r5
 2910 00f3 AD 55                   		mov.L	80[r5], r5
 2911 00f5 EF 53                   		mov.L	r5, r3
 2912 00f7 EF 41                   		mov.L	r4, r1
 2913 00f9 05 00 00 00             		bsr	_memcpy
3026:../src/src/tls.c ****                                                     csr->request.ocsp.nonceSz);
3027:../src/src/tls.c ****                             request->nonceSz = csr->request.ocsp.nonceSz;
 2914                             		.loc 2 3027 65
 2915 00fd ED A5 02                		mov.L	8[r10], r5
 2916 0100 AD 54                   		mov.L	80[r5], r4
 2917                             		.loc 2 3027 46
 2918 0102 ED A5 04                		mov.L	16[r10], r5
 2919 0105 A4 D4                   		mov.L	r4, 72[r5]
3028:../src/src/tls.c ****                         }
3029:../src/src/tls.c ****                     }
3030:../src/src/tls.c ****                 break;
 2920                             		.loc 2 3030 17
 2921 0107 0C                      		bra	.L188
 2922                             	.L187:
3031:../src/src/tls.c ****             }
3032:../src/src/tls.c ****         }
 2923                             		.loc 2 3032 9
 2924 0108 03                      		nop
 2925 0109 2E 03                   		bra	.L168
 2926                             	.L188:
3030:../src/src/tls.c ****             }
 2927                             		.loc 2 3030 17
 2928 010b 03                      		nop
 2929                             	.L168:
3033:../src/src/tls.c **** 
3034:../src/src/tls.c ****         ssl->status_request = 1;
 2930                             		.loc 2 3034 29
 2931 010c ED A5 06                		mov.L	24[r10], r5
 2932 010f FA 54 00 03 01          		mov.B	#1, 768[r5]
3035:../src/src/tls.c **** 
3036:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
3037:../src/src/tls.c ****         if (ssl->options.tls1_3) {
3038:../src/src/tls.c ****             /* Get the new extension potentially created above. */
3039:../src/src/tls.c ****             extension = TLSX_Find(ssl->extensions, TLSX_STATUS_REQUEST);
3040:../src/src/tls.c ****             csr = extension ? (CertificateStatusRequest*)extension->data : NULL;
3041:../src/src/tls.c ****             if (csr == NULL)
3042:../src/src/tls.c ****                 return MEMORY_ERROR;
3043:../src/src/tls.c **** 
3044:../src/src/tls.c ****             ret = 0;
3045:../src/src/tls.c ****             if (OPAQUE8_LEN + OPAQUE24_LEN > length)
3046:../src/src/tls.c ****                 ret = BUFFER_ERROR;
3047:../src/src/tls.c ****             if (ret == 0 && input[offset++] != WOLFSSL_CSR_OCSP)
3048:../src/src/tls.c ****                 ret = BAD_CERTIFICATE_STATUS_ERROR;
3049:../src/src/tls.c ****             if (ret == 0) {
3050:../src/src/tls.c ****                 c24to32(input + offset, &resp_length);
3051:../src/src/tls.c ****                 offset += OPAQUE24_LEN;
3052:../src/src/tls.c ****                 if (offset + resp_length != length)
3053:../src/src/tls.c ****                     ret = BUFFER_ERROR;
3054:../src/src/tls.c ****             }
3055:../src/src/tls.c ****             if (ret == 0) {
3056:../src/src/tls.c ****                 csr->response.buffer = (byte*)(input + offset);
3057:../src/src/tls.c ****                 csr->response.length = resp_length;
3058:../src/src/tls.c ****             }
3059:../src/src/tls.c **** 
3060:../src/src/tls.c ****             return ret;
3061:../src/src/tls.c ****         }
3062:../src/src/tls.c ****         else
3063:../src/src/tls.c ****     #endif
3064:../src/src/tls.c ****         {
3065:../src/src/tls.c ****             /* extension_data MUST be empty. */
3066:../src/src/tls.c ****             return length ? BUFFER_ERROR : 0;
 2933                             		.loc 2 3066 42
 2934 0114 5D A5 10                		movu.W	32[r10], r5
 2935 0117 61 05                   		cmp	#0, r5
 2936 0119 10                      		beq	.L175
 2937                             		.loc 2 3066 42 is_stmt 0 discriminator 1
 2938 011a FB 5A B8 FE             		mov.L	#-328, r5
 2939 011e 38 04 01                		bra	.L186
 2940                             	.L175:
 2941                             		.loc 2 3066 42 discriminator 2
 2942 0121 66 05                   		mov.L	#0, r5
 2943 0123 38 FF 00                		bra	.L186
 2944                             	.L165:
3067:../src/src/tls.c ****         }
3068:../src/src/tls.c **** #endif
3069:../src/src/tls.c ****     }
3070:../src/src/tls.c ****     else {
3071:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
3072:../src/src/tls.c ****         if (length == 0)
 2945                             		.loc 2 3072 12 is_stmt 1
 2946 0126 5D A5 10                		movu.W	32[r10], r5
 2947 0129 61 05                   		cmp	#0, r5
 2948 012b 1E                      		bne	.L177
3073:../src/src/tls.c ****             return 0;
 2949                             		.loc 2 3073 20
 2950 012c 66 05                   		mov.L	#0, r5
 2951 012e 38 F4 00                		bra	.L186
 2952                             	.L177:
3074:../src/src/tls.c **** 
3075:../src/src/tls.c ****         status_type = input[offset++];
 2953                             		.loc 2 3075 35
 2954 0131 EC A5                   		mov.L	[r10], r5
 2955 0133 71 54 01                		add	#1, r5, r4
 2956 0136 E3 A4                   		mov.L	r4, [r10]
 2957                             		.loc 2 3075 28
 2958 0138 ED A4 07                		mov.L	28[r10], r4
 2959 013b 4B 45                   		add	r4, r5
 2960                             		.loc 2 3075 21
 2961 013d CC 55                   		mov.B	[r5], r5
 2962 013f C7 A5 14                		mov.B	r5, 20[r10]
3076:../src/src/tls.c **** 
3077:../src/src/tls.c ****         switch (status_type) {
 2963                             		.loc 2 3077 9
 2964 0142 59 A5 14                		movu.B	20[r10], r5
 2965 0145 61 15                   		cmp	#1, r5
 2966 0147 3B 91 00                		bne	.L178
3078:../src/src/tls.c ****             case WOLFSSL_CSR_OCSP: {
3079:../src/src/tls.c **** 
3080:../src/src/tls.c ****                 /* skip responder_id_list */
3081:../src/src/tls.c ****                 if ((int)(length - offset) < OPAQUE16_LEN)
 2967                             		.loc 2 3081 34
 2968 014a 5D A5 10                		movu.W	32[r10], r5
 2969 014d EC A4                   		mov.L	[r10], r4
 2970 014f 43 45                   		sub	r4, r5
 2971                             		.loc 2 3081 20
 2972 0151 61 15                   		cmp	#1, r5
 2973 0153 2A 09                   		bgt	.L179
3082:../src/src/tls.c ****                     return BUFFER_ERROR;
 2974                             		.loc 2 3082 28
 2975 0155 FB 5A B8 FE             		mov.L	#-328, r5
 2976 0159 38 C9 00                		bra	.L186
 2977                             	.L179:
3083:../src/src/tls.c **** 
3084:../src/src/tls.c ****                 ato16(input + offset, &size);
 2978                             		.loc 2 3084 17
 2979 015c ED A5 07                		mov.L	28[r10], r5
 2980 015f 06 88 A5                		add	[r10].L, r5
 2981 0162 71 A4 16                		add	#22, r10, r4
 2982 0165 EF 42                   		mov.L	r4, r2
 2983 0167 EF 51                   		mov.L	r5, r1
 2984 0169 05 00 00 00             		bsr	_ato16
3085:../src/src/tls.c ****                 offset += OPAQUE16_LEN + size;
 2985                             		.loc 2 3085 24
 2986 016d DD A5 0B                		mov.W	22[r10], r5
 2987 0170 5F 55                   		movu.W	r5, r5
 2988 0172 06 88 A5                		add	[r10].L, r5
 2989 0175 62 25                   		add	#2, r5
 2990 0177 E3 A5                   		mov.L	r5, [r10]
3086:../src/src/tls.c **** 
3087:../src/src/tls.c ****                 /* skip request_extensions */
3088:../src/src/tls.c ****                 if ((int)(length - offset) < OPAQUE16_LEN)
 2991                             		.loc 2 3088 34
 2992 0179 5D A5 10                		movu.W	32[r10], r5
 2993 017c EC A4                   		mov.L	[r10], r4
 2994 017e 43 45                   		sub	r4, r5
 2995                             		.loc 2 3088 20
 2996 0180 61 15                   		cmp	#1, r5
 2997 0182 2A 09                   		bgt	.L180
3089:../src/src/tls.c ****                     return BUFFER_ERROR;
 2998                             		.loc 2 3089 28
 2999 0184 FB 5A B8 FE             		mov.L	#-328, r5
 3000 0188 38 9A 00                		bra	.L186
 3001                             	.L180:
3090:../src/src/tls.c **** 
3091:../src/src/tls.c ****                 ato16(input + offset, &size);
 3002                             		.loc 2 3091 17
 3003 018b ED A5 07                		mov.L	28[r10], r5
 3004 018e 06 88 A5                		add	[r10].L, r5
 3005 0191 71 A4 16                		add	#22, r10, r4
 3006 0194 EF 42                   		mov.L	r4, r2
 3007 0196 EF 51                   		mov.L	r5, r1
 3008 0198 05 00 00 00             		bsr	_ato16
3092:../src/src/tls.c ****                 offset += OPAQUE16_LEN + size;
 3009                             		.loc 2 3092 24
 3010 019c DD A5 0B                		mov.W	22[r10], r5
 3011 019f 5F 55                   		movu.W	r5, r5
 3012 01a1 06 88 A5                		add	[r10].L, r5
 3013 01a4 62 25                   		add	#2, r5
 3014 01a6 E3 A5                   		mov.L	r5, [r10]
3093:../src/src/tls.c **** 
3094:../src/src/tls.c ****                 if (offset > length)
 3015                             		.loc 2 3094 28
 3016 01a8 5D A5 10                		movu.W	32[r10], r5
 3017                             		.loc 2 3094 20
 3018 01ab EC A4                   		mov.L	[r10], r4
 3019 01ad 47 54                   		cmp	r5, r4
 3020 01af 25 08                   		bleu	.L181
3095:../src/src/tls.c ****                     return BUFFER_ERROR;
 3021                             		.loc 2 3095 28
 3022 01b1 FB 5A B8 FE             		mov.L	#-328, r5
 3023 01b5 2E 6D                   		bra	.L186
 3024                             	.L181:
3096:../src/src/tls.c **** 
3097:../src/src/tls.c ****                 /* is able to send OCSP response? */
3098:../src/src/tls.c ****                 if (SSL_CM(ssl) == NULL || !SSL_CM(ssl)->ocspStaplingEnabled)
 3025                             		.loc 2 3098 21
 3026 01b7 ED A5 06                		mov.L	24[r10], r5
 3027 01ba EC 55                   		mov.L	[r5], r5
 3028 01bc AB DD                   		mov.L	60[r5], r5
 3029                             		.loc 2 3098 20
 3030 01be 61 05                   		cmp	#0, r5
 3031 01c0 20 14                   		beq	.L182
 3032                             		.loc 2 3098 45 discriminator 1
 3033 01c2 ED A5 06                		mov.L	24[r10], r5
 3034 01c5 EC 55                   		mov.L	[r5], r5
 3035 01c7 AB DD                   		mov.L	60[r5], r5
 3036                             		.loc 2 3098 44 discriminator 1
 3037 01c9 CD 55 5C                		mov.B	92[r5], r5
 3038 01cc 75 25 40                		and	#0x40, r5
 3039                             		.loc 2 3098 41 discriminator 1
 3040 01cf 5B 55                   		movu.B	r5, r5
 3041 01d1 61 05                   		cmp	#0, r5
 3042 01d3 19                      		bne	.L189
 3043                             	.L182:
3099:../src/src/tls.c ****                     return 0;
 3044                             		.loc 2 3099 28
 3045 01d4 66 05                   		mov.L	#0, r5
 3046 01d6 2E 4C                   		bra	.L186
 3047                             	.L178:
3100:../src/src/tls.c ****             }
3101:../src/src/tls.c ****             break;
3102:../src/src/tls.c **** 
3103:../src/src/tls.c ****             /* unknown status type */
3104:../src/src/tls.c ****             default:
3105:../src/src/tls.c ****                 return 0;
 3048                             		.loc 2 3105 24
 3049 01d8 66 05                   		mov.L	#0, r5
 3050 01da 2E 48                   		bra	.L186
 3051                             	.L189:
3101:../src/src/tls.c **** 
 3052                             		.loc 2 3101 13
 3053 01dc 03                      		nop
3106:../src/src/tls.c ****         }
3107:../src/src/tls.c **** 
3108:../src/src/tls.c ****         /* if using status_request and already sending it, skip this one */
3109:../src/src/tls.c ****         #ifdef HAVE_CERTIFICATE_STATUS_REQUEST_V2
3110:../src/src/tls.c ****         if (ssl->status_request_v2)
3111:../src/src/tls.c ****             return 0;
3112:../src/src/tls.c ****         #endif
3113:../src/src/tls.c **** 
3114:../src/src/tls.c ****         /* accept the first good status_type and return */
3115:../src/src/tls.c ****         ret = TLSX_UseCertificateStatusRequest(&ssl->extensions, status_type,
 3054                             		.loc 2 3115 15
 3055 01dd ED A5 06                		mov.L	24[r10], r5
 3056 01e0 72 51 FC 02             		add	#0x2fc, r5, r1
 3057 01e4 ED A5 06                		mov.L	24[r10], r5
 3058 01e7 AA 5C                   		mov.L	36[r5], r4
 3059 01e9 ED A5 06                		mov.L	24[r10], r5
 3060 01ec ED 55 BE                		mov.L	760[r5], r5
 3061 01ef A0 0D                   		mov.L	r5, 4[r0]
 3062 01f1 E3 04                   		mov.L	r4, [r0]
 3063 01f3 ED A4 06                		mov.L	24[r10], r4
 3064 01f6 66 03                   		mov	#0, r3
 3065 01f8 CD A2 14                		mov.B	20[r10], r2
 3066 01fb 05 00 00 00             		bsr	_TLSX_UseCertificateStatusRequest
 3067 01ff E7 A1 03                		mov.L	r1, 12[r10]
3116:../src/src/tls.c ****                                                  0, ssl, ssl->heap, ssl->devId);
3117:../src/src/tls.c ****         if (ret != WOLFSSL_SUCCESS)
 3068                             		.loc 2 3117 12
 3069 0202 ED A5 03                		mov.L	12[r10], r5
 3070 0205 61 15                   		cmp	#1, r5
 3071 0207 16                      		beq	.L185
3118:../src/src/tls.c ****             return ret; /* throw error */
 3072                             		.loc 2 3118 20
 3073 0208 ED A5 03                		mov.L	12[r10], r5
 3074 020b 2E 17                   		bra	.L186
 3075                             	.L185:
3119:../src/src/tls.c **** 
3120:../src/src/tls.c ****     #if defined(WOLFSSL_TLS13)
3121:../src/src/tls.c ****         if (ssl->options.tls1_3) {
3122:../src/src/tls.c ****             cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), ssl->heap,
3123:../src/src/tls.c ****                                          DYNAMIC_TYPE_DCERT);
3124:../src/src/tls.c ****             if (cert == NULL) {
3125:../src/src/tls.c ****                 return MEMORY_E;
3126:../src/src/tls.c ****             }
3127:../src/src/tls.c ****             InitDecodedCert(cert, ssl->buffers.certificate->buffer,
3128:../src/src/tls.c ****                             ssl->buffers.certificate->length, ssl->heap);
3129:../src/src/tls.c ****             ret = ParseCert(cert, CERT_TYPE, 1, SSL_CM(ssl));
3130:../src/src/tls.c ****             if (ret != 0 ) {
3131:../src/src/tls.c ****                 XFREE(cert, ssl->heap, DYNAMIC_TYPE_DCERT);
3132:../src/src/tls.c ****                 return ret;
3133:../src/src/tls.c ****             }
3134:../src/src/tls.c ****             ret = TLSX_CSR_InitRequest(ssl->extensions, cert, ssl->heap);
3135:../src/src/tls.c ****             if (ret != 0 ) {
3136:../src/src/tls.c ****                 XFREE(cert, ssl->heap, DYNAMIC_TYPE_DCERT);
3137:../src/src/tls.c ****                 return ret;
3138:../src/src/tls.c ****             }
3139:../src/src/tls.c ****             XFREE(cert, ssl->heap, DYNAMIC_TYPE_DCERT);
3140:../src/src/tls.c **** 
3141:../src/src/tls.c ****             extension = TLSX_Find(ssl->extensions, TLSX_STATUS_REQUEST);
3142:../src/src/tls.c ****             csr = extension ?
3143:../src/src/tls.c ****                 (CertificateStatusRequest*)extension->data : NULL;
3144:../src/src/tls.c ****             if (csr == NULL)
3145:../src/src/tls.c ****                 return MEMORY_ERROR;
3146:../src/src/tls.c **** 
3147:../src/src/tls.c ****             request = &csr->request.ocsp;
3148:../src/src/tls.c ****             ret = CreateOcspResponse(ssl, &request, &csr->response);
3149:../src/src/tls.c ****             if (ret != 0)
3150:../src/src/tls.c ****                 return ret;
3151:../src/src/tls.c ****             if (csr->response.buffer)
3152:../src/src/tls.c ****                 TLSX_SetResponse(ssl, TLSX_STATUS_REQUEST);
3153:../src/src/tls.c ****         }
3154:../src/src/tls.c ****         else
3155:../src/src/tls.c ****     #endif
3156:../src/src/tls.c ****             TLSX_SetResponse(ssl, TLSX_STATUS_REQUEST);
 3076                             		.loc 2 3156 13
 3077 020d 66 52                   		mov.L	#5, r2
 3078 020f ED A1 06                		mov.L	24[r10], r1
 3079 0212 05 00 00 00             		bsr	_TLSX_SetResponse
3157:../src/src/tls.c ****         ssl->status_request = status_type;
 3080                             		.loc 2 3157 29
 3081 0216 ED A5 06                		mov.L	24[r10], r5
 3082 0219 CD A4 14                		mov.B	20[r10], r4
 3083 021c CB 54 00 03             		mov.B	r4, 768[r5]
3158:../src/src/tls.c **** #endif
3159:../src/src/tls.c ****     }
3160:../src/src/tls.c **** 
3161:../src/src/tls.c ****     return 0;
 3084                             		.loc 2 3161 12
 3085 0220 66 05                   		mov.L	#0, r5
 3086                             		.balign 8,3,1
 3087                             	.L186:
3162:../src/src/tls.c **** }
 3088                             		.loc 2 3162 1 discriminator 1
 3089 0222 EF 51                   		mov.L	r5, r1
 3090 0224 3F AA 0C                		rtsd	#48, r10-r10
 3091                             	.LFE70:
 3093 0227 03                      		.section	.text.TLSX_CSR_InitRequest,"ax",@progbits
 3094                             		.global	_TLSX_CSR_InitRequest
 3096                             	_TLSX_CSR_InitRequest:
 3097                             	.LFB71:
3163:../src/src/tls.c **** 
3164:../src/src/tls.c **** int TLSX_CSR_InitRequest(TLSX* extensions, DecodedCert* cert, void* heap)
3165:../src/src/tls.c **** {
 3098                             		.loc 2 3165 1
 3099 0000 7E AA                   		push.l	r10
 3100                             	.LCFI89:
 3101 0002 71 0A D4                		add	#-44, r0, r10
 3102                             	.LCFI90:
 3103 0005 EF A0                   		mov.L	r10, r0
 3104 0007 E7 A1 08                		mov.L	r1, 32[r10]
 3105 000a E7 A2 09                		mov.L	r2, 36[r10]
 3106 000d E7 A3 0A                		mov.L	r3, 40[r10]
3166:../src/src/tls.c ****     TLSX* extension = TLSX_Find(extensions, TLSX_STATUS_REQUEST);
 3107                             		.loc 2 3166 23
 3108 0010 66 52                   		mov.L	#5, r2
 3109 0012 ED A1 08                		mov.L	32[r10], r1
 3110 0015 05 00 00 00             		bsr	_TLSX_Find
 3111 0019 E7 A1 01                		mov.L	r1, 4[r10]
3167:../src/src/tls.c ****     CertificateStatusRequest* csr = extension ?
3168:../src/src/tls.c ****         (CertificateStatusRequest*)extension->data : NULL;
 3112                             		.loc 2 3168 52
 3113 001c ED A5 01                		mov.L	4[r10], r5
 3114 001f 61 05                   		cmp	#0, r5
 3115 0021 17                      		beq	.L191
 3116                             		.loc 2 3168 52 is_stmt 0 discriminator 1
 3117 0022 ED A5 01                		mov.L	4[r10], r5
 3118 0025 A8 5D                   		mov.L	4[r5], r5
 3119 0027 0B                      		bra	.L192
 3120                             	.L191:
 3121                             		.loc 2 3168 52 discriminator 2
 3122 0028 66 05                   		mov.L	#0, r5
 3123                             	.L192:
3167:../src/src/tls.c ****     CertificateStatusRequest* csr = extension ?
 3124                             		.loc 2 3167 31 is_stmt 1
 3125 002a E7 A5 02                		mov.L	r5, 8[r10]
3169:../src/src/tls.c ****     int ret = 0;
 3126                             		.loc 2 3169 9
 3127 002d F8 A6 00                		mov.L	#0, [r10]
3170:../src/src/tls.c **** 
3171:../src/src/tls.c ****     if (csr) {
 3128                             		.loc 2 3171 8
 3129 0030 ED A5 02                		mov.L	8[r10], r5
 3130 0033 61 05                   		cmp	#0, r5
 3131 0035 20 65                   		beq	.L196
3172:../src/src/tls.c ****         switch (csr->status_type) {
 3132                             		.loc 2 3172 20
 3133 0037 ED A5 02                		mov.L	8[r10], r5
 3134 003a CC 55                   		mov.B	[r5], r5
 3135 003c 5B 55                   		movu.B	r5, r5
 3136                             		.loc 2 3172 9
 3137 003e 61 15                   		cmp	#1, r5
 3138 0040 21 5B                   		bne	.L193
 3139                             	.LBB9:
3173:../src/src/tls.c ****             case WOLFSSL_CSR_OCSP: {
3174:../src/src/tls.c ****                 byte nonce[MAX_OCSP_NONCE_SZ];
3175:../src/src/tls.c ****                 int  nonceSz = csr->request.ocsp.nonceSz;
 3140                             		.loc 2 3175 22
 3141 0042 ED A5 02                		mov.L	8[r10], r5
 3142 0045 AD 55                   		mov.L	80[r5], r5
 3143 0047 E7 A5 03                		mov.L	r5, 12[r10]
3176:../src/src/tls.c **** 
3177:../src/src/tls.c ****                 /* preserve nonce */
3178:../src/src/tls.c ****                 XMEMCPY(nonce, csr->request.ocsp.nonce, nonceSz);
 3144                             		.loc 2 3178 17
 3145 004a ED A5 02                		mov.L	8[r10], r5
 3146 004d 71 54 40                		add	#0x40, r5, r4
 3147 0050 ED A3 03                		mov.L	12[r10], r3
 3148 0053 71 A5 10                		add	#16, r10, r5
 3149 0056 EF 42                   		mov.L	r4, r2
 3150 0058 EF 51                   		mov.L	r5, r1
 3151 005a 05 00 00 00             		bsr	_memcpy
3179:../src/src/tls.c **** 
3180:../src/src/tls.c ****                 if ((ret = InitOcspRequest(&csr->request.ocsp, cert, 0, heap))
 3152                             		.loc 2 3180 28
 3153 005e ED A5 02                		mov.L	8[r10], r5
 3154 0061 62 85                   		add	#8, r5
 3155 0063 ED A4 0A                		mov.L	40[r10], r4
 3156 0066 66 03                   		mov	#0, r3
 3157 0068 ED A2 09                		mov.L	36[r10], r2
 3158 006b EF 51                   		mov.L	r5, r1
 3159 006d 05 00 00 00             		bsr	_InitOcspRequest
 3160 0071 E3 A1                   		mov.L	r1, [r10]
 3161                             		.loc 2 3180 20
 3162 0073 EC A5                   		mov.L	[r10], r5
 3163 0075 61 05                   		cmp	#0, r5
 3164 0077 15                      		beq	.L194
3181:../src/src/tls.c ****                                                                            != 0)
3182:../src/src/tls.c ****                     return ret;
 3165                             		.loc 2 3182 28
 3166 0078 EC A5                   		mov.L	[r10], r5
 3167 007a 2E 23                   		bra	.L195
 3168                             	.L194:
3183:../src/src/tls.c **** 
3184:../src/src/tls.c ****                 /* restore nonce */
3185:../src/src/tls.c ****                 XMEMCPY(csr->request.ocsp.nonce, nonce, nonceSz);
 3169                             		.loc 2 3185 17
 3170 007c ED A5 02                		mov.L	8[r10], r5
 3171 007f 71 55 40                		add	#0x40, r5
 3172 0082 ED A3 03                		mov.L	12[r10], r3
 3173 0085 71 A4 10                		add	#16, r10, r4
 3174 0088 EF 42                   		mov.L	r4, r2
 3175 008a EF 51                   		mov.L	r5, r1
 3176 008c 05 00 00 00             		bsr	_memcpy
3186:../src/src/tls.c ****                 csr->request.ocsp.nonceSz = nonceSz;
 3177                             		.loc 2 3186 43
 3178 0090 ED A5 02                		mov.L	8[r10], r5
 3179 0093 ED A4 03                		mov.L	12[r10], r4
 3180 0096 A5 54                   		mov.L	r4, 80[r5]
 3181                             	.LBE9:
3187:../src/src/tls.c ****             }
3188:../src/src/tls.c ****             break;
 3182                             		.loc 2 3188 13
 3183 0098 2E 03                   		bra	.L193
 3184                             	.L196:
3189:../src/src/tls.c ****         }
3190:../src/src/tls.c ****     }
 3185                             		.loc 2 3190 5
 3186 009a 03                      		nop
 3187                             	.L193:
3191:../src/src/tls.c **** 
3192:../src/src/tls.c ****     return ret;
 3188                             		.loc 2 3192 12
 3189 009b EC A5                   		mov.L	[r10], r5
 3190                             	.L195:
3193:../src/src/tls.c **** }
 3191                             		.loc 2 3193 1
 3192 009d EF 51                   		mov.L	r5, r1
 3193 009f 3F AA 0C                		rtsd	#48, r10-r10
 3194                             	.LFE71:
 3196                             		.section	.text.TLSX_CSR_GetRequest,"ax",@progbits
 3197                             		.global	_TLSX_CSR_GetRequest
 3199                             	_TLSX_CSR_GetRequest:
 3200                             	.LFB72:
3194:../src/src/tls.c **** 
3195:../src/src/tls.c **** void* TLSX_CSR_GetRequest(TLSX* extensions)
3196:../src/src/tls.c **** {
 3201                             		.loc 2 3196 1
 3202 0000 7E AA                   		push.l	r10
 3203                             	.LCFI91:
 3204 0002 71 0A F4                		add	#-12, r0, r10
 3205                             	.LCFI92:
 3206 0005 EF A0                   		mov.L	r10, r0
 3207 0007 E7 A1 02                		mov.L	r1, 8[r10]
3197:../src/src/tls.c ****     TLSX* extension = TLSX_Find(extensions, TLSX_STATUS_REQUEST);
 3208                             		.loc 2 3197 23
 3209 000a 66 52                   		mov.L	#5, r2
 3210 000c ED A1 02                		mov.L	8[r10], r1
 3211 000f 05 00 00 00             		bsr	_TLSX_Find
 3212 0013 E3 A1                   		mov.L	r1, [r10]
3198:../src/src/tls.c ****     CertificateStatusRequest* csr = extension ?
3199:../src/src/tls.c ****                               (CertificateStatusRequest*)extension->data : NULL;
 3213                             		.loc 2 3199 74
 3214 0015 EC A5                   		mov.L	[r10], r5
 3215 0017 61 05                   		cmp	#0, r5
 3216 0019 16                      		beq	.L198
 3217                             		.loc 2 3199 74 is_stmt 0 discriminator 1
 3218 001a EC A5                   		mov.L	[r10], r5
 3219 001c A8 5D                   		mov.L	4[r5], r5
 3220 001e 0B                      		bra	.L199
 3221                             	.L198:
 3222                             		.loc 2 3199 74 discriminator 2
 3223 001f 66 05                   		mov.L	#0, r5
 3224                             	.L199:
3198:../src/src/tls.c ****     CertificateStatusRequest* csr = extension ?
 3225                             		.loc 2 3198 31 is_stmt 1
 3226 0021 E7 A5 01                		mov.L	r5, 4[r10]
3200:../src/src/tls.c **** 
3201:../src/src/tls.c ****     if (csr) {
 3227                             		.loc 2 3201 8
 3228 0024 ED A5 01                		mov.L	4[r10], r5
 3229 0027 61 05                   		cmp	#0, r5
 3230 0029 20 12                   		beq	.L200
3202:../src/src/tls.c ****         switch (csr->status_type) {
 3231                             		.loc 2 3202 20
 3232 002b ED A5 01                		mov.L	4[r10], r5
 3233 002e CC 55                   		mov.B	[r5], r5
 3234 0030 5B 55                   		movu.B	r5, r5
 3235                             		.loc 2 3202 9
 3236 0032 61 15                   		cmp	#1, r5
 3237 0034 1F                      		bne	.L200
3203:../src/src/tls.c ****             case WOLFSSL_CSR_OCSP:
3204:../src/src/tls.c ****                 return &csr->request.ocsp;
 3238                             		.loc 2 3204 24
 3239 0035 ED A5 01                		mov.L	4[r10], r5
 3240 0038 62 85                   		add	#8, r5
 3241 003a 0B                      		bra	.L201
 3242                             	.L200:
3205:../src/src/tls.c ****         }
3206:../src/src/tls.c ****     }
3207:../src/src/tls.c **** 
3208:../src/src/tls.c ****     return NULL;
 3243                             		.loc 2 3208 12
 3244 003b 66 05                   		mov.L	#0, r5
 3245                             	.L201:
3209:../src/src/tls.c **** }
 3246                             		.loc 2 3209 1
 3247 003d EF 51                   		mov.L	r5, r1
 3248 003f 3F AA 04                		rtsd	#16, r10-r10
 3249                             	.LFE72:
 3251                             		.section	.text.TLSX_CSR_ForceRequest,"ax",@progbits
 3252                             		.global	_TLSX_CSR_ForceRequest
 3254                             	_TLSX_CSR_ForceRequest:
 3255                             	.LFB73:
3210:../src/src/tls.c **** 
3211:../src/src/tls.c **** int TLSX_CSR_ForceRequest(WOLFSSL* ssl)
3212:../src/src/tls.c **** {
 3256                             		.loc 2 3212 1
 3257 0000 7E AA                   		push.l	r10
 3258                             	.LCFI93:
 3259 0002 71 0A F4                		add	#-12, r0, r10
 3260                             	.LCFI94:
 3261 0005 EF A0                   		mov.L	r10, r0
 3262 0007 E7 A1 02                		mov.L	r1, 8[r10]
3213:../src/src/tls.c ****     TLSX* extension = TLSX_Find(ssl->extensions, TLSX_STATUS_REQUEST);
 3263                             		.loc 2 3213 23
 3264 000a ED A5 02                		mov.L	8[r10], r5
 3265 000d ED 55 BF                		mov.L	764[r5], r5
 3266 0010 66 52                   		mov.L	#5, r2
 3267 0012 EF 51                   		mov.L	r5, r1
 3268 0014 05 00 00 00             		bsr	_TLSX_Find
 3269 0018 E3 A1                   		mov.L	r1, [r10]
3214:../src/src/tls.c ****     CertificateStatusRequest* csr = extension ?
3215:../src/src/tls.c ****                               (CertificateStatusRequest*)extension->data : NULL;
 3270                             		.loc 2 3215 74
 3271 001a EC A5                   		mov.L	[r10], r5
 3272 001c 61 05                   		cmp	#0, r5
 3273 001e 16                      		beq	.L203
 3274                             		.loc 2 3215 74 is_stmt 0 discriminator 1
 3275 001f EC A5                   		mov.L	[r10], r5
 3276 0021 A8 5D                   		mov.L	4[r5], r5
 3277 0023 0B                      		bra	.L204
 3278                             	.L203:
 3279                             		.loc 2 3215 74 discriminator 2
 3280 0024 66 05                   		mov.L	#0, r5
 3281                             	.L204:
3214:../src/src/tls.c ****     CertificateStatusRequest* csr = extension ?
 3282                             		.loc 2 3214 31 is_stmt 1
 3283 0026 E7 A5 01                		mov.L	r5, 4[r10]
3216:../src/src/tls.c **** 
3217:../src/src/tls.c ****     if (csr) {
 3284                             		.loc 2 3217 8
 3285 0029 ED A5 01                		mov.L	4[r10], r5
 3286 002c 61 05                   		cmp	#0, r5
 3287 002e 20 47                   		beq	.L205
3218:../src/src/tls.c ****         switch (csr->status_type) {
 3288                             		.loc 2 3218 20
 3289 0030 ED A5 01                		mov.L	4[r10], r5
 3290 0033 CC 55                   		mov.B	[r5], r5
 3291 0035 5B 55                   		movu.B	r5, r5
 3292                             		.loc 2 3218 9
 3293 0037 61 15                   		cmp	#1, r5
 3294 0039 21 3C                   		bne	.L205
3219:../src/src/tls.c ****             case WOLFSSL_CSR_OCSP:
3220:../src/src/tls.c ****                 if (SSL_CM(ssl)->ocspEnabled) {
 3295                             		.loc 2 3220 21
 3296 003b ED A5 02                		mov.L	8[r10], r5
 3297 003e EC 55                   		mov.L	[r5], r5
 3298 0040 AB DD                   		mov.L	60[r5], r5
 3299 0042 CD 55 5C                		mov.B	92[r5], r5
 3300 0045 64 45                   		and	#4, r5
 3301                             		.loc 2 3220 20
 3302 0047 5B 55                   		movu.B	r5, r5
 3303 0049 61 05                   		cmp	#0, r5
 3304 004b 20 25                   		beq	.L206
3221:../src/src/tls.c ****                     csr->request.ocsp.ssl = ssl;
 3305                             		.loc 2 3221 43
 3306 004d ED A5 01                		mov.L	4[r10], r5
 3307 0050 ED A4 02                		mov.L	8[r10], r4
 3308 0053 A5 D4                   		mov.L	r4, 88[r5]
3222:../src/src/tls.c ****                     return CheckOcspRequest(SSL_CM(ssl)->ocsp,
 3309                             		.loc 2 3222 45
 3310 0055 ED A5 02                		mov.L	8[r10], r5
 3311 0058 EC 55                   		mov.L	[r5], r5
 3312 005a AB DD                   		mov.L	60[r5], r5
 3313                             		.loc 2 3222 28
 3314 005c AB 5C                   		mov.L	52[r5], r4
 3315 005e ED A5 01                		mov.L	4[r10], r5
 3316 0061 62 85                   		add	#8, r5
 3317 0063 66 03                   		mov.L	#0, r3
 3318 0065 EF 52                   		mov.L	r5, r2
 3319 0067 EF 41                   		mov.L	r4, r1
 3320 0069 05 00 00 00             		bsr	_CheckOcspRequest
 3321 006d EF 15                   		mov.L	r1, r5
 3322 006f 08                      		bra	.L207
 3323                             	.L206:
3223:../src/src/tls.c ****                                                       &csr->request.ocsp, NULL);
3224:../src/src/tls.c ****                 }
3225:../src/src/tls.c ****                 else
3226:../src/src/tls.c ****                     return OCSP_LOOKUP_FAIL;
 3324                             		.loc 2 3226 28
 3325 0070 FB 5A 91 FE             		mov.L	#-367, r5
 3326 0074 0B                      		bra	.L207
 3327                             	.L205:
3227:../src/src/tls.c ****         }
3228:../src/src/tls.c ****     }
3229:../src/src/tls.c **** 
3230:../src/src/tls.c ****     return 0;
 3328                             		.loc 2 3230 12
 3329 0075 66 05                   		mov.L	#0, r5
 3330                             	.L207:
3231:../src/src/tls.c **** }
 3331                             		.loc 2 3231 1
 3332 0077 EF 51                   		mov.L	r5, r1
 3333 0079 3F AA 04                		rtsd	#16, r10-r10
 3334                             	.LFE73:
 3336                             		.section	.text.TLSX_UseCertificateStatusRequest,"ax",@progbits
 3337                             		.global	_TLSX_UseCertificateStatusRequest
 3339                             	_TLSX_UseCertificateStatusRequest:
 3340                             	.LFB74:
3232:../src/src/tls.c **** 
3233:../src/src/tls.c **** int TLSX_UseCertificateStatusRequest(TLSX** extensions, byte status_type,
3234:../src/src/tls.c ****                                          byte options, WOLFSSL* ssl, void* heap,
3235:../src/src/tls.c ****                                                                       int devId)
3236:../src/src/tls.c **** {
 3341                             		.loc 2 3236 1
 3342 0000 7E AA                   		push.l	r10
 3343                             	.LCFI95:
 3344 0002 7E A6                   		push.l	r6
 3345                             	.LCFI96:
 3346 0004 71 0A D0                		add	#-48, r0, r10
 3347                             	.LCFI97:
 3348 0007 EF A0                   		mov.L	r10, r0
 3349 0009 75 46 3C                		mov.L	#60, r6
 3350 000c 4B A6                   		add	r10, r6
 3351 000e E7 A1 07                		mov.L	r1, 28[r10]
 3352 0011 C7 A2 20                		mov.B	r2, 32[r10]
 3353 0014 C7 A3 21                		mov.B	r3, 33[r10]
 3354 0017 E7 A4 09                		mov.L	r4, 36[r10]
3237:../src/src/tls.c ****     CertificateStatusRequest* csr = NULL;
 3355                             		.loc 2 3237 31
 3356 001a F8 A6 00                		mov.L	#0, [r10]
3238:../src/src/tls.c ****     int ret = 0;
 3357                             		.loc 2 3238 9
 3358 001d F9 A6 01 00             		mov.L	#0, 4[r10]
3239:../src/src/tls.c **** 
3240:../src/src/tls.c ****     if (!extensions || status_type != WOLFSSL_CSR_OCSP)
 3359                             		.loc 2 3240 8
 3360 0021 ED A5 07                		mov.L	28[r10], r5
 3361 0024 61 05                   		cmp	#0, r5
 3362 0026 17                      		beq	.L209
 3363                             		.loc 2 3240 21 discriminator 1
 3364 0027 59 A5 20                		movu.B	32[r10], r5
 3365 002a 61 15                   		cmp	#1, r5
 3366 002c 10                      		beq	.L210
 3367                             	.L209:
3241:../src/src/tls.c ****         return BAD_FUNC_ARG;
 3368                             		.loc 2 3241 16
 3369 002d FB 5A 53 FF             		mov.L	#-173, r5
 3370 0031 38 B5 00                		bra	.L211
 3371                             	.L210:
3242:../src/src/tls.c **** 
3243:../src/src/tls.c ****     csr = (CertificateStatusRequest*)
3244:../src/src/tls.c ****              XMALLOC(sizeof(CertificateStatusRequest), heap, DYNAMIC_TYPE_TLSX);
 3372                             		.loc 2 3244 14
 3373 0034 75 41 5C                		mov.L	#0x5c, r1
 3374 0037 05 00 00 00             		bsr	_wolfSSL_Malloc
 3375 003b E3 A1                   		mov.L	r1, [r10]
3245:../src/src/tls.c ****     if (!csr)
 3376                             		.loc 2 3245 8
 3377 003d EC A5                   		mov.L	[r10], r5
 3378 003f 61 05                   		cmp	#0, r5
 3379 0041 1F                      		bne	.L212
3246:../src/src/tls.c ****         return MEMORY_E;
 3380                             		.loc 2 3246 16
 3381 0042 FB 56 83                		mov.L	#-125, r5
 3382 0045 38 A1 00                		bra	.L211
 3383                             	.L212:
3247:../src/src/tls.c **** 
3248:../src/src/tls.c ****     ForceZero(csr, sizeof(CertificateStatusRequest));
 3384                             		.loc 2 3248 5
 3385 0048 75 42 5C                		mov.L	#0x5c, r2
 3386 004b EC A1                   		mov.L	[r10], r1
 3387 004d 05 00 00 00             		bsr	_ForceZero
3249:../src/src/tls.c **** 
3250:../src/src/tls.c ****     csr->status_type = status_type;
 3388                             		.loc 2 3250 22
 3389 0051 EC A5                   		mov.L	[r10], r5
 3390 0053 CD A4 20                		mov.B	32[r10], r4
 3391 0056 C3 54                   		mov.B	r4, [r5]
3251:../src/src/tls.c ****     csr->options     = options;
 3392                             		.loc 2 3251 22
 3393 0058 EC A5                   		mov.L	[r10], r5
 3394 005a CD A4 21                		mov.B	33[r10], r4
 3395 005d 80 5C                   		mov.B	r4, 1[r5]
3252:../src/src/tls.c ****     csr->ssl         = ssl;
 3396                             		.loc 2 3252 22
 3397 005f EC A5                   		mov.L	[r10], r5
 3398 0061 ED A4 09                		mov.L	36[r10], r4
 3399 0064 A0 5C                   		mov.L	r4, 4[r5]
3253:../src/src/tls.c **** 
3254:../src/src/tls.c ****     switch (csr->status_type) {
 3400                             		.loc 2 3254 16
 3401 0066 EC A5                   		mov.L	[r10], r5
 3402 0068 CC 55                   		mov.B	[r5], r5
 3403 006a 5B 55                   		movu.B	r5, r5
 3404                             		.loc 2 3254 5
 3405 006c 61 15                   		cmp	#1, r5
 3406 006e 21 49                   		bne	.L213
3255:../src/src/tls.c ****         case WOLFSSL_CSR_OCSP:
3256:../src/src/tls.c ****             if (options & WOLFSSL_CSR_OCSP_USE_NONCE) {
 3407                             		.loc 2 3256 25
 3408 0070 59 A5 21                		movu.B	33[r10], r5
 3409 0073 64 15                   		and	#1, r5
 3410                             		.loc 2 3256 16
 3411 0075 61 05                   		cmp	#0, r5
 3412 0077 20 3F                   		beq	.L219
 3413                             	.LBB10:
3257:../src/src/tls.c ****                 WC_RNG rng;
3258:../src/src/tls.c **** 
3259:../src/src/tls.c ****             #ifndef HAVE_FIPS
3260:../src/src/tls.c ****                 ret = wc_InitRng_ex(&rng, heap, devId);
 3414                             		.loc 2 3260 23
 3415 0079 71 A5 0C                		add	#12, r10, r5
 3416 007c A8 6B                   		mov.L	4[r6], r3
 3417 007e EC 62                   		mov.L	[r6], r2
 3418 0080 EF 51                   		mov.L	r5, r1
 3419 0082 05 00 00 00             		bsr	_wc_InitRng_ex
 3420 0086 E7 A1 01                		mov.L	r1, 4[r10]
3261:../src/src/tls.c ****             #else
3262:../src/src/tls.c ****                 ret = wc_InitRng(&rng);
3263:../src/src/tls.c ****                 (void)devId;
3264:../src/src/tls.c ****             #endif
3265:../src/src/tls.c ****                 if (ret == 0) {
 3421                             		.loc 2 3265 20
 3422 0089 ED A5 01                		mov.L	4[r10], r5
 3423 008c 61 05                   		cmp	#0, r5
 3424 008e 21 28                   		bne	.L219
3266:../src/src/tls.c ****                     if (wc_RNG_GenerateBlock(&rng, csr->request.ocsp.nonce,
 3425                             		.loc 2 3266 69
 3426 0090 EC A5                   		mov.L	[r10], r5
 3427 0092 71 54 40                		add	#0x40, r5, r4
 3428                             		.loc 2 3266 25
 3429 0095 71 A5 0C                		add	#12, r10, r5
 3430 0098 75 43 10                		mov.L	#16, r3
 3431 009b EF 42                   		mov.L	r4, r2
 3432 009d EF 51                   		mov.L	r5, r1
 3433 009f 05 00 00 00             		bsr	_wc_RNG_GenerateBlock
 3434 00a3 EF 15                   		mov.L	r1, r5
 3435                             		.loc 2 3266 24
 3436 00a5 61 05                   		cmp	#0, r5
 3437 00a7 1E                      		bne	.L216
3267:../src/src/tls.c ****                                                         MAX_OCSP_NONCE_SZ) == 0)
3268:../src/src/tls.c ****                         csr->request.ocsp.nonceSz = MAX_OCSP_NONCE_SZ;
 3438                             		.loc 2 3268 51
 3439 00a8 EC A5                   		mov.L	[r10], r5
 3440 00aa 3E D4 10                		mov.L	#16, 80[r5]
 3441                             	.L216:
3269:../src/src/tls.c **** 
3270:../src/src/tls.c ****                     wc_FreeRng(&rng);
 3442                             		.loc 2 3270 21
 3443 00ad 71 A5 0C                		add	#12, r10, r5
 3444 00b0 EF 51                   		mov.L	r5, r1
 3445 00b2 05 00 00 00             		bsr	_wc_FreeRng
 3446                             	.L219:
 3447                             	.LBE10:
3271:../src/src/tls.c ****                 }
3272:../src/src/tls.c ****             }
3273:../src/src/tls.c ****         break;
 3448                             		.loc 2 3273 9
 3449 00b6 03                      		nop
 3450                             	.L213:
3274:../src/src/tls.c ****     }
3275:../src/src/tls.c **** 
3276:../src/src/tls.c ****     if ((ret = TLSX_Push(extensions, TLSX_STATUS_REQUEST, csr, heap)) != 0) {
 3451                             		.loc 2 3276 16
 3452 00b7 EC 64                   		mov.L	[r6], r4
 3453 00b9 EC A3                   		mov.L	[r10], r3
 3454 00bb 66 52                   		mov.L	#5, r2
 3455 00bd ED A1 07                		mov.L	28[r10], r1
 3456 00c0 05 00 00 00             		bsr	_TLSX_Push
 3457 00c4 E7 A1 01                		mov.L	r1, 4[r10]
 3458                             		.loc 2 3276 8
 3459 00c7 ED A5 01                		mov.L	4[r10], r5
 3460 00ca 61 05                   		cmp	#0, r5
 3461 00cc 20 18                   		beq	.L217
 3462                             	.LBB11:
3277:../src/src/tls.c ****         XFREE(csr, heap, DYNAMIC_TYPE_TLSX);
 3463                             		.loc 2 3277 9
 3464 00ce EC A5                   		mov.L	[r10], r5
 3465 00d0 E7 A5 02                		mov.L	r5, 8[r10]
 3466 00d3 ED A5 02                		mov.L	8[r10], r5
 3467 00d6 61 05                   		cmp	#0, r5
 3468 00d8 10                      		beq	.L218
 3469                             		.loc 2 3277 9 is_stmt 0 discriminator 1
 3470 00d9 ED A1 02                		mov.L	8[r10], r1
 3471 00dc 05 00 00 00             		bsr	_wolfSSL_Free
 3472                             	.L218:
 3473                             	.LBE11:
3278:../src/src/tls.c ****         return ret;
 3474                             		.loc 2 3278 16 is_stmt 1
 3475 00e0 ED A5 01                		mov.L	4[r10], r5
 3476 00e3 0B                      		bra	.L211
 3477                             	.L217:
3279:../src/src/tls.c ****     }
3280:../src/src/tls.c **** 
3281:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
 3478                             		.loc 2 3281 12
 3479 00e4 66 15                   		mov.L	#1, r5
 3480                             		.balign 8,3,1
 3481                             	.L211:
3282:../src/src/tls.c **** }
 3482                             		.loc 2 3282 1
 3483 00e6 EF 51                   		mov.L	r5, r1
 3484 00e8 71 00 30                		add	#48, r0
 3485 00eb 7E B6                   		pop	r6
 3486 00ed 7E BA                   		pop	r10
 3487 00ef 02                      		rts
 3488                             	.LFE74:
 3490                             		.section	.text.TLSX_SupportedCurve_New,"ax",@progbits
 3492                             	_TLSX_SupportedCurve_New:
 3493                             	.LFB75:
3283:../src/src/tls.c **** 
3284:../src/src/tls.c **** #define CSR_FREE_ALL TLSX_CSR_Free
3285:../src/src/tls.c **** #define CSR_GET_SIZE TLSX_CSR_GetSize
3286:../src/src/tls.c **** #define CSR_WRITE    TLSX_CSR_Write
3287:../src/src/tls.c **** #define CSR_PARSE    TLSX_CSR_Parse
3288:../src/src/tls.c **** 
3289:../src/src/tls.c **** #else
3290:../src/src/tls.c **** 
3291:../src/src/tls.c **** #define CSR_FREE_ALL(data, heap)
3292:../src/src/tls.c **** #define CSR_GET_SIZE(a, b)    0
3293:../src/src/tls.c **** #define CSR_WRITE(a, b, c)    0
3294:../src/src/tls.c **** #define CSR_PARSE(a, b, c, d) 0
3295:../src/src/tls.c **** 
3296:../src/src/tls.c **** #endif /* HAVE_CERTIFICATE_STATUS_REQUEST */
3297:../src/src/tls.c **** 
3298:../src/src/tls.c **** /******************************************************************************/
3299:../src/src/tls.c **** /* Certificate Status Request v2                                              */
3300:../src/src/tls.c **** /******************************************************************************/
3301:../src/src/tls.c **** 
3302:../src/src/tls.c **** #ifdef HAVE_CERTIFICATE_STATUS_REQUEST_V2
3303:../src/src/tls.c **** 
3304:../src/src/tls.c **** static void TLSX_CSR2_FreeAll(CertificateStatusRequestItemV2* csr2, void* heap)
3305:../src/src/tls.c **** {
3306:../src/src/tls.c ****     CertificateStatusRequestItemV2* next;
3307:../src/src/tls.c **** 
3308:../src/src/tls.c ****     for (; csr2; csr2 = next) {
3309:../src/src/tls.c ****         next = csr2->next;
3310:../src/src/tls.c **** 
3311:../src/src/tls.c ****         switch (csr2->status_type) {
3312:../src/src/tls.c ****             case WOLFSSL_CSR2_OCSP:
3313:../src/src/tls.c ****             case WOLFSSL_CSR2_OCSP_MULTI:
3314:../src/src/tls.c ****                 while(csr2->requests--)
3315:../src/src/tls.c ****                     FreeOcspRequest(&csr2->request.ocsp[csr2->requests]);
3316:../src/src/tls.c ****             break;
3317:../src/src/tls.c ****         }
3318:../src/src/tls.c **** 
3319:../src/src/tls.c ****         XFREE(csr2, heap, DYNAMIC_TYPE_TLSX);
3320:../src/src/tls.c ****     }
3321:../src/src/tls.c ****     (void)heap;
3322:../src/src/tls.c **** }
3323:../src/src/tls.c **** 
3324:../src/src/tls.c **** static word16 TLSX_CSR2_GetSize(CertificateStatusRequestItemV2* csr2,
3325:../src/src/tls.c ****                                                                  byte isRequest)
3326:../src/src/tls.c **** {
3327:../src/src/tls.c ****     word16 size = 0;
3328:../src/src/tls.c **** 
3329:../src/src/tls.c ****     /* shut up compiler warnings */
3330:../src/src/tls.c ****     (void) csr2; (void) isRequest;
3331:../src/src/tls.c **** 
3332:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
3333:../src/src/tls.c ****     if (isRequest) {
3334:../src/src/tls.c ****         CertificateStatusRequestItemV2* next;
3335:../src/src/tls.c **** 
3336:../src/src/tls.c ****         for (size = OPAQUE16_LEN; csr2; csr2 = next) {
3337:../src/src/tls.c ****             next = csr2->next;
3338:../src/src/tls.c **** 
3339:../src/src/tls.c ****             switch (csr2->status_type) {
3340:../src/src/tls.c ****                 case WOLFSSL_CSR2_OCSP:
3341:../src/src/tls.c ****                 case WOLFSSL_CSR2_OCSP_MULTI:
3342:../src/src/tls.c ****                     size += ENUM_LEN + 3 * OPAQUE16_LEN;
3343:../src/src/tls.c **** 
3344:../src/src/tls.c ****                     if (csr2->request.ocsp[0].nonceSz)
3345:../src/src/tls.c ****                         size += OCSP_NONCE_EXT_SZ;
3346:../src/src/tls.c ****                 break;
3347:../src/src/tls.c ****             }
3348:../src/src/tls.c ****         }
3349:../src/src/tls.c ****     }
3350:../src/src/tls.c **** #endif
3351:../src/src/tls.c **** 
3352:../src/src/tls.c ****     return size;
3353:../src/src/tls.c **** }
3354:../src/src/tls.c **** 
3355:../src/src/tls.c **** static word16 TLSX_CSR2_Write(CertificateStatusRequestItemV2* csr2,
3356:../src/src/tls.c ****                                                    byte* output, byte isRequest)
3357:../src/src/tls.c **** {
3358:../src/src/tls.c ****     /* shut up compiler warnings */
3359:../src/src/tls.c ****     (void) csr2; (void) output; (void) isRequest;
3360:../src/src/tls.c **** 
3361:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
3362:../src/src/tls.c ****     if (isRequest) {
3363:../src/src/tls.c ****         word16 offset;
3364:../src/src/tls.c ****         word16 length;
3365:../src/src/tls.c **** 
3366:../src/src/tls.c ****         for (offset = OPAQUE16_LEN; csr2 != NULL; csr2 = csr2->next) {
3367:../src/src/tls.c ****             /* status_type */
3368:../src/src/tls.c ****             output[offset++] = csr2->status_type;
3369:../src/src/tls.c **** 
3370:../src/src/tls.c ****             /* request */
3371:../src/src/tls.c ****             switch (csr2->status_type) {
3372:../src/src/tls.c ****                 case WOLFSSL_CSR2_OCSP:
3373:../src/src/tls.c ****                 case WOLFSSL_CSR2_OCSP_MULTI:
3374:../src/src/tls.c ****                     /* request_length */
3375:../src/src/tls.c ****                     length = 2 * OPAQUE16_LEN;
3376:../src/src/tls.c **** 
3377:../src/src/tls.c ****                     if (csr2->request.ocsp[0].nonceSz)
3378:../src/src/tls.c ****                         length += OCSP_NONCE_EXT_SZ;
3379:../src/src/tls.c **** 
3380:../src/src/tls.c ****                     c16toa(length, output + offset);
3381:../src/src/tls.c ****                     offset += OPAQUE16_LEN;
3382:../src/src/tls.c **** 
3383:../src/src/tls.c ****                     /* responder id list */
3384:../src/src/tls.c ****                     c16toa(0, output + offset);
3385:../src/src/tls.c ****                     offset += OPAQUE16_LEN;
3386:../src/src/tls.c **** 
3387:../src/src/tls.c ****                     /* request extensions */
3388:../src/src/tls.c ****                     length = 0;
3389:../src/src/tls.c **** 
3390:../src/src/tls.c ****                     if (csr2->request.ocsp[0].nonceSz)
3391:../src/src/tls.c ****                         length = (word16)EncodeOcspRequestExtensions(
3392:../src/src/tls.c ****                                                  &csr2->request.ocsp[0],
3393:../src/src/tls.c ****                                                  output + offset + OPAQUE16_LEN,
3394:../src/src/tls.c ****                                                  OCSP_NONCE_EXT_SZ);
3395:../src/src/tls.c **** 
3396:../src/src/tls.c ****                     c16toa(length, output + offset);
3397:../src/src/tls.c ****                     offset += OPAQUE16_LEN + length;
3398:../src/src/tls.c ****                 break;
3399:../src/src/tls.c ****             }
3400:../src/src/tls.c ****         }
3401:../src/src/tls.c **** 
3402:../src/src/tls.c ****         /* list size */
3403:../src/src/tls.c ****         c16toa(offset - OPAQUE16_LEN, output);
3404:../src/src/tls.c **** 
3405:../src/src/tls.c ****         return offset;
3406:../src/src/tls.c ****     }
3407:../src/src/tls.c **** #endif
3408:../src/src/tls.c **** 
3409:../src/src/tls.c ****     return 0;
3410:../src/src/tls.c **** }
3411:../src/src/tls.c **** 
3412:../src/src/tls.c **** static int TLSX_CSR2_Parse(WOLFSSL* ssl, const byte* input, word16 length,
3413:../src/src/tls.c ****                            byte isRequest)
3414:../src/src/tls.c **** {
3415:../src/src/tls.c ****     int ret;
3416:../src/src/tls.c **** 
3417:../src/src/tls.c ****     /* shut up compiler warnings */
3418:../src/src/tls.c ****     (void) ssl; (void) input;
3419:../src/src/tls.c **** 
3420:../src/src/tls.c ****     if (!isRequest) {
3421:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
3422:../src/src/tls.c ****         TLSX* extension = TLSX_Find(ssl->extensions, TLSX_STATUS_REQUEST_V2);
3423:../src/src/tls.c ****         CertificateStatusRequestItemV2* csr2 = extension ?
3424:../src/src/tls.c ****                         (CertificateStatusRequestItemV2*)extension->data : NULL;
3425:../src/src/tls.c **** 
3426:../src/src/tls.c ****         if (!csr2) {
3427:../src/src/tls.c ****             /* look at context level */
3428:../src/src/tls.c ****             extension = TLSX_Find(ssl->ctx->extensions, TLSX_STATUS_REQUEST_V2);
3429:../src/src/tls.c ****             csr2 = extension ?
3430:../src/src/tls.c ****                         (CertificateStatusRequestItemV2*)extension->data : NULL;
3431:../src/src/tls.c **** 
3432:../src/src/tls.c ****             if (!csr2) /* unexpected extension */
3433:../src/src/tls.c ****                 return TLSX_HandleUnsupportedExtension(ssl);
3434:../src/src/tls.c **** 
3435:../src/src/tls.c ****             /* enable extension at ssl level */
3436:../src/src/tls.c ****             for (; csr2; csr2 = csr2->next) {
3437:../src/src/tls.c ****                 ret = TLSX_UseCertificateStatusRequestV2(&ssl->extensions,
3438:../src/src/tls.c ****                                     csr2->status_type, csr2->options, ssl->heap,
3439:../src/src/tls.c ****                                                                     ssl->devId);
3440:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS)
3441:../src/src/tls.c ****                     return ret;
3442:../src/src/tls.c **** 
3443:../src/src/tls.c ****                 switch (csr2->status_type) {
3444:../src/src/tls.c ****                     case WOLFSSL_CSR2_OCSP:
3445:../src/src/tls.c ****                         /* followed by */
3446:../src/src/tls.c ****                     case WOLFSSL_CSR2_OCSP_MULTI:
3447:../src/src/tls.c ****                         /* propagate nonce */
3448:../src/src/tls.c ****                         if (csr2->request.ocsp[0].nonceSz) {
3449:../src/src/tls.c ****                             OcspRequest* request =
3450:../src/src/tls.c ****                              (OcspRequest*)TLSX_CSR2_GetRequest(ssl->extensions,
3451:../src/src/tls.c ****                                                           csr2->status_type, 0);
3452:../src/src/tls.c **** 
3453:../src/src/tls.c ****                             if (request) {
3454:../src/src/tls.c ****                                 XMEMCPY(request->nonce,
3455:../src/src/tls.c ****                                         csr2->request.ocsp[0].nonce,
3456:../src/src/tls.c ****                                         csr2->request.ocsp[0].nonceSz);
3457:../src/src/tls.c **** 
3458:../src/src/tls.c ****                                 request->nonceSz =
3459:../src/src/tls.c ****                                                   csr2->request.ocsp[0].nonceSz;
3460:../src/src/tls.c ****                             }
3461:../src/src/tls.c ****                         }
3462:../src/src/tls.c ****                     break;
3463:../src/src/tls.c ****                 }
3464:../src/src/tls.c ****             }
3465:../src/src/tls.c ****         }
3466:../src/src/tls.c **** 
3467:../src/src/tls.c ****         ssl->status_request_v2 = 1;
3468:../src/src/tls.c **** 
3469:../src/src/tls.c ****         return length ? BUFFER_ERROR : 0; /* extension_data MUST be empty. */
3470:../src/src/tls.c **** #endif
3471:../src/src/tls.c ****     }
3472:../src/src/tls.c ****     else {
3473:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
3474:../src/src/tls.c ****         byte   status_type;
3475:../src/src/tls.c ****         word16 request_length;
3476:../src/src/tls.c ****         word16 offset = 0;
3477:../src/src/tls.c ****         word16 size = 0;
3478:../src/src/tls.c **** 
3479:../src/src/tls.c ****         /* list size */
3480:../src/src/tls.c ****         if (offset + OPAQUE16_LEN >= length) {
3481:../src/src/tls.c ****             return BUFFER_E;
3482:../src/src/tls.c ****         }
3483:../src/src/tls.c **** 
3484:../src/src/tls.c ****         ato16(input + offset, &request_length);
3485:../src/src/tls.c ****         offset += OPAQUE16_LEN;
3486:../src/src/tls.c **** 
3487:../src/src/tls.c ****         if (length - OPAQUE16_LEN != request_length)
3488:../src/src/tls.c ****             return BUFFER_ERROR;
3489:../src/src/tls.c **** 
3490:../src/src/tls.c ****         while (length > offset) {
3491:../src/src/tls.c ****             if ((int)(length - offset) < ENUM_LEN + OPAQUE16_LEN)
3492:../src/src/tls.c ****                 return BUFFER_ERROR;
3493:../src/src/tls.c **** 
3494:../src/src/tls.c ****             status_type = input[offset++];
3495:../src/src/tls.c **** 
3496:../src/src/tls.c ****             ato16(input + offset, &request_length);
3497:../src/src/tls.c ****             offset += OPAQUE16_LEN;
3498:../src/src/tls.c **** 
3499:../src/src/tls.c ****             if (length - offset < request_length)
3500:../src/src/tls.c ****                 return BUFFER_ERROR;
3501:../src/src/tls.c **** 
3502:../src/src/tls.c ****             switch (status_type) {
3503:../src/src/tls.c ****                 case WOLFSSL_CSR2_OCSP:
3504:../src/src/tls.c ****                 case WOLFSSL_CSR2_OCSP_MULTI:
3505:../src/src/tls.c ****                     /* skip responder_id_list */
3506:../src/src/tls.c ****                     if ((int)(length - offset) < OPAQUE16_LEN)
3507:../src/src/tls.c ****                         return BUFFER_ERROR;
3508:../src/src/tls.c **** 
3509:../src/src/tls.c ****                     ato16(input + offset, &size);
3510:../src/src/tls.c ****                     if (length - offset < size)
3511:../src/src/tls.c ****                         return BUFFER_ERROR;
3512:../src/src/tls.c **** 
3513:../src/src/tls.c ****                     offset += OPAQUE16_LEN + size;
3514:../src/src/tls.c ****                     /* skip request_extensions */
3515:../src/src/tls.c ****                     if ((int)(length - offset) < OPAQUE16_LEN)
3516:../src/src/tls.c ****                         return BUFFER_ERROR;
3517:../src/src/tls.c **** 
3518:../src/src/tls.c ****                     ato16(input + offset, &size);
3519:../src/src/tls.c ****                     if (length - offset < size)
3520:../src/src/tls.c ****                         return BUFFER_ERROR;
3521:../src/src/tls.c **** 
3522:../src/src/tls.c ****                     offset += OPAQUE16_LEN + size;
3523:../src/src/tls.c ****                     if (offset > length)
3524:../src/src/tls.c ****                         return BUFFER_ERROR;
3525:../src/src/tls.c **** 
3526:../src/src/tls.c ****                     /* is able to send OCSP response? */
3527:../src/src/tls.c ****                     if (SSL_CM(ssl) == NULL
3528:../src/src/tls.c ****                     || !SSL_CM(ssl)->ocspStaplingEnabled)
3529:../src/src/tls.c ****                         continue;
3530:../src/src/tls.c ****                 break;
3531:../src/src/tls.c **** 
3532:../src/src/tls.c ****                 default:
3533:../src/src/tls.c ****                     /* unknown status type, skipping! */
3534:../src/src/tls.c ****                     offset += request_length;
3535:../src/src/tls.c ****                     continue;
3536:../src/src/tls.c ****             }
3537:../src/src/tls.c **** 
3538:../src/src/tls.c ****             /* if using status_request and already sending it, remove it
3539:../src/src/tls.c ****              * and prefer to use the v2 version */
3540:../src/src/tls.c ****             #ifdef HAVE_CERTIFICATE_STATUS_REQUEST
3541:../src/src/tls.c ****             if (ssl->status_request) {
3542:../src/src/tls.c ****                 ssl->status_request = 0;
3543:../src/src/tls.c ****                 TLSX_Remove(&ssl->extensions, TLSX_STATUS_REQUEST, ssl->heap);
3544:../src/src/tls.c ****             }
3545:../src/src/tls.c ****             #endif
3546:../src/src/tls.c **** 
3547:../src/src/tls.c ****             /* TLS 1.3 servers MUST NOT act upon presence or information in
3548:../src/src/tls.c ****              * this extension (RFC 8448 Section 4.4.2.1).
3549:../src/src/tls.c ****              */
3550:../src/src/tls.c ****             if (!IsAtLeastTLSv1_3(ssl->version)) {
3551:../src/src/tls.c ****                 /* accept the first good status_type and return */
3552:../src/src/tls.c ****                 ret = TLSX_UseCertificateStatusRequestV2(&ssl->extensions,
3553:../src/src/tls.c ****                                          status_type, 0, ssl->heap, ssl->devId);
3554:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS)
3555:../src/src/tls.c ****                     return ret; /* throw error */
3556:../src/src/tls.c **** 
3557:../src/src/tls.c ****                 TLSX_SetResponse(ssl, TLSX_STATUS_REQUEST_V2);
3558:../src/src/tls.c ****                 ssl->status_request_v2 = status_type;
3559:../src/src/tls.c ****             }
3560:../src/src/tls.c **** 
3561:../src/src/tls.c ****             return 0;
3562:../src/src/tls.c ****         }
3563:../src/src/tls.c **** #endif
3564:../src/src/tls.c ****     }
3565:../src/src/tls.c **** 
3566:../src/src/tls.c ****     return 0;
3567:../src/src/tls.c **** }
3568:../src/src/tls.c **** 
3569:../src/src/tls.c **** int TLSX_CSR2_InitRequests(TLSX* extensions, DecodedCert* cert, byte isPeer,
3570:../src/src/tls.c ****                                                                      void* heap)
3571:../src/src/tls.c **** {
3572:../src/src/tls.c ****     TLSX* extension = TLSX_Find(extensions, TLSX_STATUS_REQUEST_V2);
3573:../src/src/tls.c ****     CertificateStatusRequestItemV2* csr2 = extension ?
3574:../src/src/tls.c ****         (CertificateStatusRequestItemV2*)extension->data : NULL;
3575:../src/src/tls.c ****     int ret = 0;
3576:../src/src/tls.c **** 
3577:../src/src/tls.c ****     for (; csr2; csr2 = csr2->next) {
3578:../src/src/tls.c ****         switch (csr2->status_type) {
3579:../src/src/tls.c ****             case WOLFSSL_CSR2_OCSP:
3580:../src/src/tls.c ****                 if (!isPeer || csr2->requests != 0)
3581:../src/src/tls.c ****                     break;
3582:../src/src/tls.c **** 
3583:../src/src/tls.c ****                 FALL_THROUGH; /* followed by */
3584:../src/src/tls.c **** 
3585:../src/src/tls.c ****             case WOLFSSL_CSR2_OCSP_MULTI: {
3586:../src/src/tls.c ****                 if (csr2->requests < 1 + MAX_CHAIN_DEPTH) {
3587:../src/src/tls.c ****                     byte nonce[MAX_OCSP_NONCE_SZ];
3588:../src/src/tls.c ****                     int  nonceSz = csr2->request.ocsp[0].nonceSz;
3589:../src/src/tls.c **** 
3590:../src/src/tls.c ****                     /* preserve nonce, replicating nonce of ocsp[0] */
3591:../src/src/tls.c ****                     XMEMCPY(nonce, csr2->request.ocsp[0].nonce, nonceSz);
3592:../src/src/tls.c **** 
3593:../src/src/tls.c ****                     if ((ret = InitOcspRequest(
3594:../src/src/tls.c ****                                       &csr2->request.ocsp[csr2->requests], cert,
3595:../src/src/tls.c ****                                                                  0, heap)) != 0)
3596:../src/src/tls.c ****                         return ret;
3597:../src/src/tls.c **** 
3598:../src/src/tls.c ****                     /* restore nonce */
3599:../src/src/tls.c ****                     XMEMCPY(csr2->request.ocsp[csr2->requests].nonce,
3600:../src/src/tls.c ****                                                                 nonce, nonceSz);
3601:../src/src/tls.c ****                     csr2->request.ocsp[csr2->requests].nonceSz = nonceSz;
3602:../src/src/tls.c ****                     csr2->requests++;
3603:../src/src/tls.c ****                 }
3604:../src/src/tls.c ****             }
3605:../src/src/tls.c ****             break;
3606:../src/src/tls.c ****         }
3607:../src/src/tls.c ****     }
3608:../src/src/tls.c **** 
3609:../src/src/tls.c ****     (void)cert;
3610:../src/src/tls.c ****     return ret;
3611:../src/src/tls.c **** }
3612:../src/src/tls.c **** 
3613:../src/src/tls.c **** void* TLSX_CSR2_GetRequest(TLSX* extensions, byte status_type, byte idx)
3614:../src/src/tls.c **** {
3615:../src/src/tls.c ****     TLSX* extension = TLSX_Find(extensions, TLSX_STATUS_REQUEST_V2);
3616:../src/src/tls.c ****     CertificateStatusRequestItemV2* csr2 = extension ?
3617:../src/src/tls.c ****                         (CertificateStatusRequestItemV2*)extension->data : NULL;
3618:../src/src/tls.c **** 
3619:../src/src/tls.c ****     for (; csr2; csr2 = csr2->next) {
3620:../src/src/tls.c ****         if (csr2->status_type == status_type) {
3621:../src/src/tls.c ****             switch (csr2->status_type) {
3622:../src/src/tls.c ****                 case WOLFSSL_CSR2_OCSP:
3623:../src/src/tls.c ****                     /* followed by */
3624:../src/src/tls.c **** 
3625:../src/src/tls.c ****                 case WOLFSSL_CSR2_OCSP_MULTI:
3626:../src/src/tls.c ****                     /* requests are initialized in the reverse order */
3627:../src/src/tls.c ****                     return idx < csr2->requests
3628:../src/src/tls.c ****                          ? &csr2->request.ocsp[csr2->requests - idx - 1]
3629:../src/src/tls.c ****                          : NULL;
3630:../src/src/tls.c ****             }
3631:../src/src/tls.c ****         }
3632:../src/src/tls.c ****     }
3633:../src/src/tls.c **** 
3634:../src/src/tls.c ****     return NULL;
3635:../src/src/tls.c **** }
3636:../src/src/tls.c **** 
3637:../src/src/tls.c **** int TLSX_CSR2_ForceRequest(WOLFSSL* ssl)
3638:../src/src/tls.c **** {
3639:../src/src/tls.c ****     TLSX* extension = TLSX_Find(ssl->extensions, TLSX_STATUS_REQUEST_V2);
3640:../src/src/tls.c ****     CertificateStatusRequestItemV2* csr2 = extension ?
3641:../src/src/tls.c ****                         (CertificateStatusRequestItemV2*)extension->data : NULL;
3642:../src/src/tls.c **** 
3643:../src/src/tls.c ****     /* forces only the first one */
3644:../src/src/tls.c ****     if (csr2) {
3645:../src/src/tls.c ****         switch (csr2->status_type) {
3646:../src/src/tls.c ****             case WOLFSSL_CSR2_OCSP:
3647:../src/src/tls.c ****                 /* followed by */
3648:../src/src/tls.c **** 
3649:../src/src/tls.c ****             case WOLFSSL_CSR2_OCSP_MULTI:
3650:../src/src/tls.c ****                 if (SSL_CM(ssl)->ocspEnabled) {
3651:../src/src/tls.c ****                     csr2->request.ocsp[0].ssl = ssl;
3652:../src/src/tls.c ****                     return CheckOcspRequest(SSL_CM(ssl)->ocsp,
3653:../src/src/tls.c ****                                                   &csr2->request.ocsp[0], NULL);
3654:../src/src/tls.c ****                 }
3655:../src/src/tls.c ****                 else
3656:../src/src/tls.c ****                     return OCSP_LOOKUP_FAIL;
3657:../src/src/tls.c ****         }
3658:../src/src/tls.c ****     }
3659:../src/src/tls.c **** 
3660:../src/src/tls.c ****     return 0;
3661:../src/src/tls.c **** }
3662:../src/src/tls.c **** 
3663:../src/src/tls.c **** int TLSX_UseCertificateStatusRequestV2(TLSX** extensions, byte status_type,
3664:../src/src/tls.c ****                                            byte options, void* heap, int devId)
3665:../src/src/tls.c **** {
3666:../src/src/tls.c ****     TLSX* extension = NULL;
3667:../src/src/tls.c ****     CertificateStatusRequestItemV2* csr2 = NULL;
3668:../src/src/tls.c ****     int ret = 0;
3669:../src/src/tls.c **** 
3670:../src/src/tls.c ****     if (!extensions)
3671:../src/src/tls.c ****         return BAD_FUNC_ARG;
3672:../src/src/tls.c **** 
3673:../src/src/tls.c ****     if (status_type != WOLFSSL_CSR2_OCSP
3674:../src/src/tls.c ****     &&  status_type != WOLFSSL_CSR2_OCSP_MULTI)
3675:../src/src/tls.c ****         return BAD_FUNC_ARG;
3676:../src/src/tls.c **** 
3677:../src/src/tls.c ****     csr2 = (CertificateStatusRequestItemV2*)
3678:../src/src/tls.c ****        XMALLOC(sizeof(CertificateStatusRequestItemV2), heap, DYNAMIC_TYPE_TLSX);
3679:../src/src/tls.c ****     if (!csr2)
3680:../src/src/tls.c ****         return MEMORY_E;
3681:../src/src/tls.c **** 
3682:../src/src/tls.c ****     ForceZero(csr2, sizeof(CertificateStatusRequestItemV2));
3683:../src/src/tls.c **** 
3684:../src/src/tls.c ****     csr2->status_type = status_type;
3685:../src/src/tls.c ****     csr2->options     = options;
3686:../src/src/tls.c ****     csr2->next        = NULL;
3687:../src/src/tls.c **** 
3688:../src/src/tls.c ****     switch (csr2->status_type) {
3689:../src/src/tls.c ****         case WOLFSSL_CSR2_OCSP:
3690:../src/src/tls.c ****         case WOLFSSL_CSR2_OCSP_MULTI:
3691:../src/src/tls.c ****             if (options & WOLFSSL_CSR2_OCSP_USE_NONCE) {
3692:../src/src/tls.c ****                 WC_RNG rng;
3693:../src/src/tls.c **** 
3694:../src/src/tls.c ****             #ifndef HAVE_FIPS
3695:../src/src/tls.c ****                 ret = wc_InitRng_ex(&rng, heap, devId);
3696:../src/src/tls.c ****             #else
3697:../src/src/tls.c ****                 ret = wc_InitRng(&rng);
3698:../src/src/tls.c ****                 (void)devId;
3699:../src/src/tls.c ****             #endif
3700:../src/src/tls.c ****                 if (ret == 0) {
3701:../src/src/tls.c ****                     if (wc_RNG_GenerateBlock(&rng, csr2->request.ocsp[0].nonce,
3702:../src/src/tls.c ****                                                         MAX_OCSP_NONCE_SZ) == 0)
3703:../src/src/tls.c ****                         csr2->request.ocsp[0].nonceSz = MAX_OCSP_NONCE_SZ;
3704:../src/src/tls.c **** 
3705:../src/src/tls.c ****                     wc_FreeRng(&rng);
3706:../src/src/tls.c ****                 }
3707:../src/src/tls.c ****             }
3708:../src/src/tls.c ****         break;
3709:../src/src/tls.c ****     }
3710:../src/src/tls.c **** 
3711:../src/src/tls.c ****     /* append new item */
3712:../src/src/tls.c ****     if ((extension = TLSX_Find(*extensions, TLSX_STATUS_REQUEST_V2))) {
3713:../src/src/tls.c ****         CertificateStatusRequestItemV2* last =
3714:../src/src/tls.c ****                                (CertificateStatusRequestItemV2*)extension->data;
3715:../src/src/tls.c **** 
3716:../src/src/tls.c ****         for (; last->next; last = last->next);
3717:../src/src/tls.c **** 
3718:../src/src/tls.c ****         last->next = csr2;
3719:../src/src/tls.c ****     }
3720:../src/src/tls.c ****     else if ((ret = TLSX_Push(extensions, TLSX_STATUS_REQUEST_V2, csr2,heap))) {
3721:../src/src/tls.c ****         XFREE(csr2, heap, DYNAMIC_TYPE_TLSX);
3722:../src/src/tls.c ****         return ret;
3723:../src/src/tls.c ****     }
3724:../src/src/tls.c **** 
3725:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
3726:../src/src/tls.c **** }
3727:../src/src/tls.c **** 
3728:../src/src/tls.c **** #define CSR2_FREE_ALL TLSX_CSR2_FreeAll
3729:../src/src/tls.c **** #define CSR2_GET_SIZE TLSX_CSR2_GetSize
3730:../src/src/tls.c **** #define CSR2_WRITE    TLSX_CSR2_Write
3731:../src/src/tls.c **** #define CSR2_PARSE    TLSX_CSR2_Parse
3732:../src/src/tls.c **** 
3733:../src/src/tls.c **** #else
3734:../src/src/tls.c **** 
3735:../src/src/tls.c **** #define CSR2_FREE_ALL(data, heap)
3736:../src/src/tls.c **** #define CSR2_GET_SIZE(a, b)    0
3737:../src/src/tls.c **** #define CSR2_WRITE(a, b, c)    0
3738:../src/src/tls.c **** #define CSR2_PARSE(a, b, c, d) 0
3739:../src/src/tls.c **** 
3740:../src/src/tls.c **** #endif /* HAVE_CERTIFICATE_STATUS_REQUEST_V2 */
3741:../src/src/tls.c **** 
3742:../src/src/tls.c **** /******************************************************************************/
3743:../src/src/tls.c **** /* Supported Elliptic Curves                                                  */
3744:../src/src/tls.c **** /******************************************************************************/
3745:../src/src/tls.c **** 
3746:../src/src/tls.c **** #ifdef HAVE_SUPPORTED_CURVES
3747:../src/src/tls.c **** 
3748:../src/src/tls.c **** #if !defined(HAVE_ECC) && !defined(HAVE_CURVE25519) && !defined(HAVE_CURVE448) \
3749:../src/src/tls.c ****                        && !defined(HAVE_FFDHE) && !defined(HAVE_PQC)
3750:../src/src/tls.c **** #error Elliptic Curves Extension requires Elliptic Curve Cryptography or liboqs groups. \
3751:../src/src/tls.c ****        Use --enable-ecc and/or --enable-liboqs in the configure script or \
3752:../src/src/tls.c ****        define HAVE_ECC. Alternatively use FFDHE for DH ciphersuites.
3753:../src/src/tls.c **** #endif
3754:../src/src/tls.c **** 
3755:../src/src/tls.c **** static int TLSX_SupportedCurve_New(SupportedCurve** curve, word16 name,
3756:../src/src/tls.c ****                                                                      void* heap)
3757:../src/src/tls.c **** {
 3494                             		.loc 2 3757 1
 3495 0000 7E AA                   		push.l	r10
 3496                             	.LCFI98:
 3497 0002 71 0A F4                		add	#-12, r0, r10
 3498                             	.LCFI99:
 3499 0005 EF A0                   		mov.L	r10, r0
 3500 0007 E3 A1                   		mov.L	r1, [r10]
 3501 0009 D7 A2 02                		mov.W	r2, 4[r10]
 3502 000c E7 A3 02                		mov.L	r3, 8[r10]
3758:../src/src/tls.c ****     if (curve == NULL)
 3503                             		.loc 2 3758 8
 3504 000f EC A5                   		mov.L	[r10], r5
 3505 0011 61 05                   		cmp	#0, r5
 3506 0013 1F                      		bne	.L221
3759:../src/src/tls.c ****         return BAD_FUNC_ARG;
 3507                             		.loc 2 3759 16
 3508 0014 FB 5A 53 FF             		mov.L	#-173, r5
 3509 0018 2E 2C                   		bra	.L222
 3510                             	.L221:
3760:../src/src/tls.c **** 
3761:../src/src/tls.c ****     (void)heap;
3762:../src/src/tls.c **** 
3763:../src/src/tls.c ****     *curve = (SupportedCurve*)XMALLOC(sizeof(SupportedCurve), heap,
 3511                             		.loc 2 3763 31
 3512 001a 66 81                   		mov.L	#8, r1
 3513 001c 05 00 00 00             		bsr	_wolfSSL_Malloc
 3514 0020 EF 14                   		mov.L	r1, r4
 3515                             		.loc 2 3763 12
 3516 0022 EC A5                   		mov.L	[r10], r5
 3517 0024 E3 54                   		mov.L	r4, [r5]
3764:../src/src/tls.c ****                                                              DYNAMIC_TYPE_TLSX);
3765:../src/src/tls.c ****     if (*curve == NULL)
 3518                             		.loc 2 3765 9
 3519 0026 EC A5                   		mov.L	[r10], r5
 3520 0028 EC 55                   		mov.L	[r5], r5
 3521                             		.loc 2 3765 8
 3522 002a 61 05                   		cmp	#0, r5
 3523 002c 1E                      		bne	.L223
3766:../src/src/tls.c ****         return MEMORY_E;
 3524                             		.loc 2 3766 16
 3525 002d FB 56 83                		mov.L	#-125, r5
 3526 0030 2E 14                   		bra	.L222
 3527                             	.L223:
3767:../src/src/tls.c **** 
3768:../src/src/tls.c ****     (*curve)->name = name;
 3528                             		.loc 2 3768 6
 3529 0032 EC A5                   		mov.L	[r10], r5
 3530 0034 EC 55                   		mov.L	[r5], r5
 3531                             		.loc 2 3768 20
 3532 0036 DD A4 02                		mov.W	4[r10], r4
 3533 0039 D3 54                   		mov.W	r4, [r5]
3769:../src/src/tls.c ****     (*curve)->next = NULL;
 3534                             		.loc 2 3769 6
 3535 003b EC A5                   		mov.L	[r10], r5
 3536 003d EC 55                   		mov.L	[r5], r5
 3537                             		.loc 2 3769 20
 3538 003f 3E 51 00                		mov.L	#0, 4[r5]
3770:../src/src/tls.c **** 
3771:../src/src/tls.c ****     return 0;
 3539                             		.loc 2 3771 12
 3540 0042 66 05                   		mov.L	#0, r5
 3541                             	.L222:
3772:../src/src/tls.c **** }
 3542                             		.loc 2 3772 1
 3543 0044 EF 51                   		mov.L	r5, r1
 3544 0046 3F AA 04                		rtsd	#16, r10-r10
 3545                             	.LFE75:
 3547                             		.section	.text.TLSX_PointFormat_New,"ax",@progbits
 3549                             	_TLSX_PointFormat_New:
 3550                             	.LFB76:
3773:../src/src/tls.c **** 
3774:../src/src/tls.c **** static int TLSX_PointFormat_New(PointFormat** point, byte format, void* heap)
3775:../src/src/tls.c **** {
 3551                             		.loc 2 3775 1
 3552 0000 7E AA                   		push.l	r10
 3553                             	.LCFI100:
 3554 0002 71 0A F4                		add	#-12, r0, r10
 3555                             	.LCFI101:
 3556 0005 EF A0                   		mov.L	r10, r0
 3557 0007 E3 A1                   		mov.L	r1, [r10]
 3558 0009 C7 A2 04                		mov.B	r2, 4[r10]
 3559 000c E7 A3 02                		mov.L	r3, 8[r10]
3776:../src/src/tls.c ****     if (point == NULL)
 3560                             		.loc 2 3776 8
 3561 000f EC A5                   		mov.L	[r10], r5
 3562 0011 61 05                   		cmp	#0, r5
 3563 0013 1F                      		bne	.L225
3777:../src/src/tls.c ****         return BAD_FUNC_ARG;
 3564                             		.loc 2 3777 16
 3565 0014 FB 5A 53 FF             		mov.L	#-173, r5
 3566 0018 2E 2C                   		bra	.L226
 3567                             	.L225:
3778:../src/src/tls.c **** 
3779:../src/src/tls.c ****     (void)heap;
3780:../src/src/tls.c **** 
3781:../src/src/tls.c ****     *point = (PointFormat*)XMALLOC(sizeof(PointFormat), heap,
 3568                             		.loc 2 3781 28
 3569 001a 66 81                   		mov.L	#8, r1
 3570 001c 05 00 00 00             		bsr	_wolfSSL_Malloc
 3571 0020 EF 14                   		mov.L	r1, r4
 3572                             		.loc 2 3781 12
 3573 0022 EC A5                   		mov.L	[r10], r5
 3574 0024 E3 54                   		mov.L	r4, [r5]
3782:../src/src/tls.c ****                                                              DYNAMIC_TYPE_TLSX);
3783:../src/src/tls.c ****     if (*point == NULL)
 3575                             		.loc 2 3783 9
 3576 0026 EC A5                   		mov.L	[r10], r5
 3577 0028 EC 55                   		mov.L	[r5], r5
 3578                             		.loc 2 3783 8
 3579 002a 61 05                   		cmp	#0, r5
 3580 002c 1E                      		bne	.L227
3784:../src/src/tls.c ****         return MEMORY_E;
 3581                             		.loc 2 3784 16
 3582 002d FB 56 83                		mov.L	#-125, r5
 3583 0030 2E 14                   		bra	.L226
 3584                             	.L227:
3785:../src/src/tls.c **** 
3786:../src/src/tls.c ****     (*point)->format = format;
 3585                             		.loc 2 3786 6
 3586 0032 EC A5                   		mov.L	[r10], r5
 3587 0034 EC 55                   		mov.L	[r5], r5
 3588                             		.loc 2 3786 22
 3589 0036 CD A4 04                		mov.B	4[r10], r4
 3590 0039 C3 54                   		mov.B	r4, [r5]
3787:../src/src/tls.c ****     (*point)->next = NULL;
 3591                             		.loc 2 3787 6
 3592 003b EC A5                   		mov.L	[r10], r5
 3593 003d EC 55                   		mov.L	[r5], r5
 3594                             		.loc 2 3787 20
 3595 003f 3E 51 00                		mov.L	#0, 4[r5]
3788:../src/src/tls.c **** 
3789:../src/src/tls.c ****     return 0;
 3596                             		.loc 2 3789 12
 3597 0042 66 05                   		mov.L	#0, r5
 3598                             	.L226:
3790:../src/src/tls.c **** }
 3599                             		.loc 2 3790 1
 3600 0044 EF 51                   		mov.L	r5, r1
 3601 0046 3F AA 04                		rtsd	#16, r10-r10
 3602                             	.LFE76:
 3604                             		.section	.text.TLSX_SupportedCurve_FreeAll,"ax",@progbits
 3606                             	_TLSX_SupportedCurve_FreeAll:
 3607                             	.LFB77:
3791:../src/src/tls.c **** 
3792:../src/src/tls.c **** static void TLSX_SupportedCurve_FreeAll(SupportedCurve* list, void* heap)
3793:../src/src/tls.c **** {
 3608                             		.loc 2 3793 1
 3609 0000 7E AA                   		push.l	r10
 3610                             	.LCFI102:
 3611 0002 71 0A F0                		add	#-16, r0, r10
 3612                             	.LCFI103:
 3613 0005 EF A0                   		mov.L	r10, r0
 3614 0007 E7 A1 02                		mov.L	r1, 8[r10]
 3615 000a E7 A2 03                		mov.L	r2, 12[r10]
3794:../src/src/tls.c ****     SupportedCurve* curve;
3795:../src/src/tls.c **** 
3796:../src/src/tls.c ****     while ((curve = list)) {
 3616                             		.loc 2 3796 11
 3617 000d 2E 1B                   		bra	.L229
 3618                             	.L230:
3797:../src/src/tls.c ****         list = curve->next;
 3619                             		.loc 2 3797 14
 3620 000f EC A5                   		mov.L	[r10], r5
 3621 0011 A8 5D                   		mov.L	4[r5], r5
 3622 0013 E7 A5 02                		mov.L	r5, 8[r10]
 3623                             	.LBB12:
3798:../src/src/tls.c ****         XFREE(curve, heap, DYNAMIC_TYPE_TLSX);
 3624                             		.loc 2 3798 9
 3625 0016 EC A5                   		mov.L	[r10], r5
 3626 0018 E7 A5 01                		mov.L	r5, 4[r10]
 3627 001b ED A5 01                		mov.L	4[r10], r5
 3628 001e 61 05                   		cmp	#0, r5
 3629 0020 10                      		beq	.L229
 3630                             		.loc 2 3798 9 is_stmt 0 discriminator 1
 3631 0021 ED A1 01                		mov.L	4[r10], r1
 3632 0024 05 00 00 00             		bsr	_wolfSSL_Free
 3633                             	.L229:
 3634                             	.LBE12:
3796:../src/src/tls.c ****         list = curve->next;
 3635                             		.loc 2 3796 19 is_stmt 1
 3636 0028 ED A5 02                		mov.L	8[r10], r5
 3637 002b E3 A5                   		mov.L	r5, [r10]
3796:../src/src/tls.c ****         list = curve->next;
 3638                             		.loc 2 3796 11
 3639 002d EC A5                   		mov.L	[r10], r5
 3640 002f 61 05                   		cmp	#0, r5
 3641 0031 21 DE                   		bne	.L230
3799:../src/src/tls.c ****     }
3800:../src/src/tls.c ****     (void)heap;
3801:../src/src/tls.c **** }
 3642                             		.loc 2 3801 1
 3643 0033 03                      		nop
 3644 0034 3F AA 05                		rtsd	#20, r10-r10
 3645                             	.LFE77:
 3647                             		.section	.text.TLSX_PointFormat_FreeAll,"ax",@progbits
 3649                             	_TLSX_PointFormat_FreeAll:
 3650                             	.LFB78:
3802:../src/src/tls.c **** 
3803:../src/src/tls.c **** static void TLSX_PointFormat_FreeAll(PointFormat* list, void* heap)
3804:../src/src/tls.c **** {
 3651                             		.loc 2 3804 1
 3652 0000 7E AA                   		push.l	r10
 3653                             	.LCFI104:
 3654 0002 71 0A F0                		add	#-16, r0, r10
 3655                             	.LCFI105:
 3656 0005 EF A0                   		mov.L	r10, r0
 3657 0007 E7 A1 02                		mov.L	r1, 8[r10]
 3658 000a E7 A2 03                		mov.L	r2, 12[r10]
3805:../src/src/tls.c ****     PointFormat* point;
3806:../src/src/tls.c **** 
3807:../src/src/tls.c ****     while ((point = list)) {
 3659                             		.loc 2 3807 11
 3660 000d 2E 1B                   		bra	.L232
 3661                             	.L233:
3808:../src/src/tls.c ****         list = point->next;
 3662                             		.loc 2 3808 14
 3663 000f EC A5                   		mov.L	[r10], r5
 3664 0011 A8 5D                   		mov.L	4[r5], r5
 3665 0013 E7 A5 02                		mov.L	r5, 8[r10]
 3666                             	.LBB13:
3809:../src/src/tls.c ****         XFREE(point, heap, DYNAMIC_TYPE_TLSX);
 3667                             		.loc 2 3809 9
 3668 0016 EC A5                   		mov.L	[r10], r5
 3669 0018 E7 A5 01                		mov.L	r5, 4[r10]
 3670 001b ED A5 01                		mov.L	4[r10], r5
 3671 001e 61 05                   		cmp	#0, r5
 3672 0020 10                      		beq	.L232
 3673                             		.loc 2 3809 9 is_stmt 0 discriminator 1
 3674 0021 ED A1 01                		mov.L	4[r10], r1
 3675 0024 05 00 00 00             		bsr	_wolfSSL_Free
 3676                             	.L232:
 3677                             	.LBE13:
3807:../src/src/tls.c ****         list = point->next;
 3678                             		.loc 2 3807 19 is_stmt 1
 3679 0028 ED A5 02                		mov.L	8[r10], r5
 3680 002b E3 A5                   		mov.L	r5, [r10]
3807:../src/src/tls.c ****         list = point->next;
 3681                             		.loc 2 3807 11
 3682 002d EC A5                   		mov.L	[r10], r5
 3683 002f 61 05                   		cmp	#0, r5
 3684 0031 21 DE                   		bne	.L233
3810:../src/src/tls.c ****     }
3811:../src/src/tls.c ****     (void)heap;
3812:../src/src/tls.c **** }
 3685                             		.loc 2 3812 1
 3686 0033 03                      		nop
 3687 0034 3F AA 05                		rtsd	#20, r10-r10
 3688                             	.LFE78:
 3690                             		.section	.text.TLSX_SupportedCurve_Append,"ax",@progbits
 3692                             	_TLSX_SupportedCurve_Append:
 3693                             	.LFB79:
3813:../src/src/tls.c **** 
3814:../src/src/tls.c **** static int TLSX_SupportedCurve_Append(SupportedCurve* list, word16 name,
3815:../src/src/tls.c ****                                                                      void* heap)
3816:../src/src/tls.c **** {
 3694                             		.loc 2 3816 1
 3695 0000 7E AA                   		push.l	r10
 3696                             	.LCFI106:
 3697 0002 71 0A F0                		add	#-16, r0, r10
 3698                             	.LCFI107:
 3699 0005 EF A0                   		mov.L	r10, r0
 3700 0007 E7 A1 01                		mov.L	r1, 4[r10]
 3701 000a D7 A2 04                		mov.W	r2, 8[r10]
 3702 000d E7 A3 03                		mov.L	r3, 12[r10]
3817:../src/src/tls.c ****     int ret = BAD_FUNC_ARG;
 3703                             		.loc 2 3817 9
 3704 0010 F8 AA 53 FF             		mov.L	#-173, [r10]
3818:../src/src/tls.c **** 
3819:../src/src/tls.c ****     while (list) {
 3705                             		.loc 2 3819 11
 3706 0014 2E 3A                   		bra	.L235
 3707                             	.L239:
3820:../src/src/tls.c ****         if (list->name == name) {
 3708                             		.loc 2 3820 17
 3709 0016 ED A5 01                		mov.L	4[r10], r5
 3710 0019 DC 55                   		mov.W	[r5], r5
 3711                             		.loc 2 3820 12
 3712 001b 5D A4 04                		movu.W	8[r10], r4
 3713 001e 5F 55                   		movu.W	r5, r5
 3714 0020 47 54                   		cmp	r5, r4
 3715 0022 1E                      		bne	.L236
3821:../src/src/tls.c ****             ret = 0; /* curve already in use */
 3716                             		.loc 2 3821 17
 3717 0023 F8 A6 00                		mov.L	#0, [r10]
3822:../src/src/tls.c ****             break;
 3718                             		.loc 2 3822 13
 3719 0026 2E 2F                   		bra	.L237
 3720                             	.L236:
3823:../src/src/tls.c ****         }
3824:../src/src/tls.c **** 
3825:../src/src/tls.c ****         if (list->next == NULL) {
 3721                             		.loc 2 3825 17
 3722 0028 ED A5 01                		mov.L	4[r10], r5
 3723 002b A8 5D                   		mov.L	4[r5], r5
 3724                             		.loc 2 3825 12
 3725 002d 61 05                   		cmp	#0, r5
 3726 002f 21 17                   		bne	.L238
3826:../src/src/tls.c ****             ret = TLSX_SupportedCurve_New(&list->next, name, heap);
 3727                             		.loc 2 3826 43
 3728 0031 ED A5 01                		mov.L	4[r10], r5
 3729 0034 62 45                   		add	#4, r5
 3730                             		.loc 2 3826 19
 3731 0036 ED A3 03                		mov.L	12[r10], r3
 3732 0039 DD A2 04                		mov.W	8[r10], r2
 3733 003c EF 51                   		mov.L	r5, r1
 3734 003e 05 00 00 00             		bsr	_TLSX_SupportedCurve_New
 3735 0042 E3 A1                   		mov.L	r1, [r10]
3827:../src/src/tls.c ****             break;
 3736                             		.loc 2 3827 13
 3737 0044 2E 11                   		bra	.L237
 3738                             	.L238:
3828:../src/src/tls.c ****         }
3829:../src/src/tls.c **** 
3830:../src/src/tls.c ****         list = list->next;
 3739                             		.loc 2 3830 14
 3740 0046 ED A5 01                		mov.L	4[r10], r5
 3741 0049 A8 5D                   		mov.L	4[r5], r5
 3742 004b E7 A5 01                		mov.L	r5, 4[r10]
 3743                             	.L235:
3819:../src/src/tls.c ****         if (list->name == name) {
 3744                             		.loc 2 3819 11
 3745 004e ED A5 01                		mov.L	4[r10], r5
 3746 0051 61 05                   		cmp	#0, r5
 3747 0053 21 C3                   		bne	.L239
 3748                             	.L237:
3831:../src/src/tls.c ****     }
3832:../src/src/tls.c **** 
3833:../src/src/tls.c ****     return ret;
 3749                             		.loc 2 3833 12
 3750 0055 EC A5                   		mov.L	[r10], r5
3834:../src/src/tls.c **** }
 3751                             		.loc 2 3834 1
 3752 0057 EF 51                   		mov.L	r5, r1
 3753 0059 3F AA 05                		rtsd	#20, r10-r10
 3754                             	.LFE79:
 3756                             		.section	.text.TLSX_PointFormat_Append,"ax",@progbits
 3758                             	_TLSX_PointFormat_Append:
 3759                             	.LFB80:
3835:../src/src/tls.c **** 
3836:../src/src/tls.c **** static int TLSX_PointFormat_Append(PointFormat* list, byte format, void* heap)
3837:../src/src/tls.c **** {
 3760                             		.loc 2 3837 1
 3761 0000 7E AA                   		push.l	r10
 3762                             	.LCFI108:
 3763 0002 71 0A F0                		add	#-16, r0, r10
 3764                             	.LCFI109:
 3765 0005 EF A0                   		mov.L	r10, r0
 3766 0007 E7 A1 01                		mov.L	r1, 4[r10]
 3767 000a C7 A2 08                		mov.B	r2, 8[r10]
 3768 000d E7 A3 03                		mov.L	r3, 12[r10]
3838:../src/src/tls.c ****     int ret = BAD_FUNC_ARG;
 3769                             		.loc 2 3838 9
 3770 0010 F8 AA 53 FF             		mov.L	#-173, [r10]
3839:../src/src/tls.c **** 
3840:../src/src/tls.c ****     while (list) {
 3771                             		.loc 2 3840 11
 3772 0014 2E 3A                   		bra	.L242
 3773                             	.L246:
3841:../src/src/tls.c ****         if (list->format == format) {
 3774                             		.loc 2 3841 17
 3775 0016 ED A5 01                		mov.L	4[r10], r5
 3776 0019 CC 55                   		mov.B	[r5], r5
 3777                             		.loc 2 3841 12
 3778 001b 59 A4 08                		movu.B	8[r10], r4
 3779 001e 5B 55                   		movu.B	r5, r5
 3780 0020 47 54                   		cmp	r5, r4
 3781 0022 1E                      		bne	.L243
3842:../src/src/tls.c ****             ret = 0; /* format already in use */
 3782                             		.loc 2 3842 17
 3783 0023 F8 A6 00                		mov.L	#0, [r10]
3843:../src/src/tls.c ****             break;
 3784                             		.loc 2 3843 13
 3785 0026 2E 2F                   		bra	.L244
 3786                             	.L243:
3844:../src/src/tls.c ****         }
3845:../src/src/tls.c **** 
3846:../src/src/tls.c ****         if (list->next == NULL) {
 3787                             		.loc 2 3846 17
 3788 0028 ED A5 01                		mov.L	4[r10], r5
 3789 002b A8 5D                   		mov.L	4[r5], r5
 3790                             		.loc 2 3846 12
 3791 002d 61 05                   		cmp	#0, r5
 3792 002f 21 17                   		bne	.L245
3847:../src/src/tls.c ****             ret = TLSX_PointFormat_New(&list->next, format, heap);
 3793                             		.loc 2 3847 40
 3794 0031 ED A5 01                		mov.L	4[r10], r5
 3795 0034 62 45                   		add	#4, r5
 3796                             		.loc 2 3847 19
 3797 0036 ED A3 03                		mov.L	12[r10], r3
 3798 0039 CD A2 08                		mov.B	8[r10], r2
 3799 003c EF 51                   		mov.L	r5, r1
 3800 003e 05 00 00 00             		bsr	_TLSX_PointFormat_New
 3801 0042 E3 A1                   		mov.L	r1, [r10]
3848:../src/src/tls.c ****             break;
 3802                             		.loc 2 3848 13
 3803 0044 2E 11                   		bra	.L244
 3804                             	.L245:
3849:../src/src/tls.c ****         }
3850:../src/src/tls.c **** 
3851:../src/src/tls.c ****         list = list->next;
 3805                             		.loc 2 3851 14
 3806 0046 ED A5 01                		mov.L	4[r10], r5
 3807 0049 A8 5D                   		mov.L	4[r5], r5
 3808 004b E7 A5 01                		mov.L	r5, 4[r10]
 3809                             	.L242:
3840:../src/src/tls.c ****         if (list->format == format) {
 3810                             		.loc 2 3840 11
 3811 004e ED A5 01                		mov.L	4[r10], r5
 3812 0051 61 05                   		cmp	#0, r5
 3813 0053 21 C3                   		bne	.L246
 3814                             	.L244:
3852:../src/src/tls.c ****     }
3853:../src/src/tls.c **** 
3854:../src/src/tls.c ****     return ret;
 3815                             		.loc 2 3854 12
 3816 0055 EC A5                   		mov.L	[r10], r5
3855:../src/src/tls.c **** }
 3817                             		.loc 2 3855 1
 3818 0057 EF 51                   		mov.L	r5, r1
 3819 0059 3F AA 05                		rtsd	#20, r10-r10
 3820                             	.LFE80:
 3822                             		.section	.text.TLSX_SupportedCurve_ValidateRequest,"ax",@progbits
 3824                             	_TLSX_SupportedCurve_ValidateRequest:
 3825                             	.LFB81:
3856:../src/src/tls.c **** 
3857:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) || !defined(NO_WOLFSSL_CLIENT)
3858:../src/src/tls.c **** 
3859:../src/src/tls.c **** #if defined(HAVE_FFDHE) && (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
3860:../src/src/tls.c ****                                                          defined(HAVE_CURVE448))
3861:../src/src/tls.c **** static void TLSX_SupportedCurve_ValidateRequest(const WOLFSSL* ssl,
3862:../src/src/tls.c ****                                                 const byte* semaphore)
3863:../src/src/tls.c **** {
 3826                             		.loc 2 3863 1
 3827 0000 7E AA                   		push.l	r10
 3828                             	.LCFI110:
 3829 0002 71 0A F8                		add	#-8, r0, r10
 3830                             	.LCFI111:
 3831 0005 EF A0                   		mov.L	r10, r0
 3832 0007 E3 A1                   		mov.L	r1, [r10]
 3833 0009 E7 A2 01                		mov.L	r2, 4[r10]
3864:../src/src/tls.c ****     /* If all pre-defined parameter types for key exchange are supported then
3865:../src/src/tls.c ****      * always send SupportedGroups extension.
3866:../src/src/tls.c ****      */
3867:../src/src/tls.c ****     (void)ssl;
3868:../src/src/tls.c ****     (void)semaphore;
3869:../src/src/tls.c **** }
 3834                             		.loc 2 3869 1
 3835 000c 03                      		nop
 3836 000d 3F AA 03                		rtsd	#12, r10-r10
 3837                             	.LFE81:
 3839                             		.section	.text.TLSX_PointFormat_ValidateRequest,"ax",@progbits
 3841                             	_TLSX_PointFormat_ValidateRequest:
 3842                             	.LFB82:
3870:../src/src/tls.c **** #else
3871:../src/src/tls.c **** static void TLSX_SupportedCurve_ValidateRequest(WOLFSSL* ssl, byte* semaphore)
3872:../src/src/tls.c **** {
3873:../src/src/tls.c ****     word16 i;
3874:../src/src/tls.c **** 
3875:../src/src/tls.c ****     for (i = 0; i < ssl->suites->suiteSz; i += 2) {
3876:../src/src/tls.c ****         if (ssl->suites->suites[i] == TLS13_BYTE)
3877:../src/src/tls.c ****             return;
3878:../src/src/tls.c ****         if ((ssl->suites->suites[i] == ECC_BYTE) ||
3879:../src/src/tls.c ****             (ssl->suites->suites[i] == ECDHE_PSK_BYTE) ||
3880:../src/src/tls.c ****             (ssl->suites->suites[i] == CHACHA_BYTE)) {
3881:../src/src/tls.c ****         #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
3882:../src/src/tls.c ****                                                           defined(HAVE_CURVE448)
3883:../src/src/tls.c ****             return;
3884:../src/src/tls.c ****         #endif
3885:../src/src/tls.c ****         }
3886:../src/src/tls.c ****         #ifdef HAVE_FFDHE
3887:../src/src/tls.c ****         else {
3888:../src/src/tls.c ****             return;
3889:../src/src/tls.c ****         }
3890:../src/src/tls.c ****         #endif
3891:../src/src/tls.c ****     }
3892:../src/src/tls.c **** 
3893:../src/src/tls.c ****     /* turns semaphore on to avoid sending this extension. */
3894:../src/src/tls.c ****     TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SUPPORTED_GROUPS));
3895:../src/src/tls.c **** }
3896:../src/src/tls.c **** #endif
3897:../src/src/tls.c **** 
3898:../src/src/tls.c **** /* Only send PointFormats if TLSv13, ECC or CHACHA cipher suite present.
3899:../src/src/tls.c ****  */
3900:../src/src/tls.c **** static void TLSX_PointFormat_ValidateRequest(WOLFSSL* ssl, byte* semaphore)
3901:../src/src/tls.c **** {
 3843                             		.loc 2 3901 1
 3844 0000 7E AA                   		push.l	r10
 3845                             	.LCFI112:
 3846 0002 71 0A F4                		add	#-12, r0, r10
 3847                             	.LCFI113:
 3848 0005 EF A0                   		mov.L	r10, r0
 3849 0007 E7 A1 01                		mov.L	r1, 4[r10]
 3850 000a E7 A2 02                		mov.L	r2, 8[r10]
3902:../src/src/tls.c ****     word16 i;
3903:../src/src/tls.c **** 
3904:../src/src/tls.c ****     for (i = 0; i < ssl->suites->suiteSz; i += 2) {
 3851                             		.loc 2 3904 12
 3852 000d F8 A5 00                		mov.W	#0, [r10]
 3853                             		.loc 2 3904 5
 3854 0010 2E 50                   		bra	.L250
 3855                             	.L255:
3905:../src/src/tls.c ****         if (ssl->suites->suites[i] == TLS13_BYTE)
 3856                             		.loc 2 3905 16
 3857 0012 ED A5 01                		mov.L	4[r10], r5
 3858 0015 A8 5C                   		mov.L	4[r5], r4
 3859                             		.loc 2 3905 32
 3860 0017 5C A5                   		movu.W	[r10], r5
 3861 0019 4B 45                   		add	r4, r5
 3862 001b 89 55                   		mov.B	4[r5], r5
 3863                             		.loc 2 3905 12
 3864 001d 5B 55                   		movu.B	r5, r5
 3865 001f 75 55 13                		cmp	#19, r5
 3866 0022 20 4F                   		beq	.L256
3906:../src/src/tls.c ****             return;
3907:../src/src/tls.c ****         if ((ssl->suites->suites[i] == ECC_BYTE) ||
 3867                             		.loc 2 3907 17
 3868 0024 ED A5 01                		mov.L	4[r10], r5
 3869 0027 A8 5C                   		mov.L	4[r5], r4
 3870                             		.loc 2 3907 33
 3871 0029 5C A5                   		movu.W	[r10], r5
 3872 002b 4B 45                   		add	r4, r5
 3873 002d 89 55                   		mov.B	4[r5], r5
 3874                             		.loc 2 3907 12
 3875 002f 5B 55                   		movu.B	r5, r5
 3876 0031 75 55 C0                		cmp	#0xc0, r5
 3877 0034 20 40                   		beq	.L257
3908:../src/src/tls.c ****             (ssl->suites->suites[i] == ECDHE_PSK_BYTE) ||
 3878                             		.loc 2 3908 17 discriminator 1
 3879 0036 ED A5 01                		mov.L	4[r10], r5
 3880 0039 A8 5C                   		mov.L	4[r5], r4
 3881                             		.loc 2 3908 33 discriminator 1
 3882 003b 5C A5                   		movu.W	[r10], r5
 3883 003d 4B 45                   		add	r4, r5
 3884 003f 89 55                   		mov.B	4[r5], r5
3907:../src/src/tls.c ****             (ssl->suites->suites[i] == ECDHE_PSK_BYTE) ||
 3885                             		.loc 2 3907 50 discriminator 1
 3886 0041 5B 55                   		movu.B	r5, r5
 3887 0043 75 55 D0                		cmp	#0xd0, r5
 3888 0046 20 2E                   		beq	.L257
3909:../src/src/tls.c ****             (ssl->suites->suites[i] == CHACHA_BYTE)) {
 3889                             		.loc 2 3909 17
 3890 0048 ED A5 01                		mov.L	4[r10], r5
 3891 004b A8 5C                   		mov.L	4[r5], r4
 3892                             		.loc 2 3909 33
 3893 004d 5C A5                   		movu.W	[r10], r5
 3894 004f 4B 45                   		add	r4, r5
 3895 0051 89 55                   		mov.B	4[r5], r5
3908:../src/src/tls.c ****             (ssl->suites->suites[i] == ECDHE_PSK_BYTE) ||
 3896                             		.loc 2 3908 56
 3897 0053 5B 55                   		movu.B	r5, r5
 3898 0055 75 55 CC                		cmp	#0xcc, r5
 3899 0058 20 1C                   		beq	.L257
3904:../src/src/tls.c ****         if (ssl->suites->suites[i] == TLS13_BYTE)
 3900                             		.loc 2 3904 45 discriminator 2
 3901 005a DC A5                   		mov.W	[r10], r5
 3902 005c 62 25                   		add	#2, r5
 3903 005e D3 A5                   		mov.W	r5, [r10]
 3904                             	.L250:
3904:../src/src/tls.c ****         if (ssl->suites->suites[i] == TLS13_BYTE)
 3905                             		.loc 2 3904 24 discriminator 1
 3906 0060 ED A5 01                		mov.L	4[r10], r5
 3907 0063 A8 5D                   		mov.L	4[r5], r5
3904:../src/src/tls.c ****         if (ssl->suites->suites[i] == TLS13_BYTE)
 3908                             		.loc 2 3904 32 discriminator 1
 3909 0065 DC 55                   		mov.W	[r5], r5
3904:../src/src/tls.c ****         if (ssl->suites->suites[i] == TLS13_BYTE)
 3910                             		.loc 2 3904 5 discriminator 1
 3911 0067 5C A4                   		movu.W	[r10], r4
 3912 0069 5F 55                   		movu.W	r5, r5
 3913 006b 47 54                   		cmp	r5, r4
 3914 006d 23 A5                   		bltu	.L255
3910:../src/src/tls.c ****         #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
3911:../src/src/tls.c ****                                                           defined(HAVE_CURVE448)
3912:../src/src/tls.c ****             return;
3913:../src/src/tls.c ****         #endif
3914:../src/src/tls.c ****         }
3915:../src/src/tls.c ****     }
3916:../src/src/tls.c **** #ifdef HAVE_FFDHE
3917:../src/src/tls.c ****     (void)semaphore;
3918:../src/src/tls.c ****     return;
 3915                             		.loc 2 3918 5
 3916 006f 03                      		nop
 3917 0070 0D                      		bra	.L249
 3918                             	.L256:
3906:../src/src/tls.c ****         if ((ssl->suites->suites[i] == ECC_BYTE) ||
 3919                             		.loc 2 3906 13
 3920 0071 03                      		nop
 3921 0072 2E 03                   		bra	.L249
 3922                             	.L257:
3912:../src/src/tls.c ****         #endif
 3923                             		.loc 2 3912 13
 3924 0074 03                      		nop
 3925                             	.L249:
3919:../src/src/tls.c **** #else
3920:../src/src/tls.c ****    /* turns semaphore on to avoid sending this extension. */
3921:../src/src/tls.c ****    TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_EC_POINT_FORMATS));
3922:../src/src/tls.c **** #endif
3923:../src/src/tls.c **** }
 3926                             		.loc 2 3923 1
 3927 0075 3F AA 04                		rtsd	#16, r10-r10
 3928                             	.LFE82:
 3930                             		.section	.text.TLSX_PointFormat_ValidateResponse,"ax",@progbits
 3932                             	_TLSX_PointFormat_ValidateResponse:
 3933                             	.LFB83:
3924:../src/src/tls.c **** 
3925:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 || !NO_WOLFSSL_CLIENT */
3926:../src/src/tls.c **** 
3927:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
3928:../src/src/tls.c **** 
3929:../src/src/tls.c **** static void TLSX_PointFormat_ValidateResponse(WOLFSSL* ssl, byte* semaphore)
3930:../src/src/tls.c **** {
 3934                             		.loc 2 3930 1
 3935 0000 6E 6A                   		pushm	r6-r10
 3936                             	.LCFI114:
 3937 0002 71 0A F8                		add	#-8, r0, r10
 3938                             	.LCFI115:
 3939 0005 EF A0                   		mov.L	r10, r0
 3940 0007 E3 A1                   		mov.L	r1, [r10]
 3941 0009 E7 A2 01                		mov.L	r2, 4[r10]
3931:../src/src/tls.c **** #if defined(HAVE_FFDHE) || defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
3932:../src/src/tls.c ****                                                           defined(HAVE_CURVE448)
3933:../src/src/tls.c ****     (void)semaphore;
3934:../src/src/tls.c **** #endif
3935:../src/src/tls.c **** 
3936:../src/src/tls.c ****     if (ssl->options.cipherSuite0 == TLS13_BYTE)
 3942                             		.loc 2 3936 21
 3943 000c EC A5                   		mov.L	[r10], r5
 3944 000e CE 55 A5 02             		mov.B	677[r5], r5
 3945                             		.loc 2 3936 8
 3946 0012 5B 55                   		movu.B	r5, r5
 3947 0014 75 55 13                		cmp	#19, r5
 3948 0017 20 63                   		beq	.L263
3937:../src/src/tls.c ****         return;
3938:../src/src/tls.c **** #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
3939:../src/src/tls.c ****     if (ssl->options.cipherSuite0 == ECC_BYTE ||
 3949                             		.loc 2 3939 21
 3950 0019 EC A5                   		mov.L	[r10], r5
 3951 001b CE 55 A5 02             		mov.B	677[r5], r5
 3952                             		.loc 2 3939 8
 3953 001f 5B 55                   		movu.B	r5, r5
 3954 0021 75 55 C0                		cmp	#0xc0, r5
 3955 0024 20 59                   		beq	.L264
3940:../src/src/tls.c ****         ssl->options.cipherSuite0 == ECDHE_PSK_BYTE ||
 3956                             		.loc 2 3940 21 discriminator 1
 3957 0026 EC A5                   		mov.L	[r10], r5
 3958 0028 CE 55 A5 02             		mov.B	677[r5], r5
3939:../src/src/tls.c ****         ssl->options.cipherSuite0 == ECDHE_PSK_BYTE ||
 3959                             		.loc 2 3939 47 discriminator 1
 3960 002c 5B 55                   		movu.B	r5, r5
 3961 002e 75 55 D0                		cmp	#0xd0, r5
 3962 0031 20 4C                   		beq	.L264
3941:../src/src/tls.c ****         ssl->options.cipherSuite0 == CHACHA_BYTE) {
 3963                             		.loc 2 3941 21
 3964 0033 EC A5                   		mov.L	[r10], r5
 3965 0035 CE 55 A5 02             		mov.B	677[r5], r5
3940:../src/src/tls.c ****         ssl->options.cipherSuite0 == ECDHE_PSK_BYTE ||
 3966                             		.loc 2 3940 53
 3967 0039 5B 55                   		movu.B	r5, r5
 3968 003b 75 55 CC                		cmp	#0xcc, r5
 3969 003e 20 3F                   		beq	.L264
3942:../src/src/tls.c ****         return;
3943:../src/src/tls.c ****     }
3944:../src/src/tls.c **** #endif
3945:../src/src/tls.c **** 
3946:../src/src/tls.c ****     /* turns semaphore on to avoid sending this extension. */
3947:../src/src/tls.c ****     TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_EC_POINT_FORMATS));
 3970                             		.loc 2 3947 5
 3971 0040 66 B1                   		mov	#11, r1
 3972 0042 05 00 00 00             		bsr	_TLSX_ToSemaphore
 3973 0046 EF 15                   		mov.L	r1, r5
 3974 0048 5F 55                   		movu.W	r5, r5
 3975 004a 64 75                   		and	#7, r5
 3976 004c 66 14                   		mov.L	#1, r4
 3977 004e EF 47                   		mov.L	r4, r7
 3978 0050 FD 62 57                		shll	r5, r7
 3979 0053 EF 75                   		mov.L	r7, r5
 3980 0055 CF 56                   		mov.B	r5, r6
 3981 0057 66 B1                   		mov	#11, r1
 3982 0059 05 00 00 00             		bsr	_TLSX_ToSemaphore
 3983 005d EF 15                   		mov.L	r1, r5
 3984 005f 5F 55                   		movu.W	r5, r5
 3985 0061 68 35                   		shlr	#3, r5
 3986 0063 DF 53                   		mov.W	r5, r3
 3987 0065 5F 35                   		movu.W	r3, r5
 3988 0067 ED A4 01                		mov.L	4[r10], r4
 3989 006a 4B 45                   		add	r4, r5
 3990 006c CC 54                   		mov.B	[r5], r4
 3991 006e 5F 35                   		movu.W	r3, r5
 3992 0070 ED A3 01                		mov.L	4[r10], r3
 3993 0073 4B 35                   		add	r3, r5
 3994 0075 57 64                   		or	r6, r4
 3995 0077 C3 54                   		mov.B	r4, [r5]
 3996 0079 0D                      		bra	.L258
 3997                             	.L263:
3937:../src/src/tls.c **** #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
 3998                             		.loc 2 3937 9
 3999 007a 03                      		nop
 4000 007b 2E 03                   		bra	.L258
 4001                             	.L264:
3942:../src/src/tls.c ****         return;
 4002                             		.loc 2 3942 9
 4003 007d 03                      		nop
 4004                             	.L258:
3948:../src/src/tls.c **** }
 4005                             		.loc 2 3948 1
 4006 007e 3F 6A 07                		rtsd	#28, r6-r10
 4007                             	.LFE83:
 4009                             		.section	.text.TLSX_SupportedCurve_GetSize,"ax",@progbits
 4011                             	_TLSX_SupportedCurve_GetSize:
 4012                             	.LFB84:
3949:../src/src/tls.c **** 
3950:../src/src/tls.c **** #endif /* !NO_WOLFSSL_SERVER */
3951:../src/src/tls.c **** 
3952:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
3953:../src/src/tls.c **** 
3954:../src/src/tls.c **** static word16 TLSX_SupportedCurve_GetSize(SupportedCurve* list)
3955:../src/src/tls.c **** {
 4013                             		.loc 2 3955 1
 4014 0000 7E AA                   		push.l	r10
 4015                             	.LCFI116:
 4016 0002 71 0A F4                		add	#-12, r0, r10
 4017                             	.LCFI117:
 4018 0005 EF A0                   		mov.L	r10, r0
 4019 0007 E7 A1 02                		mov.L	r1, 8[r10]
3956:../src/src/tls.c ****     SupportedCurve* curve;
3957:../src/src/tls.c ****     word16 length = OPAQUE16_LEN; /* list length */
 4020                             		.loc 2 3957 12
 4021 000a F8 A5 02                		mov.W	#2, [r10]
3958:../src/src/tls.c **** 
3959:../src/src/tls.c ****     while ((curve = list)) {
 4022                             		.loc 2 3959 11
 4023 000d 2E 10                   		bra	.L266
 4024                             	.L267:
3960:../src/src/tls.c ****         list = curve->next;
 4025                             		.loc 2 3960 14
 4026 000f ED A5 01                		mov.L	4[r10], r5
 4027 0012 A8 5D                   		mov.L	4[r5], r5
 4028 0014 E7 A5 02                		mov.L	r5, 8[r10]
3961:../src/src/tls.c ****         length += OPAQUE16_LEN; /* curve length */
 4029                             		.loc 2 3961 16
 4030 0017 DC A5                   		mov.W	[r10], r5
 4031 0019 62 25                   		add	#2, r5
 4032 001b D3 A5                   		mov.W	r5, [r10]
 4033                             	.L266:
3959:../src/src/tls.c ****         list = curve->next;
 4034                             		.loc 2 3959 19
 4035 001d ED A5 02                		mov.L	8[r10], r5
 4036 0020 E7 A5 01                		mov.L	r5, 4[r10]
3959:../src/src/tls.c ****         list = curve->next;
 4037                             		.loc 2 3959 11
 4038 0023 ED A5 01                		mov.L	4[r10], r5
 4039 0026 61 05                   		cmp	#0, r5
 4040 0028 21 E7                   		bne	.L267
3962:../src/src/tls.c ****     }
3963:../src/src/tls.c **** 
3964:../src/src/tls.c ****     return length;
 4041                             		.loc 2 3964 12
 4042 002a DC A5                   		mov.W	[r10], r5
 4043 002c 5F 55                   		movu.W	r5, r5
3965:../src/src/tls.c **** }
 4044                             		.loc 2 3965 1
 4045 002e EF 51                   		mov.L	r5, r1
 4046 0030 3F AA 04                		rtsd	#16, r10-r10
 4047                             	.LFE84:
 4049                             		.section	.text.TLSX_PointFormat_GetSize,"ax",@progbits
 4051                             	_TLSX_PointFormat_GetSize:
 4052                             	.LFB85:
3966:../src/src/tls.c **** 
3967:../src/src/tls.c **** #endif
3968:../src/src/tls.c **** 
3969:../src/src/tls.c **** static word16 TLSX_PointFormat_GetSize(PointFormat* list)
3970:../src/src/tls.c **** {
 4053                             		.loc 2 3970 1
 4054 0000 7E AA                   		push.l	r10
 4055                             	.LCFI118:
 4056 0002 71 0A F4                		add	#-12, r0, r10
 4057                             	.LCFI119:
 4058 0005 EF A0                   		mov.L	r10, r0
 4059 0007 E7 A1 02                		mov.L	r1, 8[r10]
3971:../src/src/tls.c ****     PointFormat* point;
3972:../src/src/tls.c ****     word16 length = ENUM_LEN; /* list length */
 4060                             		.loc 2 3972 12
 4061 000a F8 A5 01                		mov.W	#1, [r10]
3973:../src/src/tls.c **** 
3974:../src/src/tls.c ****     while ((point = list)) {
 4062                             		.loc 2 3974 11
 4063 000d 2E 10                   		bra	.L270
 4064                             	.L271:
3975:../src/src/tls.c ****         list = point->next;
 4065                             		.loc 2 3975 14
 4066 000f ED A5 01                		mov.L	4[r10], r5
 4067 0012 A8 5D                   		mov.L	4[r5], r5
 4068 0014 E7 A5 02                		mov.L	r5, 8[r10]
3976:../src/src/tls.c ****         length += ENUM_LEN; /* format length */
 4069                             		.loc 2 3976 16
 4070 0017 DC A5                   		mov.W	[r10], r5
 4071 0019 62 15                   		add	#1, r5
 4072 001b D3 A5                   		mov.W	r5, [r10]
 4073                             	.L270:
3974:../src/src/tls.c ****         list = point->next;
 4074                             		.loc 2 3974 19
 4075 001d ED A5 02                		mov.L	8[r10], r5
 4076 0020 E7 A5 01                		mov.L	r5, 4[r10]
3974:../src/src/tls.c ****         list = point->next;
 4077                             		.loc 2 3974 11
 4078 0023 ED A5 01                		mov.L	4[r10], r5
 4079 0026 61 05                   		cmp	#0, r5
 4080 0028 21 E7                   		bne	.L271
3977:../src/src/tls.c ****     }
3978:../src/src/tls.c **** 
3979:../src/src/tls.c ****     return length;
 4081                             		.loc 2 3979 12
 4082 002a DC A5                   		mov.W	[r10], r5
 4083 002c 5F 55                   		movu.W	r5, r5
3980:../src/src/tls.c **** }
 4084                             		.loc 2 3980 1
 4085 002e EF 51                   		mov.L	r5, r1
 4086 0030 3F AA 04                		rtsd	#16, r10-r10
 4087                             	.LFE85:
 4089                             		.section	.text.TLSX_SupportedCurve_Write,"ax",@progbits
 4091                             	_TLSX_SupportedCurve_Write:
 4092                             	.LFB86:
3981:../src/src/tls.c **** 
3982:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
3983:../src/src/tls.c **** 
3984:../src/src/tls.c **** static word16 TLSX_SupportedCurve_Write(SupportedCurve* list, byte* output)
3985:../src/src/tls.c **** {
 4093                             		.loc 2 3985 1
 4094 0000 7E AA                   		push.l	r10
 4095                             	.LCFI120:
 4096 0002 71 0A F4                		add	#-12, r0, r10
 4097                             	.LCFI121:
 4098 0005 EF A0                   		mov.L	r10, r0
 4099 0007 E7 A1 01                		mov.L	r1, 4[r10]
 4100 000a E7 A2 02                		mov.L	r2, 8[r10]
3986:../src/src/tls.c ****     word16 offset = OPAQUE16_LEN;
 4101                             		.loc 2 3986 12
 4102 000d F8 A5 02                		mov.W	#2, [r10]
3987:../src/src/tls.c **** 
3988:../src/src/tls.c ****     while (list) {
 4103                             		.loc 2 3988 11
 4104 0010 2E 24                   		bra	.L274
 4105                             	.L275:
3989:../src/src/tls.c ****         c16toa(list->name, output + offset);
 4106                             		.loc 2 3989 9
 4107 0012 ED A5 01                		mov.L	4[r10], r5
 4108 0015 DC 53                   		mov.W	[r5], r3
 4109 0017 5C A5                   		movu.W	[r10], r5
 4110 0019 ED A4 02                		mov.L	8[r10], r4
 4111 001c 4B 45                   		add	r4, r5
 4112 001e EF 52                   		mov.L	r5, r2
 4113 0020 DF 31                   		mov.W	r3, r1
 4114 0022 05 00 00 00             		bsr	_c16toa
3990:../src/src/tls.c ****         offset += OPAQUE16_LEN;
 4115                             		.loc 2 3990 16
 4116 0026 DC A5                   		mov.W	[r10], r5
 4117 0028 62 25                   		add	#2, r5
 4118 002a D3 A5                   		mov.W	r5, [r10]
3991:../src/src/tls.c ****         list = list->next;
 4119                             		.loc 2 3991 14
 4120 002c ED A5 01                		mov.L	4[r10], r5
 4121 002f A8 5D                   		mov.L	4[r5], r5
 4122 0031 E7 A5 01                		mov.L	r5, 4[r10]
 4123                             	.L274:
3988:../src/src/tls.c ****         c16toa(list->name, output + offset);
 4124                             		.loc 2 3988 11
 4125 0034 ED A5 01                		mov.L	4[r10], r5
 4126 0037 61 05                   		cmp	#0, r5
 4127 0039 21 D9                   		bne	.L275
3992:../src/src/tls.c ****     }
3993:../src/src/tls.c **** 
3994:../src/src/tls.c ****     c16toa(offset - OPAQUE16_LEN, output); /* writing list length */
 4128                             		.loc 2 3994 5
 4129 003b DC A5                   		mov.W	[r10], r5
 4130 003d 60 25                   		sub	#2, r5
 4131 003f ED A2 02                		mov.L	8[r10], r2
 4132 0042 DF 51                   		mov.W	r5, r1
 4133 0044 05 00 00 00             		bsr	_c16toa
3995:../src/src/tls.c **** 
3996:../src/src/tls.c ****     return offset;
 4134                             		.loc 2 3996 12
 4135 0048 DC A5                   		mov.W	[r10], r5
 4136 004a 5F 55                   		movu.W	r5, r5
3997:../src/src/tls.c **** }
 4137                             		.loc 2 3997 1
 4138 004c EF 51                   		mov.L	r5, r1
 4139 004e 3F AA 04                		rtsd	#16, r10-r10
 4140                             	.LFE86:
 4142                             		.section	.text.TLSX_PointFormat_Write,"ax",@progbits
 4144                             	_TLSX_PointFormat_Write:
 4145                             	.LFB87:
3998:../src/src/tls.c **** 
3999:../src/src/tls.c **** #endif
4000:../src/src/tls.c **** 
4001:../src/src/tls.c **** static word16 TLSX_PointFormat_Write(PointFormat* list, byte* output)
4002:../src/src/tls.c **** {
 4146                             		.loc 2 4002 1
 4147 0000 7E AA                   		push.l	r10
 4148                             	.LCFI122:
 4149 0002 71 0A F4                		add	#-12, r0, r10
 4150                             	.LCFI123:
 4151 0005 EF A0                   		mov.L	r10, r0
 4152 0007 E7 A1 01                		mov.L	r1, 4[r10]
 4153 000a E7 A2 02                		mov.L	r2, 8[r10]
4003:../src/src/tls.c ****     word16 offset = ENUM_LEN;
 4154                             		.loc 2 4003 12
 4155 000d F8 A5 01                		mov.W	#1, [r10]
4004:../src/src/tls.c **** 
4005:../src/src/tls.c ****     while (list) {
 4156                             		.loc 2 4005 11
 4157 0010 2E 1F                   		bra	.L278
 4158                             	.L279:
4006:../src/src/tls.c ****         output[offset++] = list->format;
 4159                             		.loc 2 4006 22
 4160 0012 DC A5                   		mov.W	[r10], r5
 4161 0014 71 54 01                		add	#1, r5, r4
 4162 0017 D3 A4                   		mov.W	r4, [r10]
 4163 0019 5F 55                   		movu.W	r5, r5
 4164                             		.loc 2 4006 15
 4165 001b ED A4 02                		mov.L	8[r10], r4
 4166 001e 4B 45                   		add	r4, r5
 4167                             		.loc 2 4006 32
 4168 0020 ED A4 01                		mov.L	4[r10], r4
 4169 0023 CC 44                   		mov.B	[r4], r4
 4170                             		.loc 2 4006 26
 4171 0025 C3 54                   		mov.B	r4, [r5]
4007:../src/src/tls.c ****         list = list->next;
 4172                             		.loc 2 4007 14
 4173 0027 ED A5 01                		mov.L	4[r10], r5
 4174 002a A8 5D                   		mov.L	4[r5], r5
 4175 002c E7 A5 01                		mov.L	r5, 4[r10]
 4176                             	.L278:
4005:../src/src/tls.c ****         output[offset++] = list->format;
 4177                             		.loc 2 4005 11
 4178 002f ED A5 01                		mov.L	4[r10], r5
 4179 0032 61 05                   		cmp	#0, r5
 4180 0034 21 DE                   		bne	.L279
4008:../src/src/tls.c ****     }
4009:../src/src/tls.c **** 
4010:../src/src/tls.c ****     output[0] = (byte)(offset - ENUM_LEN);
 4181                             		.loc 2 4010 17
 4182 0036 DC A5                   		mov.W	[r10], r5
 4183 0038 60 15                   		sub	#1, r5
 4184 003a CF 54                   		mov.B	r5, r4
 4185                             		.loc 2 4010 15
 4186 003c ED A5 02                		mov.L	8[r10], r5
 4187 003f C3 54                   		mov.B	r4, [r5]
4011:../src/src/tls.c **** 
4012:../src/src/tls.c ****     return offset;
 4188                             		.loc 2 4012 12
 4189 0041 DC A5                   		mov.W	[r10], r5
 4190 0043 5F 55                   		movu.W	r5, r5
4013:../src/src/tls.c **** }
 4191                             		.loc 2 4013 1
 4192 0045 EF 51                   		mov.L	r5, r1
 4193 0047 3F AA 04                		rtsd	#16, r10-r10
 4194                             	.LFE87:
 4196                             		.section	.text.TLSX_SupportedCurve_Parse,"ax",@progbits
 4198                             	_TLSX_SupportedCurve_Parse:
 4199                             	.LFB88:
4014:../src/src/tls.c **** 
4015:../src/src/tls.c **** #if !defined(NO_WOLFSSL_SERVER) || (defined(WOLFSSL_TLS13) && \
4016:../src/src/tls.c ****                                          !defined(WOLFSSL_NO_SERVER_GROUPS_EXT))
4017:../src/src/tls.c **** 
4018:../src/src/tls.c **** static int TLSX_SupportedCurve_Parse(WOLFSSL* ssl, const byte* input,
4019:../src/src/tls.c ****                                      word16 length, byte isRequest)
4020:../src/src/tls.c **** {
 4200                             		.loc 2 4020 1
 4201 0000 7E AA                   		push.l	r10
 4202                             	.LCFI124:
 4203 0002 71 0A EC                		add	#-20, r0, r10
 4204                             	.LCFI125:
 4205 0005 71 A0 FC                		add	#-4, r10, r0
 4206                             	.LCFI126:
 4207 0008 E7 A1 02                		mov.L	r1, 8[r10]
 4208 000b E7 A2 03                		mov.L	r2, 12[r10]
 4209 000e D7 A3 08                		mov.W	r3, 16[r10]
 4210 0011 C7 A4 12                		mov.B	r4, 18[r10]
4021:../src/src/tls.c ****     word16 offset;
4022:../src/src/tls.c ****     word16 name;
4023:../src/src/tls.c ****     int ret;
4024:../src/src/tls.c **** 
4025:../src/src/tls.c ****     if(!isRequest && !IsAtLeastTLSv1_3(ssl->version)) {
 4211                             		.loc 2 4025 7
 4212 0014 59 A5 12                		movu.B	18[r10], r5
 4213 0017 61 05                   		cmp	#0, r5
 4214 0019 21 1A                   		bne	.L282
 4215                             		.loc 2 4025 23 discriminator 1
 4216 001b ED A5 02                		mov.L	8[r10], r5
 4217 001e DD 55 B0                		mov.W	352[r5], r5
 4218 0021 D3 05                   		mov.W	r5, [r0]
 4219 0023 05 00 00 00             		bsr	_IsAtLeastTLSv1_3
 4220 0027 EF 15                   		mov.L	r1, r5
 4221                             		.loc 2 4025 19 discriminator 1
 4222 0029 61 05                   		cmp	#0, r5
 4223 002b 18                      		bne	.L282
4026:../src/src/tls.c **** #ifdef WOLFSSL_ALLOW_SERVER_SC_EXT
4027:../src/src/tls.c ****         return 0;
4028:../src/src/tls.c **** #else
4029:../src/src/tls.c ****         return BUFFER_ERROR; /* servers doesn't send this extension. */
 4224                             		.loc 2 4029 16
 4225 002c FB 5A B8 FE             		mov.L	#-328, r5
 4226 0030 38 A3 00                		bra	.L291
 4227                             	.L282:
4030:../src/src/tls.c **** #endif
4031:../src/src/tls.c ****     }
4032:../src/src/tls.c **** 
4033:../src/src/tls.c ****     if (OPAQUE16_LEN > length || length % OPAQUE16_LEN)
 4228                             		.loc 2 4033 8
 4229 0033 5D A5 08                		movu.W	16[r10], r5
 4230 0036 61 15                   		cmp	#1, r5
 4231 0038 25 0C                   		bleu	.L284
 4232                             		.loc 2 4033 31 discriminator 1
 4233 003a DD A5 08                		mov.W	16[r10], r5
 4234 003d 64 15                   		and	#1, r5
 4235 003f 5F 55                   		movu.W	r5, r5
 4236 0041 61 05                   		cmp	#0, r5
 4237 0043 10                      		beq	.L285
 4238                             	.L284:
4034:../src/src/tls.c ****         return BUFFER_ERROR;
 4239                             		.loc 2 4034 16
 4240 0044 FB 5A B8 FE             		mov.L	#-328, r5
 4241 0048 38 8B 00                		bra	.L291
 4242                             	.L285:
4035:../src/src/tls.c **** 
4036:../src/src/tls.c ****     ato16(input, &offset);
 4243                             		.loc 2 4036 5
 4244 004b 71 A5 04                		add	#4, r10, r5
 4245 004e EF 52                   		mov.L	r5, r2
 4246 0050 ED A1 03                		mov.L	12[r10], r1
 4247 0053 05 00 00 00             		bsr	_ato16
4037:../src/src/tls.c **** 
4038:../src/src/tls.c ****     /* validating curve list length */
4039:../src/src/tls.c ****     if (length != OPAQUE16_LEN + offset)
 4248                             		.loc 2 4039 16
 4249 0057 5D A4 08                		movu.W	16[r10], r4
 4250                             		.loc 2 4039 32
 4251 005a DD A5 02                		mov.W	4[r10], r5
 4252 005d 5F 55                   		movu.W	r5, r5
 4253 005f 62 25                   		add	#2, r5
 4254                             		.loc 2 4039 8
 4255 0061 47 54                   		cmp	r5, r4
 4256 0063 17                      		beq	.L286
4040:../src/src/tls.c ****         return BUFFER_ERROR;
 4257                             		.loc 2 4040 16
 4258 0064 FB 5A B8 FE             		mov.L	#-328, r5
 4259 0068 2E 6B                   		bra	.L291
 4260                             	.L286:
4041:../src/src/tls.c **** 
4042:../src/src/tls.c ****     offset = OPAQUE16_LEN;
 4261                             		.loc 2 4042 12
 4262 006a F9 A5 02 02             		mov.W	#2, 4[r10]
4043:../src/src/tls.c ****     if (offset == length)
 4263                             		.loc 2 4043 16
 4264 006e DD A5 02                		mov.W	4[r10], r5
 4265                             		.loc 2 4043 8
 4266 0071 5D A4 08                		movu.W	16[r10], r4
 4267 0074 5F 55                   		movu.W	r5, r5
 4268 0076 47 54                   		cmp	r5, r4
 4269 0078 21 4D                   		bne	.L288
4044:../src/src/tls.c ****         return 0;
 4270                             		.loc 2 4044 16
 4271 007a 66 05                   		mov.L	#0, r5
 4272 007c 2E 57                   		bra	.L291
 4273                             	.L290:
4045:../src/src/tls.c **** 
4046:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && !defined(WOLFSSL_NO_SERVER_GROUPS_EXT)
4047:../src/src/tls.c ****     if (!isRequest) {
4048:../src/src/tls.c ****         TLSX* extension;
4049:../src/src/tls.c ****         SupportedCurve* curve;
4050:../src/src/tls.c **** 
4051:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS);
4052:../src/src/tls.c ****         if (extension != NULL) {
4053:../src/src/tls.c ****             /* Replace client list with server list of supported groups. */
4054:../src/src/tls.c ****             curve = (SupportedCurve*)extension->data;
4055:../src/src/tls.c ****             extension->data = NULL;
4056:../src/src/tls.c ****             TLSX_SupportedCurve_FreeAll(curve, ssl->heap);
4057:../src/src/tls.c **** 
4058:../src/src/tls.c ****             ato16(input + offset, &name);
4059:../src/src/tls.c ****             offset += OPAQUE16_LEN;
4060:../src/src/tls.c **** 
4061:../src/src/tls.c ****             ret = TLSX_SupportedCurve_New(&curve, name, ssl->heap);
4062:../src/src/tls.c ****             if (ret != 0)
4063:../src/src/tls.c ****                 return ret; /* throw error */
4064:../src/src/tls.c ****             extension->data = (void*)curve;
4065:../src/src/tls.c ****         }
4066:../src/src/tls.c ****     }
4067:../src/src/tls.c **** #endif
4068:../src/src/tls.c **** 
4069:../src/src/tls.c ****     for (; offset < length; offset += OPAQUE16_LEN) {
4070:../src/src/tls.c ****         ato16(input + offset, &name);
 4274                             		.loc 2 4070 9
 4275 007e DD A5 02                		mov.W	4[r10], r5
 4276 0081 5F 55                   		movu.W	r5, r5
 4277 0083 ED A4 03                		mov.L	12[r10], r4
 4278 0086 4B 45                   		add	r4, r5
 4279 0088 71 A4 06                		add	#6, r10, r4
 4280 008b EF 42                   		mov.L	r4, r2
 4281 008d EF 51                   		mov.L	r5, r1
 4282 008f 05 00 00 00             		bsr	_ato16
4071:../src/src/tls.c **** 
4072:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(&ssl->extensions, name, ssl->heap);
 4283                             		.loc 2 4072 15
 4284 0093 ED A5 02                		mov.L	8[r10], r5
 4285 0096 72 54 FC 02             		add	#0x2fc, r5, r4
 4286 009a DD A2 03                		mov.W	6[r10], r2
 4287 009d ED A5 02                		mov.L	8[r10], r5
 4288 00a0 AA 5D                   		mov.L	36[r5], r5
 4289 00a2 EF 53                   		mov.L	r5, r3
 4290 00a4 EF 41                   		mov.L	r4, r1
 4291 00a6 05 00 00 00             		bsr	_TLSX_UseSupportedCurve
 4292 00aa E3 A1                   		mov.L	r1, [r10]
4073:../src/src/tls.c ****         /* If it is BAD_FUNC_ARG then it is a group we do not support, but
4074:../src/src/tls.c ****          * that is fine. */
4075:../src/src/tls.c ****         if (ret != WOLFSSL_SUCCESS && ret != BAD_FUNC_ARG) {
 4293                             		.loc 2 4075 12
 4294 00ac EC A5                   		mov.L	[r10], r5
 4295 00ae 61 15                   		cmp	#1, r5
 4296 00b0 20 0D                   		beq	.L289
 4297                             		.loc 2 4075 36 discriminator 1
 4298 00b2 EC A5                   		mov.L	[r10], r5
 4299 00b4 76 05 53 FF             		cmp	#-173, r5
 4300 00b8 15                      		beq	.L289
4076:../src/src/tls.c ****             return ret;
 4301                             		.loc 2 4076 20
 4302 00b9 EC A5                   		mov.L	[r10], r5
 4303 00bb 2E 18                   		bra	.L291
 4304                             	.L289:
4069:../src/src/tls.c ****         ato16(input + offset, &name);
 4305                             		.loc 2 4069 36
 4306 00bd DD A5 02                		mov.W	4[r10], r5
 4307 00c0 62 25                   		add	#2, r5
 4308 00c2 D7 A5 02                		mov.W	r5, 4[r10]
 4309                             	.L288:
4069:../src/src/tls.c ****         ato16(input + offset, &name);
 4310                             		.loc 2 4069 19 discriminator 1
 4311 00c5 DD A5 02                		mov.W	4[r10], r5
4069:../src/src/tls.c ****         ato16(input + offset, &name);
 4312                             		.loc 2 4069 5 discriminator 1
 4313 00c8 5D A4 08                		movu.W	16[r10], r4
 4314 00cb 5F 55                   		movu.W	r5, r5
 4315 00cd 47 54                   		cmp	r5, r4
 4316 00cf 24 AF                   		bgtu	.L290
4077:../src/src/tls.c ****         }
4078:../src/src/tls.c ****     }
4079:../src/src/tls.c **** 
4080:../src/src/tls.c ****     return 0;
 4317                             		.loc 2 4080 12
 4318 00d1 66 05                   		mov.L	#0, r5
 4319                             		.balign 8,3,1
 4320                             	.L291:
4081:../src/src/tls.c **** }
 4321                             		.loc 2 4081 1 discriminator 1
 4322 00d3 EF 51                   		mov.L	r5, r1
 4323 00d5 3F AA 07                		rtsd	#28, r10-r10
 4324                             	.LFE88:
 4326                             		.section	.text.tlsx_ffdhe_find_group,"ax",@progbits
 4328                             	_tlsx_ffdhe_find_group:
 4329                             	.LFB89:
4082:../src/src/tls.c **** 
4083:../src/src/tls.c **** #endif
4084:../src/src/tls.c **** 
4085:../src/src/tls.c **** #if !defined(NO_WOLFSSL_SERVER)
4086:../src/src/tls.c **** 
4087:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && !defined(WOLFSSL_NO_SERVER_GROUPS_EXT)
4088:../src/src/tls.c **** 
4089:../src/src/tls.c **** /* Checks the priority of the groups on the server and set the supported groups
4090:../src/src/tls.c ****  * response if there is a group not advertised by the client that is preferred.
4091:../src/src/tls.c ****  *
4092:../src/src/tls.c ****  * ssl  SSL/TLS object.
4093:../src/src/tls.c ****  * returns 0 on success, otherwise an error.
4094:../src/src/tls.c ****  */
4095:../src/src/tls.c **** int TLSX_SupportedCurve_CheckPriority(WOLFSSL* ssl)
4096:../src/src/tls.c **** {
4097:../src/src/tls.c ****     int ret;
4098:../src/src/tls.c ****     TLSX* extension;
4099:../src/src/tls.c ****     TLSX* priority = NULL;
4100:../src/src/tls.c ****     TLSX* ext = NULL;
4101:../src/src/tls.c ****     word16 name;
4102:../src/src/tls.c ****     SupportedCurve* curve;
4103:../src/src/tls.c **** 
4104:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS);
4105:../src/src/tls.c ****     /* May be doing PSK with no key exchange. */
4106:../src/src/tls.c ****     if (extension == NULL)
4107:../src/src/tls.c ****         return 0;
4108:../src/src/tls.c **** 
4109:../src/src/tls.c ****     ret = TLSX_PopulateSupportedGroups(ssl, &priority);
4110:../src/src/tls.c ****     if (ret != WOLFSSL_SUCCESS) {
4111:../src/src/tls.c ****         TLSX_FreeAll(priority, ssl->heap);
4112:../src/src/tls.c ****         return ret;
4113:../src/src/tls.c ****     }
4114:../src/src/tls.c **** 
4115:../src/src/tls.c ****     ext = TLSX_Find(priority, TLSX_SUPPORTED_GROUPS);
4116:../src/src/tls.c ****     if (ext == NULL) {
4117:../src/src/tls.c ****         WOLFSSL_MSG("Could not find supported groups extension");
4118:../src/src/tls.c ****         TLSX_FreeAll(priority, ssl->heap);
4119:../src/src/tls.c ****         return 0;
4120:../src/src/tls.c ****     }
4121:../src/src/tls.c **** 
4122:../src/src/tls.c ****     curve = (SupportedCurve*)ext->data;
4123:../src/src/tls.c ****     name = curve->name;
4124:../src/src/tls.c **** 
4125:../src/src/tls.c ****     curve = (SupportedCurve*)extension->data;
4126:../src/src/tls.c ****     while (curve != NULL) {
4127:../src/src/tls.c ****         if (curve->name == name)
4128:../src/src/tls.c ****             break;
4129:../src/src/tls.c ****         curve = curve->next;
4130:../src/src/tls.c ****     }
4131:../src/src/tls.c **** 
4132:../src/src/tls.c ****     if (curve == NULL) {
4133:../src/src/tls.c ****         /* Couldn't find the preferred group in client list. */
4134:../src/src/tls.c ****         extension->resp = 1;
4135:../src/src/tls.c **** 
4136:../src/src/tls.c ****         /* Send server list back and free client list. */
4137:../src/src/tls.c ****         curve = (SupportedCurve*)extension->data;
4138:../src/src/tls.c ****         extension->data = ext->data;
4139:../src/src/tls.c ****         ext->data = curve;
4140:../src/src/tls.c ****     }
4141:../src/src/tls.c **** 
4142:../src/src/tls.c ****     TLSX_FreeAll(priority, ssl->heap);
4143:../src/src/tls.c **** 
4144:../src/src/tls.c ****     return 0;
4145:../src/src/tls.c **** }
4146:../src/src/tls.c **** 
4147:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 && !WOLFSSL_NO_SERVER_GROUPS_EXT */
4148:../src/src/tls.c **** 
4149:../src/src/tls.c **** #if defined(HAVE_FFDHE) && !defined(WOLFSSL_NO_TLS12)
4150:../src/src/tls.c **** #ifdef HAVE_PUBLIC_FFDHE
4151:../src/src/tls.c **** static int tlsx_ffdhe_find_group(WOLFSSL* ssl, SupportedCurve* clientGroup,
4152:../src/src/tls.c ****     SupportedCurve* serverGroup)
4153:../src/src/tls.c **** {
 4330                             		.loc 2 4153 1
 4331 0000 7E AA                   		push.l	r10
 4332                             	.LCFI127:
 4333 0002 71 0A E8                		add	#-24, r0, r10
 4334                             	.LCFI128:
 4335 0005 EF A0                   		mov.L	r10, r0
 4336 0007 E7 A1 03                		mov.L	r1, 12[r10]
 4337 000a E7 A2 04                		mov.L	r2, 16[r10]
 4338 000d E7 A3 05                		mov.L	r3, 20[r10]
4154:../src/src/tls.c ****     int ret = 0;
 4339                             		.loc 2 4154 9
 4340 0010 F8 A6 00                		mov.L	#0, [r10]
4155:../src/src/tls.c ****     SupportedCurve* group;
4156:../src/src/tls.c ****     const DhParams* params = NULL;
 4341                             		.loc 2 4156 21
 4342 0013 F9 A6 02 00             		mov.L	#0, 8[r10]
4157:../src/src/tls.c **** 
4158:../src/src/tls.c ****     for (; serverGroup != NULL; serverGroup = serverGroup->next) {
 4343                             		.loc 2 4158 5
 4344 0017 38 C1 00                		bra	.L293
 4345                             	.L307:
4159:../src/src/tls.c ****         if (serverGroup->name < MIN_FFHDE_GROUP ||
 4346                             		.loc 2 4159 24
 4347 001a ED A5 05                		mov.L	20[r10], r5
 4348 001d DC 55                   		mov.W	[r5], r5
 4349                             		.loc 2 4159 12
 4350 001f 5F 55                   		movu.W	r5, r5
 4351 0021 75 55 FF                		cmp	#0xff, r5
 4352 0024 24 05 38 A9 00          		bleu	.L310
4160:../src/src/tls.c ****             serverGroup->name > MAX_FFHDE_GROUP)
 4353                             		.loc 2 4160 24 discriminator 1
 4354 0029 ED A5 05                		mov.L	20[r10], r5
 4355 002c DC 55                   		mov.W	[r5], r5
4159:../src/src/tls.c ****         if (serverGroup->name < MIN_FFHDE_GROUP ||
 4356                             		.loc 2 4159 49 discriminator 1
 4357 002e 5F 55                   		movu.W	r5, r5
 4358 0030 76 05 FF 01             		cmp	#0x1ff, r5
 4359 0034 25 05 38 99 00          		bgtu	.L310
4161:../src/src/tls.c ****             continue;
4162:../src/src/tls.c **** 
4163:../src/src/tls.c ****         for (group = clientGroup; group != NULL; group = group->next) {
 4360                             		.loc 2 4163 20
 4361 0039 ED A5 04                		mov.L	16[r10], r5
 4362 003c E7 A5 01                		mov.L	r5, 4[r10]
 4363                             		.loc 2 4163 9
 4364 003f 2E 65                   		bra	.L297
 4365                             	.L304:
4164:../src/src/tls.c ****             if (serverGroup->name != group->name)
 4366                             		.loc 2 4164 28
 4367 0041 ED A5 05                		mov.L	20[r10], r5
 4368 0044 DC 54                   		mov.W	[r5], r4
 4369                             		.loc 2 4164 43
 4370 0046 ED A5 01                		mov.L	4[r10], r5
 4371 0049 DC 55                   		mov.W	[r5], r5
 4372                             		.loc 2 4164 16
 4373 004b 5F 44                   		movu.W	r4, r4
 4374 004d 5F 55                   		movu.W	r5, r5
 4375 004f 47 54                   		cmp	r5, r4
 4376 0051 21 4A                   		bne	.L311
4165:../src/src/tls.c ****                 continue;
4166:../src/src/tls.c **** 
4167:../src/src/tls.c ****             switch (serverGroup->name) {
 4377                             		.loc 2 4167 32
 4378 0053 ED A5 05                		mov.L	20[r10], r5
 4379 0056 DC 55                   		mov.W	[r5], r5
 4380 0058 5F 55                   		movu.W	r5, r5
 4381                             		.loc 2 4167 13
 4382 005a 76 05 00 01             		cmp	#0x100, r5
 4383 005e 1A                      		bne	.L312
4168:../src/src/tls.c ****             #ifdef HAVE_FFDHE_2048
4169:../src/src/tls.c ****                 case WOLFSSL_FFDHE_2048:
4170:../src/src/tls.c ****                     params = wc_Dh_ffdhe2048_Get();
 4384                             		.loc 2 4170 30
 4385 005f 05 00 00 00             		bsr	_wc_Dh_ffdhe2048_Get
 4386 0063 E7 A1 02                		mov.L	r1, 8[r10]
4171:../src/src/tls.c ****                     break;
 4387                             		.loc 2 4171 21
 4388 0066 2E 03                   		bra	.L301
 4389                             	.L312:
4172:../src/src/tls.c ****             #endif
4173:../src/src/tls.c ****             #ifdef HAVE_FFDHE_3072
4174:../src/src/tls.c ****                 case WOLFSSL_FFDHE_3072:
4175:../src/src/tls.c ****                     params = wc_Dh_ffdhe3072_Get();
4176:../src/src/tls.c ****                     break;
4177:../src/src/tls.c ****             #endif
4178:../src/src/tls.c ****             #ifdef HAVE_FFDHE_4096
4179:../src/src/tls.c ****                 case WOLFSSL_FFDHE_4096:
4180:../src/src/tls.c ****                     params = wc_Dh_ffdhe4096_Get();
4181:../src/src/tls.c ****                     break;
4182:../src/src/tls.c ****             #endif
4183:../src/src/tls.c ****             #ifdef HAVE_FFDHE_6144
4184:../src/src/tls.c ****                 case WOLFSSL_FFDHE_6144:
4185:../src/src/tls.c ****                     params = wc_Dh_ffdhe6144_Get();
4186:../src/src/tls.c ****                     break;
4187:../src/src/tls.c ****             #endif
4188:../src/src/tls.c ****             #ifdef HAVE_FFDHE_8192
4189:../src/src/tls.c ****                 case WOLFSSL_FFDHE_8192:
4190:../src/src/tls.c ****                     params = wc_Dh_ffdhe8192_Get();
4191:../src/src/tls.c ****                     break;
4192:../src/src/tls.c ****             #endif
4193:../src/src/tls.c ****                 default:
4194:../src/src/tls.c ****                     break;
 4390                             		.loc 2 4194 21
 4391 0068 03                      		nop
 4392                             	.L301:
4195:../src/src/tls.c ****             }
4196:../src/src/tls.c ****             if (params == NULL) {
 4393                             		.loc 2 4196 16
 4394 0069 ED A5 02                		mov.L	8[r10], r5
 4395 006c 61 05                   		cmp	#0, r5
 4396 006e 1F                      		bne	.L302
4197:../src/src/tls.c ****                 ret = BAD_FUNC_ARG;
 4397                             		.loc 2 4197 21
 4398 006f F8 AA 53 FF             		mov.L	#-173, [r10]
4198:../src/src/tls.c ****                 break;
 4399                             		.loc 2 4198 17
 4400 0073 2E 3B                   		bra	.L303
 4401                             	.L302:
4199:../src/src/tls.c ****             }
4200:../src/src/tls.c ****             if (params->p_len >= ssl->options.minDhKeySz &&
 4402                             		.loc 2 4200 23
 4403 0075 ED A5 02                		mov.L	8[r10], r5
 4404 0078 A8 5C                   		mov.L	4[r5], r4
 4405                             		.loc 2 4200 46
 4406 007a ED A5 03                		mov.L	12[r10], r5
 4407 007d DE 55 59 01             		mov.W	690[r5], r5
 4408                             		.loc 2 4200 31
 4409 0081 5F 55                   		movu.W	r5, r5
 4410                             		.loc 2 4200 16
 4411 0083 47 54                   		cmp	r5, r4
 4412 0085 23 17                   		bltu	.L299
4201:../src/src/tls.c ****                                      params->p_len <= ssl->options.maxDhKeySz) {
 4413                             		.loc 2 4201 44 discriminator 1
 4414 0087 ED A5 02                		mov.L	8[r10], r5
 4415 008a A8 5C                   		mov.L	4[r5], r4
 4416                             		.loc 2 4201 67 discriminator 1
 4417 008c ED A5 03                		mov.L	12[r10], r5
 4418 008f DE 55 5A 01             		mov.W	692[r5], r5
 4419                             		.loc 2 4201 52 discriminator 1
 4420 0093 5F 55                   		movu.W	r5, r5
4200:../src/src/tls.c ****                                      params->p_len <= ssl->options.maxDhKeySz) {
 4421                             		.loc 2 4200 58 discriminator 1
 4422 0095 47 54                   		cmp	r5, r4
 4423 0097 25 16                   		bleu	.L313
 4424 0099 2E 03                   		bra	.L299
 4425                             	.L311:
4165:../src/src/tls.c **** 
 4426                             		.loc 2 4165 17
 4427 009b 03                      		nop
 4428                             	.L299:
4163:../src/src/tls.c ****             if (serverGroup->name != group->name)
 4429                             		.loc 2 4163 56 discriminator 2
 4430 009c ED A5 01                		mov.L	4[r10], r5
 4431 009f A8 5D                   		mov.L	4[r5], r5
 4432 00a1 E7 A5 01                		mov.L	r5, 4[r10]
 4433                             	.L297:
4163:../src/src/tls.c ****             if (serverGroup->name != group->name)
 4434                             		.loc 2 4163 9 discriminator 1
 4435 00a4 ED A5 01                		mov.L	4[r10], r5
 4436 00a7 61 05                   		cmp	#0, r5
 4437 00a9 21 98                   		bne	.L304
 4438 00ab 2E 03                   		bra	.L303
 4439                             	.L313:
4202:../src/src/tls.c ****                 break;
 4440                             		.loc 2 4202 17
 4441 00ad 03                      		nop
 4442                             	.L303:
4203:../src/src/tls.c ****             }
4204:../src/src/tls.c ****         }
4205:../src/src/tls.c **** 
4206:../src/src/tls.c ****         if (ret != 0)
 4443                             		.loc 2 4206 12
 4444 00ae EC A5                   		mov.L	[r10], r5
 4445 00b0 61 05                   		cmp	#0, r5
 4446 00b2 21 2F                   		bne	.L314
4207:../src/src/tls.c ****             break;
4208:../src/src/tls.c ****         if ((group != NULL) && (serverGroup->name == group->name))
 4447                             		.loc 2 4208 12
 4448 00b4 ED A5 01                		mov.L	4[r10], r5
 4449 00b7 61 05                   		cmp	#0, r5
 4450 00b9 20 17                   		beq	.L296
 4451                             		.loc 2 4208 44 discriminator 1
 4452 00bb ED A5 05                		mov.L	20[r10], r5
 4453 00be DC 54                   		mov.W	[r5], r4
 4454                             		.loc 2 4208 59 discriminator 1
 4455 00c0 ED A5 01                		mov.L	4[r10], r5
 4456 00c3 DC 55                   		mov.W	[r5], r5
 4457                             		.loc 2 4208 29 discriminator 1
 4458 00c5 5F 44                   		movu.W	r4, r4
 4459 00c7 5F 55                   		movu.W	r5, r5
 4460 00c9 47 54                   		cmp	r5, r4
 4461 00cb 20 19                   		beq	.L315
 4462 00cd 2E 03                   		bra	.L296
 4463                             	.L310:
4161:../src/src/tls.c **** 
 4464                             		.loc 2 4161 13
 4465 00cf 03                      		nop
 4466                             	.L296:
4158:../src/src/tls.c ****         if (serverGroup->name < MIN_FFHDE_GROUP ||
 4467                             		.loc 2 4158 45
 4468 00d0 ED A5 05                		mov.L	20[r10], r5
 4469 00d3 A8 5D                   		mov.L	4[r5], r5
 4470 00d5 E7 A5 05                		mov.L	r5, 20[r10]
 4471                             	.L293:
4158:../src/src/tls.c ****         if (serverGroup->name < MIN_FFHDE_GROUP ||
 4472                             		.loc 2 4158 5 discriminator 1
 4473 00d8 ED A5 05                		mov.L	20[r10], r5
 4474 00db 61 05                   		cmp	#0, r5
 4475 00dd 3B 3D FF                		bne	.L307
 4476 00e0 0D                      		bra	.L306
 4477                             	.L314:
4207:../src/src/tls.c ****             break;
 4478                             		.loc 2 4207 13
 4479 00e1 03                      		nop
 4480 00e2 2E 03                   		bra	.L306
 4481                             	.L315:
4209:../src/src/tls.c ****             break;
 4482                             		.loc 2 4209 13
 4483 00e4 03                      		nop
 4484                             	.L306:
4210:../src/src/tls.c ****     }
4211:../src/src/tls.c **** 
4212:../src/src/tls.c ****     if ((ret == 0) && (serverGroup != NULL) && (params != NULL)) {
 4485                             		.loc 2 4212 8
 4486 00e5 EC A5                   		mov.L	[r10], r5
 4487 00e7 61 05                   		cmp	#0, r5
 4488 00e9 21 5F                   		bne	.L308
 4489                             		.loc 2 4212 20 discriminator 1
 4490 00eb ED A5 05                		mov.L	20[r10], r5
 4491 00ee 61 05                   		cmp	#0, r5
 4492 00f0 20 58                   		beq	.L308
 4493                             		.loc 2 4212 45 discriminator 2
 4494 00f2 ED A5 02                		mov.L	8[r10], r5
 4495 00f5 61 05                   		cmp	#0, r5
 4496 00f7 20 51                   		beq	.L308
4213:../src/src/tls.c ****         ssl->buffers.serverDH_P.buffer = (unsigned char *)params->p;
 4497                             		.loc 2 4213 65
 4498 00f9 ED A5 02                		mov.L	8[r10], r5
 4499 00fc EC 54                   		mov.L	[r5], r4
 4500                             		.loc 2 4213 40
 4501 00fe ED A5 03                		mov.L	12[r10], r5
 4502 0101 E7 54 37                		mov.L	r4, 220[r5]
4214:../src/src/tls.c ****         ssl->buffers.serverDH_P.length = params->p_len;
 4503                             		.loc 2 4214 48
 4504 0104 ED A5 02                		mov.L	8[r10], r5
 4505 0107 A8 5C                   		mov.L	4[r5], r4
 4506                             		.loc 2 4214 40
 4507 0109 ED A5 03                		mov.L	12[r10], r5
 4508 010c E7 54 38                		mov.L	r4, 224[r5]
4215:../src/src/tls.c ****         ssl->buffers.serverDH_G.buffer = (unsigned char *)params->g;
 4509                             		.loc 2 4215 65
 4510 010f ED A5 02                		mov.L	8[r10], r5
 4511 0112 A8 D4                   		mov.L	8[r5], r4
 4512                             		.loc 2 4215 40
 4513 0114 ED A5 03                		mov.L	12[r10], r5
 4514 0117 E7 54 39                		mov.L	r4, 228[r5]
4216:../src/src/tls.c ****         ssl->buffers.serverDH_G.length = params->g_len;
 4515                             		.loc 2 4216 48
 4516 011a ED A5 02                		mov.L	8[r10], r5
 4517 011d A8 DC                   		mov.L	12[r5], r4
 4518                             		.loc 2 4216 40
 4519 011f ED A5 03                		mov.L	12[r10], r5
 4520 0122 E7 54 3A                		mov.L	r4, 232[r5]
4217:../src/src/tls.c **** 
4218:../src/src/tls.c ****         ssl->namedGroup = serverGroup->name;
 4521                             		.loc 2 4218 38
 4522 0125 ED A5 05                		mov.L	20[r10], r5
 4523 0128 DC 54                   		mov.W	[r5], r4
 4524                             		.loc 2 4218 25
 4525 012a ED A5 03                		mov.L	12[r10], r5
 4526 012d DB 54 61 01             		mov.W	r4, 706[r5]
4219:../src/src/tls.c ****     #if !defined(WOLFSSL_OLD_PRIME_CHECK) && \
4220:../src/src/tls.c ****         !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
4221:../src/src/tls.c ****         ssl->options.dhDoKeyTest = 0;
 4527                             		.loc 2 4221 34
 4528 0131 ED A4 03                		mov.L	12[r10], r4
 4529 0134 ED 45 A8                		mov.L	672[r4], r5
 4530 0137 7B 15                   		bclr	#17, r5
 4531 0139 E7 45 A8                		mov.L	r5, 672[r4]
4222:../src/src/tls.c ****     #endif
4223:../src/src/tls.c ****         ssl->options.haveDH = 1;
 4532                             		.loc 2 4223 29
 4533 013c ED A4 03                		mov.L	12[r10], r4
 4534 013f ED 45 A7                		mov.L	668[r4], r5
 4535 0142 79 A5                   		bset	#26, r5
 4536 0144 E7 45 A7                		mov.L	r5, 668[r4]
 4537 0147 03                      		.balign 8,3,1
 4538                             	.L308:
4224:../src/src/tls.c ****     }
4225:../src/src/tls.c **** 
4226:../src/src/tls.c ****     return ret;
 4539                             		.loc 2 4226 12
 4540 0148 EC A5                   		mov.L	[r10], r5
4227:../src/src/tls.c **** }
 4541                             		.loc 2 4227 1
 4542 014a EF 51                   		mov.L	r5, r1
 4543 014c 3F AA 07                		rtsd	#28, r10-r10
 4544                             	.LFE89:
 4546 014f 03                      		.section	.text.TLSX_SupportedFFDHE_Set,"ax",@progbits
 4547                             		.global	_TLSX_SupportedFFDHE_Set
 4549                             	_TLSX_SupportedFFDHE_Set:
 4550                             	.LFB90:
4228:../src/src/tls.c **** #else
4229:../src/src/tls.c **** static int tlsx_ffdhe_find_group(WOLFSSL* ssl, SupportedCurve* clientGroup,
4230:../src/src/tls.c ****     SupportedCurve* serverGroup)
4231:../src/src/tls.c **** {
4232:../src/src/tls.c ****     int ret = 0;
4233:../src/src/tls.c ****     SupportedCurve* group;
4234:../src/src/tls.c ****     word32 p_len;
4235:../src/src/tls.c **** 
4236:../src/src/tls.c ****     for (; serverGroup != NULL; serverGroup = serverGroup->next) {
4237:../src/src/tls.c ****         if (serverGroup->name < MIN_FFHDE_GROUP ||
4238:../src/src/tls.c ****             serverGroup->name > MAX_FFHDE_GROUP)
4239:../src/src/tls.c ****             continue;
4240:../src/src/tls.c **** 
4241:../src/src/tls.c ****         for (group = clientGroup; group != NULL; group = group->next) {
4242:../src/src/tls.c ****             if (serverGroup->name != group->name)
4243:../src/src/tls.c ****                 continue;
4244:../src/src/tls.c **** 
4245:../src/src/tls.c ****             wc_DhGetNamedKeyParamSize(serverGroup->name, &p_len, NULL, NULL);
4246:../src/src/tls.c ****             if (p_len == 0) {
4247:../src/src/tls.c ****                 ret = BAD_FUNC_ARG;
4248:../src/src/tls.c ****                 break;
4249:../src/src/tls.c ****             }
4250:../src/src/tls.c ****             if (p_len >= ssl->options.minDhKeySz &&
4251:../src/src/tls.c ****                                              p_len <= ssl->options.maxDhKeySz) {
4252:../src/src/tls.c ****                 break;
4253:../src/src/tls.c ****             }
4254:../src/src/tls.c ****         }
4255:../src/src/tls.c **** 
4256:../src/src/tls.c ****         if (ret != 0)
4257:../src/src/tls.c ****             break;
4258:../src/src/tls.c ****         if ((group != NULL) && (serverGroup->name == group->name))
4259:../src/src/tls.c ****             break;
4260:../src/src/tls.c ****     }
4261:../src/src/tls.c **** 
4262:../src/src/tls.c ****     if ((ret == 0) && (serverGroup != NULL)) {
4263:../src/src/tls.c ****         word32 pSz, gSz;
4264:../src/src/tls.c **** 
4265:../src/src/tls.c ****         ssl->buffers.serverDH_P.buffer = NULL;
4266:../src/src/tls.c ****         ssl->buffers.serverDH_G.buffer = NULL;
4267:../src/src/tls.c ****         ret = wc_DhGetNamedKeyParamSize(serverGroup->name, &pSz, &gSz, NULL);
4268:../src/src/tls.c ****         if (ret == 0) {
4269:../src/src/tls.c ****             ssl->buffers.serverDH_P.buffer =
4270:../src/src/tls.c ****                 (byte*)XMALLOC(pSz, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
4271:../src/src/tls.c ****             if (ssl->buffers.serverDH_P.buffer == NULL)
4272:../src/src/tls.c ****                 ret = MEMORY_E;
4273:../src/src/tls.c ****             else
4274:../src/src/tls.c ****                 ssl->buffers.serverDH_P.length = pSz;
4275:../src/src/tls.c ****         }
4276:../src/src/tls.c ****         if (ret == 0) {
4277:../src/src/tls.c ****             ssl->buffers.serverDH_G.buffer =
4278:../src/src/tls.c ****                 (byte*)XMALLOC(gSz, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
4279:../src/src/tls.c ****             if (ssl->buffers.serverDH_G.buffer == NULL) {
4280:../src/src/tls.c ****                 ret = MEMORY_E;
4281:../src/src/tls.c ****             } else
4282:../src/src/tls.c ****                 ssl->buffers.serverDH_G.length = gSz;
4283:../src/src/tls.c ****         }
4284:../src/src/tls.c ****         if (ret == 0) {
4285:../src/src/tls.c ****             ret = wc_DhCopyNamedKey(serverGroup->name,
4286:../src/src/tls.c ****                               ssl->buffers.serverDH_P.buffer, &pSz,
4287:../src/src/tls.c ****                               ssl->buffers.serverDH_G.buffer, &gSz,
4288:../src/src/tls.c ****                               NULL, NULL);
4289:../src/src/tls.c ****         }
4290:../src/src/tls.c ****         if (ret == 0) {
4291:../src/src/tls.c ****             ssl->buffers.weOwnDH = 1;
4292:../src/src/tls.c **** 
4293:../src/src/tls.c ****             ssl->namedGroup = serverGroup->name;
4294:../src/src/tls.c ****         #if !defined(WOLFSSL_OLD_PRIME_CHECK) && \
4295:../src/src/tls.c ****             !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
4296:../src/src/tls.c ****             ssl->options.dhDoKeyTest = 0;
4297:../src/src/tls.c ****         #endif
4298:../src/src/tls.c ****             ssl->options.haveDH = 1;
4299:../src/src/tls.c ****         }
4300:../src/src/tls.c ****         else {
4301:../src/src/tls.c ****             if (ssl->buffers.serverDH_P.buffer != NULL) {
4302:../src/src/tls.c ****                 XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,
4303:../src/src/tls.c ****                     DYNAMIC_TYPE_PUBLIC_KEY);
4304:../src/src/tls.c ****                 ssl->buffers.serverDH_P.length = 0;
4305:../src/src/tls.c ****                 ssl->buffers.serverDH_P.buffer = NULL;
4306:../src/src/tls.c ****             }
4307:../src/src/tls.c ****             if (ssl->buffers.serverDH_G.buffer != NULL) {
4308:../src/src/tls.c ****                 XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,
4309:../src/src/tls.c ****                     DYNAMIC_TYPE_PUBLIC_KEY);
4310:../src/src/tls.c ****                 ssl->buffers.serverDH_G.length = 0;
4311:../src/src/tls.c ****                 ssl->buffers.serverDH_G.buffer = NULL;
4312:../src/src/tls.c ****             }
4313:../src/src/tls.c ****         }
4314:../src/src/tls.c ****     }
4315:../src/src/tls.c **** 
4316:../src/src/tls.c ****     return ret;
4317:../src/src/tls.c **** }
4318:../src/src/tls.c **** #endif
4319:../src/src/tls.c **** 
4320:../src/src/tls.c **** /* Set the highest priority common FFDHE group on the server as compared to
4321:../src/src/tls.c ****  * client extensions.
4322:../src/src/tls.c ****  *
4323:../src/src/tls.c ****  * ssl    SSL/TLS object.
4324:../src/src/tls.c ****  * returns 0 on success, otherwise an error.
4325:../src/src/tls.c ****  */
4326:../src/src/tls.c **** int TLSX_SupportedFFDHE_Set(WOLFSSL* ssl)
4327:../src/src/tls.c **** {
 4551                             		.loc 2 4327 1
 4552 0000 7E AA                   		push.l	r10
 4553                             	.LCFI129:
 4554 0002 71 0A D4                		add	#-44, r0, r10
 4555                             	.LCFI130:
 4556 0005 EF A0                   		mov.L	r10, r0
 4557 0007 E7 A1 0A                		mov.L	r1, 40[r10]
4328:../src/src/tls.c ****     int ret;
4329:../src/src/tls.c ****     TLSX* priority = NULL;
 4558                             		.loc 2 4329 11
 4559 000a F9 A6 09 00             		mov.L	#0, 36[r10]
4330:../src/src/tls.c ****     TLSX* ext = NULL;
 4560                             		.loc 2 4330 11
 4561 000e F9 A6 03 00             		mov.L	#0, 12[r10]
4331:../src/src/tls.c ****     TLSX* extension;
4332:../src/src/tls.c ****     SupportedCurve* clientGroup;
4333:../src/src/tls.c ****     SupportedCurve* serverGroup;
4334:../src/src/tls.c ****     SupportedCurve* group;
4335:../src/src/tls.c ****     int found = 0;
 4562                             		.loc 2 4335 9
 4563 0012 F9 A6 02 00             		mov.L	#0, 8[r10]
4336:../src/src/tls.c **** 
4337:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS);
 4564                             		.loc 2 4337 17
 4565 0016 ED A5 0A                		mov.L	40[r10], r5
 4566 0019 ED 55 BF                		mov.L	764[r5], r5
 4567 001c 66 A2                   		mov.L	#10, r2
 4568 001e EF 51                   		mov.L	r5, r1
 4569 0020 05 00 00 00             		bsr	_TLSX_Find
 4570 0024 E7 A1 04                		mov.L	r1, 16[r10]
4338:../src/src/tls.c ****     /* May be doing PSK with no key exchange. */
4339:../src/src/tls.c ****     if (extension == NULL)
 4571                             		.loc 2 4339 8
 4572 0027 ED A5 04                		mov.L	16[r10], r5
 4573 002a 61 05                   		cmp	#0, r5
 4574 002c 1E                      		bne	.L317
4340:../src/src/tls.c ****         return 0;
 4575                             		.loc 2 4340 16
 4576 002d 66 05                   		mov.L	#0, r5
 4577 002f 38 10 01                		bra	.L327
 4578                             	.L317:
4341:../src/src/tls.c ****     clientGroup = (SupportedCurve*)extension->data;
 4579                             		.loc 2 4341 17
 4580 0032 ED A5 04                		mov.L	16[r10], r5
 4581 0035 A8 5D                   		mov.L	4[r5], r5
 4582 0037 E7 A5 05                		mov.L	r5, 20[r10]
4342:../src/src/tls.c ****     for (group = clientGroup; group != NULL; group = group->next) {
 4583                             		.loc 2 4342 16
 4584 003a ED A5 05                		mov.L	20[r10], r5
 4585 003d E7 A5 01                		mov.L	r5, 4[r10]
 4586                             		.loc 2 4342 5
 4587 0040 2E 29                   		bra	.L319
 4588                             	.L322:
4343:../src/src/tls.c ****         if (group->name >= MIN_FFHDE_GROUP && group->name <= MAX_FFHDE_GROUP) {
 4589                             		.loc 2 4343 18
 4590 0042 ED A5 01                		mov.L	4[r10], r5
 4591 0045 DC 55                   		mov.W	[r5], r5
 4592                             		.loc 2 4343 12
 4593 0047 5F 55                   		movu.W	r5, r5
 4594 0049 75 55 FF                		cmp	#0xff, r5
 4595 004c 25 15                   		bleu	.L320
 4596                             		.loc 2 4343 52 discriminator 1
 4597 004e ED A5 01                		mov.L	4[r10], r5
 4598 0051 DC 55                   		mov.W	[r5], r5
 4599                             		.loc 2 4343 44 discriminator 1
 4600 0053 5F 55                   		movu.W	r5, r5
 4601 0055 76 05 FF 01             		cmp	#0x1ff, r5
 4602 0059 24 08                   		bgtu	.L320
4344:../src/src/tls.c ****             found = 1;
 4603                             		.loc 2 4344 19
 4604 005b F9 A6 02 01             		mov.L	#1, 8[r10]
4345:../src/src/tls.c ****             break;
 4605                             		.loc 2 4345 13
 4606 005f 2E 11                   		bra	.L321
 4607                             	.L320:
4342:../src/src/tls.c ****         if (group->name >= MIN_FFHDE_GROUP && group->name <= MAX_FFHDE_GROUP) {
 4608                             		.loc 2 4342 52 discriminator 2
 4609 0061 ED A5 01                		mov.L	4[r10], r5
 4610 0064 A8 5D                   		mov.L	4[r5], r5
 4611 0066 E7 A5 01                		mov.L	r5, 4[r10]
 4612                             	.L319:
4342:../src/src/tls.c ****         if (group->name >= MIN_FFHDE_GROUP && group->name <= MAX_FFHDE_GROUP) {
 4613                             		.loc 2 4342 5 discriminator 1
 4614 0069 ED A5 01                		mov.L	4[r10], r5
 4615 006c 61 05                   		cmp	#0, r5
 4616 006e 21 D4                   		bne	.L322
 4617                             	.L321:
4346:../src/src/tls.c ****         }
4347:../src/src/tls.c ****     }
4348:../src/src/tls.c ****     if (!found)
 4618                             		.loc 2 4348 8
 4619 0070 ED A5 02                		mov.L	8[r10], r5
 4620 0073 61 05                   		cmp	#0, r5
 4621 0075 1E                      		bne	.L323
4349:../src/src/tls.c ****         return 0;
 4622                             		.loc 2 4349 16
 4623 0076 66 05                   		mov.L	#0, r5
 4624 0078 38 C7 00                		bra	.L327
 4625                             	.L323:
4350:../src/src/tls.c **** 
4351:../src/src/tls.c ****     if (ssl->buffers.serverDH_P.buffer && ssl->buffers.weOwnDH) {
 4626                             		.loc 2 4351 32
 4627 007b ED A5 0A                		mov.L	40[r10], r5
 4628 007e ED 55 37                		mov.L	220[r5], r5
 4629                             		.loc 2 4351 8
 4630 0081 61 05                   		cmp	#0, r5
 4631 0083 20 25                   		beq	.L324
 4632                             		.loc 2 4351 55 discriminator 1
 4633 0085 ED A5 0A                		mov.L	40[r10], r5
 4634 0088 CD 55 DB                		mov.B	219[r5], r5
 4635                             		.loc 2 4351 40 discriminator 1
 4636 008b 5B 55                   		movu.B	r5, r5
 4637 008d 61 05                   		cmp	#0, r5
 4638 008f 20 19                   		beq	.L324
 4639                             	.LBB14:
4352:../src/src/tls.c ****         XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,
 4640                             		.loc 2 4352 9
 4641 0091 ED A5 0A                		mov.L	40[r10], r5
 4642 0094 ED 55 37                		mov.L	220[r5], r5
 4643 0097 E7 A5 06                		mov.L	r5, 24[r10]
 4644 009a ED A5 06                		mov.L	24[r10], r5
 4645 009d 61 05                   		cmp	#0, r5
 4646 009f 11                      		beq	.L324
 4647                             		.loc 2 4352 9 is_stmt 0 discriminator 1
 4648 00a0 ED A1 06                		mov.L	24[r10], r1
 4649 00a3 05 00 00 00             		bsr	_wolfSSL_Free
 4650 00a7 03                      		.balign 8,3,1
 4651                             	.L324:
 4652                             	.LBE14:
4353:../src/src/tls.c ****                                                        DYNAMIC_TYPE_PUBLIC_KEY);
4354:../src/src/tls.c ****     }
4355:../src/src/tls.c ****     if (ssl->buffers.serverDH_G.buffer && ssl->buffers.weOwnDH) {
 4653                             		.loc 2 4355 32 is_stmt 1
 4654 00a8 ED A5 0A                		mov.L	40[r10], r5
 4655 00ab ED 55 39                		mov.L	228[r5], r5
 4656                             		.loc 2 4355 8
 4657 00ae 61 05                   		cmp	#0, r5
 4658 00b0 20 24                   		beq	.L325
 4659                             		.loc 2 4355 55 discriminator 1
 4660 00b2 ED A5 0A                		mov.L	40[r10], r5
 4661 00b5 CD 55 DB                		mov.B	219[r5], r5
 4662                             		.loc 2 4355 40 discriminator 1
 4663 00b8 5B 55                   		movu.B	r5, r5
 4664 00ba 61 05                   		cmp	#0, r5
 4665 00bc 20 18                   		beq	.L325
 4666                             	.LBB15:
4356:../src/src/tls.c ****         XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,
 4667                             		.loc 2 4356 9
 4668 00be ED A5 0A                		mov.L	40[r10], r5
 4669 00c1 ED 55 39                		mov.L	228[r5], r5
 4670 00c4 E7 A5 07                		mov.L	r5, 28[r10]
 4671 00c7 ED A5 07                		mov.L	28[r10], r5
 4672 00ca 61 05                   		cmp	#0, r5
 4673 00cc 10                      		beq	.L325
 4674                             		.loc 2 4356 9 is_stmt 0 discriminator 1
 4675 00cd ED A1 07                		mov.L	28[r10], r1
 4676 00d0 05 00 00 00             		bsr	_wolfSSL_Free
 4677                             		.balign 8,3,1
 4678                             	.L325:
 4679                             	.LBE15:
4357:../src/src/tls.c ****                                                        DYNAMIC_TYPE_PUBLIC_KEY);
4358:../src/src/tls.c ****     }
4359:../src/src/tls.c ****     ssl->buffers.serverDH_P.buffer = NULL;
 4680                             		.loc 2 4359 36 is_stmt 1
 4681 00d4 ED A5 0A                		mov.L	40[r10], r5
 4682 00d7 F9 56 37 00             		mov.L	#0, 220[r5]
4360:../src/src/tls.c ****     ssl->buffers.serverDH_G.buffer = NULL;
 4683                             		.loc 2 4360 36
 4684 00db ED A5 0A                		mov.L	40[r10], r5
 4685 00de F9 56 39 00             		mov.L	#0, 228[r5]
4361:../src/src/tls.c ****     ssl->buffers.weOwnDH = 0;
 4686                             		.loc 2 4361 26
 4687 00e2 ED A5 0A                		mov.L	40[r10], r5
 4688 00e5 F9 54 DB 00             		mov.B	#0, 219[r5]
4362:../src/src/tls.c ****     ssl->options.haveDH = 0;
 4689                             		.loc 2 4362 25
 4690 00e9 ED A4 0A                		mov.L	40[r10], r4
 4691 00ec ED 45 A7                		mov.L	668[r4], r5
 4692 00ef 7B A5                   		bclr	#26, r5
 4693 00f1 E7 45 A7                		mov.L	r5, 668[r4]
4363:../src/src/tls.c **** 
4364:../src/src/tls.c ****     ret = TLSX_PopulateSupportedGroups(ssl, &priority);
 4694                             		.loc 2 4364 11
 4695 00f4 71 A5 24                		add	#36, r10, r5
 4696 00f7 EF 52                   		mov.L	r5, r2
 4697 00f9 ED A1 0A                		mov.L	40[r10], r1
 4698 00fc 05 00 00 00             		bsr	_TLSX_PopulateSupportedGroups
 4699 0100 E3 A1                   		mov.L	r1, [r10]
4365:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS) {
 4700                             		.loc 2 4365 8
 4701 0102 EC A5                   		mov.L	[r10], r5
 4702 0104 61 15                   		cmp	#1, r5
 4703 0106 21 27                   		bne	.L326
4366:../src/src/tls.c ****         ext = TLSX_Find(priority, TLSX_SUPPORTED_GROUPS);
 4704                             		.loc 2 4366 15
 4705 0108 ED A5 09                		mov.L	36[r10], r5
 4706 010b 66 A2                   		mov.L	#10, r2
 4707 010d EF 51                   		mov.L	r5, r1
 4708 010f 05 00 00 00             		bsr	_TLSX_Find
 4709 0113 E7 A1 03                		mov.L	r1, 12[r10]
4367:../src/src/tls.c ****         serverGroup = (SupportedCurve*)ext->data;
 4710                             		.loc 2 4367 21
 4711 0116 ED A5 03                		mov.L	12[r10], r5
 4712 0119 A8 5D                   		mov.L	4[r5], r5
 4713 011b E7 A5 08                		mov.L	r5, 32[r10]
4368:../src/src/tls.c **** 
4369:../src/src/tls.c ****         ret = tlsx_ffdhe_find_group(ssl, clientGroup, serverGroup);
 4714                             		.loc 2 4369 15
 4715 011e ED A3 08                		mov.L	32[r10], r3
 4716 0121 ED A2 05                		mov.L	20[r10], r2
 4717 0124 ED A1 0A                		mov.L	40[r10], r1
 4718 0127 05 00 00 00             		bsr	_tlsx_ffdhe_find_group
 4719 012b E3 A1                   		mov.L	r1, [r10]
 4720                             	.L326:
4370:../src/src/tls.c ****     }
4371:../src/src/tls.c **** 
4372:../src/src/tls.c ****     TLSX_FreeAll(priority, ssl->heap);
 4721                             		.loc 2 4372 5
 4722 012d ED A4 09                		mov.L	36[r10], r4
 4723 0130 ED A5 0A                		mov.L	40[r10], r5
 4724 0133 AA 5D                   		mov.L	36[r5], r5
 4725 0135 EF 52                   		mov.L	r5, r2
 4726 0137 EF 41                   		mov.L	r4, r1
 4727 0139 05 00 00 00             		bsr	_TLSX_FreeAll
4373:../src/src/tls.c **** 
4374:../src/src/tls.c ****     return ret;
 4728                             		.loc 2 4374 12
 4729 013d EC A5                   		mov.L	[r10], r5
 4730                             	.L327:
4375:../src/src/tls.c **** }
 4731                             		.loc 2 4375 1 discriminator 1
 4732 013f EF 51                   		mov.L	r5, r1
 4733 0141 3F AA 0C                		rtsd	#48, r10-r10
 4734                             	.LFE90:
 4736 0144 76 10 01 00             		.section	.text.TLSX_PointFormat_Parse,"ax",@progbits
 4738                             	_TLSX_PointFormat_Parse:
 4739                             	.LFB91:
4376:../src/src/tls.c **** #endif /* HAVE_FFDHE && !WOLFSSL_NO_TLS12 */
4377:../src/src/tls.c **** 
4378:../src/src/tls.c **** #endif /* !NO_WOLFSSL_SERVER */
4379:../src/src/tls.c **** 
4380:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && !defined(WOLFSSL_NO_SERVER_GROUPS_EXT)
4381:../src/src/tls.c **** /* Return the preferred group.
4382:../src/src/tls.c ****  *
4383:../src/src/tls.c ****  * ssl             SSL/TLS object.
4384:../src/src/tls.c ****  * checkSupported  Whether to check for the first supported group.
4385:../src/src/tls.c ****  * returns BAD_FUNC_ARG if no group found, otherwise the group.
4386:../src/src/tls.c ****  */
4387:../src/src/tls.c **** int TLSX_SupportedCurve_Preferred(WOLFSSL* ssl, int checkSupported)
4388:../src/src/tls.c **** {
4389:../src/src/tls.c ****     TLSX* extension;
4390:../src/src/tls.c ****     SupportedCurve* curve;
4391:../src/src/tls.c **** 
4392:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS);
4393:../src/src/tls.c ****     if (extension == NULL)
4394:../src/src/tls.c ****         return BAD_FUNC_ARG;
4395:../src/src/tls.c **** 
4396:../src/src/tls.c ****     curve = (SupportedCurve*)extension->data;
4397:../src/src/tls.c ****     while (curve != NULL) {
4398:../src/src/tls.c ****         if (!checkSupported || TLSX_KeyShare_IsSupported(curve->name))
4399:../src/src/tls.c ****             return curve->name;
4400:../src/src/tls.c ****         curve = curve->next;
4401:../src/src/tls.c ****     }
4402:../src/src/tls.c **** 
4403:../src/src/tls.c ****     return BAD_FUNC_ARG;
4404:../src/src/tls.c **** }
4405:../src/src/tls.c **** 
4406:../src/src/tls.c **** #endif /* HAVE_SUPPORTED_CURVES */
4407:../src/src/tls.c **** 
4408:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
4409:../src/src/tls.c **** 
4410:../src/src/tls.c **** static int TLSX_PointFormat_Parse(WOLFSSL* ssl, const byte* input,
4411:../src/src/tls.c ****                                   word16 length, byte isRequest)
4412:../src/src/tls.c **** {
 4740                             		.loc 2 4412 1
 4741 0000 7E AA                   		push.l	r10
 4742                             	.LCFI131:
 4743 0002 71 0A F0                		add	#-16, r0, r10
 4744                             	.LCFI132:
 4745 0005 EF A0                   		mov.L	r10, r0
 4746 0007 E7 A1 01                		mov.L	r1, 4[r10]
 4747 000a E7 A2 02                		mov.L	r2, 8[r10]
 4748 000d D7 A3 06                		mov.W	r3, 12[r10]
 4749 0010 C7 A4 0E                		mov.B	r4, 14[r10]
4413:../src/src/tls.c ****     int ret;
4414:../src/src/tls.c **** 
4415:../src/src/tls.c ****     /* validating formats list length */
4416:../src/src/tls.c ****     if (ENUM_LEN > length || length != (word16)ENUM_LEN + input[0])
 4750                             		.loc 2 4416 8
 4751 0013 5D A5 06                		movu.W	12[r10], r5
 4752 0016 61 05                   		cmp	#0, r5
 4753 0018 20 11                   		beq	.L329
 4754                             		.loc 2 4416 37 discriminator 1
 4755 001a 5D A4 06                		movu.W	12[r10], r4
 4756                             		.loc 2 4416 64 discriminator 1
 4757 001d ED A5 02                		mov.L	8[r10], r5
 4758 0020 CC 55                   		mov.B	[r5], r5
 4759 0022 5B 55                   		movu.B	r5, r5
 4760                             		.loc 2 4416 57 discriminator 1
 4761 0024 62 15                   		add	#1, r5
 4762                             		.loc 2 4416 27 discriminator 1
 4763 0026 47 54                   		cmp	r5, r4
 4764 0028 17                      		beq	.L330
 4765                             	.L329:
4417:../src/src/tls.c ****         return BUFFER_ERROR;
 4766                             		.loc 2 4417 16
 4767 0029 FB 5A B8 FE             		mov.L	#-328, r5
 4768 002d 2E 35                   		bra	.L331
 4769                             	.L330:
4418:../src/src/tls.c **** 
4419:../src/src/tls.c ****     if (isRequest) {
 4770                             		.loc 2 4419 8
 4771 002f 59 A5 0E                		movu.B	14[r10], r5
 4772 0032 61 05                   		cmp	#0, r5
 4773 0034 20 2C                   		beq	.L332
4420:../src/src/tls.c ****         /* adding uncompressed point format to response */
4421:../src/src/tls.c ****         ret = TLSX_UsePointFormat(&ssl->extensions, WOLFSSL_EC_PF_UNCOMPRESSED,
 4774                             		.loc 2 4421 15
 4775 0036 ED A5 01                		mov.L	4[r10], r5
 4776 0039 72 54 FC 02             		add	#0x2fc, r5, r4
 4777 003d ED A5 01                		mov.L	4[r10], r5
 4778 0040 AA 5D                   		mov.L	36[r5], r5
 4779 0042 EF 53                   		mov.L	r5, r3
 4780 0044 66 02                   		mov	#0, r2
 4781 0046 EF 41                   		mov.L	r4, r1
 4782 0048 05 00 00 00             		bsr	_TLSX_UsePointFormat
 4783 004c E3 A1                   		mov.L	r1, [r10]
4422:../src/src/tls.c ****                                                                      ssl->heap);
4423:../src/src/tls.c ****         if (ret != WOLFSSL_SUCCESS)
 4784                             		.loc 2 4423 12
 4785 004e EC A5                   		mov.L	[r10], r5
 4786 0050 61 15                   		cmp	#1, r5
 4787 0052 15                      		beq	.L333
4424:../src/src/tls.c ****             return ret; /* throw error */
 4788                             		.loc 2 4424 20
 4789 0053 EC A5                   		mov.L	[r10], r5
 4790 0055 2E 0D                   		bra	.L331
 4791                             	.L333:
4425:../src/src/tls.c **** 
4426:../src/src/tls.c ****         TLSX_SetResponse(ssl, TLSX_EC_POINT_FORMATS);
 4792                             		.loc 2 4426 9
 4793 0057 66 B2                   		mov.L	#11, r2
 4794 0059 ED A1 01                		mov.L	4[r10], r1
 4795 005c 05 00 00 00             		bsr	_TLSX_SetResponse
 4796                             	.L332:
4427:../src/src/tls.c ****     }
4428:../src/src/tls.c **** 
4429:../src/src/tls.c ****     return 0;
 4797                             		.loc 2 4429 12
 4798 0060 66 05                   		mov.L	#0, r5
 4799                             	.L331:
4430:../src/src/tls.c **** }
 4800                             		.loc 2 4430 1
 4801 0062 EF 51                   		mov.L	r5, r1
 4802 0064 3F AA 05                		rtsd	#20, r10-r10
 4803                             	.LFE91:
 4805                             		.section	.text.TLSX_ValidateSupportedCurves,"ax",@progbits
 4806                             		.global	_TLSX_ValidateSupportedCurves
 4808                             	_TLSX_ValidateSupportedCurves:
 4809                             	.LFB92:
4431:../src/src/tls.c **** 
4432:../src/src/tls.c **** #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
4433:../src/src/tls.c **** int TLSX_ValidateSupportedCurves(WOLFSSL* ssl, byte first, byte second) {
 4810                             		.loc 2 4433 73
 4811 0000 7E AA                   		push.l	r10
 4812                             	.LCFI133:
 4813 0002 71 0A CC                		add	#-52, r0, r10
 4814                             	.LCFI134:
 4815 0005 EF A0                   		mov.L	r10, r0
 4816 0007 E7 A1 0B                		mov.L	r1, 44[r10]
 4817 000a C7 A2 30                		mov.B	r2, 48[r10]
 4818 000d C7 A3 31                		mov.B	r3, 49[r10]
4434:../src/src/tls.c ****     TLSX*           extension = NULL;
 4819                             		.loc 2 4434 21
 4820 0010 F8 A6 00                		mov.L	#0, [r10]
4435:../src/src/tls.c ****     SupportedCurve* curve     = NULL;
 4821                             		.loc 2 4435 21
 4822 0013 F9 A6 01 00             		mov.L	#0, 4[r10]
4436:../src/src/tls.c ****     word32          oid       = 0;
 4823                             		.loc 2 4436 21
 4824 0017 F9 A6 02 00             		mov.L	#0, 8[r10]
4437:../src/src/tls.c ****     word32          defOid    = 0;
 4825                             		.loc 2 4437 21
 4826 001b F9 A6 03 00             		mov.L	#0, 12[r10]
4438:../src/src/tls.c ****     word32          defSz     = 80; /* Maximum known curve size is 66. */
 4827                             		.loc 2 4438 21
 4828 001f F9 A6 04 50             		mov.L	#0x50, 16[r10]
4439:../src/src/tls.c ****     word32          nextOid   = 0;
 4829                             		.loc 2 4439 21
 4830 0023 F9 A6 05 00             		mov.L	#0, 20[r10]
4440:../src/src/tls.c ****     word32          nextSz    = 80; /* Maximum known curve size is 66. */
 4831                             		.loc 2 4440 21
 4832 0027 F9 A6 06 50             		mov.L	#0x50, 24[r10]
4441:../src/src/tls.c ****     word32          currOid   = ssl->ecdhCurveOID;
 4833                             		.loc 2 4441 21
 4834 002b ED A5 0B                		mov.L	44[r10], r5
 4835 002e ED 55 B3                		mov.L	716[r5], r5
 4836 0031 E7 A5 07                		mov.L	r5, 28[r10]
4442:../src/src/tls.c ****     int             ephmSuite = 0;
 4837                             		.loc 2 4442 21
 4838 0034 F9 A6 08 00             		mov.L	#0, 32[r10]
4443:../src/src/tls.c ****     word16          octets    = 0; /* according to 'ecc_set_type ecc_sets[];' */
 4839                             		.loc 2 4443 21
 4840 0038 F9 A5 12 00             		mov.W	#0, 36[r10]
4444:../src/src/tls.c ****     int             key       = 0; /* validate key       */
 4841                             		.loc 2 4444 21
 4842 003c F9 A6 0A 00             		mov.L	#0, 40[r10]
4445:../src/src/tls.c **** 
4446:../src/src/tls.c ****     (void)oid;
4447:../src/src/tls.c **** 
4448:../src/src/tls.c ****     if (first == CHACHA_BYTE) {
 4843                             		.loc 2 4448 8
 4844 0040 59 A5 30                		movu.B	48[r10], r5
 4845 0043 75 55 CC                		cmp	#0xcc, r5
 4846 0046 21 24                   		bne	.L377
4449:../src/src/tls.c ****         switch (second) {
 4847                             		.loc 2 4449 9
 4848 0048 59 A5 31                		movu.B	49[r10], r5
 4849 004b 75 55 AB                		cmp	#0xab, r5
 4850 004e 2A 0E                   		bgt	.L336
 4851 0050 75 55 AA                		cmp	#0xaa, r5
 4852 0053 28 12                   		bge	.L337
 4853 0055 75 55 15                		cmp	#21, r5
 4854 0058 20 0D                   		beq	.L337
4450:../src/src/tls.c ****             case TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
4451:../src/src/tls.c ****             case TLS_PSK_WITH_CHACHA20_POLY1305_SHA256:
4452:../src/src/tls.c ****             case TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256:
4453:../src/src/tls.c ****             case TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256:
4454:../src/src/tls.c ****                 return 1; /* no suite restriction */
4455:../src/src/tls.c ****             case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
4456:../src/src/tls.c ****             case TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256:
4457:../src/src/tls.c ****             case TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256:
4458:../src/src/tls.c ****                 break;
 4855                             		.loc 2 4458 17
 4856 005a 2E 13                   		bra	.L378
 4857                             	.L336:
4449:../src/src/tls.c ****         switch (second) {
 4858                             		.loc 2 4449 9
 4859 005c 75 55 AC                		cmp	#0xac, r5
 4860 005f 20 0E                   		beq	.L378
 4861 0061 75 55 AD                		cmp	#0xad, r5
 4862 0064 1A                      		bne	.L335
 4863                             	.L337:
4454:../src/src/tls.c ****             case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
 4864                             		.loc 2 4454 24
 4865 0065 66 15                   		mov.L	#1, r5
 4866 0067 38 DD 02                		bra	.L339
 4867                             	.L377:
4459:../src/src/tls.c ****         }
4460:../src/src/tls.c ****     }
 4868                             		.loc 2 4460 5
 4869 006a 03                      		nop
 4870 006b 2E 03                   		bra	.L335
 4871                             	.L378:
4458:../src/src/tls.c ****         }
 4872                             		.loc 2 4458 17
 4873 006d 03                      		nop
 4874                             	.L335:
4461:../src/src/tls.c ****     if (first == ECC_BYTE || first == ECDHE_PSK_BYTE || first == CHACHA_BYTE)
 4875                             		.loc 2 4461 8
 4876 006e 59 A5 30                		movu.B	48[r10], r5
 4877 0071 75 55 C0                		cmp	#0xc0, r5
 4878 0074 20 11                   		beq	.L340
 4879                             		.loc 2 4461 27 discriminator 1
 4880 0076 59 A5 30                		movu.B	48[r10], r5
 4881 0079 75 55 D0                		cmp	#0xd0, r5
 4882 007c 11                      		beq	.L340
 4883                             		.loc 2 4461 54 discriminator 2
 4884 007d 59 A5 30                		movu.B	48[r10], r5
 4885 0080 75 55 CC                		cmp	#0xcc, r5
 4886 0083 21 12                   		bne	.L341
 4887                             	.L340:
4462:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS);
 4888                             		.loc 2 4462 21
 4889 0085 ED A5 0B                		mov.L	44[r10], r5
 4890 0088 ED 55 BF                		mov.L	764[r5], r5
 4891 008b 66 A2                   		mov.L	#10, r2
 4892 008d EF 51                   		mov.L	r5, r1
 4893 008f 05 00 00 00             		bsr	_TLSX_Find
 4894 0093 E3 A1                   		mov.L	r1, [r10]
 4895                             	.L341:
4463:../src/src/tls.c ****     if (!extension)
 4896                             		.loc 2 4463 8
 4897 0095 EC A5                   		mov.L	[r10], r5
 4898 0097 61 05                   		cmp	#0, r5
 4899 0099 1E                      		bne	.L342
4464:../src/src/tls.c ****         return 1; /* no suite restriction */
 4900                             		.loc 2 4464 16
 4901 009a 66 15                   		mov.L	#1, r5
 4902 009c 38 A8 02                		bra	.L339
 4903                             	.L342:
4465:../src/src/tls.c **** 
4466:../src/src/tls.c ****     for (curve = (SupportedCurve*)extension->data;
 4904                             		.loc 2 4466 16
 4905 009f EC A5                   		mov.L	[r10], r5
 4906 00a1 A8 5D                   		mov.L	4[r5], r5
 4907 00a3 E7 A5 01                		mov.L	r5, 4[r10]
 4908                             		.loc 2 4466 5
 4909 00a6 38 0D 02                		bra	.L343
 4910                             	.L371:
4467:../src/src/tls.c ****          curve && !key;
4468:../src/src/tls.c ****          curve = curve->next) {
4469:../src/src/tls.c **** 
4470:../src/src/tls.c ****     #ifdef OPENSSL_EXTRA
4471:../src/src/tls.c ****         /* skip if name is not in supported ECC range */
4472:../src/src/tls.c ****         if (curve->name > WOLFSSL_ECC_X448)
4473:../src/src/tls.c ****             continue;
4474:../src/src/tls.c ****         /* skip if curve is disabled by user */
4475:../src/src/tls.c ****         if (ssl->ctx->disabledCurves & (1 << curve->name))
4476:../src/src/tls.c ****             continue;
4477:../src/src/tls.c ****     #endif
4478:../src/src/tls.c **** 
4479:../src/src/tls.c ****         /* find supported curve */
4480:../src/src/tls.c ****         switch (curve->name) {
 4911                             		.loc 2 4480 22
 4912 00a9 ED A5 01                		mov.L	4[r10], r5
 4913 00ac DC 55                   		mov.W	[r5], r5
 4914 00ae 5F 55                   		movu.W	r5, r5
 4915                             		.loc 2 4480 9
 4916 00b0 75 55 18                		cmp	#24, r5
 4917 00b3 20 42                   		beq	.L344
 4918 00b5 75 55 18                		cmp	#24, r5
 4919 00b8 2A 0F                   		bgt	.L345
 4920 00ba 75 55 15                		cmp	#21, r5
 4921 00bd 20 17                   		beq	.L346
 4922 00bf 75 55 17                		cmp	#23, r5
 4923 00c2 20 1D                   		beq	.L347
4481:../src/src/tls.c **** #ifdef HAVE_ECC
4482:../src/src/tls.c ****     #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 160
4483:../src/src/tls.c ****         #ifndef NO_ECC_SECP
4484:../src/src/tls.c ****             case WOLFSSL_ECC_SECP160R1:
4485:../src/src/tls.c ****                 oid = ECC_SECP160R1_OID;
4486:../src/src/tls.c ****                 octets = 20;
4487:../src/src/tls.c ****                 break;
4488:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
4489:../src/src/tls.c ****         #ifdef HAVE_ECC_SECPR2
4490:../src/src/tls.c ****             case WOLFSSL_ECC_SECP160R2:
4491:../src/src/tls.c ****                 oid = ECC_SECP160R2_OID;
4492:../src/src/tls.c ****                 octets = 20;
4493:../src/src/tls.c ****                 break;
4494:../src/src/tls.c ****         #endif /* HAVE_ECC_SECPR2 */
4495:../src/src/tls.c ****         #ifdef HAVE_ECC_KOBLITZ
4496:../src/src/tls.c ****             case WOLFSSL_ECC_SECP160K1:
4497:../src/src/tls.c ****                 oid = ECC_SECP160K1_OID;
4498:../src/src/tls.c ****                 octets = 20;
4499:../src/src/tls.c ****                 break;
4500:../src/src/tls.c ****         #endif /* HAVE_ECC_KOBLITZ */
4501:../src/src/tls.c ****         #endif
4502:../src/src/tls.c ****     #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 192
4503:../src/src/tls.c ****         #ifndef NO_ECC_SECP
4504:../src/src/tls.c ****             case WOLFSSL_ECC_SECP192R1:
4505:../src/src/tls.c ****                 oid = ECC_SECP192R1_OID;
4506:../src/src/tls.c ****                 octets = 24;
4507:../src/src/tls.c ****                 break;
4508:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
4509:../src/src/tls.c ****         #ifdef HAVE_ECC_KOBLITZ
4510:../src/src/tls.c ****             case WOLFSSL_ECC_SECP192K1:
4511:../src/src/tls.c ****                 oid = ECC_SECP192K1_OID;
4512:../src/src/tls.c ****                 octets = 24;
4513:../src/src/tls.c ****                 break;
4514:../src/src/tls.c ****         #endif /* HAVE_ECC_KOBLITZ */
4515:../src/src/tls.c ****     #endif
4516:../src/src/tls.c ****     #if (defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 224
4517:../src/src/tls.c ****         #ifndef NO_ECC_SECP
4518:../src/src/tls.c ****             case WOLFSSL_ECC_SECP224R1:
4519:../src/src/tls.c ****                 oid = ECC_SECP224R1_OID;
4520:../src/src/tls.c ****                 octets = 28;
4521:../src/src/tls.c ****                 break;
4522:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
4523:../src/src/tls.c ****         #ifdef HAVE_ECC_KOBLITZ
4524:../src/src/tls.c ****             case WOLFSSL_ECC_SECP224K1:
4525:../src/src/tls.c ****                 oid = ECC_SECP224K1_OID;
4526:../src/src/tls.c ****                 octets = 28;
4527:../src/src/tls.c ****                 break;
4528:../src/src/tls.c ****         #endif /* HAVE_ECC_KOBLITZ */
4529:../src/src/tls.c ****     #endif
4530:../src/src/tls.c ****     #if (!defined(NO_ECC256) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
4531:../src/src/tls.c ****         #ifndef NO_ECC_SECP
4532:../src/src/tls.c ****             case WOLFSSL_ECC_SECP256R1:
4533:../src/src/tls.c ****                 oid = ECC_SECP256R1_OID;
4534:../src/src/tls.c ****                 octets = 32;
4535:../src/src/tls.c ****                 break;
4536:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
4537:../src/src/tls.c ****     #endif /* !NO_ECC256 || HAVE_ALL_CURVES */
4538:../src/src/tls.c **** #endif
4539:../src/src/tls.c ****         #if (defined(HAVE_CURVE25519) || defined(HAVE_ED25519)) && ECC_MIN_KEY_SZ <= 256
4540:../src/src/tls.c ****             case WOLFSSL_ECC_X25519:
4541:../src/src/tls.c ****                 oid = ECC_X25519_OID;
4542:../src/src/tls.c ****                 octets = 32;
4543:../src/src/tls.c ****                 break;
4544:../src/src/tls.c ****         #endif /* HAVE_CURVE25519 */
4545:../src/src/tls.c **** #ifdef HAVE_ECC
4546:../src/src/tls.c ****     #if (!defined(NO_ECC256) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
4547:../src/src/tls.c ****         #ifdef HAVE_ECC_KOBLITZ
4548:../src/src/tls.c ****             case WOLFSSL_ECC_SECP256K1:
4549:../src/src/tls.c ****                 oid = ECC_SECP256K1_OID;
4550:../src/src/tls.c ****                 octets = 32;
4551:../src/src/tls.c ****                 break;
4552:../src/src/tls.c ****         #endif /* HAVE_ECC_KOBLITZ */
4553:../src/src/tls.c ****         #ifdef HAVE_ECC_BRAINPOOL
4554:../src/src/tls.c ****             case WOLFSSL_ECC_BRAINPOOLP256R1:
4555:../src/src/tls.c ****                 oid = ECC_BRAINPOOLP256R1_OID;
4556:../src/src/tls.c ****                 octets = 32;
4557:../src/src/tls.c ****                 break;
4558:../src/src/tls.c ****         #endif /* HAVE_ECC_BRAINPOOL */
4559:../src/src/tls.c ****     #endif
4560:../src/src/tls.c ****     #if (defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 384
4561:../src/src/tls.c ****         #ifndef NO_ECC_SECP
4562:../src/src/tls.c ****             case WOLFSSL_ECC_SECP384R1:
4563:../src/src/tls.c ****                 oid = ECC_SECP384R1_OID;
4564:../src/src/tls.c ****                 octets = 48;
4565:../src/src/tls.c ****                 break;
4566:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
4567:../src/src/tls.c ****         #ifdef HAVE_ECC_BRAINPOOL
4568:../src/src/tls.c ****             case WOLFSSL_ECC_BRAINPOOLP384R1:
4569:../src/src/tls.c ****                 oid = ECC_BRAINPOOLP384R1_OID;
4570:../src/src/tls.c ****                 octets = 48;
4571:../src/src/tls.c ****                 break;
4572:../src/src/tls.c ****         #endif /* HAVE_ECC_BRAINPOOL */
4573:../src/src/tls.c ****     #endif
4574:../src/src/tls.c **** #endif
4575:../src/src/tls.c ****         #if (defined(HAVE_CURVE448) || defined(HAVE_ED448)) && ECC_MIN_KEY_SZ <= 448
4576:../src/src/tls.c ****             case WOLFSSL_ECC_X448:
4577:../src/src/tls.c ****                 oid = ECC_X448_OID;
4578:../src/src/tls.c ****                 octets = 57;
4579:../src/src/tls.c ****                 break;
4580:../src/src/tls.c ****         #endif /* HAVE_CURVE448 */
4581:../src/src/tls.c **** #ifdef HAVE_ECC
4582:../src/src/tls.c ****     #if (defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 512
4583:../src/src/tls.c ****         #ifdef HAVE_ECC_BRAINPOOL
4584:../src/src/tls.c ****             case WOLFSSL_ECC_BRAINPOOLP512R1:
4585:../src/src/tls.c ****                 oid = ECC_BRAINPOOLP512R1_OID;
4586:../src/src/tls.c ****                 octets = 64;
4587:../src/src/tls.c ****                 break;
4588:../src/src/tls.c ****         #endif /* HAVE_ECC_BRAINPOOL */
4589:../src/src/tls.c ****     #endif
4590:../src/src/tls.c ****     #if (defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 521
4591:../src/src/tls.c ****         #ifndef NO_ECC_SECP
4592:../src/src/tls.c ****             case WOLFSSL_ECC_SECP521R1:
4593:../src/src/tls.c ****                 oid = ECC_SECP521R1_OID;
4594:../src/src/tls.c ****                 octets = 66;
4595:../src/src/tls.c ****                 break;
4596:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
4597:../src/src/tls.c ****     #endif
4598:../src/src/tls.c **** #endif
4599:../src/src/tls.c ****             default: continue; /* unsupported curve */
 4924                             		.loc 2 4599 13
 4925 00c4 38 E7 01                		bra	.L352
 4926                             	.L345:
4480:../src/src/tls.c **** #ifdef HAVE_ECC
 4927                             		.loc 2 4480 9
 4928 00c7 75 55 19                		cmp	#25, r5
 4929 00ca 20 36                   		beq	.L349
 4930 00cc 75 55 1D                		cmp	#29, r5
 4931 00cf 20 1B                   		beq	.L350
 4932                             		.loc 2 4599 13
 4933 00d1 38 DA 01                		bra	.L352
 4934                             	.L346:
4519:../src/src/tls.c ****                 octets = 28;
 4935                             		.loc 2 4519 21
 4936 00d4 F9 AA 02 D1 00          		mov.L	#0xd1, 8[r10]
4520:../src/src/tls.c ****                 break;
 4937                             		.loc 2 4520 24
 4938 00d9 F9 A5 12 1C             		mov.W	#28, 36[r10]
4521:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
 4939                             		.loc 2 4521 17
 4940 00dd 2E 2D                   		bra	.L351
 4941                             	.L347:
4533:../src/src/tls.c ****                 octets = 32;
 4942                             		.loc 2 4533 21
 4943 00df F9 AA 02 0E 02          		mov.L	#0x20e, 8[r10]
4534:../src/src/tls.c ****                 break;
 4944                             		.loc 2 4534 24
 4945 00e4 F9 A5 12 20             		mov.W	#32, 36[r10]
4535:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
 4946                             		.loc 2 4535 17
 4947 00e8 2E 22                   		bra	.L351
 4948                             	.L350:
4541:../src/src/tls.c ****                 octets = 32;
 4949                             		.loc 2 4541 21
 4950 00ea F9 AA 02 6D 01          		mov.L	#0x16d, 8[r10]
4542:../src/src/tls.c ****                 break;
 4951                             		.loc 2 4542 24
 4952 00ef F9 A5 12 20             		mov.W	#32, 36[r10]
4543:../src/src/tls.c ****         #endif /* HAVE_CURVE25519 */
 4953                             		.loc 2 4543 17
 4954 00f3 2E 17                   		bra	.L351
 4955                             	.L344:
4563:../src/src/tls.c ****                 octets = 48;
 4956                             		.loc 2 4563 21
 4957 00f5 F9 AA 02 D2 00          		mov.L	#0xd2, 8[r10]
4564:../src/src/tls.c ****                 break;
 4958                             		.loc 2 4564 24
 4959 00fa F9 A5 12 30             		mov.W	#48, 36[r10]
4565:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
 4960                             		.loc 2 4565 17
 4961 00fe 2E 0C                   		bra	.L351
 4962                             	.L349:
4593:../src/src/tls.c ****                 octets = 66;
 4963                             		.loc 2 4593 21
 4964 0100 F9 AA 02 D3 00          		mov.L	#0xd3, 8[r10]
4594:../src/src/tls.c ****                 break;
 4965                             		.loc 2 4594 24
 4966 0105 F9 A5 12 42             		mov.W	#0x42, 36[r10]
4595:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
 4967                             		.loc 2 4595 17
 4968 0109 03                      		nop
 4969                             		.balign 8,3,1
 4970                             	.L351:
4600:../src/src/tls.c ****         }
4601:../src/src/tls.c **** 
4602:../src/src/tls.c ****     #ifdef HAVE_ECC
4603:../src/src/tls.c ****         /* Set default Oid */
4604:../src/src/tls.c ****         if (defOid == 0 && ssl->eccTempKeySz <= octets && defSz > octets) {
 4971                             		.loc 2 4604 12
 4972 010a ED A5 03                		mov.L	12[r10], r5
 4973 010d 61 05                   		cmp	#0, r5
 4974 010f 21 29                   		bne	.L353
 4975                             		.loc 2 4604 31 discriminator 1
 4976 0111 ED A5 0B                		mov.L	44[r10], r5
 4977 0114 DE 55 70 01             		mov.W	736[r5], r5
 4978                             		.loc 2 4604 25 discriminator 1
 4979 0118 5D A4 12                		movu.W	36[r10], r4
 4980 011b 5F 55                   		movu.W	r5, r5
 4981 011d 47 54                   		cmp	r5, r4
 4982 011f 23 19                   		bltu	.L353
 4983                             		.loc 2 4604 65 discriminator 2
 4984 0121 5D A5 12                		movu.W	36[r10], r5
 4985                             		.loc 2 4604 56 discriminator 2
 4986 0124 ED A4 04                		mov.L	16[r10], r4
 4987 0127 47 54                   		cmp	r5, r4
 4988 0129 25 0F                   		bleu	.L353
4605:../src/src/tls.c ****             defOid = oid;
 4989                             		.loc 2 4605 20
 4990 012b ED A5 02                		mov.L	8[r10], r5
 4991 012e E7 A5 03                		mov.L	r5, 12[r10]
4606:../src/src/tls.c ****             defSz = octets;
 4992                             		.loc 2 4606 19
 4993 0131 5D A5 12                		movu.W	36[r10], r5
 4994 0134 E7 A5 04                		mov.L	r5, 16[r10]
 4995 0137 03                      		.balign 8,3,1
 4996                             	.L353:
4607:../src/src/tls.c ****         }
4608:../src/src/tls.c **** 
4609:../src/src/tls.c ****         /* The eccTempKeySz is the preferred ephemeral key size */
4610:../src/src/tls.c ****         if (currOid == 0 && ssl->eccTempKeySz == octets)
 4997                             		.loc 2 4610 12
 4998 0138 ED A5 07                		mov.L	28[r10], r5
 4999 013b 61 05                   		cmp	#0, r5
 5000 013d 21 17                   		bne	.L354
 5001                             		.loc 2 4610 32 discriminator 1
 5002 013f ED A5 0B                		mov.L	44[r10], r5
 5003 0142 DE 55 70 01             		mov.W	736[r5], r5
 5004                             		.loc 2 4610 26 discriminator 1
 5005 0146 5D A4 12                		movu.W	36[r10], r4
 5006 0149 5F 55                   		movu.W	r5, r5
 5007 014b 47 54                   		cmp	r5, r4
 5008 014d 1F                      		bne	.L354
4611:../src/src/tls.c ****             currOid = oid;
 5009                             		.loc 2 4611 21
 5010 014e ED A5 02                		mov.L	8[r10], r5
 5011 0151 E7 A5 07                		mov.L	r5, 28[r10]
 5012                             	.L354:
4612:../src/src/tls.c ****         if ((nextOid == 0 || nextSz > octets) && ssl->eccTempKeySz <= octets) {
 5013                             		.loc 2 4612 12
 5014 0154 ED A5 05                		mov.L	20[r10], r5
 5015 0157 61 05                   		cmp	#0, r5
 5016 0159 20 0C                   		beq	.L355
 5017                             		.loc 2 4612 37 discriminator 2
 5018 015b 5D A5 12                		movu.W	36[r10], r5
 5019                             		.loc 2 4612 27 discriminator 2
 5020 015e ED A4 06                		mov.L	24[r10], r4
 5021 0161 47 54                   		cmp	r5, r4
 5022 0163 25 1E                   		bleu	.L356
 5023                             	.L355:
 5024                             		.loc 2 4612 53 discriminator 3
 5025 0165 ED A5 0B                		mov.L	44[r10], r5
 5026 0168 DE 55 70 01             		mov.W	736[r5], r5
 5027                             		.loc 2 4612 47 discriminator 3
 5028 016c 5D A4 12                		movu.W	36[r10], r4
 5029 016f 5F 55                   		movu.W	r5, r5
 5030 0171 47 54                   		cmp	r5, r4
 5031 0173 23 0E                   		bltu	.L356
4613:../src/src/tls.c ****             nextOid = oid;
 5032                             		.loc 2 4613 21
 5033 0175 ED A5 02                		mov.L	8[r10], r5
 5034 0178 E7 A5 05                		mov.L	r5, 20[r10]
4614:../src/src/tls.c ****             nextSz  = octets;
 5035                             		.loc 2 4614 21
 5036 017b 5D A5 12                		movu.W	36[r10], r5
 5037 017e E7 A5 06                		mov.L	r5, 24[r10]
 5038                             	.L356:
4615:../src/src/tls.c ****         }
4616:../src/src/tls.c ****     #else
4617:../src/src/tls.c ****         if (defOid == 0 && defSz > octets) {
4618:../src/src/tls.c ****             defOid = oid;
4619:../src/src/tls.c ****             defSz = octets;
4620:../src/src/tls.c ****         }
4621:../src/src/tls.c **** 
4622:../src/src/tls.c ****         if (currOid == 0)
4623:../src/src/tls.c ****             currOid = oid;
4624:../src/src/tls.c ****         if (nextOid == 0 || nextSz > octets) {
4625:../src/src/tls.c ****             nextOid = oid;
4626:../src/src/tls.c ****             nextSz  = octets;
4627:../src/src/tls.c ****         }
4628:../src/src/tls.c ****     #endif
4629:../src/src/tls.c **** 
4630:../src/src/tls.c ****         if (first == ECC_BYTE) {
 5039                             		.loc 2 4630 12
 5040 0181 59 A5 30                		movu.B	48[r10], r5
 5041 0184 75 55 C0                		cmp	#0xc0, r5
 5042 0187 3B BB 00                		bne	.L379
4631:../src/src/tls.c ****             switch (second) {
 5043                             		.loc 2 4631 13
 5044 018a 59 A5 31                		movu.B	49[r10], r5
 5045 018d 75 55 28                		cmp	#40, r5
 5046 0190 2A 22                   		bgt	.L358
 5047 0192 75 55 27                		cmp	#39, r5
 5048 0195 28 55                   		bge	.L359
 5049 0197 75 55 14                		cmp	#20, r5
 5050 019a 2A 0F                   		bgt	.L360
 5051 019c 75 55 11                		cmp	#17, r5
 5052 019f 28 4B                   		bge	.L359
 5053 01a1 60 75                   		sub	#7, r5
 5054 01a3 61 35                   		cmp	#3, r5
 5055 01a5 24 63                   		bgtu	.L361
 5056 01a7 2E 25                   		bra	.L362
 5057                             	.L360:
 5058 01a9 71 55 DD                		add	#-35, r5
 5059 01ac 61 15                   		cmp	#1, r5
 5060 01ae 24 5A                   		bgtu	.L361
 5061 01b0 2E 1C                   		bra	.L362
 5062                             	.L358:
 5063 01b2 75 55 30                		cmp	#48, r5
 5064 01b5 2A 0F                   		bgt	.L363
 5065 01b7 75 55 2F                		cmp	#47, r5
 5066 01ba 28 30                   		bge	.L359
 5067 01bc 71 55 D5                		add	#-43, r5
 5068 01bf 61 15                   		cmp	#1, r5
 5069 01c1 24 47                   		bgtu	.L361
 5070 01c3 09                      		bra	.L362
 5071                             	.L363:
 5072 01c4 72 55 52 FF             		add	#-174, r5
 5073 01c8 61 15                   		cmp	#1, r5
 5074 01ca 24 3E                   		bgtu	.L361
 5075                             		.balign 8,3,1
 5076                             	.L362:
4632:../src/src/tls.c **** #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
4633:../src/src/tls.c ****                 /* ECDHE_ECDSA */
4634:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
4635:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
4636:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:
4637:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
4638:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:
4639:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:
4640:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
4641:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:
4642:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:
4643:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8:
4644:../src/src/tls.c ****                     key |= ssl->ecdhCurveOID == oid;
 5077                             		.loc 2 4644 31
 5078 01cc ED A5 0B                		mov.L	44[r10], r5
 5079 01cf ED 55 B3                		mov.L	716[r5], r5
 5080                             		.loc 2 4644 46
 5081 01d2 ED A4 02                		mov.L	8[r10], r4
 5082 01d5 47 54                   		cmp	r5, r4
 5083 01d7 FC DB 50                		sceq.L	r5
 5084 01da 5B 55                   		movu.B	r5, r5
 5085                             		.loc 2 4644 25
 5086 01dc ED A4 0A                		mov.L	40[r10], r4
 5087 01df 57 45                   		or	r4, r5
 5088 01e1 E7 A5 0A                		mov.L	r5, 40[r10]
4645:../src/src/tls.c ****                     ephmSuite = 1;
 5089                             		.loc 2 4645 31
 5090 01e4 F9 A6 08 01             		mov.L	#1, 32[r10]
4646:../src/src/tls.c ****                 break;
 5091                             		.loc 2 4646 17
 5092 01e8 2E 5B                   		bra	.L357
 5093                             	.L359:
4647:../src/src/tls.c **** 
4648:../src/src/tls.c ****     #ifdef WOLFSSL_STATIC_DH
4649:../src/src/tls.c ****                 /* ECDH_ECDSA */
4650:../src/src/tls.c ****                 case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
4651:../src/src/tls.c ****                 case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
4652:../src/src/tls.c ****                 case TLS_ECDH_ECDSA_WITH_RC4_128_SHA:
4653:../src/src/tls.c ****                 case TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
4654:../src/src/tls.c ****                 case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256:
4655:../src/src/tls.c ****                 case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384:
4656:../src/src/tls.c ****                 case TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256:
4657:../src/src/tls.c ****                 case TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384:
4658:../src/src/tls.c ****                     if (oid == ECC_X25519_OID && defOid == oid) {
4659:../src/src/tls.c ****                         defOid = 0;
4660:../src/src/tls.c ****                         defSz = 80;
4661:../src/src/tls.c ****                     }
4662:../src/src/tls.c ****                     if (oid == ECC_X448_OID && defOid == oid) {
4663:../src/src/tls.c ****                         defOid = 0;
4664:../src/src/tls.c ****                         defSz = 80;
4665:../src/src/tls.c ****                     }
4666:../src/src/tls.c ****                     key |= ssl->pkCurveOID == oid;
4667:../src/src/tls.c ****                 break;
4668:../src/src/tls.c ****     #endif /* WOLFSSL_STATIC_DH */
4669:../src/src/tls.c **** #endif /* HAVE_ECC || HAVE_ED25519 || HAVE_ED448 */
4670:../src/src/tls.c **** #ifndef NO_RSA
4671:../src/src/tls.c ****                 /* ECDHE_RSA */
4672:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
4673:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
4674:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_RC4_128_SHA:
4675:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
4676:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:
4677:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:
4678:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
4679:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
4680:../src/src/tls.c ****                     key |= ssl->ecdhCurveOID == oid;
 5094                             		.loc 2 4680 31
 5095 01ea ED A5 0B                		mov.L	44[r10], r5
 5096 01ed ED 55 B3                		mov.L	716[r5], r5
 5097                             		.loc 2 4680 46
 5098 01f0 ED A4 02                		mov.L	8[r10], r4
 5099 01f3 47 54                   		cmp	r5, r4
 5100 01f5 FC DB 50                		sceq.L	r5
 5101 01f8 5B 55                   		movu.B	r5, r5
 5102                             		.loc 2 4680 25
 5103 01fa ED A4 0A                		mov.L	40[r10], r4
 5104 01fd 57 45                   		or	r4, r5
 5105 01ff E7 A5 0A                		mov.L	r5, 40[r10]
4681:../src/src/tls.c ****                     ephmSuite = 1;
 5106                             		.loc 2 4681 31
 5107 0202 F9 A6 08 01             		mov.L	#1, 32[r10]
4682:../src/src/tls.c ****                 break;
 5108                             		.loc 2 4682 17
 5109 0206 2E 3D                   		bra	.L357
 5110                             	.L361:
4683:../src/src/tls.c **** 
4684:../src/src/tls.c ****     #if defined(HAVE_ECC) && defined(WOLFSSL_STATIC_DH)
4685:../src/src/tls.c ****                 /* ECDH_RSA */
4686:../src/src/tls.c ****                 case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
4687:../src/src/tls.c ****                 case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
4688:../src/src/tls.c ****                 case TLS_ECDH_RSA_WITH_RC4_128_SHA:
4689:../src/src/tls.c ****                 case TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
4690:../src/src/tls.c ****                 case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256:
4691:../src/src/tls.c ****                 case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384:
4692:../src/src/tls.c ****                 case TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256:
4693:../src/src/tls.c ****                 case TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384:
4694:../src/src/tls.c ****                     if (oid == ECC_X25519_OID && defOid == oid) {
4695:../src/src/tls.c ****                         defOid = 0;
4696:../src/src/tls.c ****                         defSz = 80;
4697:../src/src/tls.c ****                     }
4698:../src/src/tls.c ****                     if (oid == ECC_X448_OID && defOid == oid) {
4699:../src/src/tls.c ****                         defOid = 0;
4700:../src/src/tls.c ****                         defSz = 80;
4701:../src/src/tls.c ****                     }
4702:../src/src/tls.c ****                     key |= ssl->pkCurveOID == oid;
4703:../src/src/tls.c ****                 break;
4704:../src/src/tls.c ****     #endif /* HAVE_ECC && WOLFSSL_STATIC_DH */
4705:../src/src/tls.c **** #endif
4706:../src/src/tls.c ****                 default:
4707:../src/src/tls.c ****                     if (oid == ECC_X25519_OID && defOid == oid) {
 5111                             		.loc 2 4707 24
 5112 0208 ED A5 02                		mov.L	8[r10], r5
 5113 020b 76 05 6D 01             		cmp	#0x16d, r5
 5114 020f 21 13                   		bne	.L364
 5115                             		.loc 2 4707 47 discriminator 1
 5116 0211 ED A4 03                		mov.L	12[r10], r4
 5117 0214 ED A5 02                		mov.L	8[r10], r5
 5118 0217 47 54                   		cmp	r5, r4
 5119 0219 19                      		bne	.L364
4708:../src/src/tls.c ****                         defOid = 0;
 5120                             		.loc 2 4708 32
 5121 021a F9 A6 03 00             		mov.L	#0, 12[r10]
4709:../src/src/tls.c ****                         defSz = 80;
 5122                             		.loc 2 4709 31
 5123 021e F9 A6 04 50             		mov.L	#0x50, 16[r10]
 5124                             	.L364:
4710:../src/src/tls.c ****                     }
4711:../src/src/tls.c ****                     if (oid == ECC_X448_OID && defOid == oid) {
 5125                             		.loc 2 4711 24
 5126 0222 ED A5 02                		mov.L	8[r10], r5
 5127 0225 76 05 6A 01             		cmp	#0x16a, r5
 5128 0229 21 13                   		bne	.L365
 5129                             		.loc 2 4711 45 discriminator 1
 5130 022b ED A4 03                		mov.L	12[r10], r4
 5131 022e ED A5 02                		mov.L	8[r10], r5
 5132 0231 47 54                   		cmp	r5, r4
 5133 0233 19                      		bne	.L365
4712:../src/src/tls.c ****                         defOid = 0;
 5134                             		.loc 2 4712 32
 5135 0234 F9 A6 03 00             		mov.L	#0, 12[r10]
4713:../src/src/tls.c ****                         defSz = 80;
 5136                             		.loc 2 4713 31
 5137 0238 F9 A6 04 50             		mov.L	#0x50, 16[r10]
 5138                             	.L365:
4714:../src/src/tls.c ****                     }
4715:../src/src/tls.c ****                     key = 1;
 5139                             		.loc 2 4715 25
 5140 023c F9 A6 0A 01             		mov.L	#1, 40[r10]
4716:../src/src/tls.c ****                 break;
 5141                             		.loc 2 4716 17
 5142 0240 2E 03                   		bra	.L357
 5143                             	.L379:
4717:../src/src/tls.c ****             }
4718:../src/src/tls.c ****         }
 5144                             		.loc 2 4718 9
 5145 0242 03                      		nop
 5146                             		.balign 8,3,3
 5147                             	.L357:
4719:../src/src/tls.c **** 
4720:../src/src/tls.c ****         /* ChaCha20-Poly1305 ECC cipher suites */
4721:../src/src/tls.c ****         if (first == CHACHA_BYTE) {
 5148                             		.loc 2 4721 12
 5149 0243 59 A5 30                		movu.B	48[r10], r5
 5150 0246 75 55 CC                		cmp	#0xcc, r5
 5151 0249 21 61                   		bne	.L380
4722:../src/src/tls.c ****             switch (second) {
 5152                             		.loc 2 4722 13
 5153 024b 59 A5 31                		movu.B	49[r10], r5
 5154 024e 75 55 14                		cmp	#20, r5
 5155 0251 20 18                   		beq	.L366
 5156 0253 75 55 14                		cmp	#20, r5
 5157 0256 2A 09                   		bgt	.L367
 5158 0258 75 55 13                		cmp	#19, r5
 5159 025b 20 2C                   		beq	.L368
 5160 025d 2E 47                   		bra	.L369
 5161                             	.L367:
 5162 025f 75 55 A8                		cmp	#0xa8, r5
 5163 0262 20 25                   		beq	.L368
 5164 0264 75 55 A9                		cmp	#0xa9, r5
 5165 0267 21 3D                   		bne	.L369
 5166                             	.L366:
4723:../src/src/tls.c **** #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
4724:../src/src/tls.c ****                 /* ECDHE_ECDSA */
4725:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 :
4726:../src/src/tls.c ****                 case TLS_ECDHE_ECDSA_WITH_CHACHA20_OLD_POLY1305_SHA256 :
4727:../src/src/tls.c ****                     key |= ssl->ecdhCurveOID == oid;
 5167                             		.loc 2 4727 31
 5168 0269 ED A5 0B                		mov.L	44[r10], r5
 5169 026c ED 55 B3                		mov.L	716[r5], r5
 5170                             		.loc 2 4727 46
 5171 026f ED A4 02                		mov.L	8[r10], r4
 5172 0272 47 54                   		cmp	r5, r4
 5173 0274 FC DB 50                		sceq.L	r5
 5174 0277 5B 55                   		movu.B	r5, r5
 5175                             		.loc 2 4727 25
 5176 0279 ED A4 0A                		mov.L	40[r10], r4
 5177 027c 57 45                   		or	r4, r5
 5178 027e E7 A5 0A                		mov.L	r5, 40[r10]
4728:../src/src/tls.c ****                     ephmSuite = 1;
 5179                             		.loc 2 4728 31
 5180 0281 F9 A6 08 01             		mov.L	#1, 32[r10]
4729:../src/src/tls.c ****                 break;
 5181                             		.loc 2 4729 17
 5182 0285 2E 26                   		bra	.L352
 5183                             	.L368:
4730:../src/src/tls.c **** #endif /* HAVE_ECC || HAVE_ED25519 || HAVE_ED448 */
4731:../src/src/tls.c **** #ifndef NO_RSA
4732:../src/src/tls.c ****                 /* ECDHE_RSA */
4733:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 :
4734:../src/src/tls.c ****                 case TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256 :
4735:../src/src/tls.c ****                     key |= ssl->ecdhCurveOID == oid;
 5184                             		.loc 2 4735 31
 5185 0287 ED A5 0B                		mov.L	44[r10], r5
 5186 028a ED 55 B3                		mov.L	716[r5], r5
 5187                             		.loc 2 4735 46
 5188 028d ED A4 02                		mov.L	8[r10], r4
 5189 0290 47 54                   		cmp	r5, r4
 5190 0292 FC DB 50                		sceq.L	r5
 5191 0295 5B 55                   		movu.B	r5, r5
 5192                             		.loc 2 4735 25
 5193 0297 ED A4 0A                		mov.L	40[r10], r4
 5194 029a 57 45                   		or	r4, r5
 5195 029c E7 A5 0A                		mov.L	r5, 40[r10]
4736:../src/src/tls.c ****                     ephmSuite = 1;
 5196                             		.loc 2 4736 31
 5197 029f F9 A6 08 01             		mov.L	#1, 32[r10]
4737:../src/src/tls.c ****                 break;
 5198                             		.loc 2 4737 17
 5199 02a3 08                      		bra	.L352
 5200                             	.L369:
4738:../src/src/tls.c **** #endif
4739:../src/src/tls.c ****                 default:
4740:../src/src/tls.c ****                     key = 1;
 5201                             		.loc 2 4740 25
 5202 02a4 F9 A6 0A 01             		mov.L	#1, 40[r10]
4741:../src/src/tls.c ****                 break;
 5203                             		.loc 2 4741 17
 5204 02a8 2E 03                   		bra	.L352
 5205                             	.L380:
4742:../src/src/tls.c ****             }
4743:../src/src/tls.c ****         }
 5206                             		.loc 2 4743 9
 5207 02aa 03                      		nop
 5208                             		.balign 8,3,1
 5209                             	.L352:
4468:../src/src/tls.c **** 
 5210                             		.loc 2 4468 16
 5211 02ab ED A5 01                		mov.L	4[r10], r5
 5212 02ae A8 5D                   		mov.L	4[r5], r5
 5213 02b0 E7 A5 01                		mov.L	r5, 4[r10]
 5214                             	.L343:
4466:../src/src/tls.c ****          curve && !key;
 5215                             		.loc 2 4466 5 discriminator 1
 5216 02b3 ED A5 01                		mov.L	4[r10], r5
 5217 02b6 61 05                   		cmp	#0, r5
 5218 02b8 11                      		beq	.L370
4467:../src/src/tls.c ****          curve = curve->next) {
 5219                             		.loc 2 4467 16
 5220 02b9 ED A5 0A                		mov.L	40[r10], r5
 5221 02bc 61 05                   		cmp	#0, r5
 5222 02be 3A EB FD                		beq	.L371
 5223                             	.L370:
4744:../src/src/tls.c ****     }
4745:../src/src/tls.c **** 
4746:../src/src/tls.c ****     /* Choose the default if it is at the required strength. */
4747:../src/src/tls.c **** #ifdef HAVE_ECC
4748:../src/src/tls.c ****     if (ssl->ecdhCurveOID == 0 && defSz == ssl->eccTempKeySz)
 5224                             		.loc 2 4748 12
 5225 02c1 ED A5 0B                		mov.L	44[r10], r5
 5226 02c4 ED 55 B3                		mov.L	716[r5], r5
 5227                             		.loc 2 4748 8
 5228 02c7 61 05                   		cmp	#0, r5
 5229 02c9 21 1F                   		bne	.L372
 5230                             		.loc 2 4748 47 discriminator 1
 5231 02cb ED A5 0B                		mov.L	44[r10], r5
 5232 02ce DE 55 70 01             		mov.W	736[r5], r5
 5233 02d2 5F 55                   		movu.W	r5, r5
 5234                             		.loc 2 4748 32 discriminator 1
 5235 02d4 ED A4 04                		mov.L	16[r10], r4
 5236 02d7 47 54                   		cmp	r5, r4
 5237 02d9 21 0F                   		bne	.L372
4749:../src/src/tls.c **** #else
4750:../src/src/tls.c ****     if (ssl->ecdhCurveOID == 0)
4751:../src/src/tls.c **** #endif
4752:../src/src/tls.c ****     {
4753:../src/src/tls.c ****         key = 1;
 5238                             		.loc 2 4753 13
 5239 02db F9 A6 0A 01             		mov.L	#1, 40[r10]
4754:../src/src/tls.c ****         ssl->ecdhCurveOID = defOid;
 5240                             		.loc 2 4754 27
 5241 02df ED A5 0B                		mov.L	44[r10], r5
 5242 02e2 ED A4 03                		mov.L	12[r10], r4
 5243 02e5 E7 54 B3                		mov.L	r4, 716[r5]
 5244                             	.L372:
4755:../src/src/tls.c ****     }
4756:../src/src/tls.c ****     /* Choose any curve at the required strength. */
4757:../src/src/tls.c ****     if (ssl->ecdhCurveOID == 0) {
 5245                             		.loc 2 4757 12
 5246 02e8 ED A5 0B                		mov.L	44[r10], r5
 5247 02eb ED 55 B3                		mov.L	716[r5], r5
 5248                             		.loc 2 4757 8
 5249 02ee 61 05                   		cmp	#0, r5
 5250 02f0 21 0F                   		bne	.L373
4758:../src/src/tls.c ****         key = 1;
 5251                             		.loc 2 4758 13
 5252 02f2 F9 A6 0A 01             		mov.L	#1, 40[r10]
4759:../src/src/tls.c ****         ssl->ecdhCurveOID = currOid;
 5253                             		.loc 2 4759 27
 5254 02f6 ED A5 0B                		mov.L	44[r10], r5
 5255 02f9 ED A4 07                		mov.L	28[r10], r4
 5256 02fc E7 54 B3                		mov.L	r4, 716[r5]
 5257                             	.L373:
4760:../src/src/tls.c ****     }
4761:../src/src/tls.c ****     /* Choose the default if it is at the next highest strength. */
4762:../src/src/tls.c ****     if (ssl->ecdhCurveOID == 0 && defSz == nextSz)
 5258                             		.loc 2 4762 12
 5259 02ff ED A5 0B                		mov.L	44[r10], r5
 5260 0302 ED 55 B3                		mov.L	716[r5], r5
 5261                             		.loc 2 4762 8
 5262 0305 61 05                   		cmp	#0, r5
 5263 0307 21 14                   		bne	.L374
 5264                             		.loc 2 4762 32 discriminator 1
 5265 0309 ED A4 04                		mov.L	16[r10], r4
 5266 030c ED A5 06                		mov.L	24[r10], r5
 5267 030f 47 54                   		cmp	r5, r4
 5268 0311 1A                      		bne	.L374
4763:../src/src/tls.c ****         ssl->ecdhCurveOID = defOid;
 5269                             		.loc 2 4763 27
 5270 0312 ED A5 0B                		mov.L	44[r10], r5
 5271 0315 ED A4 03                		mov.L	12[r10], r4
 5272 0318 E7 54 B3                		mov.L	r4, 716[r5]
 5273                             	.L374:
4764:../src/src/tls.c ****     /* Choose any curve at the next highest strength. */
4765:../src/src/tls.c ****     if (ssl->ecdhCurveOID == 0)
 5274                             		.loc 2 4765 12
 5275 031b ED A5 0B                		mov.L	44[r10], r5
 5276 031e ED 55 B3                		mov.L	716[r5], r5
 5277                             		.loc 2 4765 8
 5278 0321 61 05                   		cmp	#0, r5
 5279 0323 1A                      		bne	.L375
4766:../src/src/tls.c ****         ssl->ecdhCurveOID = nextOid;
 5280                             		.loc 2 4766 27
 5281 0324 ED A5 0B                		mov.L	44[r10], r5
 5282 0327 ED A4 05                		mov.L	20[r10], r4
 5283 032a E7 54 B3                		mov.L	r4, 716[r5]
 5284                             	.L375:
4767:../src/src/tls.c ****     /* No curve and ephemeral ECC suite requires a matching curve. */
4768:../src/src/tls.c ****     if (ssl->ecdhCurveOID == 0 && ephmSuite)
 5285                             		.loc 2 4768 12
 5286 032d ED A5 0B                		mov.L	44[r10], r5
 5287 0330 ED 55 B3                		mov.L	716[r5], r5
 5288                             		.loc 2 4768 8
 5289 0333 61 05                   		cmp	#0, r5
 5290 0335 21 0C                   		bne	.L376
 5291                             		.loc 2 4768 32 discriminator 1
 5292 0337 ED A5 08                		mov.L	32[r10], r5
 5293 033a 61 05                   		cmp	#0, r5
 5294 033c 15                      		beq	.L376
4769:../src/src/tls.c ****         key = 0;
 5295                             		.loc 2 4769 13
 5296 033d F9 A6 0A 00             		mov.L	#0, 40[r10]
 5297                             	.L376:
4770:../src/src/tls.c **** 
4771:../src/src/tls.c ****     return key;
 5298                             		.loc 2 4771 12
 5299 0341 ED A5 0A                		mov.L	40[r10], r5
 5300                             	.L339:
4772:../src/src/tls.c **** }
 5301                             		.loc 2 4772 1
 5302 0344 EF 51                   		mov.L	r5, r1
 5303 0346 3F AA 0E                		rtsd	#56, r10-r10
 5304                             	.LFE92:
 5306 0349 FD 70 40 00 00 00 80    		.section	.text.TLSX_UseSupportedCurve,"ax",@progbits
 5307                             		.global	_TLSX_UseSupportedCurve
 5309                             	_TLSX_UseSupportedCurve:
 5310                             	.LFB93:
4773:../src/src/tls.c **** #endif
4774:../src/src/tls.c **** 
4775:../src/src/tls.c **** #endif /* NO_WOLFSSL_SERVER */
4776:../src/src/tls.c **** 
4777:../src/src/tls.c **** int TLSX_UseSupportedCurve(TLSX** extensions, word16 name, void* heap)
4778:../src/src/tls.c **** {
 5311                             		.loc 2 4778 1
 5312 0000 7E AA                   		push.l	r10
 5313                             	.LCFI135:
 5314 0002 71 0A E4                		add	#-28, r0, r10
 5315                             	.LCFI136:
 5316 0005 EF A0                   		mov.L	r10, r0
 5317 0007 E7 A1 04                		mov.L	r1, 16[r10]
 5318 000a D7 A2 0A                		mov.W	r2, 20[r10]
 5319 000d E7 A3 06                		mov.L	r3, 24[r10]
4779:../src/src/tls.c ****     TLSX* extension = NULL;
 5320                             		.loc 2 4779 11
 5321 0010 F8 A6 00                		mov.L	#0, [r10]
4780:../src/src/tls.c ****     SupportedCurve* curve = NULL;
 5322                             		.loc 2 4780 21
 5323 0013 F9 A6 03 00             		mov.L	#0, 12[r10]
4781:../src/src/tls.c ****     int ret;
4782:../src/src/tls.c **** 
4783:../src/src/tls.c ****     if (extensions == NULL) {
 5324                             		.loc 2 4783 8
 5325 0017 ED A5 04                		mov.L	16[r10], r5
 5326 001a 61 05                   		cmp	#0, r5
 5327 001c 18                      		bne	.L382
4784:../src/src/tls.c ****         return BAD_FUNC_ARG;
 5328                             		.loc 2 4784 16
 5329 001d FB 5A 53 FF             		mov.L	#-173, r5
 5330 0021 38 87 00                		bra	.L388
 5331                             	.L382:
4785:../src/src/tls.c ****     }
4786:../src/src/tls.c **** 
4787:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
4788:../src/src/tls.c ****     if (! TLSX_KeyShare_IsSupported(name)) {
4789:../src/src/tls.c ****         return BAD_FUNC_ARG;
4790:../src/src/tls.c ****     }
4791:../src/src/tls.c **** #endif
4792:../src/src/tls.c **** 
4793:../src/src/tls.c ****     extension = TLSX_Find(*extensions, TLSX_SUPPORTED_GROUPS);
 5332                             		.loc 2 4793 17
 5333 0024 ED A5 04                		mov.L	16[r10], r5
 5334 0027 EC 55                   		mov.L	[r5], r5
 5335 0029 66 A2                   		mov.L	#10, r2
 5336 002b EF 51                   		mov.L	r5, r1
 5337 002d 05 00 00 00             		bsr	_TLSX_Find
 5338 0031 E3 A1                   		mov.L	r1, [r10]
4794:../src/src/tls.c **** 
4795:../src/src/tls.c ****     if (!extension) {
 5339                             		.loc 2 4795 8
 5340 0033 EC A5                   		mov.L	[r10], r5
 5341 0035 61 05                   		cmp	#0, r5
 5342 0037 21 52                   		bne	.L384
4796:../src/src/tls.c ****         ret = TLSX_SupportedCurve_New(&curve, name, heap);
 5343                             		.loc 2 4796 15
 5344 0039 71 A5 0C                		add	#12, r10, r5
 5345 003c ED A3 06                		mov.L	24[r10], r3
 5346 003f DD A2 0A                		mov.W	20[r10], r2
 5347 0042 EF 51                   		mov.L	r5, r1
 5348 0044 05 00 00 00             		bsr	_TLSX_SupportedCurve_New
 5349 0048 E7 A1 01                		mov.L	r1, 4[r10]
4797:../src/src/tls.c ****         if (ret != 0)
 5350                             		.loc 2 4797 12
 5351 004b ED A5 01                		mov.L	4[r10], r5
 5352 004e 61 05                   		cmp	#0, r5
 5353 0050 16                      		beq	.L385
4798:../src/src/tls.c ****             return ret;
 5354                             		.loc 2 4798 20
 5355 0051 ED A5 01                		mov.L	4[r10], r5
 5356 0054 2E 54                   		bra	.L388
 5357                             	.L385:
4799:../src/src/tls.c **** 
4800:../src/src/tls.c ****         ret = TLSX_Push(extensions, TLSX_SUPPORTED_GROUPS, curve, heap);
 5358                             		.loc 2 4800 15
 5359 0056 ED A5 03                		mov.L	12[r10], r5
 5360 0059 ED A4 06                		mov.L	24[r10], r4
 5361 005c EF 53                   		mov.L	r5, r3
 5362 005e 66 A2                   		mov.L	#10, r2
 5363 0060 ED A1 04                		mov.L	16[r10], r1
 5364 0063 05 00 00 00             		bsr	_TLSX_Push
 5365 0067 E7 A1 01                		mov.L	r1, 4[r10]
4801:../src/src/tls.c ****         if (ret != 0) {
 5366                             		.loc 2 4801 12
 5367 006a ED A5 01                		mov.L	4[r10], r5
 5368 006d 61 05                   		cmp	#0, r5
 5369 006f 20 37                   		beq	.L386
 5370                             	.LBB16:
4802:../src/src/tls.c ****             XFREE(curve, heap, DYNAMIC_TYPE_TLSX);
 5371                             		.loc 2 4802 13
 5372 0071 ED A5 03                		mov.L	12[r10], r5
 5373 0074 E7 A5 02                		mov.L	r5, 8[r10]
 5374 0077 ED A5 02                		mov.L	8[r10], r5
 5375 007a 61 05                   		cmp	#0, r5
 5376 007c 10                      		beq	.L387
 5377                             		.loc 2 4802 13 is_stmt 0 discriminator 1
 5378 007d ED A1 02                		mov.L	8[r10], r1
 5379 0080 05 00 00 00             		bsr	_wolfSSL_Free
 5380                             	.L387:
 5381                             	.LBE16:
4803:../src/src/tls.c ****             return ret;
 5382                             		.loc 2 4803 20 is_stmt 1
 5383 0084 ED A5 01                		mov.L	4[r10], r5
 5384 0087 2E 21                   		bra	.L388
 5385                             	.L384:
4804:../src/src/tls.c ****         }
4805:../src/src/tls.c ****     }
4806:../src/src/tls.c ****     else {
4807:../src/src/tls.c ****         ret = TLSX_SupportedCurve_Append((SupportedCurve*)extension->data, name,
 5386                             		.loc 2 4807 68
 5387 0089 EC A5                   		mov.L	[r10], r5
 5388 008b A8 5D                   		mov.L	4[r5], r5
 5389                             		.loc 2 4807 15
 5390 008d ED A3 06                		mov.L	24[r10], r3
 5391 0090 DD A2 0A                		mov.W	20[r10], r2
 5392 0093 EF 51                   		mov.L	r5, r1
 5393 0095 05 00 00 00             		bsr	_TLSX_SupportedCurve_Append
 5394 0099 E7 A1 01                		mov.L	r1, 4[r10]
4808:../src/src/tls.c ****                                                                           heap);
4809:../src/src/tls.c ****         if (ret != 0)
 5395                             		.loc 2 4809 12
 5396 009c ED A5 01                		mov.L	4[r10], r5
 5397 009f 61 05                   		cmp	#0, r5
 5398 00a1 15                      		beq	.L386
4810:../src/src/tls.c ****             return ret;
 5399                             		.loc 2 4810 20
 5400 00a2 ED A5 01                		mov.L	4[r10], r5
 5401 00a5 0B                      		bra	.L388
 5402                             	.L386:
4811:../src/src/tls.c ****     }
4812:../src/src/tls.c **** 
4813:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
 5403                             		.loc 2 4813 12
 5404 00a6 66 15                   		mov.L	#1, r5
 5405                             		.balign 8,3,1
 5406                             	.L388:
4814:../src/src/tls.c **** }
 5407                             		.loc 2 4814 1 discriminator 1
 5408 00a8 EF 51                   		mov.L	r5, r1
 5409 00aa 3F AA 08                		rtsd	#32, r10-r10
 5410                             	.LFE93:
 5412 00ad FC 13 00                		.section	.text.TLSX_UsePointFormat,"ax",@progbits
 5413                             		.global	_TLSX_UsePointFormat
 5415                             	_TLSX_UsePointFormat:
 5416                             	.LFB94:
4815:../src/src/tls.c **** 
4816:../src/src/tls.c **** int TLSX_UsePointFormat(TLSX** extensions, byte format, void* heap)
4817:../src/src/tls.c **** {
 5417                             		.loc 2 4817 1
 5418 0000 7E AA                   		push.l	r10
 5419                             	.LCFI137:
 5420 0002 71 0A E4                		add	#-28, r0, r10
 5421                             	.LCFI138:
 5422 0005 EF A0                   		mov.L	r10, r0
 5423 0007 E7 A1 04                		mov.L	r1, 16[r10]
 5424 000a C7 A2 14                		mov.B	r2, 20[r10]
 5425 000d E7 A3 06                		mov.L	r3, 24[r10]
4818:../src/src/tls.c ****     TLSX* extension = NULL;
 5426                             		.loc 2 4818 11
 5427 0010 F8 A6 00                		mov.L	#0, [r10]
4819:../src/src/tls.c ****     PointFormat* point = NULL;
 5428                             		.loc 2 4819 18
 5429 0013 F9 A6 03 00             		mov.L	#0, 12[r10]
4820:../src/src/tls.c ****     int ret = 0;
 5430                             		.loc 2 4820 9
 5431 0017 F9 A6 01 00             		mov.L	#0, 4[r10]
4821:../src/src/tls.c **** 
4822:../src/src/tls.c ****     if (extensions == NULL)
 5432                             		.loc 2 4822 8
 5433 001b ED A5 04                		mov.L	16[r10], r5
 5434 001e 61 05                   		cmp	#0, r5
 5435 0020 18                      		bne	.L390
4823:../src/src/tls.c ****         return BAD_FUNC_ARG;
 5436                             		.loc 2 4823 16
 5437 0021 FB 5A 53 FF             		mov.L	#-173, r5
 5438 0025 38 87 00                		bra	.L396
 5439                             	.L390:
4824:../src/src/tls.c **** 
4825:../src/src/tls.c ****     extension = TLSX_Find(*extensions, TLSX_EC_POINT_FORMATS);
 5440                             		.loc 2 4825 17
 5441 0028 ED A5 04                		mov.L	16[r10], r5
 5442 002b EC 55                   		mov.L	[r5], r5
 5443 002d 66 B2                   		mov.L	#11, r2
 5444 002f EF 51                   		mov.L	r5, r1
 5445 0031 05 00 00 00             		bsr	_TLSX_Find
 5446 0035 E3 A1                   		mov.L	r1, [r10]
4826:../src/src/tls.c **** 
4827:../src/src/tls.c ****     if (!extension) {
 5447                             		.loc 2 4827 8
 5448 0037 EC A5                   		mov.L	[r10], r5
 5449 0039 61 05                   		cmp	#0, r5
 5450 003b 21 52                   		bne	.L392
4828:../src/src/tls.c ****         ret = TLSX_PointFormat_New(&point, format, heap);
 5451                             		.loc 2 4828 15
 5452 003d 71 A5 0C                		add	#12, r10, r5
 5453 0040 ED A3 06                		mov.L	24[r10], r3
 5454 0043 CD A2 14                		mov.B	20[r10], r2
 5455 0046 EF 51                   		mov.L	r5, r1
 5456 0048 05 00 00 00             		bsr	_TLSX_PointFormat_New
 5457 004c E7 A1 01                		mov.L	r1, 4[r10]
4829:../src/src/tls.c ****         if (ret != 0)
 5458                             		.loc 2 4829 12
 5459 004f ED A5 01                		mov.L	4[r10], r5
 5460 0052 61 05                   		cmp	#0, r5
 5461 0054 16                      		beq	.L393
4830:../src/src/tls.c ****             return ret;
 5462                             		.loc 2 4830 20
 5463 0055 ED A5 01                		mov.L	4[r10], r5
 5464 0058 2E 54                   		bra	.L396
 5465                             	.L393:
4831:../src/src/tls.c **** 
4832:../src/src/tls.c ****         ret = TLSX_Push(extensions, TLSX_EC_POINT_FORMATS, point, heap);
 5466                             		.loc 2 4832 15
 5467 005a ED A5 03                		mov.L	12[r10], r5
 5468 005d ED A4 06                		mov.L	24[r10], r4
 5469 0060 EF 53                   		mov.L	r5, r3
 5470 0062 66 B2                   		mov.L	#11, r2
 5471 0064 ED A1 04                		mov.L	16[r10], r1
 5472 0067 05 00 00 00             		bsr	_TLSX_Push
 5473 006b E7 A1 01                		mov.L	r1, 4[r10]
4833:../src/src/tls.c ****         if (ret != 0) {
 5474                             		.loc 2 4833 12
 5475 006e ED A5 01                		mov.L	4[r10], r5
 5476 0071 61 05                   		cmp	#0, r5
 5477 0073 20 37                   		beq	.L394
 5478                             	.LBB17:
4834:../src/src/tls.c ****             XFREE(point, heap, DYNAMIC_TYPE_TLSX);
 5479                             		.loc 2 4834 13
 5480 0075 ED A5 03                		mov.L	12[r10], r5
 5481 0078 E7 A5 02                		mov.L	r5, 8[r10]
 5482 007b ED A5 02                		mov.L	8[r10], r5
 5483 007e 61 05                   		cmp	#0, r5
 5484 0080 10                      		beq	.L395
 5485                             		.loc 2 4834 13 is_stmt 0 discriminator 1
 5486 0081 ED A1 02                		mov.L	8[r10], r1
 5487 0084 05 00 00 00             		bsr	_wolfSSL_Free
 5488                             	.L395:
 5489                             	.LBE17:
4835:../src/src/tls.c ****             return ret;
 5490                             		.loc 2 4835 20 is_stmt 1
 5491 0088 ED A5 01                		mov.L	4[r10], r5
 5492 008b 2E 21                   		bra	.L396
 5493                             	.L392:
4836:../src/src/tls.c ****         }
4837:../src/src/tls.c ****     }
4838:../src/src/tls.c ****     else {
4839:../src/src/tls.c ****         ret = TLSX_PointFormat_Append((PointFormat*)extension->data, format,
 5494                             		.loc 2 4839 62
 5495 008d EC A5                   		mov.L	[r10], r5
 5496 008f A8 5D                   		mov.L	4[r5], r5
 5497                             		.loc 2 4839 15
 5498 0091 ED A3 06                		mov.L	24[r10], r3
 5499 0094 CD A2 14                		mov.B	20[r10], r2
 5500 0097 EF 51                   		mov.L	r5, r1
 5501 0099 05 00 00 00             		bsr	_TLSX_PointFormat_Append
 5502 009d E7 A1 01                		mov.L	r1, 4[r10]
4840:../src/src/tls.c ****                                                                           heap);
4841:../src/src/tls.c ****         if (ret != 0)
 5503                             		.loc 2 4841 12
 5504 00a0 ED A5 01                		mov.L	4[r10], r5
 5505 00a3 61 05                   		cmp	#0, r5
 5506 00a5 15                      		beq	.L394
4842:../src/src/tls.c ****             return ret;
 5507                             		.loc 2 4842 20
 5508 00a6 ED A5 01                		mov.L	4[r10], r5
 5509 00a9 0B                      		bra	.L396
 5510                             	.L394:
4843:../src/src/tls.c ****     }
4844:../src/src/tls.c **** 
4845:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
 5511                             		.loc 2 4845 12
 5512 00aa 66 15                   		mov.L	#1, r5
 5513                             		.balign 8,3,1
 5514                             	.L396:
4846:../src/src/tls.c **** }
 5515                             		.loc 2 4846 1 discriminator 1
 5516 00ac EF 51                   		mov.L	r5, r1
 5517 00ae 3F AA 08                		rtsd	#32, r10-r10
 5518                             	.LFE94:
 5520 00b1 FD 70 40 00 00 00 80    		.section	.text.TLSX_SignatureAlgorithms_GetSize,"ax",@progbits
 5522                             	_TLSX_SignatureAlgorithms_GetSize:
 5523                             	.LFB95:
4847:../src/src/tls.c **** 
4848:../src/src/tls.c **** #define EC_FREE_ALL         TLSX_SupportedCurve_FreeAll
4849:../src/src/tls.c **** #define EC_VALIDATE_REQUEST TLSX_SupportedCurve_ValidateRequest
4850:../src/src/tls.c **** 
4851:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
4852:../src/src/tls.c **** #define EC_GET_SIZE TLSX_SupportedCurve_GetSize
4853:../src/src/tls.c **** #define EC_WRITE    TLSX_SupportedCurve_Write
4854:../src/src/tls.c **** #else
4855:../src/src/tls.c **** #define EC_GET_SIZE(list)         0
4856:../src/src/tls.c **** #define EC_WRITE(a, b)            0
4857:../src/src/tls.c **** #endif
4858:../src/src/tls.c **** 
4859:../src/src/tls.c **** #if !defined(NO_WOLFSSL_SERVER) || (defined(WOLFSSL_TLS13) && \
4860:../src/src/tls.c ****                                          !defined(WOLFSSL_NO_SERVER_GROUPS_EXT))
4861:../src/src/tls.c **** #define EC_PARSE TLSX_SupportedCurve_Parse
4862:../src/src/tls.c **** #else
4863:../src/src/tls.c **** #define EC_PARSE(a, b, c, d)      0
4864:../src/src/tls.c **** #endif
4865:../src/src/tls.c **** 
4866:../src/src/tls.c **** #define PF_FREE_ALL          TLSX_PointFormat_FreeAll
4867:../src/src/tls.c **** #define PF_VALIDATE_REQUEST  TLSX_PointFormat_ValidateRequest
4868:../src/src/tls.c **** #define PF_VALIDATE_RESPONSE TLSX_PointFormat_ValidateResponse
4869:../src/src/tls.c **** 
4870:../src/src/tls.c **** #define PF_GET_SIZE TLSX_PointFormat_GetSize
4871:../src/src/tls.c **** #define PF_WRITE    TLSX_PointFormat_Write
4872:../src/src/tls.c **** 
4873:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
4874:../src/src/tls.c **** #define PF_PARSE TLSX_PointFormat_Parse
4875:../src/src/tls.c **** #else
4876:../src/src/tls.c **** #define PF_PARSE(a, b, c, d)      0
4877:../src/src/tls.c **** #endif
4878:../src/src/tls.c **** 
4879:../src/src/tls.c **** #else
4880:../src/src/tls.c **** 
4881:../src/src/tls.c **** #define EC_FREE_ALL(list, heap)
4882:../src/src/tls.c **** #define EC_GET_SIZE(list)         0
4883:../src/src/tls.c **** #define EC_WRITE(a, b)            0
4884:../src/src/tls.c **** #define EC_PARSE(a, b, c, d)      0
4885:../src/src/tls.c **** #define EC_VALIDATE_REQUEST(a, b)
4886:../src/src/tls.c **** 
4887:../src/src/tls.c **** #define PF_FREE_ALL(list, heap)
4888:../src/src/tls.c **** #define PF_GET_SIZE(list)         0
4889:../src/src/tls.c **** #define PF_WRITE(a, b)            0
4890:../src/src/tls.c **** #define PF_PARSE(a, b, c, d)      0
4891:../src/src/tls.c **** #define PF_VALIDATE_REQUEST(a, b)
4892:../src/src/tls.c **** #define PF_VALIDATE_RESPONSE(a, b)
4893:../src/src/tls.c **** 
4894:../src/src/tls.c **** #endif /* HAVE_SUPPORTED_CURVES */
4895:../src/src/tls.c **** 
4896:../src/src/tls.c **** /******************************************************************************/
4897:../src/src/tls.c **** /* Renegotiation Indication                                                   */
4898:../src/src/tls.c **** /******************************************************************************/
4899:../src/src/tls.c **** 
4900:../src/src/tls.c **** #if defined(HAVE_SECURE_RENEGOTIATION) \
4901:../src/src/tls.c ****  || defined(HAVE_SERVER_RENEGOTIATION_INFO)
4902:../src/src/tls.c **** 
4903:../src/src/tls.c **** static byte TLSX_SecureRenegotiation_GetSize(SecureRenegotiation* data,
4904:../src/src/tls.c ****                                                                   int isRequest)
4905:../src/src/tls.c **** {
4906:../src/src/tls.c ****     byte length = OPAQUE8_LEN; /* empty info length */
4907:../src/src/tls.c **** 
4908:../src/src/tls.c ****     /* data will be NULL for HAVE_SERVER_RENEGOTIATION_INFO only */
4909:../src/src/tls.c ****     if (data && data->enabled && data->verifySet) {
4910:../src/src/tls.c ****         /* client sends client_verify_data only */
4911:../src/src/tls.c ****         length += TLS_FINISHED_SZ;
4912:../src/src/tls.c **** 
4913:../src/src/tls.c ****         /* server also sends server_verify_data */
4914:../src/src/tls.c ****         if (!isRequest)
4915:../src/src/tls.c ****             length += TLS_FINISHED_SZ;
4916:../src/src/tls.c ****     }
4917:../src/src/tls.c **** 
4918:../src/src/tls.c ****     return length;
4919:../src/src/tls.c **** }
4920:../src/src/tls.c **** 
4921:../src/src/tls.c **** static word16 TLSX_SecureRenegotiation_Write(SecureRenegotiation* data,
4922:../src/src/tls.c ****                                                     byte* output, int isRequest)
4923:../src/src/tls.c **** {
4924:../src/src/tls.c ****     word16 offset = OPAQUE8_LEN; /* RenegotiationInfo length */
4925:../src/src/tls.c ****     if (data && data->enabled && data->verifySet) {
4926:../src/src/tls.c ****         /* client sends client_verify_data only */
4927:../src/src/tls.c ****         XMEMCPY(output + offset, data->client_verify_data, TLS_FINISHED_SZ);
4928:../src/src/tls.c ****         offset += TLS_FINISHED_SZ;
4929:../src/src/tls.c **** 
4930:../src/src/tls.c ****         /* server also sends server_verify_data */
4931:../src/src/tls.c ****         if (!isRequest) {
4932:../src/src/tls.c ****             XMEMCPY(output + offset, data->server_verify_data, TLS_FINISHED_SZ);
4933:../src/src/tls.c ****             offset += TLS_FINISHED_SZ;
4934:../src/src/tls.c ****         }
4935:../src/src/tls.c ****     }
4936:../src/src/tls.c **** 
4937:../src/src/tls.c ****     output[0] = (byte)(offset - 1);  /* info length - self */
4938:../src/src/tls.c **** 
4939:../src/src/tls.c ****     return offset;
4940:../src/src/tls.c **** }
4941:../src/src/tls.c **** 
4942:../src/src/tls.c **** static int TLSX_SecureRenegotiation_Parse(WOLFSSL* ssl, const byte* input,
4943:../src/src/tls.c ****                                           word16 length, byte isRequest)
4944:../src/src/tls.c **** {
4945:../src/src/tls.c ****     int ret = SECURE_RENEGOTIATION_E;
4946:../src/src/tls.c **** 
4947:../src/src/tls.c ****     if (length >= OPAQUE8_LEN) {
4948:../src/src/tls.c ****         if (isRequest) {
4949:../src/src/tls.c ****         #ifndef NO_WOLFSSL_SERVER
4950:../src/src/tls.c ****             if (ssl->secure_renegotiation == NULL) {
4951:../src/src/tls.c ****                 ret = wolfSSL_UseSecureRenegotiation(ssl);
4952:../src/src/tls.c ****                 if (ret == WOLFSSL_SUCCESS)
4953:../src/src/tls.c ****                     ret = 0;
4954:../src/src/tls.c ****             }
4955:../src/src/tls.c ****             if (ret != 0 && ret != SECURE_RENEGOTIATION_E) {
4956:../src/src/tls.c ****             }
4957:../src/src/tls.c ****             else if (ssl->secure_renegotiation == NULL) {
4958:../src/src/tls.c ****             }
4959:../src/src/tls.c ****             else if (!ssl->secure_renegotiation->enabled) {
4960:../src/src/tls.c ****                 if (*input == 0) {
4961:../src/src/tls.c ****                     input++; /* get past size */
4962:../src/src/tls.c **** 
4963:../src/src/tls.c ****                     ssl->secure_renegotiation->enabled = 1;
4964:../src/src/tls.c ****                     TLSX_SetResponse(ssl, TLSX_RENEGOTIATION_INFO);
4965:../src/src/tls.c ****                     ret = 0;
4966:../src/src/tls.c ****                 }
4967:../src/src/tls.c ****                 else {
4968:../src/src/tls.c ****                     /* already in error state */
4969:../src/src/tls.c ****                     WOLFSSL_MSG("SCR client verify data present");
4970:../src/src/tls.c ****                 }
4971:../src/src/tls.c ****             }
4972:../src/src/tls.c ****             else if (*input == TLS_FINISHED_SZ) {
4973:../src/src/tls.c ****                 if (length < TLS_FINISHED_SZ + 1) {
4974:../src/src/tls.c ****                     WOLFSSL_MSG("SCR malformed buffer");
4975:../src/src/tls.c ****                     ret = BUFFER_E;
4976:../src/src/tls.c ****                 }
4977:../src/src/tls.c ****                 else {
4978:../src/src/tls.c ****                     input++; /* get past size */
4979:../src/src/tls.c **** 
4980:../src/src/tls.c ****                     /* validate client verify data */
4981:../src/src/tls.c ****                     if (XMEMCMP(input,
4982:../src/src/tls.c ****                             ssl->secure_renegotiation->client_verify_data,
4983:../src/src/tls.c ****                             TLS_FINISHED_SZ) == 0) {
4984:../src/src/tls.c ****                         WOLFSSL_MSG("SCR client verify data match");
4985:../src/src/tls.c ****                         TLSX_SetResponse(ssl, TLSX_RENEGOTIATION_INFO);
4986:../src/src/tls.c ****                         ret = 0;  /* verified */
4987:../src/src/tls.c ****                     } else {
4988:../src/src/tls.c ****                         /* already in error state */
4989:../src/src/tls.c ****                         WOLFSSL_MSG("SCR client verify data Failure");
4990:../src/src/tls.c ****                     }
4991:../src/src/tls.c ****                 }
4992:../src/src/tls.c ****             }
4993:../src/src/tls.c ****         #endif
4994:../src/src/tls.c ****         }
4995:../src/src/tls.c ****         else if (ssl->secure_renegotiation != NULL) {
4996:../src/src/tls.c ****         #ifndef NO_WOLFSSL_CLIENT
4997:../src/src/tls.c ****             if (!ssl->secure_renegotiation->enabled) {
4998:../src/src/tls.c ****                 if (*input == 0) {
4999:../src/src/tls.c ****                     ssl->secure_renegotiation->enabled = 1;
5000:../src/src/tls.c ****                     ret = 0;
5001:../src/src/tls.c ****                 }
5002:../src/src/tls.c ****             }
5003:../src/src/tls.c ****             else if (*input == 2 * TLS_FINISHED_SZ &&
5004:../src/src/tls.c ****                      length == 2 * TLS_FINISHED_SZ + OPAQUE8_LEN) {
5005:../src/src/tls.c ****                 input++;  /* get past size */
5006:../src/src/tls.c **** 
5007:../src/src/tls.c ****                 /* validate client and server verify data */
5008:../src/src/tls.c ****                 if (XMEMCMP(input,
5009:../src/src/tls.c ****                             ssl->secure_renegotiation->client_verify_data,
5010:../src/src/tls.c ****                             TLS_FINISHED_SZ) == 0 &&
5011:../src/src/tls.c ****                     XMEMCMP(input + TLS_FINISHED_SZ,
5012:../src/src/tls.c ****                             ssl->secure_renegotiation->server_verify_data,
5013:../src/src/tls.c ****                             TLS_FINISHED_SZ) == 0) {
5014:../src/src/tls.c ****                     WOLFSSL_MSG("SCR client and server verify data match");
5015:../src/src/tls.c ****                     ret = 0;  /* verified */
5016:../src/src/tls.c ****                 } else {
5017:../src/src/tls.c ****                     /* already in error state */
5018:../src/src/tls.c ****                     WOLFSSL_MSG("SCR client and server verify data Failure");
5019:../src/src/tls.c ****                 }
5020:../src/src/tls.c ****             }
5021:../src/src/tls.c ****         #endif
5022:../src/src/tls.c ****         }
5023:../src/src/tls.c ****     }
5024:../src/src/tls.c **** 
5025:../src/src/tls.c ****     if (ret != 0) {
5026:../src/src/tls.c ****         SendAlert(ssl, alert_fatal, handshake_failure);
5027:../src/src/tls.c ****     }
5028:../src/src/tls.c **** 
5029:../src/src/tls.c ****     return ret;
5030:../src/src/tls.c **** }
5031:../src/src/tls.c **** 
5032:../src/src/tls.c **** int TLSX_UseSecureRenegotiation(TLSX** extensions, void* heap)
5033:../src/src/tls.c **** {
5034:../src/src/tls.c ****     int ret = 0;
5035:../src/src/tls.c ****     SecureRenegotiation* data;
5036:../src/src/tls.c **** 
5037:../src/src/tls.c ****     data = (SecureRenegotiation*)XMALLOC(sizeof(SecureRenegotiation), heap,
5038:../src/src/tls.c ****                                                              DYNAMIC_TYPE_TLSX);
5039:../src/src/tls.c ****     if (data == NULL)
5040:../src/src/tls.c ****         return MEMORY_E;
5041:../src/src/tls.c **** 
5042:../src/src/tls.c ****     XMEMSET(data, 0, sizeof(SecureRenegotiation));
5043:../src/src/tls.c **** 
5044:../src/src/tls.c ****     ret = TLSX_Push(extensions, TLSX_RENEGOTIATION_INFO, data, heap);
5045:../src/src/tls.c ****     if (ret != 0) {
5046:../src/src/tls.c ****         XFREE(data, heap, DYNAMIC_TYPE_TLSX);
5047:../src/src/tls.c ****         return ret;
5048:../src/src/tls.c ****     }
5049:../src/src/tls.c **** 
5050:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
5051:../src/src/tls.c **** }
5052:../src/src/tls.c **** 
5053:../src/src/tls.c **** #ifdef HAVE_SERVER_RENEGOTIATION_INFO
5054:../src/src/tls.c **** 
5055:../src/src/tls.c **** int TLSX_AddEmptyRenegotiationInfo(TLSX** extensions, void* heap)
5056:../src/src/tls.c **** {
5057:../src/src/tls.c ****     int ret;
5058:../src/src/tls.c **** 
5059:../src/src/tls.c ****     /* send empty renegotiation_info extension */
5060:../src/src/tls.c ****     TLSX* ext = TLSX_Find(*extensions, TLSX_RENEGOTIATION_INFO);
5061:../src/src/tls.c ****     if (ext == NULL) {
5062:../src/src/tls.c ****         ret = TLSX_UseSecureRenegotiation(extensions, heap);
5063:../src/src/tls.c ****         if (ret != WOLFSSL_SUCCESS)
5064:../src/src/tls.c ****             return ret;
5065:../src/src/tls.c **** 
5066:../src/src/tls.c ****         ext = TLSX_Find(*extensions, TLSX_RENEGOTIATION_INFO);
5067:../src/src/tls.c ****     }
5068:../src/src/tls.c ****     if (ext)
5069:../src/src/tls.c ****         ext->resp = 1;
5070:../src/src/tls.c **** 
5071:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
5072:../src/src/tls.c **** }
5073:../src/src/tls.c **** 
5074:../src/src/tls.c **** #endif /* HAVE_SERVER_RENEGOTIATION_INFO */
5075:../src/src/tls.c **** 
5076:../src/src/tls.c **** 
5077:../src/src/tls.c **** #define SCR_FREE_ALL(data, heap) XFREE(data, (heap), DYNAMIC_TYPE_TLSX)
5078:../src/src/tls.c **** #define SCR_GET_SIZE       TLSX_SecureRenegotiation_GetSize
5079:../src/src/tls.c **** #define SCR_WRITE          TLSX_SecureRenegotiation_Write
5080:../src/src/tls.c **** #define SCR_PARSE          TLSX_SecureRenegotiation_Parse
5081:../src/src/tls.c **** 
5082:../src/src/tls.c **** #else
5083:../src/src/tls.c **** 
5084:../src/src/tls.c **** #define SCR_FREE_ALL(a, heap)
5085:../src/src/tls.c **** #define SCR_GET_SIZE(a, b)    0
5086:../src/src/tls.c **** #define SCR_WRITE(a, b, c)    0
5087:../src/src/tls.c **** #define SCR_PARSE(a, b, c, d) 0
5088:../src/src/tls.c **** 
5089:../src/src/tls.c **** #endif /* HAVE_SECURE_RENEGOTIATION || HAVE_SERVER_RENEGOTIATION_INFO */
5090:../src/src/tls.c **** 
5091:../src/src/tls.c **** /******************************************************************************/
5092:../src/src/tls.c **** /* Session Tickets                                                            */
5093:../src/src/tls.c **** /******************************************************************************/
5094:../src/src/tls.c **** 
5095:../src/src/tls.c **** #ifdef HAVE_SESSION_TICKET
5096:../src/src/tls.c **** 
5097:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) || !defined(NO_WOLFSSL_CLIENT)
5098:../src/src/tls.c **** static void TLSX_SessionTicket_ValidateRequest(WOLFSSL* ssl)
5099:../src/src/tls.c **** {
5100:../src/src/tls.c ****     TLSX*          extension = TLSX_Find(ssl->extensions, TLSX_SESSION_TICKET);
5101:../src/src/tls.c ****     SessionTicket* ticket    = extension ?
5102:../src/src/tls.c ****                                          (SessionTicket*)extension->data : NULL;
5103:../src/src/tls.c **** 
5104:../src/src/tls.c ****     if (ticket) {
5105:../src/src/tls.c ****         /* TODO validate ticket timeout here! */
5106:../src/src/tls.c ****         if (ticket->lifetime == 0xfffffff) {
5107:../src/src/tls.c ****             /* send empty ticket on timeout */
5108:../src/src/tls.c ****             TLSX_UseSessionTicket(&ssl->extensions, NULL, ssl->heap);
5109:../src/src/tls.c ****         }
5110:../src/src/tls.c ****     }
5111:../src/src/tls.c **** }
5112:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 || !NO_WOLFSSL_CLIENT */
5113:../src/src/tls.c **** 
5114:../src/src/tls.c **** 
5115:../src/src/tls.c **** static word16 TLSX_SessionTicket_GetSize(SessionTicket* ticket, int isRequest)
5116:../src/src/tls.c **** {
5117:../src/src/tls.c ****     (void)isRequest;
5118:../src/src/tls.c ****     return ticket ? ticket->size : 0;
5119:../src/src/tls.c **** }
5120:../src/src/tls.c **** 
5121:../src/src/tls.c **** static word16 TLSX_SessionTicket_Write(SessionTicket* ticket, byte* output,
5122:../src/src/tls.c ****                                        int isRequest)
5123:../src/src/tls.c **** {
5124:../src/src/tls.c ****     word16 offset = 0; /* empty ticket */
5125:../src/src/tls.c **** 
5126:../src/src/tls.c ****     if (isRequest && ticket) {
5127:../src/src/tls.c ****         XMEMCPY(output + offset, ticket->data, ticket->size);
5128:../src/src/tls.c ****         offset += ticket->size;
5129:../src/src/tls.c ****     }
5130:../src/src/tls.c **** 
5131:../src/src/tls.c ****     return offset;
5132:../src/src/tls.c **** }
5133:../src/src/tls.c **** 
5134:../src/src/tls.c **** 
5135:../src/src/tls.c **** static int TLSX_SessionTicket_Parse(WOLFSSL* ssl, const byte* input,
5136:../src/src/tls.c ****                                     word16 length, byte isRequest)
5137:../src/src/tls.c **** {
5138:../src/src/tls.c ****     int ret = 0;
5139:../src/src/tls.c **** 
5140:../src/src/tls.c ****     (void) input; /* avoid unused parameter if NO_WOLFSSL_SERVER defined */
5141:../src/src/tls.c **** 
5142:../src/src/tls.c ****     if (!isRequest) {
5143:../src/src/tls.c ****         if (TLSX_CheckUnsupportedExtension(ssl, TLSX_SESSION_TICKET))
5144:../src/src/tls.c ****             return TLSX_HandleUnsupportedExtension(ssl);
5145:../src/src/tls.c **** 
5146:../src/src/tls.c ****         if (length != 0)
5147:../src/src/tls.c ****             return BUFFER_ERROR;
5148:../src/src/tls.c **** 
5149:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
5150:../src/src/tls.c ****         ssl->expect_session_ticket = 1;
5151:../src/src/tls.c **** #endif
5152:../src/src/tls.c ****     }
5153:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
5154:../src/src/tls.c ****     else {
5155:../src/src/tls.c ****         /* server side */
5156:../src/src/tls.c ****         if (ssl->ctx->ticketEncCb == NULL) {
5157:../src/src/tls.c ****             WOLFSSL_MSG("Client sent session ticket, server has no callback");
5158:../src/src/tls.c ****             return 0;
5159:../src/src/tls.c ****         }
5160:../src/src/tls.c **** 
5161:../src/src/tls.c ****         if (length > SESSION_TICKET_LEN) {
5162:../src/src/tls.c ****             ret = BAD_TICKET_MSG_SZ;
5163:../src/src/tls.c ****         } else if (IsAtLeastTLSv1_3(ssl->version)) {
5164:../src/src/tls.c ****             WOLFSSL_MSG("Process client ticket rejected, TLS 1.3 no support");
5165:../src/src/tls.c ****             ssl->options.rejectTicket = 1;
5166:../src/src/tls.c ****             ret = 0;  /* not fatal */
5167:../src/src/tls.c ****         } else if (ssl->options.noTicketTls12) {
5168:../src/src/tls.c ****             /* ignore ticket request */
5169:../src/src/tls.c ****         } else if (length == 0) {
5170:../src/src/tls.c ****             /* blank ticket */
5171:../src/src/tls.c ****             ret = TLSX_UseSessionTicket(&ssl->extensions, NULL, ssl->heap);
5172:../src/src/tls.c ****             if (ret == WOLFSSL_SUCCESS) {
5173:../src/src/tls.c ****                 ret = 0;
5174:../src/src/tls.c ****                 /* send blank ticket */
5175:../src/src/tls.c ****                 TLSX_SetResponse(ssl, TLSX_SESSION_TICKET);
5176:../src/src/tls.c ****                 ssl->options.createTicket = 1;  /* will send ticket msg */
5177:../src/src/tls.c ****                 ssl->options.useTicket    = 1;
5178:../src/src/tls.c ****                 ssl->options.resuming     = 0;  /* no standard resumption */
5179:../src/src/tls.c ****                 ssl->arrays->sessionIDSz  = 0;  /* no echo on blank ticket */
5180:../src/src/tls.c ****             }
5181:../src/src/tls.c ****         } else {
5182:../src/src/tls.c ****             /* got actual ticket from client */
5183:../src/src/tls.c ****             ret = DoClientTicket(ssl, input, length);
5184:../src/src/tls.c ****             if (ret == WOLFSSL_TICKET_RET_OK) {    /* use ticket to resume */
5185:../src/src/tls.c ****                 WOLFSSL_MSG("Using existing client ticket");
5186:../src/src/tls.c ****                 ssl->options.useTicket    = 1;
5187:../src/src/tls.c ****                 ssl->options.resuming     = 1;
5188:../src/src/tls.c ****                 /* SERVER: ticket is peer auth. */
5189:../src/src/tls.c ****                 ssl->options.peerAuthGood = 1;
5190:../src/src/tls.c ****             } else if (ret == WOLFSSL_TICKET_RET_CREATE) {
5191:../src/src/tls.c ****                 WOLFSSL_MSG("Using existing client ticket, creating new one");
5192:../src/src/tls.c ****                 ret = TLSX_UseSessionTicket(&ssl->extensions, NULL, ssl->heap);
5193:../src/src/tls.c ****                 if (ret == WOLFSSL_SUCCESS) {
5194:../src/src/tls.c ****                     ret = 0;
5195:../src/src/tls.c ****                     TLSX_SetResponse(ssl, TLSX_SESSION_TICKET);
5196:../src/src/tls.c ****                                                     /* send blank ticket */
5197:../src/src/tls.c ****                     ssl->options.createTicket = 1;  /* will send ticket msg */
5198:../src/src/tls.c ****                     ssl->options.useTicket    = 1;
5199:../src/src/tls.c ****                     ssl->options.resuming     = 1;
5200:../src/src/tls.c ****                     /* SERVER: ticket is peer auth. */
5201:../src/src/tls.c ****                     ssl->options.peerAuthGood = 1;
5202:../src/src/tls.c ****                 }
5203:../src/src/tls.c ****             } else if (ret == WOLFSSL_TICKET_RET_REJECT) {
5204:../src/src/tls.c ****                 WOLFSSL_MSG("Process client ticket rejected, not using");
5205:../src/src/tls.c ****                 ssl->options.rejectTicket = 1;
5206:../src/src/tls.c ****                 ret = 0;  /* not fatal */
5207:../src/src/tls.c ****             } else if (ret == VERSION_ERROR) {
5208:../src/src/tls.c ****                 WOLFSSL_MSG("Process client ticket rejected, bad TLS version");
5209:../src/src/tls.c ****                 ssl->options.rejectTicket = 1;
5210:../src/src/tls.c ****                 ret = 0;  /* not fatal */
5211:../src/src/tls.c ****             } else if (ret == WOLFSSL_TICKET_RET_FATAL) {
5212:../src/src/tls.c ****                 WOLFSSL_MSG("Process client ticket fatal error, not using");
5213:../src/src/tls.c ****             } else if (ret < 0) {
5214:../src/src/tls.c ****                 WOLFSSL_MSG("Process client ticket unknown error, not using");
5215:../src/src/tls.c ****             }
5216:../src/src/tls.c ****         }
5217:../src/src/tls.c ****     }
5218:../src/src/tls.c **** #endif /* NO_WOLFSSL_SERVER */
5219:../src/src/tls.c **** 
5220:../src/src/tls.c **** #if defined(NO_WOLFSSL_CLIENT) && defined(NO_WOLFSSL_SERVER)
5221:../src/src/tls.c ****     (void)ssl;
5222:../src/src/tls.c **** #endif
5223:../src/src/tls.c **** 
5224:../src/src/tls.c ****     return ret;
5225:../src/src/tls.c **** }
5226:../src/src/tls.c **** 
5227:../src/src/tls.c **** WOLFSSL_LOCAL SessionTicket* TLSX_SessionTicket_Create(word32 lifetime,
5228:../src/src/tls.c ****                                             byte* data, word16 size, void* heap)
5229:../src/src/tls.c **** {
5230:../src/src/tls.c ****     SessionTicket* ticket = (SessionTicket*)XMALLOC(sizeof(SessionTicket),
5231:../src/src/tls.c ****                                                        heap, DYNAMIC_TYPE_TLSX);
5232:../src/src/tls.c ****     if (ticket) {
5233:../src/src/tls.c ****         ticket->data = (byte*)XMALLOC(size, heap, DYNAMIC_TYPE_TLSX);
5234:../src/src/tls.c ****         if (ticket->data == NULL) {
5235:../src/src/tls.c ****             XFREE(ticket, heap, DYNAMIC_TYPE_TLSX);
5236:../src/src/tls.c ****             return NULL;
5237:../src/src/tls.c ****         }
5238:../src/src/tls.c **** 
5239:../src/src/tls.c ****         XMEMCPY(ticket->data, data, size);
5240:../src/src/tls.c ****         ticket->size     = size;
5241:../src/src/tls.c ****         ticket->lifetime = lifetime;
5242:../src/src/tls.c ****     }
5243:../src/src/tls.c **** 
5244:../src/src/tls.c ****     (void)heap;
5245:../src/src/tls.c **** 
5246:../src/src/tls.c ****     return ticket;
5247:../src/src/tls.c **** }
5248:../src/src/tls.c **** WOLFSSL_LOCAL void TLSX_SessionTicket_Free(SessionTicket* ticket, void* heap)
5249:../src/src/tls.c **** {
5250:../src/src/tls.c ****     if (ticket) {
5251:../src/src/tls.c ****         XFREE(ticket->data, heap, DYNAMIC_TYPE_TLSX);
5252:../src/src/tls.c ****         XFREE(ticket,       heap, DYNAMIC_TYPE_TLSX);
5253:../src/src/tls.c ****     }
5254:../src/src/tls.c **** 
5255:../src/src/tls.c ****     (void)heap;
5256:../src/src/tls.c **** }
5257:../src/src/tls.c **** 
5258:../src/src/tls.c **** int TLSX_UseSessionTicket(TLSX** extensions, SessionTicket* ticket, void* heap)
5259:../src/src/tls.c **** {
5260:../src/src/tls.c ****     int ret = 0;
5261:../src/src/tls.c **** 
5262:../src/src/tls.c ****     if (extensions == NULL)
5263:../src/src/tls.c ****         return BAD_FUNC_ARG;
5264:../src/src/tls.c **** 
5265:../src/src/tls.c ****     /* If the ticket is NULL, the client will request a new ticket from the
5266:../src/src/tls.c ****        server. Otherwise, the client will use it in the next client hello. */
5267:../src/src/tls.c ****     if ((ret = TLSX_Push(extensions, TLSX_SESSION_TICKET, (void*)ticket, heap))
5268:../src/src/tls.c ****                                                                            != 0)
5269:../src/src/tls.c ****         return ret;
5270:../src/src/tls.c **** 
5271:../src/src/tls.c ****     return WOLFSSL_SUCCESS;
5272:../src/src/tls.c **** }
5273:../src/src/tls.c **** 
5274:../src/src/tls.c **** #define WOLF_STK_VALIDATE_REQUEST TLSX_SessionTicket_ValidateRequest
5275:../src/src/tls.c **** #define WOLF_STK_GET_SIZE         TLSX_SessionTicket_GetSize
5276:../src/src/tls.c **** #define WOLF_STK_WRITE            TLSX_SessionTicket_Write
5277:../src/src/tls.c **** #define WOLF_STK_PARSE            TLSX_SessionTicket_Parse
5278:../src/src/tls.c **** #define WOLF_STK_FREE(stk, heap)  TLSX_SessionTicket_Free((SessionTicket*)(stk),(heap))
5279:../src/src/tls.c **** 
5280:../src/src/tls.c **** #else
5281:../src/src/tls.c **** 
5282:../src/src/tls.c **** #define WOLF_STK_FREE(a, b)
5283:../src/src/tls.c **** #define WOLF_STK_VALIDATE_REQUEST(a)
5284:../src/src/tls.c **** #define WOLF_STK_GET_SIZE(a, b)      0
5285:../src/src/tls.c **** #define WOLF_STK_WRITE(a, b, c)      0
5286:../src/src/tls.c **** #define WOLF_STK_PARSE(a, b, c, d)   0
5287:../src/src/tls.c **** 
5288:../src/src/tls.c **** #endif /* HAVE_SESSION_TICKET */
5289:../src/src/tls.c **** 
5290:../src/src/tls.c **** #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
5291:../src/src/tls.c **** /******************************************************************************/
5292:../src/src/tls.c **** /* Encrypt-then-MAC                                                           */
5293:../src/src/tls.c **** /******************************************************************************/
5294:../src/src/tls.c **** 
5295:../src/src/tls.c **** #ifndef WOLFSSL_NO_TLS12
5296:../src/src/tls.c **** static int TLSX_EncryptThenMac_Use(WOLFSSL* ssl);
5297:../src/src/tls.c **** 
5298:../src/src/tls.c **** /**
5299:../src/src/tls.c ****  * Get the size of the Encrypt-Then-MAC extension.
5300:../src/src/tls.c ****  *
5301:../src/src/tls.c ****  * msgType  Type of message to put extension into.
5302:../src/src/tls.c ****  * pSz      Size of extension data.
5303:../src/src/tls.c ****  * return SANITY_MSG_E when the message is not allowed to have extension and
5304:../src/src/tls.c ****  *        0 otherwise.
5305:../src/src/tls.c ****  */
5306:../src/src/tls.c **** static int TLSX_EncryptThenMac_GetSize(byte msgType, word16* pSz)
5307:../src/src/tls.c **** {
5308:../src/src/tls.c ****     (void)pSz;
5309:../src/src/tls.c **** 
5310:../src/src/tls.c ****     if (msgType != client_hello && msgType != server_hello) {
5311:../src/src/tls.c ****         return SANITY_MSG_E;
5312:../src/src/tls.c ****     }
5313:../src/src/tls.c **** 
5314:../src/src/tls.c ****     /* Empty extension */
5315:../src/src/tls.c **** 
5316:../src/src/tls.c ****     return 0;
5317:../src/src/tls.c **** }
5318:../src/src/tls.c **** 
5319:../src/src/tls.c **** /**
5320:../src/src/tls.c ****  * Write the Encrypt-Then-MAC extension.
5321:../src/src/tls.c ****  *
5322:../src/src/tls.c ****  * data     Unused
5323:../src/src/tls.c ****  * output   Extension data buffer. Unused.
5324:../src/src/tls.c ****  * msgType  Type of message to put extension into.
5325:../src/src/tls.c ****  * pSz      Size of extension data.
5326:../src/src/tls.c ****  * return SANITY_MSG_E when the message is not allowed to have extension and
5327:../src/src/tls.c ****  *        0 otherwise.
5328:../src/src/tls.c ****  */
5329:../src/src/tls.c **** static int TLSX_EncryptThenMac_Write(void* data, byte* output, byte msgType,
5330:../src/src/tls.c ****                                      word16* pSz)
5331:../src/src/tls.c **** {
5332:../src/src/tls.c ****     (void)data;
5333:../src/src/tls.c ****     (void)output;
5334:../src/src/tls.c ****     (void)pSz;
5335:../src/src/tls.c **** 
5336:../src/src/tls.c ****     if (msgType != client_hello && msgType != server_hello) {
5337:../src/src/tls.c ****         return SANITY_MSG_E;
5338:../src/src/tls.c ****     }
5339:../src/src/tls.c **** 
5340:../src/src/tls.c ****     /* Empty extension */
5341:../src/src/tls.c **** 
5342:../src/src/tls.c ****     return 0;
5343:../src/src/tls.c **** }
5344:../src/src/tls.c **** 
5345:../src/src/tls.c **** /**
5346:../src/src/tls.c ****  * Parse the Encrypt-Then-MAC extension.
5347:../src/src/tls.c ****  *
5348:../src/src/tls.c ****  * ssl      SSL object
5349:../src/src/tls.c ****  * input    Extension data buffer.
5350:../src/src/tls.c ****  * length   Length of this extension's data.
5351:../src/src/tls.c ****  * msgType  Type of message to extension appeared in.
5352:../src/src/tls.c ****  * return SANITY_MSG_E when the message is not allowed to have extension,
5353:../src/src/tls.c ****  *        BUFFER_ERROR when the extension's data is invalid,
5354:../src/src/tls.c ****  *        MEMORY_E when unable to allocate memory and
5355:../src/src/tls.c ****  *        0 otherwise.
5356:../src/src/tls.c ****  */
5357:../src/src/tls.c **** static int TLSX_EncryptThenMac_Parse(WOLFSSL* ssl, const byte* input,
5358:../src/src/tls.c ****                                      word16 length, byte msgType)
5359:../src/src/tls.c **** {
5360:../src/src/tls.c ****     int ret;
5361:../src/src/tls.c **** 
5362:../src/src/tls.c ****     (void)input;
5363:../src/src/tls.c **** 
5364:../src/src/tls.c ****     if (msgType != client_hello && msgType != server_hello) {
5365:../src/src/tls.c ****         return SANITY_MSG_E;
5366:../src/src/tls.c ****     }
5367:../src/src/tls.c **** 
5368:../src/src/tls.c ****     /* Empty extension */
5369:../src/src/tls.c ****     if (length != 0)
5370:../src/src/tls.c ****         return BUFFER_ERROR;
5371:../src/src/tls.c **** 
5372:../src/src/tls.c ****     if (msgType == client_hello) {
5373:../src/src/tls.c ****         /* Check the user hasn't disallowed use of Encrypt-Then-Mac. */
5374:../src/src/tls.c ****         if (!ssl->options.disallowEncThenMac) {
5375:../src/src/tls.c ****             ssl->options.encThenMac = 1;
5376:../src/src/tls.c ****             /* Set the extension reply. */
5377:../src/src/tls.c ****             ret = TLSX_EncryptThenMac_Use(ssl);
5378:../src/src/tls.c ****             if (ret != 0)
5379:../src/src/tls.c ****                 return ret;
5380:../src/src/tls.c ****         }
5381:../src/src/tls.c ****         return 0;
5382:../src/src/tls.c ****     }
5383:../src/src/tls.c **** 
5384:../src/src/tls.c ****     /* Server Hello */
5385:../src/src/tls.c ****     if (ssl->options.disallowEncThenMac)
5386:../src/src/tls.c ****         return SANITY_MSG_E;
5387:../src/src/tls.c **** 
5388:../src/src/tls.c ****     ssl->options.encThenMac = 1;
5389:../src/src/tls.c ****     return 0;
5390:../src/src/tls.c **** 
5391:../src/src/tls.c **** }
5392:../src/src/tls.c **** 
5393:../src/src/tls.c **** /**
5394:../src/src/tls.c ****  * Add the Encrypt-Then-MAC extension to list.
5395:../src/src/tls.c ****  *
5396:../src/src/tls.c ****  * ssl      SSL object
5397:../src/src/tls.c ****  * return MEMORY_E when unable to allocate memory and 0 otherwise.
5398:../src/src/tls.c ****  */
5399:../src/src/tls.c **** static int TLSX_EncryptThenMac_Use(WOLFSSL* ssl)
5400:../src/src/tls.c **** {
5401:../src/src/tls.c ****     int   ret = 0;
5402:../src/src/tls.c ****     TLSX* extension;
5403:../src/src/tls.c **** 
5404:../src/src/tls.c ****     /* Find the Encrypt-Then-Mac extension if it exists. */
5405:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_ENCRYPT_THEN_MAC);
5406:../src/src/tls.c ****     if (extension == NULL) {
5407:../src/src/tls.c ****         /* Push new Encrypt-Then-Mac extension. */
5408:../src/src/tls.c ****         ret = TLSX_Push(&ssl->extensions, TLSX_ENCRYPT_THEN_MAC, NULL,
5409:../src/src/tls.c ****             ssl->heap);
5410:../src/src/tls.c ****         if (ret != 0)
5411:../src/src/tls.c ****             return ret;
5412:../src/src/tls.c ****     }
5413:../src/src/tls.c **** 
5414:../src/src/tls.c ****     return 0;
5415:../src/src/tls.c **** }
5416:../src/src/tls.c **** 
5417:../src/src/tls.c **** /**
5418:../src/src/tls.c ****  * Set the Encrypt-Then-MAC extension as one to respond too.
5419:../src/src/tls.c ****  *
5420:../src/src/tls.c ****  * ssl      SSL object
5421:../src/src/tls.c ****  * return EXT_MISSING when EncryptThenMac extension not in list.
5422:../src/src/tls.c ****  */
5423:../src/src/tls.c **** int TLSX_EncryptThenMac_Respond(WOLFSSL* ssl)
5424:../src/src/tls.c **** {
5425:../src/src/tls.c ****     TLSX* extension;
5426:../src/src/tls.c **** 
5427:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_ENCRYPT_THEN_MAC);
5428:../src/src/tls.c ****     if (extension == NULL)
5429:../src/src/tls.c ****         return EXT_MISSING;
5430:../src/src/tls.c ****     extension->resp = 1;
5431:../src/src/tls.c **** 
5432:../src/src/tls.c ****     return 0;
5433:../src/src/tls.c **** }
5434:../src/src/tls.c **** 
5435:../src/src/tls.c **** #define ETM_GET_SIZE  TLSX_EncryptThenMac_GetSize
5436:../src/src/tls.c **** #define ETM_WRITE     TLSX_EncryptThenMac_Write
5437:../src/src/tls.c **** #define ETM_PARSE     TLSX_EncryptThenMac_Parse
5438:../src/src/tls.c **** 
5439:../src/src/tls.c **** #else
5440:../src/src/tls.c **** 
5441:../src/src/tls.c **** #define ETM_GET_SIZE(a, b)    0
5442:../src/src/tls.c **** #define ETM_WRITE(a, b, c, d) 0
5443:../src/src/tls.c **** #define ETM_PARSE(a, b, c, d) 0
5444:../src/src/tls.c **** 
5445:../src/src/tls.c **** #endif /* !WOLFSSL_NO_TLS12 */
5446:../src/src/tls.c **** 
5447:../src/src/tls.c **** #endif /* HAVE_ENCRYPT_THEN_MAC && !WOLFSSL_AEAD_ONLY */
5448:../src/src/tls.c **** 
5449:../src/src/tls.c **** 
5450:../src/src/tls.c **** #ifdef WOLFSSL_SRTP
5451:../src/src/tls.c **** 
5452:../src/src/tls.c **** /******************************************************************************/
5453:../src/src/tls.c **** /* DTLS SRTP (Secure Real-time Transport Protocol)                            */
5454:../src/src/tls.c **** /******************************************************************************/
5455:../src/src/tls.c **** 
5456:../src/src/tls.c **** /* Only support single SRTP profile */
5457:../src/src/tls.c **** typedef struct TlsxSrtp {
5458:../src/src/tls.c ****     word16 profileCount;
5459:../src/src/tls.c ****     word16 ids; /* selected bits */
5460:../src/src/tls.c **** } TlsxSrtp;
5461:../src/src/tls.c **** 
5462:../src/src/tls.c **** static int TLSX_UseSRTP_GetSize(TlsxSrtp *srtp)
5463:../src/src/tls.c **** {
5464:../src/src/tls.c ****     /*   SRTP Profile Len (2)
5465:../src/src/tls.c ****      *      SRTP Profiles (2)
5466:../src/src/tls.c ****      *   MKI (master key id) Length */
5467:../src/src/tls.c ****     return (OPAQUE16_LEN + (srtp->profileCount * OPAQUE16_LEN) + 1);
5468:../src/src/tls.c **** }
5469:../src/src/tls.c **** 
5470:../src/src/tls.c **** static TlsxSrtp* TLSX_UseSRTP_New(word16 ids, void* heap)
5471:../src/src/tls.c **** {
5472:../src/src/tls.c ****     TlsxSrtp* srtp;
5473:../src/src/tls.c ****     int i;
5474:../src/src/tls.c **** 
5475:../src/src/tls.c ****     srtp = (TlsxSrtp*)XMALLOC(sizeof(TlsxSrtp), heap, DYNAMIC_TYPE_TLSX);
5476:../src/src/tls.c ****     if (srtp == NULL) {
5477:../src/src/tls.c ****         WOLFSSL_MSG("TLSX SRTP Memory failure");
5478:../src/src/tls.c ****         return NULL;
5479:../src/src/tls.c ****     }
5480:../src/src/tls.c **** 
5481:../src/src/tls.c ****     /* count and test each bit set */
5482:../src/src/tls.c ****     srtp->profileCount = 0;
5483:../src/src/tls.c ****     for (i=0; i<16; i++) {
5484:../src/src/tls.c ****         if (ids & (1 << i)) {
5485:../src/src/tls.c ****             srtp->profileCount++;
5486:../src/src/tls.c ****         }
5487:../src/src/tls.c ****     }
5488:../src/src/tls.c ****     srtp->ids = ids;
5489:../src/src/tls.c **** 
5490:../src/src/tls.c ****     return srtp;
5491:../src/src/tls.c **** }
5492:../src/src/tls.c **** 
5493:../src/src/tls.c **** static void TLSX_UseSRTP_Free(TlsxSrtp *srtp, void* heap)
5494:../src/src/tls.c **** {
5495:../src/src/tls.c ****     if (srtp != NULL) {
5496:../src/src/tls.c ****         XFREE(srtp, heap, DYNAMIC_TYPE_TLSX);
5497:../src/src/tls.c ****     }
5498:../src/src/tls.c ****     (void)heap;
5499:../src/src/tls.c **** }
5500:../src/src/tls.c **** 
5501:../src/src/tls.c **** static int TLSX_UseSRTP_Parse(WOLFSSL* ssl, const byte* input, word16 length,
5502:../src/src/tls.c ****     byte isRequest)
5503:../src/src/tls.c **** {
5504:../src/src/tls.c ****     int ret = BAD_FUNC_ARG;
5505:../src/src/tls.c ****     word16 profile_len = 0;
5506:../src/src/tls.c ****     word16 profile_value = 0;
5507:../src/src/tls.c ****     word16 offset = 0;
5508:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
5509:../src/src/tls.c ****     int i;
5510:../src/src/tls.c ****     TlsxSrtp* srtp = NULL;
5511:../src/src/tls.c **** #endif
5512:../src/src/tls.c **** 
5513:../src/src/tls.c ****     if (length < OPAQUE16_LEN) {
5514:../src/src/tls.c ****         return BUFFER_ERROR;
5515:../src/src/tls.c ****     }
5516:../src/src/tls.c **** 
5517:../src/src/tls.c ****     /* reset selected DTLS SRTP profile ID */
5518:../src/src/tls.c ****     ssl->dtlsSrtpId = 0;
5519:../src/src/tls.c **** 
5520:../src/src/tls.c ****     /* total length, not include itself */
5521:../src/src/tls.c ****     ato16(input, &profile_len);
5522:../src/src/tls.c ****     offset += OPAQUE16_LEN;
5523:../src/src/tls.c **** 
5524:../src/src/tls.c ****     if (!isRequest) {
5525:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
5526:../src/src/tls.c ****         if (length < offset + OPAQUE16_LEN)
5527:../src/src/tls.c ****             return BUFFER_ERROR;
5528:../src/src/tls.c **** 
5529:../src/src/tls.c ****         ato16(input + offset, &profile_value);
5530:../src/src/tls.c **** 
5531:../src/src/tls.c ****         /* check that the profile received was in the ones we support */
5532:../src/src/tls.c ****         if (profile_value < 16 &&
5533:../src/src/tls.c ****                                (ssl->dtlsSrtpProfiles & (1 << profile_value))) {
5534:../src/src/tls.c ****             ssl->dtlsSrtpId = profile_value;
5535:../src/src/tls.c ****             ret = 0; /* success */
5536:../src/src/tls.c ****         }
5537:../src/src/tls.c **** #endif
5538:../src/src/tls.c ****     }
5539:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
5540:../src/src/tls.c ****     else {
5541:../src/src/tls.c ****         /* parse remainder one profile at a time, looking for match in CTX */
5542:../src/src/tls.c ****         ret = 0;
5543:../src/src/tls.c ****         for (i=offset; i<length; i+=OPAQUE16_LEN) {
5544:../src/src/tls.c ****             ato16(input+i, &profile_value);
5545:../src/src/tls.c ****             /* find first match */
5546:../src/src/tls.c ****             if (profile_value < 16 &&
5547:../src/src/tls.c ****                                  ssl->dtlsSrtpProfiles & (1 << profile_value)) {
5548:../src/src/tls.c ****                 ssl->dtlsSrtpId = profile_value;
5549:../src/src/tls.c **** 
5550:../src/src/tls.c ****                 /* make sure we respond with selected SRTP id selected */
5551:../src/src/tls.c ****                 srtp = TLSX_UseSRTP_New((1 << profile_value), ssl->heap);
5552:../src/src/tls.c ****                 if (srtp != NULL) {
5553:../src/src/tls.c ****                     ret = TLSX_Push(&ssl->extensions, TLSX_USE_SRTP,
5554:../src/src/tls.c ****                         (void*)srtp, ssl->heap);
5555:../src/src/tls.c ****                     if (ret == 0) {
5556:../src/src/tls.c ****                         TLSX_SetResponse(ssl, TLSX_USE_SRTP);
5557:../src/src/tls.c ****                         /* successfully set extension */
5558:../src/src/tls.c ****                     }
5559:../src/src/tls.c ****                 }
5560:../src/src/tls.c ****                 else {
5561:../src/src/tls.c ****                     ret = MEMORY_E;
5562:../src/src/tls.c ****                 }
5563:../src/src/tls.c ****                 break;
5564:../src/src/tls.c ****             }
5565:../src/src/tls.c ****         }
5566:../src/src/tls.c ****     }
5567:../src/src/tls.c **** 
5568:../src/src/tls.c ****     if (ret == 0 && ssl->dtlsSrtpId == 0) {
5569:../src/src/tls.c ****         WOLFSSL_MSG("TLSX_UseSRTP_Parse profile not found!");
5570:../src/src/tls.c ****         /* not fatal */
5571:../src/src/tls.c ****     }
5572:../src/src/tls.c ****     else if (ret != 0) {
5573:../src/src/tls.c ****         ssl->dtlsSrtpId = 0;
5574:../src/src/tls.c ****         TLSX_UseSRTP_Free(srtp, ssl->heap);
5575:../src/src/tls.c ****     }
5576:../src/src/tls.c **** #endif
5577:../src/src/tls.c ****     (void)profile_len;
5578:../src/src/tls.c **** 
5579:../src/src/tls.c ****     return ret;
5580:../src/src/tls.c **** }
5581:../src/src/tls.c **** 
5582:../src/src/tls.c **** static word16 TLSX_UseSRTP_Write(TlsxSrtp* srtp, byte* output)
5583:../src/src/tls.c **** {
5584:../src/src/tls.c ****     word16 offset = 0;
5585:../src/src/tls.c ****     int i, j;
5586:../src/src/tls.c **** 
5587:../src/src/tls.c ****     c16toa(srtp->profileCount*2, output+offset);
5588:../src/src/tls.c ****     offset += OPAQUE16_LEN;
5589:../src/src/tls.c ****     for (i=0; i< srtp->profileCount; i+=2) {
5590:../src/src/tls.c ****         for (j=0; j<16; j++) {
5591:../src/src/tls.c ****             if (srtp->ids & (1 << j)) {
5592:../src/src/tls.c ****                 c16toa(j, output+offset);
5593:../src/src/tls.c ****                 offset += OPAQUE16_LEN;
5594:../src/src/tls.c ****             }
5595:../src/src/tls.c ****         }
5596:../src/src/tls.c ****     }
5597:../src/src/tls.c ****     output[offset++] = 0x00; /* MKI Length */
5598:../src/src/tls.c **** 
5599:../src/src/tls.c ****     return offset;
5600:../src/src/tls.c **** }
5601:../src/src/tls.c **** 
5602:../src/src/tls.c **** static int TLSX_UseSRTP(TLSX** extensions, word16 profiles, void* heap)
5603:../src/src/tls.c **** {
5604:../src/src/tls.c ****     int ret = 0;
5605:../src/src/tls.c ****     TLSX* extension;
5606:../src/src/tls.c **** 
5607:../src/src/tls.c ****     if (extensions == NULL) {
5608:../src/src/tls.c ****         return BAD_FUNC_ARG;
5609:../src/src/tls.c ****     }
5610:../src/src/tls.c **** 
5611:../src/src/tls.c ****     extension = TLSX_Find(*extensions, TLSX_USE_SRTP);
5612:../src/src/tls.c ****     if (extension == NULL) {
5613:../src/src/tls.c ****         TlsxSrtp* srtp = TLSX_UseSRTP_New(profiles, heap);
5614:../src/src/tls.c ****         if (srtp == NULL) {
5615:../src/src/tls.c ****             return MEMORY_E;
5616:../src/src/tls.c ****         }
5617:../src/src/tls.c **** 
5618:../src/src/tls.c ****         ret = TLSX_Push(extensions, TLSX_USE_SRTP, (void*)srtp, heap);
5619:../src/src/tls.c ****         if (ret != 0) {
5620:../src/src/tls.c ****             TLSX_UseSRTP_Free(srtp, heap);
5621:../src/src/tls.c ****         }
5622:../src/src/tls.c ****     }
5623:../src/src/tls.c **** 
5624:../src/src/tls.c ****     return ret;
5625:../src/src/tls.c **** }
5626:../src/src/tls.c **** 
5627:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
5628:../src/src/tls.c ****     #define SRTP_FREE     TLSX_UseSRTP_Free
5629:../src/src/tls.c ****     #define SRTP_PARSE    TLSX_UseSRTP_Parse
5630:../src/src/tls.c ****     #define SRTP_WRITE    TLSX_UseSRTP_Write
5631:../src/src/tls.c ****     #define SRTP_GET_SIZE TLSX_UseSRTP_GetSize
5632:../src/src/tls.c **** #else
5633:../src/src/tls.c ****     #define SRTP_FREE(a, b)
5634:../src/src/tls.c ****     #define SRTP_PARSE(a, b, c, d)      0
5635:../src/src/tls.c ****     #define SRTP_WRITE(a, b)            0
5636:../src/src/tls.c ****     #define SRTP_GET_SIZE(a)            0
5637:../src/src/tls.c **** #endif
5638:../src/src/tls.c **** 
5639:../src/src/tls.c **** #endif /* WOLFSSL_SRTP */
5640:../src/src/tls.c **** 
5641:../src/src/tls.c **** 
5642:../src/src/tls.c **** /******************************************************************************/
5643:../src/src/tls.c **** /* Supported Versions                                                         */
5644:../src/src/tls.c **** /******************************************************************************/
5645:../src/src/tls.c **** 
5646:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
5647:../src/src/tls.c **** static WC_INLINE int versionIsGreater(byte isDtls, byte a, byte b)
5648:../src/src/tls.c **** {
5649:../src/src/tls.c ****     (void)isDtls;
5650:../src/src/tls.c **** 
5651:../src/src/tls.c **** #ifdef WOLFSSL_DTLS
5652:../src/src/tls.c ****     /* DTLS version increases backwards (-1,-2,-3,etc) */
5653:../src/src/tls.c ****     if (isDtls)
5654:../src/src/tls.c ****         return a < b;
5655:../src/src/tls.c **** #endif /* WOLFSSL_DTLS */
5656:../src/src/tls.c **** 
5657:../src/src/tls.c ****     return a > b;
5658:../src/src/tls.c **** }
5659:../src/src/tls.c **** 
5660:../src/src/tls.c **** static WC_INLINE int versionIsLesser(byte isDtls, byte a, byte b)
5661:../src/src/tls.c **** {
5662:../src/src/tls.c ****     (void)isDtls;
5663:../src/src/tls.c **** 
5664:../src/src/tls.c **** #ifdef WOLFSSL_DTLS
5665:../src/src/tls.c ****     /* DTLS version increases backwards (-1,-2,-3,etc) */
5666:../src/src/tls.c ****     if (isDtls)
5667:../src/src/tls.c ****         return a > b;
5668:../src/src/tls.c **** #endif /* WOLFSSL_DTLS */
5669:../src/src/tls.c **** 
5670:../src/src/tls.c ****     return a < b;
5671:../src/src/tls.c **** }
5672:../src/src/tls.c **** 
5673:../src/src/tls.c **** static WC_INLINE int versionIsAtLeast(byte isDtls, byte a, byte b)
5674:../src/src/tls.c **** {
5675:../src/src/tls.c ****     (void)isDtls;
5676:../src/src/tls.c **** 
5677:../src/src/tls.c **** #ifdef WOLFSSL_DTLS
5678:../src/src/tls.c ****     /* DTLS version increases backwards (-1,-2,-3,etc) */
5679:../src/src/tls.c ****     if (isDtls)
5680:../src/src/tls.c ****         return a <= b;
5681:../src/src/tls.c **** #endif /* WOLFSSL_DTLS */
5682:../src/src/tls.c **** 
5683:../src/src/tls.c ****     return a >= b;
5684:../src/src/tls.c **** }
5685:../src/src/tls.c **** 
5686:../src/src/tls.c **** static WC_INLINE int versionIsLessEqual(byte isDtls, byte a, byte b)
5687:../src/src/tls.c **** {
5688:../src/src/tls.c ****     (void)isDtls;
5689:../src/src/tls.c **** 
5690:../src/src/tls.c **** #ifdef WOLFSSL_DTLS
5691:../src/src/tls.c ****     /* DTLS version increases backwards (-1,-2,-3,etc) */
5692:../src/src/tls.c ****     if (isDtls)
5693:../src/src/tls.c ****         return a >= b;
5694:../src/src/tls.c **** #endif /* WOLFSSL_DTLS */
5695:../src/src/tls.c **** 
5696:../src/src/tls.c ****     return a <= b;
5697:../src/src/tls.c **** }
5698:../src/src/tls.c **** 
5699:../src/src/tls.c **** /* Return the size of the SupportedVersions extension's data.
5700:../src/src/tls.c ****  *
5701:../src/src/tls.c ****  * data       The SSL/TLS object.
5702:../src/src/tls.c ****  * msgType The type of the message this extension is being written into.
5703:../src/src/tls.c ****  * returns the length of data that will be in the extension.
5704:../src/src/tls.c ****  */
5705:../src/src/tls.c **** static int TLSX_SupportedVersions_GetSize(void* data, byte msgType, word16* pSz)
5706:../src/src/tls.c **** {
5707:../src/src/tls.c ****     WOLFSSL* ssl = (WOLFSSL*)data;
5708:../src/src/tls.c ****     byte tls13Minor, tls12Minor, tls11Minor, isDtls;
5709:../src/src/tls.c **** 
5710:../src/src/tls.c ****     isDtls = !!ssl->options.dtls;
5711:../src/src/tls.c ****     tls13Minor = (byte)(isDtls ? DTLSv1_3_MINOR : TLSv1_3_MINOR);
5712:../src/src/tls.c ****     tls12Minor = (byte)(isDtls ? DTLSv1_2_MINOR : TLSv1_2_MINOR);
5713:../src/src/tls.c ****     tls11Minor = (byte)(isDtls ? DTLS_MINOR : TLSv1_1_MINOR);
5714:../src/src/tls.c **** 
5715:../src/src/tls.c ****     /* unused on some configuration */
5716:../src/src/tls.c ****     (void)tls12Minor;
5717:../src/src/tls.c ****     (void)tls13Minor;
5718:../src/src/tls.c ****     (void)tls11Minor;
5719:../src/src/tls.c **** 
5720:../src/src/tls.c ****     if (msgType == client_hello) {
5721:../src/src/tls.c ****         /* TLS v1.2 and TLS v1.3  */
5722:../src/src/tls.c ****         int cnt = 0;
5723:../src/src/tls.c **** 
5724:../src/src/tls.c ****         if (versionIsLessEqual(isDtls, ssl->options.minDowngrade, tls13Minor)
5725:../src/src/tls.c ****         #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \
5726:../src/src/tls.c ****             defined(WOLFSSL_WPAS_SMALL)
5727:../src/src/tls.c ****             && (ssl->options.mask & SSL_OP_NO_TLSv1_3) == 0
5728:../src/src/tls.c ****         #endif
5729:../src/src/tls.c ****         ) {
5730:../src/src/tls.c ****             cnt++;
5731:../src/src/tls.c ****         }
5732:../src/src/tls.c **** 
5733:../src/src/tls.c ****         if (ssl->options.downgrade) {
5734:../src/src/tls.c ****     #ifndef WOLFSSL_NO_TLS12
5735:../src/src/tls.c ****             if (versionIsLessEqual(
5736:../src/src/tls.c ****                     isDtls, ssl->options.minDowngrade, tls12Minor)
5737:../src/src/tls.c **** #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) ||                       \
5738:../src/src/tls.c ****     defined(WOLFSSL_WPAS_SMALL)
5739:../src/src/tls.c ****                 && (ssl->options.mask & SSL_OP_NO_TLSv1_2) == 0
5740:../src/src/tls.c **** #endif
5741:../src/src/tls.c ****             ) {
5742:../src/src/tls.c ****                 cnt++;
5743:../src/src/tls.c ****             }
5744:../src/src/tls.c **** #endif
5745:../src/src/tls.c ****     #ifndef NO_OLD_TLS
5746:../src/src/tls.c ****             if (versionIsLessEqual(
5747:../src/src/tls.c ****                     isDtls, ssl->options.minDowngrade, tls11Minor)
5748:../src/src/tls.c ****             #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \
5749:../src/src/tls.c ****                 defined(WOLFSSL_WPAS_SMALL)
5750:../src/src/tls.c ****                 && (ssl->options.mask & SSL_OP_NO_TLSv1_1) == 0
5751:../src/src/tls.c ****             #endif
5752:../src/src/tls.c ****             ) {
5753:../src/src/tls.c ****                 cnt++;
5754:../src/src/tls.c ****             }
5755:../src/src/tls.c ****         #ifdef WOLFSSL_ALLOW_TLSV10
5756:../src/src/tls.c ****             if (!ssl->options.dtls && (ssl->options.minDowngrade <= TLSv1_MINOR)
5757:../src/src/tls.c ****             #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \
5758:../src/src/tls.c ****                 defined(WOLFSSL_WPAS_SMALL)
5759:../src/src/tls.c ****                 && (ssl->options.mask & SSL_OP_NO_TLSv1) == 0
5760:../src/src/tls.c ****             #endif
5761:../src/src/tls.c ****             ) {
5762:../src/src/tls.c ****                 cnt++;
5763:../src/src/tls.c ****             }
5764:../src/src/tls.c ****         #endif
5765:../src/src/tls.c ****     #endif
5766:../src/src/tls.c ****         }
5767:../src/src/tls.c **** 
5768:../src/src/tls.c ****         *pSz += (word16)(OPAQUE8_LEN + cnt * OPAQUE16_LEN);
5769:../src/src/tls.c ****     }
5770:../src/src/tls.c ****     else if (msgType == server_hello || msgType == hello_retry_request) {
5771:../src/src/tls.c ****         *pSz += OPAQUE16_LEN;
5772:../src/src/tls.c ****     }
5773:../src/src/tls.c ****     else {
5774:../src/src/tls.c ****         return SANITY_MSG_E;
5775:../src/src/tls.c ****     }
5776:../src/src/tls.c **** 
5777:../src/src/tls.c ****     return 0;
5778:../src/src/tls.c **** }
5779:../src/src/tls.c **** 
5780:../src/src/tls.c **** /* Writes the SupportedVersions extension into the buffer.
5781:../src/src/tls.c ****  *
5782:../src/src/tls.c ****  * data    The SSL/TLS object.
5783:../src/src/tls.c ****  * output  The buffer to write the extension into.
5784:../src/src/tls.c ****  * msgType The type of the message this extension is being written into.
5785:../src/src/tls.c ****  * returns the length of data that was written.
5786:../src/src/tls.c ****  */
5787:../src/src/tls.c **** static int TLSX_SupportedVersions_Write(void* data, byte* output,
5788:../src/src/tls.c ****                                         byte msgType, word16* pSz)
5789:../src/src/tls.c **** {
5790:../src/src/tls.c ****     WOLFSSL* ssl = (WOLFSSL*)data;
5791:../src/src/tls.c ****     byte major;
5792:../src/src/tls.c ****     byte* cnt;
5793:../src/src/tls.c ****     byte tls13minor, tls12minor, tls11minor, isDtls = 0;
5794:../src/src/tls.c **** 
5795:../src/src/tls.c ****     tls13minor = (byte)TLSv1_3_MINOR;
5796:../src/src/tls.c ****     tls12minor = (byte)TLSv1_2_MINOR;
5797:../src/src/tls.c ****     tls11minor = (byte)TLSv1_1_MINOR;
5798:../src/src/tls.c **** 
5799:../src/src/tls.c ****     /* unused in some configuration */
5800:../src/src/tls.c ****     (void)tls11minor;
5801:../src/src/tls.c ****     (void)tls12minor;
5802:../src/src/tls.c **** 
5803:../src/src/tls.c **** #ifdef WOLFSSL_DTLS13
5804:../src/src/tls.c ****     if (ssl->options.dtls) {
5805:../src/src/tls.c ****         tls13minor = (byte)DTLSv1_3_MINOR;
5806:../src/src/tls.c ****         tls12minor = (byte)DTLSv1_2_MINOR;
5807:../src/src/tls.c ****         tls11minor = (byte)DTLS_MINOR;
5808:../src/src/tls.c ****         isDtls = 1;
5809:../src/src/tls.c ****     }
5810:../src/src/tls.c **** #endif /* WOLFSSL_DTLS13 */
5811:../src/src/tls.c **** 
5812:../src/src/tls.c ****     if (msgType == client_hello) {
5813:../src/src/tls.c ****         major = ssl->ctx->method->version.major;
5814:../src/src/tls.c **** 
5815:../src/src/tls.c ****         cnt = output++;
5816:../src/src/tls.c ****         *cnt = 0;
5817:../src/src/tls.c **** 
5818:../src/src/tls.c ****         if (versionIsLessEqual(isDtls, ssl->options.minDowngrade, tls13minor)
5819:../src/src/tls.c **** #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) ||                       \
5820:../src/src/tls.c ****     defined(WOLFSSL_WPAS_SMALL)
5821:../src/src/tls.c ****             && (ssl->options.mask & SSL_OP_NO_TLSv1_3) == 0
5822:../src/src/tls.c **** #endif
5823:../src/src/tls.c ****         ) {
5824:../src/src/tls.c ****             *cnt += OPAQUE16_LEN;
5825:../src/src/tls.c ****         #ifdef WOLFSSL_TLS13_DRAFT
5826:../src/src/tls.c ****             /* The TLS draft major number. */
5827:../src/src/tls.c ****             *(output++) = TLS_DRAFT_MAJOR;
5828:../src/src/tls.c ****             /* Version of draft supported. */
5829:../src/src/tls.c ****             *(output++) = TLS_DRAFT_MINOR;
5830:../src/src/tls.c ****         #else
5831:../src/src/tls.c ****             *(output++) = major;
5832:../src/src/tls.c ****             *(output++) = tls13minor;
5833:../src/src/tls.c ****         #endif
5834:../src/src/tls.c ****         }
5835:../src/src/tls.c **** 
5836:../src/src/tls.c ****         if (ssl->options.downgrade) {
5837:../src/src/tls.c ****         #ifndef WOLFSSL_NO_TLS12
5838:../src/src/tls.c ****             if (versionIsLessEqual(isDtls, ssl->options.minDowngrade, tls12minor)
5839:../src/src/tls.c **** #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \
5840:../src/src/tls.c ****                 defined(WOLFSSL_WPAS_SMALL)
5841:../src/src/tls.c ****                 && (ssl->options.mask & SSL_OP_NO_TLSv1_2) == 0
5842:../src/src/tls.c ****             #endif
5843:../src/src/tls.c ****             ) {
5844:../src/src/tls.c ****                 *cnt += OPAQUE16_LEN;
5845:../src/src/tls.c ****                 *(output++) = major;
5846:../src/src/tls.c ****                 *(output++) = tls12minor;
5847:../src/src/tls.c ****             }
5848:../src/src/tls.c ****         #endif
5849:../src/src/tls.c **** 
5850:../src/src/tls.c ****     #ifndef NO_OLD_TLS
5851:../src/src/tls.c ****             if (versionIsLessEqual(isDtls, ssl->options.minDowngrade, tls11minor)
5852:../src/src/tls.c ****             #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \
5853:../src/src/tls.c ****                 defined(WOLFSSL_WPAS_SMALL)
5854:../src/src/tls.c ****                 && (ssl->options.mask & SSL_OP_NO_TLSv1_1) == 0
5855:../src/src/tls.c ****             #endif
5856:../src/src/tls.c ****             ) {
5857:../src/src/tls.c ****                 *cnt += OPAQUE16_LEN;
5858:../src/src/tls.c ****                 *(output++) = major;
5859:../src/src/tls.c ****                 *(output++) = tls11minor;
5860:../src/src/tls.c ****             }
5861:../src/src/tls.c ****         #ifdef WOLFSSL_ALLOW_TLSV10
5862:../src/src/tls.c ****             if (!ssl->options.dtls && (ssl->options.minDowngrade <= TLSv1_MINOR)
5863:../src/src/tls.c ****             #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \
5864:../src/src/tls.c ****                 defined(WOLFSSL_WPAS_SMALL)
5865:../src/src/tls.c ****                 && (ssl->options.mask & SSL_OP_NO_TLSv1) == 0
5866:../src/src/tls.c ****             #endif
5867:../src/src/tls.c ****             ) {
5868:../src/src/tls.c ****                 *cnt += OPAQUE16_LEN;
5869:../src/src/tls.c ****                 *(output++) = major;
5870:../src/src/tls.c ****                 *(output++) = (byte)TLSv1_MINOR;
5871:../src/src/tls.c ****             }
5872:../src/src/tls.c ****         #endif
5873:../src/src/tls.c ****     #endif
5874:../src/src/tls.c ****         }
5875:../src/src/tls.c **** 
5876:../src/src/tls.c ****         *pSz += (word16)(OPAQUE8_LEN + *cnt);
5877:../src/src/tls.c ****     }
5878:../src/src/tls.c ****     else if (msgType == server_hello || msgType == hello_retry_request) {
5879:../src/src/tls.c ****         output[0] = ssl->version.major;
5880:../src/src/tls.c ****         output[1] = ssl->version.minor;
5881:../src/src/tls.c **** 
5882:../src/src/tls.c ****         *pSz += OPAQUE16_LEN;
5883:../src/src/tls.c ****     }
5884:../src/src/tls.c ****     else
5885:../src/src/tls.c ****         return SANITY_MSG_E;
5886:../src/src/tls.c **** 
5887:../src/src/tls.c ****     return 0;
5888:../src/src/tls.c **** }
5889:../src/src/tls.c **** 
5890:../src/src/tls.c **** /* Parse the SupportedVersions extension.
5891:../src/src/tls.c ****  *
5892:../src/src/tls.c ****  * ssl     The SSL/TLS object.
5893:../src/src/tls.c ****  * input   The buffer with the extension data.
5894:../src/src/tls.c ****  * length  The length of the extension data.
5895:../src/src/tls.c ****  * msgType The type of the message this extension is being parsed from.
5896:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
5897:../src/src/tls.c ****  */
5898:../src/src/tls.c **** static int TLSX_SupportedVersions_Parse(WOLFSSL* ssl, const byte* input,
5899:../src/src/tls.c ****                                         word16 length, byte msgType)
5900:../src/src/tls.c **** {
5901:../src/src/tls.c ****     ProtocolVersion pv = ssl->ctx->method->version;
5902:../src/src/tls.c ****     int i;
5903:../src/src/tls.c ****     int len;
5904:../src/src/tls.c ****     byte major, minor;
5905:../src/src/tls.c ****     int newMinor = 0;
5906:../src/src/tls.c ****     int set = 0;
5907:../src/src/tls.c ****     int ret;
5908:../src/src/tls.c ****     int tls13minor;
5909:../src/src/tls.c ****     int tls12minor;
5910:../src/src/tls.c ****     byte isDtls;
5911:../src/src/tls.c **** 
5912:../src/src/tls.c ****     tls13minor = TLSv1_3_MINOR;
5913:../src/src/tls.c ****     tls12minor = TLSv1_2_MINOR;
5914:../src/src/tls.c ****     isDtls = ssl->options.dtls == 1;
5915:../src/src/tls.c **** 
5916:../src/src/tls.c **** #ifdef WOLFSSL_DTLS13
5917:../src/src/tls.c ****     if (ssl->options.dtls) {
5918:../src/src/tls.c ****         tls13minor = DTLSv1_3_MINOR;
5919:../src/src/tls.c ****         tls12minor = DTLSv1_2_MINOR;
5920:../src/src/tls.c ****     }
5921:../src/src/tls.c **** #endif /* WOLFSSL_DTLS13 */
5922:../src/src/tls.c **** 
5923:../src/src/tls.c ****     if (msgType == client_hello) {
5924:../src/src/tls.c ****         /* Must contain a length and at least one version. */
5925:../src/src/tls.c ****         if (length < OPAQUE8_LEN + OPAQUE16_LEN || (length & 1) != 1)
5926:../src/src/tls.c ****             return BUFFER_ERROR;
5927:../src/src/tls.c **** 
5928:../src/src/tls.c ****         len = *input;
5929:../src/src/tls.c **** 
5930:../src/src/tls.c ****         /* Protocol version array must fill rest of data. */
5931:../src/src/tls.c ****         if (length != (word16)OPAQUE8_LEN + len)
5932:../src/src/tls.c ****             return BUFFER_ERROR;
5933:../src/src/tls.c **** 
5934:../src/src/tls.c ****         input++;
5935:../src/src/tls.c **** 
5936:../src/src/tls.c ****         /* Find first match. */
5937:../src/src/tls.c ****         for (i = 0; i < len; i += OPAQUE16_LEN) {
5938:../src/src/tls.c ****             major = input[i];
5939:../src/src/tls.c ****             minor = input[i + OPAQUE8_LEN];
5940:../src/src/tls.c **** 
5941:../src/src/tls.c **** #ifdef WOLFSSL_TLS13_DRAFT
5942:../src/src/tls.c ****             if (major == TLS_DRAFT_MAJOR && minor == TLS_DRAFT_MINOR) {
5943:../src/src/tls.c ****                 major = SSLv3_MAJOR;
5944:../src/src/tls.c ****                 minor = TLSv1_3_MINOR;
5945:../src/src/tls.c ****             }
5946:../src/src/tls.c **** #else
5947:../src/src/tls.c ****             if (major == TLS_DRAFT_MAJOR)
5948:../src/src/tls.c ****                 continue;
5949:../src/src/tls.c **** #endif
5950:../src/src/tls.c **** 
5951:../src/src/tls.c ****             if (major != pv.major)
5952:../src/src/tls.c ****                 continue;
5953:../src/src/tls.c **** 
5954:../src/src/tls.c ****             /* No upgrade allowed. */
5955:../src/src/tls.c ****             if (versionIsGreater(isDtls, minor, ssl->version.minor))
5956:../src/src/tls.c ****                     continue;
5957:../src/src/tls.c **** 
5958:../src/src/tls.c ****             /* Check downgrade. */
5959:../src/src/tls.c ****             if (versionIsLesser(isDtls, minor, ssl->version.minor)) {
5960:../src/src/tls.c ****                 if (!ssl->options.downgrade)
5961:../src/src/tls.c ****                     continue;
5962:../src/src/tls.c **** 
5963:../src/src/tls.c ****                 if (versionIsLesser(
5964:../src/src/tls.c ****                         isDtls, minor, ssl->options.minDowngrade))
5965:../src/src/tls.c ****                     continue;
5966:../src/src/tls.c **** 
5967:../src/src/tls.c ****                 if (newMinor == 0 &&
5968:../src/src/tls.c ****                     versionIsGreater(
5969:../src/src/tls.c ****                         isDtls, minor, ssl->options.oldMinor)) {
5970:../src/src/tls.c ****                     /* Downgrade the version. */
5971:../src/src/tls.c ****                     ssl->version.minor = minor;
5972:../src/src/tls.c ****                 }
5973:../src/src/tls.c ****             }
5974:../src/src/tls.c **** 
5975:../src/src/tls.c ****             if (versionIsAtLeast(isDtls, minor, tls13minor)) {
5976:../src/src/tls.c ****                 if (!ssl->options.tls1_3) {
5977:../src/src/tls.c ****                     ssl->options.tls1_3 = 1;
5978:../src/src/tls.c ****                     ret = TLSX_Prepend(&ssl->extensions,
5979:../src/src/tls.c ****                               TLSX_SUPPORTED_VERSIONS, ssl, ssl->heap);
5980:../src/src/tls.c ****                     if (ret != 0) {
5981:../src/src/tls.c ****                         return ret;
5982:../src/src/tls.c ****                     }
5983:../src/src/tls.c ****                     TLSX_SetResponse(ssl, TLSX_SUPPORTED_VERSIONS);
5984:../src/src/tls.c ****                 }
5985:../src/src/tls.c ****                 if (versionIsGreater(isDtls, minor, newMinor)) {
5986:../src/src/tls.c ****                     ssl->version.minor = minor;
5987:../src/src/tls.c ****                     newMinor = minor;
5988:../src/src/tls.c ****                 }
5989:../src/src/tls.c ****             }
5990:../src/src/tls.c ****             else if (versionIsGreater(
5991:../src/src/tls.c ****                          isDtls, minor, ssl->options.oldMinor))
5992:../src/src/tls.c ****                 ssl->options.oldMinor = minor;
5993:../src/src/tls.c **** 
5994:../src/src/tls.c ****             set = 1;
5995:../src/src/tls.c ****         }
5996:../src/src/tls.c ****         if (!set) {
5997:../src/src/tls.c ****  #ifdef WOLFSSL_MYSQL_COMPATIBLE
5998:../src/src/tls.c ****             SendAlert(ssl, alert_fatal, wc_protocol_version);
5999:../src/src/tls.c ****  #else
6000:../src/src/tls.c ****             SendAlert(ssl, alert_fatal, protocol_version);
6001:../src/src/tls.c ****  #endif
6002:../src/src/tls.c ****             return VERSION_ERROR;
6003:../src/src/tls.c ****         }
6004:../src/src/tls.c ****     }
6005:../src/src/tls.c ****     else if (msgType == server_hello || msgType == hello_retry_request) {
6006:../src/src/tls.c ****         /* Must contain one version. */
6007:../src/src/tls.c ****         if (length != OPAQUE16_LEN)
6008:../src/src/tls.c ****             return BUFFER_ERROR;
6009:../src/src/tls.c **** 
6010:../src/src/tls.c ****         major = input[0];
6011:../src/src/tls.c ****         minor = input[OPAQUE8_LEN];
6012:../src/src/tls.c **** 
6013:../src/src/tls.c ****         if (major != pv.major)
6014:../src/src/tls.c ****             return VERSION_ERROR;
6015:../src/src/tls.c **** 
6016:../src/src/tls.c ****         /* Can't downgrade with this extension below TLS v1.3. */
6017:../src/src/tls.c ****         if (versionIsLesser(isDtls, minor, tls13minor))
6018:../src/src/tls.c ****             return VERSION_ERROR;
6019:../src/src/tls.c **** 
6020:../src/src/tls.c ****         /* Version is TLS v1.2 to handle downgrading from TLS v1.3+. */
6021:../src/src/tls.c ****         if (ssl->options.downgrade && ssl->version.minor == tls12minor) {
6022:../src/src/tls.c ****             /* Set minor version back to TLS v1.3+ */
6023:../src/src/tls.c ****             ssl->version.minor = ssl->ctx->method->version.minor;
6024:../src/src/tls.c ****         }
6025:../src/src/tls.c **** 
6026:../src/src/tls.c ****         /* No upgrade allowed. */
6027:../src/src/tls.c ****         if (versionIsLesser(isDtls, ssl->version.minor, minor))
6028:../src/src/tls.c ****             return VERSION_ERROR;
6029:../src/src/tls.c **** 
6030:../src/src/tls.c ****         /* Check downgrade. */
6031:../src/src/tls.c ****         if (versionIsGreater(isDtls, ssl->version.minor, minor)) {
6032:../src/src/tls.c ****             if (!ssl->options.downgrade)
6033:../src/src/tls.c ****                 return VERSION_ERROR;
6034:../src/src/tls.c **** 
6035:../src/src/tls.c ****             if (versionIsLesser(
6036:../src/src/tls.c ****                     isDtls, minor, ssl->options.minDowngrade))
6037:../src/src/tls.c ****                 return VERSION_ERROR;
6038:../src/src/tls.c **** 
6039:../src/src/tls.c ****             /* Downgrade the version. */
6040:../src/src/tls.c ****             ssl->version.minor = minor;
6041:../src/src/tls.c ****         }
6042:../src/src/tls.c ****     }
6043:../src/src/tls.c ****     else
6044:../src/src/tls.c ****         return SANITY_MSG_E;
6045:../src/src/tls.c **** 
6046:../src/src/tls.c ****     return 0;
6047:../src/src/tls.c **** }
6048:../src/src/tls.c **** 
6049:../src/src/tls.c **** /* Sets a new SupportedVersions extension into the extension list.
6050:../src/src/tls.c ****  *
6051:../src/src/tls.c ****  * extensions  The list of extensions.
6052:../src/src/tls.c ****  * data        The extensions specific data.
6053:../src/src/tls.c ****  * heap        The heap used for allocation.
6054:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
6055:../src/src/tls.c ****  */
6056:../src/src/tls.c **** static int TLSX_SetSupportedVersions(TLSX** extensions, const void* data,
6057:../src/src/tls.c ****                                      void* heap)
6058:../src/src/tls.c **** {
6059:../src/src/tls.c ****     if (extensions == NULL || data == NULL)
6060:../src/src/tls.c ****         return BAD_FUNC_ARG;
6061:../src/src/tls.c **** 
6062:../src/src/tls.c ****     return TLSX_Push(extensions, TLSX_SUPPORTED_VERSIONS, data, heap);
6063:../src/src/tls.c **** }
6064:../src/src/tls.c **** 
6065:../src/src/tls.c **** #define SV_GET_SIZE  TLSX_SupportedVersions_GetSize
6066:../src/src/tls.c **** #define SV_WRITE     TLSX_SupportedVersions_Write
6067:../src/src/tls.c **** #define SV_PARSE     TLSX_SupportedVersions_Parse
6068:../src/src/tls.c **** 
6069:../src/src/tls.c **** #else
6070:../src/src/tls.c **** 
6071:../src/src/tls.c **** #define SV_GET_SIZE(a, b, c) 0
6072:../src/src/tls.c **** #define SV_WRITE(a, b, c, d) 0
6073:../src/src/tls.c **** #define SV_PARSE(a, b, c, d) 0
6074:../src/src/tls.c **** 
6075:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 */
6076:../src/src/tls.c **** 
6077:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(WOLFSSL_SEND_HRR_COOKIE)
6078:../src/src/tls.c **** 
6079:../src/src/tls.c **** /******************************************************************************/
6080:../src/src/tls.c **** /* Cookie                                                                     */
6081:../src/src/tls.c **** /******************************************************************************/
6082:../src/src/tls.c **** 
6083:../src/src/tls.c **** /* Free the cookie data.
6084:../src/src/tls.c ****  *
6085:../src/src/tls.c ****  * cookie  Cookie data.
6086:../src/src/tls.c ****  * heap    The heap used for allocation.
6087:../src/src/tls.c ****  */
6088:../src/src/tls.c **** static void TLSX_Cookie_FreeAll(Cookie* cookie, void* heap)
6089:../src/src/tls.c **** {
6090:../src/src/tls.c ****     (void)heap;
6091:../src/src/tls.c **** 
6092:../src/src/tls.c ****     if (cookie != NULL)
6093:../src/src/tls.c ****         XFREE(cookie, heap, DYNAMIC_TYPE_TLSX);
6094:../src/src/tls.c **** }
6095:../src/src/tls.c **** 
6096:../src/src/tls.c **** /* Get the size of the encoded Cookie extension.
6097:../src/src/tls.c ****  * In messages: ClientHello and HelloRetryRequest.
6098:../src/src/tls.c ****  *
6099:../src/src/tls.c ****  * cookie   The cookie to write.
6100:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
6101:../src/src/tls.c ****  * returns the number of bytes of the encoded Cookie extension.
6102:../src/src/tls.c ****  */
6103:../src/src/tls.c **** static int TLSX_Cookie_GetSize(Cookie* cookie, byte msgType, word16* pSz)
6104:../src/src/tls.c **** {
6105:../src/src/tls.c ****     if (msgType == client_hello || msgType == hello_retry_request)
6106:../src/src/tls.c ****         *pSz += OPAQUE16_LEN + cookie->len;
6107:../src/src/tls.c ****     else
6108:../src/src/tls.c ****         return SANITY_MSG_E;
6109:../src/src/tls.c ****     return 0;
6110:../src/src/tls.c **** }
6111:../src/src/tls.c **** 
6112:../src/src/tls.c **** /* Writes the Cookie extension into the output buffer.
6113:../src/src/tls.c ****  * Assumes that the the output buffer is big enough to hold data.
6114:../src/src/tls.c ****  * In messages: ClientHello and HelloRetryRequest.
6115:../src/src/tls.c ****  *
6116:../src/src/tls.c ****  * cookie   The cookie to write.
6117:../src/src/tls.c ****  * output   The buffer to write into.
6118:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
6119:../src/src/tls.c ****  * returns the number of bytes written into the buffer.
6120:../src/src/tls.c ****  */
6121:../src/src/tls.c **** static int TLSX_Cookie_Write(Cookie* cookie, byte* output, byte msgType,
6122:../src/src/tls.c ****                              word16* pSz)
6123:../src/src/tls.c **** {
6124:../src/src/tls.c ****     if (msgType == client_hello || msgType == hello_retry_request) {
6125:../src/src/tls.c ****         c16toa(cookie->len, output);
6126:../src/src/tls.c ****         output += OPAQUE16_LEN;
6127:../src/src/tls.c ****         XMEMCPY(output, &cookie->data, cookie->len);
6128:../src/src/tls.c ****         *pSz += OPAQUE16_LEN + cookie->len;
6129:../src/src/tls.c ****     }
6130:../src/src/tls.c ****     else
6131:../src/src/tls.c ****         return SANITY_MSG_E;
6132:../src/src/tls.c ****     return 0;
6133:../src/src/tls.c **** }
6134:../src/src/tls.c **** 
6135:../src/src/tls.c **** /* Parse the Cookie extension.
6136:../src/src/tls.c ****  * In messages: ClientHello and HelloRetryRequest.
6137:../src/src/tls.c ****  *
6138:../src/src/tls.c ****  * ssl      The SSL/TLS object.
6139:../src/src/tls.c ****  * input    The extension data.
6140:../src/src/tls.c ****  * length   The length of the extension data.
6141:../src/src/tls.c ****  * msgType  The type of the message this extension is being parsed from.
6142:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
6143:../src/src/tls.c ****  */
6144:../src/src/tls.c **** static int TLSX_Cookie_Parse(WOLFSSL* ssl, const byte* input, word16 length,
6145:../src/src/tls.c ****                              byte msgType)
6146:../src/src/tls.c **** {
6147:../src/src/tls.c ****     word16  len;
6148:../src/src/tls.c ****     word16  idx = 0;
6149:../src/src/tls.c ****     TLSX*   extension;
6150:../src/src/tls.c ****     Cookie* cookie;
6151:../src/src/tls.c **** 
6152:../src/src/tls.c ****     if (msgType != client_hello && msgType != hello_retry_request)
6153:../src/src/tls.c ****         return SANITY_MSG_E;
6154:../src/src/tls.c **** 
6155:../src/src/tls.c ****     /* Message contains length and Cookie which must be at least one byte
6156:../src/src/tls.c ****      * in length.
6157:../src/src/tls.c ****      */
6158:../src/src/tls.c ****     if (length < OPAQUE16_LEN + 1)
6159:../src/src/tls.c ****         return BUFFER_E;
6160:../src/src/tls.c ****     ato16(input + idx, &len);
6161:../src/src/tls.c ****     idx += OPAQUE16_LEN;
6162:../src/src/tls.c ****     if (length - idx != len)
6163:../src/src/tls.c ****         return BUFFER_E;
6164:../src/src/tls.c **** 
6165:../src/src/tls.c ****     if (msgType == hello_retry_request)
6166:../src/src/tls.c ****         return TLSX_Cookie_Use(ssl, input + idx, len, NULL, 0, 0);
6167:../src/src/tls.c **** 
6168:../src/src/tls.c ****     /* client_hello */
6169:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_COOKIE);
6170:../src/src/tls.c ****     if (extension == NULL) {
6171:../src/src/tls.c **** #ifdef WOLFSSL_DTLS13
6172:../src/src/tls.c ****         if (ssl->options.dtls && IsAtLeastTLSv1_3(ssl->version))
6173:../src/src/tls.c ****             /* Allow a cookie extension with DTLS 1.3 because it is possible
6174:../src/src/tls.c ****              * that a different SSL instance sent the cookie but we are now
6175:../src/src/tls.c ****              * receiving it. */
6176:../src/src/tls.c ****             return TLSX_Cookie_Use(ssl, input + idx, len, NULL, 0, 0);
6177:../src/src/tls.c ****         else
6178:../src/src/tls.c **** #endif
6179:../src/src/tls.c ****             return HRR_COOKIE_ERROR;
6180:../src/src/tls.c ****     }
6181:../src/src/tls.c **** 
6182:../src/src/tls.c ****     cookie = (Cookie*)extension->data;
6183:../src/src/tls.c ****     if (cookie->len != len || XMEMCMP(&cookie->data, input + idx, len) != 0)
6184:../src/src/tls.c ****         return HRR_COOKIE_ERROR;
6185:../src/src/tls.c **** 
6186:../src/src/tls.c ****     /* Request seen. */
6187:../src/src/tls.c ****     extension->resp = 0;
6188:../src/src/tls.c **** 
6189:../src/src/tls.c ****     return 0;
6190:../src/src/tls.c **** }
6191:../src/src/tls.c **** 
6192:../src/src/tls.c **** /* Use the data to create a new Cookie object in the extensions.
6193:../src/src/tls.c ****  *
6194:../src/src/tls.c ****  * ssl    SSL/TLS object.
6195:../src/src/tls.c ****  * data   Cookie data.
6196:../src/src/tls.c ****  * len    Length of cookie data in bytes.
6197:../src/src/tls.c ****  * mac    MAC data.
6198:../src/src/tls.c ****  * macSz  Length of MAC data in bytes.
6199:../src/src/tls.c ****  * resp   Indicates the extension will go into a response (HelloRetryRequest).
6200:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
6201:../src/src/tls.c ****  */
6202:../src/src/tls.c **** int TLSX_Cookie_Use(WOLFSSL* ssl, const byte* data, word16 len, byte* mac,
6203:../src/src/tls.c ****                     byte macSz, int resp)
6204:../src/src/tls.c **** {
6205:../src/src/tls.c ****     int     ret = 0;
6206:../src/src/tls.c ****     TLSX*   extension;
6207:../src/src/tls.c ****     Cookie* cookie;
6208:../src/src/tls.c **** 
6209:../src/src/tls.c ****     /* Find the cookie extension if it exists. */
6210:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_COOKIE);
6211:../src/src/tls.c ****     if (extension == NULL) {
6212:../src/src/tls.c ****         /* Push new cookie extension. */
6213:../src/src/tls.c ****         ret = TLSX_Push(&ssl->extensions, TLSX_COOKIE, NULL, ssl->heap);
6214:../src/src/tls.c ****         if (ret != 0)
6215:../src/src/tls.c ****             return ret;
6216:../src/src/tls.c **** 
6217:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_COOKIE);
6218:../src/src/tls.c ****         if (extension == NULL)
6219:../src/src/tls.c ****             return MEMORY_E;
6220:../src/src/tls.c ****     }
6221:../src/src/tls.c **** 
6222:../src/src/tls.c ****     /* The Cookie structure has one byte for cookie data already. */
6223:../src/src/tls.c ****     cookie = (Cookie*)XMALLOC(sizeof(Cookie) + len + macSz - 1, ssl->heap,
6224:../src/src/tls.c ****                               DYNAMIC_TYPE_TLSX);
6225:../src/src/tls.c ****     if (cookie == NULL)
6226:../src/src/tls.c ****         return MEMORY_E;
6227:../src/src/tls.c **** 
6228:../src/src/tls.c ****     cookie->len = len + macSz;
6229:../src/src/tls.c ****     XMEMCPY(&cookie->data, data, len);
6230:../src/src/tls.c ****     if (mac != NULL)
6231:../src/src/tls.c ****         XMEMCPY(&cookie->data + len, mac, macSz);
6232:../src/src/tls.c **** 
6233:../src/src/tls.c ****     if (extension->data != NULL)
6234:../src/src/tls.c ****         XFREE(extension->data, ssl->heap, DYNAMIC_TYPE_TLSX);
6235:../src/src/tls.c **** 
6236:../src/src/tls.c ****     extension->data = (void*)cookie;
6237:../src/src/tls.c ****     extension->resp = (byte)resp;
6238:../src/src/tls.c **** 
6239:../src/src/tls.c ****     return 0;
6240:../src/src/tls.c **** }
6241:../src/src/tls.c **** 
6242:../src/src/tls.c **** #define CKE_FREE_ALL  TLSX_Cookie_FreeAll
6243:../src/src/tls.c **** #define CKE_GET_SIZE  TLSX_Cookie_GetSize
6244:../src/src/tls.c **** #define CKE_WRITE     TLSX_Cookie_Write
6245:../src/src/tls.c **** #define CKE_PARSE     TLSX_Cookie_Parse
6246:../src/src/tls.c **** 
6247:../src/src/tls.c **** #else
6248:../src/src/tls.c **** 
6249:../src/src/tls.c **** #define CKE_FREE_ALL(a, b)    0
6250:../src/src/tls.c **** #define CKE_GET_SIZE(a, b, c) 0
6251:../src/src/tls.c **** #define CKE_WRITE(a, b, c, d) 0
6252:../src/src/tls.c **** #define CKE_PARSE(a, b, c, d) 0
6253:../src/src/tls.c **** 
6254:../src/src/tls.c **** #endif
6255:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
6256:../src/src/tls.c **** /******************************************************************************/
6257:../src/src/tls.c **** /* Signature Algorithms                                                       */
6258:../src/src/tls.c **** /******************************************************************************/
6259:../src/src/tls.c **** 
6260:../src/src/tls.c **** /* Return the size of the SignatureAlgorithms extension's data.
6261:../src/src/tls.c ****  *
6262:../src/src/tls.c ****  * data  Unused
6263:../src/src/tls.c ****  * returns the length of data that will be in the extension.
6264:../src/src/tls.c ****  */
6265:../src/src/tls.c **** 
6266:../src/src/tls.c **** static word16 TLSX_SignatureAlgorithms_GetSize(void* data)
6267:../src/src/tls.c **** {
 5524                             		.loc 2 6267 1
 5525 0000 7E AA                   		push.l	r10
 5526                             	.LCFI139:
 5527 0002 71 0A F8                		add	#-8, r0, r10
 5528                             	.LCFI140:
 5529 0005 EF A0                   		mov.L	r10, r0
 5530 0007 E7 A1 01                		mov.L	r1, 4[r10]
6268:../src/src/tls.c ****     WOLFSSL* ssl = (WOLFSSL*)data;
 5531                             		.loc 2 6268 14
 5532 000a ED A5 01                		mov.L	4[r10], r5
 5533 000d E3 A5                   		mov.L	r5, [r10]
6269:../src/src/tls.c **** 
6270:../src/src/tls.c ****     return OPAQUE16_LEN + ssl->suites->hashSigAlgoSz;
 5534                             		.loc 2 6270 30
 5535 000f EC A5                   		mov.L	[r10], r5
 5536 0011 A8 5D                   		mov.L	4[r5], r5
 5537                             		.loc 2 6270 38
 5538 0013 98 5D                   		mov.W	2[r5], r5
 5539                             		.loc 2 6270 25
 5540 0015 62 25                   		add	#2, r5
 5541 0017 5F 55                   		movu.W	r5, r5
6271:../src/src/tls.c **** }
 5542                             		.loc 2 6271 1
 5543 0019 EF 51                   		mov.L	r5, r1
 5544 001b 3F AA 03                		rtsd	#12, r10-r10
 5545                             	.LFE95:
 5547                             		.section	.text.TLSX_SignatureAlgorithms_MapPss,"ax",@progbits
 5549                             	_TLSX_SignatureAlgorithms_MapPss:
 5550                             	.LFB96:
6272:../src/src/tls.c **** 
6273:../src/src/tls.c **** /* Creates a bit string of supported hash algorithms with RSA PSS.
6274:../src/src/tls.c ****  * The bit string is used when determining which signature algorithm to use
6275:../src/src/tls.c ****  * when creating the CertificateVerify message.
6276:../src/src/tls.c ****  * Note: Valid data has an even length as each signature algorithm is two bytes.
6277:../src/src/tls.c ****  *
6278:../src/src/tls.c ****  * ssl     The SSL/TLS object.
6279:../src/src/tls.c ****  * input   The buffer with the list of supported signature algorithms.
6280:../src/src/tls.c ****  * length  The length of the list in bytes.
6281:../src/src/tls.c ****  * returns 0 on success, BUFFER_ERROR when the length is not even.
6282:../src/src/tls.c ****  */
6283:../src/src/tls.c **** static int TLSX_SignatureAlgorithms_MapPss(WOLFSSL *ssl, const byte* input,
6284:../src/src/tls.c ****                                            word16 length)
6285:../src/src/tls.c **** {
 5551                             		.loc 2 6285 1
 5552 0000 6E 7A                   		pushm	r7-r10
 5553                             	.LCFI141:
 5554 0002 71 0A F0                		add	#-16, r0, r10
 5555                             	.LCFI142:
 5556 0005 EF A0                   		mov.L	r10, r0
 5557 0007 E7 A1 01                		mov.L	r1, 4[r10]
 5558 000a E7 A2 02                		mov.L	r2, 8[r10]
 5559 000d D7 A3 06                		mov.W	r3, 12[r10]
6286:../src/src/tls.c ****     word16 i;
6287:../src/src/tls.c **** 
6288:../src/src/tls.c ****     if ((length & 1) == 1)
 5560                             		.loc 2 6288 17
 5561 0010 5D A5 06                		movu.W	12[r10], r5
 5562 0013 64 15                   		and	#1, r5
 5563                             		.loc 2 6288 8
 5564 0015 61 05                   		cmp	#0, r5
 5565 0017 17                      		beq	.L400
6289:../src/src/tls.c ****         return BUFFER_ERROR;
 5566                             		.loc 2 6289 16
 5567 0018 FB 5A B8 FE             		mov.L	#-328, r5
 5568 001c 2E 6A                   		bra	.L401
 5569                             	.L400:
6290:../src/src/tls.c **** 
6291:../src/src/tls.c ****     ssl->pssAlgo = 0;
 5570                             		.loc 2 6291 18
 5571 001e ED A5 01                		mov.L	4[r10], r5
 5572 0021 FA 55 62 01 00          		mov.W	#0, 708[r5]
6292:../src/src/tls.c ****     for (i = 0; i < length; i += 2) {
 5573                             		.loc 2 6292 12
 5574 0026 F8 A5 00                		mov.W	#0, [r10]
 5575                             		.loc 2 6292 5
 5576 0029 2E 52                   		bra	.L402
 5577                             	.L404:
6293:../src/src/tls.c ****         if (input[i] == rsa_pss_sa_algo && input[i + 1] <= sha512_mac)
 5578                             		.loc 2 6293 18
 5579 002b 5C A5                   		movu.W	[r10], r5
 5580 002d ED A4 02                		mov.L	8[r10], r4
 5581 0030 4B 45                   		add	r4, r5
 5582 0032 CC 55                   		mov.B	[r5], r5
 5583                             		.loc 2 6293 12
 5584 0034 5B 55                   		movu.B	r5, r5
 5585 0036 61 85                   		cmp	#8, r5
 5586 0038 21 3D                   		bne	.L403
 5587                             		.loc 2 6293 49 discriminator 1
 5588 003a 5C A5                   		movu.W	[r10], r5
 5589 003c 62 15                   		add	#1, r5
 5590 003e ED A4 02                		mov.L	8[r10], r4
 5591 0041 4B 45                   		add	r4, r5
 5592 0043 CC 55                   		mov.B	[r5], r5
 5593                             		.loc 2 6293 41 discriminator 1
 5594 0045 5B 55                   		movu.B	r5, r5
 5595 0047 61 65                   		cmp	#6, r5
 5596 0049 24 2C                   		bgtu	.L403
6294:../src/src/tls.c ****             ssl->pssAlgo |= 1 << input[i + 1];
 5597                             		.loc 2 6294 26
 5598 004b ED A5 01                		mov.L	4[r10], r5
 5599 004e DE 55 62 01             		mov.W	708[r5], r5
 5600 0052 DF 54                   		mov.W	r5, r4
 5601                             		.loc 2 6294 39
 5602 0054 5C A5                   		movu.W	[r10], r5
 5603 0056 62 15                   		add	#1, r5
 5604 0058 ED A3 02                		mov.L	8[r10], r3
 5605 005b 4B 35                   		add	r3, r5
 5606 005d CC 55                   		mov.B	[r5], r5
 5607 005f 5B 55                   		movu.B	r5, r5
 5608                             		.loc 2 6294 31
 5609 0061 66 13                   		mov.L	#1, r3
 5610 0063 EF 37                   		mov.L	r3, r7
 5611 0065 FD 62 57                		shll	r5, r7
 5612 0068 EF 75                   		mov.L	r7, r5
 5613                             		.loc 2 6294 26
 5614 006a 57 45                   		or	r4, r5
 5615 006c DF 54                   		mov.W	r5, r4
 5616 006e ED A5 01                		mov.L	4[r10], r5
 5617 0071 DB 54 62 01             		mov.W	r4, 708[r5]
 5618                             	.L403:
6292:../src/src/tls.c ****     for (i = 0; i < length; i += 2) {
 5619                             		.loc 2 6292 31 discriminator 2
 5620 0075 DC A5                   		mov.W	[r10], r5
 5621 0077 62 25                   		add	#2, r5
 5622 0079 D3 A5                   		mov.W	r5, [r10]
 5623                             	.L402:
6292:../src/src/tls.c ****     for (i = 0; i < length; i += 2) {
 5624                             		.loc 2 6292 5 discriminator 1
 5625 007b 5C A4                   		movu.W	[r10], r4
 5626 007d 5D A5 06                		movu.W	12[r10], r5
 5627 0080 47 54                   		cmp	r5, r4
 5628 0082 23 A9                   		bltu	.L404
6295:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
6296:../src/src/tls.c ****         if (input[i] == rsa_pss_sa_algo && input[i + 1] >= pss_sha256 &&
6297:../src/src/tls.c ****                                                    input[i + 1] <= pss_sha512) {
6298:../src/src/tls.c ****             ssl->pssAlgo |= 1 << input[i + 1];
6299:../src/src/tls.c ****         }
6300:../src/src/tls.c ****     #endif
6301:../src/src/tls.c ****     }
6302:../src/src/tls.c **** 
6303:../src/src/tls.c ****     return 0;
 5629                             		.loc 2 6303 12
 5630 0084 66 05                   		mov.L	#0, r5
 5631                             	.L401:
6304:../src/src/tls.c **** }
 5632                             		.loc 2 6304 1
 5633 0086 EF 51                   		mov.L	r5, r1
 5634 0088 3F 7A 08                		rtsd	#32, r7-r10
 5635                             	.LFE96:
 5637                             		.section	.text.TLSX_SignatureAlgorithms_Write,"ax",@progbits
 5639                             	_TLSX_SignatureAlgorithms_Write:
 5640                             	.LFB97:
6305:../src/src/tls.c **** 
6306:../src/src/tls.c **** /* Writes the SignatureAlgorithms extension into the buffer.
6307:../src/src/tls.c ****  *
6308:../src/src/tls.c ****  * data    Unused
6309:../src/src/tls.c ****  * output  The buffer to write the extension into.
6310:../src/src/tls.c ****  * returns the length of data that was written.
6311:../src/src/tls.c ****  */
6312:../src/src/tls.c **** static word16 TLSX_SignatureAlgorithms_Write(void* data, byte* output)
6313:../src/src/tls.c **** {
 5641                             		.loc 2 6313 1
 5642 0000 7E AA                   		push.l	r10
 5643                             	.LCFI143:
 5644 0002 71 0A F4                		add	#-12, r0, r10
 5645                             	.LCFI144:
 5646 0005 EF A0                   		mov.L	r10, r0
 5647 0007 E7 A1 01                		mov.L	r1, 4[r10]
 5648 000a E7 A2 02                		mov.L	r2, 8[r10]
6314:../src/src/tls.c ****     WOLFSSL* ssl = (WOLFSSL*)data;
 5649                             		.loc 2 6314 14
 5650 000d ED A5 01                		mov.L	4[r10], r5
 5651 0010 E3 A5                   		mov.L	r5, [r10]
6315:../src/src/tls.c **** 
6316:../src/src/tls.c ****     c16toa(ssl->suites->hashSigAlgoSz, output);
 5652                             		.loc 2 6316 15
 5653 0012 EC A5                   		mov.L	[r10], r5
 5654 0014 A8 5D                   		mov.L	4[r5], r5
 5655                             		.loc 2 6316 5
 5656 0016 98 5D                   		mov.W	2[r5], r5
 5657 0018 ED A2 02                		mov.L	8[r10], r2
 5658 001b DF 51                   		mov.W	r5, r1
 5659 001d 05 00 00 00             		bsr	_c16toa
6317:../src/src/tls.c ****     XMEMCPY(output + OPAQUE16_LEN, ssl->suites->hashSigAlgo,
 5660                             		.loc 2 6317 5
 5661 0021 ED A5 02                		mov.L	8[r10], r5
 5662 0024 71 54 02                		add	#2, r5, r4
 5663 0027 EC A5                   		mov.L	[r10], r5
 5664 0029 A8 5D                   		mov.L	4[r5], r5
 5665 002b 72 52 30 01             		add	#0x130, r5, r2
 5666 002f EC A5                   		mov.L	[r10], r5
 5667 0031 A8 5D                   		mov.L	4[r5], r5
 5668 0033 98 5D                   		mov.W	2[r5], r5
 5669 0035 5F 55                   		movu.W	r5, r5
 5670 0037 EF 53                   		mov.L	r5, r3
 5671 0039 EF 41                   		mov.L	r4, r1
 5672 003b 05 00 00 00             		bsr	_memcpy
6318:../src/src/tls.c ****             ssl->suites->hashSigAlgoSz);
6319:../src/src/tls.c **** 
6320:../src/src/tls.c ****     TLSX_SignatureAlgorithms_MapPss(ssl, output + OPAQUE16_LEN,
 5673                             		.loc 2 6320 49
 5674 003f ED A5 02                		mov.L	8[r10], r5
 5675 0042 71 54 02                		add	#2, r5, r4
6321:../src/src/tls.c ****                                     ssl->suites->hashSigAlgoSz);
 5676                             		.loc 2 6321 40
 5677 0045 EC A5                   		mov.L	[r10], r5
 5678 0047 A8 5D                   		mov.L	4[r5], r5
6320:../src/src/tls.c ****                                     ssl->suites->hashSigAlgoSz);
 5679                             		.loc 2 6320 5
 5680 0049 98 5D                   		mov.W	2[r5], r5
 5681 004b DF 53                   		mov.W	r5, r3
 5682 004d EF 42                   		mov.L	r4, r2
 5683 004f EC A1                   		mov.L	[r10], r1
 5684 0051 05 00 00 00             		bsr	_TLSX_SignatureAlgorithms_MapPss
6322:../src/src/tls.c **** 
6323:../src/src/tls.c ****     return OPAQUE16_LEN + ssl->suites->hashSigAlgoSz;
 5685                             		.loc 2 6323 30
 5686 0055 EC A5                   		mov.L	[r10], r5
 5687 0057 A8 5D                   		mov.L	4[r5], r5
 5688                             		.loc 2 6323 38
 5689 0059 98 5D                   		mov.W	2[r5], r5
 5690                             		.loc 2 6323 25
 5691 005b 62 25                   		add	#2, r5
 5692 005d 5F 55                   		movu.W	r5, r5
6324:../src/src/tls.c **** }
 5693                             		.loc 2 6324 1
 5694 005f EF 51                   		mov.L	r5, r1
 5695 0061 3F AA 04                		rtsd	#16, r10-r10
 5696                             	.LFE97:
 5698                             		.section C,"a",@progbits
 5699 004b 00                      		.p2align 2
 5700                             	.LC2:
 5701 004c 54 4C 53 58 20 53 69 67 		.string	"TLSX SigAlgo list exceeds max, truncating"
 5701      41 6C 67 6F 20 6C 69 73 
 5701      74 20 65 78 63 65 65 64 
 5701      73 20 6D 61 78 2C 20 74 
 5701      72 75 6E 63 61 74 69 6E 
 5702                             		.section	.text.TLSX_SignatureAlgorithms_Parse,"ax",@progbits
 5704                             	_TLSX_SignatureAlgorithms_Parse:
 5705                             	.LFB98:
6325:../src/src/tls.c **** 
6326:../src/src/tls.c **** /* Parse the SignatureAlgorithms extension.
6327:../src/src/tls.c ****  *
6328:../src/src/tls.c ****  * ssl     The SSL/TLS object.
6329:../src/src/tls.c ****  * input   The buffer with the extension data.
6330:../src/src/tls.c ****  * length  The length of the extension data.
6331:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
6332:../src/src/tls.c ****  */
6333:../src/src/tls.c **** static int TLSX_SignatureAlgorithms_Parse(WOLFSSL *ssl, const byte* input,
6334:../src/src/tls.c ****                                   word16 length, byte isRequest, Suites* suites)
6335:../src/src/tls.c **** {
 5706                             		.loc 2 6335 1
 5707 0000 7E AA                   		push.l	r10
 5708                             	.LCFI145:
 5709 0002 7E A6                   		push.l	r6
 5710                             	.LCFI146:
 5711 0004 71 0A EC                		add	#-20, r0, r10
 5712                             	.LCFI147:
 5713 0007 EF A0                   		mov.L	r10, r0
 5714 0009 75 46 20                		mov.L	#32, r6
 5715 000c 4B A6                   		add	r10, r6
 5716 000e E7 A1 01                		mov.L	r1, 4[r10]
 5717 0011 E7 A2 02                		mov.L	r2, 8[r10]
 5718 0014 D7 A3 06                		mov.W	r3, 12[r10]
 5719 0017 C7 A4 0E                		mov.B	r4, 14[r10]
6336:../src/src/tls.c ****     word16 len;
6337:../src/src/tls.c **** 
6338:../src/src/tls.c ****     if (!isRequest)
 5720                             		.loc 2 6338 8
 5721 001a 59 A5 0E                		movu.B	14[r10], r5
 5722 001d 61 05                   		cmp	#0, r5
 5723 001f 18                      		bne	.L408
6339:../src/src/tls.c ****         return BUFFER_ERROR;
 5724                             		.loc 2 6339 16
 5725 0020 FB 5A B8 FE             		mov.L	#-328, r5
 5726 0024 38 94 00                		bra	.L415
 5727                             	.L408:
6340:../src/src/tls.c **** 
6341:../src/src/tls.c ****     /* Must contain a length and at least algorithm. */
6342:../src/src/tls.c ****     if (length < OPAQUE16_LEN + OPAQUE16_LEN || (length & 1) != 0)
 5728                             		.loc 2 6342 8
 5729 0027 5D A5 06                		movu.W	12[r10], r5
 5730 002a 61 35                   		cmp	#3, r5
 5731 002c 25 0A                   		bleu	.L410
 5732                             		.loc 2 6342 57 discriminator 1
 5733 002e 5D A5 06                		movu.W	12[r10], r5
 5734 0031 64 15                   		and	#1, r5
 5735                             		.loc 2 6342 46 discriminator 1
 5736 0033 61 05                   		cmp	#0, r5
 5737 0035 17                      		beq	.L411
 5738                             	.L410:
6343:../src/src/tls.c ****         return BUFFER_ERROR;
 5739                             		.loc 2 6343 16
 5740 0036 FB 5A B8 FE             		mov.L	#-328, r5
 5741 003a 2E 7E                   		bra	.L415
 5742                             	.L411:
6344:../src/src/tls.c **** 
6345:../src/src/tls.c ****     ato16(input, &len);
 5743                             		.loc 2 6345 5
 5744 003c EF A2                   		mov.L	r10, r2
 5745 003e ED A1 02                		mov.L	8[r10], r1
 5746 0041 05 00 00 00             		bsr	_ato16
6346:../src/src/tls.c ****     input += OPAQUE16_LEN;
 5747                             		.loc 2 6346 11
 5748 0045 ED A5 02                		mov.L	8[r10], r5
 5749 0048 62 25                   		add	#2, r5
 5750 004a E7 A5 02                		mov.L	r5, 8[r10]
6347:../src/src/tls.c **** 
6348:../src/src/tls.c ****     /* Algorithm array must fill rest of data. */
6349:../src/src/tls.c ****     if (length != OPAQUE16_LEN + len)
 5751                             		.loc 2 6349 16
 5752 004d 5D A4 06                		movu.W	12[r10], r4
 5753                             		.loc 2 6349 32
 5754 0050 DC A5                   		mov.W	[r10], r5
 5755 0052 5F 55                   		movu.W	r5, r5
 5756 0054 62 25                   		add	#2, r5
 5757                             		.loc 2 6349 8
 5758 0056 47 54                   		cmp	r5, r4
 5759 0058 17                      		beq	.L412
6350:../src/src/tls.c ****         return BUFFER_ERROR;
 5760                             		.loc 2 6350 16
 5761 0059 FB 5A B8 FE             		mov.L	#-328, r5
 5762 005d 2E 5B                   		bra	.L415
 5763                             	.L412:
6351:../src/src/tls.c **** 
6352:../src/src/tls.c ****     /* Sig Algo list size must be even. */
6353:../src/src/tls.c ****     if (suites->hashSigAlgoSz % 2 != 0)
 5764                             		.loc 2 6353 15
 5765 005f EC 65                   		mov.L	[r6], r5
 5766 0061 98 5D                   		mov.W	2[r5], r5
 5767                             		.loc 2 6353 35
 5768 0063 64 15                   		and	#1, r5
 5769                             		.loc 2 6353 8
 5770 0065 5F 55                   		movu.W	r5, r5
 5771 0067 61 05                   		cmp	#0, r5
 5772 0069 17                      		beq	.L413
6354:../src/src/tls.c ****         return BUFFER_ERROR;
 5773                             		.loc 2 6354 16
 5774 006a FB 5A B8 FE             		mov.L	#-328, r5
 5775 006e 2E 4A                   		bra	.L415
 5776                             	.L413:
6355:../src/src/tls.c **** 
6356:../src/src/tls.c ****     /* truncate hashSigAlgo list if too long */
6357:../src/src/tls.c ****     suites->hashSigAlgoSz = len;
 5777                             		.loc 2 6357 27
 5778 0070 DC A4                   		mov.W	[r10], r4
 5779 0072 EC 65                   		mov.L	[r6], r5
 5780 0074 90 5C                   		mov.W	r4, 2[r5]
6358:../src/src/tls.c ****     if (suites->hashSigAlgoSz > WOLFSSL_MAX_SIGALGO) {
 5781                             		.loc 2 6358 15
 5782 0076 EC 65                   		mov.L	[r6], r5
 5783 0078 98 5D                   		mov.W	2[r5], r5
 5784                             		.loc 2 6358 8
 5785 007a 5F 55                   		movu.W	r5, r5
 5786 007c 75 55 26                		cmp	#38, r5
 5787 007f 25 11                   		bleu	.L414
6359:../src/src/tls.c ****         WOLFSSL_MSG("TLSX SigAlgo list exceeds max, truncating");
 5788                             		.loc 2 6359 9
 5789 0081 FB 12 4C 00 00 00       		mov.L	#.LC2, r1
 5790 0087 05 00 00 00             		bsr	_WOLFSSL_MSG
6360:../src/src/tls.c ****         suites->hashSigAlgoSz = WOLFSSL_MAX_SIGALGO;
 5791                             		.loc 2 6360 31
 5792 008b EC 65                   		mov.L	[r6], r5
 5793 008d 3D 51 26                		mov.W	#38, 2[r5]
 5794                             	.L414:
6361:../src/src/tls.c ****     }
6362:../src/src/tls.c ****     XMEMCPY(suites->hashSigAlgo, input, suites->hashSigAlgoSz);
 5795                             		.loc 2 6362 5
 5796 0090 EC 65                   		mov.L	[r6], r5
 5797 0092 72 54 30 01             		add	#0x130, r5, r4
 5798 0096 EC 65                   		mov.L	[r6], r5
 5799 0098 98 5D                   		mov.W	2[r5], r5
 5800 009a 5F 55                   		movu.W	r5, r5
 5801 009c EF 53                   		mov.L	r5, r3
 5802 009e ED A2 02                		mov.L	8[r10], r2
 5803 00a1 EF 41                   		mov.L	r4, r1
 5804 00a3 05 00 00 00             		bsr	_memcpy
6363:../src/src/tls.c **** 
6364:../src/src/tls.c ****     return TLSX_SignatureAlgorithms_MapPss(ssl, input, len);
 5805                             		.loc 2 6364 12
 5806 00a7 DC A5                   		mov.W	[r10], r5
 5807 00a9 DF 53                   		mov.W	r5, r3
 5808 00ab ED A2 02                		mov.L	8[r10], r2
 5809 00ae ED A1 01                		mov.L	4[r10], r1
 5810 00b1 05 00 00 00             		bsr	_TLSX_SignatureAlgorithms_MapPss
 5811 00b5 EF 15                   		mov.L	r1, r5
 5812 00b7 03                      		.balign 8,3,1
 5813                             	.L415:
6365:../src/src/tls.c **** }
 5814                             		.loc 2 6365 1 discriminator 1
 5815 00b8 EF 51                   		mov.L	r5, r1
 5816 00ba 71 00 14                		add	#20, r0
 5817 00bd 7E B6                   		pop	r6
 5818 00bf 7E BA                   		pop	r10
 5819 00c1 02                      		rts
 5820                             	.LFE98:
 5822 00c2 74 10 01 00 00 00       		.section	.text.TLSX_SetSignatureAlgorithms,"ax",@progbits
 5824                             	_TLSX_SetSignatureAlgorithms:
 5825                             	.LFB99:
6366:../src/src/tls.c **** 
6367:../src/src/tls.c **** /* Sets a new SignatureAlgorithms extension into the extension list.
6368:../src/src/tls.c ****  *
6369:../src/src/tls.c ****  * extensions  The list of extensions.
6370:../src/src/tls.c ****  * data        The extensions specific data.
6371:../src/src/tls.c ****  * heap        The heap used for allocation.
6372:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
6373:../src/src/tls.c ****  */
6374:../src/src/tls.c **** static int TLSX_SetSignatureAlgorithms(TLSX** extensions, const void* data,
6375:../src/src/tls.c ****                                        void* heap)
6376:../src/src/tls.c **** {
 5826                             		.loc 2 6376 1
 5827 0000 7E AA                   		push.l	r10
 5828                             	.LCFI148:
 5829 0002 71 0A F4                		add	#-12, r0, r10
 5830                             	.LCFI149:
 5831 0005 EF A0                   		mov.L	r10, r0
 5832 0007 E3 A1                   		mov.L	r1, [r10]
 5833 0009 E7 A2 01                		mov.L	r2, 4[r10]
 5834 000c E7 A3 02                		mov.L	r3, 8[r10]
6377:../src/src/tls.c ****     if (extensions == NULL)
 5835                             		.loc 2 6377 8
 5836 000f EC A5                   		mov.L	[r10], r5
 5837 0011 61 05                   		cmp	#0, r5
 5838 0013 1F                      		bne	.L417
6378:../src/src/tls.c ****         return BAD_FUNC_ARG;
 5839                             		.loc 2 6378 16
 5840 0014 FB 5A 53 FF             		mov.L	#-173, r5
 5841 0018 2E 12                   		bra	.L418
 5842                             	.L417:
6379:../src/src/tls.c **** 
6380:../src/src/tls.c ****     return TLSX_Push(extensions, TLSX_SIGNATURE_ALGORITHMS, data, heap);
 5843                             		.loc 2 6380 12
 5844 001a ED A4 02                		mov.L	8[r10], r4
 5845 001d ED A3 01                		mov.L	4[r10], r3
 5846 0020 66 D2                   		mov.L	#13, r2
 5847 0022 EC A1                   		mov.L	[r10], r1
 5848 0024 05 00 00 00             		bsr	_TLSX_Push
 5849 0028 EF 15                   		mov.L	r1, r5
 5850                             	.L418:
6381:../src/src/tls.c **** }
 5851                             		.loc 2 6381 1
 5852 002a EF 51                   		mov.L	r5, r1
 5853 002c 3F AA 04                		rtsd	#16, r10-r10
 5854                             	.LFE99:
 5856                             		.section	.text.TLSX_Find,"ax",@progbits
 5857                             		.global	_TLSX_Find
 5859                             	_TLSX_Find:
 5860                             	.LFB100:
6382:../src/src/tls.c **** 
6383:../src/src/tls.c **** #define SA_GET_SIZE  TLSX_SignatureAlgorithms_GetSize
6384:../src/src/tls.c **** #define SA_WRITE     TLSX_SignatureAlgorithms_Write
6385:../src/src/tls.c **** #define SA_PARSE     TLSX_SignatureAlgorithms_Parse
6386:../src/src/tls.c **** #endif
6387:../src/src/tls.c **** /******************************************************************************/
6388:../src/src/tls.c **** /* Signature Algorithms Certificate                                           */
6389:../src/src/tls.c **** /******************************************************************************/
6390:../src/src/tls.c **** 
6391:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
6392:../src/src/tls.c **** /* Return the size of the SignatureAlgorithms extension's data.
6393:../src/src/tls.c ****  *
6394:../src/src/tls.c ****  * data  Unused
6395:../src/src/tls.c ****  * returns the length of data that will be in the extension.
6396:../src/src/tls.c ****  */
6397:../src/src/tls.c **** static word16 TLSX_SignatureAlgorithmsCert_GetSize(void* data)
6398:../src/src/tls.c **** {
6399:../src/src/tls.c ****     WOLFSSL* ssl = (WOLFSSL*)data;
6400:../src/src/tls.c **** 
6401:../src/src/tls.c ****     return OPAQUE16_LEN + ssl->certHashSigAlgoSz;
6402:../src/src/tls.c **** }
6403:../src/src/tls.c **** 
6404:../src/src/tls.c **** /* Writes the SignatureAlgorithmsCert extension into the buffer.
6405:../src/src/tls.c ****  *
6406:../src/src/tls.c ****  * data    Unused
6407:../src/src/tls.c ****  * output  The buffer to write the extension into.
6408:../src/src/tls.c ****  * returns the length of data that was written.
6409:../src/src/tls.c ****  */
6410:../src/src/tls.c **** static word16 TLSX_SignatureAlgorithmsCert_Write(void* data, byte* output)
6411:../src/src/tls.c **** {
6412:../src/src/tls.c ****     WOLFSSL* ssl = (WOLFSSL*)data;
6413:../src/src/tls.c **** 
6414:../src/src/tls.c ****     c16toa(ssl->certHashSigAlgoSz, output);
6415:../src/src/tls.c ****     XMEMCPY(output + OPAQUE16_LEN, ssl->certHashSigAlgo,
6416:../src/src/tls.c ****             ssl->certHashSigAlgoSz);
6417:../src/src/tls.c **** 
6418:../src/src/tls.c ****     return OPAQUE16_LEN + ssl->certHashSigAlgoSz;
6419:../src/src/tls.c **** }
6420:../src/src/tls.c **** 
6421:../src/src/tls.c **** /* Parse the SignatureAlgorithmsCert extension.
6422:../src/src/tls.c ****  *
6423:../src/src/tls.c ****  * ssl     The SSL/TLS object.
6424:../src/src/tls.c ****  * input   The buffer with the extension data.
6425:../src/src/tls.c ****  * length  The length of the extension data.
6426:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
6427:../src/src/tls.c ****  */
6428:../src/src/tls.c **** static int TLSX_SignatureAlgorithmsCert_Parse(WOLFSSL *ssl, const byte* input,
6429:../src/src/tls.c ****                                               word16 length, byte isRequest)
6430:../src/src/tls.c **** {
6431:../src/src/tls.c ****     word16 len;
6432:../src/src/tls.c **** 
6433:../src/src/tls.c ****     if (!isRequest)
6434:../src/src/tls.c ****         return BUFFER_ERROR;
6435:../src/src/tls.c **** 
6436:../src/src/tls.c ****     /* Must contain a length and at least algorithm. */
6437:../src/src/tls.c ****     if (length < OPAQUE16_LEN + OPAQUE16_LEN || (length & 1) != 0)
6438:../src/src/tls.c ****         return BUFFER_ERROR;
6439:../src/src/tls.c **** 
6440:../src/src/tls.c ****     ato16(input, &len);
6441:../src/src/tls.c ****     input += OPAQUE16_LEN;
6442:../src/src/tls.c **** 
6443:../src/src/tls.c ****     /* Algorithm array must fill rest of data. */
6444:../src/src/tls.c ****     if (length != OPAQUE16_LEN + len)
6445:../src/src/tls.c ****         return BUFFER_ERROR;
6446:../src/src/tls.c **** 
6447:../src/src/tls.c ****     /* truncate hashSigAlgo list if too long */
6448:../src/src/tls.c ****     ssl->certHashSigAlgoSz = len;
6449:../src/src/tls.c ****     if (ssl->certHashSigAlgoSz > WOLFSSL_MAX_SIGALGO) {
6450:../src/src/tls.c ****         WOLFSSL_MSG("TLSX SigAlgo list exceeds max, truncating");
6451:../src/src/tls.c ****         ssl->certHashSigAlgoSz = WOLFSSL_MAX_SIGALGO;
6452:../src/src/tls.c ****     }
6453:../src/src/tls.c ****     XMEMCPY(ssl->certHashSigAlgo, input, ssl->certHashSigAlgoSz);
6454:../src/src/tls.c **** 
6455:../src/src/tls.c ****     return 0;
6456:../src/src/tls.c **** }
6457:../src/src/tls.c **** 
6458:../src/src/tls.c **** /* Sets a new SignatureAlgorithmsCert extension into the extension list.
6459:../src/src/tls.c ****  *
6460:../src/src/tls.c ****  * extensions  The list of extensions.
6461:../src/src/tls.c ****  * data        The extensions specific data.
6462:../src/src/tls.c ****  * heap        The heap used for allocation.
6463:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
6464:../src/src/tls.c ****  */
6465:../src/src/tls.c **** static int TLSX_SetSignatureAlgorithmsCert(TLSX** extensions, const void* data,
6466:../src/src/tls.c ****                                            void* heap)
6467:../src/src/tls.c **** {
6468:../src/src/tls.c ****     if (extensions == NULL)
6469:../src/src/tls.c ****         return BAD_FUNC_ARG;
6470:../src/src/tls.c **** 
6471:../src/src/tls.c ****     return TLSX_Push(extensions, TLSX_SIGNATURE_ALGORITHMS_CERT, data, heap);
6472:../src/src/tls.c **** }
6473:../src/src/tls.c **** 
6474:../src/src/tls.c **** #define SAC_GET_SIZE  TLSX_SignatureAlgorithmsCert_GetSize
6475:../src/src/tls.c **** #define SAC_WRITE     TLSX_SignatureAlgorithmsCert_Write
6476:../src/src/tls.c **** #define SAC_PARSE     TLSX_SignatureAlgorithmsCert_Parse
6477:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 */
6478:../src/src/tls.c **** 
6479:../src/src/tls.c **** 
6480:../src/src/tls.c **** /******************************************************************************/
6481:../src/src/tls.c **** /* Key Share                                                                  */
6482:../src/src/tls.c **** /******************************************************************************/
6483:../src/src/tls.c **** 
6484:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_SUPPORTED_CURVES)
6485:../src/src/tls.c **** /* Create a key share entry using named Diffie-Hellman parameters group.
6486:../src/src/tls.c ****  * Generates a key pair.
6487:../src/src/tls.c ****  *
6488:../src/src/tls.c ****  * ssl   The SSL/TLS object.
6489:../src/src/tls.c ****  * kse   The key share entry object.
6490:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
6491:../src/src/tls.c ****  */
6492:../src/src/tls.c **** static int TLSX_KeyShare_GenDhKey(WOLFSSL *ssl, KeyShareEntry* kse)
6493:../src/src/tls.c **** {
6494:../src/src/tls.c ****     int ret = 0;
6495:../src/src/tls.c **** #if !defined(NO_DH) && (!defined(NO_CERTS) || !defined(NO_PSK))
6496:../src/src/tls.c ****     word32 pSz = 0, pvtSz = 0;
6497:../src/src/tls.c ****     DhKey* dhKey = (DhKey*)kse->key;
6498:../src/src/tls.c **** 
6499:../src/src/tls.c ****     /* Pick the parameters from the named group. */
6500:../src/src/tls.c **** #ifdef HAVE_PUBLIC_FFDHE
6501:../src/src/tls.c ****     const DhParams* params = NULL;
6502:../src/src/tls.c ****     switch (kse->group) {
6503:../src/src/tls.c ****     #ifdef HAVE_FFDHE_2048
6504:../src/src/tls.c ****         case WOLFSSL_FFDHE_2048:
6505:../src/src/tls.c ****             params = wc_Dh_ffdhe2048_Get();
6506:../src/src/tls.c ****             kse->keyLen = 29;
6507:../src/src/tls.c ****             break;
6508:../src/src/tls.c ****     #endif
6509:../src/src/tls.c ****     #ifdef HAVE_FFDHE_3072
6510:../src/src/tls.c ****         case WOLFSSL_FFDHE_3072:
6511:../src/src/tls.c ****             params = wc_Dh_ffdhe3072_Get();
6512:../src/src/tls.c ****             kse->keyLen = 34;
6513:../src/src/tls.c ****             break;
6514:../src/src/tls.c ****     #endif
6515:../src/src/tls.c ****     #ifdef HAVE_FFDHE_4096
6516:../src/src/tls.c ****         case WOLFSSL_FFDHE_4096:
6517:../src/src/tls.c ****             params = wc_Dh_ffdhe4096_Get();
6518:../src/src/tls.c ****             kse->keyLen = 39;
6519:../src/src/tls.c ****             break;
6520:../src/src/tls.c ****     #endif
6521:../src/src/tls.c ****     #ifdef HAVE_FFDHE_6144
6522:../src/src/tls.c ****         case WOLFSSL_FFDHE_6144:
6523:../src/src/tls.c ****             params = wc_Dh_ffdhe6144_Get();
6524:../src/src/tls.c ****             kse->keyLen = 46;
6525:../src/src/tls.c ****             break;
6526:../src/src/tls.c ****     #endif
6527:../src/src/tls.c ****     #ifdef HAVE_FFDHE_8192
6528:../src/src/tls.c ****         case WOLFSSL_FFDHE_8192:
6529:../src/src/tls.c ****             params = wc_Dh_ffdhe8192_Get();
6530:../src/src/tls.c ****             kse->keyLen = 52;
6531:../src/src/tls.c ****             break;
6532:../src/src/tls.c ****     #endif
6533:../src/src/tls.c ****         default:
6534:../src/src/tls.c ****             break;
6535:../src/src/tls.c ****     }
6536:../src/src/tls.c ****     if (params == NULL)
6537:../src/src/tls.c ****         return BAD_FUNC_ARG;
6538:../src/src/tls.c ****     pSz = params->p_len;
6539:../src/src/tls.c ****     pvtSz = kse->keyLen;
6540:../src/src/tls.c **** #else
6541:../src/src/tls.c ****     kse->keyLen = wc_DhGetNamedKeyMinSize(kse->group);
6542:../src/src/tls.c ****     if (kse->keyLen == 0) {
6543:../src/src/tls.c ****         return BAD_FUNC_ARG;
6544:../src/src/tls.c ****     }
6545:../src/src/tls.c ****     ret = wc_DhGetNamedKeyParamSize(kse->group, &pSz, NULL, NULL);
6546:../src/src/tls.c ****     if (ret != 0) {
6547:../src/src/tls.c ****         return BAD_FUNC_ARG;
6548:../src/src/tls.c ****     }
6549:../src/src/tls.c ****     pvtSz = kse->keyLen;
6550:../src/src/tls.c **** #endif
6551:../src/src/tls.c ****     kse->pubKeyLen = pSz;
6552:../src/src/tls.c **** 
6553:../src/src/tls.c ****     /* Trigger Key Generation */
6554:../src/src/tls.c ****     if (kse->pubKey == NULL || kse->privKey == NULL) {
6555:../src/src/tls.c ****         if (kse->key == NULL) {
6556:../src/src/tls.c ****             kse->key = (DhKey*)XMALLOC(sizeof(DhKey), ssl->heap,
6557:../src/src/tls.c ****                 DYNAMIC_TYPE_DH);
6558:../src/src/tls.c ****             if (kse->key == NULL)
6559:../src/src/tls.c ****                 return MEMORY_E;
6560:../src/src/tls.c **** 
6561:../src/src/tls.c ****             /* Setup Key */
6562:../src/src/tls.c ****             ret = wc_InitDhKey_ex((DhKey*)kse->key, ssl->heap, ssl->devId);
6563:../src/src/tls.c ****             if (ret == 0) {
6564:../src/src/tls.c ****                 dhKey = (DhKey*)kse->key;
6565:../src/src/tls.c ****             #ifdef HAVE_PUBLIC_FFDHE
6566:../src/src/tls.c ****                 ret = wc_DhSetKey(dhKey, params->p, params->p_len, params->g,
6567:../src/src/tls.c ****                                                                  params->g_len);
6568:../src/src/tls.c ****             #else
6569:../src/src/tls.c ****                 ret = wc_DhSetNamedKey(dhKey, kse->group);
6570:../src/src/tls.c ****             #endif
6571:../src/src/tls.c ****             }
6572:../src/src/tls.c ****         }
6573:../src/src/tls.c **** 
6574:../src/src/tls.c ****         /* Allocate space for the private and public key */
6575:../src/src/tls.c ****         if (ret == 0 && kse->pubKey == NULL) {
6576:../src/src/tls.c ****             kse->pubKey = (byte*)XMALLOC(kse->pubKeyLen, ssl->heap,
6577:../src/src/tls.c ****                 DYNAMIC_TYPE_PUBLIC_KEY);
6578:../src/src/tls.c ****             if (kse->pubKey == NULL)
6579:../src/src/tls.c ****                 ret = MEMORY_E;
6580:../src/src/tls.c ****         }
6581:../src/src/tls.c **** 
6582:../src/src/tls.c ****         if (ret == 0 && kse->privKey == NULL) {
6583:../src/src/tls.c ****             kse->privKey = (byte*)XMALLOC(kse->keyLen, ssl->heap,
6584:../src/src/tls.c ****                 DYNAMIC_TYPE_PRIVATE_KEY);
6585:../src/src/tls.c ****             if (kse->privKey == NULL)
6586:../src/src/tls.c ****                 ret = MEMORY_E;
6587:../src/src/tls.c ****         }
6588:../src/src/tls.c **** 
6589:../src/src/tls.c ****         if (ret == 0) {
6590:../src/src/tls.c ****         #if defined(WOLFSSL_STATIC_EPHEMERAL) && defined(WOLFSSL_DH_EXTRA)
6591:../src/src/tls.c ****             ret = wolfSSL_StaticEphemeralKeyLoad(ssl, WC_PK_TYPE_DH, kse->key);
6592:../src/src/tls.c ****             if (ret == 0) {
6593:../src/src/tls.c ****                 ret = wc_DhExportKeyPair(dhKey,
6594:../src/src/tls.c ****                     (byte*)kse->privKey, &kse->keyLen, /* private */
6595:../src/src/tls.c ****                     kse->pubKey, &kse->pubKeyLen /* public */
6596:../src/src/tls.c ****                 );
6597:../src/src/tls.c ****             }
6598:../src/src/tls.c ****             else
6599:../src/src/tls.c ****         #endif
6600:../src/src/tls.c ****             {
6601:../src/src/tls.c ****                 /* Generate a new key pair */
6602:../src/src/tls.c ****                 /* For async this is called once and when event is done, the
6603:../src/src/tls.c ****                  *   provided buffers will be populated.
6604:../src/src/tls.c ****                  * Final processing is zero pad below. */
6605:../src/src/tls.c ****                 ret = DhGenKeyPair(ssl, dhKey,
6606:../src/src/tls.c ****                     (byte*)kse->privKey, &kse->keyLen, /* private */
6607:../src/src/tls.c ****                     kse->pubKey, &kse->pubKeyLen /* public */
6608:../src/src/tls.c ****                 );
6609:../src/src/tls.c ****             #ifdef WOLFSSL_ASYNC_CRYPT
6610:../src/src/tls.c ****                 if (ret == WC_PENDING_E) {
6611:../src/src/tls.c ****                     return ret;
6612:../src/src/tls.c ****                 }
6613:../src/src/tls.c ****             #endif
6614:../src/src/tls.c ****             }
6615:../src/src/tls.c ****         }
6616:../src/src/tls.c ****     }
6617:../src/src/tls.c **** 
6618:../src/src/tls.c ****     if (ret == 0) {
6619:../src/src/tls.c ****         if (pSz != kse->pubKeyLen) {
6620:../src/src/tls.c ****             /* Zero pad the front of the public key to match prime "p" size */
6621:../src/src/tls.c ****             XMEMMOVE(kse->pubKey + pSz - kse->pubKeyLen, kse->pubKey,
6622:../src/src/tls.c ****                 kse->pubKeyLen);
6623:../src/src/tls.c ****             XMEMSET(kse->pubKey, 0, pSz - kse->pubKeyLen);
6624:../src/src/tls.c ****             kse->pubKeyLen = pSz;
6625:../src/src/tls.c ****         }
6626:../src/src/tls.c **** 
6627:../src/src/tls.c ****         if (pvtSz != kse->keyLen) {
6628:../src/src/tls.c ****             /* Zero pad the front of the private key */
6629:../src/src/tls.c ****             XMEMMOVE(kse->privKey + pvtSz - kse->keyLen, kse->privKey,
6630:../src/src/tls.c ****                 kse->keyLen);
6631:../src/src/tls.c ****             XMEMSET(kse->privKey, 0, pvtSz - kse->keyLen);
6632:../src/src/tls.c ****             kse->keyLen = pvtSz;
6633:../src/src/tls.c ****         }
6634:../src/src/tls.c **** 
6635:../src/src/tls.c ****     #ifdef WOLFSSL_DEBUG_TLS
6636:../src/src/tls.c ****         WOLFSSL_MSG("Public DH Key");
6637:../src/src/tls.c ****         WOLFSSL_BUFFER(kse->pubKey, kse->pubKeyLen);
6638:../src/src/tls.c ****     #endif
6639:../src/src/tls.c ****     }
6640:../src/src/tls.c **** 
6641:../src/src/tls.c ****     /* Always release the DH key to free up memory.
6642:../src/src/tls.c ****      * The DhKey will be setup again in TLSX_KeyShare_ProcessDh */
6643:../src/src/tls.c ****     if (dhKey != NULL)
6644:../src/src/tls.c ****         wc_FreeDhKey(dhKey);
6645:../src/src/tls.c ****     if (kse->key != NULL) {
6646:../src/src/tls.c ****         XFREE(kse->key, ssl->heap, DYNAMIC_TYPE_DH);
6647:../src/src/tls.c ****         kse->key = NULL;
6648:../src/src/tls.c ****     }
6649:../src/src/tls.c **** 
6650:../src/src/tls.c ****     if (ret != 0) {
6651:../src/src/tls.c ****         /* Cleanup on error, otherwise data owned by key share entry */
6652:../src/src/tls.c ****         if (kse->privKey != NULL) {
6653:../src/src/tls.c ****             XFREE(kse->privKey, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
6654:../src/src/tls.c ****             kse->privKey = NULL;
6655:../src/src/tls.c ****         }
6656:../src/src/tls.c ****         if (kse->pubKey != NULL) {
6657:../src/src/tls.c ****             XFREE(kse->pubKey, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
6658:../src/src/tls.c ****             kse->pubKey = NULL;
6659:../src/src/tls.c ****         }
6660:../src/src/tls.c ****     }
6661:../src/src/tls.c **** #else
6662:../src/src/tls.c ****     (void)ssl;
6663:../src/src/tls.c ****     (void)kse;
6664:../src/src/tls.c **** 
6665:../src/src/tls.c ****     ret = NOT_COMPILED_IN;
6666:../src/src/tls.c **** #endif
6667:../src/src/tls.c **** 
6668:../src/src/tls.c ****     return ret;
6669:../src/src/tls.c **** }
6670:../src/src/tls.c **** 
6671:../src/src/tls.c **** /* Create a key share entry using X25519 parameters group.
6672:../src/src/tls.c ****  * Generates a key pair.
6673:../src/src/tls.c ****  *
6674:../src/src/tls.c ****  * ssl   The SSL/TLS object.
6675:../src/src/tls.c ****  * kse   The key share entry object.
6676:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
6677:../src/src/tls.c ****  */
6678:../src/src/tls.c **** static int TLSX_KeyShare_GenX25519Key(WOLFSSL *ssl, KeyShareEntry* kse)
6679:../src/src/tls.c **** {
6680:../src/src/tls.c ****     int ret = 0;
6681:../src/src/tls.c **** #ifdef HAVE_CURVE25519
6682:../src/src/tls.c ****     curve25519_key* key = (curve25519_key*)kse->key;
6683:../src/src/tls.c **** 
6684:../src/src/tls.c ****     if (kse->key == NULL) {
6685:../src/src/tls.c ****         /* Allocate a Curve25519 key to hold private key. */
6686:../src/src/tls.c ****         kse->key = (curve25519_key*)XMALLOC(sizeof(curve25519_key), ssl->heap,
6687:../src/src/tls.c ****                                                       DYNAMIC_TYPE_PRIVATE_KEY);
6688:../src/src/tls.c ****         if (kse->key == NULL) {
6689:../src/src/tls.c ****             WOLFSSL_MSG("GenX25519Key memory error");
6690:../src/src/tls.c ****             return MEMORY_E;
6691:../src/src/tls.c ****         }
6692:../src/src/tls.c **** 
6693:../src/src/tls.c ****         /* Make an Curve25519 key. */
6694:../src/src/tls.c ****         ret = wc_curve25519_init_ex((curve25519_key*)kse->key, ssl->heap,
6695:../src/src/tls.c ****             INVALID_DEVID);
6696:../src/src/tls.c ****         if (ret == 0) {
6697:../src/src/tls.c ****             /* setting "key" means okay to call wc_curve25519_free */
6698:../src/src/tls.c ****             key = (curve25519_key*)kse->key;
6699:../src/src/tls.c **** 
6700:../src/src/tls.c ****         #ifdef WOLFSSL_STATIC_EPHEMERAL
6701:../src/src/tls.c ****             ret = wolfSSL_StaticEphemeralKeyLoad(ssl, WC_PK_TYPE_CURVE25519, kse->key);
6702:../src/src/tls.c ****             if (ret != 0)
6703:../src/src/tls.c ****         #endif
6704:../src/src/tls.c ****             {
6705:../src/src/tls.c ****                 ret = wc_curve25519_make_key(ssl->rng, CURVE25519_KEYSIZE, key);
6706:../src/src/tls.c ****             }
6707:../src/src/tls.c ****         }
6708:../src/src/tls.c ****     }
6709:../src/src/tls.c **** 
6710:../src/src/tls.c ****     if (ret == 0 && kse->pubKey == NULL) {
6711:../src/src/tls.c ****         /* Allocate space for the public key. */
6712:../src/src/tls.c ****         kse->pubKey = (byte*)XMALLOC(CURVE25519_KEYSIZE, ssl->heap,
6713:../src/src/tls.c ****                                                        DYNAMIC_TYPE_PUBLIC_KEY);
6714:../src/src/tls.c ****         if (kse->pubKey == NULL) {
6715:../src/src/tls.c ****             WOLFSSL_MSG("GenX25519Key pub memory error");
6716:../src/src/tls.c ****             ret = MEMORY_E;
6717:../src/src/tls.c ****         }
6718:../src/src/tls.c ****     }
6719:../src/src/tls.c **** 
6720:../src/src/tls.c ****     if (ret == 0) {
6721:../src/src/tls.c ****         /* Export Curve25519 public key. */
6722:../src/src/tls.c ****         kse->pubKeyLen = CURVE25519_KEYSIZE;
6723:../src/src/tls.c ****         if (wc_curve25519_export_public_ex(key, kse->pubKey, &kse->pubKeyLen,
6724:../src/src/tls.c ****                                                   EC25519_LITTLE_ENDIAN) != 0) {
6725:../src/src/tls.c ****             ret = ECC_EXPORT_ERROR;
6726:../src/src/tls.c ****         }
6727:../src/src/tls.c ****         kse->pubKeyLen = CURVE25519_KEYSIZE; /* always CURVE25519_KEYSIZE */
6728:../src/src/tls.c ****     }
6729:../src/src/tls.c **** 
6730:../src/src/tls.c **** #ifdef WOLFSSL_DEBUG_TLS
6731:../src/src/tls.c ****     if (ret == 0) {
6732:../src/src/tls.c ****         WOLFSSL_MSG("Public Curve25519 Key");
6733:../src/src/tls.c ****         WOLFSSL_BUFFER(kse->pubKey, kse->pubKeyLen);
6734:../src/src/tls.c ****     }
6735:../src/src/tls.c **** #endif
6736:../src/src/tls.c **** 
6737:../src/src/tls.c ****     if (ret != 0) {
6738:../src/src/tls.c ****         /* Data owned by key share entry otherwise. */
6739:../src/src/tls.c ****         if (kse->pubKey != NULL) {
6740:../src/src/tls.c ****             XFREE(kse->pubKey, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
6741:../src/src/tls.c ****             kse->pubKey = NULL;
6742:../src/src/tls.c ****         }
6743:../src/src/tls.c ****         if (key != NULL)
6744:../src/src/tls.c ****             wc_curve25519_free(key);
6745:../src/src/tls.c ****         if (kse->key != NULL) {
6746:../src/src/tls.c ****             XFREE(kse->key, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
6747:../src/src/tls.c ****             kse->key = NULL;
6748:../src/src/tls.c ****         }
6749:../src/src/tls.c ****     }
6750:../src/src/tls.c **** #else
6751:../src/src/tls.c ****     (void)ssl;
6752:../src/src/tls.c ****     (void)kse;
6753:../src/src/tls.c **** 
6754:../src/src/tls.c ****     ret = NOT_COMPILED_IN;
6755:../src/src/tls.c **** #endif /* HAVE_CURVE25519 */
6756:../src/src/tls.c **** 
6757:../src/src/tls.c ****     return ret;
6758:../src/src/tls.c **** }
6759:../src/src/tls.c **** 
6760:../src/src/tls.c **** /* Create a key share entry using X448 parameters group.
6761:../src/src/tls.c ****  * Generates a key pair.
6762:../src/src/tls.c ****  *
6763:../src/src/tls.c ****  * ssl   The SSL/TLS object.
6764:../src/src/tls.c ****  * kse   The key share entry object.
6765:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
6766:../src/src/tls.c ****  */
6767:../src/src/tls.c **** static int TLSX_KeyShare_GenX448Key(WOLFSSL *ssl, KeyShareEntry* kse)
6768:../src/src/tls.c **** {
6769:../src/src/tls.c ****     int ret = 0;
6770:../src/src/tls.c **** #ifdef HAVE_CURVE448
6771:../src/src/tls.c ****     curve448_key* key = (curve448_key*)kse->key;
6772:../src/src/tls.c **** 
6773:../src/src/tls.c ****     if (kse->key == NULL) {
6774:../src/src/tls.c ****         /* Allocate a Curve448 key to hold private key. */
6775:../src/src/tls.c ****         kse->key = (curve448_key*)XMALLOC(sizeof(curve448_key), ssl->heap,
6776:../src/src/tls.c ****                                                       DYNAMIC_TYPE_PRIVATE_KEY);
6777:../src/src/tls.c ****         if (kse->key == NULL) {
6778:../src/src/tls.c ****             WOLFSSL_MSG("GenX448Key memory error");
6779:../src/src/tls.c ****             return MEMORY_E;
6780:../src/src/tls.c ****         }
6781:../src/src/tls.c **** 
6782:../src/src/tls.c ****         /* Make an Curve448 key. */
6783:../src/src/tls.c ****         ret = wc_curve448_init((curve448_key*)kse->key);
6784:../src/src/tls.c ****         if (ret == 0) {
6785:../src/src/tls.c ****             key = (curve448_key*)kse->key;
6786:../src/src/tls.c **** 
6787:../src/src/tls.c ****             #ifdef WOLFSSL_STATIC_EPHEMERAL
6788:../src/src/tls.c ****             ret = wolfSSL_StaticEphemeralKeyLoad(ssl, WC_PK_TYPE_CURVE448, kse->key);
6789:../src/src/tls.c ****             if (ret != 0)
6790:../src/src/tls.c ****         #endif
6791:../src/src/tls.c ****             {
6792:../src/src/tls.c ****                 ret = wc_curve448_make_key(ssl->rng, CURVE448_KEY_SIZE, key);
6793:../src/src/tls.c ****             }
6794:../src/src/tls.c ****         }
6795:../src/src/tls.c ****     }
6796:../src/src/tls.c **** 
6797:../src/src/tls.c ****     if (ret == 0 && kse->pubKey == NULL) {
6798:../src/src/tls.c ****         /* Allocate space for the public key. */
6799:../src/src/tls.c ****         kse->pubKey = (byte*)XMALLOC(CURVE448_KEY_SIZE, ssl->heap,
6800:../src/src/tls.c ****                                                        DYNAMIC_TYPE_PUBLIC_KEY);
6801:../src/src/tls.c ****         if (kse->pubKey == NULL) {
6802:../src/src/tls.c ****             WOLFSSL_MSG("GenX448Key pub memory error");
6803:../src/src/tls.c ****             ret = MEMORY_E;
6804:../src/src/tls.c ****         }
6805:../src/src/tls.c ****     }
6806:../src/src/tls.c **** 
6807:../src/src/tls.c ****     if (ret == 0) {
6808:../src/src/tls.c ****         /* Export Curve448 public key. */
6809:../src/src/tls.c ****         kse->pubKeyLen = CURVE448_KEY_SIZE;
6810:../src/src/tls.c ****         if (wc_curve448_export_public_ex(key, kse->pubKey, &kse->pubKeyLen,
6811:../src/src/tls.c ****                                                     EC448_LITTLE_ENDIAN) != 0) {
6812:../src/src/tls.c ****             ret = ECC_EXPORT_ERROR;
6813:../src/src/tls.c ****         }
6814:../src/src/tls.c ****         kse->pubKeyLen = CURVE448_KEY_SIZE; /* always CURVE448_KEY_SIZE */
6815:../src/src/tls.c ****     }
6816:../src/src/tls.c **** 
6817:../src/src/tls.c **** #ifdef WOLFSSL_DEBUG_TLS
6818:../src/src/tls.c ****     if (ret == 0) {
6819:../src/src/tls.c ****         WOLFSSL_MSG("Public Curve448 Key");
6820:../src/src/tls.c ****         WOLFSSL_BUFFER(kse->pubKey, kse->pubKeyLen);
6821:../src/src/tls.c ****     }
6822:../src/src/tls.c **** #endif
6823:../src/src/tls.c **** 
6824:../src/src/tls.c ****     if (ret != 0) {
6825:../src/src/tls.c ****         /* Data owned by key share entry otherwise. */
6826:../src/src/tls.c ****         if (kse->pubKey != NULL) {
6827:../src/src/tls.c ****             XFREE(kse->pubKey, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
6828:../src/src/tls.c ****             kse->pubKey = NULL;
6829:../src/src/tls.c ****         }
6830:../src/src/tls.c ****         if (key != NULL)
6831:../src/src/tls.c ****             wc_curve448_free(key);
6832:../src/src/tls.c ****         if (kse->key != NULL) {
6833:../src/src/tls.c ****             XFREE(kse->key, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
6834:../src/src/tls.c ****             kse->key = NULL;
6835:../src/src/tls.c ****         }
6836:../src/src/tls.c ****     }
6837:../src/src/tls.c **** #else
6838:../src/src/tls.c ****     (void)ssl;
6839:../src/src/tls.c ****     (void)kse;
6840:../src/src/tls.c **** 
6841:../src/src/tls.c ****     ret = NOT_COMPILED_IN;
6842:../src/src/tls.c **** #endif /* HAVE_CURVE448 */
6843:../src/src/tls.c **** 
6844:../src/src/tls.c ****     return ret;
6845:../src/src/tls.c **** }
6846:../src/src/tls.c **** 
6847:../src/src/tls.c **** /* Create a key share entry using named elliptic curve parameters group.
6848:../src/src/tls.c ****  * Generates a key pair.
6849:../src/src/tls.c ****  *
6850:../src/src/tls.c ****  * ssl   The SSL/TLS object.
6851:../src/src/tls.c ****  * kse   The key share entry object.
6852:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
6853:../src/src/tls.c ****  */
6854:../src/src/tls.c **** static int TLSX_KeyShare_GenEccKey(WOLFSSL *ssl, KeyShareEntry* kse)
6855:../src/src/tls.c **** {
6856:../src/src/tls.c ****     int ret = 0;
6857:../src/src/tls.c **** #if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)
6858:../src/src/tls.c ****     word32 keySize = 0;
6859:../src/src/tls.c ****     word16 curveId = (word16) ECC_CURVE_INVALID;
6860:../src/src/tls.c ****     ecc_key* eccKey = (ecc_key*)kse->key;
6861:../src/src/tls.c **** 
6862:../src/src/tls.c ****     /* TODO: [TLS13] The key sizes should come from wolfcrypt. */
6863:../src/src/tls.c ****     /* Translate named group to a curve id. */
6864:../src/src/tls.c ****     switch (kse->group) {
6865:../src/src/tls.c ****     #if (!defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
6866:../src/src/tls.c ****         #ifndef NO_ECC_SECP
6867:../src/src/tls.c ****         case WOLFSSL_ECC_SECP256R1:
6868:../src/src/tls.c ****             curveId = ECC_SECP256R1;
6869:../src/src/tls.c ****             keySize = 32;
6870:../src/src/tls.c ****             break;
6871:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
6872:../src/src/tls.c ****     #endif
6873:../src/src/tls.c ****     #if (defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 384
6874:../src/src/tls.c ****         #ifndef NO_ECC_SECP
6875:../src/src/tls.c ****         case WOLFSSL_ECC_SECP384R1:
6876:../src/src/tls.c ****             curveId = ECC_SECP384R1;
6877:../src/src/tls.c ****             keySize = 48;
6878:../src/src/tls.c ****             break;
6879:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
6880:../src/src/tls.c ****     #endif
6881:../src/src/tls.c ****     #if (defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 521
6882:../src/src/tls.c ****         #ifndef NO_ECC_SECP
6883:../src/src/tls.c ****         case WOLFSSL_ECC_SECP521R1:
6884:../src/src/tls.c ****             curveId = ECC_SECP521R1;
6885:../src/src/tls.c ****             keySize = 66;
6886:../src/src/tls.c ****             break;
6887:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
6888:../src/src/tls.c ****     #endif
6889:../src/src/tls.c ****         default:
6890:../src/src/tls.c ****             return BAD_FUNC_ARG;
6891:../src/src/tls.c ****     }
6892:../src/src/tls.c **** 
6893:../src/src/tls.c ****     if (kse->key == NULL) {
6894:../src/src/tls.c ****         kse->keyLen = keySize;
6895:../src/src/tls.c ****         kse->pubKeyLen = keySize * 2 + 1;
6896:../src/src/tls.c **** 
6897:../src/src/tls.c ****     #if defined(WOLFSSL_RENESAS_TSIP_TLS) && (WOLFSSL_RENESAS_TSIP_VER >= 115)
6898:../src/src/tls.c ****         ret = tsip_Tls13GenEccKeyPair(ssl, kse);
6899:../src/src/tls.c ****         if (ret != CRYPTOCB_UNAVAILABLE) {
6900:../src/src/tls.c ****             return ret;
6901:../src/src/tls.c ****         }
6902:../src/src/tls.c ****     #endif
6903:../src/src/tls.c ****         /* Allocate an ECC key to hold private key. */
6904:../src/src/tls.c ****         kse->key = (byte*)XMALLOC(sizeof(ecc_key), ssl->heap, DYNAMIC_TYPE_ECC);
6905:../src/src/tls.c ****         if (kse->key == NULL) {
6906:../src/src/tls.c ****             WOLFSSL_MSG("EccTempKey Memory error");
6907:../src/src/tls.c ****             return MEMORY_E;
6908:../src/src/tls.c ****         }
6909:../src/src/tls.c **** 
6910:../src/src/tls.c ****         /* Make an ECC key */
6911:../src/src/tls.c ****         ret = wc_ecc_init_ex((ecc_key*)kse->key, ssl->heap, ssl->devId);
6912:../src/src/tls.c ****         if (ret == 0) {
6913:../src/src/tls.c ****             /* setting eccKey means okay to call wc_ecc_free */
6914:../src/src/tls.c ****             eccKey = (ecc_key*)kse->key;
6915:../src/src/tls.c **** 
6916:../src/src/tls.c ****         #ifdef WOLFSSL_STATIC_EPHEMERAL
6917:../src/src/tls.c ****             ret = wolfSSL_StaticEphemeralKeyLoad(ssl, WC_PK_TYPE_ECDH, kse->key);
6918:../src/src/tls.c ****             if (ret != 0)
6919:../src/src/tls.c ****         #endif
6920:../src/src/tls.c ****             {
6921:../src/src/tls.c ****                 /* set curve info for EccMakeKey "peer" info */
6922:../src/src/tls.c ****                 ret = wc_ecc_set_curve(eccKey, kse->keyLen, curveId);
6923:../src/src/tls.c ****                 if (ret == 0) {
6924:../src/src/tls.c ****                     /* Generate ephemeral ECC key */
6925:../src/src/tls.c ****                     /* For async this is called once and when event is done, the
6926:../src/src/tls.c ****                     *   provided buffers in key be populated.
6927:../src/src/tls.c ****                     * Final processing is x963 key export below. */
6928:../src/src/tls.c ****                     ret = EccMakeKey(ssl, eccKey, eccKey);
6929:../src/src/tls.c ****                 }
6930:../src/src/tls.c ****             #ifdef WOLFSSL_ASYNC_CRYPT
6931:../src/src/tls.c ****                 if (ret == WC_PENDING_E)
6932:../src/src/tls.c ****                     return ret;
6933:../src/src/tls.c ****             #endif
6934:../src/src/tls.c ****             }
6935:../src/src/tls.c ****         }
6936:../src/src/tls.c ****     }
6937:../src/src/tls.c **** 
6938:../src/src/tls.c ****     if (ret == 0 && kse->pubKey == NULL) {
6939:../src/src/tls.c ****         /* Allocate space for the public key */
6940:../src/src/tls.c ****         kse->pubKey = (byte*)XMALLOC(kse->pubKeyLen, ssl->heap,
6941:../src/src/tls.c ****             DYNAMIC_TYPE_PUBLIC_KEY);
6942:../src/src/tls.c ****         if (kse->pubKey == NULL) {
6943:../src/src/tls.c ****             WOLFSSL_MSG("Key data Memory error");
6944:../src/src/tls.c ****             ret = MEMORY_E;
6945:../src/src/tls.c ****         }
6946:../src/src/tls.c ****     }
6947:../src/src/tls.c **** 
6948:../src/src/tls.c ****     if (ret == 0) {
6949:../src/src/tls.c ****         XMEMSET(kse->pubKey, 0, kse->pubKeyLen);
6950:../src/src/tls.c **** 
6951:../src/src/tls.c ****         /* Export public key. */
6952:../src/src/tls.c ****         PRIVATE_KEY_UNLOCK();
6953:../src/src/tls.c ****         if (wc_ecc_export_x963(eccKey, kse->pubKey, &kse->pubKeyLen) != 0) {
6954:../src/src/tls.c ****             ret = ECC_EXPORT_ERROR;
6955:../src/src/tls.c ****         }
6956:../src/src/tls.c ****         PRIVATE_KEY_LOCK();
6957:../src/src/tls.c ****     }
6958:../src/src/tls.c **** #ifdef WOLFSSL_DEBUG_TLS
6959:../src/src/tls.c ****     if (ret == 0) {
6960:../src/src/tls.c ****         WOLFSSL_MSG("Public ECC Key");
6961:../src/src/tls.c ****         WOLFSSL_BUFFER(kse->pubKey, kse->pubKeyLen);
6962:../src/src/tls.c ****     }
6963:../src/src/tls.c **** #endif
6964:../src/src/tls.c **** 
6965:../src/src/tls.c ****     if (ret != 0) {
6966:../src/src/tls.c ****         /* Cleanup on error, otherwise data owned by key share entry */
6967:../src/src/tls.c ****         if (kse->pubKey != NULL) {
6968:../src/src/tls.c ****             XFREE(kse->pubKey, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
6969:../src/src/tls.c ****             kse->pubKey = NULL;
6970:../src/src/tls.c ****         }
6971:../src/src/tls.c ****         if (eccKey != NULL)
6972:../src/src/tls.c ****             wc_ecc_free(eccKey);
6973:../src/src/tls.c ****         if (kse->key != NULL) {
6974:../src/src/tls.c ****             XFREE(kse->key, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
6975:../src/src/tls.c ****             kse->key = NULL;
6976:../src/src/tls.c ****         }
6977:../src/src/tls.c ****     }
6978:../src/src/tls.c **** #else
6979:../src/src/tls.c ****     (void)ssl;
6980:../src/src/tls.c ****     (void)kse;
6981:../src/src/tls.c **** 
6982:../src/src/tls.c ****     ret = NOT_COMPILED_IN;
6983:../src/src/tls.c **** #endif /* HAVE_ECC && HAVE_ECC_KEY_EXPORT */
6984:../src/src/tls.c **** 
6985:../src/src/tls.c ****     return ret;
6986:../src/src/tls.c **** }
6987:../src/src/tls.c **** 
6988:../src/src/tls.c **** #ifdef HAVE_PQC
6989:../src/src/tls.c **** #ifdef HAVE_LIBOQS
6990:../src/src/tls.c **** /* Transform a group ID into an OQS Algorithm name as a string. */
6991:../src/src/tls.c **** static const char* OQS_ID2name(int id)
6992:../src/src/tls.c **** {
6993:../src/src/tls.c ****     switch (id) {
6994:../src/src/tls.c ****         case WOLFSSL_KYBER_LEVEL1:     return OQS_KEM_alg_kyber_512;
6995:../src/src/tls.c ****         case WOLFSSL_KYBER_LEVEL3:     return OQS_KEM_alg_kyber_768;
6996:../src/src/tls.c ****         case WOLFSSL_KYBER_LEVEL5:     return OQS_KEM_alg_kyber_1024;
6997:../src/src/tls.c ****         case WOLFSSL_NTRU_HPS_LEVEL1:  return OQS_KEM_alg_ntru_hps2048509;
6998:../src/src/tls.c ****         case WOLFSSL_NTRU_HPS_LEVEL3:  return OQS_KEM_alg_ntru_hps2048677;
6999:../src/src/tls.c ****         case WOLFSSL_NTRU_HPS_LEVEL5:  return OQS_KEM_alg_ntru_hps4096821;
7000:../src/src/tls.c ****         case WOLFSSL_NTRU_HRSS_LEVEL3: return OQS_KEM_alg_ntru_hrss701;
7001:../src/src/tls.c ****         case WOLFSSL_SABER_LEVEL1:     return OQS_KEM_alg_saber_lightsaber;
7002:../src/src/tls.c ****         case WOLFSSL_SABER_LEVEL3:     return OQS_KEM_alg_saber_saber;
7003:../src/src/tls.c ****         case WOLFSSL_SABER_LEVEL5:     return OQS_KEM_alg_saber_firesaber;
7004:../src/src/tls.c ****         case WOLFSSL_KYBER_90S_LEVEL1: return OQS_KEM_alg_kyber_512_90s;
7005:../src/src/tls.c ****         case WOLFSSL_KYBER_90S_LEVEL3: return OQS_KEM_alg_kyber_768_90s;
7006:../src/src/tls.c ****         case WOLFSSL_KYBER_90S_LEVEL5: return OQS_KEM_alg_kyber_1024_90s;
7007:../src/src/tls.c ****         default:                       break;
7008:../src/src/tls.c ****     }
7009:../src/src/tls.c ****     return NULL;
7010:../src/src/tls.c **** }
7011:../src/src/tls.c **** #endif /* HAVE_LIBOQS */
7012:../src/src/tls.c **** 
7013:../src/src/tls.c **** typedef struct PqcHybridMapping {
7014:../src/src/tls.c ****     int hybrid;
7015:../src/src/tls.c ****     int ecc;
7016:../src/src/tls.c ****     int pqc;
7017:../src/src/tls.c **** } PqcHybridMapping;
7018:../src/src/tls.c **** 
7019:../src/src/tls.c **** static const PqcHybridMapping pqc_hybrid_mapping[] = {
7020:../src/src/tls.c ****     {.hybrid = WOLFSSL_P256_NTRU_HPS_LEVEL1,  .ecc = WOLFSSL_ECC_SECP256R1,
7021:../src/src/tls.c ****      .pqc = WOLFSSL_NTRU_HPS_LEVEL1},
7022:../src/src/tls.c ****     {.hybrid = WOLFSSL_P384_NTRU_HPS_LEVEL3,  .ecc = WOLFSSL_ECC_SECP384R1,
7023:../src/src/tls.c ****      .pqc = WOLFSSL_NTRU_HPS_LEVEL3},
7024:../src/src/tls.c ****     {.hybrid = WOLFSSL_P521_NTRU_HPS_LEVEL5,  .ecc = WOLFSSL_ECC_SECP521R1,
7025:../src/src/tls.c ****      .pqc = WOLFSSL_NTRU_HPS_LEVEL5},
7026:../src/src/tls.c ****     {.hybrid = WOLFSSL_P384_NTRU_HRSS_LEVEL3, .ecc = WOLFSSL_ECC_SECP384R1,
7027:../src/src/tls.c ****      .pqc = WOLFSSL_NTRU_HRSS_LEVEL3},
7028:../src/src/tls.c ****     {.hybrid = WOLFSSL_P256_SABER_LEVEL1,     .ecc = WOLFSSL_ECC_SECP256R1,
7029:../src/src/tls.c ****      .pqc = WOLFSSL_SABER_LEVEL1},
7030:../src/src/tls.c ****     {.hybrid = WOLFSSL_P384_SABER_LEVEL3,     .ecc = WOLFSSL_ECC_SECP384R1,
7031:../src/src/tls.c ****      .pqc = WOLFSSL_SABER_LEVEL3},
7032:../src/src/tls.c ****     {.hybrid = WOLFSSL_P521_SABER_LEVEL5,     .ecc = WOLFSSL_ECC_SECP521R1,
7033:../src/src/tls.c ****      .pqc = WOLFSSL_SABER_LEVEL5},
7034:../src/src/tls.c ****     {.hybrid = WOLFSSL_P256_KYBER_LEVEL1,     .ecc = WOLFSSL_ECC_SECP256R1,
7035:../src/src/tls.c ****      .pqc = WOLFSSL_KYBER_LEVEL1},
7036:../src/src/tls.c ****     {.hybrid = WOLFSSL_P384_KYBER_LEVEL3,     .ecc = WOLFSSL_ECC_SECP384R1,
7037:../src/src/tls.c ****      .pqc = WOLFSSL_KYBER_LEVEL3},
7038:../src/src/tls.c ****     {.hybrid = WOLFSSL_P521_KYBER_LEVEL5,     .ecc = WOLFSSL_ECC_SECP521R1,
7039:../src/src/tls.c ****      .pqc = WOLFSSL_KYBER_LEVEL5},
7040:../src/src/tls.c ****     {.hybrid = WOLFSSL_P256_KYBER_90S_LEVEL1, .ecc = WOLFSSL_ECC_SECP256R1,
7041:../src/src/tls.c ****      .pqc = WOLFSSL_KYBER_90S_LEVEL1},
7042:../src/src/tls.c ****     {.hybrid = WOLFSSL_P384_KYBER_90S_LEVEL3, .ecc = WOLFSSL_ECC_SECP384R1,
7043:../src/src/tls.c ****      .pqc = WOLFSSL_KYBER_90S_LEVEL3},
7044:../src/src/tls.c ****     {.hybrid = WOLFSSL_P521_KYBER_90S_LEVEL5, .ecc = WOLFSSL_ECC_SECP521R1,
7045:../src/src/tls.c ****      .pqc = WOLFSSL_KYBER_90S_LEVEL5},
7046:../src/src/tls.c ****     {.hybrid = 0, .ecc = 0, .pqc = 0}
7047:../src/src/tls.c **** };
7048:../src/src/tls.c **** 
7049:../src/src/tls.c **** /* This will map an ecc-pqs hybrid group into its ecc group and pqc kem group.
7050:../src/src/tls.c ****  * If it cannot find a mapping then *pqc is set to group. ecc is optional. */
7051:../src/src/tls.c **** static void findEccPqc(int *ecc, int *pqc, int group)
7052:../src/src/tls.c **** {
7053:../src/src/tls.c ****     int i;
7054:../src/src/tls.c ****     if (pqc == NULL) {
7055:../src/src/tls.c ****         return;
7056:../src/src/tls.c ****     }
7057:../src/src/tls.c **** 
7058:../src/src/tls.c ****     *pqc = 0;
7059:../src/src/tls.c ****     if (ecc != NULL) {
7060:../src/src/tls.c ****         *ecc = 0;
7061:../src/src/tls.c ****     }
7062:../src/src/tls.c **** 
7063:../src/src/tls.c ****     for (i = 0; pqc_hybrid_mapping[i].hybrid != 0; i++) {
7064:../src/src/tls.c ****         if (pqc_hybrid_mapping[i].hybrid == group) {
7065:../src/src/tls.c ****             *pqc = pqc_hybrid_mapping[i].pqc;
7066:../src/src/tls.c ****             if (ecc != NULL) {
7067:../src/src/tls.c ****                 *ecc = pqc_hybrid_mapping[i].ecc;
7068:../src/src/tls.c ****             }
7069:../src/src/tls.c ****             break;
7070:../src/src/tls.c ****         }
7071:../src/src/tls.c ****     }
7072:../src/src/tls.c **** 
7073:../src/src/tls.c ****     if (*pqc == 0) {
7074:../src/src/tls.c ****         /* It is not a hybrid, so maybe its simple. */
7075:../src/src/tls.c ****         *pqc = group;
7076:../src/src/tls.c ****     }
7077:../src/src/tls.c **** }
7078:../src/src/tls.c **** 
7079:../src/src/tls.c **** /* Create a key share entry using liboqs parameters group.
7080:../src/src/tls.c ****  * Generates a key pair.
7081:../src/src/tls.c ****  *
7082:../src/src/tls.c ****  * ssl   The SSL/TLS object.
7083:../src/src/tls.c ****  * kse   The key share entry object.
7084:../src/src/tls.c ****  * returns 0 on success, otherwise failure.
7085:../src/src/tls.c ****  */
7086:../src/src/tls.c **** #ifdef HAVE_LIBOQS
7087:../src/src/tls.c **** static int TLSX_KeyShare_GenPqcKey(WOLFSSL *ssl, KeyShareEntry* kse)
7088:../src/src/tls.c **** {
7089:../src/src/tls.c ****     int ret = 0;
7090:../src/src/tls.c ****     const char* algName = NULL;
7091:../src/src/tls.c ****     OQS_KEM* kem = NULL;
7092:../src/src/tls.c ****     byte* pubKey = NULL;
7093:../src/src/tls.c ****     byte* privKey = NULL;
7094:../src/src/tls.c ****     KeyShareEntry *ecc_kse = NULL;
7095:../src/src/tls.c ****     int oqs_group = 0;
7096:../src/src/tls.c ****     int ecc_group = 0;
7097:../src/src/tls.c **** 
7098:../src/src/tls.c ****     findEccPqc(&ecc_group, &oqs_group, kse->group);
7099:../src/src/tls.c ****     algName = OQS_ID2name(oqs_group);
7100:../src/src/tls.c ****     if (algName == NULL) {
7101:../src/src/tls.c ****         WOLFSSL_MSG("Invalid OQS algorithm specified.");
7102:../src/src/tls.c ****         return BAD_FUNC_ARG;
7103:../src/src/tls.c ****     }
7104:../src/src/tls.c **** 
7105:../src/src/tls.c ****     kem = OQS_KEM_new(algName);
7106:../src/src/tls.c ****     if (kem == NULL) {
7107:../src/src/tls.c ****         WOLFSSL_MSG("Error creating OQS KEM, ensure algorithm support"
7108:../src/src/tls.c ****                     "was enabled in liboqs.");
7109:../src/src/tls.c ****         return BAD_FUNC_ARG;
7110:../src/src/tls.c ****     }
7111:../src/src/tls.c **** 
7112:../src/src/tls.c ****     ecc_kse = (KeyShareEntry*)XMALLOC(sizeof(*ecc_kse), ssl->heap,
7113:../src/src/tls.c ****                DYNAMIC_TYPE_TLSX);
7114:../src/src/tls.c ****     if (ecc_kse == NULL) {
7115:../src/src/tls.c ****         WOLFSSL_MSG("ecc_kse memory allocation failure");
7116:../src/src/tls.c ****         ret = MEMORY_ERROR;
7117:../src/src/tls.c ****     }
7118:../src/src/tls.c **** 
7119:../src/src/tls.c ****     if (ret == 0) {
7120:../src/src/tls.c ****         XMEMSET(ecc_kse, 0, sizeof(*ecc_kse));
7121:../src/src/tls.c ****     }
7122:../src/src/tls.c **** 
7123:../src/src/tls.c ****     if (ret == 0 && ecc_group != 0) {
7124:../src/src/tls.c ****         ecc_kse->group = ecc_group;
7125:../src/src/tls.c ****         ret = TLSX_KeyShare_GenEccKey(ssl, ecc_kse);
7126:../src/src/tls.c ****         /* If fail, no error message,  TLSX_KeyShare_GenEccKey will do it. */
7127:../src/src/tls.c ****     }
7128:../src/src/tls.c **** 
7129:../src/src/tls.c ****     if (ret == 0) {
7130:../src/src/tls.c ****         pubKey = (byte*)XMALLOC(ecc_kse->pubKeyLen + kem->length_public_key,
7131:../src/src/tls.c ****                                 ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
7132:../src/src/tls.c ****         if (pubKey == NULL) {
7133:../src/src/tls.c ****             WOLFSSL_MSG("pubkey memory allocation failure");
7134:../src/src/tls.c ****             ret = MEMORY_ERROR;
7135:../src/src/tls.c ****         }
7136:../src/src/tls.c ****     }
7137:../src/src/tls.c **** 
7138:../src/src/tls.c ****     if (ret == 0) {
7139:../src/src/tls.c ****         privKey = (byte*)XMALLOC(kem->length_secret_key,
7140:../src/src/tls.c ****                                  ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
7141:../src/src/tls.c ****         if (privKey == NULL) {
7142:../src/src/tls.c ****             WOLFSSL_MSG("privkey memory allocation failure");
7143:../src/src/tls.c ****             ret = MEMORY_ERROR;
7144:../src/src/tls.c ****         }
7145:../src/src/tls.c ****     }
7146:../src/src/tls.c **** 
7147:../src/src/tls.c ****     if (ret == 0) {
7148:../src/src/tls.c ****         if (OQS_KEM_keypair(kem, pubKey + ecc_kse->pubKeyLen, privKey) ==
7149:../src/src/tls.c ****             OQS_SUCCESS) {
7150:../src/src/tls.c ****             XMEMCPY(pubKey, ecc_kse->pubKey, ecc_kse->pubKeyLen);
7151:../src/src/tls.c ****             kse->pubKey = pubKey;
7152:../src/src/tls.c ****             kse->pubKeyLen = ecc_kse->pubKeyLen +
7153:../src/src/tls.c ****                              (word32) kem->length_public_key;
7154:../src/src/tls.c ****             pubKey = NULL;
7155:../src/src/tls.c **** 
7156:../src/src/tls.c ****             /* Note we are saving the OQS private key and ECC private key
7157:../src/src/tls.c ****              * separately. That's because the ECC private key is not simply a
7158:../src/src/tls.c ****              * buffer. Its is an ecc_key struct.
7159:../src/src/tls.c ****              */
7160:../src/src/tls.c ****             kse->privKey = privKey;
7161:../src/src/tls.c ****             privKey = NULL;
7162:../src/src/tls.c **** 
7163:../src/src/tls.c ****             kse->key = ecc_kse->key;
7164:../src/src/tls.c ****             ecc_kse->key = NULL;
7165:../src/src/tls.c **** 
7166:../src/src/tls.c ****             ret = 0;
7167:../src/src/tls.c ****         }
7168:../src/src/tls.c ****         else {
7169:../src/src/tls.c ****             WOLFSSL_MSG("liboqs keygen failure");
7170:../src/src/tls.c ****             ret = BAD_FUNC_ARG;
7171:../src/src/tls.c ****         }
7172:../src/src/tls.c ****     }
7173:../src/src/tls.c **** 
7174:../src/src/tls.c **** #ifdef WOLFSSL_DEBUG_TLS
7175:../src/src/tls.c ****     WOLFSSL_MSG("Public liboqs Key");
7176:../src/src/tls.c ****     WOLFSSL_BUFFER(kse->pubKey, kse->pubKeyLen );
7177:../src/src/tls.c **** #endif
7178:../src/src/tls.c **** 
7179:../src/src/tls.c ****     OQS_KEM_free(kem);
7180:../src/src/tls.c ****     TLSX_KeyShare_FreeAll(ecc_kse, ssl->heap);
7181:../src/src/tls.c ****     if (pubKey != NULL)
7182:../src/src/tls.c ****         XFREE(pubKey, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
7183:../src/src/tls.c ****     if (privKey != NULL)
7184:../src/src/tls.c ****         XFREE(privKey, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
7185:../src/src/tls.c **** 
7186:../src/src/tls.c ****     return ret;
7187:../src/src/tls.c **** }
7188:../src/src/tls.c **** #elif defined(HAVE_PQM4)
7189:../src/src/tls.c **** static int TLSX_KeyShare_GenPqcKey(WOLFSSL *ssl, KeyShareEntry* kse)
7190:../src/src/tls.c **** {
7191:../src/src/tls.c ****     /* This assumes KYBER LEVEL 1 (512) implementation is compiled in. */
7192:../src/src/tls.c ****     int ret = 0;
7193:../src/src/tls.c ****     byte* pubKey = NULL;
7194:../src/src/tls.c ****     byte* privKey = NULL;
7195:../src/src/tls.c ****     KeyShareEntry *ecc_kse = NULL;
7196:../src/src/tls.c ****     int oqs_group = 0;
7197:../src/src/tls.c ****     int ecc_group = 0;
7198:../src/src/tls.c **** 
7199:../src/src/tls.c ****     findEccPqc(&ecc_group, &oqs_group, kse->group);
7200:../src/src/tls.c **** 
7201:../src/src/tls.c ****     ecc_kse = (KeyShareEntry*)XMALLOC(sizeof(*ecc_kse), ssl->heap,
7202:../src/src/tls.c ****                DYNAMIC_TYPE_TLSX);
7203:../src/src/tls.c ****     if (ecc_kse == NULL) {
7204:../src/src/tls.c ****         WOLFSSL_MSG("ecc_kse memory allocation failure");
7205:../src/src/tls.c ****         ret = MEMORY_ERROR;
7206:../src/src/tls.c ****     }
7207:../src/src/tls.c **** 
7208:../src/src/tls.c ****     if (ret == 0) {
7209:../src/src/tls.c ****         XMEMSET(ecc_kse, 0, sizeof(*ecc_kse));
7210:../src/src/tls.c ****     }
7211:../src/src/tls.c **** 
7212:../src/src/tls.c ****     if (ret == 0 && ecc_group != 0) {
7213:../src/src/tls.c ****         ecc_kse->group = ecc_group;
7214:../src/src/tls.c ****         ret = TLSX_KeyShare_GenEccKey(ssl, ecc_kse);
7215:../src/src/tls.c ****         /* If fail, no error message,  TLSX_KeyShare_GenEccKey will do it. */
7216:../src/src/tls.c ****     }
7217:../src/src/tls.c **** 
7218:../src/src/tls.c ****     if (ret == 0) {
7219:../src/src/tls.c ****         pubKey = (byte*)XMALLOC(ecc_kse->pubKeyLen + PQM4_PUBLIC_KEY_LENGTH,
7220:../src/src/tls.c ****                                 ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
7221:../src/src/tls.c ****         if (pubKey == NULL) {
7222:../src/src/tls.c ****             WOLFSSL_MSG("pubkey memory allocation failure");
7223:../src/src/tls.c ****             ret = MEMORY_ERROR;
7224:../src/src/tls.c ****         }
7225:../src/src/tls.c ****     }
7226:../src/src/tls.c **** 
7227:../src/src/tls.c ****     if (ret == 0) {
7228:../src/src/tls.c ****         privKey = (byte*)XMALLOC(PQM4_PRIVATE_KEY_LENGTH,
7229:../src/src/tls.c ****                                  ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
7230:../src/src/tls.c ****         if (privKey == NULL) {
7231:../src/src/tls.c ****             WOLFSSL_MSG("privkey memory allocation failure");
7232:../src/src/tls.c ****             ret = MEMORY_ERROR;
7233:../src/src/tls.c ****         }
7234:../src/src/tls.c ****     }
7235:../src/src/tls.c **** 
7236:../src/src/tls.c ****     if (ret == 0) {
7237:../src/src/tls.c ****         if (crypto_kem_keypair(pubKey + ecc_kse->pubKeyLen, privKey) == 0) {
7238:../src/src/tls.c ****             XMEMCPY(pubKey, ecc_kse->pubKey, ecc_kse->pubKeyLen);
7239:../src/src/tls.c ****             kse->pubKey = pubKey;
7240:../src/src/tls.c ****             kse->pubKeyLen = ecc_kse->pubKeyLen +
7241:../src/src/tls.c ****                              (word32) PQM4_PUBLIC_KEY_LENGTH;
7242:../src/src/tls.c ****             pubKey = NULL;
7243:../src/src/tls.c **** 
7244:../src/src/tls.c ****             /* Note we are saving the PQ private key and ECC private key
7245:../src/src/tls.c ****              * separately. That's because the ECC private key is not simply a
7246:../src/src/tls.c ****              * buffer. Its is an ecc_key struct.
7247:../src/src/tls.c ****              */
7248:../src/src/tls.c ****             kse->privKey = privKey;
7249:../src/src/tls.c ****             privKey = NULL;
7250:../src/src/tls.c **** 
7251:../src/src/tls.c ****             kse->key = ecc_kse->key;
7252:../src/src/tls.c ****             ecc_kse->key = NULL;
7253:../src/src/tls.c **** 
7254:../src/src/tls.c ****             ret = 0;
7255:../src/src/tls.c ****         }
7256:../src/src/tls.c ****         else {
7257:../src/src/tls.c ****             WOLFSSL_MSG("liboqs keygen failure");
7258:../src/src/tls.c ****             ret = BAD_FUNC_ARG;
7259:../src/src/tls.c ****         }
7260:../src/src/tls.c ****     }
7261:../src/src/tls.c **** 
7262:../src/src/tls.c **** #ifdef WOLFSSL_DEBUG_TLS
7263:../src/src/tls.c ****     WOLFSSL_MSG("Public PQM4 Key");
7264:../src/src/tls.c ****     WOLFSSL_BUFFER(kse->pubKey, kse->pubKeyLen );
7265:../src/src/tls.c **** #endif
7266:../src/src/tls.c **** 
7267:../src/src/tls.c ****     TLSX_KeyShare_FreeAll(ecc_kse, ssl->heap);
7268:../src/src/tls.c ****     if (pubKey != NULL)
7269:../src/src/tls.c ****         XFREE(pubKey, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
7270:../src/src/tls.c ****     if (privKey != NULL)
7271:../src/src/tls.c ****         XFREE(privKey, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
7272:../src/src/tls.c **** 
7273:../src/src/tls.c ****     return ret;
7274:../src/src/tls.c **** }
7275:../src/src/tls.c **** #endif /* HAVE_PQM4 */
7276:../src/src/tls.c **** #endif /* HAVE_PQC */
7277:../src/src/tls.c **** 
7278:../src/src/tls.c **** /* Generate a secret/key using the key share entry.
7279:../src/src/tls.c ****  *
7280:../src/src/tls.c ****  * ssl  The SSL/TLS object.
7281:../src/src/tls.c ****  * kse  The key share entry holding peer data.
7282:../src/src/tls.c ****  */
7283:../src/src/tls.c **** static int TLSX_KeyShare_GenKey(WOLFSSL *ssl, KeyShareEntry *kse)
7284:../src/src/tls.c **** {
7285:../src/src/tls.c ****     int ret;
7286:../src/src/tls.c ****     /* Named FFDHE groups have a bit set to identify them. */
7287:../src/src/tls.c ****     if (kse->group >= MIN_FFHDE_GROUP && kse->group <= MAX_FFHDE_GROUP)
7288:../src/src/tls.c ****         ret = TLSX_KeyShare_GenDhKey(ssl, kse);
7289:../src/src/tls.c ****     else if (kse->group == WOLFSSL_ECC_X25519)
7290:../src/src/tls.c ****         ret = TLSX_KeyShare_GenX25519Key(ssl, kse);
7291:../src/src/tls.c ****     else if (kse->group == WOLFSSL_ECC_X448)
7292:../src/src/tls.c ****         ret = TLSX_KeyShare_GenX448Key(ssl, kse);
7293:../src/src/tls.c **** #ifdef HAVE_PQC
7294:../src/src/tls.c ****     else if (kse->group >= WOLFSSL_PQC_MIN && kse->group <= WOLFSSL_PQC_MAX)
7295:../src/src/tls.c ****         ret = TLSX_KeyShare_GenPqcKey(ssl, kse);
7296:../src/src/tls.c **** #endif
7297:../src/src/tls.c ****     else
7298:../src/src/tls.c ****         ret = TLSX_KeyShare_GenEccKey(ssl, kse);
7299:../src/src/tls.c **** #ifdef WOLFSSL_ASYNC_CRYPT
7300:../src/src/tls.c ****     kse->lastRet = ret;
7301:../src/src/tls.c **** #endif
7302:../src/src/tls.c ****     return ret;
7303:../src/src/tls.c **** }
7304:../src/src/tls.c **** 
7305:../src/src/tls.c **** /* Free the key share dynamic data.
7306:../src/src/tls.c ****  *
7307:../src/src/tls.c ****  * list  The linked list of key share entry objects.
7308:../src/src/tls.c ****  * heap  The heap used for allocation.
7309:../src/src/tls.c ****  */
7310:../src/src/tls.c **** static void TLSX_KeyShare_FreeAll(KeyShareEntry* list, void* heap)
7311:../src/src/tls.c **** {
7312:../src/src/tls.c ****     KeyShareEntry* current;
7313:../src/src/tls.c **** 
7314:../src/src/tls.c ****     while ((current = list) != NULL) {
7315:../src/src/tls.c ****         list = current->next;
7316:../src/src/tls.c ****         if (current->group >= MIN_FFHDE_GROUP &&
7317:../src/src/tls.c ****             current->group <= MAX_FFHDE_GROUP) {
7318:../src/src/tls.c **** #ifndef NO_DH
7319:../src/src/tls.c ****             wc_FreeDhKey((DhKey*)current->key);
7320:../src/src/tls.c **** #endif
7321:../src/src/tls.c ****         }
7322:../src/src/tls.c ****         else if (current->group == WOLFSSL_ECC_X25519) {
7323:../src/src/tls.c **** #ifdef HAVE_CURVE25519
7324:../src/src/tls.c ****             wc_curve25519_free((curve25519_key*)current->key);
7325:../src/src/tls.c **** #endif
7326:../src/src/tls.c ****         }
7327:../src/src/tls.c ****         else if (current->group == WOLFSSL_ECC_X448) {
7328:../src/src/tls.c **** #ifdef HAVE_CURVE448
7329:../src/src/tls.c ****             wc_curve448_free((curve448_key*)current->key);
7330:../src/src/tls.c **** #endif
7331:../src/src/tls.c ****         }
7332:../src/src/tls.c **** #ifdef HAVE_PQC
7333:../src/src/tls.c ****         else if (current->group >= WOLFSSL_PQC_MIN &&
7334:../src/src/tls.c ****                  current->group <= WOLFSSL_PQC_MAX &&
7335:../src/src/tls.c ****                  current->key != NULL) {
7336:../src/src/tls.c ****             ForceZero((byte*)current->key, current->keyLen);
7337:../src/src/tls.c ****         }
7338:../src/src/tls.c **** #endif
7339:../src/src/tls.c ****         else {
7340:../src/src/tls.c **** #ifdef HAVE_ECC
7341:../src/src/tls.c ****             wc_ecc_free((ecc_key*)current->key);
7342:../src/src/tls.c **** #endif
7343:../src/src/tls.c ****         }
7344:../src/src/tls.c ****         XFREE(current->key, heap, DYNAMIC_TYPE_PRIVATE_KEY);
7345:../src/src/tls.c ****     #if !defined(NO_DH) && (!defined(NO_CERTS) || !defined(NO_PSK))
7346:../src/src/tls.c ****         XFREE(current->privKey, heap, DYNAMIC_TYPE_PRIVATE_KEY);
7347:../src/src/tls.c ****     #endif
7348:../src/src/tls.c ****         XFREE(current->pubKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
7349:../src/src/tls.c ****         XFREE(current->ke, heap, DYNAMIC_TYPE_PUBLIC_KEY);
7350:../src/src/tls.c ****         XFREE(current, heap, DYNAMIC_TYPE_TLSX);
7351:../src/src/tls.c ****     }
7352:../src/src/tls.c **** 
7353:../src/src/tls.c ****     (void)heap;
7354:../src/src/tls.c **** }
7355:../src/src/tls.c **** 
7356:../src/src/tls.c **** /* Get the size of the encoded key share extension.
7357:../src/src/tls.c ****  *
7358:../src/src/tls.c ****  * list     The linked list of key share extensions.
7359:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
7360:../src/src/tls.c ****  * returns the number of bytes of the encoded key share extension.
7361:../src/src/tls.c ****  */
7362:../src/src/tls.c **** static word16 TLSX_KeyShare_GetSize(KeyShareEntry* list, byte msgType)
7363:../src/src/tls.c **** {
7364:../src/src/tls.c ****     word16         len = 0;
7365:../src/src/tls.c ****     byte           isRequest = (msgType == client_hello);
7366:../src/src/tls.c ****     KeyShareEntry* current;
7367:../src/src/tls.c **** 
7368:../src/src/tls.c ****     /* The named group the server wants to use. */
7369:../src/src/tls.c ****     if (msgType == hello_retry_request)
7370:../src/src/tls.c ****         return OPAQUE16_LEN;
7371:../src/src/tls.c **** 
7372:../src/src/tls.c ****     /* List of key exchange groups. */
7373:../src/src/tls.c ****     if (isRequest)
7374:../src/src/tls.c ****         len += OPAQUE16_LEN;
7375:../src/src/tls.c ****     while ((current = list) != NULL) {
7376:../src/src/tls.c ****         list = current->next;
7377:../src/src/tls.c **** 
7378:../src/src/tls.c ****         if (!isRequest && current->pubKey == NULL)
7379:../src/src/tls.c ****             continue;
7380:../src/src/tls.c **** 
7381:../src/src/tls.c ****         len += (word16)(KE_GROUP_LEN + OPAQUE16_LEN + current->pubKeyLen);
7382:../src/src/tls.c ****     }
7383:../src/src/tls.c **** 
7384:../src/src/tls.c ****     return len;
7385:../src/src/tls.c **** }
7386:../src/src/tls.c **** 
7387:../src/src/tls.c **** /* Writes the key share extension into the output buffer.
7388:../src/src/tls.c ****  * Assumes that the the output buffer is big enough to hold data.
7389:../src/src/tls.c ****  *
7390:../src/src/tls.c ****  * list     The linked list of key share entries.
7391:../src/src/tls.c ****  * output   The buffer to write into.
7392:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
7393:../src/src/tls.c ****  * returns the number of bytes written into the buffer.
7394:../src/src/tls.c ****  */
7395:../src/src/tls.c **** static word16 TLSX_KeyShare_Write(KeyShareEntry* list, byte* output,
7396:../src/src/tls.c ****                                   byte msgType)
7397:../src/src/tls.c **** {
7398:../src/src/tls.c ****     word16         i = 0;
7399:../src/src/tls.c ****     byte           isRequest = (msgType == client_hello);
7400:../src/src/tls.c ****     KeyShareEntry* current;
7401:../src/src/tls.c **** 
7402:../src/src/tls.c ****     if (msgType == hello_retry_request) {
7403:../src/src/tls.c ****         c16toa(list->group, output);
7404:../src/src/tls.c ****         return OPAQUE16_LEN;
7405:../src/src/tls.c ****     }
7406:../src/src/tls.c **** 
7407:../src/src/tls.c ****     /* ClientHello has a list but ServerHello is only the chosen. */
7408:../src/src/tls.c ****     if (isRequest)
7409:../src/src/tls.c ****         i += OPAQUE16_LEN;
7410:../src/src/tls.c **** 
7411:../src/src/tls.c ****     /* Write out all in the list. */
7412:../src/src/tls.c ****     while ((current = list) != NULL) {
7413:../src/src/tls.c ****         list = current->next;
7414:../src/src/tls.c **** 
7415:../src/src/tls.c ****         if (!isRequest && current->pubKey == NULL)
7416:../src/src/tls.c ****             continue;
7417:../src/src/tls.c **** 
7418:../src/src/tls.c ****         c16toa(current->group, &output[i]);
7419:../src/src/tls.c ****         i += KE_GROUP_LEN;
7420:../src/src/tls.c ****         c16toa((word16)(current->pubKeyLen), &output[i]);
7421:../src/src/tls.c ****         i += OPAQUE16_LEN;
7422:../src/src/tls.c ****         XMEMCPY(&output[i], current->pubKey, current->pubKeyLen);
7423:../src/src/tls.c ****         i += (word16)current->pubKeyLen;
7424:../src/src/tls.c ****     }
7425:../src/src/tls.c ****     /* Write the length of the list if required. */
7426:../src/src/tls.c ****     if (isRequest)
7427:../src/src/tls.c ****         c16toa(i - OPAQUE16_LEN, output);
7428:../src/src/tls.c **** 
7429:../src/src/tls.c ****     return i;
7430:../src/src/tls.c **** }
7431:../src/src/tls.c **** 
7432:../src/src/tls.c **** /* Process the DH key share extension on the client side.
7433:../src/src/tls.c ****  *
7434:../src/src/tls.c ****  * ssl            The SSL/TLS object.
7435:../src/src/tls.c ****  * keyShareEntry  The key share entry object to use to calculate shared secret.
7436:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
7437:../src/src/tls.c ****  */
7438:../src/src/tls.c **** static int TLSX_KeyShare_ProcessDh(WOLFSSL* ssl, KeyShareEntry* keyShareEntry)
7439:../src/src/tls.c **** {
7440:../src/src/tls.c ****     int ret = 0;
7441:../src/src/tls.c **** #if !defined(NO_DH) && (!defined(NO_CERTS) || !defined(NO_PSK))
7442:../src/src/tls.c ****     word32 pSz = 0;
7443:../src/src/tls.c ****     DhKey* dhKey = (DhKey*)keyShareEntry->key;
7444:../src/src/tls.c **** 
7445:../src/src/tls.c **** #ifdef HAVE_PUBLIC_FFDHE
7446:../src/src/tls.c ****     const DhParams* params = NULL;
7447:../src/src/tls.c ****     switch (keyShareEntry->group) {
7448:../src/src/tls.c ****     #ifdef HAVE_FFDHE_2048
7449:../src/src/tls.c ****         case WOLFSSL_FFDHE_2048:
7450:../src/src/tls.c ****             params = wc_Dh_ffdhe2048_Get();
7451:../src/src/tls.c ****             break;
7452:../src/src/tls.c ****     #endif
7453:../src/src/tls.c ****     #ifdef HAVE_FFDHE_3072
7454:../src/src/tls.c ****         case WOLFSSL_FFDHE_3072:
7455:../src/src/tls.c ****             params = wc_Dh_ffdhe3072_Get();
7456:../src/src/tls.c ****             break;
7457:../src/src/tls.c ****     #endif
7458:../src/src/tls.c ****     #ifdef HAVE_FFDHE_4096
7459:../src/src/tls.c ****         case WOLFSSL_FFDHE_4096:
7460:../src/src/tls.c ****             params = wc_Dh_ffdhe4096_Get();
7461:../src/src/tls.c ****             break;
7462:../src/src/tls.c ****     #endif
7463:../src/src/tls.c ****     #ifdef HAVE_FFDHE_6144
7464:../src/src/tls.c ****         case WOLFSSL_FFDHE_6144:
7465:../src/src/tls.c ****             params = wc_Dh_ffdhe6144_Get();
7466:../src/src/tls.c ****             break;
7467:../src/src/tls.c ****     #endif
7468:../src/src/tls.c ****     #ifdef HAVE_FFDHE_8192
7469:../src/src/tls.c ****         case WOLFSSL_FFDHE_8192:
7470:../src/src/tls.c ****             params = wc_Dh_ffdhe8192_Get();
7471:../src/src/tls.c ****             break;
7472:../src/src/tls.c ****     #endif
7473:../src/src/tls.c ****         default:
7474:../src/src/tls.c ****             break;
7475:../src/src/tls.c ****     }
7476:../src/src/tls.c ****     if (params == NULL) {
7477:../src/src/tls.c ****         return PEER_KEY_ERROR;
7478:../src/src/tls.c ****     }
7479:../src/src/tls.c ****     pSz = params->p_len;
7480:../src/src/tls.c **** #else
7481:../src/src/tls.c ****     ret = wc_DhGetNamedKeyParamSize(keyShareEntry->group, &pSz, NULL, NULL);
7482:../src/src/tls.c ****     if (ret != 0 || pSz == 0) {
7483:../src/src/tls.c ****         return PEER_KEY_ERROR;
7484:../src/src/tls.c ****     }
7485:../src/src/tls.c **** #endif
7486:../src/src/tls.c **** 
7487:../src/src/tls.c ****     /* if DhKey is not setup, do it now */
7488:../src/src/tls.c ****     if (keyShareEntry->key == NULL) {
7489:../src/src/tls.c ****         keyShareEntry->key = (DhKey*)XMALLOC(sizeof(DhKey), ssl->heap,
7490:../src/src/tls.c ****             DYNAMIC_TYPE_DH);
7491:../src/src/tls.c ****         if (keyShareEntry->key == NULL)
7492:../src/src/tls.c ****             return MEMORY_E;
7493:../src/src/tls.c **** 
7494:../src/src/tls.c ****         /* Setup Key */
7495:../src/src/tls.c ****         ret = wc_InitDhKey_ex((DhKey*)keyShareEntry->key, ssl->heap, ssl->devId);
7496:../src/src/tls.c ****         if (ret == 0) {
7497:../src/src/tls.c ****             dhKey = (DhKey*)keyShareEntry->key;
7498:../src/src/tls.c ****         /* Set key */
7499:../src/src/tls.c ****         #ifdef HAVE_PUBLIC_FFDHE
7500:../src/src/tls.c ****             ret = wc_DhSetKey(dhKey, params->p, params->p_len, params->g,
7501:../src/src/tls.c ****                                                                 params->g_len);
7502:../src/src/tls.c ****         #else
7503:../src/src/tls.c ****             ret = wc_DhSetNamedKey(dhKey, keyShareEntry->group);
7504:../src/src/tls.c ****         #endif
7505:../src/src/tls.c ****         }
7506:../src/src/tls.c ****     }
7507:../src/src/tls.c **** 
7508:../src/src/tls.c ****     if (ret == 0
7509:../src/src/tls.c ****     #ifdef WOLFSSL_ASYNC_CRYPT
7510:../src/src/tls.c ****         && keyShareEntry->lastRet == 0 /* don't enter here if WC_PENDING_E */
7511:../src/src/tls.c ****     #endif
7512:../src/src/tls.c ****     ) {
7513:../src/src/tls.c ****     #ifdef WOLFSSL_DEBUG_TLS
7514:../src/src/tls.c ****         WOLFSSL_MSG("Peer DH Key");
7515:../src/src/tls.c ****         WOLFSSL_BUFFER(keyShareEntry->ke, keyShareEntry->keLen);
7516:../src/src/tls.c ****     #endif
7517:../src/src/tls.c **** 
7518:../src/src/tls.c ****         ssl->options.dhKeySz = (word16)pSz;
7519:../src/src/tls.c **** 
7520:../src/src/tls.c ****         /* Derive secret from private key and peer's public key. */
7521:../src/src/tls.c ****         ret = DhAgree(ssl, dhKey,
7522:../src/src/tls.c ****             (const byte*)keyShareEntry->privKey, keyShareEntry->keyLen, /* our private */
7523:../src/src/tls.c ****             keyShareEntry->ke, keyShareEntry->keLen,                    /* peer's public key */
7524:../src/src/tls.c ****             ssl->arrays->preMasterSecret, &ssl->arrays->preMasterSz,    /* secret */
7525:../src/src/tls.c ****             NULL, 0
7526:../src/src/tls.c ****         );
7527:../src/src/tls.c ****     #ifdef WOLFSSL_ASYNC_CRYPT
7528:../src/src/tls.c ****         if (ret == WC_PENDING_E) {
7529:../src/src/tls.c ****             return ret;
7530:../src/src/tls.c ****         }
7531:../src/src/tls.c ****     #endif
7532:../src/src/tls.c ****     }
7533:../src/src/tls.c **** 
7534:../src/src/tls.c ****     /* RFC 8446 Section 7.4.1:
7535:../src/src/tls.c ****      *     ... left-padded with zeros up to the size of the prime. ...
7536:../src/src/tls.c ****      */
7537:../src/src/tls.c ****     if (ret == 0 && (word32)ssl->options.dhKeySz > ssl->arrays->preMasterSz) {
7538:../src/src/tls.c ****         word32 diff = (word32)ssl->options.dhKeySz - ssl->arrays->preMasterSz;
7539:../src/src/tls.c ****         XMEMMOVE(ssl->arrays->preMasterSecret + diff,
7540:../src/src/tls.c ****                         ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz);
7541:../src/src/tls.c ****         XMEMSET(ssl->arrays->preMasterSecret, 0, diff);
7542:../src/src/tls.c ****         ssl->arrays->preMasterSz = ssl->options.dhKeySz;
7543:../src/src/tls.c ****     }
7544:../src/src/tls.c **** 
7545:../src/src/tls.c ****     /* done with key share, release resources */
7546:../src/src/tls.c ****     if (dhKey)
7547:../src/src/tls.c ****         wc_FreeDhKey(dhKey);
7548:../src/src/tls.c ****     if (keyShareEntry->key) {
7549:../src/src/tls.c ****         XFREE(keyShareEntry->key, ssl->heap, DYNAMIC_TYPE_DH);
7550:../src/src/tls.c ****         keyShareEntry->key = NULL;
7551:../src/src/tls.c ****     }
7552:../src/src/tls.c ****     if (keyShareEntry->privKey != NULL) {
7553:../src/src/tls.c ****         XFREE(keyShareEntry->privKey, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
7554:../src/src/tls.c ****         keyShareEntry->privKey = NULL;
7555:../src/src/tls.c ****     }
7556:../src/src/tls.c ****     if (keyShareEntry->pubKey != NULL) {
7557:../src/src/tls.c ****         XFREE(keyShareEntry->pubKey, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
7558:../src/src/tls.c ****         keyShareEntry->pubKey = NULL;
7559:../src/src/tls.c ****     }
7560:../src/src/tls.c ****     XFREE(keyShareEntry->ke, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
7561:../src/src/tls.c ****     keyShareEntry->ke = NULL;
7562:../src/src/tls.c **** #else
7563:../src/src/tls.c ****     (void)ssl;
7564:../src/src/tls.c ****     (void)keyShareEntry;
7565:../src/src/tls.c ****     ret = PEER_KEY_ERROR;
7566:../src/src/tls.c **** #endif
7567:../src/src/tls.c ****     return ret;
7568:../src/src/tls.c **** }
7569:../src/src/tls.c **** 
7570:../src/src/tls.c **** /* Process the X25519 key share extension on the client side.
7571:../src/src/tls.c ****  *
7572:../src/src/tls.c ****  * ssl            The SSL/TLS object.
7573:../src/src/tls.c ****  * keyShareEntry  The key share entry object to use to calculate shared secret.
7574:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
7575:../src/src/tls.c ****  */
7576:../src/src/tls.c **** static int TLSX_KeyShare_ProcessX25519(WOLFSSL* ssl,
7577:../src/src/tls.c ****                                        KeyShareEntry* keyShareEntry)
7578:../src/src/tls.c **** {
7579:../src/src/tls.c ****     int ret;
7580:../src/src/tls.c **** 
7581:../src/src/tls.c **** #ifdef HAVE_CURVE25519
7582:../src/src/tls.c ****     curve25519_key* key = (curve25519_key*)keyShareEntry->key;
7583:../src/src/tls.c ****     curve25519_key* peerX25519Key;
7584:../src/src/tls.c **** 
7585:../src/src/tls.c **** #ifdef HAVE_ECC
7586:../src/src/tls.c ****     if (ssl->peerEccKey != NULL) {
7587:../src/src/tls.c ****         wc_ecc_free(ssl->peerEccKey);
7588:../src/src/tls.c ****         ssl->peerEccKey = NULL;
7589:../src/src/tls.c ****         ssl->peerEccKeyPresent = 0;
7590:../src/src/tls.c ****     }
7591:../src/src/tls.c **** #endif
7592:../src/src/tls.c **** 
7593:../src/src/tls.c ****     peerX25519Key = (curve25519_key*)XMALLOC(sizeof(curve25519_key), ssl->heap,
7594:../src/src/tls.c ****                                                              DYNAMIC_TYPE_TLSX);
7595:../src/src/tls.c ****     if (peerX25519Key == NULL) {
7596:../src/src/tls.c ****         WOLFSSL_MSG("PeerEccKey Memory error");
7597:../src/src/tls.c ****         return MEMORY_ERROR;
7598:../src/src/tls.c ****     }
7599:../src/src/tls.c ****     ret = wc_curve25519_init(peerX25519Key);
7600:../src/src/tls.c ****     if (ret != 0) {
7601:../src/src/tls.c ****         XFREE(peerX25519Key, ssl->heap, DYNAMIC_TYPE_TLSX);
7602:../src/src/tls.c ****         return ret;
7603:../src/src/tls.c ****     }
7604:../src/src/tls.c **** #ifdef WOLFSSL_DEBUG_TLS
7605:../src/src/tls.c ****     WOLFSSL_MSG("Peer Curve25519 Key");
7606:../src/src/tls.c ****     WOLFSSL_BUFFER(keyShareEntry->ke, keyShareEntry->keLen);
7607:../src/src/tls.c **** #endif
7608:../src/src/tls.c **** 
7609:../src/src/tls.c ****     if (wc_curve25519_check_public(keyShareEntry->ke, keyShareEntry->keLen,
7610:../src/src/tls.c ****                                                   EC25519_LITTLE_ENDIAN) != 0) {
7611:../src/src/tls.c ****         ret = ECC_PEERKEY_ERROR;
7612:../src/src/tls.c ****     }
7613:../src/src/tls.c **** 
7614:../src/src/tls.c ****     if (ret == 0) {
7615:../src/src/tls.c ****         if (wc_curve25519_import_public_ex(keyShareEntry->ke,
7616:../src/src/tls.c ****                                             keyShareEntry->keLen, peerX25519Key,
7617:../src/src/tls.c ****                                             EC25519_LITTLE_ENDIAN) != 0) {
7618:../src/src/tls.c ****             ret = ECC_PEERKEY_ERROR;
7619:../src/src/tls.c ****         }
7620:../src/src/tls.c ****     }
7621:../src/src/tls.c **** 
7622:../src/src/tls.c ****     if (ret == 0) {
7623:../src/src/tls.c ****         ssl->ecdhCurveOID = ECC_X25519_OID;
7624:../src/src/tls.c **** 
7625:../src/src/tls.c ****         ret = wc_curve25519_shared_secret_ex(key, peerX25519Key,
7626:../src/src/tls.c ****                                                    ssl->arrays->preMasterSecret,
7627:../src/src/tls.c ****                                                    &ssl->arrays->preMasterSz,
7628:../src/src/tls.c ****                                                    EC25519_LITTLE_ENDIAN);
7629:../src/src/tls.c ****     }
7630:../src/src/tls.c **** 
7631:../src/src/tls.c ****     wc_curve25519_free(peerX25519Key);
7632:../src/src/tls.c ****     XFREE(peerX25519Key, ssl->heap, DYNAMIC_TYPE_TLSX);
7633:../src/src/tls.c ****     wc_curve25519_free((curve25519_key*)keyShareEntry->key);
7634:../src/src/tls.c ****     if (keyShareEntry->key != NULL) {
7635:../src/src/tls.c ****         XFREE(keyShareEntry->key, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
7636:../src/src/tls.c ****         keyShareEntry->key = NULL;
7637:../src/src/tls.c ****     }
7638:../src/src/tls.c **** #else
7639:../src/src/tls.c ****     (void)ssl;
7640:../src/src/tls.c ****     (void)keyShareEntry;
7641:../src/src/tls.c **** 
7642:../src/src/tls.c ****     ret = PEER_KEY_ERROR;
7643:../src/src/tls.c **** #endif /* HAVE_CURVE25519 */
7644:../src/src/tls.c **** 
7645:../src/src/tls.c ****     return ret;
7646:../src/src/tls.c **** }
7647:../src/src/tls.c **** 
7648:../src/src/tls.c **** /* Process the X448 key share extension on the client side.
7649:../src/src/tls.c ****  *
7650:../src/src/tls.c ****  * ssl            The SSL/TLS object.
7651:../src/src/tls.c ****  * keyShareEntry  The key share entry object to use to calculate shared secret.
7652:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
7653:../src/src/tls.c ****  */
7654:../src/src/tls.c **** static int TLSX_KeyShare_ProcessX448(WOLFSSL* ssl, KeyShareEntry* keyShareEntry)
7655:../src/src/tls.c **** {
7656:../src/src/tls.c ****     int ret;
7657:../src/src/tls.c **** 
7658:../src/src/tls.c **** #ifdef HAVE_CURVE448
7659:../src/src/tls.c ****     curve448_key* key = (curve448_key*)keyShareEntry->key;
7660:../src/src/tls.c ****     curve448_key* peerX448Key;
7661:../src/src/tls.c **** 
7662:../src/src/tls.c **** #ifdef HAVE_ECC
7663:../src/src/tls.c ****     if (ssl->peerEccKey != NULL) {
7664:../src/src/tls.c ****         wc_ecc_free(ssl->peerEccKey);
7665:../src/src/tls.c ****         ssl->peerEccKey = NULL;
7666:../src/src/tls.c ****         ssl->peerEccKeyPresent = 0;
7667:../src/src/tls.c ****     }
7668:../src/src/tls.c **** #endif
7669:../src/src/tls.c **** 
7670:../src/src/tls.c ****     peerX448Key = (curve448_key*)XMALLOC(sizeof(curve448_key), ssl->heap,
7671:../src/src/tls.c ****                                                              DYNAMIC_TYPE_TLSX);
7672:../src/src/tls.c ****     if (peerX448Key == NULL) {
7673:../src/src/tls.c ****         WOLFSSL_MSG("PeerEccKey Memory error");
7674:../src/src/tls.c ****         return MEMORY_ERROR;
7675:../src/src/tls.c ****     }
7676:../src/src/tls.c ****     ret = wc_curve448_init(peerX448Key);
7677:../src/src/tls.c ****     if (ret != 0) {
7678:../src/src/tls.c ****         XFREE(peerX448Key, ssl->heap, DYNAMIC_TYPE_TLSX);
7679:../src/src/tls.c ****         return ret;
7680:../src/src/tls.c ****     }
7681:../src/src/tls.c **** #ifdef WOLFSSL_DEBUG_TLS
7682:../src/src/tls.c ****     WOLFSSL_MSG("Peer Curve448 Key");
7683:../src/src/tls.c ****     WOLFSSL_BUFFER(keyShareEntry->ke, keyShareEntry->keLen);
7684:../src/src/tls.c **** #endif
7685:../src/src/tls.c **** 
7686:../src/src/tls.c ****     if (wc_curve448_check_public(keyShareEntry->ke, keyShareEntry->keLen,
7687:../src/src/tls.c ****                                                     EC448_LITTLE_ENDIAN) != 0) {
7688:../src/src/tls.c ****         ret = ECC_PEERKEY_ERROR;
7689:../src/src/tls.c ****     }
7690:../src/src/tls.c **** 
7691:../src/src/tls.c ****     if (ret == 0) {
7692:../src/src/tls.c ****         if (wc_curve448_import_public_ex(keyShareEntry->ke,
7693:../src/src/tls.c ****                                               keyShareEntry->keLen, peerX448Key,
7694:../src/src/tls.c ****                                               EC448_LITTLE_ENDIAN) != 0) {
7695:../src/src/tls.c ****             ret = ECC_PEERKEY_ERROR;
7696:../src/src/tls.c ****         }
7697:../src/src/tls.c ****     }
7698:../src/src/tls.c **** 
7699:../src/src/tls.c ****     if (ret == 0) {
7700:../src/src/tls.c ****         ssl->ecdhCurveOID = ECC_X448_OID;
7701:../src/src/tls.c **** 
7702:../src/src/tls.c ****         ret = wc_curve448_shared_secret_ex(key, peerX448Key,
7703:../src/src/tls.c ****                                                    ssl->arrays->preMasterSecret,
7704:../src/src/tls.c ****                                                    &ssl->arrays->preMasterSz,
7705:../src/src/tls.c ****                                                    EC448_LITTLE_ENDIAN);
7706:../src/src/tls.c ****     }
7707:../src/src/tls.c **** 
7708:../src/src/tls.c ****     wc_curve448_free(peerX448Key);
7709:../src/src/tls.c ****     XFREE(peerX448Key, ssl->heap, DYNAMIC_TYPE_TLSX);
7710:../src/src/tls.c ****     wc_curve448_free((curve448_key*)keyShareEntry->key);
7711:../src/src/tls.c ****     if (keyShareEntry->key != NULL) {
7712:../src/src/tls.c ****         XFREE(keyShareEntry->key, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
7713:../src/src/tls.c ****         keyShareEntry->key = NULL;
7714:../src/src/tls.c ****     }
7715:../src/src/tls.c **** #else
7716:../src/src/tls.c ****     (void)ssl;
7717:../src/src/tls.c ****     (void)keyShareEntry;
7718:../src/src/tls.c **** 
7719:../src/src/tls.c ****     ret = PEER_KEY_ERROR;
7720:../src/src/tls.c **** #endif /* HAVE_CURVE448 */
7721:../src/src/tls.c **** 
7722:../src/src/tls.c ****     return ret;
7723:../src/src/tls.c **** }
7724:../src/src/tls.c **** 
7725:../src/src/tls.c **** /* Process the ECC key share extension on the client side.
7726:../src/src/tls.c ****  *
7727:../src/src/tls.c ****  * ssl            The SSL/TLS object.
7728:../src/src/tls.c ****  * keyShareEntry  The key share entry object to use to calculate shared secret.
7729:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
7730:../src/src/tls.c ****  */
7731:../src/src/tls.c **** static int TLSX_KeyShare_ProcessEcc(WOLFSSL* ssl, KeyShareEntry* keyShareEntry)
7732:../src/src/tls.c **** {
7733:../src/src/tls.c ****     int ret = 0;
7734:../src/src/tls.c **** #ifdef HAVE_ECC
7735:../src/src/tls.c ****     int curveId = ECC_CURVE_INVALID;
7736:../src/src/tls.c ****     ecc_key* eccKey = (ecc_key*)keyShareEntry->key;
7737:../src/src/tls.c **** 
7738:../src/src/tls.c ****     /* find supported curve */
7739:../src/src/tls.c ****     switch (keyShareEntry->group) {
7740:../src/src/tls.c ****     #if (!defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
7741:../src/src/tls.c ****         #ifndef NO_ECC_SECP
7742:../src/src/tls.c ****         case WOLFSSL_ECC_SECP256R1:
7743:../src/src/tls.c ****             curveId = ECC_SECP256R1;
7744:../src/src/tls.c ****             break;
7745:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
7746:../src/src/tls.c ****     #endif
7747:../src/src/tls.c ****     #if (defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 384
7748:../src/src/tls.c ****         #ifndef NO_ECC_SECP
7749:../src/src/tls.c ****         case WOLFSSL_ECC_SECP384R1:
7750:../src/src/tls.c ****             curveId = ECC_SECP384R1;
7751:../src/src/tls.c ****             break;
7752:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
7753:../src/src/tls.c ****     #endif
7754:../src/src/tls.c ****     #if (defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 521
7755:../src/src/tls.c ****         #ifndef NO_ECC_SECP
7756:../src/src/tls.c ****         case WOLFSSL_ECC_SECP521R1:
7757:../src/src/tls.c ****             curveId = ECC_SECP521R1;
7758:../src/src/tls.c ****             break;
7759:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
7760:../src/src/tls.c ****     #endif
7761:../src/src/tls.c ****     #if defined(HAVE_X448) && ECC_MIN_KEY_SZ <= 448
7762:../src/src/tls.c ****         case WOLFSSL_ECC_X448:
7763:../src/src/tls.c ****             curveId = ECC_X448;
7764:../src/src/tls.c ****             break;
7765:../src/src/tls.c ****     #endif
7766:../src/src/tls.c ****         default:
7767:../src/src/tls.c ****             /* unsupported curve */
7768:../src/src/tls.c ****             return ECC_PEERKEY_ERROR;
7769:../src/src/tls.c ****     }
7770:../src/src/tls.c **** 
7771:../src/src/tls.c **** #ifdef WOLFSSL_ASYNC_CRYPT
7772:../src/src/tls.c ****     if (keyShareEntry->lastRet == 0) /* don't enter here if WC_PENDING_E */
7773:../src/src/tls.c **** #endif
7774:../src/src/tls.c ****     {
7775:../src/src/tls.c ****     #ifdef WOLFSSL_DEBUG_TLS
7776:../src/src/tls.c ****         WOLFSSL_MSG("Peer ECC Key");
7777:../src/src/tls.c ****         WOLFSSL_BUFFER(keyShareEntry->ke, keyShareEntry->keLen);
7778:../src/src/tls.c ****     #endif
7779:../src/src/tls.c **** 
7780:../src/src/tls.c ****         if (ssl->peerEccKey != NULL) {
7781:../src/src/tls.c ****             wc_ecc_free(ssl->peerEccKey);
7782:../src/src/tls.c ****             XFREE(ssl->peerEccKey, ssl->heap, DYNAMIC_TYPE_ECC);
7783:../src/src/tls.c ****             ssl->peerEccKeyPresent = 0;
7784:../src/src/tls.c ****         }
7785:../src/src/tls.c **** #if defined(WOLFSSL_RENESAS_TSIP_TLS) && (WOLFSSL_RENESAS_TSIP_VER >= 115)
7786:../src/src/tls.c ****         ret = tsip_Tls13GenSharedSecret(ssl, keyShareEntry);
7787:../src/src/tls.c ****         if (ret != CRYPTOCB_UNAVAILABLE) {
7788:../src/src/tls.c ****             return ret;
7789:../src/src/tls.c ****         }
7790:../src/src/tls.c **** #endif
7791:../src/src/tls.c **** 
7792:../src/src/tls.c ****         ssl->peerEccKey = (ecc_key*)XMALLOC(sizeof(ecc_key), ssl->heap,
7793:../src/src/tls.c ****                                             DYNAMIC_TYPE_ECC);
7794:../src/src/tls.c ****         if (ssl->peerEccKey == NULL) {
7795:../src/src/tls.c ****             WOLFSSL_MSG("PeerEccKey Memory error");
7796:../src/src/tls.c ****             ret = MEMORY_ERROR;
7797:../src/src/tls.c ****         }
7798:../src/src/tls.c **** 
7799:../src/src/tls.c ****         if (ret == 0) {
7800:../src/src/tls.c ****             ret = wc_ecc_init_ex(ssl->peerEccKey, ssl->heap, ssl->devId);
7801:../src/src/tls.c ****         }
7802:../src/src/tls.c **** 
7803:../src/src/tls.c ****         /* Point is validated by import function. */
7804:../src/src/tls.c ****         if (ret == 0) {
7805:../src/src/tls.c ****             ret = wc_ecc_import_x963_ex(keyShareEntry->ke, keyShareEntry->keLen,
7806:../src/src/tls.c ****                                 ssl->peerEccKey, curveId);
7807:../src/src/tls.c ****             if (ret != 0) {
7808:../src/src/tls.c ****                 ret = ECC_PEERKEY_ERROR;
7809:../src/src/tls.c ****             }
7810:../src/src/tls.c ****         }
7811:../src/src/tls.c **** 
7812:../src/src/tls.c ****         if (ret == 0) {
7813:../src/src/tls.c ****             ssl->ecdhCurveOID = ssl->peerEccKey->dp->oidSum;
7814:../src/src/tls.c ****             ssl->peerEccKeyPresent = 1;
7815:../src/src/tls.c ****         }
7816:../src/src/tls.c ****     }
7817:../src/src/tls.c **** 
7818:../src/src/tls.c ****     if (ret == 0 && eccKey == NULL)
7819:../src/src/tls.c ****         ret = BAD_FUNC_ARG;
7820:../src/src/tls.c ****     if (ret == 0) {
7821:../src/src/tls.c ****         ret = EccSharedSecret(ssl, eccKey, ssl->peerEccKey,
7822:../src/src/tls.c ****             keyShareEntry->ke, &keyShareEntry->keLen,
7823:../src/src/tls.c ****             ssl->arrays->preMasterSecret, &ssl->arrays->preMasterSz,
7824:../src/src/tls.c ****             ssl->options.side
7825:../src/src/tls.c ****         );
7826:../src/src/tls.c ****     #ifdef WOLFSSL_ASYNC_CRYPT
7827:../src/src/tls.c ****         if (ret == WC_PENDING_E)
7828:../src/src/tls.c ****             return ret;
7829:../src/src/tls.c ****     #endif
7830:../src/src/tls.c ****     }
7831:../src/src/tls.c **** 
7832:../src/src/tls.c ****     /* done with key share, release resources */
7833:../src/src/tls.c ****     if (ssl->peerEccKey != NULL
7834:../src/src/tls.c ****     #ifdef HAVE_PK_CALLBACKS
7835:../src/src/tls.c ****         && ssl->ctx->EccSharedSecretCb == NULL
7836:../src/src/tls.c ****     #endif
7837:../src/src/tls.c ****     ) {
7838:../src/src/tls.c ****         wc_ecc_free(ssl->peerEccKey);
7839:../src/src/tls.c ****         XFREE(ssl->peerEccKey, ssl->heap, DYNAMIC_TYPE_ECC);
7840:../src/src/tls.c ****         ssl->peerEccKey = NULL;
7841:../src/src/tls.c ****         ssl->peerEccKeyPresent = 0;
7842:../src/src/tls.c ****     }
7843:../src/src/tls.c ****     if (keyShareEntry->key) {
7844:../src/src/tls.c ****         wc_ecc_free((ecc_key*)keyShareEntry->key);
7845:../src/src/tls.c ****         XFREE(keyShareEntry->key, ssl->heap, DYNAMIC_TYPE_ECC);
7846:../src/src/tls.c ****         keyShareEntry->key = NULL;
7847:../src/src/tls.c ****     }
7848:../src/src/tls.c ****     XFREE(keyShareEntry->ke, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
7849:../src/src/tls.c ****     keyShareEntry->ke = NULL;
7850:../src/src/tls.c **** #else
7851:../src/src/tls.c ****     (void)ssl;
7852:../src/src/tls.c ****     (void)keyShareEntry;
7853:../src/src/tls.c **** 
7854:../src/src/tls.c ****     ret = PEER_KEY_ERROR;
7855:../src/src/tls.c **** #endif /* HAVE_ECC */
7856:../src/src/tls.c **** 
7857:../src/src/tls.c ****     return ret;
7858:../src/src/tls.c **** }
7859:../src/src/tls.c **** 
7860:../src/src/tls.c **** #ifdef HAVE_PQC
7861:../src/src/tls.c **** #ifdef HAVE_LIBOQS
7862:../src/src/tls.c **** /* Process the liboqs key share extension on the client side.
7863:../src/src/tls.c ****  *
7864:../src/src/tls.c ****  * ssl            The SSL/TLS object.
7865:../src/src/tls.c ****  * keyShareEntry  The key share entry object to use to calculate shared secret.
7866:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
7867:../src/src/tls.c ****  */
7868:../src/src/tls.c **** static int TLSX_KeyShare_ProcessPqc(WOLFSSL* ssl, KeyShareEntry* keyShareEntry)
7869:../src/src/tls.c **** {
7870:../src/src/tls.c ****     int           ret = 0;
7871:../src/src/tls.c ****     const char*   algName = NULL;
7872:../src/src/tls.c ****     OQS_KEM*      kem = NULL;
7873:../src/src/tls.c ****     byte*         sharedSecret = NULL;
7874:../src/src/tls.c ****     word32        sharedSecretLen = 0;
7875:../src/src/tls.c ****     int           oqs_group = 0;
7876:../src/src/tls.c ****     int           ecc_group = 0;
7877:../src/src/tls.c ****     ecc_key       eccpubkey;
7878:../src/src/tls.c ****     word32        outlen = 0;
7879:../src/src/tls.c **** 
7880:../src/src/tls.c ****     if (keyShareEntry->ke == NULL) {
7881:../src/src/tls.c ****         WOLFSSL_MSG("Invalid OQS algorithm specified.");
7882:../src/src/tls.c ****         return BAD_FUNC_ARG;
7883:../src/src/tls.c ****     }
7884:../src/src/tls.c **** 
7885:../src/src/tls.c ****     if (ssl->options.side == WOLFSSL_SERVER_END) {
7886:../src/src/tls.c ****         /* I am the server, the shared secret has already been generated and
7887:../src/src/tls.c ****          * is in keyShareEntry->ke; copy it to the pre-master secret
7888:../src/src/tls.c ****          * pre-allocated buffer. */
7889:../src/src/tls.c ****         if (keyShareEntry->keLen > ENCRYPT_LEN) {
7890:../src/src/tls.c ****             WOLFSSL_MSG("shared secret is too long.");
7891:../src/src/tls.c ****             return LENGTH_ERROR;
7892:../src/src/tls.c ****         }
7893:../src/src/tls.c **** 
7894:../src/src/tls.c ****         XMEMCPY(ssl->arrays->preMasterSecret, keyShareEntry->ke, keyShareEntry->keLen);
7895:../src/src/tls.c ****         ssl->arrays->preMasterSz = keyShareEntry->keLen;
7896:../src/src/tls.c ****         XFREE(keyShareEntry->ke, sl->heap, DYNAMIC_TYPE_SECRET)
7897:../src/src/tls.c ****         keyShareEntry->ke = NULL;
7898:../src/src/tls.c ****         keyShareEntry->keLen = 0;
7899:../src/src/tls.c ****         return 0;
7900:../src/src/tls.c ****     }
7901:../src/src/tls.c **** 
7902:../src/src/tls.c ****     /* I am the client, the ciphertext is in keyShareEntry->ke */
7903:../src/src/tls.c ****     findEccPqc(&ecc_group, &oqs_group, keyShareEntry->group);
7904:../src/src/tls.c **** 
7905:../src/src/tls.c ****     algName = OQS_ID2name(oqs_group);
7906:../src/src/tls.c ****     if (algName == NULL) {
7907:../src/src/tls.c ****         WOLFSSL_MSG("Invalid OQS algorithm specified.");
7908:../src/src/tls.c ****         return BAD_FUNC_ARG;
7909:../src/src/tls.c ****     }
7910:../src/src/tls.c **** 
7911:../src/src/tls.c ****     kem = OQS_KEM_new(algName);
7912:../src/src/tls.c ****     if (kem == NULL) {
7913:../src/src/tls.c ****         WOLFSSL_MSG("Error creating OQS KEM, ensure algorithm support"
7914:../src/src/tls.c ****                     "was enabled in liboqs.");
7915:../src/src/tls.c ****         return MEMORY_E;
7916:../src/src/tls.c ****     }
7917:../src/src/tls.c **** 
7918:../src/src/tls.c ****     sharedSecretLen = (word32)kem->length_shared_secret;
7919:../src/src/tls.c ****     switch (ecc_group) {
7920:../src/src/tls.c ****     case WOLFSSL_ECC_SECP256R1:
7921:../src/src/tls.c ****         sharedSecretLen += 32;
7922:../src/src/tls.c ****         outlen = 32;
7923:../src/src/tls.c ****         break;
7924:../src/src/tls.c ****     case WOLFSSL_ECC_SECP384R1:
7925:../src/src/tls.c ****         sharedSecretLen += 48;
7926:../src/src/tls.c ****         outlen = 48;
7927:../src/src/tls.c ****         break;
7928:../src/src/tls.c ****     case WOLFSSL_ECC_SECP521R1:
7929:../src/src/tls.c ****         sharedSecretLen += 66;
7930:../src/src/tls.c ****         outlen = 66;
7931:../src/src/tls.c ****         break;
7932:../src/src/tls.c ****     default:
7933:../src/src/tls.c ****         break;
7934:../src/src/tls.c ****     }
7935:../src/src/tls.c **** 
7936:../src/src/tls.c ****     ret = wc_ecc_init_ex(&eccpubkey, ssl->heap, ssl->devId);
7937:../src/src/tls.c ****     if (ret != 0) {
7938:../src/src/tls.c ****         WOLFSSL_MSG("Memory allocation error.");
7939:../src/src/tls.c ****         return MEMORY_E;
7940:../src/src/tls.c ****     }
7941:../src/src/tls.c **** 
7942:../src/src/tls.c ****     sharedSecret = (byte*)XMALLOC(sharedSecretLen, ssl->heap,
7943:../src/src/tls.c ****                                   DYNAMIC_TYPE_TLSX);
7944:../src/src/tls.c ****     if (sharedSecret == NULL) {
7945:../src/src/tls.c ****         WOLFSSL_MSG("Memory allocation error.");
7946:../src/src/tls.c ****         ret = MEMORY_E;
7947:../src/src/tls.c ****     }
7948:../src/src/tls.c **** 
7949:../src/src/tls.c ****     if (ret == 0 && OQS_KEM_decaps(kem, sharedSecret + outlen,
7950:../src/src/tls.c ****                                    keyShareEntry->ke + keyShareEntry->keLen -
7951:../src/src/tls.c ****                                    kem->length_ciphertext,
7952:../src/src/tls.c ****                                    keyShareEntry->privKey) != OQS_SUCCESS) {
7953:../src/src/tls.c ****         WOLFSSL_MSG("Liboqs decapsulation failure.");
7954:../src/src/tls.c ****         ret = BAD_FUNC_ARG;
7955:../src/src/tls.c ****     }
7956:../src/src/tls.c **** 
7957:../src/src/tls.c ****     if (ecc_group != 0) {
7958:../src/src/tls.c ****         if (ret == 0) {
7959:../src/src/tls.c ****             /* Point is validated by import function. */
7960:../src/src/tls.c ****             ret = wc_ecc_import_x963(keyShareEntry->ke,
7961:../src/src/tls.c ****                                      keyShareEntry->keLen -
7962:../src/src/tls.c ****                                      (word32)kem->length_ciphertext,
7963:../src/src/tls.c ****                                      &eccpubkey);
7964:../src/src/tls.c ****             if (ret != 0) {
7965:../src/src/tls.c ****                 WOLFSSL_MSG("ECC Public key import error.");
7966:../src/src/tls.c ****             }
7967:../src/src/tls.c ****         }
7968:../src/src/tls.c **** 
7969:../src/src/tls.c **** #if defined(ECC_TIMING_RESISTANT) && (!defined(HAVE_FIPS) || \
7970:../src/src/tls.c ****     (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION != 2))) && \
7971:../src/src/tls.c ****     !defined(HAVE_SELFTEST)
7972:../src/src/tls.c ****         if (ret == 0) {
7973:../src/src/tls.c ****             ret = wc_ecc_set_rng(keyShareEntry->key, ssl->rng);
7974:../src/src/tls.c ****             if (ret != 0) {
7975:../src/src/tls.c ****                 WOLFSSL_MSG("Failure to set the ECC private key RNG.");
7976:../src/src/tls.c ****             }
7977:../src/src/tls.c ****         }
7978:../src/src/tls.c **** #endif
7979:../src/src/tls.c **** 
7980:../src/src/tls.c ****         if (ret == 0) {
7981:../src/src/tls.c ****             PRIVATE_KEY_UNLOCK();
7982:../src/src/tls.c ****             ret = wc_ecc_shared_secret(keyShareEntry->key, &eccpubkey, sharedSecret, &outlen);
7983:../src/src/tls.c ****             PRIVATE_KEY_LOCK();
7984:../src/src/tls.c ****             if (outlen != sharedSecretLen - kem->length_shared_secret) {
7985:../src/src/tls.c ****                 WOLFSSL_MSG("ECC shared secret derivation error.");
7986:../src/src/tls.c ****                 ret = BAD_FUNC_ARG;
7987:../src/src/tls.c ****             }
7988:../src/src/tls.c ****         }
7989:../src/src/tls.c ****     }
7990:../src/src/tls.c **** 
7991:../src/src/tls.c ****     if (sharedSecretLen > ENCRYPT_LEN) {
7992:../src/src/tls.c ****         WOLFSSL_MSG("shared secret is too long.");
7993:../src/src/tls.c ****         ret = LENGTH_ERROR;
7994:../src/src/tls.c ****     }
7995:../src/src/tls.c **** 
7996:../src/src/tls.c ****     if (ret == 0) {
7997:../src/src/tls.c ****          /* Copy the shared secret to the  pre-master secret pre-allocated
7998:../src/src/tls.c ****           * buffer. */
7999:../src/src/tls.c ****         XMEMCPY(ssl->arrays->preMasterSecret, sharedSecret, sharedSecretLen);
8000:../src/src/tls.c ****         ssl->arrays->preMasterSz = (word32) sharedSecretLen;
8001:../src/src/tls.c ****     }
8002:../src/src/tls.c **** 
8003:../src/src/tls.c ****     if (sharedSecret != NULL) {
8004:../src/src/tls.c ****         XFREE(sharedSecret, ssl->heap, DYNAMIC_TYPE_SECRET);
8005:../src/src/tls.c ****     }
8006:../src/src/tls.c **** 
8007:../src/src/tls.c ****     wc_ecc_free(&eccpubkey);
8008:../src/src/tls.c ****     OQS_KEM_free(kem);
8009:../src/src/tls.c ****     return ret;
8010:../src/src/tls.c **** }
8011:../src/src/tls.c **** #elif defined(HAVE_PQM4)
8012:../src/src/tls.c **** static int TLSX_KeyShare_ProcessPqc(WOLFSSL* ssl, KeyShareEntry* keyShareEntry)
8013:../src/src/tls.c **** {
8014:../src/src/tls.c ****     int           ret = 0;
8015:../src/src/tls.c ****     byte*         sharedSecret = NULL;
8016:../src/src/tls.c ****     word32        sharedSecretLen = 0;
8017:../src/src/tls.c ****     int           oqs_group = 0;
8018:../src/src/tls.c ****     int           ecc_group = 0;
8019:../src/src/tls.c ****     ecc_key       eccpubkey;
8020:../src/src/tls.c ****     word32        outlen = 0;
8021:../src/src/tls.c **** 
8022:../src/src/tls.c ****     if (keyShareEntry->ke == NULL) {
8023:../src/src/tls.c ****         WOLFSSL_MSG("Invalid OQS algorithm specified.");
8024:../src/src/tls.c ****         return BAD_FUNC_ARG;
8025:../src/src/tls.c ****     }
8026:../src/src/tls.c **** 
8027:../src/src/tls.c ****     if (ssl->options.side == WOLFSSL_SERVER_END) {
8028:../src/src/tls.c ****         /* I am the server, the shared secret has already been generated and
8029:../src/src/tls.c ****          * is in keyShareEntry->ke; copy it to the pre-master secret
8030:../src/src/tls.c ****          * pre-allocated buffer. */
8031:../src/src/tls.c ****         if (keyShareEntry->keLen > ENCRYPT_LEN) {
8032:../src/src/tls.c ****             WOLFSSL_MSG("shared secret is too long.");
8033:../src/src/tls.c ****             return LENGTH_ERROR;
8034:../src/src/tls.c ****         }
8035:../src/src/tls.c **** 
8036:../src/src/tls.c ****         XMEMCPY(ssl->arrays->preMasterSecret, keyShareEntry->ke, keyShareEntry->keLen);
8037:../src/src/tls.c ****         ssl->arrays->preMasterSz = keyShareEntry->keLen;
8038:../src/src/tls.c ****         XFREE(keyShareEntry->ke, sl->heap, DYNAMIC_TYPE_SECRET);
8039:../src/src/tls.c ****         keyShareEntry->ke = NULL;
8040:../src/src/tls.c ****         keyShareEntry->keLen = 0;
8041:../src/src/tls.c ****         return 0;
8042:../src/src/tls.c ****     }
8043:../src/src/tls.c **** 
8044:../src/src/tls.c ****     /* I am the client, the ciphertext is in keyShareEntry->ke */
8045:../src/src/tls.c ****     findEccPqc(&ecc_group, &oqs_group, keyShareEntry->group);
8046:../src/src/tls.c **** 
8047:../src/src/tls.c ****     sharedSecretLen = (word32)PQM4_SHARED_SECRET_LENGTH;
8048:../src/src/tls.c ****     switch (ecc_group) {
8049:../src/src/tls.c ****     case WOLFSSL_ECC_SECP256R1:
8050:../src/src/tls.c ****         sharedSecretLen += 32;
8051:../src/src/tls.c ****         outlen = 32;
8052:../src/src/tls.c ****         break;
8053:../src/src/tls.c ****     case WOLFSSL_ECC_SECP384R1:
8054:../src/src/tls.c ****         sharedSecretLen += 48;
8055:../src/src/tls.c ****         outlen = 48;
8056:../src/src/tls.c ****         break;
8057:../src/src/tls.c ****     case WOLFSSL_ECC_SECP521R1:
8058:../src/src/tls.c ****         sharedSecretLen += 66;
8059:../src/src/tls.c ****         outlen = 66;
8060:../src/src/tls.c ****         break;
8061:../src/src/tls.c ****     default:
8062:../src/src/tls.c ****         break;
8063:../src/src/tls.c ****     }
8064:../src/src/tls.c **** 
8065:../src/src/tls.c ****     ret = wc_ecc_init_ex(&eccpubkey, ssl->heap, ssl->devId);
8066:../src/src/tls.c ****     if (ret != 0) {
8067:../src/src/tls.c ****         WOLFSSL_MSG("Memory allocation error.");
8068:../src/src/tls.c ****         return MEMORY_E;
8069:../src/src/tls.c ****     }
8070:../src/src/tls.c **** 
8071:../src/src/tls.c ****     sharedSecret = (byte*)XMALLOC(sharedSecretLen, ssl->heap,
8072:../src/src/tls.c ****                                   DYNAMIC_TYPE_TLSX);
8073:../src/src/tls.c ****     if (sharedSecret == NULL) {
8074:../src/src/tls.c ****         WOLFSSL_MSG("Memory allocation error.");
8075:../src/src/tls.c ****         ret = MEMORY_E;
8076:../src/src/tls.c ****     }
8077:../src/src/tls.c **** 
8078:../src/src/tls.c ****     if (ret == 0 && crypto_kem_dec(sharedSecret + outlen,
8079:../src/src/tls.c ****                                    keyShareEntry->ke + keyShareEntry->keLen -
8080:../src/src/tls.c ****                                    PQM4_CIPHERTEXT_LENGTH,
8081:../src/src/tls.c ****                                    keyShareEntry->privKey) != 0) {
8082:../src/src/tls.c ****         WOLFSSL_MSG("PQM4 decapsulation failure.");
8083:../src/src/tls.c ****         ret = BAD_FUNC_ARG;
8084:../src/src/tls.c ****     } else {
8085:../src/src/tls.c ****         WOLFSSL_MSG("PQM4 decapsulation SUCCESS!!!!!");
8086:../src/src/tls.c ****     }
8087:../src/src/tls.c **** 
8088:../src/src/tls.c ****     if (ecc_group != 0) {
8089:../src/src/tls.c ****         if (ret == 0) {
8090:../src/src/tls.c ****             /* Point is validated by import function. */
8091:../src/src/tls.c ****             ret = wc_ecc_import_x963(keyShareEntry->ke,
8092:../src/src/tls.c ****                                      keyShareEntry->keLen -
8093:../src/src/tls.c ****                                      (word32)PQM4_CIPHERTEXT_LENGTH,
8094:../src/src/tls.c ****                                      &eccpubkey);
8095:../src/src/tls.c ****             if (ret != 0) {
8096:../src/src/tls.c ****                 WOLFSSL_MSG("ECC Public key import error.");
8097:../src/src/tls.c ****             }
8098:../src/src/tls.c ****         }
8099:../src/src/tls.c **** 
8100:../src/src/tls.c **** #if defined(ECC_TIMING_RESISTANT) && (!defined(HAVE_FIPS) || \
8101:../src/src/tls.c ****     (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION != 2))) && \
8102:../src/src/tls.c ****     !defined(HAVE_SELFTEST)
8103:../src/src/tls.c ****         if (ret == 0) {
8104:../src/src/tls.c ****             ret = wc_ecc_set_rng(keyShareEntry->key, ssl->rng);
8105:../src/src/tls.c ****             if (ret != 0) {
8106:../src/src/tls.c ****                 WOLFSSL_MSG("Failure to set the ECC private key RNG.");
8107:../src/src/tls.c ****             }
8108:../src/src/tls.c ****         }
8109:../src/src/tls.c **** #endif
8110:../src/src/tls.c **** 
8111:../src/src/tls.c ****         if (ret == 0) {
8112:../src/src/tls.c ****             PRIVATE_KEY_UNLOCK();
8113:../src/src/tls.c ****             ret = wc_ecc_shared_secret(keyShareEntry->key, &eccpubkey, sharedSecret, &outlen);
8114:../src/src/tls.c ****             PRIVATE_KEY_LOCK();
8115:../src/src/tls.c ****             if (outlen != sharedSecretLen - PQM4_SHARED_SECRET_LENGTH) {
8116:../src/src/tls.c ****                 WOLFSSL_MSG("ECC shared secret derivation error.");
8117:../src/src/tls.c ****                 ret = BAD_FUNC_ARG;
8118:../src/src/tls.c ****             }
8119:../src/src/tls.c ****         }
8120:../src/src/tls.c ****     }
8121:../src/src/tls.c **** 
8122:../src/src/tls.c ****     if (sharedSecretLen > ENCRYPT_LEN) {
8123:../src/src/tls.c ****         WOLFSSL_MSG("shared secret is too long.\n");
8124:../src/src/tls.c ****         ret = LENGTH_ERROR;
8125:../src/src/tls.c ****     }
8126:../src/src/tls.c **** 
8127:../src/src/tls.c ****     if (ret == 0) {
8128:../src/src/tls.c ****          /* Copy the shared secret to the  pre-master secret pre-allocated
8129:../src/src/tls.c ****           * buffer. */
8130:../src/src/tls.c ****         XMEMCPY(ssl->arrays->preMasterSecret, sharedSecret, sharedSecretLen);
8131:../src/src/tls.c ****         ssl->arrays->preMasterSz = (word32) sharedSecretLen;
8132:../src/src/tls.c ****     }
8133:../src/src/tls.c **** 
8134:../src/src/tls.c ****     if (sharedSecret != NULL) {
8135:../src/src/tls.c ****         XFREE(sharedSecret, ssl->heap, DYNAMIC_TYPE_SECRET);
8136:../src/src/tls.c ****     }
8137:../src/src/tls.c **** 
8138:../src/src/tls.c ****     wc_ecc_free(&eccpubkey);
8139:../src/src/tls.c ****     return ret;
8140:../src/src/tls.c **** }
8141:../src/src/tls.c **** #endif /* HAVE_PQM4 */
8142:../src/src/tls.c **** #endif /* HAVE_PQC */
8143:../src/src/tls.c **** 
8144:../src/src/tls.c **** /* Process the key share extension on the client side.
8145:../src/src/tls.c ****  *
8146:../src/src/tls.c ****  * ssl            The SSL/TLS object.
8147:../src/src/tls.c ****  * keyShareEntry  The key share entry object to use to calculate shared secret.
8148:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
8149:../src/src/tls.c ****  */
8150:../src/src/tls.c **** static int TLSX_KeyShare_Process(WOLFSSL* ssl, KeyShareEntry* keyShareEntry)
8151:../src/src/tls.c **** {
8152:../src/src/tls.c ****     int ret;
8153:../src/src/tls.c **** 
8154:../src/src/tls.c **** #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
8155:../src/src/tls.c ****     ssl->session->namedGroup = (byte)keyShareEntry->group;
8156:../src/src/tls.c **** #endif
8157:../src/src/tls.c ****     /* reset the pre master secret size */
8158:../src/src/tls.c ****     if (ssl->arrays->preMasterSz == 0)
8159:../src/src/tls.c ****         ssl->arrays->preMasterSz = ENCRYPT_LEN;
8160:../src/src/tls.c **** 
8161:../src/src/tls.c ****     /* Use Key Share Data from server. */
8162:../src/src/tls.c ****     if (keyShareEntry->group >= MIN_FFHDE_GROUP &&
8163:../src/src/tls.c ****         keyShareEntry->group <= MAX_FFHDE_GROUP)
8164:../src/src/tls.c ****         ret = TLSX_KeyShare_ProcessDh(ssl, keyShareEntry);
8165:../src/src/tls.c ****     else if (keyShareEntry->group == WOLFSSL_ECC_X25519)
8166:../src/src/tls.c ****         ret = TLSX_KeyShare_ProcessX25519(ssl, keyShareEntry);
8167:../src/src/tls.c ****     else if (keyShareEntry->group == WOLFSSL_ECC_X448)
8168:../src/src/tls.c ****         ret = TLSX_KeyShare_ProcessX448(ssl, keyShareEntry);
8169:../src/src/tls.c **** #ifdef HAVE_PQC
8170:../src/src/tls.c ****     else if (keyShareEntry->group >= WOLFSSL_PQC_MIN &&
8171:../src/src/tls.c ****              keyShareEntry->group <= WOLFSSL_PQC_MAX)
8172:../src/src/tls.c ****         ret = TLSX_KeyShare_ProcessPqc(ssl, keyShareEntry);
8173:../src/src/tls.c **** #endif
8174:../src/src/tls.c ****     else
8175:../src/src/tls.c ****         ret = TLSX_KeyShare_ProcessEcc(ssl, keyShareEntry);
8176:../src/src/tls.c **** 
8177:../src/src/tls.c **** #ifdef WOLFSSL_DEBUG_TLS
8178:../src/src/tls.c ****     if (ret == 0) {
8179:../src/src/tls.c ****         WOLFSSL_MSG("KE Secret");
8180:../src/src/tls.c ****         WOLFSSL_BUFFER(ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz);
8181:../src/src/tls.c ****     }
8182:../src/src/tls.c **** #endif
8183:../src/src/tls.c **** #ifdef WOLFSSL_ASYNC_CRYPT
8184:../src/src/tls.c ****     keyShareEntry->lastRet = ret;
8185:../src/src/tls.c **** #endif
8186:../src/src/tls.c **** 
8187:../src/src/tls.c ****     return ret;
8188:../src/src/tls.c **** }
8189:../src/src/tls.c **** 
8190:../src/src/tls.c **** /* Parse an entry of the KeyShare extension.
8191:../src/src/tls.c ****  *
8192:../src/src/tls.c ****  * ssl     The SSL/TLS object.
8193:../src/src/tls.c ****  * input   The extension data.
8194:../src/src/tls.c ****  * length  The length of the extension data.
8195:../src/src/tls.c ****  * kse     The new key share entry object.
8196:../src/src/tls.c ****  * returns a positive number to indicate amount of data parsed and a negative
8197:../src/src/tls.c ****  * number on error.
8198:../src/src/tls.c ****  */
8199:../src/src/tls.c **** static int TLSX_KeyShareEntry_Parse(WOLFSSL* ssl, const byte* input,
8200:../src/src/tls.c ****                                     word16 length, KeyShareEntry **kse)
8201:../src/src/tls.c **** {
8202:../src/src/tls.c ****     int    ret;
8203:../src/src/tls.c ****     word16 group;
8204:../src/src/tls.c ****     word16 keLen;
8205:../src/src/tls.c ****     int    offset = 0;
8206:../src/src/tls.c ****     byte*  ke;
8207:../src/src/tls.c **** 
8208:../src/src/tls.c ****     if (length < OPAQUE16_LEN + OPAQUE16_LEN)
8209:../src/src/tls.c ****         return BUFFER_ERROR;
8210:../src/src/tls.c ****     /* Named group */
8211:../src/src/tls.c ****     ato16(&input[offset], &group);
8212:../src/src/tls.c ****     offset += OPAQUE16_LEN;
8213:../src/src/tls.c ****     /* Key exchange data - public key. */
8214:../src/src/tls.c ****     ato16(&input[offset], &keLen);
8215:../src/src/tls.c ****     offset += OPAQUE16_LEN;
8216:../src/src/tls.c ****     if (keLen == 0)
8217:../src/src/tls.c ****         return INVALID_PARAMETER;
8218:../src/src/tls.c ****     if (keLen > length - offset)
8219:../src/src/tls.c ****         return BUFFER_ERROR;
8220:../src/src/tls.c **** 
8221:../src/src/tls.c **** #ifdef HAVE_PQC
8222:../src/src/tls.c ****     if (group >= WOLFSSL_PQC_MIN &&
8223:../src/src/tls.c ****         group <= WOLFSSL_PQC_MAX &&
8224:../src/src/tls.c ****         ssl->options.side == WOLFSSL_SERVER_END) {
8225:../src/src/tls.c ****         /* For KEMs, the public key is not stored. Casting away const because
8226:../src/src/tls.c ****          * we know for KEMs, it will be read-only.*/
8227:../src/src/tls.c ****         ke = (byte *)&input[offset];
8228:../src/src/tls.c ****     } else
8229:../src/src/tls.c **** #endif
8230:../src/src/tls.c ****     {
8231:../src/src/tls.c ****         /* Store a copy in the key share object. */
8232:../src/src/tls.c ****         ke = (byte*)XMALLOC(keLen, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
8233:../src/src/tls.c ****         if (ke == NULL)
8234:../src/src/tls.c ****             return MEMORY_E;
8235:../src/src/tls.c ****         XMEMCPY(ke, &input[offset], keLen);
8236:../src/src/tls.c ****     }
8237:../src/src/tls.c **** 
8238:../src/src/tls.c ****     /* Populate a key share object in the extension. */
8239:../src/src/tls.c ****     ret = TLSX_KeyShare_Use(ssl, group, keLen, ke, kse);
8240:../src/src/tls.c ****     if (ret != 0) {
8241:../src/src/tls.c ****         if (ke != &input[offset]) {
8242:../src/src/tls.c ****             XFREE(ke, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
8243:../src/src/tls.c ****         }
8244:../src/src/tls.c ****         return ret;
8245:../src/src/tls.c ****     }
8246:../src/src/tls.c **** 
8247:../src/src/tls.c ****     /* Total length of the parsed data. */
8248:../src/src/tls.c ****     return offset + keLen;
8249:../src/src/tls.c **** }
8250:../src/src/tls.c **** 
8251:../src/src/tls.c **** /* Searches the groups sent for the specified named group.
8252:../src/src/tls.c ****  *
8253:../src/src/tls.c ****  * ssl    SSL/TLS object.
8254:../src/src/tls.c ****  * name   Group name to match.
8255:../src/src/tls.c ****  * returns 1 when the extension has the group name and 0 otherwise.
8256:../src/src/tls.c ****  */
8257:../src/src/tls.c **** static int TLSX_KeyShare_Find(WOLFSSL* ssl, word16 group)
8258:../src/src/tls.c **** {
8259:../src/src/tls.c ****     TLSX*          extension;
8260:../src/src/tls.c ****     KeyShareEntry* list;
8261:../src/src/tls.c **** 
8262:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
8263:../src/src/tls.c ****     if (extension == NULL) {
8264:../src/src/tls.c ****         extension = TLSX_Find(ssl->ctx->extensions, TLSX_KEY_SHARE);
8265:../src/src/tls.c ****         if (extension == NULL)
8266:../src/src/tls.c ****             return 0;
8267:../src/src/tls.c ****     }
8268:../src/src/tls.c **** 
8269:../src/src/tls.c ****     list = (KeyShareEntry*)extension->data;
8270:../src/src/tls.c ****     while (list != NULL) {
8271:../src/src/tls.c ****         if (list->group == group)
8272:../src/src/tls.c ****             return 1;
8273:../src/src/tls.c ****         list = list->next;
8274:../src/src/tls.c ****     }
8275:../src/src/tls.c **** 
8276:../src/src/tls.c ****     return 0;
8277:../src/src/tls.c **** }
8278:../src/src/tls.c **** 
8279:../src/src/tls.c **** 
8280:../src/src/tls.c **** /* Searches the supported groups extension for the specified named group.
8281:../src/src/tls.c ****  *
8282:../src/src/tls.c ****  * ssl   The SSL/TLS object.
8283:../src/src/tls.c ****  * name  The group name to match.
8284:../src/src/tls.c ****  * returns 1 when the extension has the group name and 0 otherwise.
8285:../src/src/tls.c ****  */
8286:../src/src/tls.c **** static int TLSX_SupportedGroups_Find(WOLFSSL* ssl, word16 name)
8287:../src/src/tls.c **** {
8288:../src/src/tls.c **** #ifdef HAVE_SUPPORTED_CURVES
8289:../src/src/tls.c ****     TLSX*          extension;
8290:../src/src/tls.c ****     SupportedCurve* curve = NULL;
8291:../src/src/tls.c **** 
8292:../src/src/tls.c ****     if ((extension = TLSX_Find(ssl->extensions,
8293:../src/src/tls.c ****                                               TLSX_SUPPORTED_GROUPS)) == NULL) {
8294:../src/src/tls.c ****         if ((extension = TLSX_Find(ssl->ctx->extensions,
8295:../src/src/tls.c ****                                               TLSX_SUPPORTED_GROUPS)) == NULL) {
8296:../src/src/tls.c ****             return 0;
8297:../src/src/tls.c ****         }
8298:../src/src/tls.c ****     }
8299:../src/src/tls.c **** 
8300:../src/src/tls.c ****     for (curve = (SupportedCurve*)extension->data; curve; curve = curve->next) {
8301:../src/src/tls.c ****         if (curve->name == name)
8302:../src/src/tls.c ****             return 1;
8303:../src/src/tls.c ****     }
8304:../src/src/tls.c **** #endif
8305:../src/src/tls.c **** 
8306:../src/src/tls.c ****     (void)ssl;
8307:../src/src/tls.c ****     (void)name;
8308:../src/src/tls.c **** 
8309:../src/src/tls.c ****     return 0;
8310:../src/src/tls.c **** }
8311:../src/src/tls.c **** 
8312:../src/src/tls.c **** 
8313:../src/src/tls.c **** /* Parse the KeyShare extension.
8314:../src/src/tls.c ****  * Different formats in different messages.
8315:../src/src/tls.c ****  *
8316:../src/src/tls.c ****  * ssl      The SSL/TLS object.
8317:../src/src/tls.c ****  * input    The extension data.
8318:../src/src/tls.c ****  * length   The length of the extension data.
8319:../src/src/tls.c ****  * msgType  The type of the message this extension is being parsed from.
8320:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
8321:../src/src/tls.c ****  */
8322:../src/src/tls.c **** static int TLSX_KeyShare_Parse(WOLFSSL* ssl, const byte* input, word16 length,
8323:../src/src/tls.c ****                                byte msgType)
8324:../src/src/tls.c **** {
8325:../src/src/tls.c ****     int ret;
8326:../src/src/tls.c ****     KeyShareEntry *keyShareEntry = NULL;
8327:../src/src/tls.c ****     word16 group;
8328:../src/src/tls.c **** 
8329:../src/src/tls.c ****     if (msgType == client_hello) {
8330:../src/src/tls.c ****         int    offset = 0;
8331:../src/src/tls.c ****         word16 len;
8332:../src/src/tls.c ****         TLSX*  extension;
8333:../src/src/tls.c **** 
8334:../src/src/tls.c ****         /* Add a KeyShare extension if it doesn't exist. */
8335:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
8336:../src/src/tls.c ****         if (extension == NULL) {
8337:../src/src/tls.c ****             /* Push new KeyShare extension. */
8338:../src/src/tls.c ****             ret = TLSX_Push(&ssl->extensions, TLSX_KEY_SHARE, NULL, ssl->heap);
8339:../src/src/tls.c ****             if (ret != 0)
8340:../src/src/tls.c ****                 return ret;
8341:../src/src/tls.c ****         }
8342:../src/src/tls.c **** 
8343:../src/src/tls.c ****         if (length < OPAQUE16_LEN)
8344:../src/src/tls.c ****             return BUFFER_ERROR;
8345:../src/src/tls.c **** 
8346:../src/src/tls.c ****         /* ClientHello contains zero or more key share entries. */
8347:../src/src/tls.c ****         ato16(input, &len);
8348:../src/src/tls.c ****         if (len != length - OPAQUE16_LEN)
8349:../src/src/tls.c ****             return BUFFER_ERROR;
8350:../src/src/tls.c ****         offset += OPAQUE16_LEN;
8351:../src/src/tls.c **** 
8352:../src/src/tls.c ****         while (offset < (int)length) {
8353:../src/src/tls.c ****             ret = TLSX_KeyShareEntry_Parse(ssl, &input[offset],
8354:../src/src/tls.c ****                                                         length - (word16)offset,
8355:../src/src/tls.c ****                                                         &keyShareEntry);
8356:../src/src/tls.c ****             if (ret < 0)
8357:../src/src/tls.c ****                 return ret;
8358:../src/src/tls.c **** 
8359:../src/src/tls.c ****             offset += ret;
8360:../src/src/tls.c ****         }
8361:../src/src/tls.c **** 
8362:../src/src/tls.c ****         ret = 0;
8363:../src/src/tls.c ****     }
8364:../src/src/tls.c ****     else if (msgType == server_hello) {
8365:../src/src/tls.c ****         int len;
8366:../src/src/tls.c **** 
8367:../src/src/tls.c ****         if (length < OPAQUE16_LEN)
8368:../src/src/tls.c ****             return BUFFER_ERROR;
8369:../src/src/tls.c **** 
8370:../src/src/tls.c ****         /* The data is the named group the server wants to use. */
8371:../src/src/tls.c ****         ato16(input, &group);
8372:../src/src/tls.c **** 
8373:../src/src/tls.c ****         /* Check the selected group was supported by ClientHello extensions. */
8374:../src/src/tls.c ****         if (!TLSX_SupportedGroups_Find(ssl, group))
8375:../src/src/tls.c ****             return BAD_KEY_SHARE_DATA;
8376:../src/src/tls.c **** 
8377:../src/src/tls.c ****         /* Check if the group was sent. */
8378:../src/src/tls.c ****         if (!TLSX_KeyShare_Find(ssl, group))
8379:../src/src/tls.c ****             return BAD_KEY_SHARE_DATA;
8380:../src/src/tls.c **** 
8381:../src/src/tls.c ****         /* ServerHello contains one key share entry. */
8382:../src/src/tls.c ****         len = TLSX_KeyShareEntry_Parse(ssl, input, length, &keyShareEntry);
8383:../src/src/tls.c ****         if (len != (int)length)
8384:../src/src/tls.c ****             return BUFFER_ERROR;
8385:../src/src/tls.c **** 
8386:../src/src/tls.c ****         /* Not in list sent if there isn't a private key. */
8387:../src/src/tls.c ****         if (keyShareEntry == NULL || (keyShareEntry->key == NULL
8388:../src/src/tls.c ****         #if !defined(NO_DH) || defined(HAVE_PQC)
8389:../src/src/tls.c ****             && keyShareEntry->privKey == NULL
8390:../src/src/tls.c ****         #endif
8391:../src/src/tls.c ****         )) {
8392:../src/src/tls.c ****             return BAD_KEY_SHARE_DATA;
8393:../src/src/tls.c ****         }
8394:../src/src/tls.c **** 
8395:../src/src/tls.c ****         /* Process the entry to calculate the secret. */
8396:../src/src/tls.c ****         ret = TLSX_KeyShare_Process(ssl, keyShareEntry);
8397:../src/src/tls.c ****         if (ret == 0)
8398:../src/src/tls.c ****             ssl->session->namedGroup = ssl->namedGroup = group;
8399:../src/src/tls.c ****     }
8400:../src/src/tls.c ****     else if (msgType == hello_retry_request) {
8401:../src/src/tls.c ****         if (length != OPAQUE16_LEN)
8402:../src/src/tls.c ****             return BUFFER_ERROR;
8403:../src/src/tls.c **** 
8404:../src/src/tls.c ****         /* The data is the named group the server wants to use. */
8405:../src/src/tls.c ****         ato16(input, &group);
8406:../src/src/tls.c **** 
8407:../src/src/tls.c ****     #ifdef WOLFSSL_ASYNC_CRYPT
8408:../src/src/tls.c ****         /* only perform find and clear TLSX if not returning from async */
8409:../src/src/tls.c ****         if (ssl->error != WC_PENDING_E)
8410:../src/src/tls.c ****     #endif
8411:../src/src/tls.c ****         {
8412:../src/src/tls.c ****             /* Check the selected group was supported by ClientHello extensions. */
8413:../src/src/tls.c ****             if (!TLSX_SupportedGroups_Find(ssl, group))
8414:../src/src/tls.c ****                 return BAD_KEY_SHARE_DATA;
8415:../src/src/tls.c **** 
8416:../src/src/tls.c ****             /* Check if the group was sent. */
8417:../src/src/tls.c ****             if (TLSX_KeyShare_Find(ssl, group))
8418:../src/src/tls.c ****                 return BAD_KEY_SHARE_DATA;
8419:../src/src/tls.c **** 
8420:../src/src/tls.c ****             /* Clear out unusable key shares. */
8421:../src/src/tls.c ****             ret = TLSX_KeyShare_Empty(ssl);
8422:../src/src/tls.c ****             if (ret != 0)
8423:../src/src/tls.c ****                 return ret;
8424:../src/src/tls.c ****         }
8425:../src/src/tls.c **** 
8426:../src/src/tls.c **** #ifdef HAVE_PQC
8427:../src/src/tls.c ****         /* For post-quantum groups, do this in TLSX_PopulateExtensions(). */
8428:../src/src/tls.c ****         if (group < WOLFSSL_PQC_MIN || group > WOLFSSL_PQC_MAX)
8429:../src/src/tls.c **** #endif
8430:../src/src/tls.c ****             ret = TLSX_KeyShare_Use(ssl, group, 0, NULL, NULL);
8431:../src/src/tls.c ****     }
8432:../src/src/tls.c ****     else {
8433:../src/src/tls.c ****         /* Not a message type that is allowed to have this extension. */
8434:../src/src/tls.c ****         return SANITY_MSG_E;
8435:../src/src/tls.c ****     }
8436:../src/src/tls.c **** 
8437:../src/src/tls.c ****     return ret;
8438:../src/src/tls.c **** }
8439:../src/src/tls.c **** 
8440:../src/src/tls.c **** /* Create a new key share entry and put it into the list.
8441:../src/src/tls.c ****  *
8442:../src/src/tls.c ****  * list           The linked list of key share entries.
8443:../src/src/tls.c ****  * group          The named group.
8444:../src/src/tls.c ****  * heap           The memory to allocate with.
8445:../src/src/tls.c ****  * keyShareEntry  The new key share entry object.
8446:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
8447:../src/src/tls.c ****  */
8448:../src/src/tls.c **** static int TLSX_KeyShare_New(KeyShareEntry** list, int group, void *heap,
8449:../src/src/tls.c ****                              KeyShareEntry** keyShareEntry)
8450:../src/src/tls.c **** {
8451:../src/src/tls.c ****     KeyShareEntry* kse;
8452:../src/src/tls.c ****     KeyShareEntry** next;
8453:../src/src/tls.c **** 
8454:../src/src/tls.c ****     kse = (KeyShareEntry*)XMALLOC(sizeof(KeyShareEntry), heap,
8455:../src/src/tls.c ****                                   DYNAMIC_TYPE_TLSX);
8456:../src/src/tls.c ****     if (kse == NULL)
8457:../src/src/tls.c ****         return MEMORY_E;
8458:../src/src/tls.c **** 
8459:../src/src/tls.c ****     XMEMSET(kse, 0, sizeof(*kse));
8460:../src/src/tls.c ****     kse->group = (word16)group;
8461:../src/src/tls.c **** 
8462:../src/src/tls.c ****     /* Add it to the back and maintain the links. */
8463:../src/src/tls.c ****     while (*list != NULL) {
8464:../src/src/tls.c ****         /* Assign to temporary to work around compiler bug found by customer. */
8465:../src/src/tls.c ****         next = &((*list)->next);
8466:../src/src/tls.c ****         list = next;
8467:../src/src/tls.c ****     }
8468:../src/src/tls.c ****     *list = kse;
8469:../src/src/tls.c ****     *keyShareEntry = kse;
8470:../src/src/tls.c **** 
8471:../src/src/tls.c ****     (void)heap;
8472:../src/src/tls.c **** 
8473:../src/src/tls.c ****     return 0;
8474:../src/src/tls.c **** }
8475:../src/src/tls.c **** 
8476:../src/src/tls.c **** #ifdef HAVE_PQC
8477:../src/src/tls.c **** #ifdef HAVE_LIBOQS
8478:../src/src/tls.c **** static int server_generate_pqc_ciphertext(WOLFSSL* ssl,
8479:../src/src/tls.c ****                                           KeyShareEntry* keyShareEntry,
8480:../src/src/tls.c ****                                           byte* data, word16 len) {
8481:../src/src/tls.c ****     /* I am the server. The data parameter is the client's public key. I need
8482:../src/src/tls.c ****      * to generate the public information (AKA ciphertext) and shared secret
8483:../src/src/tls.c ****      * here. Note the "public information" is equivalent to a the public key in
8484:../src/src/tls.c ****      * key exchange parlance. That's why it is being assigned to pubKey.
8485:../src/src/tls.c ****      */
8486:../src/src/tls.c ****     const char* algName = NULL;
8487:../src/src/tls.c ****     OQS_KEM* kem = NULL;
8488:../src/src/tls.c ****     byte* sharedSecret = NULL;
8489:../src/src/tls.c ****     byte* ciphertext = NULL;
8490:../src/src/tls.c ****     int ret = 0;
8491:../src/src/tls.c ****     int oqs_group = 0;
8492:../src/src/tls.c ****     int ecc_group = 0;
8493:../src/src/tls.c ****     KeyShareEntry *ecc_kse = NULL;
8494:../src/src/tls.c ****     ecc_key eccpubkey;
8495:../src/src/tls.c ****     word32 outlen = 0;
8496:../src/src/tls.c **** 
8497:../src/src/tls.c ****     findEccPqc(&ecc_group, &oqs_group, keyShareEntry->group);
8498:../src/src/tls.c ****     algName = OQS_ID2name(oqs_group);
8499:../src/src/tls.c ****     if (algName == NULL) {
8500:../src/src/tls.c ****         WOLFSSL_MSG("Invalid OQS algorithm specified.");
8501:../src/src/tls.c ****         return BAD_FUNC_ARG;
8502:../src/src/tls.c ****     }
8503:../src/src/tls.c **** 
8504:../src/src/tls.c ****     ret = wc_ecc_init_ex(&eccpubkey, ssl->heap, ssl->devId);
8505:../src/src/tls.c ****     if (ret != 0) {
8506:../src/src/tls.c ****         WOLFSSL_MSG("Could not do ECC public key initialization.");
8507:../src/src/tls.c ****         return MEMORY_E;
8508:../src/src/tls.c ****     }
8509:../src/src/tls.c **** 
8510:../src/src/tls.c ****     ecc_kse = (KeyShareEntry*)XMALLOC(sizeof(*ecc_kse), ssl->heap, DYNAMIC_TYPE_TLSX);
8511:../src/src/tls.c ****     if (ecc_kse == NULL) {
8512:../src/src/tls.c ****         WOLFSSL_MSG("ecc_kse memory allocation failure");
8513:../src/src/tls.c ****         ret = MEMORY_ERROR;
8514:../src/src/tls.c ****     }
8515:../src/src/tls.c **** 
8516:../src/src/tls.c ****     if (ret == 0) {
8517:../src/src/tls.c ****         XMEMSET(ecc_kse, 0, sizeof(*ecc_kse));
8518:../src/src/tls.c ****     }
8519:../src/src/tls.c **** 
8520:../src/src/tls.c ****     if (ret == 0 && ecc_group != 0) {
8521:../src/src/tls.c ****         ecc_kse->group = ecc_group;
8522:../src/src/tls.c ****         ret = TLSX_KeyShare_GenEccKey(ssl, ecc_kse);
8523:../src/src/tls.c ****         if (ret != 0) {
8524:../src/src/tls.c ****             /* No message, TLSX_KeyShare_GenEccKey() will do it. */
8525:../src/src/tls.c ****             return ret;
8526:../src/src/tls.c ****         }
8527:../src/src/tls.c ****         ret = 0;
8528:../src/src/tls.c ****     }
8529:../src/src/tls.c **** 
8530:../src/src/tls.c ****     if (ret == 0) {
8531:../src/src/tls.c ****         kem = OQS_KEM_new(algName);
8532:../src/src/tls.c ****         if (kem == NULL) {
8533:../src/src/tls.c ****             WOLFSSL_MSG("Error creating OQS KEM, ensure algorithm support "
8534:../src/src/tls.c ****                         "was enabled in liboqs.");
8535:../src/src/tls.c ****             ret = MEMORY_E;
8536:../src/src/tls.c ****         }
8537:../src/src/tls.c ****     }
8538:../src/src/tls.c **** 
8539:../src/src/tls.c ****     if (ret == 0 && len != kem->length_public_key + ecc_kse->pubKeyLen) {
8540:../src/src/tls.c ****         WOLFSSL_MSG("Invalid public key.");
8541:../src/src/tls.c ****         ret = BAD_FUNC_ARG;
8542:../src/src/tls.c ****     }
8543:../src/src/tls.c **** 
8544:../src/src/tls.c ****     if (ret == 0) {
8545:../src/src/tls.c ****         sharedSecret = (byte*)XMALLOC(ecc_kse->keyLen +
8546:../src/src/tls.c ****                                       kem->length_shared_secret,
8547:../src/src/tls.c ****                                       ssl->heap, DYNAMIC_TYPE_TLSX);
8548:../src/src/tls.c ****         ciphertext = (byte*)XMALLOC(ecc_kse->pubKeyLen + kem->length_ciphertext,
8549:../src/src/tls.c ****                                     ssl->heap, DYNAMIC_TYPE_TLSX);
8550:../src/src/tls.c **** 
8551:../src/src/tls.c ****         if (sharedSecret == NULL || ciphertext == NULL) {
8552:../src/src/tls.c ****             WOLFSSL_MSG("Ciphertext/shared secret memory allocation failure.");
8553:../src/src/tls.c ****             ret = MEMORY_E;
8554:../src/src/tls.c ****         }
8555:../src/src/tls.c ****     }
8556:../src/src/tls.c **** 
8557:../src/src/tls.c ****     if (ecc_group != 0) {
8558:../src/src/tls.c ****         if (ret == 0) {
8559:../src/src/tls.c ****             /* Point is validated by import function. */
8560:../src/src/tls.c ****             ret = wc_ecc_import_x963(data, len - (word32)kem->length_public_key,
8561:../src/src/tls.c ****                                      &eccpubkey);
8562:../src/src/tls.c ****             if (ret != 0) {
8563:../src/src/tls.c ****                 WOLFSSL_MSG("Bad ECC public key.");
8564:../src/src/tls.c ****             }
8565:../src/src/tls.c ****         }
8566:../src/src/tls.c **** 
8567:../src/src/tls.c **** #if defined(ECC_TIMING_RESISTANT) && (!defined(HAVE_FIPS) || \
8568:../src/src/tls.c ****     (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION != 2))) && \
8569:../src/src/tls.c ****     !defined(HAVE_SELFTEST)
8570:../src/src/tls.c ****         if (ret == 0) {
8571:../src/src/tls.c ****             ret = wc_ecc_set_rng(ecc_kse->key, ssl->rng);
8572:../src/src/tls.c ****         }
8573:../src/src/tls.c **** #endif
8574:../src/src/tls.c **** 
8575:../src/src/tls.c ****         if (ret == 0) {
8576:../src/src/tls.c ****             outlen = ecc_kse->keyLen;
8577:../src/src/tls.c ****             PRIVATE_KEY_UNLOCK();
8578:../src/src/tls.c ****             ret = wc_ecc_shared_secret(ecc_kse->key, &eccpubkey,
8579:../src/src/tls.c ****                                        sharedSecret,
8580:../src/src/tls.c ****                                        &outlen);
8581:../src/src/tls.c ****             PRIVATE_KEY_LOCK();
8582:../src/src/tls.c ****             if (outlen != ecc_kse->keyLen) {
8583:../src/src/tls.c ****                 WOLFSSL_MSG("Data length mismatch.");
8584:../src/src/tls.c ****                 ret = BAD_FUNC_ARG;
8585:../src/src/tls.c ****             }
8586:../src/src/tls.c ****         }
8587:../src/src/tls.c ****     }
8588:../src/src/tls.c **** 
8589:../src/src/tls.c ****     if (ret == 0 &&
8590:../src/src/tls.c ****         OQS_KEM_encaps(kem, ciphertext + ecc_kse->pubKeyLen,
8591:../src/src/tls.c ****                        sharedSecret + outlen,
8592:../src/src/tls.c ****                        data + ecc_kse->pubKeyLen) != OQS_SUCCESS) {
8593:../src/src/tls.c ****         WOLFSSL_MSG("OQS Encapsulation failure.");
8594:../src/src/tls.c ****         ret = BAD_FUNC_ARG;
8595:../src/src/tls.c ****     }
8596:../src/src/tls.c **** 
8597:../src/src/tls.c ****     if (ret == 0) {
8598:../src/src/tls.c ****         if (keyShareEntry->ke != NULL) {
8599:../src/src/tls.c ****             XFREE(keyShareEntry->ke, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
8600:../src/src/tls.c ****         }
8601:../src/src/tls.c **** 
8602:../src/src/tls.c ****         keyShareEntry->ke = sharedSecret;
8603:../src/src/tls.c ****         keyShareEntry->keLen = outlen + (word32)kem->length_shared_secret;
8604:../src/src/tls.c ****         sharedSecret = NULL;
8605:../src/src/tls.c **** 
8606:../src/src/tls.c ****         XMEMCPY(ciphertext, ecc_kse->pubKey, ecc_kse->pubKeyLen);
8607:../src/src/tls.c ****         keyShareEntry->pubKey = ciphertext;
8608:../src/src/tls.c ****         keyShareEntry->pubKeyLen = (word32)(ecc_kse->pubKeyLen +
8609:../src/src/tls.c ****                                    kem->length_ciphertext);
8610:../src/src/tls.c ****         ciphertext = NULL;
8611:../src/src/tls.c ****     }
8612:../src/src/tls.c **** 
8613:../src/src/tls.c ****     TLSX_KeyShare_FreeAll(ecc_kse, ssl->heap);
8614:../src/src/tls.c ****     if (sharedSecret != NULL)
8615:../src/src/tls.c ****         XFREE(sharedSecret, ssl->heap, DYNAMIC_TYPE_TLSX);
8616:../src/src/tls.c ****     if (ciphertext != NULL)
8617:../src/src/tls.c ****         XFREE(ciphertext, ssl->heap, DYNAMIC_TYPE_TLSX);
8618:../src/src/tls.c ****     wc_ecc_free(&eccpubkey);
8619:../src/src/tls.c ****     OQS_KEM_free(kem);
8620:../src/src/tls.c ****     return ret;
8621:../src/src/tls.c **** }
8622:../src/src/tls.c **** #elif defined(HAVE_PQM4)
8623:../src/src/tls.c **** static int server_generate_pqc_ciphertext(WOLFSSL* ssl,
8624:../src/src/tls.c ****                                           KeyShareEntry* keyShareEntry,
8625:../src/src/tls.c ****                                           byte* data, word16 len) {
8626:../src/src/tls.c ****     /* I am the server. The data parameter is the client's public key. I need
8627:../src/src/tls.c ****      * to generate the public information (AKA ciphertext) and shared secret
8628:../src/src/tls.c ****      * here. Note the "public information" is equivalent to a the public key in
8629:../src/src/tls.c ****      * key exchange parlance. That's why it is being assigned to pubKey.
8630:../src/src/tls.c ****      */
8631:../src/src/tls.c ****     byte* sharedSecret = NULL;
8632:../src/src/tls.c ****     byte* ciphertext = NULL;
8633:../src/src/tls.c ****     int ret = 0;
8634:../src/src/tls.c ****     int oqs_group = 0;
8635:../src/src/tls.c ****     int ecc_group = 0;
8636:../src/src/tls.c ****     KeyShareEntry *ecc_kse = NULL;
8637:../src/src/tls.c ****     ecc_key eccpubkey;
8638:../src/src/tls.c ****     word32 outlen = 0;
8639:../src/src/tls.c **** 
8640:../src/src/tls.c ****     findEccPqc(&ecc_group, &oqs_group, keyShareEntry->group);
8641:../src/src/tls.c ****     ret = wc_ecc_init_ex(&eccpubkey, ssl->heap, ssl->devId);
8642:../src/src/tls.c ****     if (ret != 0) {
8643:../src/src/tls.c ****         WOLFSSL_MSG("Could not do ECC public key initialization.");
8644:../src/src/tls.c ****         return MEMORY_E;
8645:../src/src/tls.c ****     }
8646:../src/src/tls.c **** 
8647:../src/src/tls.c ****     ecc_kse = (KeyShareEntry*)XMALLOC(sizeof(*ecc_kse), ssl->heap, DYNAMIC_TYPE_TLSX);
8648:../src/src/tls.c ****     if (ecc_kse == NULL) {
8649:../src/src/tls.c ****         WOLFSSL_MSG("ecc_kse memory allocation failure");
8650:../src/src/tls.c ****         ret = MEMORY_ERROR;
8651:../src/src/tls.c ****     }
8652:../src/src/tls.c **** 
8653:../src/src/tls.c ****     if (ret == 0) {
8654:../src/src/tls.c ****         XMEMSET(ecc_kse, 0, sizeof(*ecc_kse));
8655:../src/src/tls.c ****     }
8656:../src/src/tls.c **** 
8657:../src/src/tls.c ****     if (ret == 0 && ecc_group != 0) {
8658:../src/src/tls.c ****         ecc_kse->group = ecc_group;
8659:../src/src/tls.c ****         ret = TLSX_KeyShare_GenEccKey(ssl, ecc_kse);
8660:../src/src/tls.c ****         if (ret != 0) {
8661:../src/src/tls.c ****             /* No message, TLSX_KeyShare_GenEccKey() will do it. */
8662:../src/src/tls.c ****             return ret;
8663:../src/src/tls.c ****         }
8664:../src/src/tls.c ****         ret = 0;
8665:../src/src/tls.c ****     }
8666:../src/src/tls.c **** 
8667:../src/src/tls.c ****     if (ret == 0 && len != PQM4_PUBLIC_KEY_LENGTH + ecc_kse->pubKeyLen) {
8668:../src/src/tls.c ****         WOLFSSL_MSG("Invalid public key.");
8669:../src/src/tls.c ****         ret = BAD_FUNC_ARG;
8670:../src/src/tls.c ****     }
8671:../src/src/tls.c **** 
8672:../src/src/tls.c ****     if (ret == 0) {
8673:../src/src/tls.c ****         sharedSecret = (byte*)XMALLOC(ecc_kse->keyLen + PQM4_SHARED_SECRET_LENGTH,
8674:../src/src/tls.c ****                                       ssl->heap, DYNAMIC_TYPE_TLSX);
8675:../src/src/tls.c ****         ciphertext = (byte*)XMALLOC(ecc_kse->pubKeyLen + PQM4_CIPHERTEXT_LENGTH,
8676:../src/src/tls.c ****                                     ssl->heap, DYNAMIC_TYPE_TLSX);
8677:../src/src/tls.c **** 
8678:../src/src/tls.c ****         if (sharedSecret == NULL || ciphertext == NULL) {
8679:../src/src/tls.c ****             WOLFSSL_MSG("Ciphertext/shared secret memory allocation failure.");
8680:../src/src/tls.c ****             ret = MEMORY_E;
8681:../src/src/tls.c ****         }
8682:../src/src/tls.c ****     }
8683:../src/src/tls.c **** 
8684:../src/src/tls.c ****     if (ecc_group != 0) {
8685:../src/src/tls.c ****         if (ret == 0) {
8686:../src/src/tls.c ****             /* Point is validated by import function. */
8687:../src/src/tls.c ****             ret = wc_ecc_import_x963(data, len - PQM4_PUBLIC_KEY_LENGTH,
8688:../src/src/tls.c ****                                      &eccpubkey);
8689:../src/src/tls.c ****             if (ret != 0) {
8690:../src/src/tls.c ****                 WOLFSSL_MSG("Bad ECC public key.");
8691:../src/src/tls.c ****             }
8692:../src/src/tls.c ****         }
8693:../src/src/tls.c **** 
8694:../src/src/tls.c **** #if defined(ECC_TIMING_RESISTANT) && (!defined(HAVE_FIPS) || \
8695:../src/src/tls.c ****     (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION != 2))) && \
8696:../src/src/tls.c ****     !defined(HAVE_SELFTEST)
8697:../src/src/tls.c ****         if (ret == 0) {
8698:../src/src/tls.c ****             ret = wc_ecc_set_rng(ecc_kse->key, ssl->rng);
8699:../src/src/tls.c ****         }
8700:../src/src/tls.c **** #endif
8701:../src/src/tls.c **** 
8702:../src/src/tls.c ****         if (ret == 0) {
8703:../src/src/tls.c ****             outlen = ecc_kse->keyLen;
8704:../src/src/tls.c ****             PRIVATE_KEY_UNLOCK();
8705:../src/src/tls.c ****             ret = wc_ecc_shared_secret(ecc_kse->key, &eccpubkey,
8706:../src/src/tls.c ****                                        sharedSecret,
8707:../src/src/tls.c ****                                        &outlen);
8708:../src/src/tls.c ****             PRIVATE_KEY_LOCK();
8709:../src/src/tls.c ****             if (outlen != ecc_kse->keyLen) {
8710:../src/src/tls.c ****                 WOLFSSL_MSG("Data length mismatch.");
8711:../src/src/tls.c ****                 ret = BAD_FUNC_ARG;
8712:../src/src/tls.c ****             }
8713:../src/src/tls.c ****         }
8714:../src/src/tls.c ****     }
8715:../src/src/tls.c **** 
8716:../src/src/tls.c ****     if (ret == 0 &&
8717:../src/src/tls.c ****         crypto_kem_enc(ciphertext + ecc_kse->pubKeyLen,
8718:../src/src/tls.c ****                        sharedSecret + outlen,
8719:../src/src/tls.c ****                        data + ecc_kse->pubKeyLen) != 0) {
8720:../src/src/tls.c ****         WOLFSSL_MSG("PQM4 Encapsulation failure.");
8721:../src/src/tls.c ****         ret = BAD_FUNC_ARG;
8722:../src/src/tls.c ****     }
8723:../src/src/tls.c **** 
8724:../src/src/tls.c ****     if (ret == 0) {
8725:../src/src/tls.c ****         if (keyShareEntry->ke != NULL) {
8726:../src/src/tls.c ****             XFREE(keyShareEntry->ke, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
8727:../src/src/tls.c ****         }
8728:../src/src/tls.c **** 
8729:../src/src/tls.c ****         keyShareEntry->ke = sharedSecret;
8730:../src/src/tls.c ****         keyShareEntry->keLen = outlen + (word32)PQM4_SHARED_SECRET_LENGTH;
8731:../src/src/tls.c ****         sharedSecret = NULL;
8732:../src/src/tls.c **** 
8733:../src/src/tls.c ****         XMEMCPY(ciphertext, ecc_kse->pubKey, ecc_kse->pubKeyLen);
8734:../src/src/tls.c ****         keyShareEntry->pubKey = ciphertext;
8735:../src/src/tls.c ****         keyShareEntry->pubKeyLen = (word32)(ecc_kse->pubKeyLen +
8736:../src/src/tls.c ****                                    PQM4_CIPHERTEXT_LENGTH);
8737:../src/src/tls.c ****         ciphertext = NULL;
8738:../src/src/tls.c ****     }
8739:../src/src/tls.c **** 
8740:../src/src/tls.c ****     TLSX_KeyShare_FreeAll(ecc_kse, ssl->heap);
8741:../src/src/tls.c ****     if (sharedSecret != NULL)
8742:../src/src/tls.c ****         XFREE(sharedSecret, ssl->heap, DYNAMIC_TYPE_TLSX);
8743:../src/src/tls.c ****     if (ciphertext != NULL)
8744:../src/src/tls.c ****         XFREE(ciphertext, ssl->heap, DYNAMIC_TYPE_TLSX);
8745:../src/src/tls.c ****     wc_ecc_free(&eccpubkey);
8746:../src/src/tls.c ****     return ret;
8747:../src/src/tls.c **** }
8748:../src/src/tls.c **** #endif /* HAVE_PQM4 */
8749:../src/src/tls.c **** #endif /* HAVE_PQC */
8750:../src/src/tls.c **** 
8751:../src/src/tls.c **** /* Use the data to create a new key share object in the extensions.
8752:../src/src/tls.c ****  *
8753:../src/src/tls.c ****  * ssl    The SSL/TLS object.
8754:../src/src/tls.c ****  * group  The named group.
8755:../src/src/tls.c ****  * len    The length of the public key data.
8756:../src/src/tls.c ****  * data   The public key data.
8757:../src/src/tls.c ****  * kse    The new key share entry object.
8758:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
8759:../src/src/tls.c ****  */
8760:../src/src/tls.c **** int TLSX_KeyShare_Use(WOLFSSL* ssl, word16 group, word16 len, byte* data,
8761:../src/src/tls.c ****                       KeyShareEntry **kse)
8762:../src/src/tls.c **** {
8763:../src/src/tls.c ****     int            ret = 0;
8764:../src/src/tls.c ****     TLSX*          extension;
8765:../src/src/tls.c ****     KeyShareEntry* keyShareEntry = NULL;
8766:../src/src/tls.c **** 
8767:../src/src/tls.c ****     /* Find the KeyShare extension if it exists. */
8768:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
8769:../src/src/tls.c ****     if (extension == NULL) {
8770:../src/src/tls.c ****         /* Push new KeyShare extension. */
8771:../src/src/tls.c ****         ret = TLSX_Push(&ssl->extensions, TLSX_KEY_SHARE, NULL, ssl->heap);
8772:../src/src/tls.c ****         if (ret != 0)
8773:../src/src/tls.c ****             return ret;
8774:../src/src/tls.c **** 
8775:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
8776:../src/src/tls.c ****         if (extension == NULL)
8777:../src/src/tls.c ****             return MEMORY_E;
8778:../src/src/tls.c ****     }
8779:../src/src/tls.c ****     extension->resp = 0;
8780:../src/src/tls.c **** 
8781:../src/src/tls.c ****     /* Try to find the key share entry with this group. */
8782:../src/src/tls.c ****     keyShareEntry = (KeyShareEntry*)extension->data;
8783:../src/src/tls.c ****     while (keyShareEntry != NULL) {
8784:../src/src/tls.c ****         if (keyShareEntry->group == group)
8785:../src/src/tls.c ****             break;
8786:../src/src/tls.c ****         keyShareEntry = keyShareEntry->next;
8787:../src/src/tls.c ****     }
8788:../src/src/tls.c **** 
8789:../src/src/tls.c ****     /* Create a new key share entry if not found. */
8790:../src/src/tls.c ****     if (keyShareEntry == NULL) {
8791:../src/src/tls.c ****         ret = TLSX_KeyShare_New((KeyShareEntry**)&extension->data, group,
8792:../src/src/tls.c ****                                 ssl->heap, &keyShareEntry);
8793:../src/src/tls.c ****         if (ret != 0)
8794:../src/src/tls.c ****             return ret;
8795:../src/src/tls.c ****     }
8796:../src/src/tls.c **** 
8797:../src/src/tls.c **** 
8798:../src/src/tls.c **** #ifdef HAVE_PQC
8799:../src/src/tls.c ****     if (group >= WOLFSSL_PQC_MIN &&
8800:../src/src/tls.c ****         group <= WOLFSSL_PQC_MAX &&
8801:../src/src/tls.c ****         ssl->options.side == WOLFSSL_SERVER_END) {
8802:../src/src/tls.c ****         ret = server_generate_pqc_ciphertext(ssl, keyShareEntry, data,
8803:../src/src/tls.c ****                                              len);
8804:../src/src/tls.c ****         if (ret != 0)
8805:../src/src/tls.c ****             return ret;
8806:../src/src/tls.c ****     }
8807:../src/src/tls.c ****     else
8808:../src/src/tls.c **** #endif
8809:../src/src/tls.c ****     if (data != NULL) {
8810:../src/src/tls.c ****         if (keyShareEntry->ke != NULL) {
8811:../src/src/tls.c ****             XFREE(keyShareEntry->ke, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
8812:../src/src/tls.c ****         }
8813:../src/src/tls.c ****         keyShareEntry->ke = data;
8814:../src/src/tls.c ****         keyShareEntry->keLen = len;
8815:../src/src/tls.c ****     }
8816:../src/src/tls.c ****     else {
8817:../src/src/tls.c ****         /* Generate a key pair. */
8818:../src/src/tls.c ****         ret = TLSX_KeyShare_GenKey(ssl, keyShareEntry);
8819:../src/src/tls.c ****         if (ret != 0)
8820:../src/src/tls.c ****             return ret;
8821:../src/src/tls.c ****     }
8822:../src/src/tls.c **** 
8823:../src/src/tls.c ****     if (kse != NULL)
8824:../src/src/tls.c ****         *kse = keyShareEntry;
8825:../src/src/tls.c **** 
8826:../src/src/tls.c ****     return 0;
8827:../src/src/tls.c **** }
8828:../src/src/tls.c **** 
8829:../src/src/tls.c **** /* Set an empty Key Share extension.
8830:../src/src/tls.c ****  *
8831:../src/src/tls.c ****  * ssl  The SSL/TLS object.
8832:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
8833:../src/src/tls.c ****  */
8834:../src/src/tls.c **** int TLSX_KeyShare_Empty(WOLFSSL* ssl)
8835:../src/src/tls.c **** {
8836:../src/src/tls.c ****     int   ret = 0;
8837:../src/src/tls.c ****     TLSX* extension;
8838:../src/src/tls.c **** 
8839:../src/src/tls.c ****     /* Find the KeyShare extension if it exists. */
8840:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
8841:../src/src/tls.c ****     if (extension == NULL) {
8842:../src/src/tls.c ****         /* Push new KeyShare extension. */
8843:../src/src/tls.c ****         ret = TLSX_Push(&ssl->extensions, TLSX_KEY_SHARE, NULL, ssl->heap);
8844:../src/src/tls.c ****     }
8845:../src/src/tls.c ****     else if (extension->data != NULL) {
8846:../src/src/tls.c ****         TLSX_KeyShare_FreeAll((KeyShareEntry*)extension->data, ssl->heap);
8847:../src/src/tls.c ****         extension->data = NULL;
8848:../src/src/tls.c ****     }
8849:../src/src/tls.c **** 
8850:../src/src/tls.c ****     return ret;
8851:../src/src/tls.c **** }
8852:../src/src/tls.c **** 
8853:../src/src/tls.c **** /* Returns whether this group is supported.
8854:../src/src/tls.c ****  *
8855:../src/src/tls.c ****  * namedGroup  The named group to check.
8856:../src/src/tls.c ****  * returns 1 when supported or 0 otherwise.
8857:../src/src/tls.c ****  */
8858:../src/src/tls.c **** static int TLSX_KeyShare_IsSupported(int namedGroup)
8859:../src/src/tls.c **** {
8860:../src/src/tls.c ****     switch (namedGroup) {
8861:../src/src/tls.c ****     #ifdef HAVE_FFDHE_2048
8862:../src/src/tls.c ****         case WOLFSSL_FFDHE_2048:
8863:../src/src/tls.c ****             break;
8864:../src/src/tls.c ****     #endif
8865:../src/src/tls.c ****     #ifdef HAVE_FFDHE_3072
8866:../src/src/tls.c ****         case WOLFSSL_FFDHE_3072:
8867:../src/src/tls.c ****             break;
8868:../src/src/tls.c ****     #endif
8869:../src/src/tls.c ****     #ifdef HAVE_FFDHE_4096
8870:../src/src/tls.c ****         case WOLFSSL_FFDHE_4096:
8871:../src/src/tls.c ****             break;
8872:../src/src/tls.c ****     #endif
8873:../src/src/tls.c ****     #ifdef HAVE_FFDHE_6144
8874:../src/src/tls.c ****         case WOLFSSL_FFDHE_6144:
8875:../src/src/tls.c ****             break;
8876:../src/src/tls.c ****     #endif
8877:../src/src/tls.c ****     #ifdef HAVE_FFDHE_8192
8878:../src/src/tls.c ****         case WOLFSSL_FFDHE_8192:
8879:../src/src/tls.c ****             break;
8880:../src/src/tls.c ****     #endif
8881:../src/src/tls.c ****     #if (!defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
8882:../src/src/tls.c ****         #ifdef HAVE_ECC_KOBLITZ
8883:../src/src/tls.c ****         case WOLFSSL_ECC_SECP256K1:
8884:../src/src/tls.c ****             break;
8885:../src/src/tls.c ****         #endif
8886:../src/src/tls.c ****         #ifndef NO_ECC_SECP
8887:../src/src/tls.c ****         case WOLFSSL_ECC_SECP256R1:
8888:../src/src/tls.c ****             break;
8889:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
8890:../src/src/tls.c ****         #ifdef HAVE_ECC_BRAINPOOL
8891:../src/src/tls.c ****         case WOLFSSL_ECC_BRAINPOOLP256R1:
8892:../src/src/tls.c ****             break;
8893:../src/src/tls.c ****         #endif
8894:../src/src/tls.c ****     #endif
8895:../src/src/tls.c ****     #if defined(HAVE_CURVE25519) && ECC_MIN_KEY_SZ <= 256
8896:../src/src/tls.c ****         case WOLFSSL_ECC_X25519:
8897:../src/src/tls.c ****             break;
8898:../src/src/tls.c ****     #endif
8899:../src/src/tls.c ****     #if defined(HAVE_CURVE448) && ECC_MIN_KEY_SZ <= 448
8900:../src/src/tls.c ****         case WOLFSSL_ECC_X448:
8901:../src/src/tls.c ****             break;
8902:../src/src/tls.c ****     #endif
8903:../src/src/tls.c ****     #if (defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 384
8904:../src/src/tls.c ****         #ifndef NO_ECC_SECP
8905:../src/src/tls.c ****         case WOLFSSL_ECC_SECP384R1:
8906:../src/src/tls.c ****             break;
8907:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
8908:../src/src/tls.c ****         #ifdef HAVE_ECC_BRAINPOOL
8909:../src/src/tls.c ****         case WOLFSSL_ECC_BRAINPOOLP384R1:
8910:../src/src/tls.c ****             break;
8911:../src/src/tls.c ****         #endif
8912:../src/src/tls.c ****     #endif
8913:../src/src/tls.c ****     #if (defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 521
8914:../src/src/tls.c ****         #ifndef NO_ECC_SECP
8915:../src/src/tls.c ****         case WOLFSSL_ECC_SECP521R1:
8916:../src/src/tls.c ****             break;
8917:../src/src/tls.c ****         #endif /* !NO_ECC_SECP */
8918:../src/src/tls.c ****     #endif
8919:../src/src/tls.c ****     #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 160
8920:../src/src/tls.c ****         #ifdef HAVE_ECC_KOBLITZ
8921:../src/src/tls.c ****         case WOLFSSL_ECC_SECP160K1:
8922:../src/src/tls.c ****             break;
8923:../src/src/tls.c ****         #endif
8924:../src/src/tls.c ****         #ifndef NO_ECC_SECP
8925:../src/src/tls.c ****         case WOLFSSL_ECC_SECP160R1:
8926:../src/src/tls.c ****             break;
8927:../src/src/tls.c ****         #endif
8928:../src/src/tls.c ****         #ifdef HAVE_ECC_SECPR2
8929:../src/src/tls.c ****         case WOLFSSL_ECC_SECP160R2:
8930:../src/src/tls.c ****             break;
8931:../src/src/tls.c ****         #endif
8932:../src/src/tls.c ****     #endif
8933:../src/src/tls.c ****     #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 192
8934:../src/src/tls.c ****         #ifdef HAVE_ECC_KOBLITZ
8935:../src/src/tls.c ****         case WOLFSSL_ECC_SECP192K1:
8936:../src/src/tls.c ****             break;
8937:../src/src/tls.c ****         #endif
8938:../src/src/tls.c ****         #ifndef NO_ECC_SECP
8939:../src/src/tls.c ****         case WOLFSSL_ECC_SECP192R1:
8940:../src/src/tls.c ****             break;
8941:../src/src/tls.c ****         #endif
8942:../src/src/tls.c ****     #endif
8943:../src/src/tls.c ****     #if (defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 224
8944:../src/src/tls.c ****         #ifdef HAVE_ECC_KOBLITZ
8945:../src/src/tls.c ****         case WOLFSSL_ECC_SECP224K1:
8946:../src/src/tls.c ****             break;
8947:../src/src/tls.c ****         #endif
8948:../src/src/tls.c ****         #ifndef NO_ECC_SECP
8949:../src/src/tls.c ****         case WOLFSSL_ECC_SECP224R1:
8950:../src/src/tls.c ****             break;
8951:../src/src/tls.c ****         #endif
8952:../src/src/tls.c ****     #endif
8953:../src/src/tls.c ****     #if (defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 512
8954:../src/src/tls.c ****         #ifdef HAVE_ECC_BRAINPOOL
8955:../src/src/tls.c ****         case WOLFSSL_ECC_BRAINPOOLP512R1:
8956:../src/src/tls.c ****             break;
8957:../src/src/tls.c ****         #endif
8958:../src/src/tls.c ****     #endif
8959:../src/src/tls.c ****     #ifdef HAVE_PQC
8960:../src/src/tls.c ****     #ifdef HAVE_LIBOQS
8961:../src/src/tls.c ****         case WOLFSSL_KYBER_LEVEL1:
8962:../src/src/tls.c ****         case WOLFSSL_KYBER_LEVEL3:
8963:../src/src/tls.c ****         case WOLFSSL_KYBER_LEVEL5:
8964:../src/src/tls.c ****         case WOLFSSL_NTRU_HPS_LEVEL1:
8965:../src/src/tls.c ****         case WOLFSSL_NTRU_HPS_LEVEL3:
8966:../src/src/tls.c ****         case WOLFSSL_NTRU_HPS_LEVEL5:
8967:../src/src/tls.c ****         case WOLFSSL_NTRU_HRSS_LEVEL3:
8968:../src/src/tls.c ****         case WOLFSSL_SABER_LEVEL1:
8969:../src/src/tls.c ****         case WOLFSSL_SABER_LEVEL3:
8970:../src/src/tls.c ****         case WOLFSSL_SABER_LEVEL5:
8971:../src/src/tls.c ****         case WOLFSSL_KYBER_90S_LEVEL1:
8972:../src/src/tls.c ****         case WOLFSSL_KYBER_90S_LEVEL3:
8973:../src/src/tls.c ****         case WOLFSSL_KYBER_90S_LEVEL5:
8974:../src/src/tls.c ****         case WOLFSSL_P256_NTRU_HPS_LEVEL1:
8975:../src/src/tls.c ****         case WOLFSSL_P384_NTRU_HPS_LEVEL3:
8976:../src/src/tls.c ****         case WOLFSSL_P521_NTRU_HPS_LEVEL5:
8977:../src/src/tls.c ****         case WOLFSSL_P384_NTRU_HRSS_LEVEL3:
8978:../src/src/tls.c ****         case WOLFSSL_P256_SABER_LEVEL1:
8979:../src/src/tls.c ****         case WOLFSSL_P384_SABER_LEVEL3:
8980:../src/src/tls.c ****         case WOLFSSL_P521_SABER_LEVEL5:
8981:../src/src/tls.c ****         case WOLFSSL_P256_KYBER_LEVEL1:
8982:../src/src/tls.c ****         case WOLFSSL_P384_KYBER_LEVEL3:
8983:../src/src/tls.c ****         case WOLFSSL_P521_KYBER_LEVEL5:
8984:../src/src/tls.c ****         case WOLFSSL_P256_KYBER_90S_LEVEL1:
8985:../src/src/tls.c ****         case WOLFSSL_P384_KYBER_90S_LEVEL3:
8986:../src/src/tls.c ****         case WOLFSSL_P521_KYBER_90S_LEVEL5:
8987:../src/src/tls.c ****             findEccPqc(NULL, &namedGroup, namedGroup);
8988:../src/src/tls.c ****             if (! OQS_KEM_alg_is_enabled(OQS_ID2name(namedGroup))) {
8989:../src/src/tls.c ****                 return 0;
8990:../src/src/tls.c ****             }
8991:../src/src/tls.c ****             break;
8992:../src/src/tls.c ****     #elif defined(HAVE_PQM4)
8993:../src/src/tls.c ****         case WOLFSSL_KYBER_LEVEL1:
8994:../src/src/tls.c ****             break;
8995:../src/src/tls.c ****     #endif
8996:../src/src/tls.c ****     #endif /* HAVE_PQC */
8997:../src/src/tls.c ****         default:
8998:../src/src/tls.c ****             return 0;
8999:../src/src/tls.c ****     }
9000:../src/src/tls.c **** 
9001:../src/src/tls.c ****     return 1;
9002:../src/src/tls.c **** }
9003:../src/src/tls.c **** 
9004:../src/src/tls.c **** /* Examines the application specified group ranking and returns the rank of the
9005:../src/src/tls.c ****  * group.
9006:../src/src/tls.c ****  * If no group ranking set then all groups are rank 0 (highest).
9007:../src/src/tls.c ****  *
9008:../src/src/tls.c ****  * ssl    The SSL/TLS object.
9009:../src/src/tls.c ****  * group  The group to check ranking for.
9010:../src/src/tls.c ****  * returns ranking from 0 to MAX_GROUP_COUNT-1 or -1 when group not in list.
9011:../src/src/tls.c ****  */
9012:../src/src/tls.c **** static int TLSX_KeyShare_GroupRank(WOLFSSL* ssl, int group)
9013:../src/src/tls.c **** {
9014:../src/src/tls.c ****     byte i;
9015:../src/src/tls.c **** 
9016:../src/src/tls.c ****     if (ssl->numGroups == 0) {
9017:../src/src/tls.c **** #if defined(HAVE_ECC) && defined(HAVE_SUPPORTED_CURVES)
9018:../src/src/tls.c ****     #if (!defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
9019:../src/src/tls.c ****         #ifndef NO_ECC_SECP
9020:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_ECC_SECP256R1;
9021:../src/src/tls.c ****         #endif
9022:../src/src/tls.c ****     #endif
9023:../src/src/tls.c **** #endif
9024:../src/src/tls.c ****     #ifndef HAVE_FIPS
9025:../src/src/tls.c ****         #if defined(HAVE_CURVE25519) && ECC_MIN_KEY_SZ <= 256
9026:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_ECC_X25519;
9027:../src/src/tls.c ****         #endif
9028:../src/src/tls.c ****     #endif
9029:../src/src/tls.c ****     #ifndef HAVE_FIPS
9030:../src/src/tls.c ****         #if defined(HAVE_CURVE448) && ECC_MIN_KEY_SZ <= 448
9031:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_ECC_X448;
9032:../src/src/tls.c ****         #endif
9033:../src/src/tls.c ****     #endif
9034:../src/src/tls.c **** #if defined(HAVE_ECC) && defined(HAVE_SUPPORTED_CURVES)
9035:../src/src/tls.c ****     #if (defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 384
9036:../src/src/tls.c ****         #ifndef NO_ECC_SECP
9037:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_ECC_SECP384R1;
9038:../src/src/tls.c ****         #endif
9039:../src/src/tls.c ****     #endif
9040:../src/src/tls.c ****     #if (defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 521
9041:../src/src/tls.c ****         #ifndef NO_ECC_SECP
9042:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_ECC_SECP521R1;
9043:../src/src/tls.c ****         #endif
9044:../src/src/tls.c ****     #endif
9045:../src/src/tls.c **** #endif
9046:../src/src/tls.c ****             /* Add FFDHE supported groups. */
9047:../src/src/tls.c ****         #ifdef HAVE_FFDHE_2048
9048:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_FFDHE_2048;
9049:../src/src/tls.c ****         #endif
9050:../src/src/tls.c ****         #ifdef HAVE_FFDHE_3072
9051:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_FFDHE_3072;
9052:../src/src/tls.c ****         #endif
9053:../src/src/tls.c ****         #ifdef HAVE_FFDHE_4096
9054:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_FFDHE_4096;
9055:../src/src/tls.c ****         #endif
9056:../src/src/tls.c ****         #ifdef HAVE_FFDHE_6144
9057:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_FFDHE_6144;
9058:../src/src/tls.c ****         #endif
9059:../src/src/tls.c ****         #ifdef HAVE_FFDHE_8192
9060:../src/src/tls.c ****             ssl->group[ssl->numGroups++] = WOLFSSL_FFDHE_8192;
9061:../src/src/tls.c ****         #endif
9062:../src/src/tls.c **** #ifdef HAVE_PQC
9063:../src/src/tls.c ****             /* For the liboqs groups we need to do a runtime check because
9064:../src/src/tls.c ****              * liboqs could be compiled to make an algorithm unavailable.
9065:../src/src/tls.c ****              */
9066:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_KYBER_LEVEL1))
9067:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_KYBER_LEVEL1;
9068:../src/src/tls.c ****     #ifdef HAVE_LIBOQS
9069:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_KYBER_LEVEL3))
9070:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_KYBER_LEVEL3;
9071:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_KYBER_LEVEL5))
9072:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_KYBER_LEVEL5;
9073:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_NTRU_HPS_LEVEL1))
9074:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_NTRU_HPS_LEVEL1;
9075:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_NTRU_HPS_LEVEL3))
9076:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_NTRU_HPS_LEVEL3;
9077:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_NTRU_HPS_LEVEL5))
9078:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_NTRU_HPS_LEVEL5;
9079:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_NTRU_HRSS_LEVEL3))
9080:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_NTRU_HRSS_LEVEL3;
9081:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_SABER_LEVEL1))
9082:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_SABER_LEVEL1;
9083:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_SABER_LEVEL3))
9084:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_SABER_LEVEL3;
9085:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_SABER_LEVEL5))
9086:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_SABER_LEVEL5;
9087:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_KYBER_90S_LEVEL1))
9088:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_KYBER_90S_LEVEL1;
9089:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_KYBER_90S_LEVEL3))
9090:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_KYBER_90S_LEVEL3;
9091:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_KYBER_90S_LEVEL5))
9092:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_KYBER_90S_LEVEL5;
9093:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P256_NTRU_HPS_LEVEL1))
9094:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P256_NTRU_HPS_LEVEL1;
9095:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P384_NTRU_HPS_LEVEL3))
9096:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P384_NTRU_HPS_LEVEL3;
9097:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P521_NTRU_HPS_LEVEL5))
9098:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P521_NTRU_HPS_LEVEL5;
9099:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P384_NTRU_HRSS_LEVEL3))
9100:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P384_NTRU_HRSS_LEVEL3;
9101:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P256_SABER_LEVEL1))
9102:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P256_SABER_LEVEL1;
9103:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P384_SABER_LEVEL3))
9104:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P384_SABER_LEVEL3;
9105:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P521_SABER_LEVEL5))
9106:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P521_SABER_LEVEL5;
9107:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P256_KYBER_LEVEL1))
9108:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P256_KYBER_LEVEL1;
9109:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P384_KYBER_LEVEL3))
9110:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P384_KYBER_LEVEL3;
9111:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P521_KYBER_LEVEL5))
9112:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P521_KYBER_LEVEL5;
9113:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P256_KYBER_90S_LEVEL1))
9114:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P256_KYBER_90S_LEVEL1;
9115:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P384_KYBER_90S_LEVEL3))
9116:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P384_KYBER_90S_LEVEL3;
9117:../src/src/tls.c ****             if (TLSX_KeyShare_IsSupported(WOLFSSL_P521_KYBER_90S_LEVEL5))
9118:../src/src/tls.c ****                 ssl->group[ssl->numGroups++] = WOLFSSL_P521_KYBER_90S_LEVEL5;
9119:../src/src/tls.c ****     #endif /* HAVE_LIBOQS */
9120:../src/src/tls.c **** #endif /* HAVE_PQC */
9121:../src/src/tls.c ****     }
9122:../src/src/tls.c **** 
9123:../src/src/tls.c ****     for (i = 0; i < ssl->numGroups; i++)
9124:../src/src/tls.c ****         if (ssl->group[i] == (word16)group)
9125:../src/src/tls.c ****             return i;
9126:../src/src/tls.c **** 
9127:../src/src/tls.c ****     return -1;
9128:../src/src/tls.c **** }
9129:../src/src/tls.c **** 
9130:../src/src/tls.c **** /* Set a key share that is supported by the client into extensions.
9131:../src/src/tls.c ****  *
9132:../src/src/tls.c ****  * ssl  The SSL/TLS object.
9133:../src/src/tls.c ****  * returns BAD_KEY_SHARE_DATA if no supported group has a key share,
9134:../src/src/tls.c ****  * 0 if a supported group has a key share and other values indicate an error.
9135:../src/src/tls.c ****  */
9136:../src/src/tls.c **** static int TLSX_KeyShare_SetSupported(WOLFSSL* ssl)
9137:../src/src/tls.c **** {
9138:../src/src/tls.c ****     int             ret;
9139:../src/src/tls.c **** #ifdef HAVE_SUPPORTED_CURVES
9140:../src/src/tls.c ****     TLSX*           extension;
9141:../src/src/tls.c ****     SupportedCurve* curve = NULL;
9142:../src/src/tls.c ****     SupportedCurve* preferredCurve = NULL;
9143:../src/src/tls.c ****     int             preferredRank = WOLFSSL_MAX_GROUP_COUNT;
9144:../src/src/tls.c ****     int             rank;
9145:../src/src/tls.c **** 
9146:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS);
9147:../src/src/tls.c ****     if (extension != NULL)
9148:../src/src/tls.c ****         curve = (SupportedCurve*)extension->data;
9149:../src/src/tls.c ****     /* Use server's preference order. */
9150:../src/src/tls.c ****     for (; curve != NULL; curve = curve->next) {
9151:../src/src/tls.c ****         if (!TLSX_KeyShare_IsSupported(curve->name))
9152:../src/src/tls.c ****             continue;
9153:../src/src/tls.c **** 
9154:../src/src/tls.c ****         rank = TLSX_KeyShare_GroupRank(ssl, curve->name);
9155:../src/src/tls.c ****         if (rank == -1)
9156:../src/src/tls.c ****             continue;
9157:../src/src/tls.c ****         if (rank < preferredRank) {
9158:../src/src/tls.c ****             preferredCurve = curve;
9159:../src/src/tls.c ****             preferredRank = rank;
9160:../src/src/tls.c ****         }
9161:../src/src/tls.c ****     }
9162:../src/src/tls.c ****     curve = preferredCurve;
9163:../src/src/tls.c **** 
9164:../src/src/tls.c ****     if (curve == NULL)
9165:../src/src/tls.c ****         return BAD_KEY_SHARE_DATA;
9166:../src/src/tls.c **** 
9167:../src/src/tls.c ****     /* Delete the old key share data list. */
9168:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
9169:../src/src/tls.c ****     if (extension != NULL) {
9170:../src/src/tls.c ****         KeyShareEntry* kse = (KeyShareEntry*)extension->data;
9171:../src/src/tls.c ****     #ifdef WOLFSSL_ASYNC_CRYPT
9172:../src/src/tls.c ****         /* for async don't free, call `TLSX_KeyShare_Use` again */
9173:../src/src/tls.c ****         if (kse && kse->lastRet != WC_PENDING_E)
9174:../src/src/tls.c ****     #endif
9175:../src/src/tls.c ****         {
9176:../src/src/tls.c ****             TLSX_KeyShare_FreeAll(kse, ssl->heap);
9177:../src/src/tls.c ****             extension->data = NULL;
9178:../src/src/tls.c ****         }
9179:../src/src/tls.c ****     }
9180:../src/src/tls.c **** 
9181:../src/src/tls.c ****     /* Add in the chosen group. */
9182:../src/src/tls.c ****     ret = TLSX_KeyShare_Use(ssl, curve->name, 0, NULL, NULL);
9183:../src/src/tls.c ****     if (ret != 0 && ret != WC_PENDING_E)
9184:../src/src/tls.c ****         return ret;
9185:../src/src/tls.c **** 
9186:../src/src/tls.c ****     /* Set extension to be in response. */
9187:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
9188:../src/src/tls.c ****     extension->resp = 1;
9189:../src/src/tls.c **** #else
9190:../src/src/tls.c **** 
9191:../src/src/tls.c ****     (void)ssl;
9192:../src/src/tls.c ****     ret = NOT_COMPILED_IN;
9193:../src/src/tls.c **** #endif
9194:../src/src/tls.c **** 
9195:../src/src/tls.c ****     return ret;
9196:../src/src/tls.c **** }
9197:../src/src/tls.c **** 
9198:../src/src/tls.c **** /* Ensure there is a key pair that can be used for key exchange.
9199:../src/src/tls.c ****  *
9200:../src/src/tls.c ****  * ssl  The SSL/TLS object.
9201:../src/src/tls.c ****  * doHelloRetry If set to non-zero will do hello_retry
9202:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
9203:../src/src/tls.c ****  */
9204:../src/src/tls.c **** int TLSX_KeyShare_Establish(WOLFSSL *ssl, int* doHelloRetry)
9205:../src/src/tls.c **** {
9206:../src/src/tls.c ****     int            ret;
9207:../src/src/tls.c ****     TLSX*          extension;
9208:../src/src/tls.c ****     KeyShareEntry* clientKSE = NULL;
9209:../src/src/tls.c ****     KeyShareEntry* serverKSE;
9210:../src/src/tls.c ****     KeyShareEntry* list = NULL;
9211:../src/src/tls.c ****     KeyShareEntry* preferredKSE = NULL;
9212:../src/src/tls.c ****     int preferredRank = WOLFSSL_MAX_GROUP_COUNT;
9213:../src/src/tls.c ****     int rank;
9214:../src/src/tls.c **** 
9215:../src/src/tls.c ****     /* Find the KeyShare extension if it exists. */
9216:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
9217:../src/src/tls.c ****     if (extension != NULL)
9218:../src/src/tls.c ****         list = (KeyShareEntry*)extension->data;
9219:../src/src/tls.c **** 
9220:../src/src/tls.c ****     if (extension && extension->resp == 1) {
9221:../src/src/tls.c ****         ret = 0;
9222:../src/src/tls.c ****     #ifdef WOLFSSL_ASYNC_CRYPT
9223:../src/src/tls.c ****         /* in async case make sure key generation is finalized */
9224:../src/src/tls.c ****         serverKSE = (KeyShareEntry*)extension->data;
9225:../src/src/tls.c ****         if (serverKSE->lastRet == WC_PENDING_E) {
9226:../src/src/tls.c ****             if (ssl->options.serverState == SERVER_HELLO_RETRY_REQUEST_COMPLETE)
9227:../src/src/tls.c ****                 *doHelloRetry = 1;
9228:../src/src/tls.c ****             ret = TLSX_KeyShare_GenKey(ssl, serverKSE);
9229:../src/src/tls.c ****         }
9230:../src/src/tls.c ****     #endif
9231:../src/src/tls.c ****         return ret;
9232:../src/src/tls.c ****     }
9233:../src/src/tls.c **** 
9234:../src/src/tls.c ****     /* Use server's preference order. */
9235:../src/src/tls.c ****     for (clientKSE = list; clientKSE != NULL; clientKSE = clientKSE->next) {
9236:../src/src/tls.c ****         if (clientKSE->ke == NULL)
9237:../src/src/tls.c ****             continue;
9238:../src/src/tls.c **** 
9239:../src/src/tls.c ****         /* Check consistency now - extensions in any order. */
9240:../src/src/tls.c ****         if (!TLSX_SupportedGroups_Find(ssl, clientKSE->group))
9241:../src/src/tls.c ****             continue;
9242:../src/src/tls.c **** 
9243:../src/src/tls.c ****         if (clientKSE->group < MIN_FFHDE_GROUP ||
9244:../src/src/tls.c ****             clientKSE->group > MAX_FFHDE_GROUP) {
9245:../src/src/tls.c ****             /* Check max value supported. */
9246:../src/src/tls.c ****             if (clientKSE->group > WOLFSSL_ECC_MAX) {
9247:../src/src/tls.c **** #ifdef HAVE_PQC
9248:../src/src/tls.c ****                 if (clientKSE->group < WOLFSSL_PQC_MIN ||
9249:../src/src/tls.c ****                     clientKSE->group > WOLFSSL_PQC_MAX )
9250:../src/src/tls.c **** #endif
9251:../src/src/tls.c ****                     continue;
9252:../src/src/tls.c ****             }
9253:../src/src/tls.c ****         #ifdef OPENSSL_EXTRA
9254:../src/src/tls.c ****             /* Check if server supports group. */
9255:../src/src/tls.c ****             if (ssl->ctx->disabledCurves & ((word32)1 << clientKSE->group))
9256:../src/src/tls.c ****                 continue;
9257:../src/src/tls.c ****         #endif
9258:../src/src/tls.c ****         }
9259:../src/src/tls.c ****         if (!TLSX_KeyShare_IsSupported(clientKSE->group))
9260:../src/src/tls.c ****             continue;
9261:../src/src/tls.c **** 
9262:../src/src/tls.c ****         rank = TLSX_KeyShare_GroupRank(ssl, clientKSE->group);
9263:../src/src/tls.c ****         if (rank == -1)
9264:../src/src/tls.c ****             continue;
9265:../src/src/tls.c ****         if (rank < preferredRank) {
9266:../src/src/tls.c ****             preferredKSE = clientKSE;
9267:../src/src/tls.c ****             preferredRank = rank;
9268:../src/src/tls.c ****         }
9269:../src/src/tls.c ****     }
9270:../src/src/tls.c ****     clientKSE = preferredKSE;
9271:../src/src/tls.c **** 
9272:../src/src/tls.c ****     /* No supported group found - send HelloRetryRequest. */
9273:../src/src/tls.c ****     if (clientKSE == NULL) {
9274:../src/src/tls.c ****         /* Set KEY_SHARE_ERROR to indicate HelloRetryRequest required. */
9275:../src/src/tls.c ****         *doHelloRetry = 1;
9276:../src/src/tls.c ****         return TLSX_KeyShare_SetSupported(ssl);
9277:../src/src/tls.c ****     }
9278:../src/src/tls.c **** 
9279:../src/src/tls.c ****     list = NULL;
9280:../src/src/tls.c ****     /* Generate a new key pair except in the case of OQS KEM because we
9281:../src/src/tls.c ****      * are going to encapsulate and that does not require us to generate a
9282:../src/src/tls.c ****      * key pair.
9283:../src/src/tls.c ****      */
9284:../src/src/tls.c ****     ret = TLSX_KeyShare_New(&list, clientKSE->group, ssl->heap, &serverKSE);
9285:../src/src/tls.c ****     if (ret != 0)
9286:../src/src/tls.c ****         return ret;
9287:../src/src/tls.c **** 
9288:../src/src/tls.c ****     if (clientKSE->key == NULL) {
9289:../src/src/tls.c **** #ifdef HAVE_PQC
9290:../src/src/tls.c ****         if (clientKSE->group >= WOLFSSL_PQC_MIN &&
9291:../src/src/tls.c ****             clientKSE->group <= WOLFSSL_PQC_MAX ) {
9292:../src/src/tls.c ****             /* Going to need the public key (AKA ciphertext). */
9293:../src/src/tls.c ****             serverKSE->pubKey = clientKSE->pubKey;
9294:../src/src/tls.c ****             clientKSE->pubKey = NULL;
9295:../src/src/tls.c ****             serverKSE->pubKeyLen = clientKSE->pubKeyLen;
9296:../src/src/tls.c ****             clientKSE->pubKeyLen = 0;
9297:../src/src/tls.c ****         }
9298:../src/src/tls.c ****         else
9299:../src/src/tls.c **** #endif
9300:../src/src/tls.c ****         {
9301:../src/src/tls.c ****             ret = TLSX_KeyShare_GenKey(ssl, serverKSE);
9302:../src/src/tls.c ****         }
9303:../src/src/tls.c **** 
9304:../src/src/tls.c ****         /* for async do setup of serverKSE below, but return WC_PENDING_E */
9305:../src/src/tls.c ****         if (ret != 0
9306:../src/src/tls.c ****         #ifdef WOLFSSL_ASYNC_CRYPT
9307:../src/src/tls.c ****             && ret != WC_PENDING_E
9308:../src/src/tls.c ****         #endif
9309:../src/src/tls.c ****         ) {
9310:../src/src/tls.c ****             return ret;
9311:../src/src/tls.c ****         }
9312:../src/src/tls.c ****     }
9313:../src/src/tls.c ****     else {
9314:../src/src/tls.c ****         /* transfer buffers to serverKSE */
9315:../src/src/tls.c ****         serverKSE->key = clientKSE->key;
9316:../src/src/tls.c ****         clientKSE->key = NULL;
9317:../src/src/tls.c ****         serverKSE->keyLen = clientKSE->keyLen;
9318:../src/src/tls.c ****         serverKSE->pubKey = clientKSE->pubKey;
9319:../src/src/tls.c ****         clientKSE->pubKey = NULL;
9320:../src/src/tls.c ****         serverKSE->pubKeyLen = clientKSE->pubKeyLen;
9321:../src/src/tls.c ****     #ifndef NO_DH
9322:../src/src/tls.c ****         serverKSE->privKey = clientKSE->privKey;
9323:../src/src/tls.c ****         clientKSE->privKey = NULL;
9324:../src/src/tls.c ****     #endif
9325:../src/src/tls.c ****     }
9326:../src/src/tls.c ****     serverKSE->ke = clientKSE->ke;
9327:../src/src/tls.c ****     serverKSE->keLen = clientKSE->keLen;
9328:../src/src/tls.c ****     clientKSE->ke = NULL;
9329:../src/src/tls.c ****     clientKSE->keLen = 0;
9330:../src/src/tls.c **** 
9331:../src/src/tls.c ****     TLSX_KeyShare_FreeAll((KeyShareEntry*)extension->data, ssl->heap);
9332:../src/src/tls.c ****     extension->data = (void *)serverKSE;
9333:../src/src/tls.c **** 
9334:../src/src/tls.c ****     extension->resp = 1;
9335:../src/src/tls.c **** 
9336:../src/src/tls.c ****     return ret;
9337:../src/src/tls.c **** }
9338:../src/src/tls.c **** 
9339:../src/src/tls.c **** /* Derive the shared secret of the key exchange.
9340:../src/src/tls.c ****  *
9341:../src/src/tls.c ****  * ssl  The SSL/TLS object.
9342:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
9343:../src/src/tls.c ****  */
9344:../src/src/tls.c **** int TLSX_KeyShare_DeriveSecret(WOLFSSL *ssl)
9345:../src/src/tls.c **** {
9346:../src/src/tls.c ****     int            ret;
9347:../src/src/tls.c ****     TLSX*          extension;
9348:../src/src/tls.c ****     KeyShareEntry* list = NULL;
9349:../src/src/tls.c **** 
9350:../src/src/tls.c **** #ifdef WOLFSSL_ASYNC_CRYPT
9351:../src/src/tls.c ****     ret = wolfSSL_AsyncPop(ssl, NULL);
9352:../src/src/tls.c ****     /* Check for error */
9353:../src/src/tls.c ****     if (ret != WC_NOT_PENDING_E && ret < 0) {
9354:../src/src/tls.c ****         return ret;
9355:../src/src/tls.c ****     }
9356:../src/src/tls.c **** #endif
9357:../src/src/tls.c **** 
9358:../src/src/tls.c ****     /* Find the KeyShare extension if it exists. */
9359:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
9360:../src/src/tls.c ****     if (extension != NULL)
9361:../src/src/tls.c ****         list = (KeyShareEntry*)extension->data;
9362:../src/src/tls.c **** 
9363:../src/src/tls.c ****     if (list == NULL)
9364:../src/src/tls.c ****         return KEY_SHARE_ERROR;
9365:../src/src/tls.c **** 
9366:../src/src/tls.c ****     /* Calculate secret. */
9367:../src/src/tls.c ****     ret = TLSX_KeyShare_Process(ssl, list);
9368:../src/src/tls.c **** 
9369:../src/src/tls.c ****     return ret;
9370:../src/src/tls.c **** }
9371:../src/src/tls.c **** 
9372:../src/src/tls.c **** #define KS_FREE_ALL  TLSX_KeyShare_FreeAll
9373:../src/src/tls.c **** #define KS_GET_SIZE  TLSX_KeyShare_GetSize
9374:../src/src/tls.c **** #define KS_WRITE     TLSX_KeyShare_Write
9375:../src/src/tls.c **** #define KS_PARSE     TLSX_KeyShare_Parse
9376:../src/src/tls.c **** 
9377:../src/src/tls.c **** #else
9378:../src/src/tls.c **** 
9379:../src/src/tls.c **** #define KS_FREE_ALL(a, b)
9380:../src/src/tls.c **** #define KS_GET_SIZE(a, b)    0
9381:../src/src/tls.c **** #define KS_WRITE(a, b, c)    0
9382:../src/src/tls.c **** #define KS_PARSE(a, b, c, d) 0
9383:../src/src/tls.c **** 
9384:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 */
9385:../src/src/tls.c **** 
9386:../src/src/tls.c **** /******************************************************************************/
9387:../src/src/tls.c **** /* Pre-Shared Key                                                             */
9388:../src/src/tls.c **** /******************************************************************************/
9389:../src/src/tls.c **** 
9390:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))
9391:../src/src/tls.c **** /* Free the pre-shared key dynamic data.
9392:../src/src/tls.c ****  *
9393:../src/src/tls.c ****  * list  The linked list of key share entry objects.
9394:../src/src/tls.c ****  * heap  The heap used for allocation.
9395:../src/src/tls.c ****  */
9396:../src/src/tls.c **** static void TLSX_PreSharedKey_FreeAll(PreSharedKey* list, void* heap)
9397:../src/src/tls.c **** {
9398:../src/src/tls.c ****     PreSharedKey* current;
9399:../src/src/tls.c **** 
9400:../src/src/tls.c ****     while ((current = list) != NULL) {
9401:../src/src/tls.c ****         list = current->next;
9402:../src/src/tls.c ****         XFREE(current->identity, heap, DYNAMIC_TYPE_TLSX);
9403:../src/src/tls.c ****         XFREE(current, heap, DYNAMIC_TYPE_TLSX);
9404:../src/src/tls.c ****     }
9405:../src/src/tls.c **** 
9406:../src/src/tls.c ****     (void)heap;
9407:../src/src/tls.c **** }
9408:../src/src/tls.c **** 
9409:../src/src/tls.c **** /* Get the size of the encoded pre shared key extension.
9410:../src/src/tls.c ****  *
9411:../src/src/tls.c ****  * list     The linked list of pre-shared key extensions.
9412:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
9413:../src/src/tls.c ****  * returns the number of bytes of the encoded pre-shared key extension or
9414:../src/src/tls.c ****  * SANITY_MSG_E to indicate invalid message type.
9415:../src/src/tls.c ****  */
9416:../src/src/tls.c **** static int TLSX_PreSharedKey_GetSize(PreSharedKey* list, byte msgType,
9417:../src/src/tls.c ****                                      word16* pSz)
9418:../src/src/tls.c **** {
9419:../src/src/tls.c ****     if (msgType == client_hello) {
9420:../src/src/tls.c ****         /* Length of identities + Length of binders. */
9421:../src/src/tls.c ****         word16 len = OPAQUE16_LEN + OPAQUE16_LEN;
9422:../src/src/tls.c ****         while (list != NULL) {
9423:../src/src/tls.c ****             /* Each entry has: identity, ticket age and binder. */
9424:../src/src/tls.c ****             len += OPAQUE16_LEN + list->identityLen + OPAQUE32_LEN +
9425:../src/src/tls.c ****                    OPAQUE8_LEN + (word16)list->binderLen;
9426:../src/src/tls.c ****             list = list->next;
9427:../src/src/tls.c ****         }
9428:../src/src/tls.c ****         *pSz += len;
9429:../src/src/tls.c ****         return 0;
9430:../src/src/tls.c ****     }
9431:../src/src/tls.c **** 
9432:../src/src/tls.c ****     if (msgType == server_hello) {
9433:../src/src/tls.c ****         *pSz += OPAQUE16_LEN;
9434:../src/src/tls.c ****         return 0;
9435:../src/src/tls.c ****     }
9436:../src/src/tls.c **** 
9437:../src/src/tls.c ****     return SANITY_MSG_E;
9438:../src/src/tls.c **** }
9439:../src/src/tls.c **** 
9440:../src/src/tls.c **** /* The number of bytes to be written for the binders.
9441:../src/src/tls.c ****  *
9442:../src/src/tls.c ****  * list     The linked list of pre-shared key extensions.
9443:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
9444:../src/src/tls.c ****  * returns the number of bytes of the encoded pre-shared key extension or
9445:../src/src/tls.c ****  * SANITY_MSG_E to indicate invalid message type.
9446:../src/src/tls.c ****  */
9447:../src/src/tls.c **** int TLSX_PreSharedKey_GetSizeBinders(PreSharedKey* list, byte msgType,
9448:../src/src/tls.c ****                                      word16* pSz)
9449:../src/src/tls.c **** {
9450:../src/src/tls.c ****     word16 len;
9451:../src/src/tls.c **** 
9452:../src/src/tls.c ****     if (msgType != client_hello)
9453:../src/src/tls.c ****         return SANITY_MSG_E;
9454:../src/src/tls.c **** 
9455:../src/src/tls.c ****     /* Length of all binders. */
9456:../src/src/tls.c ****     len = OPAQUE16_LEN;
9457:../src/src/tls.c ****     while (list != NULL) {
9458:../src/src/tls.c ****         len += OPAQUE8_LEN + (word16)list->binderLen;
9459:../src/src/tls.c ****         list = list->next;
9460:../src/src/tls.c ****     }
9461:../src/src/tls.c **** 
9462:../src/src/tls.c ****     *pSz = len;
9463:../src/src/tls.c ****     return 0;
9464:../src/src/tls.c **** }
9465:../src/src/tls.c **** 
9466:../src/src/tls.c **** /* Writes the pre-shared key extension into the output buffer - binders only.
9467:../src/src/tls.c ****  * Assumes that the the output buffer is big enough to hold data.
9468:../src/src/tls.c ****  *
9469:../src/src/tls.c ****  * list     The linked list of key share entries.
9470:../src/src/tls.c ****  * output   The buffer to write into.
9471:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
9472:../src/src/tls.c ****  * returns the number of bytes written into the buffer.
9473:../src/src/tls.c ****  */
9474:../src/src/tls.c **** int TLSX_PreSharedKey_WriteBinders(PreSharedKey* list, byte* output,
9475:../src/src/tls.c ****                                    byte msgType, word16* pSz)
9476:../src/src/tls.c **** {
9477:../src/src/tls.c ****     PreSharedKey* current = list;
9478:../src/src/tls.c ****     word16 idx = 0;
9479:../src/src/tls.c ****     word16 lenIdx;
9480:../src/src/tls.c ****     word16 len;
9481:../src/src/tls.c **** 
9482:../src/src/tls.c ****     if (msgType != client_hello)
9483:../src/src/tls.c ****         return SANITY_MSG_E;
9484:../src/src/tls.c **** 
9485:../src/src/tls.c ****     /* Skip length of all binders. */
9486:../src/src/tls.c ****     lenIdx = idx;
9487:../src/src/tls.c ****     idx += OPAQUE16_LEN;
9488:../src/src/tls.c ****     while (current != NULL) {
9489:../src/src/tls.c ****         /* Binder data length. */
9490:../src/src/tls.c ****         output[idx++] = (byte)current->binderLen;
9491:../src/src/tls.c ****         /* Binder data. */
9492:../src/src/tls.c ****         XMEMCPY(output + idx, current->binder, current->binderLen);
9493:../src/src/tls.c ****         idx += (word16)current->binderLen;
9494:../src/src/tls.c **** 
9495:../src/src/tls.c ****         current = current->next;
9496:../src/src/tls.c ****     }
9497:../src/src/tls.c ****     /* Length of the binders. */
9498:../src/src/tls.c ****     len = idx - lenIdx - OPAQUE16_LEN;
9499:../src/src/tls.c ****     c16toa(len, output + lenIdx);
9500:../src/src/tls.c **** 
9501:../src/src/tls.c ****     *pSz = idx;
9502:../src/src/tls.c ****     return 0;
9503:../src/src/tls.c **** }
9504:../src/src/tls.c **** 
9505:../src/src/tls.c **** 
9506:../src/src/tls.c **** /* Writes the pre-shared key extension into the output buffer.
9507:../src/src/tls.c ****  * Assumes that the the output buffer is big enough to hold data.
9508:../src/src/tls.c ****  *
9509:../src/src/tls.c ****  * list     The linked list of key share entries.
9510:../src/src/tls.c ****  * output   The buffer to write into.
9511:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
9512:../src/src/tls.c ****  * returns the number of bytes written into the buffer.
9513:../src/src/tls.c ****  */
9514:../src/src/tls.c **** static int TLSX_PreSharedKey_Write(PreSharedKey* list, byte* output,
9515:../src/src/tls.c ****                                    byte msgType, word16* pSz)
9516:../src/src/tls.c **** {
9517:../src/src/tls.c ****     if (msgType == client_hello) {
9518:../src/src/tls.c ****         PreSharedKey* current = list;
9519:../src/src/tls.c ****         word16 idx = 0;
9520:../src/src/tls.c ****         word16 lenIdx;
9521:../src/src/tls.c ****         word16 len;
9522:../src/src/tls.c ****         int ret;
9523:../src/src/tls.c **** 
9524:../src/src/tls.c ****         /* Write identites only. Binders after HMACing over this. */
9525:../src/src/tls.c ****         lenIdx = idx;
9526:../src/src/tls.c ****         idx += OPAQUE16_LEN;
9527:../src/src/tls.c ****         while (current != NULL) {
9528:../src/src/tls.c ****             /* Identity length */
9529:../src/src/tls.c ****             c16toa(current->identityLen, output + idx);
9530:../src/src/tls.c ****             idx += OPAQUE16_LEN;
9531:../src/src/tls.c ****             /* Identity data */
9532:../src/src/tls.c ****             XMEMCPY(output + idx, current->identity, current->identityLen);
9533:../src/src/tls.c ****             idx += current->identityLen;
9534:../src/src/tls.c **** 
9535:../src/src/tls.c ****             /* Obfuscated ticket age. */
9536:../src/src/tls.c ****             c32toa(current->ticketAge, output + idx);
9537:../src/src/tls.c ****             idx += OPAQUE32_LEN;
9538:../src/src/tls.c **** 
9539:../src/src/tls.c ****             current = current->next;
9540:../src/src/tls.c ****         }
9541:../src/src/tls.c ****         /* Length of the identites. */
9542:../src/src/tls.c ****         len = idx - lenIdx - OPAQUE16_LEN;
9543:../src/src/tls.c ****         c16toa(len, output + lenIdx);
9544:../src/src/tls.c **** 
9545:../src/src/tls.c ****         /* Don't include binders here.
9546:../src/src/tls.c ****          * The binders are based on the hash of all the ClientHello data up to
9547:../src/src/tls.c ****          * and include the identities written above.
9548:../src/src/tls.c ****          */
9549:../src/src/tls.c ****         ret = TLSX_PreSharedKey_GetSizeBinders(list, msgType, &len);
9550:../src/src/tls.c ****         if (ret < 0)
9551:../src/src/tls.c ****             return ret;
9552:../src/src/tls.c ****         *pSz += idx + len;
9553:../src/src/tls.c ****     }
9554:../src/src/tls.c ****     else if (msgType == server_hello) {
9555:../src/src/tls.c ****         word16 i;
9556:../src/src/tls.c **** 
9557:../src/src/tls.c ****         /* Find the index of the chosen identity. */
9558:../src/src/tls.c ****         for (i=0; list != NULL && !list->chosen; i++)
9559:../src/src/tls.c ****             list = list->next;
9560:../src/src/tls.c ****         if (list == NULL)
9561:../src/src/tls.c ****             return BUILD_MSG_ERROR;
9562:../src/src/tls.c **** 
9563:../src/src/tls.c ****         /* The index of the identity chosen by the server from the list supplied
9564:../src/src/tls.c ****          * by the client.
9565:../src/src/tls.c ****          */
9566:../src/src/tls.c ****         c16toa(i, output);
9567:../src/src/tls.c ****         *pSz += OPAQUE16_LEN;
9568:../src/src/tls.c ****     }
9569:../src/src/tls.c ****     else
9570:../src/src/tls.c ****         return SANITY_MSG_E;
9571:../src/src/tls.c **** 
9572:../src/src/tls.c ****     return 0;
9573:../src/src/tls.c **** }
9574:../src/src/tls.c **** 
9575:../src/src/tls.c **** /* Parse the pre-shared key extension.
9576:../src/src/tls.c ****  * Different formats in different messages.
9577:../src/src/tls.c ****  *
9578:../src/src/tls.c ****  * ssl      The SSL/TLS object.
9579:../src/src/tls.c ****  * input    The extension data.
9580:../src/src/tls.c ****  * length   The length of the extension data.
9581:../src/src/tls.c ****  * msgType  The type of the message this extension is being parsed from.
9582:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
9583:../src/src/tls.c ****  */
9584:../src/src/tls.c **** static int TLSX_PreSharedKey_Parse(WOLFSSL* ssl, const byte* input,
9585:../src/src/tls.c ****                                    word16 length, byte msgType)
9586:../src/src/tls.c **** {
9587:../src/src/tls.c ****     TLSX*         extension;
9588:../src/src/tls.c ****     PreSharedKey* list;
9589:../src/src/tls.c **** 
9590:../src/src/tls.c ****     if (msgType == client_hello) {
9591:../src/src/tls.c ****         int    ret;
9592:../src/src/tls.c ****         word16 len;
9593:../src/src/tls.c ****         word16 idx = 0;
9594:../src/src/tls.c **** 
9595:../src/src/tls.c ****         TLSX_Remove(&ssl->extensions, TLSX_PRE_SHARED_KEY, ssl->heap);
9596:../src/src/tls.c **** 
9597:../src/src/tls.c ****         /* Length of identities and of binders. */
9598:../src/src/tls.c ****         if ((int)(length - idx) < OPAQUE16_LEN + OPAQUE16_LEN)
9599:../src/src/tls.c ****             return BUFFER_E;
9600:../src/src/tls.c **** 
9601:../src/src/tls.c ****         /* Length of identities. */
9602:../src/src/tls.c ****         ato16(input + idx, &len);
9603:../src/src/tls.c ****         idx += OPAQUE16_LEN;
9604:../src/src/tls.c ****         if (len < MIN_PSK_ID_LEN || length - idx < len)
9605:../src/src/tls.c ****             return BUFFER_E;
9606:../src/src/tls.c **** 
9607:../src/src/tls.c ****         /* Create a pre-shared key object for each identity. */
9608:../src/src/tls.c ****         while (len > 0) {
9609:../src/src/tls.c ****             const byte* identity;
9610:../src/src/tls.c ****             word16      identityLen;
9611:../src/src/tls.c ****             word32      age;
9612:../src/src/tls.c **** 
9613:../src/src/tls.c ****             if (len < OPAQUE16_LEN)
9614:../src/src/tls.c ****                 return BUFFER_E;
9615:../src/src/tls.c **** 
9616:../src/src/tls.c ****             /* Length of identity. */
9617:../src/src/tls.c ****             ato16(input + idx, &identityLen);
9618:../src/src/tls.c ****             idx += OPAQUE16_LEN;
9619:../src/src/tls.c ****             if (len < OPAQUE16_LEN + identityLen + OPAQUE32_LEN ||
9620:../src/src/tls.c ****                     identityLen > MAX_PSK_ID_LEN)
9621:../src/src/tls.c ****                 return BUFFER_E;
9622:../src/src/tls.c ****             /* Cache identity pointer. */
9623:../src/src/tls.c ****             identity = input + idx;
9624:../src/src/tls.c ****             idx += identityLen;
9625:../src/src/tls.c ****             /* Ticket age. */
9626:../src/src/tls.c ****             ato32(input + idx, &age);
9627:../src/src/tls.c ****             idx += OPAQUE32_LEN;
9628:../src/src/tls.c **** 
9629:../src/src/tls.c ****             ret = TLSX_PreSharedKey_Use(ssl, identity, identityLen, age, no_mac,
9630:../src/src/tls.c ****                                         0, 0, 1, NULL);
9631:../src/src/tls.c ****             if (ret != 0)
9632:../src/src/tls.c ****                 return ret;
9633:../src/src/tls.c **** 
9634:../src/src/tls.c ****             /* Done with this identity. */
9635:../src/src/tls.c ****             len -= OPAQUE16_LEN + identityLen + OPAQUE32_LEN;
9636:../src/src/tls.c ****         }
9637:../src/src/tls.c **** 
9638:../src/src/tls.c ****         /* Find the list of identities sent to server. */
9639:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_PRE_SHARED_KEY);
9640:../src/src/tls.c ****         if (extension == NULL)
9641:../src/src/tls.c ****             return PSK_KEY_ERROR;
9642:../src/src/tls.c ****         list = (PreSharedKey*)extension->data;
9643:../src/src/tls.c **** 
9644:../src/src/tls.c ****         /* Length of binders. */
9645:../src/src/tls.c ****         if (idx + OPAQUE16_LEN > length)
9646:../src/src/tls.c ****             return BUFFER_E;
9647:../src/src/tls.c ****         ato16(input + idx, &len);
9648:../src/src/tls.c ****         idx += OPAQUE16_LEN;
9649:../src/src/tls.c ****         if (len < MIN_PSK_BINDERS_LEN || length - idx < len)
9650:../src/src/tls.c ****             return BUFFER_E;
9651:../src/src/tls.c **** 
9652:../src/src/tls.c ****         /* Set binder for each identity. */
9653:../src/src/tls.c ****         while (list != NULL && len > 0) {
9654:../src/src/tls.c ****             /* Length of binder */
9655:../src/src/tls.c ****             list->binderLen = input[idx++];
9656:../src/src/tls.c ****             if (list->binderLen < WC_SHA256_DIGEST_SIZE ||
9657:../src/src/tls.c ****                     list->binderLen > WC_MAX_DIGEST_SIZE)
9658:../src/src/tls.c ****                 return BUFFER_E;
9659:../src/src/tls.c ****             if (len < OPAQUE8_LEN + list->binderLen)
9660:../src/src/tls.c ****                 return BUFFER_E;
9661:../src/src/tls.c **** 
9662:../src/src/tls.c ****             /* Copy binder into static buffer. */
9663:../src/src/tls.c ****             XMEMCPY(list->binder, input + idx, list->binderLen);
9664:../src/src/tls.c ****             idx += (word16)list->binderLen;
9665:../src/src/tls.c **** 
9666:../src/src/tls.c ****             /* Done with binder entry. */
9667:../src/src/tls.c ****             len -= OPAQUE8_LEN + (word16)list->binderLen;
9668:../src/src/tls.c **** 
9669:../src/src/tls.c ****             /* Next identity. */
9670:../src/src/tls.c ****             list = list->next;
9671:../src/src/tls.c ****         }
9672:../src/src/tls.c ****         if (list != NULL || len != 0)
9673:../src/src/tls.c ****             return BUFFER_E;
9674:../src/src/tls.c **** 
9675:../src/src/tls.c ****         return 0;
9676:../src/src/tls.c ****     }
9677:../src/src/tls.c **** 
9678:../src/src/tls.c ****     if (msgType == server_hello) {
9679:../src/src/tls.c ****         word16 idx;
9680:../src/src/tls.c **** 
9681:../src/src/tls.c ****         /* Index of identity chosen by server. */
9682:../src/src/tls.c ****         if (length != OPAQUE16_LEN)
9683:../src/src/tls.c ****             return BUFFER_E;
9684:../src/src/tls.c ****         ato16(input, &idx);
9685:../src/src/tls.c **** 
9686:../src/src/tls.c ****     #ifdef WOLFSSL_EARLY_DATA
9687:../src/src/tls.c ****         ssl->options.pskIdIndex = idx + 1;
9688:../src/src/tls.c ****     #endif
9689:../src/src/tls.c **** 
9690:../src/src/tls.c ****         /* Find the list of identities sent to server. */
9691:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_PRE_SHARED_KEY);
9692:../src/src/tls.c ****         if (extension == NULL)
9693:../src/src/tls.c ****             return PSK_KEY_ERROR;
9694:../src/src/tls.c ****         list = (PreSharedKey*)extension->data;
9695:../src/src/tls.c **** 
9696:../src/src/tls.c ****         /* Mark the identity as chosen. */
9697:../src/src/tls.c ****         for (; list != NULL && idx > 0; idx--)
9698:../src/src/tls.c ****             list = list->next;
9699:../src/src/tls.c ****         if (list == NULL)
9700:../src/src/tls.c ****             return PSK_KEY_ERROR;
9701:../src/src/tls.c ****         list->chosen = 1;
9702:../src/src/tls.c **** 
9703:../src/src/tls.c ****     #ifdef HAVE_SESSION_TICKET
9704:../src/src/tls.c ****         if (list->resumption) {
9705:../src/src/tls.c ****            /* Check that the session's details are the same as the server's. */
9706:../src/src/tls.c ****            if (ssl->options.cipherSuite0  != ssl->session->cipherSuite0       ||
9707:../src/src/tls.c ****                ssl->options.cipherSuite   != ssl->session->cipherSuite        ||
9708:../src/src/tls.c ****                ssl->session->version.major != ssl->ctx->method->version.major ||
9709:../src/src/tls.c ****                ssl->session->version.minor != ssl->ctx->method->version.minor) {
9710:../src/src/tls.c ****                return PSK_KEY_ERROR;
9711:../src/src/tls.c ****            }
9712:../src/src/tls.c ****         }
9713:../src/src/tls.c ****     #endif
9714:../src/src/tls.c **** 
9715:../src/src/tls.c ****         return 0;
9716:../src/src/tls.c ****     }
9717:../src/src/tls.c **** 
9718:../src/src/tls.c ****     return SANITY_MSG_E;
9719:../src/src/tls.c **** }
9720:../src/src/tls.c **** 
9721:../src/src/tls.c **** /* Create a new pre-shared key and put it into the list.
9722:../src/src/tls.c ****  *
9723:../src/src/tls.c ****  * list          The linked list of pre-shared key.
9724:../src/src/tls.c ****  * identity      The identity.
9725:../src/src/tls.c ****  * len           The length of the identity data.
9726:../src/src/tls.c ****  * heap          The memory to allocate with.
9727:../src/src/tls.c ****  * preSharedKey  The new pre-shared key object.
9728:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
9729:../src/src/tls.c ****  */
9730:../src/src/tls.c **** static int TLSX_PreSharedKey_New(PreSharedKey** list, const byte* identity,
9731:../src/src/tls.c ****                                  word16 len, void *heap,
9732:../src/src/tls.c ****                                  PreSharedKey** preSharedKey)
9733:../src/src/tls.c **** {
9734:../src/src/tls.c ****     PreSharedKey* psk;
9735:../src/src/tls.c ****     PreSharedKey** next;
9736:../src/src/tls.c **** 
9737:../src/src/tls.c ****     psk = (PreSharedKey*)XMALLOC(sizeof(PreSharedKey), heap, DYNAMIC_TYPE_TLSX);
9738:../src/src/tls.c ****     if (psk == NULL)
9739:../src/src/tls.c ****         return MEMORY_E;
9740:../src/src/tls.c ****     XMEMSET(psk, 0, sizeof(*psk));
9741:../src/src/tls.c **** 
9742:../src/src/tls.c ****     /* Make a copy of the identity data. */
9743:../src/src/tls.c ****     psk->identity = (byte*)XMALLOC(len, heap, DYNAMIC_TYPE_TLSX);
9744:../src/src/tls.c ****     if (psk->identity == NULL) {
9745:../src/src/tls.c ****         XFREE(psk, heap, DYNAMIC_TYPE_TLSX);
9746:../src/src/tls.c ****         return MEMORY_E;
9747:../src/src/tls.c ****     }
9748:../src/src/tls.c ****     XMEMCPY(psk->identity, identity, len);
9749:../src/src/tls.c ****     psk->identityLen = len;
9750:../src/src/tls.c **** 
9751:../src/src/tls.c ****     /* Add it to the end and maintain the links. */
9752:../src/src/tls.c ****     while (*list != NULL) {
9753:../src/src/tls.c ****         /* Assign to temporary to work around compiler bug found by customer. */
9754:../src/src/tls.c ****         next = &((*list)->next);
9755:../src/src/tls.c ****         list = next;
9756:../src/src/tls.c ****     }
9757:../src/src/tls.c ****     *list = psk;
9758:../src/src/tls.c ****     *preSharedKey = psk;
9759:../src/src/tls.c **** 
9760:../src/src/tls.c ****     (void)heap;
9761:../src/src/tls.c **** 
9762:../src/src/tls.c ****     return 0;
9763:../src/src/tls.c **** }
9764:../src/src/tls.c **** 
9765:../src/src/tls.c **** static WC_INLINE byte GetHmacLength(int hmac)
9766:../src/src/tls.c **** {
9767:../src/src/tls.c ****     switch (hmac) {
9768:../src/src/tls.c ****     #ifndef NO_SHA256
9769:../src/src/tls.c ****         case sha256_mac:
9770:../src/src/tls.c ****             return WC_SHA256_DIGEST_SIZE;
9771:../src/src/tls.c ****     #endif
9772:../src/src/tls.c ****     #ifdef WOLFSSL_SHA384
9773:../src/src/tls.c ****         case sha384_mac:
9774:../src/src/tls.c ****             return WC_SHA384_DIGEST_SIZE;
9775:../src/src/tls.c ****     #endif
9776:../src/src/tls.c ****     #ifdef WOLFSSL_SHA512
9777:../src/src/tls.c ****         case sha512_mac:
9778:../src/src/tls.c ****             return WC_SHA512_DIGEST_SIZE;
9779:../src/src/tls.c ****     #endif
9780:../src/src/tls.c ****     }
9781:../src/src/tls.c ****     return 0;
9782:../src/src/tls.c **** }
9783:../src/src/tls.c **** 
9784:../src/src/tls.c **** /* Use the data to create a new pre-shared key object in the extensions.
9785:../src/src/tls.c ****  *
9786:../src/src/tls.c ****  * ssl           The SSL/TLS object.
9787:../src/src/tls.c ****  * identity      The identity.
9788:../src/src/tls.c ****  * len           The length of the identity data.
9789:../src/src/tls.c ****  * age           The age of the identity.
9790:../src/src/tls.c ****  * hmac          The HMAC algorithm.
9791:../src/src/tls.c ****  * ciphersuite0  The first byte of the ciphersuite to use.
9792:../src/src/tls.c ****  * ciphersuite   The second byte of the ciphersuite to use.
9793:../src/src/tls.c ****  * resumption    The PSK is for resumption of a session.
9794:../src/src/tls.c ****  * preSharedKey  The new pre-shared key object.
9795:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
9796:../src/src/tls.c ****  */
9797:../src/src/tls.c **** int TLSX_PreSharedKey_Use(WOLFSSL* ssl, const byte* identity, word16 len,
9798:../src/src/tls.c ****                           word32 age, byte hmac, byte cipherSuite0,
9799:../src/src/tls.c ****                           byte cipherSuite, byte resumption,
9800:../src/src/tls.c ****                           PreSharedKey **preSharedKey)
9801:../src/src/tls.c **** {
9802:../src/src/tls.c ****     int           ret = 0;
9803:../src/src/tls.c ****     TLSX*         extension;
9804:../src/src/tls.c ****     PreSharedKey* psk = NULL;
9805:../src/src/tls.c **** 
9806:../src/src/tls.c ****     /* Find the pre-shared key extension if it exists. */
9807:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_PRE_SHARED_KEY);
9808:../src/src/tls.c ****     if (extension == NULL) {
9809:../src/src/tls.c ****         /* Push new pre-shared key extension. */
9810:../src/src/tls.c ****         ret = TLSX_Push(&ssl->extensions, TLSX_PRE_SHARED_KEY, NULL, ssl->heap);
9811:../src/src/tls.c ****         if (ret != 0)
9812:../src/src/tls.c ****             return ret;
9813:../src/src/tls.c **** 
9814:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_PRE_SHARED_KEY);
9815:../src/src/tls.c ****         if (extension == NULL)
9816:../src/src/tls.c ****             return MEMORY_E;
9817:../src/src/tls.c ****     }
9818:../src/src/tls.c **** 
9819:../src/src/tls.c ****     /* Try to find the pre-shared key with this identity. */
9820:../src/src/tls.c ****     psk = (PreSharedKey*)extension->data;
9821:../src/src/tls.c ****     while (psk != NULL) {
9822:../src/src/tls.c ****         if ((psk->identityLen == len) &&
9823:../src/src/tls.c ****                (XMEMCMP(psk->identity, identity, len) == 0)) {
9824:../src/src/tls.c ****             break;
9825:../src/src/tls.c ****         }
9826:../src/src/tls.c ****         psk = psk->next;
9827:../src/src/tls.c ****     }
9828:../src/src/tls.c **** 
9829:../src/src/tls.c ****     /* Create a new pre-shared key object if not found. */
9830:../src/src/tls.c ****     if (psk == NULL) {
9831:../src/src/tls.c ****         ret = TLSX_PreSharedKey_New((PreSharedKey**)&extension->data, identity,
9832:../src/src/tls.c ****                                     len, ssl->heap, &psk);
9833:../src/src/tls.c ****         if (ret != 0)
9834:../src/src/tls.c ****             return ret;
9835:../src/src/tls.c ****     }
9836:../src/src/tls.c **** 
9837:../src/src/tls.c ****     /* Update/set age and HMAC algorithm. */
9838:../src/src/tls.c ****     psk->ticketAge    = age;
9839:../src/src/tls.c ****     psk->hmac         = hmac;
9840:../src/src/tls.c ****     psk->cipherSuite0 = cipherSuite0;
9841:../src/src/tls.c ****     psk->cipherSuite  = cipherSuite;
9842:../src/src/tls.c ****     psk->resumption   = resumption;
9843:../src/src/tls.c ****     psk->binderLen    = GetHmacLength(psk->hmac);
9844:../src/src/tls.c **** 
9845:../src/src/tls.c ****     if (preSharedKey != NULL)
9846:../src/src/tls.c ****         *preSharedKey = psk;
9847:../src/src/tls.c **** 
9848:../src/src/tls.c ****     return 0;
9849:../src/src/tls.c **** }
9850:../src/src/tls.c **** 
9851:../src/src/tls.c **** #define PSK_FREE_ALL  TLSX_PreSharedKey_FreeAll
9852:../src/src/tls.c **** #define PSK_GET_SIZE  TLSX_PreSharedKey_GetSize
9853:../src/src/tls.c **** #define PSK_WRITE     TLSX_PreSharedKey_Write
9854:../src/src/tls.c **** #define PSK_PARSE     TLSX_PreSharedKey_Parse
9855:../src/src/tls.c **** 
9856:../src/src/tls.c **** #else
9857:../src/src/tls.c **** 
9858:../src/src/tls.c **** #define PSK_FREE_ALL(a, b)
9859:../src/src/tls.c **** #define PSK_GET_SIZE(a, b, c) 0
9860:../src/src/tls.c **** #define PSK_WRITE(a, b, c, d) 0
9861:../src/src/tls.c **** #define PSK_PARSE(a, b, c, d) 0
9862:../src/src/tls.c **** 
9863:../src/src/tls.c **** #endif
9864:../src/src/tls.c **** 
9865:../src/src/tls.c **** /******************************************************************************/
9866:../src/src/tls.c **** /* PSK Key Exchange Modes                                                     */
9867:../src/src/tls.c **** /******************************************************************************/
9868:../src/src/tls.c **** 
9869:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))
9870:../src/src/tls.c **** /* Get the size of the encoded PSK KE modes extension.
9871:../src/src/tls.c ****  * Only in ClientHello.
9872:../src/src/tls.c ****  *
9873:../src/src/tls.c ****  * modes    The PSK KE mode bit string.
9874:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
9875:../src/src/tls.c ****  * returns the number of bytes of the encoded PSK KE mode extension.
9876:../src/src/tls.c ****  */
9877:../src/src/tls.c **** static int TLSX_PskKeModes_GetSize(byte modes, byte msgType, word16* pSz)
9878:../src/src/tls.c **** {
9879:../src/src/tls.c ****     if (msgType == client_hello) {
9880:../src/src/tls.c ****         /* Format: Len | Modes* */
9881:../src/src/tls.c ****         word16 len = OPAQUE8_LEN;
9882:../src/src/tls.c ****         /* Check whether each possible mode is to be written. */
9883:../src/src/tls.c ****         if (modes & (1 << PSK_KE))
9884:../src/src/tls.c ****             len += OPAQUE8_LEN;
9885:../src/src/tls.c ****         if (modes & (1 << PSK_DHE_KE))
9886:../src/src/tls.c ****             len += OPAQUE8_LEN;
9887:../src/src/tls.c ****         *pSz += len;
9888:../src/src/tls.c ****         return 0;
9889:../src/src/tls.c ****     }
9890:../src/src/tls.c **** 
9891:../src/src/tls.c ****     return SANITY_MSG_E;
9892:../src/src/tls.c **** }
9893:../src/src/tls.c **** 
9894:../src/src/tls.c **** /* Writes the PSK KE modes extension into the output buffer.
9895:../src/src/tls.c ****  * Assumes that the the output buffer is big enough to hold data.
9896:../src/src/tls.c ****  * Only in ClientHello.
9897:../src/src/tls.c ****  *
9898:../src/src/tls.c ****  * modes    The PSK KE mode bit string.
9899:../src/src/tls.c ****  * output   The buffer to write into.
9900:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
9901:../src/src/tls.c ****  * returns the number of bytes written into the buffer.
9902:../src/src/tls.c ****  */
9903:../src/src/tls.c **** static int TLSX_PskKeModes_Write(byte modes, byte* output, byte msgType,
9904:../src/src/tls.c ****                                  word16* pSz)
9905:../src/src/tls.c **** {
9906:../src/src/tls.c ****     if (msgType == client_hello) {
9907:../src/src/tls.c ****         /* Format: Len | Modes* */
9908:../src/src/tls.c ****         word16 idx = OPAQUE8_LEN;
9909:../src/src/tls.c **** 
9910:../src/src/tls.c ****         /* Write out each possible mode. */
9911:../src/src/tls.c ****         if (modes & (1 << PSK_KE))
9912:../src/src/tls.c ****             output[idx++] = PSK_KE;
9913:../src/src/tls.c ****         if (modes & (1 << PSK_DHE_KE))
9914:../src/src/tls.c ****             output[idx++] = PSK_DHE_KE;
9915:../src/src/tls.c ****         /* Write out length of mode list. */
9916:../src/src/tls.c ****         output[0] = (byte)(idx - OPAQUE8_LEN);
9917:../src/src/tls.c **** 
9918:../src/src/tls.c ****         *pSz += idx;
9919:../src/src/tls.c ****         return 0;
9920:../src/src/tls.c ****     }
9921:../src/src/tls.c **** 
9922:../src/src/tls.c ****     return SANITY_MSG_E;
9923:../src/src/tls.c **** }
9924:../src/src/tls.c **** 
9925:../src/src/tls.c **** /* Parse the PSK KE modes extension.
9926:../src/src/tls.c ****  * Only in ClientHello.
9927:../src/src/tls.c ****  *
9928:../src/src/tls.c ****  * ssl      The SSL/TLS object.
9929:../src/src/tls.c ****  * input    The extension data.
9930:../src/src/tls.c ****  * length   The length of the extension data.
9931:../src/src/tls.c ****  * msgType  The type of the message this extension is being parsed from.
9932:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
9933:../src/src/tls.c ****  */
9934:../src/src/tls.c **** static int TLSX_PskKeModes_Parse(WOLFSSL* ssl, const byte* input, word16 length,
9935:../src/src/tls.c ****                                  byte msgType)
9936:../src/src/tls.c **** {
9937:../src/src/tls.c ****     int    ret;
9938:../src/src/tls.c **** 
9939:../src/src/tls.c ****     if (msgType == client_hello) {
9940:../src/src/tls.c ****         /* Format: Len | Modes* */
9941:../src/src/tls.c ****         int   idx = 0;
9942:../src/src/tls.c ****         word16 len;
9943:../src/src/tls.c ****         byte  modes = 0;
9944:../src/src/tls.c **** 
9945:../src/src/tls.c ****         /* Ensure length byte exists. */
9946:../src/src/tls.c ****         if (length < OPAQUE8_LEN)
9947:../src/src/tls.c ****             return BUFFER_E;
9948:../src/src/tls.c **** 
9949:../src/src/tls.c ****         /* Get length of mode list and ensure that is the only data. */
9950:../src/src/tls.c ****         len = input[0];
9951:../src/src/tls.c ****         if (length - OPAQUE8_LEN != len)
9952:../src/src/tls.c ****             return BUFFER_E;
9953:../src/src/tls.c **** 
9954:../src/src/tls.c ****         idx = OPAQUE8_LEN;
9955:../src/src/tls.c ****         /* Set a bit for each recognized modes. */
9956:../src/src/tls.c ****         while (len > 0) {
9957:../src/src/tls.c ****             /* Ignore unrecognized modes.  */
9958:../src/src/tls.c ****             if (input[idx] <= PSK_DHE_KE)
9959:../src/src/tls.c ****                modes |= 1 << input[idx];
9960:../src/src/tls.c ****             idx++;
9961:../src/src/tls.c ****             len--;
9962:../src/src/tls.c ****         }
9963:../src/src/tls.c **** 
9964:../src/src/tls.c ****         ret = TLSX_PskKeModes_Use(ssl, modes);
9965:../src/src/tls.c ****         if (ret != 0)
9966:../src/src/tls.c ****             return ret;
9967:../src/src/tls.c **** 
9968:../src/src/tls.c ****         return 0;
9969:../src/src/tls.c ****     }
9970:../src/src/tls.c **** 
9971:../src/src/tls.c ****     return SANITY_MSG_E;
9972:../src/src/tls.c **** }
9973:../src/src/tls.c **** 
9974:../src/src/tls.c **** /* Use the data to create a new PSK Key Exchange Modes object in the extensions.
9975:../src/src/tls.c ****  *
9976:../src/src/tls.c ****  * ssl    The SSL/TLS object.
9977:../src/src/tls.c ****  * modes  The PSK key exchange modes.
9978:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
9979:../src/src/tls.c ****  */
9980:../src/src/tls.c **** int TLSX_PskKeModes_Use(WOLFSSL* ssl, byte modes)
9981:../src/src/tls.c **** {
9982:../src/src/tls.c ****     int           ret = 0;
9983:../src/src/tls.c ****     TLSX*         extension;
9984:../src/src/tls.c **** 
9985:../src/src/tls.c ****     /* Find the PSK key exchange modes extension if it exists. */
9986:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_PSK_KEY_EXCHANGE_MODES);
9987:../src/src/tls.c ****     if (extension == NULL) {
9988:../src/src/tls.c ****         /* Push new PSK key exchange modes extension. */
9989:../src/src/tls.c ****         ret = TLSX_Push(&ssl->extensions, TLSX_PSK_KEY_EXCHANGE_MODES, NULL,
9990:../src/src/tls.c ****             ssl->heap);
9991:../src/src/tls.c ****         if (ret != 0)
9992:../src/src/tls.c ****             return ret;
9993:../src/src/tls.c **** 
9994:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_PSK_KEY_EXCHANGE_MODES);
9995:../src/src/tls.c ****         if (extension == NULL)
9996:../src/src/tls.c ****             return MEMORY_E;
9997:../src/src/tls.c ****     }
9998:../src/src/tls.c **** 
9999:../src/src/tls.c ****     extension->val = modes;
10000:../src/src/tls.c **** 
10001:../src/src/tls.c ****     return 0;
10002:../src/src/tls.c **** }
10003:../src/src/tls.c **** 
10004:../src/src/tls.c **** #define PKM_GET_SIZE  TLSX_PskKeModes_GetSize
10005:../src/src/tls.c **** #define PKM_WRITE     TLSX_PskKeModes_Write
10006:../src/src/tls.c **** #define PKM_PARSE     TLSX_PskKeModes_Parse
10007:../src/src/tls.c **** 
10008:../src/src/tls.c **** #else
10009:../src/src/tls.c **** 
10010:../src/src/tls.c **** #define PKM_GET_SIZE(a, b, c) 0
10011:../src/src/tls.c **** #define PKM_WRITE(a, b, c, d) 0
10012:../src/src/tls.c **** #define PKM_PARSE(a, b, c, d) 0
10013:../src/src/tls.c **** 
10014:../src/src/tls.c **** #endif
10015:../src/src/tls.c **** 
10016:../src/src/tls.c **** /******************************************************************************/
10017:../src/src/tls.c **** /* Post-Handshake Authentication                                              */
10018:../src/src/tls.c **** /******************************************************************************/
10019:../src/src/tls.c **** 
10020:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(WOLFSSL_POST_HANDSHAKE_AUTH)
10021:../src/src/tls.c **** /* Get the size of the encoded Post-Handshake Authentication extension.
10022:../src/src/tls.c ****  * Only in ClientHello.
10023:../src/src/tls.c ****  *
10024:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
10025:../src/src/tls.c ****  * returns the number of bytes of the encoded Post-Handshake Authentication
10026:../src/src/tls.c ****  * extension.
10027:../src/src/tls.c ****  */
10028:../src/src/tls.c **** static int TLSX_PostHandAuth_GetSize(byte msgType, word16* pSz)
10029:../src/src/tls.c **** {
10030:../src/src/tls.c ****     if (msgType == client_hello) {
10031:../src/src/tls.c ****         *pSz += 0;
10032:../src/src/tls.c ****         return 0;
10033:../src/src/tls.c ****     }
10034:../src/src/tls.c **** 
10035:../src/src/tls.c ****     return SANITY_MSG_E;
10036:../src/src/tls.c **** }
10037:../src/src/tls.c **** 
10038:../src/src/tls.c **** /* Writes the Post-Handshake Authentication extension into the output buffer.
10039:../src/src/tls.c ****  * Assumes that the the output buffer is big enough to hold data.
10040:../src/src/tls.c ****  * Only in ClientHello.
10041:../src/src/tls.c ****  *
10042:../src/src/tls.c ****  * output   The buffer to write into.
10043:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
10044:../src/src/tls.c ****  * returns the number of bytes written into the buffer.
10045:../src/src/tls.c ****  */
10046:../src/src/tls.c **** static int TLSX_PostHandAuth_Write(byte* output, byte msgType, word16* pSz)
10047:../src/src/tls.c **** {
10048:../src/src/tls.c ****     (void)output;
10049:../src/src/tls.c **** 
10050:../src/src/tls.c ****     if (msgType == client_hello) {
10051:../src/src/tls.c ****         *pSz += 0;
10052:../src/src/tls.c ****         return 0;
10053:../src/src/tls.c ****     }
10054:../src/src/tls.c **** 
10055:../src/src/tls.c ****     return SANITY_MSG_E;
10056:../src/src/tls.c **** }
10057:../src/src/tls.c **** 
10058:../src/src/tls.c **** /* Parse the Post-Handshake Authentication extension.
10059:../src/src/tls.c ****  * Only in ClientHello.
10060:../src/src/tls.c ****  *
10061:../src/src/tls.c ****  * ssl      The SSL/TLS object.
10062:../src/src/tls.c ****  * input    The extension data.
10063:../src/src/tls.c ****  * length   The length of the extension data.
10064:../src/src/tls.c ****  * msgType  The type of the message this extension is being parsed from.
10065:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
10066:../src/src/tls.c ****  */
10067:../src/src/tls.c **** static int TLSX_PostHandAuth_Parse(WOLFSSL* ssl, const byte* input,
10068:../src/src/tls.c ****                                    word16 length, byte msgType)
10069:../src/src/tls.c **** {
10070:../src/src/tls.c ****     (void)input;
10071:../src/src/tls.c **** 
10072:../src/src/tls.c ****     if (msgType == client_hello) {
10073:../src/src/tls.c ****         /* Ensure extension is empty. */
10074:../src/src/tls.c ****         if (length != 0)
10075:../src/src/tls.c ****             return BUFFER_E;
10076:../src/src/tls.c **** 
10077:../src/src/tls.c ****         ssl->options.postHandshakeAuth = 1;
10078:../src/src/tls.c ****         return 0;
10079:../src/src/tls.c ****     }
10080:../src/src/tls.c **** 
10081:../src/src/tls.c ****     return SANITY_MSG_E;
10082:../src/src/tls.c **** }
10083:../src/src/tls.c **** 
10084:../src/src/tls.c **** /* Create a new Post-handshake authentication object in the extensions.
10085:../src/src/tls.c ****  *
10086:../src/src/tls.c ****  * ssl    The SSL/TLS object.
10087:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
10088:../src/src/tls.c ****  */
10089:../src/src/tls.c **** static int TLSX_PostHandAuth_Use(WOLFSSL* ssl)
10090:../src/src/tls.c **** {
10091:../src/src/tls.c ****     int   ret = 0;
10092:../src/src/tls.c ****     TLSX* extension;
10093:../src/src/tls.c **** 
10094:../src/src/tls.c ****     /* Find the PSK key exchange modes extension if it exists. */
10095:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_POST_HANDSHAKE_AUTH);
10096:../src/src/tls.c ****     if (extension == NULL) {
10097:../src/src/tls.c ****         /* Push new Post-handshake Authentication extension. */
10098:../src/src/tls.c ****         ret = TLSX_Push(&ssl->extensions, TLSX_POST_HANDSHAKE_AUTH, NULL,
10099:../src/src/tls.c ****             ssl->heap);
10100:../src/src/tls.c ****         if (ret != 0)
10101:../src/src/tls.c ****             return ret;
10102:../src/src/tls.c ****     }
10103:../src/src/tls.c **** 
10104:../src/src/tls.c ****     return 0;
10105:../src/src/tls.c **** }
10106:../src/src/tls.c **** 
10107:../src/src/tls.c **** #define PHA_GET_SIZE  TLSX_PostHandAuth_GetSize
10108:../src/src/tls.c **** #define PHA_WRITE     TLSX_PostHandAuth_Write
10109:../src/src/tls.c **** #define PHA_PARSE     TLSX_PostHandAuth_Parse
10110:../src/src/tls.c **** 
10111:../src/src/tls.c **** #else
10112:../src/src/tls.c **** 
10113:../src/src/tls.c **** #define PHA_GET_SIZE(a, b)    0
10114:../src/src/tls.c **** #define PHA_WRITE(a, b, c)    0
10115:../src/src/tls.c **** #define PHA_PARSE(a, b, c, d) 0
10116:../src/src/tls.c **** 
10117:../src/src/tls.c **** #endif
10118:../src/src/tls.c **** 
10119:../src/src/tls.c **** /******************************************************************************/
10120:../src/src/tls.c **** /* Early Data Indication                                                      */
10121:../src/src/tls.c **** /******************************************************************************/
10122:../src/src/tls.c **** 
10123:../src/src/tls.c **** #ifdef WOLFSSL_EARLY_DATA
10124:../src/src/tls.c **** /* Get the size of the encoded Early Data Indication extension.
10125:../src/src/tls.c ****  * In messages: ClientHello, EncryptedExtensions and NewSessionTicket.
10126:../src/src/tls.c ****  *
10127:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
10128:../src/src/tls.c ****  * returns the number of bytes of the encoded Early Data Indication extension.
10129:../src/src/tls.c ****  */
10130:../src/src/tls.c **** static int TLSX_EarlyData_GetSize(byte msgType, word16* pSz)
10131:../src/src/tls.c **** {
10132:../src/src/tls.c ****     int ret = 0;
10133:../src/src/tls.c **** 
10134:../src/src/tls.c ****     if (msgType == client_hello || msgType == encrypted_extensions)
10135:../src/src/tls.c ****         *pSz += 0;
10136:../src/src/tls.c ****     else if (msgType == session_ticket)
10137:../src/src/tls.c ****         *pSz += OPAQUE32_LEN;
10138:../src/src/tls.c ****     else
10139:../src/src/tls.c ****         ret = SANITY_MSG_E;
10140:../src/src/tls.c **** 
10141:../src/src/tls.c ****     return ret;
10142:../src/src/tls.c **** }
10143:../src/src/tls.c **** 
10144:../src/src/tls.c **** /* Writes the Early Data Indicator extension into the output buffer.
10145:../src/src/tls.c ****  * Assumes that the the output buffer is big enough to hold data.
10146:../src/src/tls.c ****  * In messages: ClientHello, EncryptedExtensions and NewSessionTicket.
10147:../src/src/tls.c ****  *
10148:../src/src/tls.c ****  * maxSz    The maximum early data size.
10149:../src/src/tls.c ****  * output   The buffer to write into.
10150:../src/src/tls.c ****  * msgType  The type of the message this extension is being written into.
10151:../src/src/tls.c ****  * returns the number of bytes written into the buffer.
10152:../src/src/tls.c ****  */
10153:../src/src/tls.c **** static int TLSX_EarlyData_Write(word32 maxSz, byte* output, byte msgType,
10154:../src/src/tls.c ****                                 word16* pSz)
10155:../src/src/tls.c **** {
10156:../src/src/tls.c ****     if (msgType == client_hello || msgType == encrypted_extensions)
10157:../src/src/tls.c ****         return 0;
10158:../src/src/tls.c ****     else if (msgType == session_ticket) {
10159:../src/src/tls.c ****         c32toa(maxSz, output);
10160:../src/src/tls.c ****         *pSz += OPAQUE32_LEN;
10161:../src/src/tls.c ****         return 0;
10162:../src/src/tls.c ****     }
10163:../src/src/tls.c **** 
10164:../src/src/tls.c ****     return SANITY_MSG_E;
10165:../src/src/tls.c **** }
10166:../src/src/tls.c **** 
10167:../src/src/tls.c **** /* Parse the Early Data Indicator extension.
10168:../src/src/tls.c ****  * In messages: ClientHello, EncryptedExtensions and NewSessionTicket.
10169:../src/src/tls.c ****  *
10170:../src/src/tls.c ****  * ssl      The SSL/TLS object.
10171:../src/src/tls.c ****  * input    The extension data.
10172:../src/src/tls.c ****  * length   The length of the extension data.
10173:../src/src/tls.c ****  * msgType  The type of the message this extension is being parsed from.
10174:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
10175:../src/src/tls.c ****  */
10176:../src/src/tls.c **** static int TLSX_EarlyData_Parse(WOLFSSL* ssl, const byte* input, word16 length,
10177:../src/src/tls.c ****                                  byte msgType)
10178:../src/src/tls.c **** {
10179:../src/src/tls.c ****     if (msgType == client_hello) {
10180:../src/src/tls.c ****         if (length != 0)
10181:../src/src/tls.c ****             return BUFFER_E;
10182:../src/src/tls.c **** 
10183:../src/src/tls.c ****         if (ssl->earlyData == expecting_early_data) {
10184:../src/src/tls.c **** 
10185:../src/src/tls.c ****             if (ssl->options.maxEarlyDataSz != 0)
10186:../src/src/tls.c ****                 ssl->earlyDataStatus = WOLFSSL_EARLY_DATA_ACCEPTED;
10187:../src/src/tls.c ****             else
10188:../src/src/tls.c ****                 ssl->earlyDataStatus = WOLFSSL_EARLY_DATA_REJECTED;
10189:../src/src/tls.c **** 
10190:../src/src/tls.c ****             return TLSX_EarlyData_Use(ssl, 0);
10191:../src/src/tls.c ****         }
10192:../src/src/tls.c ****         ssl->earlyData = early_data_ext;
10193:../src/src/tls.c **** 
10194:../src/src/tls.c ****         return 0;
10195:../src/src/tls.c ****     }
10196:../src/src/tls.c ****     if (msgType == encrypted_extensions) {
10197:../src/src/tls.c ****         if (length != 0)
10198:../src/src/tls.c ****             return BUFFER_E;
10199:../src/src/tls.c **** 
10200:../src/src/tls.c ****         /* Ensure the index of PSK identity chosen by server is 0.
10201:../src/src/tls.c ****          * Index is plus one to handle 'not set' value of 0.
10202:../src/src/tls.c ****          */
10203:../src/src/tls.c ****         if (ssl->options.pskIdIndex != 1)
10204:../src/src/tls.c ****             return PSK_KEY_ERROR;
10205:../src/src/tls.c **** 
10206:../src/src/tls.c ****         if (ssl->options.side == WOLFSSL_CLIENT_END) {
10207:../src/src/tls.c ****             /* the extension from server comes in */
10208:../src/src/tls.c ****             ssl->earlyDataStatus = WOLFSSL_EARLY_DATA_ACCEPTED;
10209:../src/src/tls.c ****         }
10210:../src/src/tls.c **** 
10211:../src/src/tls.c ****         return TLSX_EarlyData_Use(ssl, 1);
10212:../src/src/tls.c ****     }
10213:../src/src/tls.c ****     if (msgType == session_ticket) {
10214:../src/src/tls.c ****         word32 maxSz;
10215:../src/src/tls.c **** 
10216:../src/src/tls.c ****         if (length != OPAQUE32_LEN)
10217:../src/src/tls.c ****             return BUFFER_E;
10218:../src/src/tls.c ****         ato32(input, &maxSz);
10219:../src/src/tls.c **** 
10220:../src/src/tls.c ****         ssl->session->maxEarlyDataSz = maxSz;
10221:../src/src/tls.c ****         return 0;
10222:../src/src/tls.c ****     }
10223:../src/src/tls.c **** 
10224:../src/src/tls.c ****     return SANITY_MSG_E;
10225:../src/src/tls.c **** }
10226:../src/src/tls.c **** 
10227:../src/src/tls.c **** /* Use the data to create a new Early Data object in the extensions.
10228:../src/src/tls.c ****  *
10229:../src/src/tls.c ****  * ssl    The SSL/TLS object.
10230:../src/src/tls.c ****  * maxSz  The maximum early data size.
10231:../src/src/tls.c ****  * returns 0 on success and other values indicate failure.
10232:../src/src/tls.c ****  */
10233:../src/src/tls.c **** int TLSX_EarlyData_Use(WOLFSSL* ssl, word32 maxSz)
10234:../src/src/tls.c **** {
10235:../src/src/tls.c ****     int   ret = 0;
10236:../src/src/tls.c ****     TLSX* extension;
10237:../src/src/tls.c **** 
10238:../src/src/tls.c ****     /* Find the early data extension if it exists. */
10239:../src/src/tls.c ****     extension = TLSX_Find(ssl->extensions, TLSX_EARLY_DATA);
10240:../src/src/tls.c ****     if (extension == NULL) {
10241:../src/src/tls.c ****         /* Push new early data extension. */
10242:../src/src/tls.c ****         ret = TLSX_Push(&ssl->extensions, TLSX_EARLY_DATA, NULL, ssl->heap);
10243:../src/src/tls.c ****         if (ret != 0)
10244:../src/src/tls.c ****             return ret;
10245:../src/src/tls.c **** 
10246:../src/src/tls.c ****         extension = TLSX_Find(ssl->extensions, TLSX_EARLY_DATA);
10247:../src/src/tls.c ****         if (extension == NULL)
10248:../src/src/tls.c ****             return MEMORY_E;
10249:../src/src/tls.c ****     }
10250:../src/src/tls.c **** 
10251:../src/src/tls.c ****     extension->resp = 1;
10252:../src/src/tls.c ****     extension->val  = maxSz;
10253:../src/src/tls.c **** 
10254:../src/src/tls.c ****     return 0;
10255:../src/src/tls.c **** }
10256:../src/src/tls.c **** 
10257:../src/src/tls.c **** #define EDI_GET_SIZE  TLSX_EarlyData_GetSize
10258:../src/src/tls.c **** #define EDI_WRITE     TLSX_EarlyData_Write
10259:../src/src/tls.c **** #define EDI_PARSE     TLSX_EarlyData_Parse
10260:../src/src/tls.c **** 
10261:../src/src/tls.c **** #else
10262:../src/src/tls.c **** 
10263:../src/src/tls.c **** #define EDI_GET_SIZE(a, b)    0
10264:../src/src/tls.c **** #define EDI_WRITE(a, b, c, d) 0
10265:../src/src/tls.c **** #define EDI_PARSE(a, b, c, d) 0
10266:../src/src/tls.c **** 
10267:../src/src/tls.c **** #endif
10268:../src/src/tls.c **** 
10269:../src/src/tls.c **** /******************************************************************************/
10270:../src/src/tls.c **** /* TLS Extensions Framework                                                   */
10271:../src/src/tls.c **** /******************************************************************************/
10272:../src/src/tls.c **** 
10273:../src/src/tls.c **** /** Finds an extension in the provided list. */
10274:../src/src/tls.c **** TLSX* TLSX_Find(TLSX* list, TLSX_Type type)
10275:../src/src/tls.c **** {
 5861                             		.loc 2 10275 1
 5862 0000 7E AA                   		push.l	r10
 5863                             	.LCFI150:
 5864 0002 71 0A F4                		add	#-12, r0, r10
 5865                             	.LCFI151:
 5866 0005 EF A0                   		mov.L	r10, r0
 5867 0007 E7 A1 01                		mov.L	r1, 4[r10]
 5868 000a E7 A2 02                		mov.L	r2, 8[r10]
10276:../src/src/tls.c ****     TLSX* extension = list;
 5869                             		.loc 2 10276 11
 5870 000d ED A5 01                		mov.L	4[r10], r5
 5871 0010 E3 A5                   		mov.L	r5, [r10]
10277:../src/src/tls.c **** 
10278:../src/src/tls.c ****     while (extension && extension->type != type)
 5872                             		.loc 2 10278 11
 5873 0012 0F                      		bra	.L420
 5874                             	.L422:
10279:../src/src/tls.c ****         extension = extension->next;
 5875                             		.loc 2 10279 19
 5876 0013 EC A5                   		mov.L	[r10], r5
 5877 0015 A9 55                   		mov.L	16[r5], r5
 5878 0017 E3 A5                   		mov.L	r5, [r10]
 5879                             	.L420:
10278:../src/src/tls.c ****         extension = extension->next;
 5880                             		.loc 2 10278 11
 5881 0019 EC A5                   		mov.L	[r10], r5
 5882 001b 61 05                   		cmp	#0, r5
 5883 001d 20 0D                   		beq	.L421
10278:../src/src/tls.c ****         extension = extension->next;
 5884                             		.loc 2 10278 34 discriminator 1
 5885 001f EC A5                   		mov.L	[r10], r5
 5886 0021 EC 55                   		mov.L	[r5], r5
10278:../src/src/tls.c ****         extension = extension->next;
 5887                             		.loc 2 10278 22 discriminator 1
 5888 0023 ED A4 02                		mov.L	8[r10], r4
 5889 0026 47 54                   		cmp	r5, r4
 5890 0028 21 EB                   		bne	.L422
 5891                             	.L421:
10280:../src/src/tls.c **** 
10281:../src/src/tls.c ****     return extension;
 5892                             		.loc 2 10281 12
 5893 002a EC A5                   		mov.L	[r10], r5
10282:../src/src/tls.c **** }
 5894                             		.loc 2 10282 1
 5895 002c EF 51                   		mov.L	r5, r1
 5896 002e 3F AA 04                		rtsd	#16, r10-r10
 5897                             	.LFE100:
 5899                             		.section	.text.TLSX_Remove,"ax",@progbits
 5900                             		.global	_TLSX_Remove
 5902                             	_TLSX_Remove:
 5903                             	.LFB101:
10283:../src/src/tls.c **** 
10284:../src/src/tls.c **** /** Remove an extension. */
10285:../src/src/tls.c **** void TLSX_Remove(TLSX** list, TLSX_Type type, void* heap)
10286:../src/src/tls.c **** {
 5904                             		.loc 2 10286 1
 5905 0000 7E AA                   		push.l	r10
 5906                             	.LCFI152:
 5907 0002 71 0A EC                		add	#-20, r0, r10
 5908                             	.LCFI153:
 5909 0005 EF A0                   		mov.L	r10, r0
 5910 0007 E7 A1 02                		mov.L	r1, 8[r10]
 5911 000a E7 A2 03                		mov.L	r2, 12[r10]
 5912 000d E7 A3 04                		mov.L	r3, 16[r10]
10287:../src/src/tls.c ****     TLSX* extension = *list;
 5913                             		.loc 2 10287 11
 5914 0010 ED A5 02                		mov.L	8[r10], r5
 5915 0013 EC 55                   		mov.L	[r5], r5
 5916 0015 E3 A5                   		mov.L	r5, [r10]
10288:../src/src/tls.c ****     TLSX** next = list;
 5917                             		.loc 2 10288 12
 5918 0017 ED A5 02                		mov.L	8[r10], r5
 5919 001a E7 A5 01                		mov.L	r5, 4[r10]
10289:../src/src/tls.c **** 
10290:../src/src/tls.c ****     while (extension && extension->type != type) {
 5920                             		.loc 2 10290 11
 5921 001d 2E 10                   		bra	.L425
 5922                             	.L427:
10291:../src/src/tls.c ****         next = &extension->next;
 5923                             		.loc 2 10291 14
 5924 001f EC A5                   		mov.L	[r10], r5
 5925 0021 71 55 10                		add	#16, r5
 5926 0024 E7 A5 01                		mov.L	r5, 4[r10]
10292:../src/src/tls.c ****         extension = extension->next;
 5927                             		.loc 2 10292 19
 5928 0027 EC A5                   		mov.L	[r10], r5
 5929 0029 A9 55                   		mov.L	16[r5], r5
 5930 002b E3 A5                   		mov.L	r5, [r10]
 5931                             	.L425:
10290:../src/src/tls.c ****         next = &extension->next;
 5932                             		.loc 2 10290 11
 5933 002d EC A5                   		mov.L	[r10], r5
 5934 002f 61 05                   		cmp	#0, r5
 5935 0031 20 0D                   		beq	.L426
10290:../src/src/tls.c ****         next = &extension->next;
 5936                             		.loc 2 10290 34 discriminator 1
 5937 0033 EC A5                   		mov.L	[r10], r5
 5938 0035 EC 55                   		mov.L	[r5], r5
10290:../src/src/tls.c ****         next = &extension->next;
 5939                             		.loc 2 10290 22 discriminator 1
 5940 0037 ED A4 03                		mov.L	12[r10], r4
 5941 003a 47 54                   		cmp	r5, r4
 5942 003c 21 E3                   		bne	.L427
 5943                             	.L426:
10293:../src/src/tls.c ****     }
10294:../src/src/tls.c **** 
10295:../src/src/tls.c ****     if (extension) {
 5944                             		.loc 2 10295 8
 5945 003e EC A5                   		mov.L	[r10], r5
 5946 0040 61 05                   		cmp	#0, r5
 5947 0042 20 19                   		beq	.L429
10296:../src/src/tls.c ****         *next = extension->next;
 5948                             		.loc 2 10296 26
 5949 0044 EC A5                   		mov.L	[r10], r5
 5950 0046 A9 54                   		mov.L	16[r5], r4
 5951                             		.loc 2 10296 15
 5952 0048 ED A5 01                		mov.L	4[r10], r5
 5953 004b E3 54                   		mov.L	r4, [r5]
10297:../src/src/tls.c ****         extension->next = NULL;
 5954                             		.loc 2 10297 25
 5955 004d EC A5                   		mov.L	[r10], r5
 5956 004f 3E 54 00                		mov.L	#0, 16[r5]
10298:../src/src/tls.c ****         TLSX_FreeAll(extension, heap);
 5957                             		.loc 2 10298 9
 5958 0052 ED A2 04                		mov.L	16[r10], r2
 5959 0055 EC A1                   		mov.L	[r10], r1
 5960 0057 05 00 00 00             		bsr	_TLSX_FreeAll
 5961                             	.L429:
10299:../src/src/tls.c ****     }
10300:../src/src/tls.c **** }
 5962                             		.loc 2 10300 1
 5963 005b 03                      		nop
 5964 005c 3F AA 06                		rtsd	#24, r10-r10
 5965                             	.LFE101:
 5967                             		.section	.text.TLSX_FreeAll,"ax",@progbits
 5968                             		.global	_TLSX_FreeAll
 5970                             	_TLSX_FreeAll:
 5971                             	.LFB102:
10301:../src/src/tls.c **** 
10302:../src/src/tls.c **** /** Releases all extensions in the provided list. */
10303:../src/src/tls.c **** void TLSX_FreeAll(TLSX* list, void* heap)
10304:../src/src/tls.c **** {
 5972                             		.loc 2 10304 1
 5973 0000 7E AA                   		push.l	r10
 5974                             	.LCFI154:
 5975 0002 71 0A F0                		add	#-16, r0, r10
 5976                             	.LCFI155:
 5977 0005 EF A0                   		mov.L	r10, r0
 5978 0007 E7 A1 02                		mov.L	r1, 8[r10]
 5979 000a E7 A2 03                		mov.L	r2, 12[r10]
10305:../src/src/tls.c ****     TLSX* extension;
10306:../src/src/tls.c **** 
10307:../src/src/tls.c ****     while ((extension = list)) {
 5980                             		.loc 2 10307 11
 5981 000d 38 AD 00                		bra	.L431
 5982                             	.L448:
10308:../src/src/tls.c ****         list = extension->next;
 5983                             		.loc 2 10308 14
 5984 0010 EC A5                   		mov.L	[r10], r5
 5985 0012 A9 55                   		mov.L	16[r5], r5
 5986 0014 E7 A5 02                		mov.L	r5, 8[r10]
10309:../src/src/tls.c **** 
10310:../src/src/tls.c ****         switch (extension->type) {
 5987                             		.loc 2 10310 26
 5988 0017 EC A5                   		mov.L	[r10], r5
 5989 0019 EC 55                   		mov.L	[r5], r5
 5990                             		.loc 2 10310 9
 5991 001b 61 B5                   		cmp	#11, r5
 5992 001d 20 59                   		beq	.L432
 5993 001f 61 B5                   		cmp	#11, r5
 5994 0021 24 1E                   		bgtu	.L433
 5995 0023 61 45                   		cmp	#4, r5
 5996 0025 20 6F                   		beq	.L449
 5997 0027 61 45                   		cmp	#4, r5
 5998 0029 24 0C                   		bgtu	.L435
 5999 002b 61 15                   		cmp	#1, r5
 6000 002d 20 6A                   		beq	.L450
 6001 002f 61 35                   		cmp	#3, r5
 6002 0031 20 69                   		beq	.L451
10311:../src/src/tls.c **** 
10312:../src/src/tls.c **** #ifdef HAVE_SNI
10313:../src/src/tls.c ****             case TLSX_SERVER_NAME:
10314:../src/src/tls.c ****                 SNI_FREE_ALL((SNI*)extension->data, heap);
10315:../src/src/tls.c ****                 break;
10316:../src/src/tls.c **** #endif
10317:../src/src/tls.c **** 
10318:../src/src/tls.c ****             case TLSX_TRUSTED_CA_KEYS:
10319:../src/src/tls.c ****                 TCA_FREE_ALL((TCA*)extension->data, heap);
10320:../src/src/tls.c ****                 break;
10321:../src/src/tls.c **** 
10322:../src/src/tls.c ****             case TLSX_MAX_FRAGMENT_LENGTH:
10323:../src/src/tls.c ****                 MFL_FREE_ALL(extension->data, heap);
10324:../src/src/tls.c ****                 break;
10325:../src/src/tls.c **** 
10326:../src/src/tls.c ****             case TLSX_EXTENDED_MASTER_SECRET:
10327:../src/src/tls.c ****             case TLSX_TRUNCATED_HMAC:
10328:../src/src/tls.c ****                 /* Nothing to do. */
10329:../src/src/tls.c ****                 break;
10330:../src/src/tls.c **** 
10331:../src/src/tls.c ****             case TLSX_SUPPORTED_GROUPS:
10332:../src/src/tls.c ****                 EC_FREE_ALL((SupportedCurve*)extension->data, heap);
10333:../src/src/tls.c ****                 break;
10334:../src/src/tls.c **** 
10335:../src/src/tls.c ****             case TLSX_EC_POINT_FORMATS:
10336:../src/src/tls.c ****                 PF_FREE_ALL((PointFormat*)extension->data, heap);
10337:../src/src/tls.c ****                 break;
10338:../src/src/tls.c **** 
10339:../src/src/tls.c ****             case TLSX_STATUS_REQUEST:
10340:../src/src/tls.c ****                 CSR_FREE_ALL((CertificateStatusRequest*)extension->data, heap);
10341:../src/src/tls.c ****                 break;
10342:../src/src/tls.c **** 
10343:../src/src/tls.c ****             case TLSX_STATUS_REQUEST_V2:
10344:../src/src/tls.c ****                 CSR2_FREE_ALL((CertificateStatusRequestItemV2*)extension->data,
10345:../src/src/tls.c ****                         heap);
10346:../src/src/tls.c ****                 break;
10347:../src/src/tls.c **** 
10348:../src/src/tls.c ****             case TLSX_RENEGOTIATION_INFO:
10349:../src/src/tls.c ****                 SCR_FREE_ALL(extension->data, heap);
10350:../src/src/tls.c ****                 break;
10351:../src/src/tls.c **** 
10352:../src/src/tls.c ****             case TLSX_SESSION_TICKET:
10353:../src/src/tls.c ****                 WOLF_STK_FREE(extension->data, heap);
10354:../src/src/tls.c ****                 break;
10355:../src/src/tls.c **** 
10356:../src/src/tls.c ****             case TLSX_APPLICATION_LAYER_PROTOCOL:
10357:../src/src/tls.c ****                 ALPN_FREE_ALL((ALPN*)extension->data, heap);
10358:../src/src/tls.c ****                 break;
10359:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
10360:../src/src/tls.c ****             case TLSX_SIGNATURE_ALGORITHMS:
10361:../src/src/tls.c ****                 break;
10362:../src/src/tls.c **** #endif
10363:../src/src/tls.c **** #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
10364:../src/src/tls.c ****             case TLSX_ENCRYPT_THEN_MAC:
10365:../src/src/tls.c ****                 break;
10366:../src/src/tls.c **** #endif
10367:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
10368:../src/src/tls.c ****             case TLSX_SUPPORTED_VERSIONS:
10369:../src/src/tls.c ****                 break;
10370:../src/src/tls.c **** 
10371:../src/src/tls.c ****     #ifdef WOLFSSL_SEND_HRR_COOKIE
10372:../src/src/tls.c ****             case TLSX_COOKIE:
10373:../src/src/tls.c ****                 CKE_FREE_ALL((Cookie*)extension->data, heap);
10374:../src/src/tls.c ****                 break;
10375:../src/src/tls.c ****     #endif
10376:../src/src/tls.c **** 
10377:../src/src/tls.c ****     #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
10378:../src/src/tls.c ****             case TLSX_PRE_SHARED_KEY:
10379:../src/src/tls.c ****                 PSK_FREE_ALL((PreSharedKey*)extension->data, heap);
10380:../src/src/tls.c ****                 break;
10381:../src/src/tls.c **** 
10382:../src/src/tls.c ****             case TLSX_PSK_KEY_EXCHANGE_MODES:
10383:../src/src/tls.c ****                 break;
10384:../src/src/tls.c ****     #endif
10385:../src/src/tls.c **** 
10386:../src/src/tls.c ****     #ifdef WOLFSSL_EARLY_DATA
10387:../src/src/tls.c ****             case TLSX_EARLY_DATA:
10388:../src/src/tls.c ****                 break;
10389:../src/src/tls.c ****     #endif
10390:../src/src/tls.c **** 
10391:../src/src/tls.c ****     #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
10392:../src/src/tls.c ****             case TLSX_POST_HANDSHAKE_AUTH:
10393:../src/src/tls.c ****                 break;
10394:../src/src/tls.c ****     #endif
10395:../src/src/tls.c **** 
10396:../src/src/tls.c ****     #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
10397:../src/src/tls.c ****             case TLSX_SIGNATURE_ALGORITHMS_CERT:
10398:../src/src/tls.c ****                 break;
10399:../src/src/tls.c ****     #endif
10400:../src/src/tls.c **** 
10401:../src/src/tls.c ****             case TLSX_KEY_SHARE:
10402:../src/src/tls.c ****                 KS_FREE_ALL((KeyShareEntry*)extension->data, heap);
10403:../src/src/tls.c ****                 break;
10404:../src/src/tls.c **** #endif
10405:../src/src/tls.c **** #ifdef WOLFSSL_SRTP
10406:../src/src/tls.c ****             case TLSX_USE_SRTP:
10407:../src/src/tls.c ****                 SRTP_FREE((TlsxSrtp*)extension->data, heap);
10408:../src/src/tls.c ****                 break;
10409:../src/src/tls.c **** #endif
10410:../src/src/tls.c **** 
10411:../src/src/tls.c ****             default:
10412:../src/src/tls.c ****                 break;
 6003                             		.loc 2 10412 17
 6004 0033 2E 75                   		bra	.L447
 6005                             	.L435:
10310:../src/src/tls.c **** 
 6006                             		.loc 2 10310 9
 6007 0035 61 55                   		cmp	#5, r5
 6008 0037 20 4E                   		beq	.L439
 6009 0039 61 A5                   		cmp	#10, r5
 6010 003b 20 2C                   		beq	.L440
 6011                             		.loc 2 10412 17
 6012 003d 2E 6B                   		bra	.L447
 6013                             	.L433:
10310:../src/src/tls.c **** 
 6014                             		.loc 2 10310 9
 6015 003f 75 55 11                		cmp	#17, r5
 6016 0042 20 5B                   		beq	.L452
 6017 0044 75 55 11                		cmp	#17, r5
 6018 0047 24 0D                   		bgtu	.L442
 6019 0049 61 D5                   		cmp	#13, r5
 6020 004b 20 54                   		beq	.L453
 6021 004d 75 55 10                		cmp	#16, r5
 6022 0050 20 51                   		beq	.L454
 6023                             		.loc 2 10412 17
 6024 0052 2E 56                   		bra	.L447
 6025                             	.L442:
10310:../src/src/tls.c **** 
 6026                             		.loc 2 10310 9
 6027 0054 75 55 23                		cmp	#35, r5
 6028 0057 20 4C                   		beq	.L455
 6029 0059 77 05 01 FF 00          		cmp	#0xff01, r5
 6030 005e 20 48                   		beq	.L456
 6031 0060 75 55 17                		cmp	#23, r5
 6032 0063 20 31                   		beq	.L449
 6033                             		.loc 2 10412 17
 6034 0065 2E 43                   		bra	.L447
 6035                             	.L440:
10332:../src/src/tls.c ****                 break;
 6036                             		.loc 2 10332 55
 6037 0067 EC A5                   		mov.L	[r10], r5
 6038 0069 A8 5D                   		mov.L	4[r5], r5
10332:../src/src/tls.c ****                 break;
 6039                             		.loc 2 10332 17
 6040 006b ED A2 03                		mov.L	12[r10], r2
 6041 006e EF 51                   		mov.L	r5, r1
 6042 0070 05 00 00 00             		bsr	_TLSX_SupportedCurve_FreeAll
10333:../src/src/tls.c **** 
 6043                             		.loc 2 10333 17
 6044 0074 2E 34                   		bra	.L447
 6045                             	.L432:
10336:../src/src/tls.c ****                 break;
 6046                             		.loc 2 10336 52
 6047 0076 EC A5                   		mov.L	[r10], r5
 6048 0078 A8 5D                   		mov.L	4[r5], r5
10336:../src/src/tls.c ****                 break;
 6049                             		.loc 2 10336 17
 6050 007a ED A2 03                		mov.L	12[r10], r2
 6051 007d EF 51                   		mov.L	r5, r1
 6052 007f 05 00 00 00             		bsr	_TLSX_PointFormat_FreeAll
10337:../src/src/tls.c **** 
 6053                             		.loc 2 10337 17
 6054 0083 2E 25                   		bra	.L447
 6055                             	.L439:
10340:../src/src/tls.c ****                 break;
 6056                             		.loc 2 10340 66
 6057 0085 EC A5                   		mov.L	[r10], r5
 6058 0087 A8 5D                   		mov.L	4[r5], r5
10340:../src/src/tls.c ****                 break;
 6059                             		.loc 2 10340 17
 6060 0089 ED A2 03                		mov.L	12[r10], r2
 6061 008c EF 51                   		mov.L	r5, r1
 6062 008e 05 00 00 00             		bsr	_TLSX_CSR_Free
10341:../src/src/tls.c **** 
 6063                             		.loc 2 10341 17
 6064 0092 2E 16                   		bra	.L447
 6065                             	.L449:
10329:../src/src/tls.c **** 
 6066                             		.loc 2 10329 17
 6067 0094 03                      		nop
 6068 0095 2E 13                   		bra	.L447
 6069                             	.L450:
10324:../src/src/tls.c **** 
 6070                             		.loc 2 10324 17
 6071 0097 03                      		nop
 6072 0098 2E 10                   		bra	.L447
 6073                             	.L451:
10320:../src/src/tls.c **** 
 6074                             		.loc 2 10320 17
 6075 009a 03                      		nop
 6076 009b 2E 0D                   		bra	.L447
 6077                             	.L452:
10346:../src/src/tls.c **** 
 6078                             		.loc 2 10346 17
 6079 009d 03                      		nop
 6080 009e 0A                      		bra	.L447
 6081                             	.L453:
10361:../src/src/tls.c **** #endif
 6082                             		.loc 2 10361 17
 6083 009f 03                      		nop
 6084 00a0 08                      		bra	.L447
 6085                             	.L454:
10358:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
 6086                             		.loc 2 10358 17
 6087 00a1 03                      		nop
 6088 00a2 0E                      		bra	.L447
 6089                             	.L455:
10354:../src/src/tls.c **** 
 6090                             		.loc 2 10354 17
 6091 00a3 03                      		nop
 6092 00a4 2E 04                   		bra	.L447
 6093                             	.L456:
10350:../src/src/tls.c **** 
 6094                             		.loc 2 10350 17
 6095 00a6 03                      		nop
 6096 00a7 03                      		.balign 8,3,1
 6097                             	.L447:
 6098                             	.LBB18:
10413:../src/src/tls.c ****         }
10414:../src/src/tls.c **** 
10415:../src/src/tls.c ****         XFREE(extension, heap, DYNAMIC_TYPE_TLSX);
 6099                             		.loc 2 10415 9
 6100 00a8 EC A5                   		mov.L	[r10], r5
 6101 00aa E7 A5 01                		mov.L	r5, 4[r10]
 6102 00ad ED A5 01                		mov.L	4[r10], r5
 6103 00b0 61 05                   		cmp	#0, r5
 6104 00b2 10                      		beq	.L431
 6105                             		.loc 2 10415 9 is_stmt 0 discriminator 1
 6106 00b3 ED A1 01                		mov.L	4[r10], r1
 6107 00b6 05 00 00 00             		bsr	_wolfSSL_Free
 6108                             	.L431:
 6109                             	.LBE18:
10307:../src/src/tls.c ****         list = extension->next;
 6110                             		.loc 2 10307 23 is_stmt 1
 6111 00ba ED A5 02                		mov.L	8[r10], r5
 6112 00bd E3 A5                   		mov.L	r5, [r10]
10307:../src/src/tls.c ****         list = extension->next;
 6113                             		.loc 2 10307 11
 6114 00bf EC A5                   		mov.L	[r10], r5
 6115 00c1 61 05                   		cmp	#0, r5
 6116 00c3 3B 4D FF                		bne	.L448
10416:../src/src/tls.c ****     }
10417:../src/src/tls.c **** 
10418:../src/src/tls.c ****     (void)heap;
10419:../src/src/tls.c **** }
 6117                             		.loc 2 10419 1
 6118 00c6 03                      		nop
 6119 00c7 3F AA 05                		rtsd	#20, r10-r10
 6120                             	.LFE102:
 6122 00ca 74 10 01 00 00 00       		.section	.text.TLSX_SupportExtensions,"ax",@progbits
 6123                             		.global	_TLSX_SupportExtensions
 6125                             	_TLSX_SupportExtensions:
 6126                             	.LFB103:
10420:../src/src/tls.c **** 
10421:../src/src/tls.c **** /** Checks if the tls extensions are supported based on the protocol version. */
10422:../src/src/tls.c **** int TLSX_SupportExtensions(WOLFSSL* ssl) {
 6127                             		.loc 2 10422 42
 6128 0000 7E AA                   		push.l	r10
 6129                             	.LCFI156:
 6130 0002 71 0A FC                		add	#-4, r0, r10
 6131                             	.LCFI157:
 6132 0005 EF A0                   		mov.L	r10, r0
 6133 0007 E3 A1                   		mov.L	r1, [r10]
10423:../src/src/tls.c ****     return ssl && (IsTLS(ssl) || ssl->version.major == DTLS_MAJOR);
 6134                             		.loc 2 10423 16
 6135 0009 EC A5                   		mov.L	[r10], r5
 6136 000b 61 05                   		cmp	#0, r5
 6137 000d 20 1D                   		beq	.L458
 6138                             		.loc 2 10423 20 discriminator 1
 6139 000f EC A1                   		mov.L	[r10], r1
 6140 0011 05 00 00 00             		bsr	_IsTLS
 6141 0015 EF 15                   		mov.L	r1, r5
 6142                             		.loc 2 10423 16 discriminator 1
 6143 0017 61 05                   		cmp	#0, r5
 6144 0019 21 0E                   		bne	.L459
 6145                             		.loc 2 10423 46 discriminator 4
 6146 001b EC A5                   		mov.L	[r10], r5
 6147 001d CE 55 60 01             		mov.B	352[r5], r5
 6148                             		.loc 2 10423 31 discriminator 4
 6149 0021 5B 55                   		movu.B	r5, r5
 6150 0023 75 55 FE                		cmp	#0xfe, r5
 6151 0026 1C                      		bne	.L458
 6152                             	.L459:
 6153                             		.loc 2 10423 16 discriminator 5
 6154 0027 66 15                   		mov.L	#1, r5
 6155 0029 0B                      		bra	.L461
 6156                             	.L458:
 6157                             		.loc 2 10423 16 is_stmt 0 discriminator 6
 6158 002a 66 05                   		mov.L	#0, r5
 6159                             	.L461:
10424:../src/src/tls.c **** }
 6160                             		.loc 2 10424 1 is_stmt 1 discriminator 9
 6161 002c EF 51                   		mov.L	r5, r1
 6162 002e 3F AA 02                		rtsd	#8, r10-r10
 6163                             	.LFE103:
 6165                             		.section	.text.TLSX_GetSize,"ax",@progbits
 6167                             	_TLSX_GetSize:
 6168                             	.LFB104:
10425:../src/src/tls.c **** 
10426:../src/src/tls.c **** /** Tells the buffered size of the extensions in a list. */
10427:../src/src/tls.c **** static int TLSX_GetSize(TLSX* list, byte* semaphore, byte msgType,
10428:../src/src/tls.c ****                         word16* pLength)
10429:../src/src/tls.c **** {
 6169                             		.loc 2 10429 1
 6170 0000 6E 6A                   		pushm	r6-r10
 6171                             	.LCFI158:
 6172 0002 71 0A E0                		add	#-32, r0, r10
 6173                             	.LCFI159:
 6174 0005 EF A0                   		mov.L	r10, r0
 6175 0007 E7 A1 04                		mov.L	r1, 16[r10]
 6176 000a E7 A2 05                		mov.L	r2, 20[r10]
 6177 000d C7 A3 18                		mov.B	r3, 24[r10]
 6178 0010 E7 A4 07                		mov.L	r4, 28[r10]
10430:../src/src/tls.c ****     int    ret = 0;
 6179                             		.loc 2 10430 12
 6180 0013 F9 A6 01 00             		mov.L	#0, 4[r10]
10431:../src/src/tls.c ****     TLSX*  extension;
10432:../src/src/tls.c ****     word16 length = 0;
 6181                             		.loc 2 10432 12
 6182 0017 F8 A5 00                		mov.W	#0, [r10]
10433:../src/src/tls.c ****     byte   isRequest = (msgType == client_hello ||
 6183                             		.loc 2 10433 49
 6184 001a 59 A5 18                		movu.B	24[r10], r5
 6185 001d 61 15                   		cmp	#1, r5
 6186 001f 17                      		beq	.L463
 6187                             		.loc 2 10433 49 is_stmt 0 discriminator 2
 6188 0020 59 A5 18                		movu.B	24[r10], r5
 6189 0023 61 D5                   		cmp	#13, r5
 6190 0025 1C                      		bne	.L464
 6191                             	.L463:
 6192                             		.loc 2 10433 49 discriminator 3
 6193 0026 66 15                   		mov.L	#1, r5
 6194 0028 0B                      		bra	.L465
 6195                             	.L464:
 6196                             		.loc 2 10433 49 discriminator 4
 6197 0029 66 05                   		mov.L	#0, r5
 6198                             	.L465:
 6199                             		.loc 2 10433 12 is_stmt 1 discriminator 6
 6200 002b C7 A5 08                		mov.B	r5, 8[r10]
10434:../src/src/tls.c ****                         msgType == certificate_request);
10435:../src/src/tls.c **** 
10436:../src/src/tls.c ****     while ((extension = list)) {
 6201                             		.loc 2 10436 11 discriminator 6
 6202 002e 38 6E 01                		bra	.L466
 6203                             	.L486:
10437:../src/src/tls.c ****         list = extension->next;
 6204                             		.loc 2 10437 14
 6205 0031 ED A5 03                		mov.L	12[r10], r5
 6206 0034 A9 55                   		mov.L	16[r5], r5
 6207 0036 E7 A5 04                		mov.L	r5, 16[r10]
10438:../src/src/tls.c **** 
10439:../src/src/tls.c ****         /* only extensions marked as response are sent back to the client. */
10440:../src/src/tls.c ****         if (!isRequest && !extension->resp)
 6208                             		.loc 2 10440 12
 6209 0039 59 A5 08                		movu.B	8[r10], r5
 6210 003c 61 05                   		cmp	#0, r5
 6211 003e 21 0F                   		bne	.L467
 6212                             		.loc 2 10440 37 discriminator 1
 6213 0040 ED A5 03                		mov.L	12[r10], r5
 6214 0043 8B 55                   		mov.B	12[r5], r5
 6215                             		.loc 2 10440 24 discriminator 1
 6216 0045 5B 55                   		movu.B	r5, r5
 6217 0047 61 05                   		cmp	#0, r5
 6218 0049 1C                      		bne	.L467
10441:../src/src/tls.c ****             continue; /* skip! */
 6219                             		.loc 2 10441 13
 6220 004a 38 52 01                		bra	.L466
 6221                             	.L467:
10442:../src/src/tls.c **** 
10443:../src/src/tls.c ****         /* ssl level extensions are expected to override ctx level ones. */
10444:../src/src/tls.c ****         if (!IS_OFF(semaphore, TLSX_ToSemaphore(extension->type)))
 6222                             		.loc 2 10444 14
 6223 004d ED A5 03                		mov.L	12[r10], r5
 6224 0050 EC 55                   		mov.L	[r5], r5
 6225 0052 DF 51                   		mov.W	r5, r1
 6226 0054 05 00 00 00             		bsr	_TLSX_ToSemaphore
 6227 0058 EF 15                   		mov.L	r1, r5
 6228 005a 5F 55                   		movu.W	r5, r5
 6229 005c 68 35                   		shlr	#3, r5
 6230 005e 5F 55                   		movu.W	r5, r5
 6231 0060 ED A4 05                		mov.L	20[r10], r4
 6232 0063 4B 45                   		add	r4, r5
 6233 0065 CC 56                   		mov.B	[r5], r6
 6234 0067 ED A5 03                		mov.L	12[r10], r5
 6235 006a EC 55                   		mov.L	[r5], r5
 6236 006c DF 51                   		mov.W	r5, r1
 6237 006e 05 00 00 00             		bsr	_TLSX_ToSemaphore
 6238 0072 EF 15                   		mov.L	r1, r5
 6239 0074 5F 55                   		movu.W	r5, r5
 6240 0076 64 75                   		and	#7, r5
 6241 0078 66 14                   		mov.L	#1, r4
 6242 007a EF 47                   		mov.L	r4, r7
 6243 007c FD 62 57                		shll	r5, r7
 6244 007f EF 75                   		mov.L	r7, r5
 6245                             		.loc 2 10444 13
 6246 0081 53 65                   		and	r6, r5
 6247                             		.loc 2 10444 12
 6248 0083 5B 55                   		movu.B	r5, r5
 6249 0085 61 05                   		cmp	#0, r5
 6250 0087 14                      		beq	.L468
10445:../src/src/tls.c ****             continue; /* skip! */
 6251                             		.loc 2 10445 13
 6252 0088 38 14 01                		bra	.L466
 6253                             	.L468:
10446:../src/src/tls.c **** 
10447:../src/src/tls.c ****         /* extension type + extension data length. */
10448:../src/src/tls.c ****         length += HELLO_EXT_TYPE_SZ + OPAQUE16_LEN;
 6254                             		.loc 2 10448 16
 6255 008b DC A5                   		mov.W	[r10], r5
 6256 008d 62 45                   		add	#4, r5
 6257 008f D3 A5                   		mov.W	r5, [r10]
10449:../src/src/tls.c **** 
10450:../src/src/tls.c ****         switch (extension->type) {
 6258                             		.loc 2 10450 26
 6259 0091 ED A5 03                		mov.L	12[r10], r5
 6260 0094 EC 55                   		mov.L	[r5], r5
 6261                             		.loc 2 10450 9
 6262 0096 61 B5                   		cmp	#11, r5
 6263 0098 20 69                   		beq	.L469
 6264 009a 61 B5                   		cmp	#11, r5
 6265 009c 24 23                   		bgtu	.L470
 6266 009e 61 45                   		cmp	#4, r5
 6267 00a0 3A A9 00                		beq	.L488
 6268 00a3 61 45                   		cmp	#4, r5
 6269 00a5 24 0F                   		bgtu	.L472
 6270 00a7 61 15                   		cmp	#1, r5
 6271 00a9 3A A3 00                		beq	.L489
 6272 00ac 61 35                   		cmp	#3, r5
 6273 00ae 3A A1 00                		beq	.L490
10451:../src/src/tls.c **** 
10452:../src/src/tls.c **** #ifdef HAVE_SNI
10453:../src/src/tls.c ****             case TLSX_SERVER_NAME:
10454:../src/src/tls.c ****                 /* SNI only sends the name on the request. */
10455:../src/src/tls.c ****                 if (isRequest)
10456:../src/src/tls.c ****                     length += SNI_GET_SIZE((SNI*)extension->data);
10457:../src/src/tls.c ****                 break;
10458:../src/src/tls.c **** #endif
10459:../src/src/tls.c **** 
10460:../src/src/tls.c ****             case TLSX_TRUSTED_CA_KEYS:
10461:../src/src/tls.c ****                 /* TCA only sends the list on the request. */
10462:../src/src/tls.c ****                 if (isRequest)
10463:../src/src/tls.c ****                     length += TCA_GET_SIZE((TCA*)extension->data);
10464:../src/src/tls.c ****                 break;
10465:../src/src/tls.c **** 
10466:../src/src/tls.c ****             case TLSX_MAX_FRAGMENT_LENGTH:
10467:../src/src/tls.c ****                 length += MFL_GET_SIZE(extension->data);
10468:../src/src/tls.c ****                 break;
10469:../src/src/tls.c **** 
10470:../src/src/tls.c ****             case TLSX_EXTENDED_MASTER_SECRET:
10471:../src/src/tls.c ****             case TLSX_TRUNCATED_HMAC:
10472:../src/src/tls.c ****                 /* always empty. */
10473:../src/src/tls.c ****                 break;
10474:../src/src/tls.c **** 
10475:../src/src/tls.c ****             case TLSX_SUPPORTED_GROUPS:
10476:../src/src/tls.c ****                 length += EC_GET_SIZE((SupportedCurve*)extension->data);
10477:../src/src/tls.c ****                 break;
10478:../src/src/tls.c **** 
10479:../src/src/tls.c ****             case TLSX_EC_POINT_FORMATS:
10480:../src/src/tls.c ****                 length += PF_GET_SIZE((PointFormat*)extension->data);
10481:../src/src/tls.c ****                 break;
10482:../src/src/tls.c **** 
10483:../src/src/tls.c ****             case TLSX_STATUS_REQUEST:
10484:../src/src/tls.c ****                 length += CSR_GET_SIZE(
10485:../src/src/tls.c ****                          (CertificateStatusRequest*)extension->data, isRequest);
10486:../src/src/tls.c ****                 break;
10487:../src/src/tls.c **** 
10488:../src/src/tls.c ****             case TLSX_STATUS_REQUEST_V2:
10489:../src/src/tls.c ****                 length += CSR2_GET_SIZE(
10490:../src/src/tls.c ****                         (CertificateStatusRequestItemV2*)extension->data,
10491:../src/src/tls.c ****                         isRequest);
10492:../src/src/tls.c ****                 break;
10493:../src/src/tls.c **** 
10494:../src/src/tls.c ****             case TLSX_RENEGOTIATION_INFO:
10495:../src/src/tls.c ****                 length += SCR_GET_SIZE((SecureRenegotiation*)extension->data,
10496:../src/src/tls.c ****                         isRequest);
10497:../src/src/tls.c ****                 break;
10498:../src/src/tls.c **** 
10499:../src/src/tls.c ****             case TLSX_SESSION_TICKET:
10500:../src/src/tls.c ****                 length += WOLF_STK_GET_SIZE((SessionTicket*)extension->data,
10501:../src/src/tls.c ****                         isRequest);
10502:../src/src/tls.c ****                 break;
10503:../src/src/tls.c **** 
10504:../src/src/tls.c ****             case TLSX_APPLICATION_LAYER_PROTOCOL:
10505:../src/src/tls.c ****                 length += ALPN_GET_SIZE((ALPN*)extension->data);
10506:../src/src/tls.c ****                 break;
10507:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
10508:../src/src/tls.c ****             case TLSX_SIGNATURE_ALGORITHMS:
10509:../src/src/tls.c ****                 length += SA_GET_SIZE(extension->data);
10510:../src/src/tls.c ****                 break;
10511:../src/src/tls.c **** #endif
10512:../src/src/tls.c **** #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
10513:../src/src/tls.c ****             case TLSX_ENCRYPT_THEN_MAC:
10514:../src/src/tls.c ****                 ret = ETM_GET_SIZE(msgType, &length);
10515:../src/src/tls.c ****                 break;
10516:../src/src/tls.c **** #endif /* HAVE_ENCRYPT_THEN_MAC */
10517:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
10518:../src/src/tls.c ****             case TLSX_SUPPORTED_VERSIONS:
10519:../src/src/tls.c ****                 ret = SV_GET_SIZE(extension->data, msgType, &length);
10520:../src/src/tls.c ****                 break;
10521:../src/src/tls.c **** 
10522:../src/src/tls.c ****     #ifdef WOLFSSL_SEND_HRR_COOKIE
10523:../src/src/tls.c ****             case TLSX_COOKIE:
10524:../src/src/tls.c ****                 ret = CKE_GET_SIZE((Cookie*)extension->data, msgType, &length);
10525:../src/src/tls.c ****                 break;
10526:../src/src/tls.c ****     #endif
10527:../src/src/tls.c **** 
10528:../src/src/tls.c ****     #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
10529:../src/src/tls.c ****             case TLSX_PRE_SHARED_KEY:
10530:../src/src/tls.c ****                 ret = PSK_GET_SIZE((PreSharedKey*)extension->data, msgType,
10531:../src/src/tls.c ****                                                                        &length);
10532:../src/src/tls.c ****                 break;
10533:../src/src/tls.c **** 
10534:../src/src/tls.c ****             case TLSX_PSK_KEY_EXCHANGE_MODES:
10535:../src/src/tls.c ****                 ret = PKM_GET_SIZE((byte)extension->val, msgType, &length);
10536:../src/src/tls.c ****                 break;
10537:../src/src/tls.c ****     #endif
10538:../src/src/tls.c **** 
10539:../src/src/tls.c ****     #ifdef WOLFSSL_EARLY_DATA
10540:../src/src/tls.c ****             case TLSX_EARLY_DATA:
10541:../src/src/tls.c ****                 ret = EDI_GET_SIZE(msgType, &length);
10542:../src/src/tls.c ****                 break;
10543:../src/src/tls.c ****     #endif
10544:../src/src/tls.c **** 
10545:../src/src/tls.c ****     #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
10546:../src/src/tls.c ****             case TLSX_POST_HANDSHAKE_AUTH:
10547:../src/src/tls.c ****                 ret = PHA_GET_SIZE(msgType, &length);
10548:../src/src/tls.c ****                 break;
10549:../src/src/tls.c ****     #endif
10550:../src/src/tls.c **** 
10551:../src/src/tls.c ****     #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
10552:../src/src/tls.c ****             case TLSX_SIGNATURE_ALGORITHMS_CERT:
10553:../src/src/tls.c ****                 length += SAC_GET_SIZE(extension->data);
10554:../src/src/tls.c ****                 break;
10555:../src/src/tls.c ****     #endif
10556:../src/src/tls.c **** 
10557:../src/src/tls.c ****             case TLSX_KEY_SHARE:
10558:../src/src/tls.c ****                 length += KS_GET_SIZE((KeyShareEntry*)extension->data, msgType);
10559:../src/src/tls.c ****                 break;
10560:../src/src/tls.c **** #endif
10561:../src/src/tls.c **** #ifdef WOLFSSL_SRTP
10562:../src/src/tls.c ****             case TLSX_USE_SRTP:
10563:../src/src/tls.c ****                 length += SRTP_GET_SIZE((TlsxSrtp*)extension->data);
10564:../src/src/tls.c ****                 break;
10565:../src/src/tls.c **** #endif
10566:../src/src/tls.c ****             default:
10567:../src/src/tls.c ****                 break;
 6274                             		.loc 2 10567 17
 6275 00b1 38 A8 00                		bra	.L485
 6276                             	.L472:
10450:../src/src/tls.c **** 
 6277                             		.loc 2 10450 9
 6278 00b4 61 55                   		cmp	#5, r5
 6279 00b6 20 62                   		beq	.L476
 6280 00b8 61 A5                   		cmp	#10, r5
 6281 00ba 20 30                   		beq	.L477
 6282                             		.loc 2 10567 17
 6283 00bc 38 9D 00                		bra	.L485
 6284                             	.L470:
10450:../src/src/tls.c **** 
 6285                             		.loc 2 10450 9
 6286 00bf 75 55 11                		cmp	#17, r5
 6287 00c2 3A 8F 00                		beq	.L491
 6288 00c5 75 55 11                		cmp	#17, r5
 6289 00c8 24 0F                   		bgtu	.L479
 6290 00ca 61 D5                   		cmp	#13, r5
 6291 00cc 20 66                   		beq	.L480
 6292 00ce 75 55 10                		cmp	#16, r5
 6293 00d1 3A 82 00                		beq	.L492
 6294                             		.loc 2 10567 17
 6295 00d4 38 85 00                		bra	.L485
 6296                             	.L479:
10450:../src/src/tls.c **** 
 6297                             		.loc 2 10450 9
 6298 00d7 75 55 23                		cmp	#35, r5
 6299 00da 20 7B                   		beq	.L493
 6300 00dc 77 05 01 FF 00          		cmp	#0xff01, r5
 6301 00e1 20 77                   		beq	.L494
 6302 00e3 75 55 17                		cmp	#23, r5
 6303 00e6 20 63                   		beq	.L488
 6304                             		.loc 2 10567 17
 6305 00e8 2E 71                   		bra	.L485
 6306                             	.L477:
10476:../src/src/tls.c ****                 break;
 6307                             		.loc 2 10476 65
 6308 00ea ED A5 03                		mov.L	12[r10], r5
 6309 00ed A8 5D                   		mov.L	4[r5], r5
10476:../src/src/tls.c ****                 break;
 6310                             		.loc 2 10476 27
 6311 00ef EF 51                   		mov.L	r5, r1
 6312 00f1 05 00 00 00             		bsr	_TLSX_SupportedCurve_GetSize
 6313 00f5 EF 15                   		mov.L	r1, r5
 6314 00f7 DF 54                   		mov.W	r5, r4
10476:../src/src/tls.c ****                 break;
 6315                             		.loc 2 10476 24
 6316 00f9 DC A5                   		mov.W	[r10], r5
 6317 00fb 4B 45                   		add	r4, r5
 6318 00fd D3 A5                   		mov.W	r5, [r10]
10477:../src/src/tls.c **** 
 6319                             		.loc 2 10477 17
 6320 00ff 2E 5A                   		bra	.L485
 6321                             	.L469:
10480:../src/src/tls.c ****                 break;
 6322                             		.loc 2 10480 62
 6323 0101 ED A5 03                		mov.L	12[r10], r5
 6324 0104 A8 5D                   		mov.L	4[r5], r5
10480:../src/src/tls.c ****                 break;
 6325                             		.loc 2 10480 27
 6326 0106 EF 51                   		mov.L	r5, r1
 6327 0108 05 00 00 00             		bsr	_TLSX_PointFormat_GetSize
 6328 010c EF 15                   		mov.L	r1, r5
 6329 010e DF 54                   		mov.W	r5, r4
10480:../src/src/tls.c ****                 break;
 6330                             		.loc 2 10480 24
 6331 0110 DC A5                   		mov.W	[r10], r5
 6332 0112 4B 45                   		add	r4, r5
 6333 0114 D3 A5                   		mov.W	r5, [r10]
10481:../src/src/tls.c **** 
 6334                             		.loc 2 10481 17
 6335 0116 2E 43                   		bra	.L485
 6336                             	.L476:
10485:../src/src/tls.c ****                 break;
 6337                             		.loc 2 10485 62
 6338 0118 ED A5 03                		mov.L	12[r10], r5
 6339 011b A8 5D                   		mov.L	4[r5], r5
10484:../src/src/tls.c ****                          (CertificateStatusRequest*)extension->data, isRequest);
 6340                             		.loc 2 10484 27
 6341 011d CD A2 08                		mov.B	8[r10], r2
 6342 0120 EF 51                   		mov.L	r5, r1
 6343 0122 05 00 00 00             		bsr	_TLSX_CSR_GetSize
 6344 0126 EF 15                   		mov.L	r1, r5
 6345 0128 DF 54                   		mov.W	r5, r4
10484:../src/src/tls.c ****                          (CertificateStatusRequest*)extension->data, isRequest);
 6346                             		.loc 2 10484 24
 6347 012a DC A5                   		mov.W	[r10], r5
 6348 012c 4B 45                   		add	r4, r5
 6349 012e D3 A5                   		mov.W	r5, [r10]
10486:../src/src/tls.c **** 
 6350                             		.loc 2 10486 17
 6351 0130 2E 29                   		bra	.L485
 6352                             	.L480:
10509:../src/src/tls.c ****                 break;
 6353                             		.loc 2 10509 27
 6354 0132 ED A5 03                		mov.L	12[r10], r5
 6355 0135 A8 5D                   		mov.L	4[r5], r5
 6356 0137 EF 51                   		mov.L	r5, r1
 6357 0139 05 00 00 00             		bsr	_TLSX_SignatureAlgorithms_GetSize
 6358 013d EF 15                   		mov.L	r1, r5
 6359 013f DF 54                   		mov.W	r5, r4
10509:../src/src/tls.c ****                 break;
 6360                             		.loc 2 10509 24
 6361 0141 DC A5                   		mov.W	[r10], r5
 6362 0143 4B 45                   		add	r4, r5
 6363 0145 D3 A5                   		mov.W	r5, [r10]
10510:../src/src/tls.c **** #endif
 6364                             		.loc 2 10510 17
 6365 0147 2E 12                   		bra	.L485
 6366                             	.L488:
10473:../src/src/tls.c **** 
 6367                             		.loc 2 10473 17
 6368 0149 03                      		nop
 6369 014a 2E 0F                   		bra	.L485
 6370                             	.L489:
10468:../src/src/tls.c **** 
 6371                             		.loc 2 10468 17
 6372 014c 03                      		nop
 6373 014d 2E 0C                   		bra	.L485
 6374                             	.L490:
10464:../src/src/tls.c **** 
 6375                             		.loc 2 10464 17
 6376 014f 03                      		nop
 6377 0150 09                      		bra	.L485
 6378                             	.L491:
10492:../src/src/tls.c **** 
 6379                             		.loc 2 10492 17
 6380 0151 03                      		nop
 6381 0152 0F                      		bra	.L485
 6382                             	.L492:
10506:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
 6383                             		.loc 2 10506 17
 6384 0153 03                      		nop
 6385 0154 0D                      		bra	.L485
 6386                             	.L493:
10502:../src/src/tls.c **** 
 6387                             		.loc 2 10502 17
 6388 0155 03                      		nop
 6389 0156 2E 03                   		bra	.L485
 6390                             	.L494:
10497:../src/src/tls.c **** 
 6391                             		.loc 2 10497 17
 6392 0158 03                      		nop
 6393                             		.balign 8,3,1
 6394                             	.L485:
10568:../src/src/tls.c ****         }
10569:../src/src/tls.c **** 
10570:../src/src/tls.c ****         /* marks the extension as processed so ctx level */
10571:../src/src/tls.c ****         /* extensions don't overlap with ssl level ones. */
10572:../src/src/tls.c ****         TURN_ON(semaphore, TLSX_ToSemaphore(extension->type));
 6395                             		.loc 2 10572 9
 6396 0159 ED A5 03                		mov.L	12[r10], r5
 6397 015c EC 55                   		mov.L	[r5], r5
 6398 015e DF 51                   		mov.W	r5, r1
 6399 0160 05 00 00 00             		bsr	_TLSX_ToSemaphore
 6400 0164 EF 15                   		mov.L	r1, r5
 6401 0166 5F 55                   		movu.W	r5, r5
 6402 0168 64 75                   		and	#7, r5
 6403 016a 66 14                   		mov.L	#1, r4
 6404 016c EF 47                   		mov.L	r4, r7
 6405 016e FD 62 57                		shll	r5, r7
 6406 0171 EF 75                   		mov.L	r7, r5
 6407 0173 CF 56                   		mov.B	r5, r6
 6408 0175 ED A5 03                		mov.L	12[r10], r5
 6409 0178 EC 55                   		mov.L	[r5], r5
 6410 017a DF 51                   		mov.W	r5, r1
 6411 017c 05 00 00 00             		bsr	_TLSX_ToSemaphore
 6412 0180 EF 15                   		mov.L	r1, r5
 6413 0182 5F 55                   		movu.W	r5, r5
 6414 0184 68 35                   		shlr	#3, r5
 6415 0186 DF 53                   		mov.W	r5, r3
 6416 0188 5F 35                   		movu.W	r3, r5
 6417 018a ED A4 05                		mov.L	20[r10], r4
 6418 018d 4B 45                   		add	r4, r5
 6419 018f CC 54                   		mov.B	[r5], r4
 6420 0191 5F 35                   		movu.W	r3, r5
 6421 0193 ED A3 05                		mov.L	20[r10], r3
 6422 0196 4B 35                   		add	r3, r5
 6423 0198 57 64                   		or	r6, r4
 6424 019a C3 54                   		mov.B	r4, [r5]
 6425                             		.balign 8,3,1
 6426                             	.L466:
10436:../src/src/tls.c ****         list = extension->next;
 6427                             		.loc 2 10436 23
 6428 019c ED A5 04                		mov.L	16[r10], r5
 6429 019f E7 A5 03                		mov.L	r5, 12[r10]
10436:../src/src/tls.c ****         list = extension->next;
 6430                             		.loc 2 10436 11
 6431 01a2 ED A5 03                		mov.L	12[r10], r5
 6432 01a5 61 05                   		cmp	#0, r5
 6433 01a7 3B 8A FE                		bne	.L486
10573:../src/src/tls.c ****     }
10574:../src/src/tls.c **** 
10575:../src/src/tls.c ****     *pLength += length;
 6434                             		.loc 2 10575 14
 6435 01aa ED A5 07                		mov.L	28[r10], r5
 6436 01ad DC 55                   		mov.W	[r5], r5
 6437 01af DC A4                   		mov.W	[r10], r4
 6438 01b1 4B 45                   		add	r4, r5
 6439 01b3 DF 54                   		mov.W	r5, r4
 6440 01b5 ED A5 07                		mov.L	28[r10], r5
 6441 01b8 D3 54                   		mov.W	r4, [r5]
10576:../src/src/tls.c **** 
10577:../src/src/tls.c ****     return ret;
 6442                             		.loc 2 10577 12
 6443 01ba ED A5 01                		mov.L	4[r10], r5
10578:../src/src/tls.c **** }
 6444                             		.loc 2 10578 1
 6445 01bd EF 51                   		mov.L	r5, r1
 6446 01bf 3F 6A 0D                		rtsd	#52, r6-r10
 6447                             	.LFE104:
 6449 01c2 74 10 01 00 00 00       		.section C,"a",@progbits
 6450 0076 00 00                   		.p2align 2
 6451                             	.LC3:
 6452 0078 54 72 75 73 74 65 64 20 		.string	"Trusted CA Indication extension to write"
 6452      43 41 20 49 6E 64 69 63 
 6452      61 74 69 6F 6E 20 65 78 
 6452      74 65 6E 73 69 6F 6E 20 
 6452      74 6F 20 77 72 69 74 65 
 6453                             	.LC4:
 6454 00a1 4D 61 78 20 46 72 61 67 		.string	"Max Fragment Length extension to write"
 6454      6D 65 6E 74 20 4C 65 6E 
 6454      67 74 68 20 65 78 74 65 
 6454      6E 73 69 6F 6E 20 74 6F 
 6454      20 77 72 69 74 65 00 
 6455                             	.LC5:
 6456 00c8 45 78 74 65 6E 64 65 64 		.string	"Extended Master Secret"
 6456      20 4D 61 73 74 65 72 20 
 6456      53 65 63 72 65 74 00 
 6457                             	.LC6:
 6458 00df 54 72 75 6E 63 61 74 65 		.string	"Truncated HMAC extension to write"
 6458      64 20 48 4D 41 43 20 65 
 6458      78 74 65 6E 73 69 6F 6E 
 6458      20 74 6F 20 77 72 69 74 
 6458      65 00 
 6459                             	.LC7:
 6460 0101 53 75 70 70 6F 72 74 65 		.string	"Supported Groups extension to write"
 6460      64 20 47 72 6F 75 70 73 
 6460      20 65 78 74 65 6E 73 69 
 6460      6F 6E 20 74 6F 20 77 72 
 6460      69 74 65 00 
 6461                             	.LC8:
 6462 0125 50 6F 69 6E 74 20 46 6F 		.string	"Point Formats extension to write"
 6462      72 6D 61 74 73 20 65 78 
 6462      74 65 6E 73 69 6F 6E 20 
 6462      74 6F 20 77 72 69 74 65 
 6462      00 
 6463                             	.LC9:
 6464 0146 43 65 72 74 69 66 69 63 		.string	"Certificate Status Request extension to write"
 6464      61 74 65 20 53 74 61 74 
 6464      75 73 20 52 65 71 75 65 
 6464      73 74 20 65 78 74 65 6E 
 6464      73 69 6F 6E 20 74 6F 20 
 6465                             	.LC10:
 6466 0174 43 65 72 74 69 66 69 63 		.string	"Certificate Status Request v2 extension to write"
 6466      61 74 65 20 53 74 61 74 
 6466      75 73 20 52 65 71 75 65 
 6466      73 74 20 76 32 20 65 78 
 6466      74 65 6E 73 69 6F 6E 20 
 6467                             	.LC11:
 6468 01a5 53 65 63 75 72 65 20 52 		.string	"Secure Renegotiation extension to write"
 6468      65 6E 65 67 6F 74 69 61 
 6468      74 69 6F 6E 20 65 78 74 
 6468      65 6E 73 69 6F 6E 20 74 
 6468      6F 20 77 72 69 74 65 00 
 6469                             	.LC12:
 6470 01cd 53 65 73 73 69 6F 6E 20 		.string	"Session Ticket extension to write"
 6470      54 69 63 6B 65 74 20 65 
 6470      78 74 65 6E 73 69 6F 6E 
 6470      20 74 6F 20 77 72 69 74 
 6470      65 00 
 6471                             	.LC13:
 6472 01ef 41 4C 50 4E 20 65 78 74 		.string	"ALPN extension to write"
 6472      65 6E 73 69 6F 6E 20 74 
 6472      6F 20 77 72 69 74 65 00 
 6473                             	.LC14:
 6474 0207 53 69 67 6E 61 74 75 72 		.string	"Signature Algorithms extension to write"
 6474      65 20 41 6C 67 6F 72 69 
 6474      74 68 6D 73 20 65 78 74 
 6474      65 6E 73 69 6F 6E 20 74 
 6474      6F 20 77 72 69 74 65 00 
 6475                             		.section	.text.TLSX_Write,"ax",@progbits
 6477                             	_TLSX_Write:
 6478                             	.LFB105:
10579:../src/src/tls.c **** 
10580:../src/src/tls.c **** /** Writes the extensions of a list in a buffer. */
10581:../src/src/tls.c **** static int TLSX_Write(TLSX* list, byte* output, byte* semaphore,
10582:../src/src/tls.c ****                          byte msgType, word16* pOffset)
10583:../src/src/tls.c **** {
 6479                             		.loc 2 10583 1
 6480 0000 6E 6B                   		pushm	r6-r11
 6481                             	.LCFI160:
 6482 0002 71 0A DC                		add	#-36, r0, r10
 6483                             	.LCFI161:
 6484 0005 EF A0                   		mov.L	r10, r0
 6485 0007 75 46 40                		mov.L	#0x40, r6
 6486 000a 4B A6                   		add	r10, r6
 6487 000c E7 A1 04                		mov.L	r1, 16[r10]
 6488 000f E7 A2 05                		mov.L	r2, 20[r10]
 6489 0012 E7 A3 06                		mov.L	r3, 24[r10]
 6490 0015 C7 A4 1C                		mov.B	r4, 28[r10]
10584:../src/src/tls.c ****     int    ret = 0;
 6491                             		.loc 2 10584 12
 6492 0018 F9 A6 01 00             		mov.L	#0, 4[r10]
10585:../src/src/tls.c ****     TLSX*  extension;
10586:../src/src/tls.c ****     word16 offset = 0;
 6493                             		.loc 2 10586 12
 6494 001c F8 A5 00                		mov.W	#0, [r10]
10587:../src/src/tls.c ****     word16 length_offset = 0;
 6495                             		.loc 2 10587 12
 6496 001f F9 A5 04 00             		mov.W	#0, 8[r10]
10588:../src/src/tls.c ****     byte   isRequest = (msgType == client_hello ||
 6497                             		.loc 2 10588 49
 6498 0023 59 A5 1C                		movu.B	28[r10], r5
 6499 0026 61 15                   		cmp	#1, r5
 6500 0028 17                      		beq	.L496
 6501                             		.loc 2 10588 49 is_stmt 0 discriminator 2
 6502 0029 59 A5 1C                		movu.B	28[r10], r5
 6503 002c 61 D5                   		cmp	#13, r5
 6504 002e 1C                      		bne	.L497
 6505                             	.L496:
 6506                             		.loc 2 10588 49 discriminator 3
 6507 002f 66 15                   		mov.L	#1, r5
 6508 0031 0B                      		bra	.L498
 6509                             	.L497:
 6510                             		.loc 2 10588 49 discriminator 4
 6511 0032 66 05                   		mov.L	#0, r5
 6512                             	.L498:
 6513                             		.loc 2 10588 12 is_stmt 1 discriminator 6
 6514 0034 C7 A5 0A                		mov.B	r5, 10[r10]
10589:../src/src/tls.c ****                         msgType == certificate_request);
10590:../src/src/tls.c **** 
10591:../src/src/tls.c ****     while ((extension = list)) {
 6515                             		.loc 2 10591 11 discriminator 6
 6516 0037 38 49 02                		bra	.L499
 6517                             	.L520:
10592:../src/src/tls.c ****         list = extension->next;
 6518                             		.loc 2 10592 14
 6519 003a ED A5 03                		mov.L	12[r10], r5
 6520 003d A9 55                   		mov.L	16[r5], r5
 6521 003f E7 A5 04                		mov.L	r5, 16[r10]
10593:../src/src/tls.c **** 
10594:../src/src/tls.c ****         /* only extensions marked as response are written in a response. */
10595:../src/src/tls.c ****         if (!isRequest && !extension->resp)
 6522                             		.loc 2 10595 12
 6523 0042 59 A5 0A                		movu.B	10[r10], r5
 6524 0045 61 05                   		cmp	#0, r5
 6525 0047 21 0F                   		bne	.L500
 6526                             		.loc 2 10595 37 discriminator 1
 6527 0049 ED A5 03                		mov.L	12[r10], r5
 6528 004c 8B 55                   		mov.B	12[r5], r5
 6529                             		.loc 2 10595 24 discriminator 1
 6530 004e 5B 55                   		movu.B	r5, r5
 6531 0050 61 05                   		cmp	#0, r5
 6532 0052 1C                      		bne	.L500
10596:../src/src/tls.c ****             continue; /* skip! */
 6533                             		.loc 2 10596 13
 6534 0053 38 2D 02                		bra	.L499
 6535                             	.L500:
10597:../src/src/tls.c **** 
10598:../src/src/tls.c ****         /* ssl level extensions are expected to override ctx level ones. */
10599:../src/src/tls.c ****         if (!IS_OFF(semaphore, TLSX_ToSemaphore(extension->type)))
 6536                             		.loc 2 10599 14
 6537 0056 ED A5 03                		mov.L	12[r10], r5
 6538 0059 EC 55                   		mov.L	[r5], r5
 6539 005b DF 51                   		mov.W	r5, r1
 6540 005d 05 00 00 00             		bsr	_TLSX_ToSemaphore
 6541 0061 EF 15                   		mov.L	r1, r5
 6542 0063 5F 55                   		movu.W	r5, r5
 6543 0065 68 35                   		shlr	#3, r5
 6544 0067 5F 55                   		movu.W	r5, r5
 6545 0069 ED A4 06                		mov.L	24[r10], r4
 6546 006c 4B 45                   		add	r4, r5
 6547 006e CC 5B                   		mov.B	[r5], r11
 6548 0070 ED A5 03                		mov.L	12[r10], r5
 6549 0073 EC 55                   		mov.L	[r5], r5
 6550 0075 DF 51                   		mov.W	r5, r1
 6551 0077 05 00 00 00             		bsr	_TLSX_ToSemaphore
 6552 007b EF 15                   		mov.L	r1, r5
 6553 007d 5F 55                   		movu.W	r5, r5
 6554 007f 64 75                   		and	#7, r5
 6555 0081 66 14                   		mov.L	#1, r4
 6556 0083 EF 47                   		mov.L	r4, r7
 6557 0085 FD 62 57                		shll	r5, r7
 6558 0088 EF 75                   		mov.L	r7, r5
 6559                             		.loc 2 10599 13
 6560 008a 53 B5                   		and	r11, r5
 6561                             		.loc 2 10599 12
 6562 008c 5B 55                   		movu.B	r5, r5
 6563 008e 61 05                   		cmp	#0, r5
 6564 0090 14                      		beq	.L501
10600:../src/src/tls.c ****             continue; /* skip! */
 6565                             		.loc 2 10600 13
 6566 0091 38 EF 01                		bra	.L499
 6567                             	.L501:
10601:../src/src/tls.c **** 
10602:../src/src/tls.c ****         /* writes extension type. */
10603:../src/src/tls.c ****         c16toa(extension->type, output + offset);
 6568                             		.loc 2 10603 25
 6569 0094 ED A5 03                		mov.L	12[r10], r5
 6570 0097 EC 55                   		mov.L	[r5], r5
 6571                             		.loc 2 10603 9
 6572 0099 DF 53                   		mov.W	r5, r3
 6573 009b 5C A5                   		movu.W	[r10], r5
 6574 009d ED A4 05                		mov.L	20[r10], r4
 6575 00a0 4B 45                   		add	r4, r5
 6576 00a2 EF 52                   		mov.L	r5, r2
 6577 00a4 DF 31                   		mov.W	r3, r1
 6578 00a6 05 00 00 00             		bsr	_c16toa
10604:../src/src/tls.c ****         offset += HELLO_EXT_TYPE_SZ + OPAQUE16_LEN;
 6579                             		.loc 2 10604 16
 6580 00aa DC A5                   		mov.W	[r10], r5
 6581 00ac 62 45                   		add	#4, r5
 6582 00ae D3 A5                   		mov.W	r5, [r10]
10605:../src/src/tls.c ****         length_offset = offset;
 6583                             		.loc 2 10605 23
 6584 00b0 DC A5                   		mov.W	[r10], r5
 6585 00b2 D7 A5 04                		mov.W	r5, 8[r10]
10606:../src/src/tls.c **** 
10607:../src/src/tls.c ****         /* extension data should be written internally. */
10608:../src/src/tls.c ****         switch (extension->type) {
 6586                             		.loc 2 10608 26
 6587 00b5 ED A5 03                		mov.L	12[r10], r5
 6588 00b8 EC 55                   		mov.L	[r5], r5
 6589                             		.loc 2 10608 9
 6590 00ba 61 B5                   		cmp	#11, r5
 6591 00bc 3A B4 00                		beq	.L502
 6592 00bf 61 B5                   		cmp	#11, r5
 6593 00c1 24 21                   		bgtu	.L503
 6594 00c3 61 45                   		cmp	#4, r5
 6595 00c5 20 73                   		beq	.L504
 6596 00c7 61 45                   		cmp	#4, r5
 6597 00c9 24 0D                   		bgtu	.L505
 6598 00cb 61 15                   		cmp	#1, r5
 6599 00cd 20 51                   		beq	.L506
 6600 00cf 61 35                   		cmp	#3, r5
 6601 00d1 20 40                   		beq	.L507
10609:../src/src/tls.c **** #ifdef HAVE_SNI
10610:../src/src/tls.c ****             case TLSX_SERVER_NAME:
10611:../src/src/tls.c ****                 if (isRequest) {
10612:../src/src/tls.c ****                     WOLFSSL_MSG("SNI extension to write");
10613:../src/src/tls.c ****                     offset += SNI_WRITE((SNI*)extension->data, output + offset);
10614:../src/src/tls.c ****                 }
10615:../src/src/tls.c ****                 break;
10616:../src/src/tls.c **** #endif
10617:../src/src/tls.c **** 
10618:../src/src/tls.c ****             case TLSX_TRUSTED_CA_KEYS:
10619:../src/src/tls.c ****                 WOLFSSL_MSG("Trusted CA Indication extension to write");
10620:../src/src/tls.c ****                 if (isRequest) {
10621:../src/src/tls.c ****                     offset += TCA_WRITE((TCA*)extension->data, output + offset);
10622:../src/src/tls.c ****                 }
10623:../src/src/tls.c ****                 break;
10624:../src/src/tls.c **** 
10625:../src/src/tls.c ****             case TLSX_MAX_FRAGMENT_LENGTH:
10626:../src/src/tls.c ****                 WOLFSSL_MSG("Max Fragment Length extension to write");
10627:../src/src/tls.c ****                 offset += MFL_WRITE((byte*)extension->data, output + offset);
10628:../src/src/tls.c ****                 break;
10629:../src/src/tls.c **** 
10630:../src/src/tls.c ****             case TLSX_EXTENDED_MASTER_SECRET:
10631:../src/src/tls.c ****                 WOLFSSL_MSG("Extended Master Secret");
10632:../src/src/tls.c ****                 /* always empty. */
10633:../src/src/tls.c ****                 break;
10634:../src/src/tls.c **** 
10635:../src/src/tls.c ****             case TLSX_TRUNCATED_HMAC:
10636:../src/src/tls.c ****                 WOLFSSL_MSG("Truncated HMAC extension to write");
10637:../src/src/tls.c ****                 /* always empty. */
10638:../src/src/tls.c ****                 break;
10639:../src/src/tls.c **** 
10640:../src/src/tls.c ****             case TLSX_SUPPORTED_GROUPS:
10641:../src/src/tls.c ****                 WOLFSSL_MSG("Supported Groups extension to write");
10642:../src/src/tls.c ****                 offset += EC_WRITE((SupportedCurve*)extension->data,
10643:../src/src/tls.c ****                                     output + offset);
10644:../src/src/tls.c ****                 break;
10645:../src/src/tls.c **** 
10646:../src/src/tls.c ****             case TLSX_EC_POINT_FORMATS:
10647:../src/src/tls.c ****                 WOLFSSL_MSG("Point Formats extension to write");
10648:../src/src/tls.c ****                 offset += PF_WRITE((PointFormat*)extension->data,
10649:../src/src/tls.c ****                                     output + offset);
10650:../src/src/tls.c ****                 break;
10651:../src/src/tls.c **** 
10652:../src/src/tls.c ****             case TLSX_STATUS_REQUEST:
10653:../src/src/tls.c ****                 WOLFSSL_MSG("Certificate Status Request extension to write");
10654:../src/src/tls.c ****                 offset += CSR_WRITE((CertificateStatusRequest*)extension->data,
10655:../src/src/tls.c ****                         output + offset, isRequest);
10656:../src/src/tls.c ****                 break;
10657:../src/src/tls.c **** 
10658:../src/src/tls.c ****             case TLSX_STATUS_REQUEST_V2:
10659:../src/src/tls.c ****                 WOLFSSL_MSG("Certificate Status Request v2 extension to write");
10660:../src/src/tls.c ****                 offset += CSR2_WRITE(
10661:../src/src/tls.c ****                         (CertificateStatusRequestItemV2*)extension->data,
10662:../src/src/tls.c ****                         output + offset, isRequest);
10663:../src/src/tls.c ****                 break;
10664:../src/src/tls.c **** 
10665:../src/src/tls.c ****             case TLSX_RENEGOTIATION_INFO:
10666:../src/src/tls.c ****                 WOLFSSL_MSG("Secure Renegotiation extension to write");
10667:../src/src/tls.c ****                 offset += SCR_WRITE((SecureRenegotiation*)extension->data,
10668:../src/src/tls.c ****                         output + offset, isRequest);
10669:../src/src/tls.c ****                 break;
10670:../src/src/tls.c **** 
10671:../src/src/tls.c ****             case TLSX_SESSION_TICKET:
10672:../src/src/tls.c ****                 WOLFSSL_MSG("Session Ticket extension to write");
10673:../src/src/tls.c ****                 offset += WOLF_STK_WRITE((SessionTicket*)extension->data,
10674:../src/src/tls.c ****                         output + offset, isRequest);
10675:../src/src/tls.c ****                 break;
10676:../src/src/tls.c **** 
10677:../src/src/tls.c ****             case TLSX_APPLICATION_LAYER_PROTOCOL:
10678:../src/src/tls.c ****                 WOLFSSL_MSG("ALPN extension to write");
10679:../src/src/tls.c ****                 offset += ALPN_WRITE((ALPN*)extension->data, output + offset);
10680:../src/src/tls.c ****                 break;
10681:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
10682:../src/src/tls.c ****             case TLSX_SIGNATURE_ALGORITHMS:
10683:../src/src/tls.c ****                 WOLFSSL_MSG("Signature Algorithms extension to write");
10684:../src/src/tls.c ****                 offset += SA_WRITE(extension->data, output + offset);
10685:../src/src/tls.c ****                 break;
10686:../src/src/tls.c **** #endif
10687:../src/src/tls.c **** #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
10688:../src/src/tls.c ****             case TLSX_ENCRYPT_THEN_MAC:
10689:../src/src/tls.c ****                 WOLFSSL_MSG("Encrypt-Then-Mac extension to write");
10690:../src/src/tls.c ****                 ret = ETM_WRITE(extension->data, output, msgType, &offset);
10691:../src/src/tls.c ****                 break;
10692:../src/src/tls.c **** #endif /* HAVE_ENCRYPT_THEN_MAC */
10693:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
10694:../src/src/tls.c ****             case TLSX_SUPPORTED_VERSIONS:
10695:../src/src/tls.c ****                 WOLFSSL_MSG("Supported Versions extension to write");
10696:../src/src/tls.c ****                 ret = SV_WRITE(extension->data, output + offset, msgType, &offset);
10697:../src/src/tls.c ****                 break;
10698:../src/src/tls.c **** 
10699:../src/src/tls.c ****     #ifdef WOLFSSL_SEND_HRR_COOKIE
10700:../src/src/tls.c ****             case TLSX_COOKIE:
10701:../src/src/tls.c ****                 WOLFSSL_MSG("Cookie extension to write");
10702:../src/src/tls.c ****                 ret = CKE_WRITE((Cookie*)extension->data, output + offset,
10703:../src/src/tls.c ****                                 msgType, &offset);
10704:../src/src/tls.c ****                 break;
10705:../src/src/tls.c ****     #endif
10706:../src/src/tls.c **** 
10707:../src/src/tls.c ****     #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
10708:../src/src/tls.c ****             case TLSX_PRE_SHARED_KEY:
10709:../src/src/tls.c ****                 WOLFSSL_MSG("Pre-Shared Key extension to write");
10710:../src/src/tls.c ****                 ret = PSK_WRITE((PreSharedKey*)extension->data, output + offset,
10711:../src/src/tls.c ****                                                               msgType, &offset);
10712:../src/src/tls.c ****                 break;
10713:../src/src/tls.c **** 
10714:../src/src/tls.c ****             case TLSX_PSK_KEY_EXCHANGE_MODES:
10715:../src/src/tls.c ****                 WOLFSSL_MSG("PSK Key Exchange Modes extension to write");
10716:../src/src/tls.c ****                 ret = PKM_WRITE((byte)extension->val, output + offset, msgType,
10717:../src/src/tls.c ****                                                                        &offset);
10718:../src/src/tls.c ****                 break;
10719:../src/src/tls.c ****     #endif
10720:../src/src/tls.c **** 
10721:../src/src/tls.c ****     #ifdef WOLFSSL_EARLY_DATA
10722:../src/src/tls.c ****             case TLSX_EARLY_DATA:
10723:../src/src/tls.c ****                 WOLFSSL_MSG("Early Data extension to write");
10724:../src/src/tls.c ****                 ret = EDI_WRITE(extension->val, output + offset, msgType,
10725:../src/src/tls.c ****                                                                        &offset);
10726:../src/src/tls.c ****                 break;
10727:../src/src/tls.c ****     #endif
10728:../src/src/tls.c **** 
10729:../src/src/tls.c ****     #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
10730:../src/src/tls.c ****             case TLSX_POST_HANDSHAKE_AUTH:
10731:../src/src/tls.c ****                 WOLFSSL_MSG("Post-Handshake Authentication extension to write");
10732:../src/src/tls.c ****                 ret = PHA_WRITE(output + offset, msgType, &offset);
10733:../src/src/tls.c ****                 break;
10734:../src/src/tls.c ****     #endif
10735:../src/src/tls.c **** 
10736:../src/src/tls.c ****     #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
10737:../src/src/tls.c ****             case TLSX_SIGNATURE_ALGORITHMS_CERT:
10738:../src/src/tls.c ****                 WOLFSSL_MSG("Signature Algorithms extension to write");
10739:../src/src/tls.c ****                 offset += SAC_WRITE(extension->data, output + offset);
10740:../src/src/tls.c ****                 break;
10741:../src/src/tls.c ****     #endif
10742:../src/src/tls.c **** 
10743:../src/src/tls.c ****             case TLSX_KEY_SHARE:
10744:../src/src/tls.c ****                 WOLFSSL_MSG("Key Share extension to write");
10745:../src/src/tls.c ****                 offset += KS_WRITE((KeyShareEntry*)extension->data,
10746:../src/src/tls.c ****                                                       output + offset, msgType);
10747:../src/src/tls.c ****                 break;
10748:../src/src/tls.c **** #endif
10749:../src/src/tls.c **** #ifdef WOLFSSL_SRTP
10750:../src/src/tls.c ****             case TLSX_USE_SRTP:
10751:../src/src/tls.c ****                 offset += SRTP_WRITE((TlsxSrtp*)extension->data, output+offset);
10752:../src/src/tls.c ****                 break;
10753:../src/src/tls.c **** #endif
10754:../src/src/tls.c ****             default:
10755:../src/src/tls.c ****                 break;
 6602                             		.loc 2 10755 17
 6603 00d3 38 4D 01                		bra	.L519
 6604                             	.L505:
10608:../src/src/tls.c **** #ifdef HAVE_SNI
 6605                             		.loc 2 10608 9
 6606 00d6 61 55                   		cmp	#5, r5
 6607 00d8 3A C3 00                		beq	.L509
 6608 00db 61 A5                   		cmp	#10, r5
 6609 00dd 20 68                   		beq	.L510
 6610                             		.loc 2 10755 17
 6611 00df 38 41 01                		bra	.L519
 6612                             	.L503:
10608:../src/src/tls.c **** #ifdef HAVE_SNI
 6613                             		.loc 2 10608 9
 6614 00e2 75 55 11                		cmp	#17, r5
 6615 00e5 3A E1 00                		beq	.L511
 6616 00e8 75 55 11                		cmp	#17, r5
 6617 00eb 24 10                   		bgtu	.L512
 6618 00ed 61 D5                   		cmp	#13, r5
 6619 00ef 3A 07 01                		beq	.L513
 6620 00f2 75 55 10                		cmp	#16, r5
 6621 00f5 3A F5 00                		beq	.L514
 6622                             		.loc 2 10755 17
 6623 00f8 38 28 01                		bra	.L519
 6624                             	.L512:
10608:../src/src/tls.c **** #ifdef HAVE_SNI
 6625                             		.loc 2 10608 9
 6626 00fb 75 55 23                		cmp	#35, r5
 6627 00fe 3A E0 00                		beq	.L515
 6628 0101 77 05 01 FF 00          		cmp	#0xff01, r5
 6629 0106 3A CC 00                		beq	.L516
 6630 0109 75 55 17                		cmp	#23, r5
 6631 010c 20 1F                   		beq	.L517
 6632                             		.loc 2 10755 17
 6633 010e 38 12 01                		bra	.L519
 6634                             	.L507:
10619:../src/src/tls.c ****                 if (isRequest) {
 6635                             		.loc 2 10619 17
 6636 0111 FB 12 78 00 00 00       		mov.L	#.LC3, r1
 6637 0117 05 00 00 00             		bsr	_WOLFSSL_MSG
10623:../src/src/tls.c **** 
 6638                             		.loc 2 10623 17
 6639 011b 38 05 01                		bra	.L519
 6640                             	.L506:
10626:../src/src/tls.c ****                 offset += MFL_WRITE((byte*)extension->data, output + offset);
 6641                             		.loc 2 10626 17
 6642 011e FB 12 A1 00 00 00       		mov.L	#.LC4, r1
 6643 0124 05 00 00 00             		bsr	_WOLFSSL_MSG
10628:../src/src/tls.c **** 
 6644                             		.loc 2 10628 17
 6645 0128 38 F8 00                		bra	.L519
 6646                             	.L517:
10631:../src/src/tls.c ****                 /* always empty. */
 6647                             		.loc 2 10631 17
 6648 012b FB 12 C8 00 00 00       		mov.L	#.LC5, r1
 6649 0131 05 00 00 00             		bsr	_WOLFSSL_MSG
10633:../src/src/tls.c **** 
 6650                             		.loc 2 10633 17
 6651 0135 38 EB 00                		bra	.L519
 6652                             	.L504:
10636:../src/src/tls.c ****                 /* always empty. */
 6653                             		.loc 2 10636 17
 6654 0138 FB 12 DF 00 00 00       		mov.L	#.LC6, r1
 6655 013e 05 00 00 00             		bsr	_WOLFSSL_MSG
10638:../src/src/tls.c **** 
 6656                             		.loc 2 10638 17
 6657 0142 38 DE 00                		bra	.L519
 6658                             	.L510:
10641:../src/src/tls.c ****                 offset += EC_WRITE((SupportedCurve*)extension->data,
 6659                             		.loc 2 10641 17
 6660 0145 FB 12 01 01 00 00       		mov.L	#.LC7, r1
 6661 014b 05 00 00 00             		bsr	_WOLFSSL_MSG
10642:../src/src/tls.c ****                                     output + offset);
 6662                             		.loc 2 10642 62
 6663 014f ED A5 03                		mov.L	12[r10], r5
 6664 0152 A8 5B                   		mov.L	4[r5], r3
10642:../src/src/tls.c ****                                     output + offset);
 6665                             		.loc 2 10642 27
 6666 0154 5C A5                   		movu.W	[r10], r5
 6667 0156 ED A4 05                		mov.L	20[r10], r4
 6668 0159 4B 45                   		add	r4, r5
 6669 015b EF 52                   		mov.L	r5, r2
 6670 015d EF 31                   		mov.L	r3, r1
 6671 015f 05 00 00 00             		bsr	_TLSX_SupportedCurve_Write
 6672 0163 EF 15                   		mov.L	r1, r5
 6673 0165 DF 54                   		mov.W	r5, r4
10642:../src/src/tls.c ****                                     output + offset);
 6674                             		.loc 2 10642 24
 6675 0167 DC A5                   		mov.W	[r10], r5
 6676 0169 4B 45                   		add	r4, r5
 6677 016b D3 A5                   		mov.W	r5, [r10]
10644:../src/src/tls.c **** 
 6678                             		.loc 2 10644 17
 6679 016d 38 B3 00                		bra	.L519
 6680                             	.L502:
10647:../src/src/tls.c ****                 offset += PF_WRITE((PointFormat*)extension->data,
 6681                             		.loc 2 10647 17
 6682 0170 FB 12 25 01 00 00       		mov.L	#.LC8, r1
 6683 0176 05 00 00 00             		bsr	_WOLFSSL_MSG
10648:../src/src/tls.c ****                                     output + offset);
 6684                             		.loc 2 10648 59
 6685 017a ED A5 03                		mov.L	12[r10], r5
 6686 017d A8 5B                   		mov.L	4[r5], r3
10648:../src/src/tls.c ****                                     output + offset);
 6687                             		.loc 2 10648 27
 6688 017f 5C A5                   		movu.W	[r10], r5
 6689 0181 ED A4 05                		mov.L	20[r10], r4
 6690 0184 4B 45                   		add	r4, r5
 6691 0186 EF 52                   		mov.L	r5, r2
 6692 0188 EF 31                   		mov.L	r3, r1
 6693 018a 05 00 00 00             		bsr	_TLSX_PointFormat_Write
 6694 018e EF 15                   		mov.L	r1, r5
 6695 0190 DF 54                   		mov.W	r5, r4
10648:../src/src/tls.c ****                                     output + offset);
 6696                             		.loc 2 10648 24
 6697 0192 DC A5                   		mov.W	[r10], r5
 6698 0194 4B 45                   		add	r4, r5
 6699 0196 D3 A5                   		mov.W	r5, [r10]
10650:../src/src/tls.c **** 
 6700                             		.loc 2 10650 17
 6701 0198 38 88 00                		bra	.L519
 6702                             	.L509:
10653:../src/src/tls.c ****                 offset += CSR_WRITE((CertificateStatusRequest*)extension->data,
 6703                             		.loc 2 10653 17
 6704 019b FB 12 46 01 00 00       		mov.L	#.LC9, r1
 6705 01a1 05 00 00 00             		bsr	_WOLFSSL_MSG
10654:../src/src/tls.c ****                         output + offset, isRequest);
 6706                             		.loc 2 10654 73
 6707 01a5 ED A5 03                		mov.L	12[r10], r5
 6708 01a8 A8 59                   		mov.L	4[r5], r1
10654:../src/src/tls.c ****                         output + offset, isRequest);
 6709                             		.loc 2 10654 27
 6710 01aa 5C A5                   		movu.W	[r10], r5
 6711 01ac ED A4 05                		mov.L	20[r10], r4
 6712 01af 4B 45                   		add	r4, r5
 6713 01b1 CD A3 0A                		mov.B	10[r10], r3
 6714 01b4 EF 52                   		mov.L	r5, r2
 6715 01b6 05 00 00 00             		bsr	_TLSX_CSR_Write
 6716 01ba EF 15                   		mov.L	r1, r5
 6717 01bc DF 54                   		mov.W	r5, r4
10654:../src/src/tls.c ****                         output + offset, isRequest);
 6718                             		.loc 2 10654 24
 6719 01be DC A5                   		mov.W	[r10], r5
 6720 01c0 4B 45                   		add	r4, r5
 6721 01c2 D3 A5                   		mov.W	r5, [r10]
10656:../src/src/tls.c **** 
 6722                             		.loc 2 10656 17
 6723 01c4 2E 5C                   		bra	.L519
 6724                             	.L511:
10659:../src/src/tls.c ****                 offset += CSR2_WRITE(
 6725                             		.loc 2 10659 17
 6726 01c6 FB 12 74 01 00 00       		mov.L	#.LC10, r1
 6727 01cc 05 00 00 00             		bsr	_WOLFSSL_MSG
10663:../src/src/tls.c **** 
 6728                             		.loc 2 10663 17
 6729 01d0 2E 50                   		bra	.L519
 6730                             	.L516:
10666:../src/src/tls.c ****                 offset += SCR_WRITE((SecureRenegotiation*)extension->data,
 6731                             		.loc 2 10666 17
 6732 01d2 FB 12 A5 01 00 00       		mov.L	#.LC11, r1
 6733 01d8 05 00 00 00             		bsr	_WOLFSSL_MSG
10669:../src/src/tls.c **** 
 6734                             		.loc 2 10669 17
 6735 01dc 2E 44                   		bra	.L519
 6736                             	.L515:
10672:../src/src/tls.c ****                 offset += WOLF_STK_WRITE((SessionTicket*)extension->data,
 6737                             		.loc 2 10672 17
 6738 01de FB 12 CD 01 00 00       		mov.L	#.LC12, r1
 6739 01e4 05 00 00 00             		bsr	_WOLFSSL_MSG
10675:../src/src/tls.c **** 
 6740                             		.loc 2 10675 17
 6741 01e8 2E 38                   		bra	.L519
 6742                             	.L514:
10678:../src/src/tls.c ****                 offset += ALPN_WRITE((ALPN*)extension->data, output + offset);
 6743                             		.loc 2 10678 17
 6744 01ea FB 12 EF 01 00 00       		mov.L	#.LC13, r1
 6745 01f0 05 00 00 00             		bsr	_WOLFSSL_MSG
10680:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
 6746                             		.loc 2 10680 17
 6747 01f4 2E 2C                   		bra	.L519
 6748                             	.L513:
10683:../src/src/tls.c ****                 offset += SA_WRITE(extension->data, output + offset);
 6749                             		.loc 2 10683 17
 6750 01f6 FB 12 07 02 00 00       		mov.L	#.LC14, r1
 6751 01fc 05 00 00 00             		bsr	_WOLFSSL_MSG
10684:../src/src/tls.c ****                 break;
 6752                             		.loc 2 10684 27
 6753 0200 ED A5 03                		mov.L	12[r10], r5
 6754 0203 A8 5B                   		mov.L	4[r5], r3
 6755 0205 5C A5                   		movu.W	[r10], r5
 6756 0207 ED A4 05                		mov.L	20[r10], r4
 6757 020a 4B 45                   		add	r4, r5
 6758 020c EF 52                   		mov.L	r5, r2
 6759 020e EF 31                   		mov.L	r3, r1
 6760 0210 05 00 00 00             		bsr	_TLSX_SignatureAlgorithms_Write
 6761 0214 EF 15                   		mov.L	r1, r5
 6762 0216 DF 54                   		mov.W	r5, r4
10684:../src/src/tls.c ****                 break;
 6763                             		.loc 2 10684 24
 6764 0218 DC A5                   		mov.W	[r10], r5
 6765 021a 4B 45                   		add	r4, r5
 6766 021c D3 A5                   		mov.W	r5, [r10]
10685:../src/src/tls.c **** #endif
 6767                             		.loc 2 10685 17
 6768 021e 03                      		nop
 6769 021f 03                      		.balign 8,3,1
 6770                             	.L519:
10756:../src/src/tls.c ****         }
10757:../src/src/tls.c **** 
10758:../src/src/tls.c ****         /* writes extension data length. */
10759:../src/src/tls.c ****         c16toa(offset - length_offset, output + length_offset - OPAQUE16_LEN);
 6771                             		.loc 2 10759 9
 6772 0220 DC A4                   		mov.W	[r10], r4
 6773 0222 DD A5 04                		mov.W	8[r10], r5
 6774 0225 FF 05 54                		sub	r5, r4, r5
 6775 0228 DF 53                   		mov.W	r5, r3
 6776                             		.loc 2 10759 63
 6777 022a 5D A5 04                		movu.W	8[r10], r5
 6778 022d 60 25                   		sub	#2, r5
 6779                             		.loc 2 10759 9
 6780 022f ED A4 05                		mov.L	20[r10], r4
 6781 0232 4B 45                   		add	r4, r5
 6782 0234 EF 52                   		mov.L	r5, r2
 6783 0236 DF 31                   		mov.W	r3, r1
 6784 0238 05 00 00 00             		bsr	_c16toa
10760:../src/src/tls.c **** 
10761:../src/src/tls.c ****         /* marks the extension as processed so ctx level */
10762:../src/src/tls.c ****         /* extensions don't overlap with ssl level ones. */
10763:../src/src/tls.c ****         TURN_ON(semaphore, TLSX_ToSemaphore(extension->type));
 6785                             		.loc 2 10763 9
 6786 023c ED A5 03                		mov.L	12[r10], r5
 6787 023f EC 55                   		mov.L	[r5], r5
 6788 0241 DF 51                   		mov.W	r5, r1
 6789 0243 05 00 00 00             		bsr	_TLSX_ToSemaphore
 6790 0247 EF 15                   		mov.L	r1, r5
 6791 0249 5F 55                   		movu.W	r5, r5
 6792 024b 64 75                   		and	#7, r5
 6793 024d 66 14                   		mov.L	#1, r4
 6794 024f EF 47                   		mov.L	r4, r7
 6795 0251 FD 62 57                		shll	r5, r7
 6796 0254 EF 75                   		mov.L	r7, r5
 6797 0256 CF 5B                   		mov.B	r5, r11
 6798 0258 ED A5 03                		mov.L	12[r10], r5
 6799 025b EC 55                   		mov.L	[r5], r5
 6800 025d DF 51                   		mov.W	r5, r1
 6801 025f 05 00 00 00             		bsr	_TLSX_ToSemaphore
 6802 0263 EF 15                   		mov.L	r1, r5
 6803 0265 5F 55                   		movu.W	r5, r5
 6804 0267 68 35                   		shlr	#3, r5
 6805 0269 DF 53                   		mov.W	r5, r3
 6806 026b 5F 35                   		movu.W	r3, r5
 6807 026d ED A4 06                		mov.L	24[r10], r4
 6808 0270 4B 45                   		add	r4, r5
 6809 0272 CC 54                   		mov.B	[r5], r4
 6810 0274 5F 35                   		movu.W	r3, r5
 6811 0276 ED A3 06                		mov.L	24[r10], r3
 6812 0279 4B 35                   		add	r3, r5
 6813 027b 57 B4                   		or	r11, r4
 6814 027d C3 54                   		mov.B	r4, [r5]
 6815 027f 03                      		.balign 8,3,1
 6816                             	.L499:
10591:../src/src/tls.c ****         list = extension->next;
 6817                             		.loc 2 10591 23
 6818 0280 ED A5 04                		mov.L	16[r10], r5
 6819 0283 E7 A5 03                		mov.L	r5, 12[r10]
10591:../src/src/tls.c ****         list = extension->next;
 6820                             		.loc 2 10591 11
 6821 0286 ED A5 03                		mov.L	12[r10], r5
 6822 0289 61 05                   		cmp	#0, r5
 6823 028b 3B AF FD                		bne	.L520
10764:../src/src/tls.c ****     }
10765:../src/src/tls.c **** 
10766:../src/src/tls.c ****     *pOffset += offset;
 6824                             		.loc 2 10766 14
 6825 028e EC 65                   		mov.L	[r6], r5
 6826 0290 DC 55                   		mov.W	[r5], r5
 6827 0292 DC A4                   		mov.W	[r10], r4
 6828 0294 4B 45                   		add	r4, r5
 6829 0296 DF 54                   		mov.W	r5, r4
 6830 0298 EC 65                   		mov.L	[r6], r5
 6831 029a D3 54                   		mov.W	r4, [r5]
10767:../src/src/tls.c **** 
10768:../src/src/tls.c ****     return ret;
 6832                             		.loc 2 10768 12
 6833 029c ED A5 01                		mov.L	4[r10], r5
10769:../src/src/tls.c **** }
 6834                             		.loc 2 10769 1
 6835 029f EF 51                   		mov.L	r5, r1
 6836 02a1 3F 6B 0F                		rtsd	#60, r6-r11
 6837                             	.LFE105:
 6839 02a4 76 10 01 00             		.section	.text.TLSX_PopulateSupportedGroups,"ax",@progbits
 6841                             	_TLSX_PopulateSupportedGroups:
 6842                             	.LFB106:
10770:../src/src/tls.c **** 
10771:../src/src/tls.c **** #ifdef HAVE_SUPPORTED_CURVES
10772:../src/src/tls.c **** 
10773:../src/src/tls.c **** /* Populates the default supported groups / curves */
10774:../src/src/tls.c **** static int TLSX_PopulateSupportedGroups(WOLFSSL* ssl, TLSX** extensions)
10775:../src/src/tls.c **** {
 6843                             		.loc 2 10775 1
 6844 0000 7E AA                   		push.l	r10
 6845                             	.LCFI162:
 6846 0002 71 0A F4                		add	#-12, r0, r10
 6847                             	.LCFI163:
 6848 0005 EF A0                   		mov.L	r10, r0
 6849 0007 E7 A1 01                		mov.L	r1, 4[r10]
 6850 000a E7 A2 02                		mov.L	r2, 8[r10]
10776:../src/src/tls.c ****     int ret = WOLFSSL_SUCCESS;
 6851                             		.loc 2 10776 9
 6852 000d F8 A6 01                		mov.L	#1, [r10]
10777:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
10778:../src/src/tls.c **** #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
10779:../src/src/tls.c ****     if (ssl->options.resuming && ssl->session->namedGroup != 0) {
10780:../src/src/tls.c ****         return TLSX_UseSupportedCurve(extensions, ssl->session->namedGroup,
10781:../src/src/tls.c ****                                                                      ssl->heap);
10782:../src/src/tls.c ****     }
10783:../src/src/tls.c **** #endif
10784:../src/src/tls.c **** 
10785:../src/src/tls.c ****     if (ssl->numGroups != 0) {
10786:../src/src/tls.c ****         int i;
10787:../src/src/tls.c ****         for (i = 0; i < ssl->numGroups; i++) {
10788:../src/src/tls.c ****             ret = TLSX_UseSupportedCurve(extensions, ssl->group[i], ssl->heap);
10789:../src/src/tls.c ****             if (ret != WOLFSSL_SUCCESS)
10790:../src/src/tls.c ****                 return ret;
10791:../src/src/tls.c ****         }
10792:../src/src/tls.c ****         return WOLFSSL_SUCCESS;
10793:../src/src/tls.c ****     }
10794:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 */
10795:../src/src/tls.c **** 
10796:../src/src/tls.c **** #if defined(HAVE_ECC)
10797:../src/src/tls.c ****         /* list in order by strength, since not all servers choose by strength */
10798:../src/src/tls.c ****         #if (defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 521
10799:../src/src/tls.c ****             #ifndef NO_ECC_SECP
10800:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
 6853                             		.loc 2 10800 23
 6854 0010 ED A5 01                		mov.L	4[r10], r5
 6855 0013 AA 5D                   		mov.L	36[r5], r5
 6856 0015 EF 53                   		mov.L	r5, r3
 6857 0017 75 42 19                		mov	#25, r2
 6858 001a ED A1 02                		mov.L	8[r10], r1
 6859 001d 05 00 00 00             		bsr	_TLSX_UseSupportedCurve
 6860 0021 E3 A1                   		mov.L	r1, [r10]
10801:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP521R1, ssl->heap);
10802:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
 6861                             		.loc 2 10802 20
 6862 0023 EC A5                   		mov.L	[r10], r5
 6863 0025 61 15                   		cmp	#1, r5
 6864 0027 16                      		beq	.L523
 6865                             		.loc 2 10802 52 discriminator 1
 6866 0028 EC A5                   		mov.L	[r10], r5
 6867 002a 38 AF 00                		bra	.L524
 6868                             	.L523:
10803:../src/src/tls.c ****             #endif
10804:../src/src/tls.c ****         #endif
10805:../src/src/tls.c ****         #if (defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 512
10806:../src/src/tls.c ****             #ifdef HAVE_ECC_BRAINPOOL
10807:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10808:../src/src/tls.c ****                                         WOLFSSL_ECC_BRAINPOOLP512R1, ssl->heap);
10809:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10810:../src/src/tls.c ****             #endif
10811:../src/src/tls.c ****         #endif
10812:../src/src/tls.c ****         #if (defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 384
10813:../src/src/tls.c ****             #ifndef NO_ECC_SECP
10814:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
 6869                             		.loc 2 10814 23
 6870 002d ED A5 01                		mov.L	4[r10], r5
 6871 0030 AA 5D                   		mov.L	36[r5], r5
 6872 0032 EF 53                   		mov.L	r5, r3
 6873 0034 75 42 18                		mov	#24, r2
 6874 0037 ED A1 02                		mov.L	8[r10], r1
 6875 003a 05 00 00 00             		bsr	_TLSX_UseSupportedCurve
 6876 003e E3 A1                   		mov.L	r1, [r10]
10815:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP384R1, ssl->heap);
10816:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
 6877                             		.loc 2 10816 20
 6878 0040 EC A5                   		mov.L	[r10], r5
 6879 0042 61 15                   		cmp	#1, r5
 6880 0044 16                      		beq	.L525
 6881                             		.loc 2 10816 52 discriminator 1
 6882 0045 EC A5                   		mov.L	[r10], r5
 6883 0047 38 92 00                		bra	.L524
 6884                             	.L525:
10817:../src/src/tls.c ****             #endif
10818:../src/src/tls.c ****             #ifdef HAVE_ECC_BRAINPOOL
10819:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10820:../src/src/tls.c ****                                         WOLFSSL_ECC_BRAINPOOLP384R1, ssl->heap);
10821:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10822:../src/src/tls.c ****             #endif
10823:../src/src/tls.c ****         #endif
10824:../src/src/tls.c **** #endif /* HAVE_ECC */
10825:../src/src/tls.c **** 
10826:../src/src/tls.c ****         #ifndef HAVE_FIPS
10827:../src/src/tls.c ****             #if defined(HAVE_CURVE448) && ECC_MIN_KEY_SZ <= 448
10828:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10829:../src/src/tls.c ****                                                    WOLFSSL_ECC_X448, ssl->heap);
10830:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10831:../src/src/tls.c ****             #endif
10832:../src/src/tls.c ****         #endif /* HAVE_FIPS */
10833:../src/src/tls.c **** 
10834:../src/src/tls.c **** #if defined(HAVE_ECC) && defined(HAVE_SUPPORTED_CURVES)
10835:../src/src/tls.c ****         #if (!defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
10836:../src/src/tls.c ****             #ifndef NO_ECC_SECP
10837:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
 6885                             		.loc 2 10837 23
 6886 004a ED A5 01                		mov.L	4[r10], r5
 6887 004d AA 5D                   		mov.L	36[r5], r5
 6888 004f EF 53                   		mov.L	r5, r3
 6889 0051 75 42 17                		mov	#23, r2
 6890 0054 ED A1 02                		mov.L	8[r10], r1
 6891 0057 05 00 00 00             		bsr	_TLSX_UseSupportedCurve
 6892 005b E3 A1                   		mov.L	r1, [r10]
10838:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP256R1, ssl->heap);
10839:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
 6893                             		.loc 2 10839 20
 6894 005d EC A5                   		mov.L	[r10], r5
 6895 005f 61 15                   		cmp	#1, r5
 6896 0061 15                      		beq	.L526
 6897                             		.loc 2 10839 52 discriminator 1
 6898 0062 EC A5                   		mov.L	[r10], r5
 6899 0064 2E 75                   		bra	.L524
 6900                             	.L526:
10840:../src/src/tls.c ****             #endif
10841:../src/src/tls.c ****             #ifdef HAVE_ECC_KOBLITZ
10842:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10843:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP256K1, ssl->heap);
10844:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10845:../src/src/tls.c ****             #endif
10846:../src/src/tls.c ****             #ifdef HAVE_ECC_BRAINPOOL
10847:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10848:../src/src/tls.c ****                                         WOLFSSL_ECC_BRAINPOOLP256R1, ssl->heap);
10849:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10850:../src/src/tls.c ****             #endif
10851:../src/src/tls.c ****         #endif
10852:../src/src/tls.c **** #endif /* HAVE_ECC */
10853:../src/src/tls.c **** 
10854:../src/src/tls.c ****         #ifndef HAVE_FIPS
10855:../src/src/tls.c ****             #if defined(HAVE_CURVE25519) && ECC_MIN_KEY_SZ <= 256
10856:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
 6901                             		.loc 2 10856 23
 6902 0066 ED A5 01                		mov.L	4[r10], r5
 6903 0069 AA 5D                   		mov.L	36[r5], r5
 6904 006b EF 53                   		mov.L	r5, r3
 6905 006d 75 42 1D                		mov	#29, r2
 6906 0070 ED A1 02                		mov.L	8[r10], r1
 6907 0073 05 00 00 00             		bsr	_TLSX_UseSupportedCurve
 6908 0077 E3 A1                   		mov.L	r1, [r10]
10857:../src/src/tls.c ****                                                  WOLFSSL_ECC_X25519, ssl->heap);
10858:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
 6909                             		.loc 2 10858 20
 6910 0079 EC A5                   		mov.L	[r10], r5
 6911 007b 61 15                   		cmp	#1, r5
 6912 007d 15                      		beq	.L527
 6913                             		.loc 2 10858 52 discriminator 1
 6914 007e EC A5                   		mov.L	[r10], r5
 6915 0080 2E 59                   		bra	.L524
 6916                             	.L527:
10859:../src/src/tls.c ****             #endif
10860:../src/src/tls.c ****         #endif /* HAVE_FIPS */
10861:../src/src/tls.c **** 
10862:../src/src/tls.c **** #if defined(HAVE_ECC) && defined(HAVE_SUPPORTED_CURVES)
10863:../src/src/tls.c ****         #if (defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 224
10864:../src/src/tls.c ****             #ifndef NO_ECC_SECP
10865:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
 6917                             		.loc 2 10865 23
 6918 0082 ED A5 01                		mov.L	4[r10], r5
 6919 0085 AA 5D                   		mov.L	36[r5], r5
 6920 0087 EF 53                   		mov.L	r5, r3
 6921 0089 75 42 15                		mov	#21, r2
 6922 008c ED A1 02                		mov.L	8[r10], r1
 6923 008f 05 00 00 00             		bsr	_TLSX_UseSupportedCurve
 6924 0093 E3 A1                   		mov.L	r1, [r10]
10866:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP224R1, ssl->heap);
10867:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
 6925                             		.loc 2 10867 20
 6926 0095 EC A5                   		mov.L	[r10], r5
 6927 0097 61 15                   		cmp	#1, r5
 6928 0099 15                      		beq	.L528
 6929                             		.loc 2 10867 52 discriminator 1
 6930 009a EC A5                   		mov.L	[r10], r5
 6931 009c 2E 3D                   		bra	.L524
 6932                             	.L528:
10868:../src/src/tls.c ****             #endif
10869:../src/src/tls.c ****             #ifdef HAVE_ECC_KOBLITZ
10870:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10871:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP224K1, ssl->heap);
10872:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10873:../src/src/tls.c ****             #endif
10874:../src/src/tls.c ****         #endif
10875:../src/src/tls.c **** 
10876:../src/src/tls.c ****     #ifndef HAVE_FIPS
10877:../src/src/tls.c ****         #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 192
10878:../src/src/tls.c ****             #ifndef NO_ECC_SECP
10879:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10880:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP192R1, ssl->heap);
10881:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10882:../src/src/tls.c ****             #endif
10883:../src/src/tls.c ****             #ifdef HAVE_ECC_KOBLITZ
10884:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10885:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP192K1, ssl->heap);
10886:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10887:../src/src/tls.c ****             #endif
10888:../src/src/tls.c ****         #endif
10889:../src/src/tls.c ****         #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 160
10890:../src/src/tls.c ****             #ifndef NO_ECC_SECP
10891:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10892:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP160R1, ssl->heap);
10893:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10894:../src/src/tls.c ****             #endif
10895:../src/src/tls.c ****             #ifdef HAVE_ECC_SECPR2
10896:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10897:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP160R2, ssl->heap);
10898:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10899:../src/src/tls.c ****             #endif
10900:../src/src/tls.c ****             #ifdef HAVE_ECC_KOBLITZ
10901:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10902:../src/src/tls.c ****                                               WOLFSSL_ECC_SECP160K1, ssl->heap);
10903:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS) return ret;
10904:../src/src/tls.c ****             #endif
10905:../src/src/tls.c ****         #endif
10906:../src/src/tls.c ****     #endif /* HAVE_FIPS */
10907:../src/src/tls.c **** #endif /* HAVE_ECC */
10908:../src/src/tls.c **** 
10909:../src/src/tls.c **** #ifndef NO_DH
10910:../src/src/tls.c ****             /* Add FFDHE supported groups. */
10911:../src/src/tls.c ****         #ifdef HAVE_FFDHE_8192
10912:../src/src/tls.c ****             if (8192/8 >= ssl->options.minDhKeySz &&
10913:../src/src/tls.c ****                                             8192/8 <= ssl->options.maxDhKeySz) {
10914:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10915:../src/src/tls.c ****                                              WOLFSSL_FFDHE_8192, ssl->heap);
10916:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS)
10917:../src/src/tls.c ****                     return ret;
10918:../src/src/tls.c ****             }
10919:../src/src/tls.c ****         #endif
10920:../src/src/tls.c ****         #ifdef HAVE_FFDHE_6144
10921:../src/src/tls.c ****             if (6144/8 >= ssl->options.minDhKeySz &&
10922:../src/src/tls.c ****                                             6144/8 <= ssl->options.maxDhKeySz) {
10923:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10924:../src/src/tls.c ****                                              WOLFSSL_FFDHE_6144, ssl->heap);
10925:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS)
10926:../src/src/tls.c ****                     return ret;
10927:../src/src/tls.c ****             }
10928:../src/src/tls.c ****         #endif
10929:../src/src/tls.c ****         #ifdef HAVE_FFDHE_4096
10930:../src/src/tls.c ****             if (4096/8 >= ssl->options.minDhKeySz &&
10931:../src/src/tls.c ****                                             4096/8 <= ssl->options.maxDhKeySz) {
10932:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10933:../src/src/tls.c ****                                              WOLFSSL_FFDHE_4096, ssl->heap);
10934:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS)
10935:../src/src/tls.c ****                     return ret;
10936:../src/src/tls.c ****             }
10937:../src/src/tls.c ****         #endif
10938:../src/src/tls.c ****         #ifdef HAVE_FFDHE_3072
10939:../src/src/tls.c ****             if (3072/8 >= ssl->options.minDhKeySz &&
10940:../src/src/tls.c ****                                             3072/8 <= ssl->options.maxDhKeySz) {
10941:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
10942:../src/src/tls.c ****                                              WOLFSSL_FFDHE_3072, ssl->heap);
10943:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS)
10944:../src/src/tls.c ****                     return ret;
10945:../src/src/tls.c ****             }
10946:../src/src/tls.c ****         #endif
10947:../src/src/tls.c ****         #ifdef HAVE_FFDHE_2048
10948:../src/src/tls.c ****             if (2048/8 >= ssl->options.minDhKeySz &&
 6933                             		.loc 2 10948 39
 6934 009e ED A5 01                		mov.L	4[r10], r5
 6935 00a1 DE 55 59 01             		mov.W	690[r5], r5
 6936                             		.loc 2 10948 16
 6937 00a5 5F 55                   		movu.W	r5, r5
 6938 00a7 76 05 00 01             		cmp	#0x100, r5
 6939 00ab 24 2C                   		bgtu	.L529
10949:../src/src/tls.c ****                                             2048/8 <= ssl->options.maxDhKeySz) {
 6940                             		.loc 2 10949 67 discriminator 1
 6941 00ad ED A5 01                		mov.L	4[r10], r5
 6942 00b0 DE 55 5A 01             		mov.W	692[r5], r5
10948:../src/src/tls.c ****                                             2048/8 <= ssl->options.maxDhKeySz) {
 6943                             		.loc 2 10948 51 discriminator 1
 6944 00b4 5F 55                   		movu.W	r5, r5
 6945 00b6 75 55 FF                		cmp	#0xff, r5
 6946 00b9 25 1E                   		bleu	.L529
10950:../src/src/tls.c ****                 ret = TLSX_UseSupportedCurve(extensions,
 6947                             		.loc 2 10950 23
 6948 00bb ED A5 01                		mov.L	4[r10], r5
 6949 00be AA 5D                   		mov.L	36[r5], r5
 6950 00c0 EF 53                   		mov.L	r5, r3
 6951 00c2 FB 2A 00 01             		mov	#0x100, r2
 6952 00c6 ED A1 02                		mov.L	8[r10], r1
 6953 00c9 05 00 00 00             		bsr	_TLSX_UseSupportedCurve
 6954 00cd E3 A1                   		mov.L	r1, [r10]
10951:../src/src/tls.c ****                                              WOLFSSL_FFDHE_2048, ssl->heap);
10952:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS)
 6955                             		.loc 2 10952 20
 6956 00cf EC A5                   		mov.L	[r10], r5
 6957 00d1 61 15                   		cmp	#1, r5
 6958 00d3 14                      		beq	.L529
10953:../src/src/tls.c ****                     return ret;
 6959                             		.loc 2 10953 28
 6960 00d4 EC A5                   		mov.L	[r10], r5
 6961 00d6 0B                      		bra	.L524
 6962                             	.L529:
10954:../src/src/tls.c ****             }
10955:../src/src/tls.c ****         #endif
10956:../src/src/tls.c **** #endif
10957:../src/src/tls.c **** 
10958:../src/src/tls.c **** #ifdef HAVE_PQC
10959:../src/src/tls.c ****     ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_KYBER_LEVEL1, ssl->heap);
10960:../src/src/tls.c **** #if HAVE_LIBOQS
10961:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10962:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_KYBER_LEVEL3,
10963:../src/src/tls.c ****                                      ssl->heap);
10964:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10965:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_KYBER_LEVEL5,
10966:../src/src/tls.c ****                                      ssl->heap);
10967:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10968:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_NTRU_HPS_LEVEL1,
10969:../src/src/tls.c ****                                      ssl->heap);
10970:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10971:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_NTRU_HPS_LEVEL3,
10972:../src/src/tls.c ****                                      ssl->heap);
10973:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10974:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_NTRU_HPS_LEVEL5,
10975:../src/src/tls.c ****                                      ssl->heap);
10976:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10977:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_NTRU_HRSS_LEVEL3,
10978:../src/src/tls.c ****                                      ssl->heap);
10979:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10980:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_SABER_LEVEL1,
10981:../src/src/tls.c ****                                      ssl->heap);
10982:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10983:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_SABER_LEVEL3,
10984:../src/src/tls.c ****                                      ssl->heap);
10985:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10986:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_SABER_LEVEL5,
10987:../src/src/tls.c ****                                      ssl->heap);
10988:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10989:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_KYBER_90S_LEVEL1,
10990:../src/src/tls.c ****                                      ssl->heap);
10991:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10992:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_KYBER_90S_LEVEL3,
10993:../src/src/tls.c ****                                      ssl->heap);
10994:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10995:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_KYBER_90S_LEVEL5,
10996:../src/src/tls.c ****                                      ssl->heap);
10997:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
10998:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P256_NTRU_HPS_LEVEL1,
10999:../src/src/tls.c ****                                      ssl->heap);
11000:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11001:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P384_NTRU_HPS_LEVEL3,
11002:../src/src/tls.c ****                                      ssl->heap);
11003:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11004:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P521_NTRU_HPS_LEVEL5,
11005:../src/src/tls.c ****                                      ssl->heap);
11006:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11007:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P384_NTRU_HRSS_LEVEL3,
11008:../src/src/tls.c ****                                      ssl->heap);
11009:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11010:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P256_SABER_LEVEL1,
11011:../src/src/tls.c ****                                      ssl->heap);
11012:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11013:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P384_SABER_LEVEL3,
11014:../src/src/tls.c ****                                      ssl->heap);
11015:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11016:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P521_SABER_LEVEL5,
11017:../src/src/tls.c ****                                      ssl->heap);
11018:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11019:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P256_KYBER_LEVEL1,
11020:../src/src/tls.c ****                                      ssl->heap);
11021:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11022:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P384_KYBER_LEVEL3,
11023:../src/src/tls.c ****                                      ssl->heap);
11024:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11025:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P521_KYBER_LEVEL5,
11026:../src/src/tls.c ****                                      ssl->heap);
11027:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11028:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P256_KYBER_90S_LEVEL1,
11029:../src/src/tls.c ****                                      ssl->heap);
11030:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11031:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P384_KYBER_90S_LEVEL3,
11032:../src/src/tls.c ****                                      ssl->heap);
11033:../src/src/tls.c ****     if (ret == WOLFSSL_SUCCESS)
11034:../src/src/tls.c ****         ret = TLSX_UseSupportedCurve(extensions, WOLFSSL_P521_KYBER_90S_LEVEL5,
11035:../src/src/tls.c ****                                      ssl->heap);
11036:../src/src/tls.c **** 
11037:../src/src/tls.c **** #endif /* HAVE_LIBOQS */
11038:../src/src/tls.c **** #endif /* HAVE_PQC */
11039:../src/src/tls.c **** 
11040:../src/src/tls.c ****     (void)ssl;
11041:../src/src/tls.c ****     (void)extensions;
11042:../src/src/tls.c **** 
11043:../src/src/tls.c ****     return ret;
 6963                             		.loc 2 11043 12
 6964 00d7 EC A5                   		mov.L	[r10], r5
 6965                             		.balign 8,3,1
 6966                             	.L524:
11044:../src/src/tls.c **** }
 6967                             		.loc 2 11044 1
 6968 00d9 EF 51                   		mov.L	r5, r1
 6969 00db 3F AA 04                		rtsd	#16, r10-r10
 6970                             	.LFE106:
 6972 00de EF 00                   		.section C,"a",@progbits
 6973 022f 00                      		.p2align 2
 6974                             	.LC15:
 6975 0230 41 64 64 69 6E 67 20 73 		.string	"Adding signature algorithms extension"
 6975      69 67 6E 61 74 75 72 65 
 6975      20 61 6C 67 6F 72 69 74 
 6975      68 6D 73 20 65 78 74 65 
 6975      6E 73 69 6F 6E 00 
 6976                             		.section	.text.TLSX_PopulateExtensions,"ax",@progbits
 6977                             		.global	_TLSX_PopulateExtensions
 6979                             	_TLSX_PopulateExtensions:
 6980                             	.LFB107:
11045:../src/src/tls.c **** 
11046:../src/src/tls.c **** #endif /* HAVE_SUPPORTED_CURVES */
11047:../src/src/tls.c **** 
11048:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_SUPPORTED_CURVES)
11049:../src/src/tls.c **** 
11050:../src/src/tls.c **** static const word16 preferredGroup[] = {
11051:../src/src/tls.c **** #if defined(HAVE_ECC) && (!defined(NO_ECC256) || \
11052:../src/src/tls.c ****     defined(HAVE_ALL_CURVES)) && !defined(NO_ECC_SECP) && ECC_MIN_KEY_SZ <= 256
11053:../src/src/tls.c ****     WOLFSSL_ECC_SECP256R1,
11054:../src/src/tls.c **** #endif
11055:../src/src/tls.c **** #if defined(HAVE_CURVE25519) && ECC_MIN_KEY_SZ <= 256
11056:../src/src/tls.c ****     WOLFSSL_ECC_X25519,
11057:../src/src/tls.c **** #endif
11058:../src/src/tls.c **** #if defined(HAVE_CURVE448) && ECC_MIN_KEY_SZ <= 448
11059:../src/src/tls.c ****     WOLFSSL_ECC_X448,
11060:../src/src/tls.c **** #endif
11061:../src/src/tls.c **** #if defined(HAVE_ECC) && (!defined(NO_ECC384) || \
11062:../src/src/tls.c ****     defined(HAVE_ALL_CURVES)) && !defined(NO_ECC_SECP) && ECC_MIN_KEY_SZ <= 384
11063:../src/src/tls.c ****     WOLFSSL_ECC_SECP384R1,
11064:../src/src/tls.c **** #endif
11065:../src/src/tls.c **** #if defined(HAVE_ECC) && (!defined(NO_ECC521) || \
11066:../src/src/tls.c ****     defined(HAVE_ALL_CURVES)) && !defined(NO_ECC_SECP) && ECC_MIN_KEY_SZ <= 521
11067:../src/src/tls.c ****     WOLFSSL_ECC_SECP521R1,
11068:../src/src/tls.c **** #endif
11069:../src/src/tls.c **** #if defined(HAVE_FFDHE_2048)
11070:../src/src/tls.c ****     WOLFSSL_FFDHE_2048,
11071:../src/src/tls.c **** #endif
11072:../src/src/tls.c **** #if defined(HAVE_FFDHE_3072)
11073:../src/src/tls.c ****     WOLFSSL_FFDHE_3072,
11074:../src/src/tls.c **** #endif
11075:../src/src/tls.c **** #if defined(HAVE_FFDHE_4096)
11076:../src/src/tls.c ****     WOLFSSL_FFDHE_4096,
11077:../src/src/tls.c **** #endif
11078:../src/src/tls.c **** #if defined(HAVE_FFDHE_6144)
11079:../src/src/tls.c ****     WOLFSSL_FFDHE_6144,
11080:../src/src/tls.c **** #endif
11081:../src/src/tls.c **** #if defined(HAVE_FFDHE_8192)
11082:../src/src/tls.c ****     WOLFSSL_FFDHE_8192,
11083:../src/src/tls.c **** #endif
11084:../src/src/tls.c ****     WOLFSSL_NAMED_GROUP_INVALID
11085:../src/src/tls.c **** };
11086:../src/src/tls.c **** 
11087:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 && HAVE_SUPPORTED_CURVES */
11088:../src/src/tls.c **** 
11089:../src/src/tls.c **** int TLSX_PopulateExtensions(WOLFSSL* ssl, byte isServer)
11090:../src/src/tls.c **** {
 6981                             		.loc 2 11090 1
 6982 0000 7E AA                   		push.l	r10
 6983                             	.LCFI164:
 6984 0002 71 0A EC                		add	#-20, r0, r10
 6985                             	.LCFI165:
 6986 0005 71 A0 FC                		add	#-4, r10, r0
 6987                             	.LCFI166:
 6988 0008 E7 A1 03                		mov.L	r1, 12[r10]
 6989 000b C7 A2 10                		mov.B	r2, 16[r10]
11091:../src/src/tls.c ****     int ret = 0;
 6990                             		.loc 2 11091 9
 6991 000e F8 A6 00                		mov.L	#0, [r10]
11092:../src/src/tls.c ****     byte* public_key      = NULL;
 6992                             		.loc 2 11092 11
 6993 0011 F9 A6 01 00             		mov.L	#0, 4[r10]
11093:../src/src/tls.c ****     word16 public_key_len = 0;
 6994                             		.loc 2 11093 12
 6995 0015 F9 A5 04 00             		mov.W	#0, 8[r10]
11094:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))
11095:../src/src/tls.c ****     int usingPSK = 0;
11096:../src/src/tls.c **** #endif
11097:../src/src/tls.c **** #if defined(HAVE_SUPPORTED_CURVES) && defined(WOLFSSL_TLS13)
11098:../src/src/tls.c ****     TLSX* extension = NULL;
11099:../src/src/tls.c ****     word16 namedGroup = WOLFSSL_NAMED_GROUP_INVALID;
11100:../src/src/tls.c **** #endif
11101:../src/src/tls.c **** 
11102:../src/src/tls.c ****     /* server will add extension depending on what is parsed from client */
11103:../src/src/tls.c ****     if (!isServer) {
 6996                             		.loc 2 11103 8
 6997 0019 59 A5 10                		movu.B	16[r10], r5
 6998 001c 61 05                   		cmp	#0, r5
 6999 001e 3B BD 00                		bne	.L531
11104:../src/src/tls.c **** #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
11105:../src/src/tls.c ****         if (!ssl->options.disallowEncThenMac) {
11106:../src/src/tls.c ****             ret = TLSX_EncryptThenMac_Use(ssl);
11107:../src/src/tls.c ****             if (ret != 0)
11108:../src/src/tls.c ****                 return ret;
11109:../src/src/tls.c ****         }
11110:../src/src/tls.c **** #endif
11111:../src/src/tls.c **** 
11112:../src/src/tls.c **** #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
11113:../src/src/tls.c ****                        defined(HAVE_CURVE448)) && defined(HAVE_SUPPORTED_CURVES)
11114:../src/src/tls.c ****         if (!ssl->options.userCurves && !ssl->ctx->userCurves) {
 7000                             		.loc 2 11114 13
 7001 0021 ED A5 03                		mov.L	12[r10], r5
 7002 0024 ED 55 A8                		mov.L	672[r5], r5
 7003 0027 76 25 00 08             		and	#0x800, r5
 7004                             		.loc 2 11114 12
 7005 002b 61 05                   		cmp	#0, r5
 7006 002d 21 43                   		bne	.L532
 7007                             		.loc 2 11114 45 discriminator 1
 7008 002f ED A5 03                		mov.L	12[r10], r5
 7009 0032 EC 55                   		mov.L	[r5], r5
 7010                             		.loc 2 11114 50 discriminator 1
 7011 0034 CE 55 2C 01             		mov.B	300[r5], r5
 7012                             		.loc 2 11114 38 discriminator 1
 7013 0038 5B 55                   		movu.B	r5, r5
 7014 003a 61 05                   		cmp	#0, r5
 7015 003c 21 34                   		bne	.L532
11115:../src/src/tls.c ****             if (TLSX_Find(ssl->ctx->extensions,
 7016                             		.loc 2 11115 30
 7017 003e ED A5 03                		mov.L	12[r10], r5
 7018 0041 EC 55                   		mov.L	[r5], r5
 7019                             		.loc 2 11115 17
 7020 0043 ED 55 49                		mov.L	292[r5], r5
 7021 0046 66 A2                   		mov.L	#10, r2
 7022 0048 EF 51                   		mov.L	r5, r1
 7023 004a 05 00 00 00             		bsr	_TLSX_Find
 7024 004e EF 15                   		mov.L	r1, r5
 7025                             		.loc 2 11115 16
 7026 0050 61 05                   		cmp	#0, r5
 7027 0052 21 1E                   		bne	.L532
11116:../src/src/tls.c ****                                                TLSX_SUPPORTED_GROUPS) == NULL) {
11117:../src/src/tls.c ****                 ret = TLSX_PopulateSupportedGroups(ssl, &ssl->extensions);
 7028                             		.loc 2 11117 23
 7029 0054 ED A5 03                		mov.L	12[r10], r5
 7030 0057 72 55 FC 02             		add	#0x2fc, r5
 7031 005b EF 52                   		mov.L	r5, r2
 7032 005d ED A1 03                		mov.L	12[r10], r1
 7033 0060 05 00 00 00             		bsr	_TLSX_PopulateSupportedGroups
 7034 0064 E3 A1                   		mov.L	r1, [r10]
11118:../src/src/tls.c ****                 if (ret != WOLFSSL_SUCCESS)
 7035                             		.loc 2 11118 20
 7036 0066 EC A5                   		mov.L	[r10], r5
 7037 0068 61 15                   		cmp	#1, r5
 7038 006a 16                      		beq	.L532
11119:../src/src/tls.c ****                     return ret;
 7039                             		.loc 2 11119 28
 7040 006b EC A5                   		mov.L	[r10], r5
 7041 006d 38 9B 00                		bra	.L533
 7042                             	.L532:
11120:../src/src/tls.c ****             }
11121:../src/src/tls.c ****         }
11122:../src/src/tls.c ****         if ((!IsAtLeastTLSv1_3(ssl->version) || ssl->options.downgrade) &&
 7043                             		.loc 2 11122 15
 7044 0070 ED A5 03                		mov.L	12[r10], r5
 7045 0073 DD 55 B0                		mov.W	352[r5], r5
 7046 0076 D3 05                   		mov.W	r5, [r0]
 7047 0078 05 00 00 00             		bsr	_IsAtLeastTLSv1_3
 7048 007c EF 15                   		mov.L	r1, r5
 7049                             		.loc 2 11122 12
 7050 007e 61 05                   		cmp	#0, r5
 7051 0080 20 10                   		beq	.L534
 7052                             		.loc 2 11122 46 discriminator 2
 7053 0082 ED A5 03                		mov.L	12[r10], r5
 7054 0085 ED 55 A7                		mov.L	668[r5], r5
 7055 0088 76 25 00 08             		and	#0x800, r5
 7056 008c 61 05                   		cmp	#0, r5
 7057 008e 20 4D                   		beq	.L531
 7058                             	.L534:
11123:../src/src/tls.c ****                TLSX_Find(ssl->ctx->extensions, TLSX_EC_POINT_FORMATS) == NULL &&
 7059                             		.loc 2 11123 29 discriminator 3
 7060 0090 ED A5 03                		mov.L	12[r10], r5
 7061 0093 EC 55                   		mov.L	[r5], r5
 7062                             		.loc 2 11123 16 discriminator 3
 7063 0095 ED 55 49                		mov.L	292[r5], r5
 7064 0098 66 B2                   		mov.L	#11, r2
 7065 009a EF 51                   		mov.L	r5, r1
 7066 009c 05 00 00 00             		bsr	_TLSX_Find
 7067 00a0 EF 15                   		mov.L	r1, r5
11122:../src/src/tls.c ****                TLSX_Find(ssl->ctx->extensions, TLSX_EC_POINT_FORMATS) == NULL &&
 7068                             		.loc 2 11122 73 discriminator 3
 7069 00a2 61 05                   		cmp	#0, r5
 7070 00a4 21 37                   		bne	.L531
11124:../src/src/tls.c ****                TLSX_Find(ssl->extensions, TLSX_EC_POINT_FORMATS) == NULL) {
 7071                             		.loc 2 11124 16
 7072 00a6 ED A5 03                		mov.L	12[r10], r5
 7073 00a9 ED 55 BF                		mov.L	764[r5], r5
 7074 00ac 66 B2                   		mov.L	#11, r2
 7075 00ae EF 51                   		mov.L	r5, r1
 7076 00b0 05 00 00 00             		bsr	_TLSX_Find
 7077 00b4 EF 15                   		mov.L	r1, r5
11123:../src/src/tls.c ****                TLSX_Find(ssl->ctx->extensions, TLSX_EC_POINT_FORMATS) == NULL &&
 7078                             		.loc 2 11123 79
 7079 00b6 61 05                   		cmp	#0, r5
 7080 00b8 21 23                   		bne	.L531
11125:../src/src/tls.c ****              ret = TLSX_UsePointFormat(&ssl->extensions,
 7081                             		.loc 2 11125 20
 7082 00ba ED A5 03                		mov.L	12[r10], r5
 7083 00bd 72 54 FC 02             		add	#0x2fc, r5, r4
 7084 00c1 ED A5 03                		mov.L	12[r10], r5
 7085 00c4 AA 5D                   		mov.L	36[r5], r5
 7086 00c6 EF 53                   		mov.L	r5, r3
 7087 00c8 66 02                   		mov	#0, r2
 7088 00ca EF 41                   		mov.L	r4, r1
 7089 00cc 05 00 00 00             		bsr	_TLSX_UsePointFormat
 7090 00d0 E3 A1                   		mov.L	r1, [r10]
11126:../src/src/tls.c ****                                          WOLFSSL_EC_PF_UNCOMPRESSED, ssl->heap);
11127:../src/src/tls.c ****              if (ret != WOLFSSL_SUCCESS)
 7091                             		.loc 2 11127 17
 7092 00d2 EC A5                   		mov.L	[r10], r5
 7093 00d4 61 15                   		cmp	#1, r5
 7094 00d6 15                      		beq	.L531
11128:../src/src/tls.c ****                  return ret;
 7095                             		.loc 2 11128 25
 7096 00d7 EC A5                   		mov.L	[r10], r5
 7097 00d9 2E 2F                   		bra	.L533
 7098                             	.L531:
11129:../src/src/tls.c ****         }
11130:../src/src/tls.c **** #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && HAVE_SUPPORTED_CURVES */
11131:../src/src/tls.c **** 
11132:../src/src/tls.c **** #ifdef WOLFSSL_SRTP
11133:../src/src/tls.c ****         if (ssl->options.dtls && ssl->dtlsSrtpProfiles != 0) {
11134:../src/src/tls.c ****             WOLFSSL_MSG("Adding DTLS SRTP extension");
11135:../src/src/tls.c ****             if ((ret = TLSX_UseSRTP(&ssl->extensions, ssl->dtlsSrtpProfiles,
11136:../src/src/tls.c ****                                                                 ssl->heap)) != 0) {
11137:../src/src/tls.c ****                 return ret;
11138:../src/src/tls.c ****             }
11139:../src/src/tls.c ****         }
11140:../src/src/tls.c **** #endif
11141:../src/src/tls.c ****     } /* is not server */
11142:../src/src/tls.c **** 
11143:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
11144:../src/src/tls.c ****     WOLFSSL_MSG("Adding signature algorithms extension");
 7099                             		.loc 2 11144 5
 7100 00db FB 12 30 02 00 00       		mov.L	#.LC15, r1
 7101 00e1 05 00 00 00             		bsr	_WOLFSSL_MSG
11145:../src/src/tls.c ****     if ((ret = TLSX_SetSignatureAlgorithms(&ssl->extensions, ssl, ssl->heap))
 7102                             		.loc 2 11145 16
 7103 00e5 ED A5 03                		mov.L	12[r10], r5
 7104 00e8 72 54 FC 02             		add	#0x2fc, r5, r4
 7105 00ec ED A5 03                		mov.L	12[r10], r5
 7106 00ef AA 5D                   		mov.L	36[r5], r5
 7107 00f1 EF 53                   		mov.L	r5, r3
 7108 00f3 ED A2 03                		mov.L	12[r10], r2
 7109 00f6 EF 41                   		mov.L	r4, r1
 7110 00f8 05 00 00 00             		bsr	_TLSX_SetSignatureAlgorithms
 7111 00fc E3 A1                   		mov.L	r1, [r10]
 7112                             		.loc 2 11145 8
 7113 00fe EC A5                   		mov.L	[r10], r5
 7114 0100 61 05                   		cmp	#0, r5
 7115 0102 14                      		beq	.L535
11146:../src/src/tls.c ****                                                                          != 0) {
11147:../src/src/tls.c ****             return ret;
 7116                             		.loc 2 11147 20
 7117 0103 EC A5                   		mov.L	[r10], r5
 7118 0105 0B                      		bra	.L533
 7119                             	.L535:
11148:../src/src/tls.c ****     }
11149:../src/src/tls.c **** #else
11150:../src/src/tls.c ****     ret = 0;
11151:../src/src/tls.c **** #endif
11152:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
11153:../src/src/tls.c ****         if (!isServer && IsAtLeastTLSv1_3(ssl->version)) {
11154:../src/src/tls.c ****             /* Add mandatory TLS v1.3 extension: supported version */
11155:../src/src/tls.c ****             WOLFSSL_MSG("Adding supported versions extension");
11156:../src/src/tls.c ****             if ((ret = TLSX_SetSupportedVersions(&ssl->extensions, ssl,
11157:../src/src/tls.c ****                                                              ssl->heap)) != 0) {
11158:../src/src/tls.c ****                 return ret;
11159:../src/src/tls.c ****             }
11160:../src/src/tls.c **** 
11161:../src/src/tls.c ****     #if !defined(HAVE_ECC) && !defined(HAVE_CURVE25519) && \
11162:../src/src/tls.c ****                        !defined(HAVE_CURVE448) && defined(HAVE_SUPPORTED_CURVES)
11163:../src/src/tls.c ****         if (TLSX_Find(ssl->ctx->extensions, TLSX_SUPPORTED_GROUPS) == NULL) {
11164:../src/src/tls.c ****             /* Put in DH groups for TLS 1.3 only. */
11165:../src/src/tls.c ****             ret = TLSX_PopulateSupportedGroups(ssl, &ssl->extensions);
11166:../src/src/tls.c ****             if (ret != WOLFSSL_SUCCESS)
11167:../src/src/tls.c ****                 return ret;
11168:../src/src/tls.c ****             ret = 0;
11169:../src/src/tls.c ****         }
11170:../src/src/tls.c ****     #endif /* !(HAVE_ECC || CURVE25519 || CURVE448) && HAVE_SUPPORTED_CURVES */
11171:../src/src/tls.c **** 
11172:../src/src/tls.c ****         #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
11173:../src/src/tls.c ****             if (ssl->certHashSigAlgoSz > 0) {
11174:../src/src/tls.c ****                 WOLFSSL_MSG("Adding signature algorithms cert extension");
11175:../src/src/tls.c ****                 if ((ret = TLSX_SetSignatureAlgorithmsCert(&ssl->extensions,
11176:../src/src/tls.c ****                                                         ssl, ssl->heap)) != 0) {
11177:../src/src/tls.c ****                     return ret;
11178:../src/src/tls.c ****                 }
11179:../src/src/tls.c ****             }
11180:../src/src/tls.c ****         #endif
11181:../src/src/tls.c **** 
11182:../src/src/tls.c ****         #if defined(HAVE_SUPPORTED_CURVES)
11183:../src/src/tls.c ****             extension = TLSX_Find(ssl->extensions, TLSX_KEY_SHARE);
11184:../src/src/tls.c ****             if (extension == NULL) {
11185:../src/src/tls.c ****             #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11186:../src/src/tls.c ****                 if (ssl->options.resuming && ssl->session->namedGroup != 0)
11187:../src/src/tls.c ****                     namedGroup = ssl->session->namedGroup;
11188:../src/src/tls.c ****                 else
11189:../src/src/tls.c ****             #endif
11190:../src/src/tls.c ****                 if (ssl->numGroups > 0) {
11191:../src/src/tls.c ****                     int set = 0;
11192:../src/src/tls.c ****                     int i, j;
11193:../src/src/tls.c **** 
11194:../src/src/tls.c ****                     /* try to find the highest element in ssl->group[]
11195:../src/src/tls.c ****                      * that is contained in preferredGroup[].
11196:../src/src/tls.c ****                      */
11197:../src/src/tls.c ****                     namedGroup = preferredGroup[0];
11198:../src/src/tls.c ****                     for (i = 0; i < ssl->numGroups && !set; i++) {
11199:../src/src/tls.c ****                         for (j = 0; preferredGroup[j] != WOLFSSL_NAMED_GROUP_INVALID; j++) {
11200:../src/src/tls.c ****                             if (preferredGroup[j] == ssl->group[i]) {
11201:../src/src/tls.c ****                                 namedGroup = ssl->group[i];
11202:../src/src/tls.c ****                                 set = 1;
11203:../src/src/tls.c ****                                 break;
11204:../src/src/tls.c ****                             }
11205:../src/src/tls.c ****                         }
11206:../src/src/tls.c ****                     }
11207:../src/src/tls.c ****                 }
11208:../src/src/tls.c ****                 else {
11209:../src/src/tls.c ****                     /* Choose the most preferred group. */
11210:../src/src/tls.c ****                     namedGroup = preferredGroup[0];
11211:../src/src/tls.c ****                 }
11212:../src/src/tls.c ****             }
11213:../src/src/tls.c ****             else {
11214:../src/src/tls.c ****                 KeyShareEntry* kse = (KeyShareEntry*)extension->data;
11215:../src/src/tls.c ****                 if (kse)
11216:../src/src/tls.c ****                     namedGroup = kse->group;
11217:../src/src/tls.c ****             }
11218:../src/src/tls.c ****             if (namedGroup > 0) {
11219:../src/src/tls.c **** #ifdef HAVE_PQC
11220:../src/src/tls.c ****                 /* For KEMs, the key share has already been generated. */
11221:../src/src/tls.c ****                 if (namedGroup < WOLFSSL_PQC_MIN || namedGroup > WOLFSSL_PQC_MAX)
11222:../src/src/tls.c **** #endif
11223:../src/src/tls.c ****                     ret = TLSX_KeyShare_Use(ssl, namedGroup, 0, NULL, NULL);
11224:../src/src/tls.c ****                 if (ret != 0)
11225:../src/src/tls.c ****                     return ret;
11226:../src/src/tls.c ****             }
11227:../src/src/tls.c ****         #endif /* HAVE_SUPPORTED_CURVES */
11228:../src/src/tls.c **** 
11229:../src/src/tls.c ****         #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11230:../src/src/tls.c ****             TLSX_Remove(&ssl->extensions, TLSX_PRE_SHARED_KEY, ssl->heap);
11231:../src/src/tls.c ****         #endif
11232:../src/src/tls.c ****         #if defined(HAVE_SESSION_TICKET)
11233:../src/src/tls.c ****             if (ssl->options.resuming && ssl->session->ticketLen > 0) {
11234:../src/src/tls.c ****                 WOLFSSL_SESSION* sess = ssl->session;
11235:../src/src/tls.c ****                 word32           now, milli;
11236:../src/src/tls.c **** 
11237:../src/src/tls.c ****                 if (sess->ticketLen > MAX_PSK_ID_LEN) {
11238:../src/src/tls.c ****                     WOLFSSL_MSG("Session ticket length for PSK ext is too large");
11239:../src/src/tls.c ****                     return BUFFER_ERROR;
11240:../src/src/tls.c ****                 }
11241:../src/src/tls.c **** 
11242:../src/src/tls.c ****                 /* Determine the MAC algorithm for the cipher suite used. */
11243:../src/src/tls.c ****                 ssl->options.cipherSuite0 = sess->cipherSuite0;
11244:../src/src/tls.c ****                 ssl->options.cipherSuite  = sess->cipherSuite;
11245:../src/src/tls.c ****                 ret = SetCipherSpecs(ssl);
11246:../src/src/tls.c ****                 if (ret != 0)
11247:../src/src/tls.c ****                     return ret;
11248:../src/src/tls.c ****                 now = TimeNowInMilliseconds();
11249:../src/src/tls.c ****                 if (now < sess->ticketSeen)
11250:../src/src/tls.c ****                     milli = (0xFFFFFFFFU - sess->ticketSeen) + 1 + now;
11251:../src/src/tls.c ****                 else
11252:../src/src/tls.c ****                     milli = now - sess->ticketSeen;
11253:../src/src/tls.c ****                 milli += sess->ticketAdd;
11254:../src/src/tls.c **** 
11255:../src/src/tls.c ****                 /* Pre-shared key is mandatory extension for resumption. */
11256:../src/src/tls.c ****                 ret = TLSX_PreSharedKey_Use(ssl, sess->ticket, sess->ticketLen,
11257:../src/src/tls.c ****                                             milli, ssl->specs.mac_algorithm,
11258:../src/src/tls.c ****                                             ssl->options.cipherSuite0,
11259:../src/src/tls.c ****                                             ssl->options.cipherSuite, 1,
11260:../src/src/tls.c ****                                             NULL);
11261:../src/src/tls.c ****                 if (ret != 0)
11262:../src/src/tls.c ****                     return ret;
11263:../src/src/tls.c **** 
11264:../src/src/tls.c ****                 usingPSK = 1;
11265:../src/src/tls.c ****             }
11266:../src/src/tls.c ****         #endif
11267:../src/src/tls.c ****     #ifndef NO_PSK
11268:../src/src/tls.c ****         #ifndef WOLFSSL_PSK_ONE_ID
11269:../src/src/tls.c ****             if (ssl->options.client_psk_cs_cb != NULL) {
11270:../src/src/tls.c ****                 int i;
11271:../src/src/tls.c ****                 for (i = 0; i < ssl->suites->suiteSz; i += 2) {
11272:../src/src/tls.c ****                     byte cipherSuite0 = ssl->suites->suites[i + 0];
11273:../src/src/tls.c ****                     byte cipherSuite = ssl->suites->suites[i + 1];
11274:../src/src/tls.c ****                     unsigned int keySz;
11275:../src/src/tls.c ****                 #ifdef WOLFSSL_PSK_MULTI_ID_PER_CS
11276:../src/src/tls.c ****                     int cnt = 0;
11277:../src/src/tls.c ****                 #endif
11278:../src/src/tls.c **** 
11279:../src/src/tls.c ****                 #ifdef HAVE_NULL_CIPHER
11280:../src/src/tls.c ****                     if (cipherSuite0 == ECC_BYTE ||
11281:../src/src/tls.c ****                         cipherSuite0 == ECDHE_PSK_BYTE) {
11282:../src/src/tls.c ****                         if (cipherSuite != TLS_SHA256_SHA256 &&
11283:../src/src/tls.c ****                                              cipherSuite != TLS_SHA384_SHA384) {
11284:../src/src/tls.c ****                             continue;
11285:../src/src/tls.c ****                         }
11286:../src/src/tls.c ****                     }
11287:../src/src/tls.c ****                     else
11288:../src/src/tls.c ****                 #endif
11289:../src/src/tls.c ****                     if (cipherSuite0 != TLS13_BYTE)
11290:../src/src/tls.c ****                         continue;
11291:../src/src/tls.c **** 
11292:../src/src/tls.c ****                 #ifdef WOLFSSL_PSK_MULTI_ID_PER_CS
11293:../src/src/tls.c ****                     do {
11294:../src/src/tls.c ****                         ssl->arrays->client_identity[0] = cnt;
11295:../src/src/tls.c ****                 #endif
11296:../src/src/tls.c **** 
11297:../src/src/tls.c ****                         ssl->arrays->client_identity[MAX_PSK_ID_LEN] = '\0';
11298:../src/src/tls.c ****                         keySz = ssl->options.client_psk_cs_cb(
11299:../src/src/tls.c ****                             ssl, ssl->arrays->server_hint,
11300:../src/src/tls.c ****                             ssl->arrays->client_identity, MAX_PSK_ID_LEN,
11301:../src/src/tls.c ****                             ssl->arrays->psk_key, MAX_PSK_KEY_LEN,
11302:../src/src/tls.c ****                             GetCipherNameInternal(cipherSuite0, cipherSuite));
11303:../src/src/tls.c ****                         if (keySz > 0) {
11304:../src/src/tls.c ****                             ssl->arrays->psk_keySz = keySz;
11305:../src/src/tls.c ****                             ret = TLSX_PreSharedKey_Use(ssl,
11306:../src/src/tls.c ****                                 (byte*)ssl->arrays->client_identity,
11307:../src/src/tls.c ****                                 (word16)XSTRLEN(ssl->arrays->client_identity),
11308:../src/src/tls.c ****                                 0, SuiteMac(ssl->suites->suites + i),
11309:../src/src/tls.c ****                                 cipherSuite0, cipherSuite, 0, NULL);
11310:../src/src/tls.c ****                             if (ret != 0)
11311:../src/src/tls.c ****                                 return ret;
11312:../src/src/tls.c ****                 #ifdef WOLFSSL_PSK_MULTI_ID_PER_CS
11313:../src/src/tls.c ****                             cnt++;
11314:../src/src/tls.c ****                 #endif
11315:../src/src/tls.c ****                         }
11316:../src/src/tls.c ****                 #ifdef WOLFSSL_PSK_MULTI_ID_PER_CS
11317:../src/src/tls.c ****                     }
11318:../src/src/tls.c ****                     while (keySz > 0);
11319:../src/src/tls.c ****                 #endif
11320:../src/src/tls.c ****                 }
11321:../src/src/tls.c **** 
11322:../src/src/tls.c ****                 usingPSK = 1;
11323:../src/src/tls.c ****             }
11324:../src/src/tls.c ****             else
11325:../src/src/tls.c ****         #endif
11326:../src/src/tls.c ****             if (ssl->options.client_psk_cb != NULL ||
11327:../src/src/tls.c ****                                      ssl->options.client_psk_tls13_cb != NULL) {
11328:../src/src/tls.c ****                 /* Default ciphersuite. */
11329:../src/src/tls.c ****                 byte cipherSuite0 = TLS13_BYTE;
11330:../src/src/tls.c ****                 byte cipherSuite = WOLFSSL_DEF_PSK_CIPHER;
11331:../src/src/tls.c ****                 int cipherSuiteFlags = WOLFSSL_CIPHER_SUITE_FLAG_NONE;
11332:../src/src/tls.c ****                 const char* cipherName = NULL;
11333:../src/src/tls.c **** 
11334:../src/src/tls.c ****                 if (ssl->options.client_psk_tls13_cb != NULL) {
11335:../src/src/tls.c ****                     ssl->arrays->psk_keySz = ssl->options.client_psk_tls13_cb(
11336:../src/src/tls.c ****                         ssl, ssl->arrays->server_hint,
11337:../src/src/tls.c ****                         ssl->arrays->client_identity, MAX_PSK_ID_LEN,
11338:../src/src/tls.c ****                         ssl->arrays->psk_key, MAX_PSK_KEY_LEN, &cipherName);
11339:../src/src/tls.c ****                     if (GetCipherSuiteFromName(cipherName, &cipherSuite0,
11340:../src/src/tls.c ****                                         &cipherSuite, &cipherSuiteFlags) != 0) {
11341:../src/src/tls.c ****                         return PSK_KEY_ERROR;
11342:../src/src/tls.c ****                     }
11343:../src/src/tls.c ****                 }
11344:../src/src/tls.c ****                 else {
11345:../src/src/tls.c ****                     ssl->arrays->psk_keySz = ssl->options.client_psk_cb(ssl,
11346:../src/src/tls.c ****                         ssl->arrays->server_hint, ssl->arrays->client_identity,
11347:../src/src/tls.c ****                         MAX_PSK_ID_LEN, ssl->arrays->psk_key, MAX_PSK_KEY_LEN);
11348:../src/src/tls.c ****                 }
11349:../src/src/tls.c ****         #if defined(OPENSSL_EXTRA)
11350:../src/src/tls.c ****                 /* OpenSSL treats 0 as a PSK key length of 0
11351:../src/src/tls.c ****                  * and meaning no PSK available.
11352:../src/src/tls.c ****                  */
11353:../src/src/tls.c ****                 if (ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
11354:../src/src/tls.c ****                     return PSK_KEY_ERROR;
11355:../src/src/tls.c ****                 }
11356:../src/src/tls.c ****                 if (ssl->arrays->psk_keySz > 0) {
11357:../src/src/tls.c ****         #else
11358:../src/src/tls.c ****                 if (ssl->arrays->psk_keySz == 0 ||
11359:../src/src/tls.c ****                                      ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
11360:../src/src/tls.c ****                     return PSK_KEY_ERROR;
11361:../src/src/tls.c ****                 }
11362:../src/src/tls.c ****         #endif
11363:../src/src/tls.c ****                 ssl->arrays->client_identity[MAX_PSK_ID_LEN] = '\0';
11364:../src/src/tls.c **** 
11365:../src/src/tls.c ****                 ssl->options.cipherSuite0 = cipherSuite0;
11366:../src/src/tls.c ****                 ssl->options.cipherSuite  = cipherSuite;
11367:../src/src/tls.c ****                 (void)cipherSuiteFlags;
11368:../src/src/tls.c ****                 ret = SetCipherSpecs(ssl);
11369:../src/src/tls.c ****                 if (ret != 0)
11370:../src/src/tls.c ****                     return ret;
11371:../src/src/tls.c **** 
11372:../src/src/tls.c ****                 ret = TLSX_PreSharedKey_Use(ssl,
11373:../src/src/tls.c ****                                   (byte*)ssl->arrays->client_identity,
11374:../src/src/tls.c ****                                   (word16)XSTRLEN(ssl->arrays->client_identity),
11375:../src/src/tls.c ****                                   0, ssl->specs.mac_algorithm,
11376:../src/src/tls.c ****                                   cipherSuite0, cipherSuite, 0,
11377:../src/src/tls.c ****                                   NULL);
11378:../src/src/tls.c ****                 if (ret != 0)
11379:../src/src/tls.c ****                     return ret;
11380:../src/src/tls.c **** 
11381:../src/src/tls.c ****                 usingPSK = 1;
11382:../src/src/tls.c ****         #if defined(OPENSSL_EXTRA)
11383:../src/src/tls.c ****                 }
11384:../src/src/tls.c ****         #endif
11385:../src/src/tls.c ****             }
11386:../src/src/tls.c ****     #endif /* !NO_PSK */
11387:../src/src/tls.c ****         #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11388:../src/src/tls.c ****             if (usingPSK) {
11389:../src/src/tls.c ****                 byte modes;
11390:../src/src/tls.c **** 
11391:../src/src/tls.c ****                 /* Pre-shared key modes: mandatory extension for resumption. */
11392:../src/src/tls.c ****                 modes = 1 << PSK_KE;
11393:../src/src/tls.c ****             #if !defined(NO_DH) || defined(HAVE_ECC) || \
11394:../src/src/tls.c ****                               defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
11395:../src/src/tls.c ****                 if (!ssl->options.noPskDheKe)
11396:../src/src/tls.c ****                     modes |= 1 << PSK_DHE_KE;
11397:../src/src/tls.c ****             #endif
11398:../src/src/tls.c ****                 ret = TLSX_PskKeModes_Use(ssl, modes);
11399:../src/src/tls.c ****                 if (ret != 0)
11400:../src/src/tls.c ****                     return ret;
11401:../src/src/tls.c ****             }
11402:../src/src/tls.c ****         #endif
11403:../src/src/tls.c ****         #if defined(WOLFSSL_POST_HANDSHAKE_AUTH)
11404:../src/src/tls.c ****             if (!isServer && ssl->options.postHandshakeAuth) {
11405:../src/src/tls.c ****                 ret = TLSX_PostHandAuth_Use(ssl);
11406:../src/src/tls.c ****                 if (ret != 0)
11407:../src/src/tls.c ****                     return ret;
11408:../src/src/tls.c ****             }
11409:../src/src/tls.c ****         #endif
11410:../src/src/tls.c ****         }
11411:../src/src/tls.c **** 
11412:../src/src/tls.c **** #endif
11413:../src/src/tls.c **** 
11414:../src/src/tls.c ****     (void)isServer;
11415:../src/src/tls.c ****     (void)public_key;
11416:../src/src/tls.c ****     (void)public_key_len;
11417:../src/src/tls.c ****     (void)ssl;
11418:../src/src/tls.c **** 
11419:../src/src/tls.c ****     return ret;
 7120                             		.loc 2 11419 12
 7121 0106 EC A5                   		mov.L	[r10], r5
 7122                             		.balign 8,3,1
 7123                             	.L533:
11420:../src/src/tls.c **** }
 7124                             		.loc 2 11420 1
 7125 0108 EF 51                   		mov.L	r5, r1
 7126 010a 3F AA 07                		rtsd	#28, r10-r10
 7127                             	.LFE107:
 7129 010d FC 13 00                		.section	.text.TLSX_GetRequestSize,"ax",@progbits
 7130                             		.global	_TLSX_GetRequestSize
 7132                             	_TLSX_GetRequestSize:
 7133                             	.LFB108:
11421:../src/src/tls.c **** 
11422:../src/src/tls.c **** 
11423:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) || !defined(NO_WOLFSSL_CLIENT)
11424:../src/src/tls.c **** 
11425:../src/src/tls.c **** /** Tells the buffered size of extensions to be sent into the client hello. */
11426:../src/src/tls.c **** int TLSX_GetRequestSize(WOLFSSL* ssl, byte msgType, word16* pLength)
11427:../src/src/tls.c **** {
 7134                             		.loc 2 11427 1
 7135 0000 6E 6A                   		pushm	r6-r10
 7136                             	.LCFI167:
 7137 0002 71 0A E4                		add	#-28, r0, r10
 7138                             	.LCFI168:
 7139 0005 EF A0                   		mov.L	r10, r0
 7140 0007 E7 A1 04                		mov.L	r1, 16[r10]
 7141 000a C7 A2 14                		mov.B	r2, 20[r10]
 7142 000d E7 A3 06                		mov.L	r3, 24[r10]
11428:../src/src/tls.c ****     int ret = 0;
 7143                             		.loc 2 11428 9
 7144 0010 F8 A6 00                		mov.L	#0, [r10]
11429:../src/src/tls.c ****     word16 length = 0;
 7145                             		.loc 2 11429 12
 7146 0013 F9 A5 02 00             		mov.W	#0, 4[r10]
11430:../src/src/tls.c ****     byte semaphore[SEMAPHORE_SIZE] = {0};
 7147                             		.loc 2 11430 10
 7148 0017 71 A4 06                		add	#6, r10, r4
 7149 001a 66 05                   		mov.L	#0, r5
 7150 001c 66 06                   		mov.L	#0, r6
 7151 001e E3 45                   		mov.L	r5, [r4]
 7152 0020 A0 4E                   		mov.L	r6, 4[r4]
11431:../src/src/tls.c **** 
11432:../src/src/tls.c ****     if (!TLSX_SupportExtensions(ssl))
 7153                             		.loc 2 11432 10
 7154 0022 ED A1 04                		mov.L	16[r10], r1
 7155 0025 05 00 00 00             		bsr	_TLSX_SupportExtensions
 7156 0029 EF 15                   		mov.L	r1, r5
 7157                             		.loc 2 11432 8
 7158 002b 61 05                   		cmp	#0, r5
 7159 002d 1E                      		bne	.L537
11433:../src/src/tls.c ****         return 0;
 7160                             		.loc 2 11433 16
 7161 002e 66 05                   		mov.L	#0, r5
 7162 0030 38 74 01                		bra	.L544
 7163                             	.L537:
11434:../src/src/tls.c ****     if (msgType == client_hello) {
 7164                             		.loc 2 11434 8
 7165 0033 59 A5 14                		movu.B	20[r10], r5
 7166 0036 61 15                   		cmp	#1, r5
 7167 0038 3B E8 00                		bne	.L539
11435:../src/src/tls.c ****         EC_VALIDATE_REQUEST(ssl, semaphore);
 7168                             		.loc 2 11435 9
 7169 003b 71 A5 06                		add	#6, r10, r5
 7170 003e EF 52                   		mov.L	r5, r2
 7171 0040 ED A1 04                		mov.L	16[r10], r1
 7172 0043 05 00 00 00             		bsr	_TLSX_SupportedCurve_ValidateRequest
11436:../src/src/tls.c ****         PF_VALIDATE_REQUEST(ssl, semaphore);
 7173                             		.loc 2 11436 9
 7174 0047 71 A5 06                		add	#6, r10, r5
 7175 004a EF 52                   		mov.L	r5, r2
 7176 004c ED A1 04                		mov.L	16[r10], r1
 7177 004f 05 00 00 00             		bsr	_TLSX_PointFormat_ValidateRequest
11437:../src/src/tls.c ****         WOLF_STK_VALIDATE_REQUEST(ssl);
11438:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
11439:../src/src/tls.c ****         if (ssl->suites->hashSigAlgoSz == 0)
 7178                             		.loc 2 11439 16
 7179 0053 ED A5 04                		mov.L	16[r10], r5
 7180 0056 A8 5D                   		mov.L	4[r5], r5
 7181                             		.loc 2 11439 24
 7182 0058 98 5D                   		mov.W	2[r5], r5
 7183                             		.loc 2 11439 12
 7184 005a 5F 55                   		movu.W	r5, r5
 7185 005c 61 05                   		cmp	#0, r5
 7186 005e 21 3B                   		bne	.L540
11440:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SIGNATURE_ALGORITHMS));
 7187                             		.loc 2 11440 13
 7188 0060 66 D1                   		mov	#13, r1
 7189 0062 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7190 0066 EF 15                   		mov.L	r1, r5
 7191 0068 5F 55                   		movu.W	r5, r5
 7192 006a 64 75                   		and	#7, r5
 7193 006c 66 14                   		mov.L	#1, r4
 7194 006e EF 47                   		mov.L	r4, r7
 7195 0070 FD 62 57                		shll	r5, r7
 7196 0073 EF 75                   		mov.L	r7, r5
 7197 0075 CF 56                   		mov.B	r5, r6
 7198 0077 66 D1                   		mov	#13, r1
 7199 0079 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7200 007d EF 15                   		mov.L	r1, r5
 7201 007f 5F 55                   		movu.W	r5, r5
 7202 0081 68 35                   		shlr	#3, r5
 7203 0083 DF 53                   		mov.W	r5, r3
 7204 0085 5F 35                   		movu.W	r3, r5
 7205 0087 71 A4 06                		add	#6, r10, r4
 7206 008a FE 45 44                		mov.B	[r5,r4], r4
 7207 008d 5F 35                   		movu.W	r3, r5
 7208 008f 57 64                   		or	r6, r4
 7209 0091 CF 43                   		mov.B	r4, r3
 7210 0093 71 A4 06                		add	#6, r10, r4
 7211 0096 FE 05 43                		mov.B	r3, [r5,r4]
 7212                             	.L540:
11441:../src/src/tls.c **** #endif
11442:../src/src/tls.c **** #if defined(WOLFSSL_TLS13)
11443:../src/src/tls.c ****         if (!IsAtLeastTLSv1_2(ssl))
11444:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SUPPORTED_VERSIONS));
11445:../src/src/tls.c ****     #if !defined(WOLFSSL_NO_TLS12) || !defined(NO_OLD_TLS)
11446:../src/src/tls.c ****         if (!IsAtLeastTLSv1_3(ssl->version)) {
11447:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11448:../src/src/tls.c ****         #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11449:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_PRE_SHARED_KEY));
11450:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_PSK_KEY_EXCHANGE_MODES));
11451:../src/src/tls.c ****         #endif
11452:../src/src/tls.c ****         #ifdef WOLFSSL_EARLY_DATA
11453:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_EARLY_DATA));
11454:../src/src/tls.c ****         #endif
11455:../src/src/tls.c ****         #ifdef WOLFSSL_SEND_HRR_COOKIE
11456:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_COOKIE));
11457:../src/src/tls.c ****         #endif
11458:../src/src/tls.c ****         #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
11459:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_POST_HANDSHAKE_AUTH));
11460:../src/src/tls.c ****         #endif
11461:../src/src/tls.c ****         }
11462:../src/src/tls.c ****     #endif
11463:../src/src/tls.c **** #endif
11464:../src/src/tls.c ****     #if defined(HAVE_CERTIFICATE_STATUS_REQUEST) \
11465:../src/src/tls.c ****      || defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2)
11466:../src/src/tls.c ****         if (!SSL_CM(ssl)->ocspStaplingEnabled) {
 7213                             		.loc 2 11466 14
 7214 0099 ED A5 04                		mov.L	16[r10], r5
 7215 009c EC 55                   		mov.L	[r5], r5
 7216 009e AB DD                   		mov.L	60[r5], r5
 7217                             		.loc 2 11466 13
 7218 00a0 CD 55 5C                		mov.B	92[r5], r5
 7219 00a3 75 25 40                		and	#0x40, r5
 7220                             		.loc 2 11466 12
 7221 00a6 5B 55                   		movu.B	r5, r5
 7222 00a8 61 05                   		cmp	#0, r5
 7223 00aa 21 76                   		bne	.L539
11467:../src/src/tls.c ****             /* mark already sent, so it won't send it */
11468:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST));
 7224                             		.loc 2 11468 13
 7225 00ac 66 51                   		mov	#5, r1
 7226 00ae 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7227 00b2 EF 15                   		mov.L	r1, r5
 7228 00b4 5F 55                   		movu.W	r5, r5
 7229 00b6 64 75                   		and	#7, r5
 7230 00b8 66 14                   		mov.L	#1, r4
 7231 00ba EF 47                   		mov.L	r4, r7
 7232 00bc FD 62 57                		shll	r5, r7
 7233 00bf EF 75                   		mov.L	r7, r5
 7234 00c1 CF 56                   		mov.B	r5, r6
 7235 00c3 66 51                   		mov	#5, r1
 7236 00c5 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7237 00c9 EF 15                   		mov.L	r1, r5
 7238 00cb 5F 55                   		movu.W	r5, r5
 7239 00cd 68 35                   		shlr	#3, r5
 7240 00cf DF 53                   		mov.W	r5, r3
 7241 00d1 5F 35                   		movu.W	r3, r5
 7242 00d3 71 A4 06                		add	#6, r10, r4
 7243 00d6 FE 45 44                		mov.B	[r5,r4], r4
 7244 00d9 5F 35                   		movu.W	r3, r5
 7245 00db 57 64                   		or	r6, r4
 7246 00dd CF 43                   		mov.B	r4, r3
 7247 00df 71 A4 06                		add	#6, r10, r4
 7248 00e2 FE 05 43                		mov.B	r3, [r5,r4]
11469:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST_V2));
 7249                             		.loc 2 11469 13
 7250 00e5 75 41 11                		mov	#17, r1
 7251 00e8 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7252 00ec EF 15                   		mov.L	r1, r5
 7253 00ee 5F 55                   		movu.W	r5, r5
 7254 00f0 64 75                   		and	#7, r5
 7255 00f2 66 14                   		mov.L	#1, r4
 7256 00f4 EF 47                   		mov.L	r4, r7
 7257 00f6 FD 62 57                		shll	r5, r7
 7258 00f9 EF 75                   		mov.L	r7, r5
 7259 00fb CF 56                   		mov.B	r5, r6
 7260 00fd 75 41 11                		mov	#17, r1
 7261 0100 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7262 0104 EF 15                   		mov.L	r1, r5
 7263 0106 5F 55                   		movu.W	r5, r5
 7264 0108 68 35                   		shlr	#3, r5
 7265 010a DF 53                   		mov.W	r5, r3
 7266 010c 5F 35                   		movu.W	r3, r5
 7267 010e 71 A4 06                		add	#6, r10, r4
 7268 0111 FE 45 44                		mov.B	[r5,r4], r4
 7269 0114 5F 35                   		movu.W	r3, r5
 7270 0116 57 64                   		or	r6, r4
 7271 0118 CF 43                   		mov.B	r4, r3
 7272 011a 71 A4 06                		add	#6, r10, r4
 7273 011d FE 05 43                		mov.B	r3, [r5,r4]
 7274                             	.L539:
11470:../src/src/tls.c ****         }
11471:../src/src/tls.c ****     #endif
11472:../src/src/tls.c ****     }
11473:../src/src/tls.c **** 
11474:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
11475:../src/src/tls.c ****     #ifndef NO_CERTS
11476:../src/src/tls.c ****     else if (msgType == certificate_request) {
11477:../src/src/tls.c ****         /* Don't send out any extension except those that are turned off. */
11478:../src/src/tls.c ****         XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11479:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
11480:../src/src/tls.c ****         TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_SIGNATURE_ALGORITHMS));
11481:../src/src/tls.c **** #endif
11482:../src/src/tls.c ****         /* TODO: TLSX_SIGNED_CERTIFICATE_TIMESTAMP,
11483:../src/src/tls.c ****          *       TLSX_CERTIFICATE_AUTHORITIES, OID_FILTERS
11484:../src/src/tls.c ****          *       TLSX_STATUS_REQUEST
11485:../src/src/tls.c ****          */
11486:../src/src/tls.c ****     }
11487:../src/src/tls.c ****     #endif
11488:../src/src/tls.c **** #endif
11489:../src/src/tls.c ****     if (ssl->extensions) {
 7275                             		.loc 2 11489 12
 7276 0120 ED A5 04                		mov.L	16[r10], r5
 7277 0123 ED 55 BF                		mov.L	764[r5], r5
 7278                             		.loc 2 11489 8
 7279 0126 61 05                   		cmp	#0, r5
 7280 0128 20 22                   		beq	.L541
11490:../src/src/tls.c ****         ret = TLSX_GetSize(ssl->extensions, semaphore, msgType, &length);
 7281                             		.loc 2 11490 15
 7282 012a ED A5 04                		mov.L	16[r10], r5
 7283 012d ED 51 BF                		mov.L	764[r5], r1
 7284 0130 71 A4 04                		add	#4, r10, r4
 7285 0133 71 A5 06                		add	#6, r10, r5
 7286 0136 CD A3 14                		mov.B	20[r10], r3
 7287 0139 EF 52                   		mov.L	r5, r2
 7288 013b 05 00 00 00             		bsr	_TLSX_GetSize
 7289 013f E3 A1                   		mov.L	r1, [r10]
11491:../src/src/tls.c ****         if (ret != 0)
 7290                             		.loc 2 11491 12
 7291 0141 EC A5                   		mov.L	[r10], r5
 7292 0143 61 05                   		cmp	#0, r5
 7293 0145 15                      		beq	.L541
11492:../src/src/tls.c ****             return ret;
 7294                             		.loc 2 11492 20
 7295 0146 EC A5                   		mov.L	[r10], r5
 7296 0148 2E 5C                   		bra	.L544
 7297                             	.L541:
11493:../src/src/tls.c ****     }
11494:../src/src/tls.c ****     if (ssl->ctx && ssl->ctx->extensions) {
 7298                             		.loc 2 11494 12
 7299 014a ED A5 04                		mov.L	16[r10], r5
 7300 014d EC 55                   		mov.L	[r5], r5
 7301                             		.loc 2 11494 8
 7302 014f 61 05                   		cmp	#0, r5
 7303 0151 20 30                   		beq	.L542
 7304                             		.loc 2 11494 24 discriminator 1
 7305 0153 ED A5 04                		mov.L	16[r10], r5
 7306 0156 EC 55                   		mov.L	[r5], r5
 7307                             		.loc 2 11494 29 discriminator 1
 7308 0158 ED 55 49                		mov.L	292[r5], r5
 7309                             		.loc 2 11494 18 discriminator 1
 7310 015b 61 05                   		cmp	#0, r5
 7311 015d 20 24                   		beq	.L542
11495:../src/src/tls.c ****         ret = TLSX_GetSize(ssl->ctx->extensions, semaphore, msgType, &length);
 7312                             		.loc 2 11495 31
 7313 015f ED A5 04                		mov.L	16[r10], r5
 7314 0162 EC 55                   		mov.L	[r5], r5
 7315                             		.loc 2 11495 15
 7316 0164 ED 51 49                		mov.L	292[r5], r1
 7317 0167 71 A4 04                		add	#4, r10, r4
 7318 016a 71 A5 06                		add	#6, r10, r5
 7319 016d CD A3 14                		mov.B	20[r10], r3
 7320 0170 EF 52                   		mov.L	r5, r2
 7321 0172 05 00 00 00             		bsr	_TLSX_GetSize
 7322 0176 E3 A1                   		mov.L	r1, [r10]
11496:../src/src/tls.c ****         if (ret != 0)
 7323                             		.loc 2 11496 12
 7324 0178 EC A5                   		mov.L	[r10], r5
 7325 017a 61 05                   		cmp	#0, r5
 7326 017c 15                      		beq	.L542
11497:../src/src/tls.c ****             return ret;
 7327                             		.loc 2 11497 20
 7328 017d EC A5                   		mov.L	[r10], r5
 7329 017f 2E 25                   		bra	.L544
 7330                             	.L542:
11498:../src/src/tls.c ****     }
11499:../src/src/tls.c **** 
11500:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
11501:../src/src/tls.c ****     if (msgType == client_hello && ssl->options.haveEMS &&
11502:../src/src/tls.c ****                   (!IsAtLeastTLSv1_3(ssl->version) || ssl->options.downgrade)) {
11503:../src/src/tls.c ****         length += HELLO_EXT_SZ;
11504:../src/src/tls.c ****     }
11505:../src/src/tls.c **** #endif
11506:../src/src/tls.c **** 
11507:../src/src/tls.c ****     if (length)
 7331                             		.loc 2 11507 9
 7332 0181 DD A5 02                		mov.W	4[r10], r5
 7333                             		.loc 2 11507 8
 7334 0184 5F 55                   		movu.W	r5, r5
 7335 0186 61 05                   		cmp	#0, r5
 7336 0188 11                      		beq	.L543
11508:../src/src/tls.c ****         length += OPAQUE16_LEN; /* for total length storage. */
 7337                             		.loc 2 11508 16
 7338 0189 DD A5 02                		mov.W	4[r10], r5
 7339 018c 62 25                   		add	#2, r5
 7340 018e D7 A5 02                		mov.W	r5, 4[r10]
 7341                             	.L543:
11509:../src/src/tls.c **** 
11510:../src/src/tls.c ****     *pLength += length;
 7342                             		.loc 2 11510 14
 7343 0191 ED A5 06                		mov.L	24[r10], r5
 7344 0194 DC 54                   		mov.W	[r5], r4
 7345 0196 DD A5 02                		mov.W	4[r10], r5
 7346 0199 4B 45                   		add	r4, r5
 7347 019b DF 54                   		mov.W	r5, r4
 7348 019d ED A5 06                		mov.L	24[r10], r5
 7349 01a0 D3 54                   		mov.W	r4, [r5]
11511:../src/src/tls.c **** 
11512:../src/src/tls.c ****     return ret;
 7350                             		.loc 2 11512 12
 7351 01a2 EC A5                   		mov.L	[r10], r5
 7352                             		.balign 8,3,1
 7353                             	.L544:
11513:../src/src/tls.c **** }
 7354                             		.loc 2 11513 1 discriminator 1
 7355 01a4 EF 51                   		mov.L	r5, r1
 7356 01a6 3F 6A 0C                		rtsd	#48, r6-r10
 7357                             	.LFE108:
 7359 01a9 FD 70 40 00 00 00 80    		.section	.text.TLSX_WriteRequest,"ax",@progbits
 7360                             		.global	_TLSX_WriteRequest
 7362                             	_TLSX_WriteRequest:
 7363                             	.LFB109:
11514:../src/src/tls.c **** 
11515:../src/src/tls.c **** /** Writes the extensions to be sent into the client hello. */
11516:../src/src/tls.c **** int TLSX_WriteRequest(WOLFSSL* ssl, byte* output, byte msgType, word16* pOffset)
11517:../src/src/tls.c **** {
 7364                             		.loc 2 11517 1
 7365 0000 6E 6A                   		pushm	r6-r10
 7366                             	.LCFI169:
 7367 0002 71 0A E0                		add	#-32, r0, r10
 7368                             	.LCFI170:
 7369 0005 71 A0 FC                		add	#-4, r10, r0
 7370                             	.LCFI171:
 7371 0008 E7 A1 04                		mov.L	r1, 16[r10]
 7372 000b E7 A2 05                		mov.L	r2, 20[r10]
 7373 000e C7 A3 18                		mov.B	r3, 24[r10]
 7374 0011 E7 A4 07                		mov.L	r4, 28[r10]
11518:../src/src/tls.c ****     int ret = 0;
 7375                             		.loc 2 11518 9
 7376 0014 F8 A6 00                		mov.L	#0, [r10]
11519:../src/src/tls.c ****     word16 offset = 0;
 7377                             		.loc 2 11519 12
 7378 0017 F9 A5 02 00             		mov.W	#0, 4[r10]
11520:../src/src/tls.c ****     byte semaphore[SEMAPHORE_SIZE] = {0};
 7379                             		.loc 2 11520 10
 7380 001b 71 A4 06                		add	#6, r10, r4
 7381 001e 66 05                   		mov.L	#0, r5
 7382 0020 66 06                   		mov.L	#0, r6
 7383 0022 E3 45                   		mov.L	r5, [r4]
 7384 0024 A0 4E                   		mov.L	r6, 4[r4]
11521:../src/src/tls.c **** 
11522:../src/src/tls.c ****     if (!TLSX_SupportExtensions(ssl) || output == NULL)
 7385                             		.loc 2 11522 10
 7386 0026 ED A1 04                		mov.L	16[r10], r1
 7387 0029 05 00 00 00             		bsr	_TLSX_SupportExtensions
 7388 002d EF 15                   		mov.L	r1, r5
 7389                             		.loc 2 11522 8
 7390 002f 61 05                   		cmp	#0, r5
 7391 0031 17                      		beq	.L546
 7392                             		.loc 2 11522 38 discriminator 1
 7393 0032 ED A5 05                		mov.L	20[r10], r5
 7394 0035 61 05                   		cmp	#0, r5
 7395 0037 1E                      		bne	.L547
 7396                             	.L546:
11523:../src/src/tls.c ****         return 0;
 7397                             		.loc 2 11523 16
 7398 0038 66 05                   		mov.L	#0, r5
 7399 003a 38 A2 01                		bra	.L555
 7400                             	.L547:
11524:../src/src/tls.c **** 
11525:../src/src/tls.c ****     offset += OPAQUE16_LEN; /* extensions length */
 7401                             		.loc 2 11525 12
 7402 003d DD A5 02                		mov.W	4[r10], r5
 7403 0040 62 25                   		add	#2, r5
 7404 0042 D7 A5 02                		mov.W	r5, 4[r10]
11526:../src/src/tls.c **** 
11527:../src/src/tls.c ****     if (msgType == client_hello) {
 7405                             		.loc 2 11527 8
 7406 0045 59 A5 18                		movu.B	24[r10], r5
 7407 0048 61 15                   		cmp	#1, r5
 7408 004a 3B E8 00                		bne	.L549
11528:../src/src/tls.c ****         EC_VALIDATE_REQUEST(ssl, semaphore);
 7409                             		.loc 2 11528 9
 7410 004d 71 A5 06                		add	#6, r10, r5
 7411 0050 EF 52                   		mov.L	r5, r2
 7412 0052 ED A1 04                		mov.L	16[r10], r1
 7413 0055 05 00 00 00             		bsr	_TLSX_SupportedCurve_ValidateRequest
11529:../src/src/tls.c ****         PF_VALIDATE_REQUEST(ssl, semaphore);
 7414                             		.loc 2 11529 9
 7415 0059 71 A5 06                		add	#6, r10, r5
 7416 005c EF 52                   		mov.L	r5, r2
 7417 005e ED A1 04                		mov.L	16[r10], r1
 7418 0061 05 00 00 00             		bsr	_TLSX_PointFormat_ValidateRequest
11530:../src/src/tls.c ****         WOLF_STK_VALIDATE_REQUEST(ssl);
11531:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
11532:../src/src/tls.c ****         if (ssl->suites->hashSigAlgoSz == 0)
 7419                             		.loc 2 11532 16
 7420 0065 ED A5 04                		mov.L	16[r10], r5
 7421 0068 A8 5D                   		mov.L	4[r5], r5
 7422                             		.loc 2 11532 24
 7423 006a 98 5D                   		mov.W	2[r5], r5
 7424                             		.loc 2 11532 12
 7425 006c 5F 55                   		movu.W	r5, r5
 7426 006e 61 05                   		cmp	#0, r5
 7427 0070 21 3B                   		bne	.L550
11533:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SIGNATURE_ALGORITHMS));
 7428                             		.loc 2 11533 13
 7429 0072 66 D1                   		mov	#13, r1
 7430 0074 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7431 0078 EF 15                   		mov.L	r1, r5
 7432 007a 5F 55                   		movu.W	r5, r5
 7433 007c 64 75                   		and	#7, r5
 7434 007e 66 14                   		mov.L	#1, r4
 7435 0080 EF 47                   		mov.L	r4, r7
 7436 0082 FD 62 57                		shll	r5, r7
 7437 0085 EF 75                   		mov.L	r7, r5
 7438 0087 CF 56                   		mov.B	r5, r6
 7439 0089 66 D1                   		mov	#13, r1
 7440 008b 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7441 008f EF 15                   		mov.L	r1, r5
 7442 0091 5F 55                   		movu.W	r5, r5
 7443 0093 68 35                   		shlr	#3, r5
 7444 0095 DF 53                   		mov.W	r5, r3
 7445 0097 5F 35                   		movu.W	r3, r5
 7446 0099 71 A4 06                		add	#6, r10, r4
 7447 009c FE 45 44                		mov.B	[r5,r4], r4
 7448 009f 5F 35                   		movu.W	r3, r5
 7449 00a1 57 64                   		or	r6, r4
 7450 00a3 CF 43                   		mov.B	r4, r3
 7451 00a5 71 A4 06                		add	#6, r10, r4
 7452 00a8 FE 05 43                		mov.B	r3, [r5,r4]
 7453                             	.L550:
11534:../src/src/tls.c **** #endif
11535:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
11536:../src/src/tls.c ****         if (!IsAtLeastTLSv1_2(ssl))
11537:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SUPPORTED_VERSIONS));
11538:../src/src/tls.c ****     #if !defined(WOLFSSL_NO_TLS12) || !defined(NO_OLD_TLS)
11539:../src/src/tls.c ****         if (!IsAtLeastTLSv1_3(ssl->version)) {
11540:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11541:../src/src/tls.c ****         #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11542:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_PSK_KEY_EXCHANGE_MODES));
11543:../src/src/tls.c ****         #endif
11544:../src/src/tls.c ****         #ifdef WOLFSSL_EARLY_DATA
11545:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_EARLY_DATA));
11546:../src/src/tls.c ****         #endif
11547:../src/src/tls.c ****         #ifdef WOLFSSL_SEND_HRR_COOKIE
11548:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_COOKIE));
11549:../src/src/tls.c ****         #endif
11550:../src/src/tls.c ****         #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
11551:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_POST_HANDSHAKE_AUTH));
11552:../src/src/tls.c ****         #endif
11553:../src/src/tls.c ****         }
11554:../src/src/tls.c ****     #endif
11555:../src/src/tls.c ****     #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11556:../src/src/tls.c ****         /* Must write Pre-shared Key extension at the end in TLS v1.3.
11557:../src/src/tls.c ****          * Must not write out Pre-shared Key extension in earlier versions of
11558:../src/src/tls.c ****          * protocol.
11559:../src/src/tls.c ****          */
11560:../src/src/tls.c ****         TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_PRE_SHARED_KEY));
11561:../src/src/tls.c ****     #endif
11562:../src/src/tls.c **** #endif
11563:../src/src/tls.c ****     #if defined(HAVE_CERTIFICATE_STATUS_REQUEST) \
11564:../src/src/tls.c ****      || defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2)
11565:../src/src/tls.c ****          /* mark already sent, so it won't send it */
11566:../src/src/tls.c ****         if (!SSL_CM(ssl)->ocspStaplingEnabled) {
 7454                             		.loc 2 11566 14
 7455 00ab ED A5 04                		mov.L	16[r10], r5
 7456 00ae EC 55                   		mov.L	[r5], r5
 7457 00b0 AB DD                   		mov.L	60[r5], r5
 7458                             		.loc 2 11566 13
 7459 00b2 CD 55 5C                		mov.B	92[r5], r5
 7460 00b5 75 25 40                		and	#0x40, r5
 7461                             		.loc 2 11566 12
 7462 00b8 5B 55                   		movu.B	r5, r5
 7463 00ba 61 05                   		cmp	#0, r5
 7464 00bc 21 76                   		bne	.L549
11567:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST));
 7465                             		.loc 2 11567 13
 7466 00be 66 51                   		mov	#5, r1
 7467 00c0 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7468 00c4 EF 15                   		mov.L	r1, r5
 7469 00c6 5F 55                   		movu.W	r5, r5
 7470 00c8 64 75                   		and	#7, r5
 7471 00ca 66 14                   		mov.L	#1, r4
 7472 00cc EF 47                   		mov.L	r4, r7
 7473 00ce FD 62 57                		shll	r5, r7
 7474 00d1 EF 75                   		mov.L	r7, r5
 7475 00d3 CF 56                   		mov.B	r5, r6
 7476 00d5 66 51                   		mov	#5, r1
 7477 00d7 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7478 00db EF 15                   		mov.L	r1, r5
 7479 00dd 5F 55                   		movu.W	r5, r5
 7480 00df 68 35                   		shlr	#3, r5
 7481 00e1 DF 53                   		mov.W	r5, r3
 7482 00e3 5F 35                   		movu.W	r3, r5
 7483 00e5 71 A4 06                		add	#6, r10, r4
 7484 00e8 FE 45 44                		mov.B	[r5,r4], r4
 7485 00eb 5F 35                   		movu.W	r3, r5
 7486 00ed 57 64                   		or	r6, r4
 7487 00ef CF 43                   		mov.B	r4, r3
 7488 00f1 71 A4 06                		add	#6, r10, r4
 7489 00f4 FE 05 43                		mov.B	r3, [r5,r4]
11568:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST_V2));
 7490                             		.loc 2 11568 13
 7491 00f7 75 41 11                		mov	#17, r1
 7492 00fa 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7493 00fe EF 15                   		mov.L	r1, r5
 7494 0100 5F 55                   		movu.W	r5, r5
 7495 0102 64 75                   		and	#7, r5
 7496 0104 66 14                   		mov.L	#1, r4
 7497 0106 EF 47                   		mov.L	r4, r7
 7498 0108 FD 62 57                		shll	r5, r7
 7499 010b EF 75                   		mov.L	r7, r5
 7500 010d CF 56                   		mov.B	r5, r6
 7501 010f 75 41 11                		mov	#17, r1
 7502 0112 05 00 00 00             		bsr	_TLSX_ToSemaphore
 7503 0116 EF 15                   		mov.L	r1, r5
 7504 0118 5F 55                   		movu.W	r5, r5
 7505 011a 68 35                   		shlr	#3, r5
 7506 011c DF 53                   		mov.W	r5, r3
 7507 011e 5F 35                   		movu.W	r3, r5
 7508 0120 71 A4 06                		add	#6, r10, r4
 7509 0123 FE 45 44                		mov.B	[r5,r4], r4
 7510 0126 5F 35                   		movu.W	r3, r5
 7511 0128 57 64                   		or	r6, r4
 7512 012a CF 43                   		mov.B	r4, r3
 7513 012c 71 A4 06                		add	#6, r10, r4
 7514 012f FE 05 43                		mov.B	r3, [r5,r4]
 7515                             	.L549:
11569:../src/src/tls.c ****         }
11570:../src/src/tls.c ****     #endif
11571:../src/src/tls.c ****     }
11572:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
11573:../src/src/tls.c ****     #ifndef NO_CERTS
11574:../src/src/tls.c ****     else if (msgType == certificate_request) {
11575:../src/src/tls.c ****         /* Don't send out any extension except those that are turned off. */
11576:../src/src/tls.c ****         XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11577:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
11578:../src/src/tls.c ****         TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_SIGNATURE_ALGORITHMS));
11579:../src/src/tls.c **** #endif
11580:../src/src/tls.c ****         /* TODO: TLSX_SIGNED_CERTIFICATE_TIMESTAMP,
11581:../src/src/tls.c ****          *       TLSX_CERTIFICATE_AUTHORITIES, TLSX_OID_FILTERS
11582:../src/src/tls.c ****          *       TLSX_STATUS_REQUEST
11583:../src/src/tls.c ****          */
11584:../src/src/tls.c ****     }
11585:../src/src/tls.c ****     #endif
11586:../src/src/tls.c **** #endif
11587:../src/src/tls.c ****     if (ssl->extensions) {
 7516                             		.loc 2 11587 12
 7517 0132 ED A5 04                		mov.L	16[r10], r5
 7518 0135 ED 55 BF                		mov.L	764[r5], r5
 7519                             		.loc 2 11587 8
 7520 0138 61 05                   		cmp	#0, r5
 7521 013a 20 2E                   		beq	.L551
11588:../src/src/tls.c ****         ret = TLSX_Write(ssl->extensions, output + offset, semaphore,
 7522                             		.loc 2 11588 15
 7523 013c ED A5 04                		mov.L	16[r10], r5
 7524 013f ED 51 BF                		mov.L	764[r5], r1
 7525 0142 DD A5 02                		mov.W	4[r10], r5
 7526 0145 5F 55                   		movu.W	r5, r5
 7527 0147 ED A4 05                		mov.L	20[r10], r4
 7528 014a 4B 45                   		add	r4, r5
 7529 014c 71 A3 06                		add	#6, r10, r3
 7530 014f 71 A4 04                		add	#4, r10, r4
 7531 0152 E3 04                   		mov.L	r4, [r0]
 7532 0154 CD A4 18                		mov.B	24[r10], r4
 7533 0157 EF 52                   		mov.L	r5, r2
 7534 0159 05 00 00 00             		bsr	_TLSX_Write
 7535 015d E3 A1                   		mov.L	r1, [r10]
11589:../src/src/tls.c ****                          msgType, &offset);
11590:../src/src/tls.c ****         if (ret != 0)
 7536                             		.loc 2 11590 12
 7537 015f EC A5                   		mov.L	[r10], r5
 7538 0161 61 05                   		cmp	#0, r5
 7539 0163 15                      		beq	.L551
11591:../src/src/tls.c ****             return ret;
 7540                             		.loc 2 11591 20
 7541 0164 EC A5                   		mov.L	[r10], r5
 7542 0166 2E 76                   		bra	.L555
 7543                             	.L551:
11592:../src/src/tls.c ****     }
11593:../src/src/tls.c ****     if (ssl->ctx && ssl->ctx->extensions) {
 7544                             		.loc 2 11593 12
 7545 0168 ED A5 04                		mov.L	16[r10], r5
 7546 016b EC 55                   		mov.L	[r5], r5
 7547                             		.loc 2 11593 8
 7548 016d 61 05                   		cmp	#0, r5
 7549 016f 20 3C                   		beq	.L552
 7550                             		.loc 2 11593 24 discriminator 1
 7551 0171 ED A5 04                		mov.L	16[r10], r5
 7552 0174 EC 55                   		mov.L	[r5], r5
 7553                             		.loc 2 11593 29 discriminator 1
 7554 0176 ED 55 49                		mov.L	292[r5], r5
 7555                             		.loc 2 11593 18 discriminator 1
 7556 0179 61 05                   		cmp	#0, r5
 7557 017b 20 30                   		beq	.L552
11594:../src/src/tls.c ****         ret = TLSX_Write(ssl->ctx->extensions, output + offset, semaphore,
 7558                             		.loc 2 11594 29
 7559 017d ED A5 04                		mov.L	16[r10], r5
 7560 0180 EC 55                   		mov.L	[r5], r5
 7561                             		.loc 2 11594 15
 7562 0182 ED 51 49                		mov.L	292[r5], r1
 7563 0185 DD A5 02                		mov.W	4[r10], r5
 7564 0188 5F 55                   		movu.W	r5, r5
 7565 018a ED A4 05                		mov.L	20[r10], r4
 7566 018d 4B 45                   		add	r4, r5
 7567 018f 71 A3 06                		add	#6, r10, r3
 7568 0192 71 A4 04                		add	#4, r10, r4
 7569 0195 E3 04                   		mov.L	r4, [r0]
 7570 0197 CD A4 18                		mov.B	24[r10], r4
 7571 019a EF 52                   		mov.L	r5, r2
 7572 019c 05 00 00 00             		bsr	_TLSX_Write
 7573 01a0 E3 A1                   		mov.L	r1, [r10]
11595:../src/src/tls.c ****                          msgType, &offset);
11596:../src/src/tls.c ****         if (ret != 0)
 7574                             		.loc 2 11596 12
 7575 01a2 EC A5                   		mov.L	[r10], r5
 7576 01a4 61 05                   		cmp	#0, r5
 7577 01a6 15                      		beq	.L552
11597:../src/src/tls.c ****             return ret;
 7578                             		.loc 2 11597 20
 7579 01a7 EC A5                   		mov.L	[r10], r5
 7580 01a9 2E 33                   		bra	.L555
 7581                             	.L552:
11598:../src/src/tls.c ****     }
11599:../src/src/tls.c **** 
11600:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
11601:../src/src/tls.c ****     if (msgType == client_hello && ssl->options.haveEMS &&
11602:../src/src/tls.c ****                   (!IsAtLeastTLSv1_3(ssl->version) || ssl->options.downgrade)) {
11603:../src/src/tls.c ****         WOLFSSL_MSG("EMS extension to write");
11604:../src/src/tls.c ****         c16toa(HELLO_EXT_EXTMS, output + offset);
11605:../src/src/tls.c ****         offset += HELLO_EXT_TYPE_SZ;
11606:../src/src/tls.c ****         c16toa(0, output + offset);
11607:../src/src/tls.c ****         offset += HELLO_EXT_SZ_SZ;
11608:../src/src/tls.c ****     }
11609:../src/src/tls.c **** #endif
11610:../src/src/tls.c **** 
11611:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
11612:../src/src/tls.c ****     #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11613:../src/src/tls.c ****     if (msgType == client_hello && IsAtLeastTLSv1_3(ssl->version)) {
11614:../src/src/tls.c ****         /* Write out what we can of Pre-shared key extension.  */
11615:../src/src/tls.c ****         TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_PRE_SHARED_KEY));
11616:../src/src/tls.c ****         ret = TLSX_Write(ssl->extensions, output + offset, semaphore,
11617:../src/src/tls.c ****                          client_hello, &offset);
11618:../src/src/tls.c ****         if (ret != 0)
11619:../src/src/tls.c ****             return ret;
11620:../src/src/tls.c ****     }
11621:../src/src/tls.c ****     #endif
11622:../src/src/tls.c **** #endif
11623:../src/src/tls.c **** 
11624:../src/src/tls.c ****     if (offset > OPAQUE16_LEN || msgType != client_hello)
 7582                             		.loc 2 11624 16
 7583 01ab DD A5 02                		mov.W	4[r10], r5
 7584                             		.loc 2 11624 8
 7585 01ae 5F 55                   		movu.W	r5, r5
 7586 01b0 61 25                   		cmp	#2, r5
 7587 01b2 24 09                   		bgtu	.L553
 7588                             		.loc 2 11624 31 discriminator 1
 7589 01b4 59 A5 18                		movu.B	24[r10], r5
 7590 01b7 61 15                   		cmp	#1, r5
 7591 01b9 20 10                   		beq	.L554
 7592                             	.L553:
11625:../src/src/tls.c ****         c16toa(offset - OPAQUE16_LEN, output); /* extensions length */
 7593                             		.loc 2 11625 9
 7594 01bb DD A5 02                		mov.W	4[r10], r5
 7595 01be 60 25                   		sub	#2, r5
 7596 01c0 ED A2 05                		mov.L	20[r10], r2
 7597 01c3 DF 51                   		mov.W	r5, r1
 7598 01c5 05 00 00 00             		bsr	_c16toa
 7599                             	.L554:
11626:../src/src/tls.c **** 
11627:../src/src/tls.c ****      *pOffset += offset;
 7600                             		.loc 2 11627 15
 7601 01c9 ED A5 07                		mov.L	28[r10], r5
 7602 01cc DC 54                   		mov.W	[r5], r4
 7603 01ce DD A5 02                		mov.W	4[r10], r5
 7604 01d1 4B 45                   		add	r4, r5
 7605 01d3 DF 54                   		mov.W	r5, r4
 7606 01d5 ED A5 07                		mov.L	28[r10], r5
 7607 01d8 D3 54                   		mov.W	r4, [r5]
11628:../src/src/tls.c **** 
11629:../src/src/tls.c ****     return ret;
 7608                             		.loc 2 11629 12
 7609 01da EC A5                   		mov.L	[r10], r5
 7610                             		.balign 8,3,1
 7611                             	.L555:
11630:../src/src/tls.c **** }
 7612                             		.loc 2 11630 1 discriminator 1
 7613 01dc EF 51                   		mov.L	r5, r1
 7614 01de 3F 6A 0E                		rtsd	#56, r6-r10
 7615                             	.LFE109:
 7617 01e1 FD 70 40 00 00 00 80    		.section	.text.TLSX_GetResponseSize,"ax",@progbits
 7618                             		.global	_TLSX_GetResponseSize
 7620                             	_TLSX_GetResponseSize:
 7621                             	.LFB110:
11631:../src/src/tls.c **** 
11632:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 || !NO_WOLFSSL_CLIENT */
11633:../src/src/tls.c **** 
11634:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) || !defined(NO_WOLFSSL_SERVER)
11635:../src/src/tls.c **** 
11636:../src/src/tls.c **** /** Tells the buffered size of extensions to be sent into the server hello. */
11637:../src/src/tls.c **** int TLSX_GetResponseSize(WOLFSSL* ssl, byte msgType, word16* pLength)
11638:../src/src/tls.c **** {
 7622                             		.loc 2 11638 1
 7623 0000 7E AA                   		push.l	r10
 7624                             	.LCFI172:
 7625 0002 7E A6                   		push.l	r6
 7626                             	.LCFI173:
 7627 0004 71 0A E4                		add	#-28, r0, r10
 7628                             	.LCFI174:
 7629 0007 EF A0                   		mov.L	r10, r0
 7630 0009 E7 A1 04                		mov.L	r1, 16[r10]
 7631 000c C7 A2 14                		mov.B	r2, 20[r10]
 7632 000f E7 A3 06                		mov.L	r3, 24[r10]
11639:../src/src/tls.c ****     int ret = 0;
 7633                             		.loc 2 11639 9
 7634 0012 F8 A6 00                		mov.L	#0, [r10]
11640:../src/src/tls.c ****     word16 length = 0;
 7635                             		.loc 2 11640 12
 7636 0015 F9 A5 02 00             		mov.W	#0, 4[r10]
11641:../src/src/tls.c ****     byte semaphore[SEMAPHORE_SIZE] = {0};
 7637                             		.loc 2 11641 10
 7638 0019 71 A4 06                		add	#6, r10, r4
 7639 001c 66 05                   		mov.L	#0, r5
 7640 001e 66 06                   		mov.L	#0, r6
 7641 0020 E3 45                   		mov.L	r5, [r4]
 7642 0022 A0 4E                   		mov.L	r6, 4[r4]
11642:../src/src/tls.c **** 
11643:../src/src/tls.c ****     switch (msgType) {
 7643                             		.loc 2 11643 5
 7644 0024 59 A5 14                		movu.B	20[r10], r5
 7645 0027 61 25                   		cmp	#2, r5
 7646 0029 21 0F                   		bne	.L557
11644:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
11645:../src/src/tls.c ****         case server_hello:
11646:../src/src/tls.c ****             PF_VALIDATE_RESPONSE(ssl, semaphore);
 7647                             		.loc 2 11646 13
 7648 002b 71 A5 06                		add	#6, r10, r5
 7649 002e EF 52                   		mov.L	r5, r2
 7650 0030 ED A1 04                		mov.L	16[r10], r1
 7651 0033 05 00 00 00             		bsr	_TLSX_PointFormat_ValidateResponse
11647:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
11648:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version)) {
11649:../src/src/tls.c ****                     XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11650:../src/src/tls.c ****                     TURN_OFF(semaphore,
11651:../src/src/tls.c ****                                      TLSX_ToSemaphore(TLSX_SUPPORTED_VERSIONS));
11652:../src/src/tls.c ****             #ifdef HAVE_SUPPORTED_CURVES
11653:../src/src/tls.c ****                     if (!ssl->options.noPskDheKe)
11654:../src/src/tls.c ****                         TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11655:../src/src/tls.c ****             #endif
11656:../src/src/tls.c ****         #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11657:../src/src/tls.c ****                     TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_PRE_SHARED_KEY));
11658:../src/src/tls.c ****         #endif
11659:../src/src/tls.c ****                 }
11660:../src/src/tls.c ****         #if !defined(WOLFSSL_NO_TLS12) || !defined(NO_OLD_TLS)
11661:../src/src/tls.c ****                 else {
11662:../src/src/tls.c ****             #ifdef HAVE_SUPPORTED_CURVES
11663:../src/src/tls.c ****                     TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11664:../src/src/tls.c ****             #endif
11665:../src/src/tls.c ****             #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11666:../src/src/tls.c ****                     TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_PRE_SHARED_KEY));
11667:../src/src/tls.c ****             #endif
11668:../src/src/tls.c ****                 }
11669:../src/src/tls.c ****         #endif
11670:../src/src/tls.c ****     #endif
11671:../src/src/tls.c ****             break;
 7652                             		.loc 2 11671 13
 7653 0037 03                      		nop
 7654                             	.L557:
11672:../src/src/tls.c **** 
11673:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
11674:../src/src/tls.c ****         case hello_retry_request:
11675:../src/src/tls.c ****             XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11676:../src/src/tls.c ****                 TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_SUPPORTED_VERSIONS));
11677:../src/src/tls.c ****         #ifdef HAVE_SUPPORTED_CURVES
11678:../src/src/tls.c ****             if (!ssl->options.noPskDheKe)
11679:../src/src/tls.c ****                 TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11680:../src/src/tls.c ****         #endif
11681:../src/src/tls.c ****         #ifdef WOLFSSL_SEND_HRR_COOKIE
11682:../src/src/tls.c ****             TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_COOKIE));
11683:../src/src/tls.c ****         #endif
11684:../src/src/tls.c ****             break;
11685:../src/src/tls.c ****     #endif
11686:../src/src/tls.c **** 
11687:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
11688:../src/src/tls.c ****         case encrypted_extensions:
11689:../src/src/tls.c ****             /* Send out all extension except those that are turned on. */
11690:../src/src/tls.c ****         #ifdef HAVE_ECC
11691:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_EC_POINT_FORMATS));
11692:../src/src/tls.c ****         #endif
11693:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SUPPORTED_VERSIONS));
11694:../src/src/tls.c ****         #ifdef HAVE_SESSION_TICKET
11695:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SESSION_TICKET));
11696:../src/src/tls.c ****         #endif
11697:../src/src/tls.c ****         #ifdef HAVE_SUPPORTED_CURVES
11698:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11699:../src/src/tls.c ****         #endif
11700:../src/src/tls.c ****         #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11701:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_PRE_SHARED_KEY));
11702:../src/src/tls.c ****         #endif
11703:../src/src/tls.c ****         #ifdef HAVE_CERTIFICATE_STATUS_REQUEST
11704:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST));
11705:../src/src/tls.c ****         #endif
11706:../src/src/tls.c ****         #ifdef HAVE_CERTIFICATE_STATUS_REQUEST_V2
11707:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST_V2));
11708:../src/src/tls.c ****         #endif
11709:../src/src/tls.c ****         #if defined(HAVE_SERVER_RENEGOTIATION_INFO)
11710:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_RENEGOTIATION_INFO));
11711:../src/src/tls.c ****         #endif
11712:../src/src/tls.c ****             break;
11713:../src/src/tls.c **** 
11714:../src/src/tls.c ****         #ifdef WOLFSSL_EARLY_DATA
11715:../src/src/tls.c ****         case session_ticket:
11716:../src/src/tls.c ****             if (ssl->options.tls1_3) {
11717:../src/src/tls.c ****                 XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11718:../src/src/tls.c ****                 TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_EARLY_DATA));
11719:../src/src/tls.c ****             }
11720:../src/src/tls.c ****             break;
11721:../src/src/tls.c ****         #endif
11722:../src/src/tls.c ****     #endif
11723:../src/src/tls.c **** #endif
11724:../src/src/tls.c **** 
11725:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
11726:../src/src/tls.c ****     #ifndef NO_CERTS
11727:../src/src/tls.c ****         case certificate:
11728:../src/src/tls.c ****             /* Don't send out any extension except those that are turned off. */
11729:../src/src/tls.c ****             XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11730:../src/src/tls.c ****             TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST));
11731:../src/src/tls.c ****             /* TODO: TLSX_SIGNED_CERTIFICATE_TIMESTAMP,
11732:../src/src/tls.c ****              *       TLSX_SERVER_CERTIFICATE_TYPE
11733:../src/src/tls.c ****              */
11734:../src/src/tls.c ****             break;
11735:../src/src/tls.c ****     #endif
11736:../src/src/tls.c **** #endif
11737:../src/src/tls.c ****     }
11738:../src/src/tls.c **** 
11739:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
11740:../src/src/tls.c ****     if (ssl->options.haveEMS && msgType == server_hello &&
11741:../src/src/tls.c ****                                               !IsAtLeastTLSv1_3(ssl->version)) {
11742:../src/src/tls.c ****         length += HELLO_EXT_SZ;
11743:../src/src/tls.c ****     }
11744:../src/src/tls.c **** #endif
11745:../src/src/tls.c **** 
11746:../src/src/tls.c ****     if (TLSX_SupportExtensions(ssl)) {
 7655                             		.loc 2 11746 9
 7656 0038 ED A1 04                		mov.L	16[r10], r1
 7657 003b 05 00 00 00             		bsr	_TLSX_SupportExtensions
 7658 003f EF 15                   		mov.L	r1, r5
 7659                             		.loc 2 11746 8
 7660 0041 61 05                   		cmp	#0, r5
 7661 0043 20 22                   		beq	.L558
11747:../src/src/tls.c ****         ret = TLSX_GetSize(ssl->extensions, semaphore, msgType, &length);
 7662                             		.loc 2 11747 15
 7663 0045 ED A5 04                		mov.L	16[r10], r5
 7664 0048 ED 51 BF                		mov.L	764[r5], r1
 7665 004b 71 A4 04                		add	#4, r10, r4
 7666 004e 71 A5 06                		add	#6, r10, r5
 7667 0051 CD A3 14                		mov.B	20[r10], r3
 7668 0054 EF 52                   		mov.L	r5, r2
 7669 0056 05 00 00 00             		bsr	_TLSX_GetSize
 7670 005a E3 A1                   		mov.L	r1, [r10]
11748:../src/src/tls.c ****         if (ret != 0)
 7671                             		.loc 2 11748 12
 7672 005c EC A5                   		mov.L	[r10], r5
 7673 005e 61 05                   		cmp	#0, r5
 7674 0060 15                      		beq	.L558
11749:../src/src/tls.c ****             return ret;
 7675                             		.loc 2 11749 20
 7676 0061 EC A5                   		mov.L	[r10], r5
 7677 0063 2E 2B                   		bra	.L562
 7678                             	.L558:
11750:../src/src/tls.c ****     }
11751:../src/src/tls.c **** 
11752:../src/src/tls.c ****     /* All the response data is set at the ssl object only, so no ctx here. */
11753:../src/src/tls.c **** 
11754:../src/src/tls.c ****     if (length || msgType != server_hello)
 7679                             		.loc 2 11754 9
 7680 0065 DD A5 02                		mov.W	4[r10], r5
 7681                             		.loc 2 11754 8
 7682 0068 5F 55                   		movu.W	r5, r5
 7683 006a 61 05                   		cmp	#0, r5
 7684 006c 1F                      		bne	.L560
 7685                             		.loc 2 11754 16 discriminator 1
 7686 006d 59 A5 14                		movu.B	20[r10], r5
 7687 0070 61 25                   		cmp	#2, r5
 7688 0072 11                      		beq	.L561
 7689                             	.L560:
11755:../src/src/tls.c ****         length += OPAQUE16_LEN; /* for total length storage. */
 7690                             		.loc 2 11755 16
 7691 0073 DD A5 02                		mov.W	4[r10], r5
 7692 0076 62 25                   		add	#2, r5
 7693 0078 D7 A5 02                		mov.W	r5, 4[r10]
 7694                             	.L561:
11756:../src/src/tls.c **** 
11757:../src/src/tls.c ****     *pLength += length;
 7695                             		.loc 2 11757 14
 7696 007b ED A5 06                		mov.L	24[r10], r5
 7697 007e DC 54                   		mov.W	[r5], r4
 7698 0080 DD A5 02                		mov.W	4[r10], r5
 7699 0083 4B 45                   		add	r4, r5
 7700 0085 DF 54                   		mov.W	r5, r4
 7701 0087 ED A5 06                		mov.L	24[r10], r5
 7702 008a D3 54                   		mov.W	r4, [r5]
11758:../src/src/tls.c **** 
11759:../src/src/tls.c ****     return ret;
 7703                             		.loc 2 11759 12
 7704 008c EC A5                   		mov.L	[r10], r5
 7705                             	.L562:
11760:../src/src/tls.c **** }
 7706                             		.loc 2 11760 1 discriminator 1
 7707 008e EF 51                   		mov.L	r5, r1
 7708 0090 71 00 1C                		add	#28, r0
 7709 0093 7E B6                   		pop	r6
 7710 0095 7E BA                   		pop	r10
 7711 0097 02                      		rts
 7712                             	.LFE110:
 7714                             		.section	.text.TLSX_WriteResponse,"ax",@progbits
 7715                             		.global	_TLSX_WriteResponse
 7717                             	_TLSX_WriteResponse:
 7718                             	.LFB111:
11761:../src/src/tls.c **** 
11762:../src/src/tls.c **** /** Writes the server hello extensions into a buffer. */
11763:../src/src/tls.c **** int TLSX_WriteResponse(WOLFSSL *ssl, byte* output, byte msgType, word16* pOffset)
11764:../src/src/tls.c **** {
 7719                             		.loc 2 11764 1
 7720 0000 7E AA                   		push.l	r10
 7721                             	.LCFI175:
 7722 0002 7E A6                   		push.l	r6
 7723                             	.LCFI176:
 7724 0004 71 0A E0                		add	#-32, r0, r10
 7725                             	.LCFI177:
 7726 0007 71 A0 FC                		add	#-4, r10, r0
 7727                             	.LCFI178:
 7728 000a E7 A1 04                		mov.L	r1, 16[r10]
 7729 000d E7 A2 05                		mov.L	r2, 20[r10]
 7730 0010 C7 A3 18                		mov.B	r3, 24[r10]
 7731 0013 E7 A4 07                		mov.L	r4, 28[r10]
11765:../src/src/tls.c ****     int ret = 0;
 7732                             		.loc 2 11765 9
 7733 0016 F8 A6 00                		mov.L	#0, [r10]
11766:../src/src/tls.c ****     word16 offset = 0;
 7734                             		.loc 2 11766 12
 7735 0019 F9 A5 02 00             		mov.W	#0, 4[r10]
11767:../src/src/tls.c **** 
11768:../src/src/tls.c ****     if (TLSX_SupportExtensions(ssl) && output) {
 7736                             		.loc 2 11768 9
 7737 001d ED A1 04                		mov.L	16[r10], r1
 7738 0020 05 00 00 00             		bsr	_TLSX_SupportExtensions
 7739 0024 EF 15                   		mov.L	r1, r5
 7740                             		.loc 2 11768 8
 7741 0026 61 05                   		cmp	#0, r5
 7742 0028 20 7C                   		beq	.L564
 7743                             		.loc 2 11768 37 discriminator 1
 7744 002a ED A5 05                		mov.L	20[r10], r5
 7745 002d 61 05                   		cmp	#0, r5
 7746 002f 20 75                   		beq	.L564
 7747                             	.LBB19:
11769:../src/src/tls.c ****         byte semaphore[SEMAPHORE_SIZE] = {0};
 7748                             		.loc 2 11769 14
 7749 0031 71 A4 06                		add	#6, r10, r4
 7750 0034 66 05                   		mov.L	#0, r5
 7751 0036 66 06                   		mov.L	#0, r6
 7752 0038 E3 45                   		mov.L	r5, [r4]
 7753 003a A0 4E                   		mov.L	r6, 4[r4]
11770:../src/src/tls.c **** 
11771:../src/src/tls.c ****         switch (msgType) {
 7754                             		.loc 2 11771 9
 7755 003c 59 A5 18                		movu.B	24[r10], r5
 7756 003f 61 25                   		cmp	#2, r5
 7757 0041 21 10                   		bne	.L573
11772:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
11773:../src/src/tls.c ****             case server_hello:
11774:../src/src/tls.c ****                 PF_VALIDATE_RESPONSE(ssl, semaphore);
 7758                             		.loc 2 11774 17
 7759 0043 71 A5 06                		add	#6, r10, r5
 7760 0046 EF 52                   		mov.L	r5, r2
 7761 0048 ED A1 04                		mov.L	16[r10], r1
 7762 004b 05 00 00 00             		bsr	_TLSX_PointFormat_ValidateResponse
11775:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
11776:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version)) {
11777:../src/src/tls.c ****                     XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11778:../src/src/tls.c ****                     TURN_OFF(semaphore,
11779:../src/src/tls.c ****                                      TLSX_ToSemaphore(TLSX_SUPPORTED_VERSIONS));
11780:../src/src/tls.c ****             #ifdef HAVE_SUPPORTED_CURVES
11781:../src/src/tls.c ****                     if (!ssl->options.noPskDheKe)
11782:../src/src/tls.c ****                         TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11783:../src/src/tls.c ****             #endif
11784:../src/src/tls.c ****             #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11785:../src/src/tls.c ****                     TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_PRE_SHARED_KEY));
11786:../src/src/tls.c ****             #endif
11787:../src/src/tls.c ****                 }
11788:../src/src/tls.c ****         #if !defined(WOLFSSL_NO_TLS12) || !defined(NO_OLD_TLS)
11789:../src/src/tls.c ****                 else {
11790:../src/src/tls.c ****             #ifdef HAVE_SUPPORTED_CURVES
11791:../src/src/tls.c ****                     TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11792:../src/src/tls.c ****             #endif
11793:../src/src/tls.c ****             #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11794:../src/src/tls.c ****                     TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_PRE_SHARED_KEY));
11795:../src/src/tls.c ****             #endif
11796:../src/src/tls.c ****                 }
11797:../src/src/tls.c ****         #endif
11798:../src/src/tls.c ****     #endif
11799:../src/src/tls.c ****                 break;
 7763                             		.loc 2 11799 17
 7764 004f 2E 03                   		bra	.L566
 7765                             	.L573:
11800:../src/src/tls.c **** 
11801:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
11802:../src/src/tls.c ****             case hello_retry_request:
11803:../src/src/tls.c ****                 XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11804:../src/src/tls.c ****                 TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_SUPPORTED_VERSIONS));
11805:../src/src/tls.c ****         #ifdef HAVE_SUPPORTED_CURVES
11806:../src/src/tls.c ****                 if (!ssl->options.noPskDheKe)
11807:../src/src/tls.c ****                     TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11808:../src/src/tls.c ****         #endif
11809:../src/src/tls.c ****                 /* Cookie is written below as last extension. */
11810:../src/src/tls.c ****                 break;
11811:../src/src/tls.c ****     #endif
11812:../src/src/tls.c **** 
11813:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
11814:../src/src/tls.c ****             case encrypted_extensions:
11815:../src/src/tls.c ****                 /* Send out all extension except those that are turned on. */
11816:../src/src/tls.c ****         #ifdef HAVE_ECC
11817:../src/src/tls.c ****                 TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_EC_POINT_FORMATS));
11818:../src/src/tls.c ****         #endif
11819:../src/src/tls.c ****                 TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SUPPORTED_VERSIONS));
11820:../src/src/tls.c ****         #ifdef HAVE_SESSION_TICKET
11821:../src/src/tls.c ****                 TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SESSION_TICKET));
11822:../src/src/tls.c ****         #endif
11823:../src/src/tls.c ****         #ifdef HAVE_SUPPORTED_CURVES
11824:../src/src/tls.c ****                 TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_KEY_SHARE));
11825:../src/src/tls.c ****         #endif
11826:../src/src/tls.c ****         #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
11827:../src/src/tls.c ****                 TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_PRE_SHARED_KEY));
11828:../src/src/tls.c ****         #endif
11829:../src/src/tls.c ****         #ifdef HAVE_CERTIFICATE_STATUS_REQUEST
11830:../src/src/tls.c ****                 TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST));
11831:../src/src/tls.c ****         #endif
11832:../src/src/tls.c ****         #ifdef HAVE_CERTIFICATE_STATUS_REQUEST_V2
11833:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST_V2));
11834:../src/src/tls.c ****         #endif
11835:../src/src/tls.c ****         #if defined(HAVE_SERVER_RENEGOTIATION_INFO)
11836:../src/src/tls.c ****             TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_RENEGOTIATION_INFO));
11837:../src/src/tls.c ****         #endif
11838:../src/src/tls.c ****                 break;
11839:../src/src/tls.c **** 
11840:../src/src/tls.c ****         #ifdef WOLFSSL_EARLY_DATA
11841:../src/src/tls.c ****             case session_ticket:
11842:../src/src/tls.c ****                 if (ssl->options.tls1_3) {
11843:../src/src/tls.c ****                     XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11844:../src/src/tls.c ****                     TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_EARLY_DATA));
11845:../src/src/tls.c ****                 }
11846:../src/src/tls.c ****                 break;
11847:../src/src/tls.c ****         #endif
11848:../src/src/tls.c ****     #endif
11849:../src/src/tls.c **** #endif
11850:../src/src/tls.c **** 
11851:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
11852:../src/src/tls.c ****         #ifndef NO_CERTS
11853:../src/src/tls.c ****             case certificate:
11854:../src/src/tls.c ****                 /* Don't send out any extension except those that are turned
11855:../src/src/tls.c ****                  * off. */
11856:../src/src/tls.c ****                 XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11857:../src/src/tls.c ****                 TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_STATUS_REQUEST));
11858:../src/src/tls.c ****                 /* TODO: TLSX_SIGNED_CERTIFICATE_TIMESTAMP,
11859:../src/src/tls.c ****                  *       TLSX_SERVER_CERTIFICATE_TYPE
11860:../src/src/tls.c ****                  */
11861:../src/src/tls.c ****                 break;
11862:../src/src/tls.c ****         #endif
11863:../src/src/tls.c ****     #endif
11864:../src/src/tls.c **** 
11865:../src/src/tls.c ****             default:
11866:../src/src/tls.c ****                 break;
 7766                             		.loc 2 11866 17
 7767 0051 03                      		nop
 7768                             	.L566:
11867:../src/src/tls.c ****         }
11868:../src/src/tls.c **** 
11869:../src/src/tls.c ****         offset += OPAQUE16_LEN; /* extensions length */
 7769                             		.loc 2 11869 16
 7770 0052 DD A5 02                		mov.W	4[r10], r5
 7771 0055 62 25                   		add	#2, r5
 7772 0057 D7 A5 02                		mov.W	r5, 4[r10]
11870:../src/src/tls.c **** 
11871:../src/src/tls.c ****         ret = TLSX_Write(ssl->extensions, output + offset, semaphore,
 7773                             		.loc 2 11871 15
 7774 005a ED A5 04                		mov.L	16[r10], r5
 7775 005d ED 51 BF                		mov.L	764[r5], r1
 7776 0060 DD A5 02                		mov.W	4[r10], r5
 7777 0063 5F 55                   		movu.W	r5, r5
 7778 0065 ED A4 05                		mov.L	20[r10], r4
 7779 0068 4B 45                   		add	r4, r5
 7780 006a 71 A3 06                		add	#6, r10, r3
 7781 006d 71 A4 04                		add	#4, r10, r4
 7782 0070 E3 04                   		mov.L	r4, [r0]
 7783 0072 CD A4 18                		mov.B	24[r10], r4
 7784 0075 EF 52                   		mov.L	r5, r2
 7785 0077 05 00 00 00             		bsr	_TLSX_Write
 7786 007b E3 A1                   		mov.L	r1, [r10]
11872:../src/src/tls.c ****                          msgType, &offset);
11873:../src/src/tls.c ****         if (ret != 0)
 7787                             		.loc 2 11873 12
 7788 007d EC A5                   		mov.L	[r10], r5
 7789 007f 61 05                   		cmp	#0, r5
 7790 0081 15                      		beq	.L567
11874:../src/src/tls.c ****             return ret;
 7791                             		.loc 2 11874 20
 7792 0082 EC A5                   		mov.L	[r10], r5
 7793 0084 2E 3A                   		bra	.L572
 7794                             	.L567:
11875:../src/src/tls.c **** 
11876:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(WOLFSSL_SEND_HRR_COOKIE)
11877:../src/src/tls.c ****         if (msgType == hello_retry_request) {
11878:../src/src/tls.c ****             XMEMSET(semaphore, 0xff, SEMAPHORE_SIZE);
11879:../src/src/tls.c ****             TURN_OFF(semaphore, TLSX_ToSemaphore(TLSX_COOKIE));
11880:../src/src/tls.c ****             ret = TLSX_Write(ssl->extensions, output + offset, semaphore,
11881:../src/src/tls.c ****                              msgType, &offset);
11882:../src/src/tls.c ****             if (ret != 0)
11883:../src/src/tls.c ****                 return ret;
11884:../src/src/tls.c ****         }
11885:../src/src/tls.c **** #endif
11886:../src/src/tls.c **** 
11887:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
11888:../src/src/tls.c ****         if (ssl->options.haveEMS && msgType == server_hello &&
11889:../src/src/tls.c ****                                               !IsAtLeastTLSv1_3(ssl->version)) {
11890:../src/src/tls.c ****             WOLFSSL_MSG("EMS extension to write");
11891:../src/src/tls.c ****             c16toa(HELLO_EXT_EXTMS, output + offset);
11892:../src/src/tls.c ****             offset += HELLO_EXT_TYPE_SZ;
11893:../src/src/tls.c ****             c16toa(0, output + offset);
11894:../src/src/tls.c ****             offset += HELLO_EXT_SZ_SZ;
11895:../src/src/tls.c ****         }
11896:../src/src/tls.c **** #endif
11897:../src/src/tls.c **** 
11898:../src/src/tls.c ****         if (offset > OPAQUE16_LEN || msgType != server_hello)
 7795                             		.loc 2 11898 20
 7796 0086 DD A5 02                		mov.W	4[r10], r5
 7797                             		.loc 2 11898 12
 7798 0089 5F 55                   		movu.W	r5, r5
 7799 008b 61 25                   		cmp	#2, r5
 7800 008d 24 09                   		bgtu	.L569
 7801                             		.loc 2 11898 35 discriminator 1
 7802 008f 59 A5 18                		movu.B	24[r10], r5
 7803 0092 61 25                   		cmp	#2, r5
 7804 0094 20 10                   		beq	.L564
 7805                             	.L569:
11899:../src/src/tls.c ****             c16toa(offset - OPAQUE16_LEN, output); /* extensions length */
 7806                             		.loc 2 11899 13
 7807 0096 DD A5 02                		mov.W	4[r10], r5
 7808 0099 60 25                   		sub	#2, r5
 7809 009b ED A2 05                		mov.L	20[r10], r2
 7810 009e DF 51                   		mov.W	r5, r1
 7811 00a0 05 00 00 00             		bsr	_c16toa
 7812                             		.balign 8,3,1
 7813                             	.L564:
 7814                             	.LBE19:
11900:../src/src/tls.c ****     }
11901:../src/src/tls.c **** 
11902:../src/src/tls.c ****     if (pOffset)
 7815                             		.loc 2 11902 8
 7816 00a4 ED A5 07                		mov.L	28[r10], r5
 7817 00a7 61 05                   		cmp	#0, r5
 7818 00a9 20 13                   		beq	.L571
11903:../src/src/tls.c ****         *pOffset += offset;
 7819                             		.loc 2 11903 18
 7820 00ab ED A5 07                		mov.L	28[r10], r5
 7821 00ae DC 54                   		mov.W	[r5], r4
 7822 00b0 DD A5 02                		mov.W	4[r10], r5
 7823 00b3 4B 45                   		add	r4, r5
 7824 00b5 DF 54                   		mov.W	r5, r4
 7825 00b7 ED A5 07                		mov.L	28[r10], r5
 7826 00ba D3 54                   		mov.W	r4, [r5]
 7827                             	.L571:
11904:../src/src/tls.c **** 
11905:../src/src/tls.c ****     return ret;
 7828                             		.loc 2 11905 12
 7829 00bc EC A5                   		mov.L	[r10], r5
 7830                             	.L572:
11906:../src/src/tls.c **** }
 7831                             		.loc 2 11906 1 discriminator 1
 7832 00be EF 51                   		mov.L	r5, r1
 7833 00c0 71 00 24                		add	#36, r0
 7834 00c3 7E B6                   		pop	r6
 7835 00c5 7E BA                   		pop	r10
 7836 00c7 02                      		rts
 7837                             	.LFE111:
 7839                             		.section C,"a",@progbits
 7840 0256 00 00                   		.p2align 2
 7841                             	.LC16:
 7842 0258 54 72 75 73 74 65 64 20 		.string	"Trusted CA extension received"
 7842      43 41 20 65 78 74 65 6E 
 7842      73 69 6F 6E 20 72 65 63 
 7842      65 69 76 65 64 00 
 7843                             	.LC17:
 7844 0276 4D 61 78 20 46 72 61 67 		.string	"Max Fragment Length extension received"
 7844      6D 65 6E 74 20 4C 65 6E 
 7844      67 74 68 20 65 78 74 65 
 7844      6E 73 69 6F 6E 20 72 65 
 7844      63 65 69 76 65 64 00 
 7845                             	.LC18:
 7846 029d 54 72 75 6E 63 61 74 65 		.string	"Truncated HMAC extension received"
 7846      64 20 48 4D 41 43 20 65 
 7846      78 74 65 6E 73 69 6F 6E 
 7846      20 72 65 63 65 69 76 65 
 7846      64 00 
 7847                             	.LC19:
 7848 02bf 53 75 70 70 6F 72 74 65 		.string	"Supported Groups extension received"
 7848      64 20 47 72 6F 75 70 73 
 7848      20 65 78 74 65 6E 73 69 
 7848      6F 6E 20 72 65 63 65 69 
 7848      76 65 64 00 
 7849                             	.LC20:
 7850 02e3 50 6F 69 6E 74 20 46 6F 		.string	"Point Formats extension received"
 7850      72 6D 61 74 73 20 65 78 
 7850      74 65 6E 73 69 6F 6E 20 
 7850      72 65 63 65 69 76 65 64 
 7850      00 
 7851                             	.LC21:
 7852 0304 43 65 72 74 69 66 69 63 		.string	"Certificate Status Request extension received"
 7852      61 74 65 20 53 74 61 74 
 7852      75 73 20 52 65 71 75 65 
 7852      73 74 20 65 78 74 65 6E 
 7852      73 69 6F 6E 20 72 65 63 
 7853                             	.LC22:
 7854 0332 43 65 72 74 69 66 69 63 		.string	"Certificate Status Request v2 extension received"
 7854      61 74 65 20 53 74 61 74 
 7854      75 73 20 52 65 71 75 65 
 7854      73 74 20 76 32 20 65 78 
 7854      74 65 6E 73 69 6F 6E 20 
 7855                             	.LC23:
 7856 0363 53 65 63 75 72 65 20 52 		.string	"Secure Renegotiation extension received"
 7856      65 6E 65 67 6F 74 69 61 
 7856      74 69 6F 6E 20 65 78 74 
 7856      65 6E 73 69 6F 6E 20 72 
 7856      65 63 65 69 76 65 64 00 
 7857                             	.LC24:
 7858 038b 53 65 73 73 69 6F 6E 20 		.string	"Session Ticket extension received"
 7858      54 69 63 6B 65 74 20 65 
 7858      78 74 65 6E 73 69 6F 6E 
 7858      20 72 65 63 65 69 76 65 
 7858      64 00 
 7859                             	.LC25:
 7860 03ad 41 4C 50 4E 20 65 78 74 		.string	"ALPN extension received"
 7860      65 6E 73 69 6F 6E 20 72 
 7860      65 63 65 69 76 65 64 00 
 7861                             	.LC26:
 7862 03c5 53 69 67 6E 61 74 75 72 		.string	"Signature Algorithms extension received"
 7862      65 20 41 6C 67 6F 72 69 
 7862      74 68 6D 73 20 65 78 74 
 7862      65 6E 73 69 6F 6E 20 72 
 7862      65 63 65 69 76 65 64 00 
 7863                             	.LC27:
 7864 03ed 55 6E 6B 6E 6F 77 6E 20 		.string	"Unknown TLS extension type"
 7864      54 4C 53 20 65 78 74 65 
 7864      6E 73 69 6F 6E 20 74 79 
 7864      70 65 00 
 7865                             		.section	.text.TLSX_Parse,"ax",@progbits
 7866                             		.global	_TLSX_Parse
 7868                             	_TLSX_Parse:
 7869                             	.LFB112:
11907:../src/src/tls.c **** 
11908:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 || !NO_WOLFSSL_SERVER */
11909:../src/src/tls.c **** 
11910:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
11911:../src/src/tls.c **** int TLSX_ParseVersion(WOLFSSL* ssl, const byte* input, word16 length,
11912:../src/src/tls.c ****                       byte msgType, int* found)
11913:../src/src/tls.c **** {
11914:../src/src/tls.c ****     int ret = 0;
11915:../src/src/tls.c ****     int offset = 0;
11916:../src/src/tls.c **** 
11917:../src/src/tls.c ****     *found = 0;
11918:../src/src/tls.c ****     while (offset < (int)length) {
11919:../src/src/tls.c ****         word16 type;
11920:../src/src/tls.c ****         word16 size;
11921:../src/src/tls.c **** 
11922:../src/src/tls.c ****         if (offset + (2 * OPAQUE16_LEN) > length) {
11923:../src/src/tls.c ****             ret = BUFFER_ERROR;
11924:../src/src/tls.c ****             break;
11925:../src/src/tls.c ****         }
11926:../src/src/tls.c **** 
11927:../src/src/tls.c ****         ato16(input + offset, &type);
11928:../src/src/tls.c ****         offset += HELLO_EXT_TYPE_SZ;
11929:../src/src/tls.c **** 
11930:../src/src/tls.c ****         ato16(input + offset, &size);
11931:../src/src/tls.c ****         offset += OPAQUE16_LEN;
11932:../src/src/tls.c **** 
11933:../src/src/tls.c ****         if (offset + size > length) {
11934:../src/src/tls.c ****             ret = BUFFER_ERROR;
11935:../src/src/tls.c ****             break;
11936:../src/src/tls.c ****         }
11937:../src/src/tls.c **** 
11938:../src/src/tls.c ****         if (type == TLSX_SUPPORTED_VERSIONS) {
11939:../src/src/tls.c ****             *found = 1;
11940:../src/src/tls.c **** 
11941:../src/src/tls.c ****             WOLFSSL_MSG("Supported Versions extension received");
11942:../src/src/tls.c **** 
11943:../src/src/tls.c ****             ret = SV_PARSE(ssl, input + offset, size, msgType);
11944:../src/src/tls.c ****             break;
11945:../src/src/tls.c ****         }
11946:../src/src/tls.c **** 
11947:../src/src/tls.c ****         offset += size;
11948:../src/src/tls.c ****     }
11949:../src/src/tls.c **** 
11950:../src/src/tls.c ****     return ret;
11951:../src/src/tls.c **** }
11952:../src/src/tls.c **** #endif
11953:../src/src/tls.c **** 
11954:../src/src/tls.c **** /** Parses a buffer of TLS extensions. */
11955:../src/src/tls.c **** int TLSX_Parse(WOLFSSL* ssl, const byte* input, word16 length, byte msgType,
11956:../src/src/tls.c ****                                                                  Suites *suites)
11957:../src/src/tls.c **** {
 7870                             		.loc 2 11957 1
 7871 0000 7E AA                   		push.l	r10
 7872                             	.LCFI179:
 7873 0002 7E A6                   		push.l	r6
 7874                             	.LCFI180:
 7875 0004 71 0A E4                		add	#-28, r0, r10
 7876                             	.LCFI181:
 7877 0007 71 A0 FC                		add	#-4, r10, r0
 7878                             	.LCFI182:
 7879 000a 75 46 28                		mov.L	#40, r6
 7880 000d 4B A6                   		add	r10, r6
 7881 000f E7 A1 03                		mov.L	r1, 12[r10]
 7882 0012 E7 A2 04                		mov.L	r2, 16[r10]
 7883 0015 D7 A3 0A                		mov.W	r3, 20[r10]
 7884 0018 C7 A4 16                		mov.B	r4, 22[r10]
11958:../src/src/tls.c ****     int ret = 0;
 7885                             		.loc 2 11958 9
 7886 001b F8 A6 00                		mov.L	#0, [r10]
11959:../src/src/tls.c ****     word16 offset = 0;
 7887                             		.loc 2 11959 12
 7888 001e F9 A5 02 00             		mov.W	#0, 4[r10]
11960:../src/src/tls.c ****     byte isRequest = (msgType == client_hello ||
 7889                             		.loc 2 11960 47
 7890 0022 59 A5 16                		movu.B	22[r10], r5
 7891 0025 61 15                   		cmp	#1, r5
 7892 0027 17                      		beq	.L575
 7893                             		.loc 2 11960 47 is_stmt 0 discriminator 2
 7894 0028 59 A5 16                		movu.B	22[r10], r5
 7895 002b 61 D5                   		cmp	#13, r5
 7896 002d 1C                      		bne	.L576
 7897                             	.L575:
 7898                             		.loc 2 11960 47 discriminator 3
 7899 002e 66 15                   		mov.L	#1, r5
 7900 0030 0B                      		bra	.L577
 7901                             	.L576:
 7902                             		.loc 2 11960 47 discriminator 4
 7903 0031 66 05                   		mov.L	#0, r5
 7904                             	.L577:
 7905                             		.loc 2 11960 10 is_stmt 1 discriminator 6
 7906 0033 C7 A5 06                		mov.B	r5, 6[r10]
11961:../src/src/tls.c ****                       msgType == certificate_request);
11962:../src/src/tls.c **** 
11963:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
11964:../src/src/tls.c ****     byte pendingEMS = 0;
11965:../src/src/tls.c **** #endif
11966:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))
11967:../src/src/tls.c ****     int pskDone = 0;
11968:../src/src/tls.c **** #endif
11969:../src/src/tls.c **** 
11970:../src/src/tls.c ****     if (!ssl || !input || (isRequest && !suites))
 7907                             		.loc 2 11970 8 discriminator 6
 7908 0036 ED A5 03                		mov.L	12[r10], r5
 7909 0039 61 05                   		cmp	#0, r5
 7910 003b 20 18                   		beq	.L578
 7911                             		.loc 2 11970 14 discriminator 1
 7912 003d ED A5 04                		mov.L	16[r10], r5
 7913 0040 61 05                   		cmp	#0, r5
 7914 0042 20 11                   		beq	.L578
 7915                             		.loc 2 11970 24 discriminator 2
 7916 0044 59 A5 06                		movu.B	6[r10], r5
 7917 0047 61 05                   		cmp	#0, r5
 7918 0049 3A F6 01                		beq	.L581
 7919                             		.loc 2 11970 38 discriminator 3
 7920 004c EC 65                   		mov.L	[r6], r5
 7921 004e 61 05                   		cmp	#0, r5
 7922 0050 3B EF 01                		bne	.L581
 7923                             	.L578:
11971:../src/src/tls.c ****         return BAD_FUNC_ARG;
 7924                             		.loc 2 11971 16
 7925 0053 FB 5A 53 FF             		mov.L	#-173, r5
 7926 0057 38 0D 02                		bra	.L580
 7927                             	.L603:
 7928                             	.LBB20:
11972:../src/src/tls.c **** 
11973:../src/src/tls.c ****     while (ret == 0 && offset < length) {
11974:../src/src/tls.c ****         word16 type;
11975:../src/src/tls.c ****         word16 size;
11976:../src/src/tls.c **** 
11977:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))
11978:../src/src/tls.c ****         if (msgType == client_hello && pskDone)
11979:../src/src/tls.c ****             return PSK_KEY_ERROR;
11980:../src/src/tls.c **** #endif
11981:../src/src/tls.c **** 
11982:../src/src/tls.c ****         if (length - offset < HELLO_EXT_TYPE_SZ + OPAQUE16_LEN)
 7929                             		.loc 2 11982 20
 7930 005a 5D A4 0A                		movu.W	20[r10], r4
 7931 005d 5D A5 02                		movu.W	4[r10], r5
 7932 0060 FF 05 54                		sub	r5, r4, r5
 7933                             		.loc 2 11982 12
 7934 0063 61 35                   		cmp	#3, r5
 7935 0065 2A 09                   		bgt	.L582
11983:../src/src/tls.c ****             return BUFFER_ERROR;
 7936                             		.loc 2 11983 20
 7937 0067 FB 5A B8 FE             		mov.L	#-328, r5
 7938 006b 38 F9 01                		bra	.L580
 7939                             	.L582:
11984:../src/src/tls.c **** 
11985:../src/src/tls.c ****         ato16(input + offset, &type);
 7940                             		.loc 2 11985 9
 7941 006e 5D A5 02                		movu.W	4[r10], r5
 7942 0071 ED A4 04                		mov.L	16[r10], r4
 7943 0074 4B 45                   		add	r4, r5
 7944 0076 71 A4 08                		add	#8, r10, r4
 7945 0079 EF 42                   		mov.L	r4, r2
 7946 007b EF 51                   		mov.L	r5, r1
 7947 007d 05 00 00 00             		bsr	_ato16
11986:../src/src/tls.c ****         offset += HELLO_EXT_TYPE_SZ;
 7948                             		.loc 2 11986 16
 7949 0081 DD A5 02                		mov.W	4[r10], r5
 7950 0084 62 25                   		add	#2, r5
 7951 0086 D7 A5 02                		mov.W	r5, 4[r10]
11987:../src/src/tls.c **** 
11988:../src/src/tls.c ****         ato16(input + offset, &size);
 7952                             		.loc 2 11988 9
 7953 0089 5D A5 02                		movu.W	4[r10], r5
 7954 008c ED A4 04                		mov.L	16[r10], r4
 7955 008f 4B 45                   		add	r4, r5
 7956 0091 71 A4 0A                		add	#10, r10, r4
 7957 0094 EF 42                   		mov.L	r4, r2
 7958 0096 EF 51                   		mov.L	r5, r1
 7959 0098 05 00 00 00             		bsr	_ato16
11989:../src/src/tls.c ****         offset += OPAQUE16_LEN;
 7960                             		.loc 2 11989 16
 7961 009c DD A5 02                		mov.W	4[r10], r5
 7962 009f 62 25                   		add	#2, r5
 7963 00a1 D7 A5 02                		mov.W	r5, 4[r10]
11990:../src/src/tls.c **** 
11991:../src/src/tls.c ****         if (length - offset < size)
 7964                             		.loc 2 11991 20
 7965 00a4 5D A4 0A                		movu.W	20[r10], r4
 7966 00a7 5D A5 02                		movu.W	4[r10], r5
 7967 00aa 43 54                   		sub	r5, r4
 7968                             		.loc 2 11991 29
 7969 00ac DD A5 05                		mov.W	10[r10], r5
 7970 00af 5F 55                   		movu.W	r5, r5
 7971                             		.loc 2 11991 12
 7972 00b1 47 54                   		cmp	r5, r4
 7973 00b3 28 09                   		bge	.L584
11992:../src/src/tls.c ****             return BUFFER_ERROR;
 7974                             		.loc 2 11992 20
 7975 00b5 FB 5A B8 FE             		mov.L	#-328, r5
 7976 00b9 38 AB 01                		bra	.L580
 7977                             	.L584:
11993:../src/src/tls.c **** 
11994:../src/src/tls.c ****         switch (type) {
 7978                             		.loc 2 11994 9
 7979 00bc DD A5 04                		mov.W	8[r10], r5
 7980 00bf 5F 55                   		movu.W	r5, r5
 7981 00c1 61 B5                   		cmp	#11, r5
 7982 00c3 3A A6 00                		beq	.L585
 7983 00c6 61 B5                   		cmp	#11, r5
 7984 00c8 2A 21                   		bgt	.L586
 7985 00ca 61 45                   		cmp	#4, r5
 7986 00cc 20 67                   		beq	.L587
 7987 00ce 61 45                   		cmp	#4, r5
 7988 00d0 2A 0D                   		bgt	.L588
 7989 00d2 61 15                   		cmp	#1, r5
 7990 00d4 20 4F                   		beq	.L589
 7991 00d6 61 35                   		cmp	#3, r5
 7992 00d8 20 3B                   		beq	.L590
 7993 00da 38 4D 01                		bra	.L591
 7994                             	.L588:
 7995 00dd 61 55                   		cmp	#5, r5
 7996 00df 3A B0 00                		beq	.L592
 7997 00e2 61 A5                   		cmp	#10, r5
 7998 00e4 20 5F                   		beq	.L593
 7999 00e6 38 41 01                		bra	.L591
 8000                             	.L586:
 8001 00e9 75 55 11                		cmp	#17, r5
 8002 00ec 3A C9 00                		beq	.L594
 8003 00ef 75 55 11                		cmp	#17, r5
 8004 00f2 2A 10                   		bgt	.L595
 8005 00f4 61 D5                   		cmp	#13, r5
 8006 00f6 3A FB 00                		beq	.L596
 8007 00f9 75 55 10                		cmp	#16, r5
 8008 00fc 3A E6 00                		beq	.L597
 8009 00ff 38 28 01                		bra	.L591
 8010                             	.L595:
 8011 0102 75 55 23                		cmp	#35, r5
 8012 0105 3A CE 00                		beq	.L598
 8013 0108 77 05 01 FF 00          		cmp	#0xff01, r5
 8014 010d 3A B7 00                		beq	.L599
 8015 0110 38 17 01                		bra	.L591
 8016                             	.L590:
11995:../src/src/tls.c **** #ifdef HAVE_SNI
11996:../src/src/tls.c ****             case TLSX_SERVER_NAME:
11997:../src/src/tls.c ****                 WOLFSSL_MSG("SNI extension received");
11998:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
11999:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12000:../src/src/tls.c ****             #endif
12001:../src/src/tls.c **** 
12002:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_SNI)
12003:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version) &&
12004:../src/src/tls.c ****                         msgType != client_hello &&
12005:../src/src/tls.c ****                         msgType != server_hello &&
12006:../src/src/tls.c ****                         msgType != encrypted_extensions) {
12007:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12008:../src/src/tls.c ****                 }
12009:../src/src/tls.c ****                 else if (!IsAtLeastTLSv1_3(ssl->version) &&
12010:../src/src/tls.c ****                          msgType == encrypted_extensions) {
12011:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12012:../src/src/tls.c ****                 }
12013:../src/src/tls.c **** #endif
12014:../src/src/tls.c ****                 ret = SNI_PARSE(ssl, input + offset, size, isRequest);
12015:../src/src/tls.c ****                 break;
12016:../src/src/tls.c **** #endif
12017:../src/src/tls.c **** 
12018:../src/src/tls.c ****             case TLSX_TRUSTED_CA_KEYS:
12019:../src/src/tls.c ****                 WOLFSSL_MSG("Trusted CA extension received");
 8017                             		.loc 2 12019 17
 8018 0113 FB 12 58 02 00 00       		mov.L	#.LC16, r1
 8019 0119 05 00 00 00             		bsr	_WOLFSSL_MSG
12020:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12021:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12022:../src/src/tls.c ****             #endif
12023:../src/src/tls.c **** 
12024:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_TRUSTED_CA)
12025:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version) &&
12026:../src/src/tls.c ****                         msgType != client_hello &&
12027:../src/src/tls.c ****                         msgType != encrypted_extensions) {
12028:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12029:../src/src/tls.c ****                 }
12030:../src/src/tls.c **** #endif
12031:../src/src/tls.c ****                 ret = TCA_PARSE(ssl, input + offset, size, isRequest);
 8020                             		.loc 2 12031 21
 8021 011d F8 A6 00                		mov.L	#0, [r10]
12032:../src/src/tls.c ****                 break;
 8022                             		.loc 2 12032 17
 8023 0120 38 14 01                		bra	.L600
 8024                             	.L589:
12033:../src/src/tls.c **** 
12034:../src/src/tls.c ****             case TLSX_MAX_FRAGMENT_LENGTH:
12035:../src/src/tls.c ****                 WOLFSSL_MSG("Max Fragment Length extension received");
 8025                             		.loc 2 12035 17
 8026 0123 FB 12 76 02 00 00       		mov.L	#.LC17, r1
 8027 0129 05 00 00 00             		bsr	_WOLFSSL_MSG
12036:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12037:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12038:../src/src/tls.c ****             #endif
12039:../src/src/tls.c **** 
12040:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_MAX_FRAGMENT)
12041:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version) &&
12042:../src/src/tls.c ****                         msgType != client_hello &&
12043:../src/src/tls.c ****                         msgType != encrypted_extensions) {
12044:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12045:../src/src/tls.c ****                 }
12046:../src/src/tls.c ****                 else if (!IsAtLeastTLSv1_3(ssl->version) &&
12047:../src/src/tls.c ****                          msgType == encrypted_extensions) {
12048:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12049:../src/src/tls.c ****                 }
12050:../src/src/tls.c **** #endif
12051:../src/src/tls.c ****                 ret = MFL_PARSE(ssl, input + offset, size, isRequest);
 8028                             		.loc 2 12051 21
 8029 012d F8 A6 00                		mov.L	#0, [r10]
12052:../src/src/tls.c ****                 break;
 8030                             		.loc 2 12052 17
 8031 0130 38 04 01                		bra	.L600
 8032                             	.L587:
12053:../src/src/tls.c **** 
12054:../src/src/tls.c ****             case TLSX_TRUNCATED_HMAC:
12055:../src/src/tls.c ****                 WOLFSSL_MSG("Truncated HMAC extension received");
 8033                             		.loc 2 12055 17
 8034 0133 FB 12 9D 02 00 00       		mov.L	#.LC18, r1
 8035 0139 05 00 00 00             		bsr	_WOLFSSL_MSG
12056:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12057:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12058:../src/src/tls.c ****             #endif
12059:../src/src/tls.c **** 
12060:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_TRUNCATED_HMAC)
12061:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version))
12062:../src/src/tls.c ****                     break;
12063:../src/src/tls.c **** #endif
12064:../src/src/tls.c ****                 ret = THM_PARSE(ssl, input + offset, size, isRequest);
 8036                             		.loc 2 12064 21
 8037 013d F8 A6 00                		mov.L	#0, [r10]
12065:../src/src/tls.c ****                 break;
 8038                             		.loc 2 12065 17
 8039 0140 38 F4 00                		bra	.L600
 8040                             	.L593:
12066:../src/src/tls.c **** 
12067:../src/src/tls.c ****             case TLSX_SUPPORTED_GROUPS:
12068:../src/src/tls.c ****                 WOLFSSL_MSG("Supported Groups extension received");
 8041                             		.loc 2 12068 17
 8042 0143 FB 12 BF 02 00 00       		mov.L	#.LC19, r1
 8043 0149 05 00 00 00             		bsr	_WOLFSSL_MSG
12069:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12070:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12071:../src/src/tls.c ****             #endif
12072:../src/src/tls.c **** 
12073:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_SUPPORTED_CURVES)
12074:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version) &&
12075:../src/src/tls.c ****                         msgType != client_hello &&
12076:../src/src/tls.c ****                         msgType != server_hello &&
12077:../src/src/tls.c ****                         msgType != encrypted_extensions) {
12078:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12079:../src/src/tls.c ****                 }
12080:../src/src/tls.c ****                 else if (!IsAtLeastTLSv1_3(ssl->version) &&
12081:../src/src/tls.c ****                          msgType == encrypted_extensions) {
12082:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12083:../src/src/tls.c ****                 }
12084:../src/src/tls.c **** #endif
12085:../src/src/tls.c ****                 ret = EC_PARSE(ssl, input + offset, size, isRequest);
 8044                             		.loc 2 12085 23
 8045 014d 5D A5 02                		movu.W	4[r10], r5
 8046 0150 ED A4 04                		mov.L	16[r10], r4
 8047 0153 4B 45                   		add	r4, r5
 8048 0155 DD A3 05                		mov.W	10[r10], r3
 8049 0158 CD A4 06                		mov.B	6[r10], r4
 8050 015b EF 52                   		mov.L	r5, r2
 8051 015d ED A1 03                		mov.L	12[r10], r1
 8052 0160 05 00 00 00             		bsr	_TLSX_SupportedCurve_Parse
 8053 0164 E3 A1                   		mov.L	r1, [r10]
12086:../src/src/tls.c ****                 break;
 8054                             		.loc 2 12086 17
 8055 0166 38 CE 00                		bra	.L600
 8056                             	.L585:
12087:../src/src/tls.c **** 
12088:../src/src/tls.c ****             case TLSX_EC_POINT_FORMATS:
12089:../src/src/tls.c ****                 WOLFSSL_MSG("Point Formats extension received");
 8057                             		.loc 2 12089 17
 8058 0169 FB 12 E3 02 00 00       		mov.L	#.LC20, r1
 8059 016f 05 00 00 00             		bsr	_WOLFSSL_MSG
12090:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12091:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12092:../src/src/tls.c ****             #endif
12093:../src/src/tls.c **** 
12094:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_SUPPORTED_CURVES)
12095:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version))
12096:../src/src/tls.c ****                     break;
12097:../src/src/tls.c **** #endif
12098:../src/src/tls.c ****                 ret = PF_PARSE(ssl, input + offset, size, isRequest);
 8060                             		.loc 2 12098 23
 8061 0173 5D A5 02                		movu.W	4[r10], r5
 8062 0176 ED A4 04                		mov.L	16[r10], r4
 8063 0179 4B 45                   		add	r4, r5
 8064 017b DD A3 05                		mov.W	10[r10], r3
 8065 017e CD A4 06                		mov.B	6[r10], r4
 8066 0181 EF 52                   		mov.L	r5, r2
 8067 0183 ED A1 03                		mov.L	12[r10], r1
 8068 0186 05 00 00 00             		bsr	_TLSX_PointFormat_Parse
 8069 018a E3 A1                   		mov.L	r1, [r10]
12099:../src/src/tls.c ****                 break;
 8070                             		.loc 2 12099 17
 8071 018c 38 A8 00                		bra	.L600
 8072                             	.L592:
12100:../src/src/tls.c **** 
12101:../src/src/tls.c ****             case TLSX_STATUS_REQUEST:
12102:../src/src/tls.c ****                 WOLFSSL_MSG("Certificate Status Request extension received");
 8073                             		.loc 2 12102 17
 8074 018f FB 12 04 03 00 00       		mov.L	#.LC21, r1
 8075 0195 05 00 00 00             		bsr	_WOLFSSL_MSG
12103:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12104:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12105:../src/src/tls.c ****             #endif
12106:../src/src/tls.c **** 
12107:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_CERTIFICATE_STATUS_REQUEST)
12108:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version) &&
12109:../src/src/tls.c ****                         msgType != client_hello &&
12110:../src/src/tls.c ****                         msgType != certificate_request &&
12111:../src/src/tls.c ****                         msgType != certificate) {
12112:../src/src/tls.c ****                      break;
12113:../src/src/tls.c ****                 }
12114:../src/src/tls.c ****  #endif
12115:../src/src/tls.c ****                 ret = CSR_PARSE(ssl, input + offset, size, isRequest);
 8076                             		.loc 2 12115 23
 8077 0199 5D A5 02                		movu.W	4[r10], r5
 8078 019c ED A4 04                		mov.L	16[r10], r4
 8079 019f 4B 45                   		add	r4, r5
 8080 01a1 DD A3 05                		mov.W	10[r10], r3
 8081 01a4 CD A4 06                		mov.B	6[r10], r4
 8082 01a7 EF 52                   		mov.L	r5, r2
 8083 01a9 ED A1 03                		mov.L	12[r10], r1
 8084 01ac 05 00 00 00             		bsr	_TLSX_CSR_Parse
 8085 01b0 E3 A1                   		mov.L	r1, [r10]
12116:../src/src/tls.c ****                 break;
 8086                             		.loc 2 12116 17
 8087 01b2 38 82 00                		bra	.L600
 8088                             	.L594:
12117:../src/src/tls.c **** 
12118:../src/src/tls.c ****             case TLSX_STATUS_REQUEST_V2:
12119:../src/src/tls.c ****                 WOLFSSL_MSG("Certificate Status Request v2 extension received");
 8089                             		.loc 2 12119 17
 8090 01b5 FB 12 32 03 00 00       		mov.L	#.LC22, r1
 8091 01bb 05 00 00 00             		bsr	_WOLFSSL_MSG
12120:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12121:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12122:../src/src/tls.c ****             #endif
12123:../src/src/tls.c **** 
12124:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2)
12125:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version) &&
12126:../src/src/tls.c ****                         msgType != client_hello &&
12127:../src/src/tls.c ****                         msgType != certificate_request &&
12128:../src/src/tls.c ****                         msgType != certificate) {
12129:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12130:../src/src/tls.c ****                 }
12131:../src/src/tls.c **** #endif
12132:../src/src/tls.c ****                 ret = CSR2_PARSE(ssl, input + offset, size, isRequest);
 8092                             		.loc 2 12132 21
 8093 01bf F8 A6 00                		mov.L	#0, [r10]
12133:../src/src/tls.c ****                 break;
 8094                             		.loc 2 12133 17
 8095 01c2 2E 72                   		bra	.L600
 8096                             	.L599:
12134:../src/src/tls.c **** 
12135:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
12136:../src/src/tls.c ****             case HELLO_EXT_EXTMS:
12137:../src/src/tls.c ****                 WOLFSSL_MSG("Extended Master Secret extension received");
12138:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12139:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12140:../src/src/tls.c ****             #endif
12141:../src/src/tls.c **** 
12142:../src/src/tls.c **** #if defined(WOLFSSL_TLS13)
12143:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version))
12144:../src/src/tls.c ****                     break;
12145:../src/src/tls.c **** #endif
12146:../src/src/tls.c ****                 if (size != 0)
12147:../src/src/tls.c ****                     return BUFFER_ERROR;
12148:../src/src/tls.c **** 
12149:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
12150:../src/src/tls.c ****                 if (isRequest)
12151:../src/src/tls.c ****                     ssl->options.haveEMS = 1;
12152:../src/src/tls.c **** #endif
12153:../src/src/tls.c ****                 pendingEMS = 1;
12154:../src/src/tls.c ****                 break;
12155:../src/src/tls.c **** #endif
12156:../src/src/tls.c **** 
12157:../src/src/tls.c ****             case TLSX_RENEGOTIATION_INFO:
12158:../src/src/tls.c ****                 WOLFSSL_MSG("Secure Renegotiation extension received");
 8097                             		.loc 2 12158 17
 8098 01c4 FB 12 63 03 00 00       		mov.L	#.LC23, r1
 8099 01ca 05 00 00 00             		bsr	_WOLFSSL_MSG
12159:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12160:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12161:../src/src/tls.c ****             #endif
12162:../src/src/tls.c **** 
12163:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_SERVER_RENEGOTIATION_INFO)
12164:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version))
12165:../src/src/tls.c ****                     break;
12166:../src/src/tls.c **** #endif
12167:../src/src/tls.c ****                 ret = SCR_PARSE(ssl, input + offset, size, isRequest);
 8100                             		.loc 2 12167 21
 8101 01ce F8 A6 00                		mov.L	#0, [r10]
12168:../src/src/tls.c ****                 break;
 8102                             		.loc 2 12168 17
 8103 01d1 2E 63                   		bra	.L600
 8104                             	.L598:
12169:../src/src/tls.c **** 
12170:../src/src/tls.c ****             case TLSX_SESSION_TICKET:
12171:../src/src/tls.c ****                 WOLFSSL_MSG("Session Ticket extension received");
 8105                             		.loc 2 12171 17
 8106 01d3 FB 12 8B 03 00 00       		mov.L	#.LC24, r1
 8107 01d9 05 00 00 00             		bsr	_WOLFSSL_MSG
12172:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12173:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12174:../src/src/tls.c ****             #endif
12175:../src/src/tls.c **** 
12176:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_SESSION_TICKET)
12177:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version) &&
12178:../src/src/tls.c ****                         msgType != client_hello) {
12179:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12180:../src/src/tls.c ****                 }
12181:../src/src/tls.c **** #endif
12182:../src/src/tls.c ****                 ret = WOLF_STK_PARSE(ssl, input + offset, size, isRequest);
 8108                             		.loc 2 12182 21
 8109 01dd F8 A6 00                		mov.L	#0, [r10]
12183:../src/src/tls.c ****                 break;
 8110                             		.loc 2 12183 17
 8111 01e0 2E 54                   		bra	.L600
 8112                             	.L597:
12184:../src/src/tls.c **** 
12185:../src/src/tls.c ****             case TLSX_APPLICATION_LAYER_PROTOCOL:
12186:../src/src/tls.c ****                 WOLFSSL_MSG("ALPN extension received");
 8113                             		.loc 2 12186 17
 8114 01e2 FB 12 AD 03 00 00       		mov.L	#.LC25, r1
 8115 01e8 05 00 00 00             		bsr	_WOLFSSL_MSG
12187:../src/src/tls.c **** 
12188:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12189:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12190:../src/src/tls.c ****             #endif
12191:../src/src/tls.c **** 
12192:../src/src/tls.c **** #if defined(WOLFSSL_TLS13) && defined(HAVE_ALPN)
12193:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version) &&
12194:../src/src/tls.c ****                         msgType != client_hello &&
12195:../src/src/tls.c ****                         msgType != server_hello &&
12196:../src/src/tls.c ****                         msgType != encrypted_extensions) {
12197:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12198:../src/src/tls.c ****                 }
12199:../src/src/tls.c ****                 else if (!IsAtLeastTLSv1_3(ssl->version) &&
12200:../src/src/tls.c ****                          msgType == encrypted_extensions) {
12201:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12202:../src/src/tls.c ****                 }
12203:../src/src/tls.c **** #endif
12204:../src/src/tls.c ****                 ret = ALPN_PARSE(ssl, input + offset, size, isRequest);
 8116                             		.loc 2 12204 21
 8117 01ec F8 A6 00                		mov.L	#0, [r10]
12205:../src/src/tls.c ****                 break;
 8118                             		.loc 2 12205 17
 8119 01ef 2E 45                   		bra	.L600
 8120                             	.L596:
12206:../src/src/tls.c **** #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
12207:../src/src/tls.c ****             case TLSX_SIGNATURE_ALGORITHMS:
12208:../src/src/tls.c ****                 WOLFSSL_MSG("Signature Algorithms extension received");
 8121                             		.loc 2 12208 17
 8122 01f1 FB 12 C5 03 00 00       		mov.L	#.LC26, r1
 8123 01f7 05 00 00 00             		bsr	_WOLFSSL_MSG
12209:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12210:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12211:../src/src/tls.c ****             #endif
12212:../src/src/tls.c **** 
12213:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_2(ssl))
 8124                             		.loc 2 12213 22
 8125 01fb ED A1 03                		mov.L	12[r10], r1
 8126 01fe 05 00 00 00             		bsr	_IsAtLeastTLSv1_2
 8127 0202 EF 15                   		mov.L	r1, r5
 8128                             		.loc 2 12213 20
 8129 0204 61 05                   		cmp	#0, r5
 8130 0206 20 2D                   		beq	.L606
12214:../src/src/tls.c ****                     break;
12215:../src/src/tls.c ****             #ifdef WOLFSSL_TLS13
12216:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version) &&
12217:../src/src/tls.c ****                         msgType != client_hello &&
12218:../src/src/tls.c ****                         msgType != certificate_request) {
12219:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12220:../src/src/tls.c ****                 }
12221:../src/src/tls.c ****             #endif
12222:../src/src/tls.c ****                 ret = SA_PARSE(ssl, input + offset, size, isRequest, suites);
 8131                             		.loc 2 12222 23
 8132 0208 5D A5 02                		movu.W	4[r10], r5
 8133 020b ED A4 04                		mov.L	16[r10], r4
 8134 020e 4B 45                   		add	r4, r5
 8135 0210 DD A3 05                		mov.W	10[r10], r3
 8136 0213 EC 64                   		mov.L	[r6], r4
 8137 0215 E3 04                   		mov.L	r4, [r0]
 8138 0217 CD A4 06                		mov.B	6[r10], r4
 8139 021a EF 52                   		mov.L	r5, r2
 8140 021c ED A1 03                		mov.L	12[r10], r1
 8141 021f 05 00 00 00             		bsr	_TLSX_SignatureAlgorithms_Parse
 8142 0223 E3 A1                   		mov.L	r1, [r10]
12223:../src/src/tls.c ****                 break;
 8143                             		.loc 2 12223 17
 8144 0225 2E 0F                   		bra	.L600
 8145                             	.L591:
12224:../src/src/tls.c **** #endif
12225:../src/src/tls.c **** 
12226:../src/src/tls.c **** #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
12227:../src/src/tls.c ****             case TLSX_ENCRYPT_THEN_MAC:
12228:../src/src/tls.c ****                 WOLFSSL_MSG("Encrypt-Then-Mac extension received");
12229:../src/src/tls.c **** 
12230:../src/src/tls.c ****                 /* Ignore for TLS 1.3+ */
12231:../src/src/tls.c ****                 if (IsAtLeastTLSv1_3(ssl->version))
12232:../src/src/tls.c ****                     break;
12233:../src/src/tls.c **** 
12234:../src/src/tls.c ****                 ret = ETM_PARSE(ssl, input + offset, size, msgType);
12235:../src/src/tls.c ****                 break;
12236:../src/src/tls.c **** #endif /* HAVE_ENCRYPT_THEN_MAC */
12237:../src/src/tls.c **** 
12238:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
12239:../src/src/tls.c ****             case TLSX_SUPPORTED_VERSIONS:
12240:../src/src/tls.c ****                 WOLFSSL_MSG("Skipping Supported Versions - already processed");
12241:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12242:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12243:../src/src/tls.c ****             #endif
12244:../src/src/tls.c **** 
12245:../src/src/tls.c ****                 break;
12246:../src/src/tls.c **** 
12247:../src/src/tls.c ****     #ifdef WOLFSSL_SEND_HRR_COOKIE
12248:../src/src/tls.c ****             case TLSX_COOKIE:
12249:../src/src/tls.c ****                 WOLFSSL_MSG("Cookie extension received");
12250:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12251:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12252:../src/src/tls.c ****             #endif
12253:../src/src/tls.c **** 
12254:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_3(ssl->version))
12255:../src/src/tls.c ****                     break;
12256:../src/src/tls.c **** 
12257:../src/src/tls.c ****                 if (msgType != client_hello &&
12258:../src/src/tls.c ****                         msgType != hello_retry_request) {
12259:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12260:../src/src/tls.c ****                 }
12261:../src/src/tls.c **** 
12262:../src/src/tls.c ****                 ret = CKE_PARSE(ssl, input + offset, size, msgType);
12263:../src/src/tls.c ****                 break;
12264:../src/src/tls.c ****     #endif
12265:../src/src/tls.c **** 
12266:../src/src/tls.c ****     #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
12267:../src/src/tls.c ****             case TLSX_PRE_SHARED_KEY:
12268:../src/src/tls.c ****                 WOLFSSL_MSG("Pre-Shared Key extension received");
12269:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12270:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12271:../src/src/tls.c ****             #endif
12272:../src/src/tls.c **** 
12273:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_3(ssl->version))
12274:../src/src/tls.c ****                     break;
12275:../src/src/tls.c **** 
12276:../src/src/tls.c ****                 if (msgType != client_hello && msgType != server_hello)
12277:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12278:../src/src/tls.c **** 
12279:../src/src/tls.c ****                 ret = PSK_PARSE(ssl, input + offset, size, msgType);
12280:../src/src/tls.c ****                 pskDone = 1;
12281:../src/src/tls.c ****                 break;
12282:../src/src/tls.c **** 
12283:../src/src/tls.c ****             case TLSX_PSK_KEY_EXCHANGE_MODES:
12284:../src/src/tls.c ****                 WOLFSSL_MSG("PSK Key Exchange Modes extension received");
12285:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12286:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12287:../src/src/tls.c ****             #endif
12288:../src/src/tls.c **** 
12289:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_3(ssl->version))
12290:../src/src/tls.c ****                     break;
12291:../src/src/tls.c **** 
12292:../src/src/tls.c ****                 if (msgType != client_hello)
12293:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12294:../src/src/tls.c **** 
12295:../src/src/tls.c ****                 ret = PKM_PARSE(ssl, input + offset, size, msgType);
12296:../src/src/tls.c ****                 break;
12297:../src/src/tls.c ****     #endif
12298:../src/src/tls.c **** 
12299:../src/src/tls.c ****     #ifdef WOLFSSL_EARLY_DATA
12300:../src/src/tls.c ****             case TLSX_EARLY_DATA:
12301:../src/src/tls.c ****                 WOLFSSL_MSG("Early Data extension received");
12302:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12303:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12304:../src/src/tls.c ****             #endif
12305:../src/src/tls.c **** 
12306:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_3(ssl->version))
12307:../src/src/tls.c ****                     break;
12308:../src/src/tls.c **** 
12309:../src/src/tls.c ****                 if (msgType != client_hello && msgType != session_ticket &&
12310:../src/src/tls.c ****                         msgType != encrypted_extensions) {
12311:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12312:../src/src/tls.c ****                 }
12313:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_3(ssl->version) &&
12314:../src/src/tls.c ****                         (msgType == session_ticket ||
12315:../src/src/tls.c ****                          msgType == encrypted_extensions)) {
12316:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12317:../src/src/tls.c ****                 }
12318:../src/src/tls.c ****                 ret = EDI_PARSE(ssl, input + offset, size, msgType);
12319:../src/src/tls.c ****                 break;
12320:../src/src/tls.c ****     #endif
12321:../src/src/tls.c **** 
12322:../src/src/tls.c ****     #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
12323:../src/src/tls.c ****             case TLSX_POST_HANDSHAKE_AUTH:
12324:../src/src/tls.c ****                 WOLFSSL_MSG("Post Handshake Authentication extension received");
12325:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12326:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12327:../src/src/tls.c ****             #endif
12328:../src/src/tls.c **** 
12329:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_3(ssl->version))
12330:../src/src/tls.c ****                     break;
12331:../src/src/tls.c **** 
12332:../src/src/tls.c ****                 if (msgType != client_hello)
12333:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12334:../src/src/tls.c **** 
12335:../src/src/tls.c ****                 ret = PHA_PARSE(ssl, input + offset, size, msgType);
12336:../src/src/tls.c ****                 break;
12337:../src/src/tls.c ****     #endif
12338:../src/src/tls.c **** 
12339:../src/src/tls.c ****     #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
12340:../src/src/tls.c ****             case TLSX_SIGNATURE_ALGORITHMS_CERT:
12341:../src/src/tls.c ****                 WOLFSSL_MSG("Signature Algorithms extension received");
12342:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12343:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12344:../src/src/tls.c ****             #endif
12345:../src/src/tls.c **** 
12346:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_3(ssl->version))
12347:../src/src/tls.c ****                     break;
12348:../src/src/tls.c **** 
12349:../src/src/tls.c ****                 if (msgType != client_hello &&
12350:../src/src/tls.c ****                         msgType != certificate_request) {
12351:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12352:../src/src/tls.c ****                 }
12353:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_3(ssl->version) &&
12354:../src/src/tls.c ****                         msgType == certificate_request) {
12355:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12356:../src/src/tls.c ****                 }
12357:../src/src/tls.c **** 
12358:../src/src/tls.c ****                 ret = SAC_PARSE(ssl, input + offset, size, isRequest);
12359:../src/src/tls.c ****                 break;
12360:../src/src/tls.c ****     #endif
12361:../src/src/tls.c **** 
12362:../src/src/tls.c ****             case TLSX_KEY_SHARE:
12363:../src/src/tls.c ****                 WOLFSSL_MSG("Key Share extension received");
12364:../src/src/tls.c ****             #ifdef WOLFSSL_DEBUG_TLS
12365:../src/src/tls.c ****                 WOLFSSL_BUFFER(input + offset, size);
12366:../src/src/tls.c ****             #endif
12367:../src/src/tls.c **** 
12368:../src/src/tls.c ****     #ifdef HAVE_SUPPORTED_CURVES
12369:../src/src/tls.c ****                 if (!IsAtLeastTLSv1_3(ssl->version))
12370:../src/src/tls.c ****                     break;
12371:../src/src/tls.c **** 
12372:../src/src/tls.c ****                 if (msgType != client_hello && msgType != server_hello &&
12373:../src/src/tls.c ****                         msgType != hello_retry_request) {
12374:../src/src/tls.c ****                     return EXT_NOT_ALLOWED;
12375:../src/src/tls.c ****                 }
12376:../src/src/tls.c ****     #endif
12377:../src/src/tls.c **** 
12378:../src/src/tls.c ****                 ret = KS_PARSE(ssl, input + offset, size, msgType);
12379:../src/src/tls.c ****                 break;
12380:../src/src/tls.c **** #endif
12381:../src/src/tls.c **** #ifdef WOLFSSL_SRTP
12382:../src/src/tls.c ****             case TLSX_USE_SRTP:
12383:../src/src/tls.c ****                 WOLFSSL_MSG("Use SRTP extension received");
12384:../src/src/tls.c ****                 ret = SRTP_PARSE(ssl, input + offset, size, isRequest);
12385:../src/src/tls.c ****                 break;
12386:../src/src/tls.c **** #endif
12387:../src/src/tls.c ****             default:
12388:../src/src/tls.c ****                 WOLFSSL_MSG("Unknown TLS extension type");
 8146                             		.loc 2 12388 17
 8147 0227 FB 12 ED 03 00 00       		mov.L	#.LC27, r1
 8148 022d 05 00 00 00             		bsr	_WOLFSSL_MSG
 8149 0231 2E 03                   		bra	.L600
 8150                             	.L606:
12214:../src/src/tls.c ****             #ifdef WOLFSSL_TLS13
 8151                             		.loc 2 12214 21
 8152 0233 03                      		nop
 8153                             		.balign 8,3,1
 8154                             	.L600:
12389:../src/src/tls.c ****         }
12390:../src/src/tls.c **** 
12391:../src/src/tls.c ****         /* offset should be updated here! */
12392:../src/src/tls.c ****         offset += size;
 8155                             		.loc 2 12392 16 discriminator 1
 8156 0234 DD A5 05                		mov.W	10[r10], r5
 8157 0237 DD A4 02                		mov.W	4[r10], r4
 8158 023a 4B 45                   		add	r4, r5
 8159 023c D7 A5 02                		mov.W	r5, 4[r10]
 8160                             	.L581:
 8161                             	.LBE20:
11973:../src/src/tls.c ****         word16 type;
 8162                             		.loc 2 11973 11
 8163 023f EC A5                   		mov.L	[r10], r5
 8164 0241 61 05                   		cmp	#0, r5
 8165 0243 21 0F                   		bne	.L602
11973:../src/src/tls.c ****         word16 type;
 8166                             		.loc 2 11973 21 discriminator 1
 8167 0245 5D A4 02                		movu.W	4[r10], r4
 8168 0248 5D A5 0A                		movu.W	20[r10], r5
 8169 024b 47 54                   		cmp	r5, r4
 8170 024d 22 05 38 0B FE          		bltu	.L603
 8171                             	.L602:
12393:../src/src/tls.c ****     }
12394:../src/src/tls.c **** 
12395:../src/src/tls.c **** #ifdef HAVE_EXTENDED_MASTER
12396:../src/src/tls.c ****     if (IsAtLeastTLSv1_3(ssl->version) && msgType == hello_retry_request) {
12397:../src/src/tls.c ****         /* Don't change EMS status until server_hello received.
12398:../src/src/tls.c ****          * Second ClientHello must have same extensions.
12399:../src/src/tls.c ****          */
12400:../src/src/tls.c ****     }
12401:../src/src/tls.c ****     else if (!isRequest && ssl->options.haveEMS && !pendingEMS)
12402:../src/src/tls.c ****         ssl->options.haveEMS = 0;
12403:../src/src/tls.c **** #endif
12404:../src/src/tls.c **** 
12405:../src/src/tls.c ****     if (ret == 0)
 8172                             		.loc 2 12405 8
 8173 0252 EC A5                   		mov.L	[r10], r5
 8174 0254 61 05                   		cmp	#0, r5
 8175 0256 1C                      		bne	.L604
12406:../src/src/tls.c ****         ret = SNI_VERIFY_PARSE(ssl, isRequest);
 8176                             		.loc 2 12406 13
 8177 0257 F8 A6 00                		mov.L	#0, [r10]
 8178                             	.L604:
12407:../src/src/tls.c ****     if (ret == 0)
 8179                             		.loc 2 12407 8
 8180 025a EC A5                   		mov.L	[r10], r5
 8181 025c 61 05                   		cmp	#0, r5
 8182 025e 1C                      		bne	.L605
12408:../src/src/tls.c ****         ret = TCA_VERIFY_PARSE(ssl, isRequest);
 8183                             		.loc 2 12408 13
 8184 025f F8 A6 00                		mov.L	#0, [r10]
 8185                             	.L605:
12409:../src/src/tls.c **** 
12410:../src/src/tls.c ****     return ret;
 8186                             		.loc 2 12410 12
 8187 0262 EC A5                   		mov.L	[r10], r5
 8188                             		.balign 8,3,1
 8189                             	.L580:
12411:../src/src/tls.c **** }
 8190                             		.loc 2 12411 1
 8191 0264 EF 51                   		mov.L	r5, r1
 8192 0266 71 00 20                		add	#32, r0
 8193 0269 7E B6                   		pop	r6
 8194 026b 7E BA                   		pop	r10
 8195 026d 02                      		rts
 8196                             	.LFE112:
 8198 026e EF 00                   		.section	.text.wolfTLS_client_method,"ax",@progbits
 8199                             		.global	_wolfTLS_client_method
 8201                             	_wolfTLS_client_method:
 8202                             	.LFB113:
12412:../src/src/tls.c **** 
12413:../src/src/tls.c **** /* undefining semaphore macros */
12414:../src/src/tls.c **** #undef IS_OFF
12415:../src/src/tls.c **** #undef TURN_ON
12416:../src/src/tls.c **** #undef SEMAPHORE_SIZE
12417:../src/src/tls.c **** 
12418:../src/src/tls.c **** #endif /* HAVE_TLS_EXTENSIONS */
12419:../src/src/tls.c **** 
12420:../src/src/tls.c **** #ifndef NO_WOLFSSL_CLIENT
12421:../src/src/tls.c **** 
12422:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLS_client_method(void)
12423:../src/src/tls.c ****     {
 8203                             		.loc 2 12423 5
 8204 0000 7E AA                   		push.l	r10
 8205                             	.LCFI183:
 8206 0002 EF 0A                   		mov.L	r0, r10
 8207                             	.LCFI184:
12424:../src/src/tls.c ****         return wolfTLS_client_method_ex(NULL);
 8208                             		.loc 2 12424 16
 8209 0004 66 01                   		mov.L	#0, r1
 8210 0006 05 00 00 00             		bsr	_wolfTLS_client_method_ex
 8211 000a EF 15                   		mov.L	r1, r5
12425:../src/src/tls.c ****     }
 8212                             		.loc 2 12425 5
 8213 000c EF 51                   		mov.L	r5, r1
 8214 000e 3F AA 01                		rtsd	#4, r10-r10
 8215                             	.LFE113:
 8217                             		.section C,"a",@progbits
 8218                             		.p2align 2
 8219                             	.LC28:
 8220 0408 54 4C 53 5F 63 6C 69 65 		.string	"TLS_client_method_ex"
 8220      6E 74 5F 6D 65 74 68 6F 
 8220      64 5F 65 78 00 
 8221                             		.section	.text.wolfTLS_client_method_ex,"ax",@progbits
 8222                             		.global	_wolfTLS_client_method_ex
 8224                             	_wolfTLS_client_method_ex:
 8225                             	.LFB114:
12426:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLS_client_method_ex(void* heap)
12427:../src/src/tls.c ****     {
 8226                             		.loc 2 12427 5
 8227 0000 7E AA                   		push.l	r10
 8228                             	.LCFI185:
 8229 0002 71 0A F4                		add	#-12, r0, r10
 8230                             	.LCFI186:
 8231 0005 71 A0 FC                		add	#-4, r10, r0
 8232                             	.LCFI187:
 8233 0008 E7 A1 02                		mov.L	r1, 8[r10]
12428:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12429:../src/src/tls.c ****                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
 8234                             		.loc 2 12429 49
 8235 000b 66 41                   		mov.L	#4, r1
 8236 000d 05 00 00 00             		bsr	_wolfSSL_Malloc
 8237 0011 E3 A1                   		mov.L	r1, [r10]
12430:../src/src/tls.c ****                                                      heap, DYNAMIC_TYPE_METHOD);
12431:../src/src/tls.c ****         (void)heap;
12432:../src/src/tls.c ****         WOLFSSL_ENTER("TLS_client_method_ex");
 8238                             		.loc 2 12432 9
 8239 0013 FB 12 08 04 00 00       		mov.L	#.LC28, r1
 8240 0019 05 00 00 00             		bsr	_WOLFSSL_ENTER
12433:../src/src/tls.c ****         if (method) {
 8241                             		.loc 2 12433 12
 8242 001d EC A5                   		mov.L	[r10], r5
 8243 001f 61 05                   		cmp	#0, r5
 8244 0021 20 20                   		beq	.L610
12434:../src/src/tls.c ****         #if defined(WOLFSSL_TLS13)
12435:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_3());
12436:../src/src/tls.c ****         #elif !defined(WOLFSSL_NO_TLS12)
12437:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_2());
 8245                             		.loc 2 12437 13
 8246 0023 71 A5 04                		add	#4, r10, r5
 8247 0026 EF 5F                   		mov.L	r5, r15
 8248 0028 05 00 00 00             		bsr	_MakeTLSv1_2
 8249 002c DD A5 02                		mov.W	4[r10], r5
 8250 002f D3 05                   		mov.W	r5, [r0]
 8251 0031 EC A1                   		mov.L	[r10], r1
 8252 0033 05 00 00 00             		bsr	_InitSSL_Method
12438:../src/src/tls.c ****         #elif !defined(NO_OLD_TLS)
12439:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_1());
12440:../src/src/tls.c ****         #elif defined(WOLFSSL_ALLOW_TLSV10)
12441:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1());
12442:../src/src/tls.c ****         #else
12443:../src/src/tls.c ****             #error No TLS version enabled!
12444:../src/src/tls.c ****         #endif
12445:../src/src/tls.c **** 
12446:../src/src/tls.c ****             method->downgrade = 1;
 8253                             		.loc 2 12446 31
 8254 0037 EC A5                   		mov.L	[r10], r5
 8255 0039 3C 53 01                		mov.B	#1, 3[r5]
12447:../src/src/tls.c ****             method->side      = WOLFSSL_CLIENT_END;
 8256                             		.loc 2 12447 31
 8257 003c EC A5                   		mov.L	[r10], r5
 8258 003e 3C 52 01                		mov.B	#1, 2[r5]
 8259                             	.L610:
12448:../src/src/tls.c ****         }
12449:../src/src/tls.c ****         return method;
 8260                             		.loc 2 12449 16
 8261 0041 EC A5                   		mov.L	[r10], r5
12450:../src/src/tls.c ****     }
 8262                             		.loc 2 12450 5
 8263 0043 EF 51                   		mov.L	r5, r1
 8264 0045 3F AA 05                		rtsd	#20, r10-r10
 8265                             	.LFE114:
 8267                             		.section	.text.wolfTLSv1_1_client_method,"ax",@progbits
 8268                             		.global	_wolfTLSv1_1_client_method
 8270                             	_wolfTLSv1_1_client_method:
 8271                             	.LFB115:
12451:../src/src/tls.c **** 
12452:../src/src/tls.c **** #ifndef NO_OLD_TLS
12453:../src/src/tls.c ****     #ifdef WOLFSSL_ALLOW_TLSV10
12454:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_client_method(void)
12455:../src/src/tls.c ****     {
12456:../src/src/tls.c ****         return wolfTLSv1_client_method_ex(NULL);
12457:../src/src/tls.c ****     }
12458:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_client_method_ex(void* heap)
12459:../src/src/tls.c ****     {
12460:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12461:../src/src/tls.c ****                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
12462:../src/src/tls.c ****                                                      heap, DYNAMIC_TYPE_METHOD);
12463:../src/src/tls.c ****         (void)heap;
12464:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_client_method_ex");
12465:../src/src/tls.c ****         if (method)
12466:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1());
12467:../src/src/tls.c ****         return method;
12468:../src/src/tls.c ****     }
12469:../src/src/tls.c ****     #endif /* WOLFSSL_ALLOW_TLSV10 */
12470:../src/src/tls.c **** 
12471:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_1_client_method(void)
12472:../src/src/tls.c ****     {
 8272                             		.loc 2 12472 5
 8273 0000 7E AA                   		push.l	r10
 8274                             	.LCFI188:
 8275 0002 EF 0A                   		mov.L	r0, r10
 8276                             	.LCFI189:
12473:../src/src/tls.c ****         return wolfTLSv1_1_client_method_ex(NULL);
 8277                             		.loc 2 12473 16
 8278 0004 66 01                   		mov.L	#0, r1
 8279 0006 05 00 00 00             		bsr	_wolfTLSv1_1_client_method_ex
 8280 000a EF 15                   		mov.L	r1, r5
12474:../src/src/tls.c ****     }
 8281                             		.loc 2 12474 5
 8282 000c EF 51                   		mov.L	r5, r1
 8283 000e 3F AA 01                		rtsd	#4, r10-r10
 8284                             	.LFE115:
 8286                             		.section C,"a",@progbits
 8287 041d 00 00 00                		.p2align 2
 8288                             	.LC29:
 8289 0420 54 4C 53 76 31 5F 31 5F 		.string	"TLSv1_1_client_method_ex"
 8289      63 6C 69 65 6E 74 5F 6D 
 8289      65 74 68 6F 64 5F 65 78 
 8289      00 
 8290                             		.section	.text.wolfTLSv1_1_client_method_ex,"ax",@progbits
 8291                             		.global	_wolfTLSv1_1_client_method_ex
 8293                             	_wolfTLSv1_1_client_method_ex:
 8294                             	.LFB116:
12475:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_1_client_method_ex(void* heap)
12476:../src/src/tls.c ****     {
 8295                             		.loc 2 12476 5
 8296 0000 7E AA                   		push.l	r10
 8297                             	.LCFI190:
 8298 0002 71 0A F4                		add	#-12, r0, r10
 8299                             	.LCFI191:
 8300 0005 71 A0 FC                		add	#-4, r10, r0
 8301                             	.LCFI192:
 8302 0008 E7 A1 02                		mov.L	r1, 8[r10]
12477:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12478:../src/src/tls.c ****                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
 8303                             		.loc 2 12478 49
 8304 000b 66 41                   		mov.L	#4, r1
 8305 000d 05 00 00 00             		bsr	_wolfSSL_Malloc
 8306 0011 E3 A1                   		mov.L	r1, [r10]
12479:../src/src/tls.c ****                                                      heap, DYNAMIC_TYPE_METHOD);
12480:../src/src/tls.c ****         (void)heap;
12481:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_1_client_method_ex");
 8307                             		.loc 2 12481 9
 8308 0013 FB 12 20 04 00 00       		mov.L	#.LC29, r1
 8309 0019 05 00 00 00             		bsr	_WOLFSSL_ENTER
12482:../src/src/tls.c ****         if (method)
 8310                             		.loc 2 12482 12
 8311 001d EC A5                   		mov.L	[r10], r5
 8312 001f 61 05                   		cmp	#0, r5
 8313 0021 20 16                   		beq	.L615
12483:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_1());
 8314                             		.loc 2 12483 13
 8315 0023 71 A5 04                		add	#4, r10, r5
 8316 0026 EF 5F                   		mov.L	r5, r15
 8317 0028 05 00 00 00             		bsr	_MakeTLSv1_1
 8318 002c DD A5 02                		mov.W	4[r10], r5
 8319 002f D3 05                   		mov.W	r5, [r0]
 8320 0031 EC A1                   		mov.L	[r10], r1
 8321 0033 05 00 00 00             		bsr	_InitSSL_Method
 8322                             	.L615:
12484:../src/src/tls.c ****         return method;
 8323                             		.loc 2 12484 16
 8324 0037 EC A5                   		mov.L	[r10], r5
12485:../src/src/tls.c ****     }
 8325                             		.loc 2 12485 5
 8326 0039 EF 51                   		mov.L	r5, r1
 8327 003b 3F AA 05                		rtsd	#20, r10-r10
 8328                             	.LFE116:
 8330                             		.section	.text.wolfTLSv1_2_client_method,"ax",@progbits
 8331                             		.global	_wolfTLSv1_2_client_method
 8333                             	_wolfTLSv1_2_client_method:
 8334                             	.LFB117:
12486:../src/src/tls.c **** #endif /* !NO_OLD_TLS */
12487:../src/src/tls.c **** 
12488:../src/src/tls.c **** #ifndef WOLFSSL_NO_TLS12
12489:../src/src/tls.c ****     WOLFSSL_ABI
12490:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_2_client_method(void)
12491:../src/src/tls.c ****     {
 8335                             		.loc 2 12491 5
 8336 0000 7E AA                   		push.l	r10
 8337                             	.LCFI193:
 8338 0002 EF 0A                   		mov.L	r0, r10
 8339                             	.LCFI194:
12492:../src/src/tls.c ****         return wolfTLSv1_2_client_method_ex(NULL);
 8340                             		.loc 2 12492 16
 8341 0004 66 01                   		mov.L	#0, r1
 8342 0006 05 00 00 00             		bsr	_wolfTLSv1_2_client_method_ex
 8343 000a EF 15                   		mov.L	r1, r5
12493:../src/src/tls.c ****     }
 8344                             		.loc 2 12493 5
 8345 000c EF 51                   		mov.L	r5, r1
 8346 000e 3F AA 01                		rtsd	#4, r10-r10
 8347                             	.LFE117:
 8349                             		.section C,"a",@progbits
 8350 0439 00 00 00                		.p2align 2
 8351                             	.LC30:
 8352 043c 54 4C 53 76 31 5F 32 5F 		.string	"TLSv1_2_client_method_ex"
 8352      63 6C 69 65 6E 74 5F 6D 
 8352      65 74 68 6F 64 5F 65 78 
 8352      00 
 8353                             		.section	.text.wolfTLSv1_2_client_method_ex,"ax",@progbits
 8354                             		.global	_wolfTLSv1_2_client_method_ex
 8356                             	_wolfTLSv1_2_client_method_ex:
 8357                             	.LFB118:
12494:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_2_client_method_ex(void* heap)
12495:../src/src/tls.c ****     {
 8358                             		.loc 2 12495 5
 8359 0000 7E AA                   		push.l	r10
 8360                             	.LCFI195:
 8361 0002 71 0A F4                		add	#-12, r0, r10
 8362                             	.LCFI196:
 8363 0005 71 A0 FC                		add	#-4, r10, r0
 8364                             	.LCFI197:
 8365 0008 E7 A1 02                		mov.L	r1, 8[r10]
12496:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12497:../src/src/tls.c ****                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
 8366                             		.loc 2 12497 49
 8367 000b 66 41                   		mov.L	#4, r1
 8368 000d 05 00 00 00             		bsr	_wolfSSL_Malloc
 8369 0011 E3 A1                   		mov.L	r1, [r10]
12498:../src/src/tls.c ****                                                      heap, DYNAMIC_TYPE_METHOD);
12499:../src/src/tls.c ****         (void)heap;
12500:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_2_client_method_ex");
 8370                             		.loc 2 12500 9
 8371 0013 FB 12 3C 04 00 00       		mov.L	#.LC30, r1
 8372 0019 05 00 00 00             		bsr	_WOLFSSL_ENTER
12501:../src/src/tls.c ****         if (method)
 8373                             		.loc 2 12501 12
 8374 001d EC A5                   		mov.L	[r10], r5
 8375 001f 61 05                   		cmp	#0, r5
 8376 0021 20 16                   		beq	.L620
12502:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_2());
 8377                             		.loc 2 12502 13
 8378 0023 71 A5 04                		add	#4, r10, r5
 8379 0026 EF 5F                   		mov.L	r5, r15
 8380 0028 05 00 00 00             		bsr	_MakeTLSv1_2
 8381 002c DD A5 02                		mov.W	4[r10], r5
 8382 002f D3 05                   		mov.W	r5, [r0]
 8383 0031 EC A1                   		mov.L	[r10], r1
 8384 0033 05 00 00 00             		bsr	_InitSSL_Method
 8385                             	.L620:
12503:../src/src/tls.c ****         return method;
 8386                             		.loc 2 12503 16
 8387 0037 EC A5                   		mov.L	[r10], r5
12504:../src/src/tls.c ****     }
 8388                             		.loc 2 12504 5
 8389 0039 EF 51                   		mov.L	r5, r1
 8390 003b 3F AA 05                		rtsd	#20, r10-r10
 8391                             	.LFE118:
 8393                             		.section	.text.wolfTLS_server_method,"ax",@progbits
 8394                             		.global	_wolfTLS_server_method
 8396                             	_wolfTLS_server_method:
 8397                             	.LFB119:
12505:../src/src/tls.c **** #endif /* WOLFSSL_NO_TLS12 */
12506:../src/src/tls.c **** 
12507:../src/src/tls.c **** #ifdef WOLFSSL_TLS13
12508:../src/src/tls.c ****     /* The TLS v1.3 client method data.
12509:../src/src/tls.c ****      *
12510:../src/src/tls.c ****      * returns the method data for a TLS v1.3 client.
12511:../src/src/tls.c ****      */
12512:../src/src/tls.c ****     WOLFSSL_ABI
12513:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_3_client_method(void)
12514:../src/src/tls.c ****     {
12515:../src/src/tls.c ****         return wolfTLSv1_3_client_method_ex(NULL);
12516:../src/src/tls.c ****     }
12517:../src/src/tls.c **** 
12518:../src/src/tls.c ****     /* The TLS v1.3 client method data.
12519:../src/src/tls.c ****      *
12520:../src/src/tls.c ****      * heap  The heap used for allocation.
12521:../src/src/tls.c ****      * returns the method data for a TLS v1.3 client.
12522:../src/src/tls.c ****      */
12523:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_3_client_method_ex(void* heap)
12524:../src/src/tls.c ****     {
12525:../src/src/tls.c ****         WOLFSSL_METHOD* method = (WOLFSSL_METHOD*)
12526:../src/src/tls.c ****                                  XMALLOC(sizeof(WOLFSSL_METHOD), heap,
12527:../src/src/tls.c ****                                          DYNAMIC_TYPE_METHOD);
12528:../src/src/tls.c ****         (void)heap;
12529:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_3_client_method_ex");
12530:../src/src/tls.c ****         if (method)
12531:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_3());
12532:../src/src/tls.c ****         return method;
12533:../src/src/tls.c ****     }
12534:../src/src/tls.c **** #endif /* WOLFSSL_TLS13 */
12535:../src/src/tls.c **** 
12536:../src/src/tls.c **** #ifdef WOLFSSL_DTLS
12537:../src/src/tls.c **** 
12538:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLS_client_method(void)
12539:../src/src/tls.c ****     {
12540:../src/src/tls.c ****         return wolfDTLS_client_method_ex(NULL);
12541:../src/src/tls.c ****     }
12542:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLS_client_method_ex(void* heap)
12543:../src/src/tls.c ****     {
12544:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12545:../src/src/tls.c ****                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
12546:../src/src/tls.c ****                                                      heap, DYNAMIC_TYPE_METHOD);
12547:../src/src/tls.c ****         (void)heap;
12548:../src/src/tls.c ****         WOLFSSL_ENTER("DTLS_client_method_ex");
12549:../src/src/tls.c ****         if (method) {
12550:../src/src/tls.c ****         #if defined(WOLFSSL_DTLS13)
12551:../src/src/tls.c ****             InitSSL_Method(method, MakeDTLSv1_3());
12552:../src/src/tls.c ****         #elif !defined(WOLFSSL_NO_TLS12)
12553:../src/src/tls.c ****             InitSSL_Method(method, MakeDTLSv1_2());
12554:../src/src/tls.c ****         #elif !defined(NO_OLD_TLS)
12555:../src/src/tls.c ****             InitSSL_Method(method, MakeDTLSv1());
12556:../src/src/tls.c ****         #else
12557:../src/src/tls.c ****             #error No DTLS version enabled!
12558:../src/src/tls.c ****         #endif
12559:../src/src/tls.c **** 
12560:../src/src/tls.c ****             method->downgrade = 1;
12561:../src/src/tls.c ****             method->side      = WOLFSSL_CLIENT_END;
12562:../src/src/tls.c ****         }
12563:../src/src/tls.c ****         return method;
12564:../src/src/tls.c ****     }
12565:../src/src/tls.c **** 
12566:../src/src/tls.c ****     #ifndef NO_OLD_TLS
12567:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLSv1_client_method(void)
12568:../src/src/tls.c ****     {
12569:../src/src/tls.c ****         return wolfDTLSv1_client_method_ex(NULL);
12570:../src/src/tls.c ****     }
12571:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLSv1_client_method_ex(void* heap)
12572:../src/src/tls.c ****     {
12573:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12574:../src/src/tls.c ****                           (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
12575:../src/src/tls.c ****                                                  heap, DYNAMIC_TYPE_METHOD);
12576:../src/src/tls.c ****         (void)heap;
12577:../src/src/tls.c ****         WOLFSSL_ENTER("DTLSv1_client_method_ex");
12578:../src/src/tls.c ****         if (method)
12579:../src/src/tls.c ****             InitSSL_Method(method, MakeDTLSv1());
12580:../src/src/tls.c ****         return method;
12581:../src/src/tls.c ****     }
12582:../src/src/tls.c ****     #endif  /* NO_OLD_TLS */
12583:../src/src/tls.c **** 
12584:../src/src/tls.c ****     #ifndef WOLFSSL_NO_TLS12
12585:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLSv1_2_client_method(void)
12586:../src/src/tls.c ****     {
12587:../src/src/tls.c ****         return wolfDTLSv1_2_client_method_ex(NULL);
12588:../src/src/tls.c ****     }
12589:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLSv1_2_client_method_ex(void* heap)
12590:../src/src/tls.c ****     {
12591:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12592:../src/src/tls.c ****                           (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
12593:../src/src/tls.c ****                                                  heap, DYNAMIC_TYPE_METHOD);
12594:../src/src/tls.c ****         (void)heap;
12595:../src/src/tls.c ****         WOLFSSL_ENTER("DTLSv1_2_client_method_ex");
12596:../src/src/tls.c ****         if (method)
12597:../src/src/tls.c ****             InitSSL_Method(method, MakeDTLSv1_2());
12598:../src/src/tls.c ****         (void)heap;
12599:../src/src/tls.c ****         return method;
12600:../src/src/tls.c ****     }
12601:../src/src/tls.c ****     #endif /* !WOLFSSL_NO_TLS12 */
12602:../src/src/tls.c **** #endif /* WOLFSSL_DTLS */
12603:../src/src/tls.c **** 
12604:../src/src/tls.c **** #endif /* NO_WOLFSSL_CLIENT */
12605:../src/src/tls.c **** 
12606:../src/src/tls.c **** 
12607:../src/src/tls.c **** /* EITHER SIDE METHODS */
12608:../src/src/tls.c **** #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EITHER_SIDE)
12609:../src/src/tls.c ****     #ifndef NO_OLD_TLS
12610:../src/src/tls.c ****     #ifdef WOLFSSL_ALLOW_TLSV10
12611:../src/src/tls.c ****     /* Gets a WOLFSSL_METHOD type that is not set as client or server
12612:../src/src/tls.c ****      *
12613:../src/src/tls.c ****      * Returns a pointer to a WOLFSSL_METHOD struct
12614:../src/src/tls.c ****      */
12615:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_method(void)
12616:../src/src/tls.c ****     {
12617:../src/src/tls.c ****         return wolfTLSv1_method_ex(NULL);
12618:../src/src/tls.c ****     }
12619:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_method_ex(void* heap)
12620:../src/src/tls.c ****     {
12621:../src/src/tls.c ****         WOLFSSL_METHOD* m;
12622:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_method");
12623:../src/src/tls.c ****     #ifndef NO_WOLFSSL_CLIENT
12624:../src/src/tls.c ****         m = wolfTLSv1_client_method_ex(heap);
12625:../src/src/tls.c ****     #else
12626:../src/src/tls.c ****         m = wolfTLSv1_server_method_ex(heap);
12627:../src/src/tls.c ****     #endif
12628:../src/src/tls.c ****         if (m != NULL) {
12629:../src/src/tls.c ****             m->side = WOLFSSL_NEITHER_END;
12630:../src/src/tls.c ****         }
12631:../src/src/tls.c **** 
12632:../src/src/tls.c ****         return m;
12633:../src/src/tls.c ****     }
12634:../src/src/tls.c ****     #endif /* WOLFSSL_ALLOW_TLSV10 */
12635:../src/src/tls.c **** 
12636:../src/src/tls.c ****     /* Gets a WOLFSSL_METHOD type that is not set as client or server
12637:../src/src/tls.c ****      *
12638:../src/src/tls.c ****      * Returns a pointer to a WOLFSSL_METHOD struct
12639:../src/src/tls.c ****      */
12640:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_1_method(void)
12641:../src/src/tls.c ****     {
12642:../src/src/tls.c ****         return wolfTLSv1_1_method_ex(NULL);
12643:../src/src/tls.c ****     }
12644:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_1_method_ex(void* heap)
12645:../src/src/tls.c ****     {
12646:../src/src/tls.c ****         WOLFSSL_METHOD* m;
12647:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_1_method");
12648:../src/src/tls.c ****     #ifndef NO_WOLFSSL_CLIENT
12649:../src/src/tls.c ****         m = wolfTLSv1_1_client_method_ex(heap);
12650:../src/src/tls.c ****     #else
12651:../src/src/tls.c ****         m = wolfTLSv1_1_server_method_ex(heap);
12652:../src/src/tls.c ****     #endif
12653:../src/src/tls.c ****         if (m != NULL) {
12654:../src/src/tls.c ****             m->side = WOLFSSL_NEITHER_END;
12655:../src/src/tls.c ****         }
12656:../src/src/tls.c ****         return m;
12657:../src/src/tls.c ****     }
12658:../src/src/tls.c ****     #endif /* !NO_OLD_TLS */
12659:../src/src/tls.c **** 
12660:../src/src/tls.c ****     #ifndef WOLFSSL_NO_TLS12
12661:../src/src/tls.c ****     /* Gets a WOLFSSL_METHOD type that is not set as client or server
12662:../src/src/tls.c ****      *
12663:../src/src/tls.c ****      * Returns a pointer to a WOLFSSL_METHOD struct
12664:../src/src/tls.c ****      */
12665:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_2_method(void)
12666:../src/src/tls.c ****     {
12667:../src/src/tls.c ****         return wolfTLSv1_2_method_ex(NULL);
12668:../src/src/tls.c ****     }
12669:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_2_method_ex(void* heap)
12670:../src/src/tls.c ****     {
12671:../src/src/tls.c ****         WOLFSSL_METHOD* m;
12672:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_2_method");
12673:../src/src/tls.c ****     #ifndef NO_WOLFSSL_CLIENT
12674:../src/src/tls.c ****         m = wolfTLSv1_2_client_method_ex(heap);
12675:../src/src/tls.c ****     #else
12676:../src/src/tls.c ****         m = wolfTLSv1_2_server_method_ex(heap);
12677:../src/src/tls.c ****     #endif
12678:../src/src/tls.c ****         if (m != NULL) {
12679:../src/src/tls.c ****             m->side = WOLFSSL_NEITHER_END;
12680:../src/src/tls.c ****         }
12681:../src/src/tls.c ****         return m;
12682:../src/src/tls.c ****     }
12683:../src/src/tls.c ****     #endif /* !WOLFSSL_NO_TLS12 */
12684:../src/src/tls.c **** 
12685:../src/src/tls.c ****     #ifdef WOLFSSL_TLS13
12686:../src/src/tls.c ****     /* Gets a WOLFSSL_METHOD type that is not set as client or server
12687:../src/src/tls.c ****      *
12688:../src/src/tls.c ****      * Returns a pointer to a WOLFSSL_METHOD struct
12689:../src/src/tls.c ****      */
12690:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_3_method(void)
12691:../src/src/tls.c ****     {
12692:../src/src/tls.c ****         return wolfTLSv1_3_method_ex(NULL);
12693:../src/src/tls.c ****     }
12694:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_3_method_ex(void* heap)
12695:../src/src/tls.c ****     {
12696:../src/src/tls.c ****         WOLFSSL_METHOD* m;
12697:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_3_method");
12698:../src/src/tls.c ****     #ifndef NO_WOLFSSL_CLIENT
12699:../src/src/tls.c ****         m = wolfTLSv1_3_client_method_ex(heap);
12700:../src/src/tls.c ****     #else
12701:../src/src/tls.c ****         m = wolfTLSv1_3_server_method_ex(heap);
12702:../src/src/tls.c ****     #endif
12703:../src/src/tls.c ****         if (m != NULL) {
12704:../src/src/tls.c ****             m->side = WOLFSSL_NEITHER_END;
12705:../src/src/tls.c ****         }
12706:../src/src/tls.c ****         return m;
12707:../src/src/tls.c ****     }
12708:../src/src/tls.c ****     #endif /* WOLFSSL_TLS13 */
12709:../src/src/tls.c **** 
12710:../src/src/tls.c **** #ifdef WOLFSSL_DTLS
12711:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLS_method(void)
12712:../src/src/tls.c ****     {
12713:../src/src/tls.c ****         return wolfDTLS_method_ex(NULL);
12714:../src/src/tls.c ****     }
12715:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLS_method_ex(void* heap)
12716:../src/src/tls.c ****     {
12717:../src/src/tls.c ****         WOLFSSL_METHOD* m;
12718:../src/src/tls.c ****         WOLFSSL_ENTER("DTLS_method_ex");
12719:../src/src/tls.c ****     #ifndef NO_WOLFSSL_CLIENT
12720:../src/src/tls.c ****         m = wolfDTLS_client_method_ex(heap);
12721:../src/src/tls.c ****     #else
12722:../src/src/tls.c ****         m = wolfDTLS_server_method_ex(heap);
12723:../src/src/tls.c ****     #endif
12724:../src/src/tls.c ****         if (m != NULL) {
12725:../src/src/tls.c ****             m->side = WOLFSSL_NEITHER_END;
12726:../src/src/tls.c ****         }
12727:../src/src/tls.c ****         return m;
12728:../src/src/tls.c ****     }
12729:../src/src/tls.c **** 
12730:../src/src/tls.c ****     #ifndef NO_OLD_TLS
12731:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLSv1_method(void)
12732:../src/src/tls.c ****     {
12733:../src/src/tls.c ****         return wolfDTLSv1_method_ex(NULL);
12734:../src/src/tls.c ****     }
12735:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLSv1_method_ex(void* heap)
12736:../src/src/tls.c ****     {
12737:../src/src/tls.c ****         WOLFSSL_METHOD* m;
12738:../src/src/tls.c ****         WOLFSSL_ENTER("DTLSv1_method_ex");
12739:../src/src/tls.c ****     #ifndef NO_WOLFSSL_CLIENT
12740:../src/src/tls.c ****         m = wolfDTLSv1_client_method_ex(heap);
12741:../src/src/tls.c ****     #else
12742:../src/src/tls.c ****         m = wolfDTLSv1_server_method_ex(heap);
12743:../src/src/tls.c ****     #endif
12744:../src/src/tls.c ****         if (m != NULL) {
12745:../src/src/tls.c ****             m->side = WOLFSSL_NEITHER_END;
12746:../src/src/tls.c ****         }
12747:../src/src/tls.c ****         return m;
12748:../src/src/tls.c ****     }
12749:../src/src/tls.c ****     #endif /* !NO_OLD_TLS */
12750:../src/src/tls.c ****     #ifndef WOLFSSL_NO_TLS12
12751:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLSv1_2_method(void)
12752:../src/src/tls.c ****     {
12753:../src/src/tls.c ****         return wolfDTLSv1_2_method_ex(NULL);
12754:../src/src/tls.c ****     }
12755:../src/src/tls.c ****     WOLFSSL_METHOD* wolfDTLSv1_2_method_ex(void* heap)
12756:../src/src/tls.c ****     {
12757:../src/src/tls.c ****         WOLFSSL_METHOD* m;
12758:../src/src/tls.c ****         WOLFSSL_ENTER("DTLSv1_2_method");
12759:../src/src/tls.c ****     #ifndef NO_WOLFSSL_CLIENT
12760:../src/src/tls.c ****         m = wolfDTLSv1_2_client_method_ex(heap);
12761:../src/src/tls.c ****     #else
12762:../src/src/tls.c ****         m = wolfDTLSv1_2_server_method_ex(heap);
12763:../src/src/tls.c ****     #endif
12764:../src/src/tls.c ****         if (m != NULL) {
12765:../src/src/tls.c ****             m->side = WOLFSSL_NEITHER_END;
12766:../src/src/tls.c ****         }
12767:../src/src/tls.c ****         return m;
12768:../src/src/tls.c ****     }
12769:../src/src/tls.c ****     #endif /* !WOLFSSL_NO_TLS12 */
12770:../src/src/tls.c **** #endif /* WOLFSSL_DTLS */
12771:../src/src/tls.c **** #endif /* OPENSSL_EXTRA || WOLFSSL_EITHER_SIDE */
12772:../src/src/tls.c **** 
12773:../src/src/tls.c **** 
12774:../src/src/tls.c **** #ifndef NO_WOLFSSL_SERVER
12775:../src/src/tls.c **** 
12776:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLS_server_method(void)
12777:../src/src/tls.c ****     {
 8398                             		.loc 2 12777 5
 8399 0000 7E AA                   		push.l	r10
 8400                             	.LCFI198:
 8401 0002 EF 0A                   		mov.L	r0, r10
 8402                             	.LCFI199:
12778:../src/src/tls.c ****         return wolfTLS_server_method_ex(NULL);
 8403                             		.loc 2 12778 16
 8404 0004 66 01                   		mov.L	#0, r1
 8405 0006 05 00 00 00             		bsr	_wolfTLS_server_method_ex
 8406 000a EF 15                   		mov.L	r1, r5
12779:../src/src/tls.c ****     }
 8407                             		.loc 2 12779 5
 8408 000c EF 51                   		mov.L	r5, r1
 8409 000e 3F AA 01                		rtsd	#4, r10-r10
 8410                             	.LFE119:
 8412                             		.section C,"a",@progbits
 8413 0455 00 00 00                		.p2align 2
 8414                             	.LC31:
 8415 0458 54 4C 53 5F 73 65 72 76 		.string	"TLS_server_method_ex"
 8415      65 72 5F 6D 65 74 68 6F 
 8415      64 5F 65 78 00 
 8416                             		.section	.text.wolfTLS_server_method_ex,"ax",@progbits
 8417                             		.global	_wolfTLS_server_method_ex
 8419                             	_wolfTLS_server_method_ex:
 8420                             	.LFB120:
12780:../src/src/tls.c **** 
12781:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLS_server_method_ex(void* heap)
12782:../src/src/tls.c ****     {
 8421                             		.loc 2 12782 5
 8422 0000 7E AA                   		push.l	r10
 8423                             	.LCFI200:
 8424 0002 71 0A F4                		add	#-12, r0, r10
 8425                             	.LCFI201:
 8426 0005 71 A0 FC                		add	#-4, r10, r0
 8427                             	.LCFI202:
 8428 0008 E7 A1 02                		mov.L	r1, 8[r10]
12783:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12784:../src/src/tls.c ****                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
 8429                             		.loc 2 12784 49
 8430 000b 66 41                   		mov.L	#4, r1
 8431 000d 05 00 00 00             		bsr	_wolfSSL_Malloc
 8432 0011 E3 A1                   		mov.L	r1, [r10]
12785:../src/src/tls.c ****                                                      heap, DYNAMIC_TYPE_METHOD);
12786:../src/src/tls.c ****         (void)heap;
12787:../src/src/tls.c ****         WOLFSSL_ENTER("TLS_server_method_ex");
 8433                             		.loc 2 12787 9
 8434 0013 FB 12 58 04 00 00       		mov.L	#.LC31, r1
 8435 0019 05 00 00 00             		bsr	_WOLFSSL_ENTER
12788:../src/src/tls.c ****         if (method) {
 8436                             		.loc 2 12788 12
 8437 001d EC A5                   		mov.L	[r10], r5
 8438 001f 61 05                   		cmp	#0, r5
 8439 0021 20 20                   		beq	.L625
12789:../src/src/tls.c ****         #if defined(WOLFSSL_TLS13)
12790:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_3());
12791:../src/src/tls.c ****         #elif !defined(WOLFSSL_NO_TLS12)
12792:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_2());
 8440                             		.loc 2 12792 13
 8441 0023 71 A5 04                		add	#4, r10, r5
 8442 0026 EF 5F                   		mov.L	r5, r15
 8443 0028 05 00 00 00             		bsr	_MakeTLSv1_2
 8444 002c DD A5 02                		mov.W	4[r10], r5
 8445 002f D3 05                   		mov.W	r5, [r0]
 8446 0031 EC A1                   		mov.L	[r10], r1
 8447 0033 05 00 00 00             		bsr	_InitSSL_Method
12793:../src/src/tls.c ****         #elif !defined(NO_OLD_TLS)
12794:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_1());
12795:../src/src/tls.c ****         #elif defined(WOLFSSL_ALLOW_TLSV10)
12796:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1());
12797:../src/src/tls.c ****         #else
12798:../src/src/tls.c ****             #error No TLS version enabled!
12799:../src/src/tls.c ****         #endif
12800:../src/src/tls.c **** 
12801:../src/src/tls.c ****             method->downgrade = 1;
 8448                             		.loc 2 12801 31
 8449 0037 EC A5                   		mov.L	[r10], r5
 8450 0039 3C 53 01                		mov.B	#1, 3[r5]
12802:../src/src/tls.c ****             method->side      = WOLFSSL_SERVER_END;
 8451                             		.loc 2 12802 31
 8452 003c EC A5                   		mov.L	[r10], r5
 8453 003e 3C 52 00                		mov.B	#0, 2[r5]
 8454                             	.L625:
12803:../src/src/tls.c ****         }
12804:../src/src/tls.c ****         return method;
 8455                             		.loc 2 12804 16
 8456 0041 EC A5                   		mov.L	[r10], r5
12805:../src/src/tls.c ****     }
 8457                             		.loc 2 12805 5
 8458 0043 EF 51                   		mov.L	r5, r1
 8459 0045 3F AA 05                		rtsd	#20, r10-r10
 8460                             	.LFE120:
 8462                             		.section	.text.wolfTLSv1_1_server_method,"ax",@progbits
 8463                             		.global	_wolfTLSv1_1_server_method
 8465                             	_wolfTLSv1_1_server_method:
 8466                             	.LFB121:
12806:../src/src/tls.c **** 
12807:../src/src/tls.c **** #ifndef NO_OLD_TLS
12808:../src/src/tls.c ****     #ifdef WOLFSSL_ALLOW_TLSV10
12809:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_server_method(void)
12810:../src/src/tls.c ****     {
12811:../src/src/tls.c ****         return wolfTLSv1_server_method_ex(NULL);
12812:../src/src/tls.c ****     }
12813:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_server_method_ex(void* heap)
12814:../src/src/tls.c ****     {
12815:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12816:../src/src/tls.c ****                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
12817:../src/src/tls.c ****                                                      heap, DYNAMIC_TYPE_METHOD);
12818:../src/src/tls.c ****         (void)heap;
12819:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_server_method_ex");
12820:../src/src/tls.c ****         if (method) {
12821:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1());
12822:../src/src/tls.c ****             method->side = WOLFSSL_SERVER_END;
12823:../src/src/tls.c ****         }
12824:../src/src/tls.c ****         return method;
12825:../src/src/tls.c ****     }
12826:../src/src/tls.c ****     #endif /* WOLFSSL_ALLOW_TLSV10 */
12827:../src/src/tls.c **** 
12828:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_1_server_method(void)
12829:../src/src/tls.c ****     {
 8467                             		.loc 2 12829 5
 8468 0000 7E AA                   		push.l	r10
 8469                             	.LCFI203:
 8470 0002 EF 0A                   		mov.L	r0, r10
 8471                             	.LCFI204:
12830:../src/src/tls.c ****         return wolfTLSv1_1_server_method_ex(NULL);
 8472                             		.loc 2 12830 16
 8473 0004 66 01                   		mov.L	#0, r1
 8474 0006 05 00 00 00             		bsr	_wolfTLSv1_1_server_method_ex
 8475 000a EF 15                   		mov.L	r1, r5
12831:../src/src/tls.c ****     }
 8476                             		.loc 2 12831 5
 8477 000c EF 51                   		mov.L	r5, r1
 8478 000e 3F AA 01                		rtsd	#4, r10-r10
 8479                             	.LFE121:
 8481                             		.section C,"a",@progbits
 8482 046d 00 00 00                		.p2align 2
 8483                             	.LC32:
 8484 0470 54 4C 53 76 31 5F 31 5F 		.string	"TLSv1_1_server_method_ex"
 8484      73 65 72 76 65 72 5F 6D 
 8484      65 74 68 6F 64 5F 65 78 
 8484      00 
 8485                             		.section	.text.wolfTLSv1_1_server_method_ex,"ax",@progbits
 8486                             		.global	_wolfTLSv1_1_server_method_ex
 8488                             	_wolfTLSv1_1_server_method_ex:
 8489                             	.LFB122:
12832:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_1_server_method_ex(void* heap)
12833:../src/src/tls.c ****     {
 8490                             		.loc 2 12833 5
 8491 0000 7E AA                   		push.l	r10
 8492                             	.LCFI205:
 8493 0002 71 0A F4                		add	#-12, r0, r10
 8494                             	.LCFI206:
 8495 0005 71 A0 FC                		add	#-4, r10, r0
 8496                             	.LCFI207:
 8497 0008 E7 A1 02                		mov.L	r1, 8[r10]
12834:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12835:../src/src/tls.c ****                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
 8498                             		.loc 2 12835 49
 8499 000b 66 41                   		mov.L	#4, r1
 8500 000d 05 00 00 00             		bsr	_wolfSSL_Malloc
 8501 0011 E3 A1                   		mov.L	r1, [r10]
12836:../src/src/tls.c ****                                                      heap, DYNAMIC_TYPE_METHOD);
12837:../src/src/tls.c ****         (void)heap;
12838:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_1_server_method_ex");
 8502                             		.loc 2 12838 9
 8503 0013 FB 12 70 04 00 00       		mov.L	#.LC32, r1
 8504 0019 05 00 00 00             		bsr	_WOLFSSL_ENTER
12839:../src/src/tls.c ****         if (method) {
 8505                             		.loc 2 12839 12
 8506 001d EC A5                   		mov.L	[r10], r5
 8507 001f 61 05                   		cmp	#0, r5
 8508 0021 20 1B                   		beq	.L630
12840:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_1());
 8509                             		.loc 2 12840 13
 8510 0023 71 A5 04                		add	#4, r10, r5
 8511 0026 EF 5F                   		mov.L	r5, r15
 8512 0028 05 00 00 00             		bsr	_MakeTLSv1_1
 8513 002c DD A5 02                		mov.W	4[r10], r5
 8514 002f D3 05                   		mov.W	r5, [r0]
 8515 0031 EC A1                   		mov.L	[r10], r1
 8516 0033 05 00 00 00             		bsr	_InitSSL_Method
12841:../src/src/tls.c ****             method->side = WOLFSSL_SERVER_END;
 8517                             		.loc 2 12841 26
 8518 0037 EC A5                   		mov.L	[r10], r5
 8519 0039 3C 52 00                		mov.B	#0, 2[r5]
 8520                             	.L630:
12842:../src/src/tls.c ****         }
12843:../src/src/tls.c ****         return method;
 8521                             		.loc 2 12843 16
 8522 003c EC A5                   		mov.L	[r10], r5
12844:../src/src/tls.c ****     }
 8523                             		.loc 2 12844 5
 8524 003e EF 51                   		mov.L	r5, r1
 8525 0040 3F AA 05                		rtsd	#20, r10-r10
 8526                             	.LFE122:
 8528                             		.section	.text.wolfTLSv1_2_server_method,"ax",@progbits
 8529                             		.global	_wolfTLSv1_2_server_method
 8531                             	_wolfTLSv1_2_server_method:
 8532                             	.LFB123:
12845:../src/src/tls.c **** #endif /* !NO_OLD_TLS */
12846:../src/src/tls.c **** 
12847:../src/src/tls.c **** 
12848:../src/src/tls.c **** #ifndef WOLFSSL_NO_TLS12
12849:../src/src/tls.c ****     WOLFSSL_ABI
12850:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_2_server_method(void)
12851:../src/src/tls.c ****     {
 8533                             		.loc 2 12851 5
 8534 0000 7E AA                   		push.l	r10
 8535                             	.LCFI208:
 8536 0002 EF 0A                   		mov.L	r0, r10
 8537                             	.LCFI209:
12852:../src/src/tls.c ****         return wolfTLSv1_2_server_method_ex(NULL);
 8538                             		.loc 2 12852 16
 8539 0004 66 01                   		mov.L	#0, r1
 8540 0006 05 00 00 00             		bsr	_wolfTLSv1_2_server_method_ex
 8541 000a EF 15                   		mov.L	r1, r5
12853:../src/src/tls.c ****     }
 8542                             		.loc 2 12853 5
 8543 000c EF 51                   		mov.L	r5, r1
 8544 000e 3F AA 01                		rtsd	#4, r10-r10
 8545                             	.LFE123:
 8547                             		.section C,"a",@progbits
 8548 0489 00 00 00                		.p2align 2
 8549                             	.LC33:
 8550 048c 54 4C 53 76 31 5F 32 5F 		.string	"TLSv1_2_server_method_ex"
 8550      73 65 72 76 65 72 5F 6D 
 8550      65 74 68 6F 64 5F 65 78 
 8550      00 
 8551 04a5 00 00 00                		.section	.text.wolfTLSv1_2_server_method_ex,"ax",@progbits
 8552                             		.global	_wolfTLSv1_2_server_method_ex
 8554                             	_wolfTLSv1_2_server_method_ex:
 8555                             	.LFB124:
12854:../src/src/tls.c ****     WOLFSSL_METHOD* wolfTLSv1_2_server_method_ex(void* heap)
12855:../src/src/tls.c ****     {
 8556                             		.loc 2 12855 5
 8557 0000 7E AA                   		push.l	r10
 8558                             	.LCFI210:
 8559 0002 71 0A F4                		add	#-12, r0, r10
 8560                             	.LCFI211:
 8561 0005 71 A0 FC                		add	#-4, r10, r0
 8562                             	.LCFI212:
 8563 0008 E7 A1 02                		mov.L	r1, 8[r10]
12856:../src/src/tls.c ****         WOLFSSL_METHOD* method =
12857:../src/src/tls.c ****                               (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
 8564                             		.loc 2 12857 49
 8565 000b 66 41                   		mov.L	#4, r1
 8566 000d 05 00 00 00             		bsr	_wolfSSL_Malloc
 8567 0011 E3 A1                   		mov.L	r1, [r10]
12858:../src/src/tls.c ****                                                      heap, DYNAMIC_TYPE_METHOD);
12859:../src/src/tls.c ****         (void)heap;
12860:../src/src/tls.c ****         WOLFSSL_ENTER("TLSv1_2_server_method_ex");
 8568                             		.loc 2 12860 9
 8569 0013 FB 12 8C 04 00 00       		mov.L	#.LC33, r1
 8570 0019 05 00 00 00             		bsr	_WOLFSSL_ENTER
12861:../src/src/tls.c ****         if (method) {
 8571                             		.loc 2 12861 12
 8572 001d EC A5                   		mov.L	[r10], r5
 8573 001f 61 05                   		cmp	#0, r5
 8574 0021 20 1B                   		beq	.L635
12862:../src/src/tls.c ****             InitSSL_Method(method, MakeTLSv1_2());
 8575                             		.loc 2 12862 13
 8576 0023 71 A5 04                		add	#4, r10, r5
 8577 0026 EF 5F                   		mov.L	r5, r15
 8578 0028 05 00 00 00             		bsr	_MakeTLSv1_2
 8579 002c DD A5 02                		mov.W	4[r10], r5
 8580 002f D3 05                   		mov.W	r5, [r0]
 8581 0031 EC A1                   		mov.L	[r10], r1
 8582 0033 05 00 00 00             		bsr	_InitSSL_Method
12863:../src/src/tls.c ****             method->side = WOLFSSL_SERVER_END;
 8583                             		.loc 2 12863 26
 8584 0037 EC A5                   		mov.L	[r10], r5
 8585 0039 3C 52 00                		mov.B	#0, 2[r5]
 8586                             	.L635:
12864:../src/src/tls.c ****         }
12865:../src/src/tls.c ****         return method;
 8587                             		.loc 2 12865 16
 8588 003c EC A5                   		mov.L	[r10], r5
12866:../src/src/tls.c ****     }
 8589                             		.loc 2 12866 5
 8590 003e EF 51                   		mov.L	r5, r1
 8591 0040 3F AA 05                		rtsd	#20, r10-r10
 8592                             	.LFE124:
 10600                             	.Letext0:
 10601                             		.file 3 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/wc_port.h"
 10602                             		.file 4 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\lib\\gcc\\rx-
 10603                             		.file 5 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 10604                             		.file 6 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 10605                             		.file 7 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 10606                             		.file 8 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 10607                             		.file 9 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/types.h"
 10608                             		.file 10 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\incl
 10609                             		.file 11 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\incl
 10610                             		.file 12 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sp_int.h"
 10611                             		.file 13 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha256.h"
 10612                             		.file 14 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/random.h"
 10613                             		.file 15 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/wolfmath.h"
 10614                             		.file 16 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/dsa.h"
 10615                             		.file 17 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/asn_public.h"
 10616                             		.file 18 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/ecc.h"
 10617                             		.file 19 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/ed25519.h"
 10618                             		.file 20 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/curve25519.h"
 10619                             		.file 21 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/rsa.h"
 10620                             		.file 22 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/dh.h"
 10621                             		.file 23 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/error-crypt.h"
 10622                             		.file 24 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/md5.h"
 10623                             		.file 25 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha.h"
 10624                             		.file 26 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha512.h"
 10625                             		.file 27 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/md4.h"
 10626                             		.file 28 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/hash.h"
 10627                             		.file 29 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/hmac.h"
 10628                             		.file 30 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/openssl/compat_types.h"
 10629                             		.file 31 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/ssl.h"
 10630                             		.file 32 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/callbacks.h"
 10631                             		.file 33 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/internal.h"
 10632                             		.file 34 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfio.h"
 10633                             		.file 35 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/asn.h"
 10634                             		.file 36 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/des3.h"
 10635                             		.file 37 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/aes.h"
 10636                             		.file 38 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/ocsp.h"
 10637                             		.file 39 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/fe_operations.h"
 10638                             		.file 40 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/kdf.h"
 10639                             		.file 41 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/error-ssl.h"
