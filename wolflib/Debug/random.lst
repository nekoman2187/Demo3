   1                             		.file	"random.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.section	.text.rotlFixed,"ax",@progbits
   6                             	_rotlFixed:
   7                             	.LFB1:
   8                             		.file 1 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfcrypt/src/misc.c"
   1:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* misc.c
   2:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   3:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   5:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * This file is part of wolfSSL.
   6:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   7:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * it under the terms of the GNU General Public License as published by
   9:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * (at your option) any later version.
  11:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  12:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * GNU General Public License for more details.
  16:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  17:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * You should have received a copy of the GNU General Public License
  18:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * along with this program; if not, write to the Free Software
  19:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  21:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /*
  22:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  23:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** DESCRIPTION
  24:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** This module implements the arithmetic-shift right, left, byte swapping, XOR,
  25:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** masking and clearing memory logic.
  26:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  27:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** */
  28:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef HAVE_CONFIG_H
  29:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <config.h>
  30:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  31:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  32:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/settings.h>
  33:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  34:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLF_CRYPT_MISC_C
  35:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #define WOLF_CRYPT_MISC_C
  36:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  37:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/misc.h>
  38:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  39:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* inlining these functions is a huge speed increase and a small size decrease,
  40:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    because the functions are smaller than function call setup/cleanup, e.g.,
  41:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    md5 benchmark is twice as fast with inline.  If you don't want it, then
  42:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    define NO_INLINE and compile this file into wolfssl, otherwise it's used as
  43:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    a source header
  44:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  45:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  46:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef NO_INLINE
  47:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC
  48:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  49:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC static
  50:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  51:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  52:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Check for if compiling misc.c when not needed. */
  53:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if !defined(WOLFSSL_MISC_INCLUDED) && !defined(NO_INLINE)
  54:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_IGNORE_FILE_WARN
  55:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #warning misc.c does not need to be compiled when using inline (NO_INLINE not defined)
  56:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
  57:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  58:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  59:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  60:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  61:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__ICCARM__)
  62:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <intrinsics.h>
  63:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  64:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  65:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  66:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef INTEL_INTRINSICS
  67:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  68:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <stdlib.h>      /* get intrinsic definitions */
  69:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  70:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* for non visual studio probably need no long version, 32 bit only
  71:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****      * i.e., _rotl and _rotr */
  72:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #pragma intrinsic(_lrotl, _lrotr)
  73:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  74:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  75:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  76:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotl(x, y) : x;
  77:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  78:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  79:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
  80:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  81:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotr(x, y) : x;
  82:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  83:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  84:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
  85:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  86:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <builtin.h>      /* get intrinsic definitions */
  87:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  88:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if !defined(NO_INLINE)
  89:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  90:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotlFixed(x, y) _builtin_rotl(x, y)
  91:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  92:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotrFixed(x, y) _builtin_rotr(x, y)
  93:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  94:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #else /* create real function */
  95:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  96:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  97:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  98:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotl(x, y);
  99:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 100:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 101:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 102:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 103:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotr(x, y);
 104:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 105:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 106:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 107:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 108:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else /* generic */
 109:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value. */
 110:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 111:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
 112:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
   9                             		.loc 1 112 5
  10 0000 6E 7A                   		pushm	r7-r10
  11                             	.LCFI0:
  12 0002 71 0A F8                		add	#-8, r0, r10
  13                             	.LCFI1:
  14 0005 EF A0                   		mov.L	r10, r0
  15 0007 E3 A1                   		mov.L	r1, [r10]
  16 0009 E7 A2 01                		mov.L	r2, 4[r10]
 113:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x << y) | (x >> (sizeof(y) * 8 - y));
  17                             		.loc 1 113 25
  18 000c EC A4                   		mov.L	[r10], r4
  19 000e ED A5 01                		mov.L	4[r10], r5
  20 0011 EF 47                   		mov.L	r4, r7
  21 0013 FD 66 57                		rotl	r5, r7
  22 0016 EF 75                   		mov.L	r7, r5
 114:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  23                             		.loc 1 114 5
  24 0018 EF 51                   		mov.L	r5, r1
  25 001a 3F 7A 06                		rtsd	#24, r7-r10
  26                             	.LFE1:
  28                             		.section	.text.ByteReverseWord32,"ax",@progbits
  30                             	_ByteReverseWord32:
  31                             	.LFB3:
 115:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 116:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value. */
 117:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 118:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 119:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x >> y) | (x << (sizeof(y) * 8 - y));
 120:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 121:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 122:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 123:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 124:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef WC_RC2
 125:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 126:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value */
 127:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotlFixed16(word16 x, word16 y)
 128:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 129:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 130:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 131:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 132:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 133:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value */
 134:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotrFixed16(word16 x, word16 y)
 135:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 136:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 137:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 138:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 139:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WC_RC2 */
 140:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 141:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of 32-bit word value. */
 142:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__CCRX__) && !defined(NO_INLINE) /* shortest version for CC-RX */
 143:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define ByteReverseWord32(value) _builtin_revl(value)
 144:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 145:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word32 ByteReverseWord32(word32 value)
 146:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
  32                             		.loc 1 146 1
  33 0000 7E AA                   		push.l	r10
  34                             	.LCFI2:
  35 0002 71 0A FC                		add	#-4, r0, r10
  36                             	.LCFI3:
  37 0005 EF A0                   		mov.L	r10, r0
  38 0007 E3 A1                   		mov.L	r1, [r10]
 147:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef PPC_INTRINSICS
 148:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* PPC: load reverse indexed instruction */
 149:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__lwbrx(&value,0);
 150:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__ICCARM__)
 151:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__REV(value);
 152:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(KEIL_INTRINSICS)
 153:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__rev(value);
 154:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
 155:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)_builtin_revl(value);
 156:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLF_ALLOW_BUILTIN) && \
 157:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 158:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__builtin_bswap32(value);
 159:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 160:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       defined(__aarch64__)
 161:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 162:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV32 %0, %0  \n"
 163:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 164:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 165:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 166:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 167:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 168:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       (defined(__thumb__) || defined(__arm__))
 169:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 170:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV %0, %0  \n"
 171:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 172:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 173:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 174:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 175:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(FAST_ROTATE)
 176:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 5 instructions with rotate instruction, 9 without */
 177:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (rotrFixed(value, 8U) & 0xff00ff00) |
 178:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****            (rotlFixed(value, 8U) & 0x00ff00ff);
 179:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 180:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 6 instructions with rotate instruction, 8 without */
 181:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
  39                             		.loc 1 181 35
  40 0009 EC A5                   		mov.L	[r10], r5
  41 000b 68 85                   		shlr	#8, r5
  42 000d FB 42 FF 00 FF 00       		mov.L	#0xff00ff, r4
  43 0013 53 54                   		and	r5, r4
  44                             		.loc 1 181 65
  45 0015 EC A5                   		mov.L	[r10], r5
  46 0017 6C 85                   		shll	#8, r5
  47 0019 74 25 00 FF 00 FF       		and	#-16711936, r5
  48                             		.loc 1 181 11
  49 001f 57 45                   		or	r4, r5
  50 0021 E3 A5                   		mov.L	r5, [r10]
 182:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed(value, 16U);
  51                             		.loc 1 182 12
  52 0023 75 42 10                		mov.L	#16, r2
  53 0026 EC A1                   		mov.L	[r10], r1
  54 0028 05 00 00 00             		bsr	_rotlFixed
  55 002c EF 15                   		mov.L	r1, r5
 183:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 184:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
  56                             		.loc 1 184 1
  57 002e EF 51                   		mov.L	r5, r1
  58 0030 3F AA 02                		rtsd	#8, r10-r10
  59                             	.LFE3:
  61                             		.section	.text.ForceZero,"ax",@progbits
  63                             	_ForceZero:
  64                             	.LFB13:
 185:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* __CCRX__ */
 186:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of words array of a given count. */
 187:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords(word32* out, const word32* in,
 188:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                     word32 byteCount)
 189:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 190:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word32), i;
 191:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 192:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 193:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord32(in[i]);
 194:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 195:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 196:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 197:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WORD64_AVAILABLE) && !defined(WOLFSSL_NO_WORD64_OPS)
 198:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 199:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 200:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotlFixed64(word64 x, word64 y)
 201:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 202:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 203:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 204:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 205:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 206:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotrFixed64(word64 x, word64 y)
 207:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 208:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 209:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 210:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 211:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 212:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 ByteReverseWord64(word64 value)
 213:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 214:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WOLF_ALLOW_BUILTIN) && defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 215:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)__builtin_bswap64(value);
 216:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFCRYPT_SLOW_WORD64)
 217:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)((word64)ByteReverseWord32((word32) value)) << 32 |
 218:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         (word64)ByteReverseWord32((word32)(value   >> 32));
 219:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 220:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) |
 221:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
 222:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) |
 223:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
 224:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed64(value, 32U);
 225:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 226:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 227:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 228:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 229:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords64(word64* out, const word64* in,
 230:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                       word32 byteCount)
 231:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 232:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word64), i;
 233:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 234:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 235:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord64(in[i]);
 236:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 237:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 238:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 239:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WORD64_AVAILABLE && !WOLFSSL_NO_WORD64_OPS */
 240:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 241:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_XOR_OPS
 242:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 243:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 244:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWordsOut(wolfssl_word* r, const wolfssl_word* a,
 245:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                      const wolfssl_word* b, word32 n)
 246:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 247:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 248:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 249:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] = a[i] ^ b[i];
 250:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 251:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 252:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 253:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 254:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 255:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbufout(void*out, const void* buf, const void* mask,
 256:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                    word32 count)
 257:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 258:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)out | (wc_ptr_t)buf | (wc_ptr_t)mask | count) %
 259:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                          WOLFSSL_WORD_SIZE == 0)
 260:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWordsOut( (wolfssl_word*)out, (wolfssl_word*)buf,
 261:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                      (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 262:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 263:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 264:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       o = (byte*)out;
 265:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 266:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 267:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 268:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) o[i] = b[i] ^ m[i];
 269:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 270:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 271:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 272:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 273:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 274:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWords(wolfssl_word* r, const wolfssl_word* a, word32 n)
 275:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 276:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 277:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 278:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] ^= a[i];
 279:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 280:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 281:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 282:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 283:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 284:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbuf(void* buf, const void* mask, word32 count)
 285:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 286:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)buf | (wc_ptr_t)mask | count) % WOLFSSL_WORD_SIZE == 0)
 287:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWords( (wolfssl_word*)buf,
 288:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                   (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 289:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 290:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 291:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 292:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 293:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 294:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) b[i] ^= m[i];
 295:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 296:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 297:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 298:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 299:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_FORCE_ZERO
 300:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine fills the first len bytes of the memory area pointed by mem
 301:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    with zeros. It ensures compiler optimizations doesn't skip it  */
 302:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
 303:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
  65                             		.loc 1 303 1
  66 0000 7E AA                   		push.l	r10
  67                             	.LCFI4:
  68 0002 71 0A F4                		add	#-12, r0, r10
  69                             	.LCFI5:
  70 0005 EF A0                   		mov.L	r10, r0
  71 0007 E7 A1 01                		mov.L	r1, 4[r10]
  72 000a E7 A2 02                		mov.L	r2, 8[r10]
 304:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile byte* z = (volatile byte*)mem;
  73                             		.loc 1 304 20
  74 000d ED A5 01                		mov.L	4[r10], r5
  75 0010 E3 A5                   		mov.L	r5, [r10]
 305:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 306:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if (defined(WOLFSSL_X86_64_BUILD) || defined(WOLFSSL_AARCH64_BUILD)) \
 307:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****             && defined(WORD64_AVAILABLE)
 308:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile word64* w;
 309:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_UNALIGNED_64BIT_ACCESS
 310:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 l = (sizeof(word64) - ((size_t)z & (sizeof(word64)-1))) &
 311:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                              (sizeof(word64)-1);
 312:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 313:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         if (len < l) l = len;
 314:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         len -= l;
 315:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         while (l--) *z++ = 0;
 316:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 317:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
 318:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         *w++ = 0;
 319:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     z = (volatile byte*)w;
 320:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 321:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 322:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     while (len--) *z++ = 0;
  76                             		.loc 1 322 11
  77 0012 2E 0C                   		bra	.L6
  78                             	.L7:
  79                             		.loc 1 322 21 discriminator 2
  80 0014 EC A5                   		mov.L	[r10], r5
  81 0016 71 54 01                		add	#1, r5, r4
  82 0019 E3 A4                   		mov.L	r4, [r10]
  83                             		.loc 1 322 24 discriminator 2
  84 001b F8 54 00                		mov.B	#0, [r5]
  85                             	.L6:
  86                             		.loc 1 322 15 discriminator 1
  87 001e ED A5 02                		mov.L	8[r10], r5
  88 0021 71 54 FF                		add	#-1, r5, r4
  89 0024 E7 A4 02                		mov.L	r4, 8[r10]
  90                             		.loc 1 322 11 discriminator 1
  91 0027 61 05                   		cmp	#0, r5
  92 0029 21 EB                   		bne	.L7
 323:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
  93                             		.loc 1 323 1
  94 002b 03                      		nop
  95 002c 3F AA 04                		rtsd	#16, r10-r10
  96                             	.LFE13:
  98                             		.section	.text.ConstantCompare,"ax",@progbits
 100                             	_ConstantCompare:
 101                             	.LFB14:
 324:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 325:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 326:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 327:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_CONST_CMP
 328:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* check all length bytes for equality, return 0 on success */
 329:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE int ConstantCompare(const byte* a, const byte* b, int length)
 330:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 102                             		.loc 1 330 1
 103 0000 7E AA                   		push.l	r10
 104                             	.LCFI6:
 105 0002 71 0A EC                		add	#-20, r0, r10
 106                             	.LCFI7:
 107 0005 EF A0                   		mov.L	r10, r0
 108 0007 E7 A1 02                		mov.L	r1, 8[r10]
 109 000a E7 A2 03                		mov.L	r2, 12[r10]
 110 000d E7 A3 04                		mov.L	r3, 16[r10]
 331:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int i;
 332:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     int compareSum = 0;
 111                             		.loc 1 332 9
 112 0010 F9 A6 01 00             		mov.L	#0, 4[r10]
 333:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 334:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < length; i++) {
 113                             		.loc 1 334 12
 114 0014 F8 A6 00                		mov.L	#0, [r10]
 115                             		.loc 1 334 5
 116 0017 2E 27                   		bra	.L9
 117                             	.L10:
 335:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         compareSum |= a[i] ^ b[i];
 118                             		.loc 1 335 24 discriminator 3
 119 0019 EC A5                   		mov.L	[r10], r5
 120 001b ED A4 02                		mov.L	8[r10], r4
 121 001e 4B 45                   		add	r4, r5
 122 0020 CC 53                   		mov.B	[r5], r3
 123                             		.loc 1 335 31 discriminator 3
 124 0022 EC A5                   		mov.L	[r10], r5
 125 0024 ED A4 03                		mov.L	12[r10], r4
 126 0027 4B 45                   		add	r4, r5
 127 0029 CC 55                   		mov.B	[r5], r5
 128                             		.loc 1 335 28 discriminator 3
 129 002b FC 37 35                		xor	r3, r5
 130 002e 5B 55                   		movu.B	r5, r5
 131                             		.loc 1 335 20 discriminator 3
 132 0030 ED A4 01                		mov.L	4[r10], r4
 133 0033 57 45                   		or	r4, r5
 134 0035 E7 A5 01                		mov.L	r5, 4[r10]
 334:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         compareSum |= a[i] ^ b[i];
 135                             		.loc 1 334 30 discriminator 3
 136 0038 EC A5                   		mov.L	[r10], r5
 137 003a 62 15                   		add	#1, r5
 138 003c E3 A5                   		mov.L	r5, [r10]
 139                             	.L9:
 334:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         compareSum |= a[i] ^ b[i];
 140                             		.loc 1 334 5 discriminator 1
 141 003e EC A4                   		mov.L	[r10], r4
 142 0040 ED A5 04                		mov.L	16[r10], r5
 143 0043 47 54                   		cmp	r5, r4
 144 0045 29 D4                   		blt	.L10
 336:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 337:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 338:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return compareSum;
 145                             		.loc 1 338 12
 146 0047 ED A5 01                		mov.L	4[r10], r5
 339:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 147                             		.loc 1 339 1
 148 004a EF 51                   		mov.L	r5, r1
 149 004c 3F AA 06                		rtsd	#24, r10-r10
 150                             	.LFE14:
 152                             		.section	.text.min,"ax",@progbits
 154                             	_min:
 155                             	.LFB15:
 340:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 341:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 342:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 343:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_HAVE_MIN
 344:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WOLFSSL_HAVE_MIN
 345:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
 346:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #define min min
 347:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 348:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* returns the smaller of a and b */
 349:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 min(word32 a, word32 b)
 350:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 156                             		.loc 1 350 5
 157 0000 7E AA                   		push.l	r10
 158                             	.LCFI8:
 159 0002 71 0A F8                		add	#-8, r0, r10
 160                             	.LCFI9:
 161 0005 EF A0                   		mov.L	r10, r0
 162 0007 E3 A1                   		mov.L	r1, [r10]
 163 0009 E7 A2 01                		mov.L	r2, 4[r10]
 351:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return a > b ? b : a;
 164                             		.loc 1 351 26
 165 000c ED A5 01                		mov.L	4[r10], r5
 166 000f EC A3                   		mov.L	[r10], r3
 167 0011 EC A4                   		mov.L	[r10], r4
 168 0013 47 53                   		cmp	r5, r3
 169 0015 24 04                   		bgtu 1f
 170 0017 EF 45                   		mov r4, r5
 171                             	1:
 352:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 172                             		.loc 1 352 5
 173 0019 EF 51                   		mov.L	r5, r1
 174 001b 3F AA 03                		rtsd	#12, r10-r10
 175                             	.LFE15:
 177                             		.section	.text.Hash_df,"ax",@progbits
 179                             	_Hash_df:
 180                             	.LFB43:
 181                             		.file 2 "../src/wolfcrypt/src/random.c"
   1:../src/wolfcrypt/src/random.c **** /* random.c
   2:../src/wolfcrypt/src/random.c ****  *
   3:../src/wolfcrypt/src/random.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:../src/wolfcrypt/src/random.c ****  *
   5:../src/wolfcrypt/src/random.c ****  * This file is part of wolfSSL.
   6:../src/wolfcrypt/src/random.c ****  *
   7:../src/wolfcrypt/src/random.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:../src/wolfcrypt/src/random.c ****  * it under the terms of the GNU General Public License as published by
   9:../src/wolfcrypt/src/random.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:../src/wolfcrypt/src/random.c ****  * (at your option) any later version.
  11:../src/wolfcrypt/src/random.c ****  *
  12:../src/wolfcrypt/src/random.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:../src/wolfcrypt/src/random.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../src/wolfcrypt/src/random.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../src/wolfcrypt/src/random.c ****  * GNU General Public License for more details.
  16:../src/wolfcrypt/src/random.c ****  *
  17:../src/wolfcrypt/src/random.c ****  * You should have received a copy of the GNU General Public License
  18:../src/wolfcrypt/src/random.c ****  * along with this program; if not, write to the Free Software
  19:../src/wolfcrypt/src/random.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:../src/wolfcrypt/src/random.c ****  */
  21:../src/wolfcrypt/src/random.c **** 
  22:../src/wolfcrypt/src/random.c **** /*
  23:../src/wolfcrypt/src/random.c **** 
  24:../src/wolfcrypt/src/random.c **** DESCRIPTION
  25:../src/wolfcrypt/src/random.c **** This library contains implementation for the random number generator.
  26:../src/wolfcrypt/src/random.c **** 
  27:../src/wolfcrypt/src/random.c **** */
  28:../src/wolfcrypt/src/random.c **** #ifdef HAVE_CONFIG_H
  29:../src/wolfcrypt/src/random.c ****     #include <config.h>
  30:../src/wolfcrypt/src/random.c **** #endif
  31:../src/wolfcrypt/src/random.c **** 
  32:../src/wolfcrypt/src/random.c **** #include <wolfssl/wolfcrypt/settings.h>
  33:../src/wolfcrypt/src/random.c **** #include <wolfssl/wolfcrypt/error-crypt.h>
  34:../src/wolfcrypt/src/random.c **** 
  35:../src/wolfcrypt/src/random.c **** /* on HPUX 11 you may need to install /dev/random see
  36:../src/wolfcrypt/src/random.c ****    http://h20293.www2.hp.com/portal/swdepot/displayProductInfo.do?productNumber=KRNG11I
  37:../src/wolfcrypt/src/random.c **** 
  38:../src/wolfcrypt/src/random.c **** */
  39:../src/wolfcrypt/src/random.c **** 
  40:../src/wolfcrypt/src/random.c **** #if defined(HAVE_FIPS) && \
  41:../src/wolfcrypt/src/random.c ****     defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)
  42:../src/wolfcrypt/src/random.c **** 
  43:../src/wolfcrypt/src/random.c ****     /* set NO_WRAPPERS before headers, use direct internal f()s not wrappers */
  44:../src/wolfcrypt/src/random.c ****     #define FIPS_NO_WRAPPERS
  45:../src/wolfcrypt/src/random.c **** 
  46:../src/wolfcrypt/src/random.c ****     #ifdef USE_WINDOWS_API
  47:../src/wolfcrypt/src/random.c ****         #pragma code_seg(".fipsA$c")
  48:../src/wolfcrypt/src/random.c ****         #pragma const_seg(".fipsB$c")
  49:../src/wolfcrypt/src/random.c ****     #endif
  50:../src/wolfcrypt/src/random.c **** #endif
  51:../src/wolfcrypt/src/random.c **** 
  52:../src/wolfcrypt/src/random.c **** 
  53:../src/wolfcrypt/src/random.c **** #include <wolfssl/wolfcrypt/random.h>
  54:../src/wolfcrypt/src/random.c **** #include <wolfssl/wolfcrypt/cpuid.h>
  55:../src/wolfcrypt/src/random.c **** 
  56:../src/wolfcrypt/src/random.c **** 
  57:../src/wolfcrypt/src/random.c **** /* If building for old FIPS. */
  58:../src/wolfcrypt/src/random.c **** #if defined(HAVE_FIPS) && \
  59:../src/wolfcrypt/src/random.c ****     (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION < 2))
  60:../src/wolfcrypt/src/random.c **** 
  61:../src/wolfcrypt/src/random.c **** int wc_GenerateSeed(OS_Seed* os, byte* seed, word32 sz)
  62:../src/wolfcrypt/src/random.c **** {
  63:../src/wolfcrypt/src/random.c ****     return GenerateSeed(os, seed, sz);
  64:../src/wolfcrypt/src/random.c **** }
  65:../src/wolfcrypt/src/random.c **** 
  66:../src/wolfcrypt/src/random.c **** int wc_InitRng_ex(WC_RNG* rng, void* heap, int devId)
  67:../src/wolfcrypt/src/random.c **** {
  68:../src/wolfcrypt/src/random.c ****     (void)heap;
  69:../src/wolfcrypt/src/random.c ****     (void)devId;
  70:../src/wolfcrypt/src/random.c ****     return InitRng_fips(rng);
  71:../src/wolfcrypt/src/random.c **** }
  72:../src/wolfcrypt/src/random.c **** 
  73:../src/wolfcrypt/src/random.c **** int wc_InitRng(WC_RNG* rng)
  74:../src/wolfcrypt/src/random.c **** {
  75:../src/wolfcrypt/src/random.c ****     return InitRng_fips(rng);
  76:../src/wolfcrypt/src/random.c **** }
  77:../src/wolfcrypt/src/random.c **** 
  78:../src/wolfcrypt/src/random.c **** 
  79:../src/wolfcrypt/src/random.c **** int wc_RNG_GenerateBlock(WC_RNG* rng, byte* b, word32 sz)
  80:../src/wolfcrypt/src/random.c **** {
  81:../src/wolfcrypt/src/random.c ****     return RNG_GenerateBlock_fips(rng, b, sz);
  82:../src/wolfcrypt/src/random.c **** }
  83:../src/wolfcrypt/src/random.c **** 
  84:../src/wolfcrypt/src/random.c **** 
  85:../src/wolfcrypt/src/random.c **** int wc_RNG_GenerateByte(WC_RNG* rng, byte* b)
  86:../src/wolfcrypt/src/random.c **** {
  87:../src/wolfcrypt/src/random.c ****     return RNG_GenerateByte(rng, b);
  88:../src/wolfcrypt/src/random.c **** }
  89:../src/wolfcrypt/src/random.c **** 
  90:../src/wolfcrypt/src/random.c **** #ifdef HAVE_HASHDRBG
  91:../src/wolfcrypt/src/random.c **** 
  92:../src/wolfcrypt/src/random.c ****     int wc_FreeRng(WC_RNG* rng)
  93:../src/wolfcrypt/src/random.c ****     {
  94:../src/wolfcrypt/src/random.c ****         return FreeRng_fips(rng);
  95:../src/wolfcrypt/src/random.c ****     }
  96:../src/wolfcrypt/src/random.c **** 
  97:../src/wolfcrypt/src/random.c ****     int wc_RNG_HealthTest(int reseed, const byte* seedA, word32 seedASz,
  98:../src/wolfcrypt/src/random.c ****                                       const byte* seedB, word32 seedBSz,
  99:../src/wolfcrypt/src/random.c ****                                       byte* output, word32 outputSz)
 100:../src/wolfcrypt/src/random.c ****     {
 101:../src/wolfcrypt/src/random.c ****         return RNG_HealthTest_fips(reseed, seedA, seedASz,
 102:../src/wolfcrypt/src/random.c ****                               seedB, seedBSz, output, outputSz);
 103:../src/wolfcrypt/src/random.c ****    }
 104:../src/wolfcrypt/src/random.c **** #endif /* HAVE_HASHDRBG */
 105:../src/wolfcrypt/src/random.c **** 
 106:../src/wolfcrypt/src/random.c **** #else /* else build without fips, or for new fips */
 107:../src/wolfcrypt/src/random.c **** 
 108:../src/wolfcrypt/src/random.c **** #ifndef WC_NO_RNG /* if not FIPS and RNG is disabled then do not compile */
 109:../src/wolfcrypt/src/random.c **** 
 110:../src/wolfcrypt/src/random.c **** #include <wolfssl/wolfcrypt/sha256.h>
 111:../src/wolfcrypt/src/random.c **** 
 112:../src/wolfcrypt/src/random.c **** #ifdef WOLF_CRYPTO_CB
 113:../src/wolfcrypt/src/random.c ****     #include <wolfssl/wolfcrypt/cryptocb.h>
 114:../src/wolfcrypt/src/random.c **** #endif
 115:../src/wolfcrypt/src/random.c **** 
 116:../src/wolfcrypt/src/random.c **** #ifdef NO_INLINE
 117:../src/wolfcrypt/src/random.c ****     #include <wolfssl/wolfcrypt/misc.h>
 118:../src/wolfcrypt/src/random.c **** #else
 119:../src/wolfcrypt/src/random.c ****     #define WOLFSSL_MISC_INCLUDED
 120:../src/wolfcrypt/src/random.c ****     #include <wolfcrypt/src/misc.c>
 121:../src/wolfcrypt/src/random.c **** #endif
 122:../src/wolfcrypt/src/random.c **** 
 123:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_SGX)
 124:../src/wolfcrypt/src/random.c ****     #include <sgx_trts.h>
 125:../src/wolfcrypt/src/random.c **** #elif defined(USE_WINDOWS_API)
 126:../src/wolfcrypt/src/random.c ****     #ifndef _WIN32_WINNT
 127:../src/wolfcrypt/src/random.c ****         #define _WIN32_WINNT 0x0400
 128:../src/wolfcrypt/src/random.c ****     #endif
 129:../src/wolfcrypt/src/random.c ****     #include <windows.h>
 130:../src/wolfcrypt/src/random.c ****     #include <wincrypt.h>
 131:../src/wolfcrypt/src/random.c **** #elif defined(HAVE_WNR)
 132:../src/wolfcrypt/src/random.c ****     #include <wnr.h>
 133:../src/wolfcrypt/src/random.c ****     #include <wolfssl/wolfcrypt/logging.h>
 134:../src/wolfcrypt/src/random.c ****     wolfSSL_Mutex wnr_mutex;    /* global netRandom mutex */
 135:../src/wolfcrypt/src/random.c ****     int wnr_timeout     = 0;    /* entropy timeout, milliseconds */
 136:../src/wolfcrypt/src/random.c ****     int wnr_mutex_init  = 0;    /* flag for mutex init */
 137:../src/wolfcrypt/src/random.c ****     wnr_context*  wnr_ctx;      /* global netRandom context */
 138:../src/wolfcrypt/src/random.c **** #elif defined(FREESCALE_KSDK_2_0_TRNG)
 139:../src/wolfcrypt/src/random.c ****     #include "fsl_trng.h"
 140:../src/wolfcrypt/src/random.c **** #elif defined(FREESCALE_KSDK_2_0_RNGA)
 141:../src/wolfcrypt/src/random.c ****     #include "fsl_rnga.h"
 142:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_WICED)
 143:../src/wolfcrypt/src/random.c ****     #include "wiced_crypto.h"
 144:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_NETBURNER)
 145:../src/wolfcrypt/src/random.c ****     #include <predef.h>
 146:../src/wolfcrypt/src/random.c ****     #include <basictypes.h>
 147:../src/wolfcrypt/src/random.c ****     #include <random.h>
 148:../src/wolfcrypt/src/random.c **** #elif defined(NO_DEV_RANDOM)
 149:../src/wolfcrypt/src/random.c **** #elif defined(CUSTOM_RAND_GENERATE)
 150:../src/wolfcrypt/src/random.c **** #elif defined(CUSTOM_RAND_GENERATE_BLOCK)
 151:../src/wolfcrypt/src/random.c **** #elif defined(CUSTOM_RAND_GENERATE_SEED)
 152:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_GENSEED_FORTEST)
 153:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_MDK_ARM)
 154:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_IAR_ARM)
 155:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_ROWLEY_ARM)
 156:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_EMBOS)
 157:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_DEOS)
 158:../src/wolfcrypt/src/random.c **** #elif defined(MICRIUM)
 159:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_NUCLEUS)
 160:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_PB)
 161:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_ZEPHYR)
 162:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_TELIT_M2MB)
 163:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_SCE) && !defined(WOLFSSL_SCE_NO_TRNG)
 164:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_GETRANDOM)
 165:../src/wolfcrypt/src/random.c ****     #include <errno.h>
 166:../src/wolfcrypt/src/random.c ****     #include <sys/random.h>
 167:../src/wolfcrypt/src/random.c **** #else
 168:../src/wolfcrypt/src/random.c ****     /* include headers that may be needed to get good seed */
 169:../src/wolfcrypt/src/random.c ****     #include <fcntl.h>
 170:../src/wolfcrypt/src/random.c ****     #ifndef EBSNET
 171:../src/wolfcrypt/src/random.c ****         #include <unistd.h>
 172:../src/wolfcrypt/src/random.c ****     #endif
 173:../src/wolfcrypt/src/random.c **** #endif
 174:../src/wolfcrypt/src/random.c **** 
 175:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_SILABS_SE_ACCEL)
 176:../src/wolfcrypt/src/random.c **** #include <wolfssl/wolfcrypt/port/silabs/silabs_random.h>
 177:../src/wolfcrypt/src/random.c **** #endif
 178:../src/wolfcrypt/src/random.c **** 
 179:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_IOTSAFE) && defined(HAVE_IOTSAFE_HWRNG)
 180:../src/wolfcrypt/src/random.c **** #include <wolfssl/wolfcrypt/port/iotsafe/iotsafe.h>
 181:../src/wolfcrypt/src/random.c **** #endif
 182:../src/wolfcrypt/src/random.c **** 
 183:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_HAVE_PSA) && !defined(WOLFSSL_PSA_NO_RNG)
 184:../src/wolfcrypt/src/random.c **** #include <wolfssl/wolfcrypt/port/psa/psa.h>
 185:../src/wolfcrypt/src/random.c **** #endif
 186:../src/wolfcrypt/src/random.c **** 
 187:../src/wolfcrypt/src/random.c **** #if defined(HAVE_INTEL_RDRAND) || defined(HAVE_INTEL_RDSEED) || \
 188:../src/wolfcrypt/src/random.c ****     defined(HAVE_AMD_RDSEED)
 189:../src/wolfcrypt/src/random.c ****     static word32 intel_flags = 0;
 190:../src/wolfcrypt/src/random.c ****     static void wc_InitRng_IntelRD(void)
 191:../src/wolfcrypt/src/random.c ****     {
 192:../src/wolfcrypt/src/random.c ****         intel_flags = cpuid_get_flags();
 193:../src/wolfcrypt/src/random.c ****     }
 194:../src/wolfcrypt/src/random.c ****     #if (defined(HAVE_INTEL_RDSEED) || defined(HAVE_AMD_RDSEED)) && \
 195:../src/wolfcrypt/src/random.c ****         !defined(WOLFSSL_LINUXKM)
 196:../src/wolfcrypt/src/random.c ****     static int wc_GenerateSeed_IntelRD(OS_Seed* os, byte* output, word32 sz);
 197:../src/wolfcrypt/src/random.c ****     #endif
 198:../src/wolfcrypt/src/random.c ****     #ifdef HAVE_INTEL_RDRAND
 199:../src/wolfcrypt/src/random.c ****     static int wc_GenerateRand_IntelRD(OS_Seed* os, byte* output, word32 sz);
 200:../src/wolfcrypt/src/random.c ****     #endif
 201:../src/wolfcrypt/src/random.c **** 
 202:../src/wolfcrypt/src/random.c **** #ifdef USE_WINDOWS_API
 203:../src/wolfcrypt/src/random.c ****     #define USE_INTEL_INTRINSICS
 204:../src/wolfcrypt/src/random.c **** #elif !defined __GNUC__ || defined __clang__ || __GNUC__ > 4
 205:../src/wolfcrypt/src/random.c ****     #define USE_INTEL_INTRINSICS
 206:../src/wolfcrypt/src/random.c **** #else
 207:../src/wolfcrypt/src/random.c ****     #undef USE_INTEL_INTRINSICS
 208:../src/wolfcrypt/src/random.c **** #endif
 209:../src/wolfcrypt/src/random.c **** 
 210:../src/wolfcrypt/src/random.c **** #ifdef USE_INTEL_INTRINSICS
 211:../src/wolfcrypt/src/random.c ****     #include <immintrin.h>
 212:../src/wolfcrypt/src/random.c ****     /* Before clang 7 or GCC 9, immintrin.h did not define _rdseed64_step() */
 213:../src/wolfcrypt/src/random.c ****     #ifndef HAVE_INTEL_RDSEED
 214:../src/wolfcrypt/src/random.c ****     #elif defined __clang__ && __clang_major__ > 6
 215:../src/wolfcrypt/src/random.c ****     #elif !defined __GNUC__
 216:../src/wolfcrypt/src/random.c ****     #elif __GNUC__ > 8
 217:../src/wolfcrypt/src/random.c ****     #else
 218:../src/wolfcrypt/src/random.c ****         #ifndef __clang__
 219:../src/wolfcrypt/src/random.c ****             #pragma GCC push_options
 220:../src/wolfcrypt/src/random.c ****             #pragma GCC target("rdseed")
 221:../src/wolfcrypt/src/random.c ****         #else
 222:../src/wolfcrypt/src/random.c ****             #define __RDSEED__
 223:../src/wolfcrypt/src/random.c ****         #endif
 224:../src/wolfcrypt/src/random.c ****         #include <x86intrin.h>
 225:../src/wolfcrypt/src/random.c ****         #ifndef __clang__
 226:../src/wolfcrypt/src/random.c ****             #pragma GCC pop_options
 227:../src/wolfcrypt/src/random.c ****         #endif
 228:../src/wolfcrypt/src/random.c ****     #endif
 229:../src/wolfcrypt/src/random.c **** #endif /* USE_WINDOWS_API */
 230:../src/wolfcrypt/src/random.c **** #endif
 231:../src/wolfcrypt/src/random.c **** 
 232:../src/wolfcrypt/src/random.c **** /* Start NIST DRBG code */
 233:../src/wolfcrypt/src/random.c **** #ifdef HAVE_HASHDRBG
 234:../src/wolfcrypt/src/random.c **** 
 235:../src/wolfcrypt/src/random.c **** #define OUTPUT_BLOCK_LEN  (WC_SHA256_DIGEST_SIZE)
 236:../src/wolfcrypt/src/random.c **** #define MAX_REQUEST_LEN   (0x10000)
 237:../src/wolfcrypt/src/random.c **** #define RESEED_INTERVAL   WC_RESEED_INTERVAL
 238:../src/wolfcrypt/src/random.c **** 
 239:../src/wolfcrypt/src/random.c **** 
 240:../src/wolfcrypt/src/random.c **** /* The security strength for the RNG is the target number of bits of
 241:../src/wolfcrypt/src/random.c ****  * entropy you are looking for in a seed. */
 242:../src/wolfcrypt/src/random.c **** #ifndef RNG_SECURITY_STRENGTH
 243:../src/wolfcrypt/src/random.c ****     /* SHA-256 requires a minimum of 256-bits of entropy. */
 244:../src/wolfcrypt/src/random.c ****     #define RNG_SECURITY_STRENGTH (256)
 245:../src/wolfcrypt/src/random.c **** #endif
 246:../src/wolfcrypt/src/random.c **** 
 247:../src/wolfcrypt/src/random.c **** #ifndef ENTROPY_SCALE_FACTOR
 248:../src/wolfcrypt/src/random.c ****     /* The entropy scale factor should be the whole number inverse of the
 249:../src/wolfcrypt/src/random.c ****      * minimum bits of entropy per bit of NDRNG output. */
 250:../src/wolfcrypt/src/random.c ****     #if defined(HAVE_AMD_RDSEED)
 251:../src/wolfcrypt/src/random.c ****         /* This will yield a SEED_SZ of 16kb. Since nonceSz will be 0,
 252:../src/wolfcrypt/src/random.c ****          * we'll add an additional 8kb on top. */
 253:../src/wolfcrypt/src/random.c ****         #define ENTROPY_SCALE_FACTOR  (512)
 254:../src/wolfcrypt/src/random.c ****     #elif defined(HAVE_INTEL_RDSEED) || defined(HAVE_INTEL_RDRAND)
 255:../src/wolfcrypt/src/random.c ****         /* The value of 2 applies to Intel's RDSEED which provides about
 256:../src/wolfcrypt/src/random.c ****          * 0.5 bits minimum of entropy per bit. The value of 4 gives a
 257:../src/wolfcrypt/src/random.c ****          * conservative margin for FIPS. */
 258:../src/wolfcrypt/src/random.c ****         #if defined(HAVE_FIPS) && defined(HAVE_FIPS_VERSION) && \
 259:../src/wolfcrypt/src/random.c ****             (HAVE_FIPS_VERSION >= 2)
 260:../src/wolfcrypt/src/random.c ****             #define ENTROPY_SCALE_FACTOR (2*4)
 261:../src/wolfcrypt/src/random.c ****         #else
 262:../src/wolfcrypt/src/random.c ****             /* Not FIPS, but Intel RDSEED, only double. */
 263:../src/wolfcrypt/src/random.c ****             #define ENTROPY_SCALE_FACTOR (2)
 264:../src/wolfcrypt/src/random.c ****         #endif
 265:../src/wolfcrypt/src/random.c ****     #elif defined(HAVE_FIPS) && defined(HAVE_FIPS_VERSION) && \
 266:../src/wolfcrypt/src/random.c ****         (HAVE_FIPS_VERSION >= 2)
 267:../src/wolfcrypt/src/random.c ****         /* If doing a FIPS build without a specific scale factor, default
 268:../src/wolfcrypt/src/random.c ****          * to 4. This will give 1024 bits of entropy. More is better, but
 269:../src/wolfcrypt/src/random.c ****          * more is also slower. */
 270:../src/wolfcrypt/src/random.c ****         #define ENTROPY_SCALE_FACTOR (4)
 271:../src/wolfcrypt/src/random.c ****     #else
 272:../src/wolfcrypt/src/random.c ****         /* Setting the default to 1. */
 273:../src/wolfcrypt/src/random.c ****         #define ENTROPY_SCALE_FACTOR (1)
 274:../src/wolfcrypt/src/random.c ****     #endif
 275:../src/wolfcrypt/src/random.c **** #endif
 276:../src/wolfcrypt/src/random.c **** 
 277:../src/wolfcrypt/src/random.c **** #ifndef SEED_BLOCK_SZ
 278:../src/wolfcrypt/src/random.c ****     /* The seed block size, is the size of the output of the underlying NDRNG.
 279:../src/wolfcrypt/src/random.c ****      * This value is used for testing the output of the NDRNG. */
 280:../src/wolfcrypt/src/random.c ****     #if defined(HAVE_AMD_RDSEED)
 281:../src/wolfcrypt/src/random.c ****         /* AMD's RDSEED instruction works in 128-bit blocks read 64-bits
 282:../src/wolfcrypt/src/random.c ****         * at a time. */
 283:../src/wolfcrypt/src/random.c ****         #define SEED_BLOCK_SZ (sizeof(word64)*2)
 284:../src/wolfcrypt/src/random.c ****     #elif defined(HAVE_INTEL_RDSEED) || defined(HAVE_INTEL_RDRAND)
 285:../src/wolfcrypt/src/random.c ****         /* RDSEED outputs in blocks of 64-bits. */
 286:../src/wolfcrypt/src/random.c ****         #define SEED_BLOCK_SZ sizeof(word64)
 287:../src/wolfcrypt/src/random.c ****     #else
 288:../src/wolfcrypt/src/random.c ****         /* Setting the default to 4. */
 289:../src/wolfcrypt/src/random.c ****         #define SEED_BLOCK_SZ 4
 290:../src/wolfcrypt/src/random.c ****     #endif
 291:../src/wolfcrypt/src/random.c **** #endif
 292:../src/wolfcrypt/src/random.c **** 
 293:../src/wolfcrypt/src/random.c **** #define SEED_SZ        (RNG_SECURITY_STRENGTH*ENTROPY_SCALE_FACTOR/8)
 294:../src/wolfcrypt/src/random.c **** 
 295:../src/wolfcrypt/src/random.c **** /* The maximum seed size will be the seed size plus a seed block for the
 296:../src/wolfcrypt/src/random.c ****  * test, and an additional half of the seed size. This additional half
 297:../src/wolfcrypt/src/random.c ****  * is in case the user does not supply a nonce. A nonce will be obtained
 298:../src/wolfcrypt/src/random.c ****  * from the NDRNG. */
 299:../src/wolfcrypt/src/random.c **** #define MAX_SEED_SZ    (SEED_SZ + SEED_SZ/2 + SEED_BLOCK_SZ)
 300:../src/wolfcrypt/src/random.c **** 
 301:../src/wolfcrypt/src/random.c **** 
 302:../src/wolfcrypt/src/random.c **** #ifdef WC_RNG_SEED_CB
 303:../src/wolfcrypt/src/random.c **** 
 304:../src/wolfcrypt/src/random.c **** static wc_RngSeed_Cb seedCb = NULL;
 305:../src/wolfcrypt/src/random.c **** 
 306:../src/wolfcrypt/src/random.c **** int wc_SetSeed_Cb(wc_RngSeed_Cb cb)
 307:../src/wolfcrypt/src/random.c **** {
 308:../src/wolfcrypt/src/random.c ****     seedCb = cb;
 309:../src/wolfcrypt/src/random.c ****     return 0;
 310:../src/wolfcrypt/src/random.c **** }
 311:../src/wolfcrypt/src/random.c **** 
 312:../src/wolfcrypt/src/random.c **** #endif
 313:../src/wolfcrypt/src/random.c **** 
 314:../src/wolfcrypt/src/random.c **** 
 315:../src/wolfcrypt/src/random.c **** /* Internal return codes */
 316:../src/wolfcrypt/src/random.c **** #define DRBG_SUCCESS      0
 317:../src/wolfcrypt/src/random.c **** #define DRBG_FAILURE      1
 318:../src/wolfcrypt/src/random.c **** #define DRBG_NEED_RESEED  2
 319:../src/wolfcrypt/src/random.c **** #define DRBG_CONT_FAILURE 3
 320:../src/wolfcrypt/src/random.c **** #define DRBG_NO_SEED_CB   4
 321:../src/wolfcrypt/src/random.c **** 
 322:../src/wolfcrypt/src/random.c **** /* RNG health states */
 323:../src/wolfcrypt/src/random.c **** #define DRBG_NOT_INIT     0
 324:../src/wolfcrypt/src/random.c **** #define DRBG_OK           1
 325:../src/wolfcrypt/src/random.c **** #define DRBG_FAILED       2
 326:../src/wolfcrypt/src/random.c **** #define DRBG_CONT_FAILED  3
 327:../src/wolfcrypt/src/random.c **** 
 328:../src/wolfcrypt/src/random.c **** #define RNG_HEALTH_TEST_CHECK_SIZE (WC_SHA256_DIGEST_SIZE * 4)
 329:../src/wolfcrypt/src/random.c **** 
 330:../src/wolfcrypt/src/random.c **** /* Verify max gen block len */
 331:../src/wolfcrypt/src/random.c **** #if RNG_MAX_BLOCK_LEN > MAX_REQUEST_LEN
 332:../src/wolfcrypt/src/random.c ****     #error RNG_MAX_BLOCK_LEN is larger than NIST DBRG max request length
 333:../src/wolfcrypt/src/random.c **** #endif
 334:../src/wolfcrypt/src/random.c **** 
 335:../src/wolfcrypt/src/random.c **** enum {
 336:../src/wolfcrypt/src/random.c ****     drbgInitC     = 0,
 337:../src/wolfcrypt/src/random.c ****     drbgReseed    = 1,
 338:../src/wolfcrypt/src/random.c ****     drbgGenerateW = 2,
 339:../src/wolfcrypt/src/random.c ****     drbgGenerateH = 3,
 340:../src/wolfcrypt/src/random.c ****     drbgInitV     = 4
 341:../src/wolfcrypt/src/random.c **** };
 342:../src/wolfcrypt/src/random.c **** 
 343:../src/wolfcrypt/src/random.c **** typedef struct DRBG_internal DRBG_internal;
 344:../src/wolfcrypt/src/random.c **** 
 345:../src/wolfcrypt/src/random.c **** static int wc_RNG_HealthTestLocal(int reseed);
 346:../src/wolfcrypt/src/random.c **** 
 347:../src/wolfcrypt/src/random.c **** /* Hash Derivation Function */
 348:../src/wolfcrypt/src/random.c **** /* Returns: DRBG_SUCCESS or DRBG_FAILURE */
 349:../src/wolfcrypt/src/random.c **** static int Hash_df(DRBG_internal* drbg, byte* out, word32 outSz, byte type,
 350:../src/wolfcrypt/src/random.c ****                                                   const byte* inA, word32 inASz,
 351:../src/wolfcrypt/src/random.c ****                                                   const byte* inB, word32 inBSz)
 352:../src/wolfcrypt/src/random.c **** {
 182                             		.loc 2 352 1
 183 0000 7E AA                   		push.l	r10
 184                             	.LCFI10:
 185 0002 7E A6                   		push.l	r6
 186                             	.LCFI11:
 187 0004 72 0A 3C FF             		add	#-196, r0, r10
 188                             	.LCFI12:
 189 0008 EF A0                   		mov.L	r10, r0
 190 000a 75 46 D0                		mov.L	#0xd0, r6
 191 000d 4B A6                   		add	r10, r6
 192 000f E7 A1 29                		mov.L	r1, 164[r10]
 193 0012 E7 A2 2A                		mov.L	r2, 168[r10]
 194 0015 E7 A3 2B                		mov.L	r3, 172[r10]
 195 0018 C7 A4 B0                		mov.B	r4, 176[r10]
 353:../src/wolfcrypt/src/random.c ****     int ret = DRBG_FAILURE;
 196                             		.loc 2 353 9
 197 001b F8 A6 01                		mov.L	#1, [r10]
 354:../src/wolfcrypt/src/random.c ****     byte ctr;
 355:../src/wolfcrypt/src/random.c ****     int i;
 356:../src/wolfcrypt/src/random.c ****     int len;
 357:../src/wolfcrypt/src/random.c ****     word32 bits = (outSz * 8); /* reverse byte order */
 198                             		.loc 2 357 26
 199 001e ED A5 2B                		mov.L	172[r10], r5
 200 0021 6C 35                   		shll	#3, r5
 201                             		.loc 2 357 12
 202 0023 E7 A5 04                		mov.L	r5, 16[r10]
 358:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
 359:../src/wolfcrypt/src/random.c ****     wc_Sha256* sha = &drbg->sha256;
 360:../src/wolfcrypt/src/random.c **** #else
 361:../src/wolfcrypt/src/random.c ****     wc_Sha256 sha[1];
 362:../src/wolfcrypt/src/random.c **** #endif
 363:../src/wolfcrypt/src/random.c **** #ifdef WC_ASYNC_ENABLE_SHA256
 364:../src/wolfcrypt/src/random.c ****     WC_DECLARE_VAR(digest, byte, WC_SHA256_DIGEST_SIZE, drbg->heap);
 365:../src/wolfcrypt/src/random.c ****     if (digest == NULL)
 366:../src/wolfcrypt/src/random.c ****         return MEMORY_E;
 367:../src/wolfcrypt/src/random.c **** #else
 368:../src/wolfcrypt/src/random.c ****     byte digest[WC_SHA256_DIGEST_SIZE];
 369:../src/wolfcrypt/src/random.c **** #endif
 370:../src/wolfcrypt/src/random.c **** 
 371:../src/wolfcrypt/src/random.c ****     (void)drbg;
 372:../src/wolfcrypt/src/random.c **** #ifdef WC_ASYNC_ENABLE_SHA256
 373:../src/wolfcrypt/src/random.c ****     if (digest == NULL)
 374:../src/wolfcrypt/src/random.c ****         return DRBG_FAILURE;
 375:../src/wolfcrypt/src/random.c **** #endif
 376:../src/wolfcrypt/src/random.c **** 
 377:../src/wolfcrypt/src/random.c **** #ifdef LITTLE_ENDIAN_ORDER
 378:../src/wolfcrypt/src/random.c ****     bits = ByteReverseWord32(bits);
 203                             		.loc 2 378 12
 204 0026 ED A5 04                		mov.L	16[r10], r5
 205 0029 EF 51                   		mov.L	r5, r1
 206 002b 05 00 00 00             		bsr	_ByteReverseWord32
 207 002f EF 15                   		mov.L	r1, r5
 208                             		.loc 2 378 10
 209 0031 E7 A5 04                		mov.L	r5, 16[r10]
 379:../src/wolfcrypt/src/random.c **** #endif
 380:../src/wolfcrypt/src/random.c ****     len = (outSz / OUTPUT_BLOCK_LEN)
 210                             		.loc 2 380 18
 211 0034 ED A5 2B                		mov.L	172[r10], r5
 212 0037 FD 85 54                		shlr	#5, r5, r4
 381:../src/wolfcrypt/src/random.c ****         + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 213                             		.loc 2 381 19
 214 003a ED A5 2B                		mov.L	172[r10], r5
 215 003d 75 25 1F                		and	#31, r5
 216                             		.loc 2 381 43
 217 0040 61 05                   		cmp	#0, r5
 218 0042 14                      		beq	.L15
 219                             		.loc 2 381 43 is_stmt 0 discriminator 1
 220 0043 66 15                   		mov.L	#1, r5
 221 0045 0B                      		bra	.L16
 222                             	.L15:
 223                             		.loc 2 381 43 discriminator 2
 224 0046 66 05                   		mov.L	#0, r5
 225                             	.L16:
 226                             		.loc 2 381 9 is_stmt 1 discriminator 4
 227 0048 4B 45                   		add	r4, r5
 380:../src/wolfcrypt/src/random.c ****         + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 228                             		.loc 2 380 9 discriminator 4
 229 004a E7 A5 02                		mov.L	r5, 8[r10]
 382:../src/wolfcrypt/src/random.c **** 
 383:../src/wolfcrypt/src/random.c ****     ctr = 1;
 230                             		.loc 2 383 9 discriminator 4
 231 004d F9 A4 0C 01             		mov.B	#1, 12[r10]
 384:../src/wolfcrypt/src/random.c ****     for (i = 0; i < len; i++) {
 232                             		.loc 2 384 12 discriminator 4
 233 0051 F9 A6 01 00             		mov.L	#0, 4[r10]
 234                             		.loc 2 384 5 discriminator 4
 235 0055 38 0B 01                		bra	.L17
 236                             	.L27:
 385:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 386:../src/wolfcrypt/src/random.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
 387:../src/wolfcrypt/src/random.c ****         ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
 388:../src/wolfcrypt/src/random.c ****     #else
 389:../src/wolfcrypt/src/random.c ****         ret = wc_InitSha256(sha);
 237                             		.loc 2 389 15
 238 0058 71 A5 14                		add	#20, r10, r5
 239 005b EF 51                   		mov.L	r5, r1
 240 005d 05 00 00 00             		bsr	_wc_InitSha256
 241 0061 E3 A1                   		mov.L	r1, [r10]
 390:../src/wolfcrypt/src/random.c ****     #endif
 391:../src/wolfcrypt/src/random.c ****         if (ret != 0)
 242                             		.loc 2 391 12
 243 0063 EC A5                   		mov.L	[r10], r5
 244 0065 61 05                   		cmp	#0, r5
 245 0067 3B 08 01                		bne	.L29
 392:../src/wolfcrypt/src/random.c ****             break;
 393:../src/wolfcrypt/src/random.c **** #endif
 394:../src/wolfcrypt/src/random.c ****         ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
 246                             		.loc 2 394 15
 247 006a 71 A4 0C                		add	#12, r10, r4
 248 006d 71 A5 14                		add	#20, r10, r5
 249 0070 66 13                   		mov.L	#1, r3
 250 0072 EF 42                   		mov.L	r4, r2
 251 0074 EF 51                   		mov.L	r5, r1
 252 0076 05 00 00 00             		bsr	_wc_Sha256Update
 253 007a E3 A1                   		mov.L	r1, [r10]
 395:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
 254                             		.loc 2 395 12
 255 007c EC A5                   		mov.L	[r10], r5
 256 007e 61 05                   		cmp	#0, r5
 257 0080 21 1C                   		bne	.L20
 396:../src/wolfcrypt/src/random.c ****             ctr++;
 258                             		.loc 2 396 16
 259 0082 CD A5 0C                		mov.B	12[r10], r5
 260 0085 62 15                   		add	#1, r5
 261 0087 C7 A5 0C                		mov.B	r5, 12[r10]
 397:../src/wolfcrypt/src/random.c ****             ret = wc_Sha256Update(sha, (byte*)&bits, sizeof(bits));
 262                             		.loc 2 397 19
 263 008a 71 A4 10                		add	#16, r10, r4
 264 008d 71 A5 14                		add	#20, r10, r5
 265 0090 66 43                   		mov.L	#4, r3
 266 0092 EF 42                   		mov.L	r4, r2
 267 0094 EF 51                   		mov.L	r5, r1
 268 0096 05 00 00 00             		bsr	_wc_Sha256Update
 269 009a E3 A1                   		mov.L	r1, [r10]
 270                             	.L20:
 398:../src/wolfcrypt/src/random.c ****         }
 399:../src/wolfcrypt/src/random.c **** 
 400:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
 271                             		.loc 2 400 12
 272 009c EC A5                   		mov.L	[r10], r5
 273 009e 61 05                   		cmp	#0, r5
 274 00a0 21 1E                   		bne	.L21
 401:../src/wolfcrypt/src/random.c ****             /* churning V is the only string that doesn't have the type added */
 402:../src/wolfcrypt/src/random.c ****             if (type != drbgInitV)
 275                             		.loc 2 402 22
 276 00a2 CD A5 B0                		mov.B	176[r10], r5
 277                             		.loc 2 402 16
 278 00a5 5B 55                   		movu.B	r5, r5
 279 00a7 61 45                   		cmp	#4, r5
 280 00a9 20 15                   		beq	.L21
 403:../src/wolfcrypt/src/random.c ****                 ret = wc_Sha256Update(sha, &type, sizeof(type));
 281                             		.loc 2 403 23
 282 00ab 72 A4 B0 00             		add	#0xb0, r10, r4
 283 00af 71 A5 14                		add	#20, r10, r5
 284 00b2 66 13                   		mov.L	#1, r3
 285 00b4 EF 42                   		mov.L	r4, r2
 286 00b6 EF 51                   		mov.L	r5, r1
 287 00b8 05 00 00 00             		bsr	_wc_Sha256Update
 288 00bc E3 A1                   		mov.L	r1, [r10]
 289                             	.L21:
 404:../src/wolfcrypt/src/random.c ****         }
 405:../src/wolfcrypt/src/random.c ****         if (ret == 0)
 290                             		.loc 2 405 12
 291 00be EC A5                   		mov.L	[r10], r5
 292 00c0 61 05                   		cmp	#0, r5
 293 00c2 21 11                   		bne	.L22
 406:../src/wolfcrypt/src/random.c ****             ret = wc_Sha256Update(sha, inA, inASz);
 294                             		.loc 2 406 19
 295 00c4 71 A5 14                		add	#20, r10, r5
 296 00c7 A8 6B                   		mov.L	4[r6], r3
 297 00c9 EC 62                   		mov.L	[r6], r2
 298 00cb EF 51                   		mov.L	r5, r1
 299 00cd 05 00 00 00             		bsr	_wc_Sha256Update
 300 00d1 E3 A1                   		mov.L	r1, [r10]
 301                             	.L22:
 407:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
 302                             		.loc 2 407 12
 303 00d3 EC A5                   		mov.L	[r10], r5
 304 00d5 61 05                   		cmp	#0, r5
 305 00d7 21 1D                   		bne	.L23
 408:../src/wolfcrypt/src/random.c ****             if (inB != NULL && inBSz > 0)
 306                             		.loc 2 408 16
 307 00d9 A8 E5                   		mov.L	8[r6], r5
 308 00db 61 05                   		cmp	#0, r5
 309 00dd 20 17                   		beq	.L23
 310                             		.loc 2 408 29 discriminator 1
 311 00df A8 ED                   		mov.L	12[r6], r5
 312 00e1 61 05                   		cmp	#0, r5
 313 00e3 20 11                   		beq	.L23
 409:../src/wolfcrypt/src/random.c ****                 ret = wc_Sha256Update(sha, inB, inBSz);
 314                             		.loc 2 409 23
 315 00e5 71 A5 14                		add	#20, r10, r5
 316 00e8 A8 EB                   		mov.L	12[r6], r3
 317 00ea A8 E2                   		mov.L	8[r6], r2
 318 00ec EF 51                   		mov.L	r5, r1
 319 00ee 05 00 00 00             		bsr	_wc_Sha256Update
 320 00f2 E3 A1                   		mov.L	r1, [r10]
 321                             		.balign 8,3,1
 322                             	.L23:
 410:../src/wolfcrypt/src/random.c ****         }
 411:../src/wolfcrypt/src/random.c ****         if (ret == 0)
 323                             		.loc 2 411 12
 324 00f4 EC A5                   		mov.L	[r10], r5
 325 00f6 61 05                   		cmp	#0, r5
 326 00f8 21 13                   		bne	.L24
 412:../src/wolfcrypt/src/random.c ****             ret = wc_Sha256Final(sha, digest);
 327                             		.loc 2 412 19
 328 00fa 72 A4 84 00             		add	#0x84, r10, r4
 329 00fe 71 A5 14                		add	#20, r10, r5
 330 0101 EF 42                   		mov.L	r4, r2
 331 0103 EF 51                   		mov.L	r5, r1
 332 0105 05 00 00 00             		bsr	_wc_Sha256Final
 333 0109 E3 A1                   		mov.L	r1, [r10]
 334                             	.L24:
 413:../src/wolfcrypt/src/random.c **** 
 414:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 415:../src/wolfcrypt/src/random.c ****         wc_Sha256Free(sha);
 335                             		.loc 2 415 9
 336 010b 71 A5 14                		add	#20, r10, r5
 337 010e EF 51                   		mov.L	r5, r1
 338 0110 05 00 00 00             		bsr	_wc_Sha256Free
 416:../src/wolfcrypt/src/random.c **** #endif
 417:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
 339                             		.loc 2 417 12
 340 0114 EC A5                   		mov.L	[r10], r5
 341 0116 61 05                   		cmp	#0, r5
 342 0118 21 40                   		bne	.L25
 418:../src/wolfcrypt/src/random.c ****             if (outSz > OUTPUT_BLOCK_LEN) {
 343                             		.loc 2 418 16
 344 011a ED A5 2B                		mov.L	172[r10], r5
 345 011d 75 55 20                		cmp	#32, r5
 346 0120 25 28                   		bleu	.L26
 419:../src/wolfcrypt/src/random.c ****                 XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 347                             		.loc 2 419 17
 348 0122 ED A5 2A                		mov.L	168[r10], r5
 349 0125 75 44 20                		mov.L	#32, r4
 350 0128 EF 51                   		mov.L	r5, r1
 351 012a 72 A5 84 00             		add	#0x84, r10, r5
 352 012e EF 52                   		mov.L	r5, r2
 353 0130 EF 43                   		mov.L	r4, r3
 354 0132 7F 8F                   		smovf
 420:../src/wolfcrypt/src/random.c ****                 outSz -= OUTPUT_BLOCK_LEN;
 355                             		.loc 2 420 23
 356 0134 ED A5 2B                		mov.L	172[r10], r5
 357 0137 71 55 E0                		add	#-32, r5
 358 013a E7 A5 2B                		mov.L	r5, 172[r10]
 421:../src/wolfcrypt/src/random.c ****                 out += OUTPUT_BLOCK_LEN;
 359                             		.loc 2 421 21
 360 013d ED A5 2A                		mov.L	168[r10], r5
 361 0140 71 55 20                		add	#32, r5
 362 0143 E7 A5 2A                		mov.L	r5, 168[r10]
 363 0146 2E 12                   		bra	.L25
 364                             	.L26:
 422:../src/wolfcrypt/src/random.c ****             }
 423:../src/wolfcrypt/src/random.c ****             else {
 424:../src/wolfcrypt/src/random.c ****                 XMEMCPY(out, digest, outSz);
 365                             		.loc 2 424 17
 366 0148 72 A5 84 00             		add	#0x84, r10, r5
 367 014c ED A3 2B                		mov.L	172[r10], r3
 368 014f EF 52                   		mov.L	r5, r2
 369 0151 ED A1 2A                		mov.L	168[r10], r1
 370 0154 05 00 00 00             		bsr	_memcpy
 371                             	.L25:
 384:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 372                             		.loc 2 384 27 discriminator 2
 373 0158 ED A5 01                		mov.L	4[r10], r5
 374 015b 62 15                   		add	#1, r5
 375 015d E7 A5 01                		mov.L	r5, 4[r10]
 376                             	.L17:
 384:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 377                             		.loc 2 384 5 discriminator 1
 378 0160 ED A4 01                		mov.L	4[r10], r4
 379 0163 ED A5 02                		mov.L	8[r10], r5
 380 0166 47 54                   		cmp	r5, r4
 381 0168 28 05 38 EE FE          		blt	.L27
 382 016d 2E 03                   		bra	.L19
 383                             	.L29:
 392:../src/wolfcrypt/src/random.c **** #endif
 384                             		.loc 2 392 13
 385 016f 03                      		nop
 386                             	.L19:
 425:../src/wolfcrypt/src/random.c ****             }
 426:../src/wolfcrypt/src/random.c ****         }
 427:../src/wolfcrypt/src/random.c ****     }
 428:../src/wolfcrypt/src/random.c **** 
 429:../src/wolfcrypt/src/random.c ****     ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 387                             		.loc 2 429 5
 388 0170 72 A5 84 00             		add	#0x84, r10, r5
 389 0174 75 42 20                		mov.L	#32, r2
 390 0177 EF 51                   		mov.L	r5, r1
 391 0179 05 00 00 00             		bsr	_ForceZero
 430:../src/wolfcrypt/src/random.c **** 
 431:../src/wolfcrypt/src/random.c **** #ifdef WC_ASYNC_ENABLE_SHA256
 432:../src/wolfcrypt/src/random.c ****     WC_FREE_VAR(digest, drbg->heap);
 433:../src/wolfcrypt/src/random.c **** #endif
 434:../src/wolfcrypt/src/random.c **** 
 435:../src/wolfcrypt/src/random.c ****     return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 392                             		.loc 2 435 38
 393 017d EC A5                   		mov.L	[r10], r5
 394 017f 61 05                   		cmp	#0, r5
 395 0181 FC DB 51                		scne.L	r5
 396 0184 5B 55                   		movu.B	r5, r5
 436:../src/wolfcrypt/src/random.c **** }
 397                             		.loc 2 436 1
 398 0186 EF 51                   		mov.L	r5, r1
 399 0188 72 00 C4 00             		add	#0xc4, r0
 400 018c 7E B6                   		pop	r6
 401 018e 7E BA                   		pop	r10
 402 0190 02                      		rts
 403                             	.LFE43:
 405 0191 FD 70 40 00 00 00 80    		.section	.text.Hash_DRBG_Reseed,"ax",@progbits
 407                             	_Hash_DRBG_Reseed:
 408                             	.LFB44:
 437:../src/wolfcrypt/src/random.c **** 
 438:../src/wolfcrypt/src/random.c **** /* Returns: DRBG_SUCCESS or DRBG_FAILURE */
 439:../src/wolfcrypt/src/random.c **** static int Hash_DRBG_Reseed(DRBG_internal* drbg, const byte* seed, word32 seedSz)
 440:../src/wolfcrypt/src/random.c **** {
 409                             		.loc 2 440 1
 410 0000 7E AA                   		push.l	r10
 411                             	.LCFI13:
 412 0002 71 0A BC                		add	#-68, r0, r10
 413                             	.LCFI14:
 414 0005 71 A0 F0                		add	#-16, r10, r0
 415                             	.LCFI15:
 416 0008 E7 A1 0E                		mov.L	r1, 56[r10]
 417 000b E7 A2 0F                		mov.L	r2, 60[r10]
 418 000e E7 A3 10                		mov.L	r3, 64[r10]
 441:../src/wolfcrypt/src/random.c ****     byte newV[DRBG_SEED_LEN];
 442:../src/wolfcrypt/src/random.c **** 
 443:../src/wolfcrypt/src/random.c ****     if (drbg == NULL) {
 419                             		.loc 2 443 8
 420 0011 ED A5 0E                		mov.L	56[r10], r5
 421 0014 61 05                   		cmp	#0, r5
 422 0016 1E                      		bne	.L31
 444:../src/wolfcrypt/src/random.c ****         return DRBG_FAILURE;
 423                             		.loc 2 444 16
 424 0017 66 15                   		mov.L	#1, r5
 425 0019 38 92 00                		bra	.L35
 426                             	.L31:
 445:../src/wolfcrypt/src/random.c ****     }
 446:../src/wolfcrypt/src/random.c **** 
 447:../src/wolfcrypt/src/random.c ****     XMEMSET(newV, 0, DRBG_SEED_LEN);
 427                             		.loc 2 447 5
 428 001c 75 43 37                		mov.L	#55, r3
 429 001f 66 02                   		mov.L	#0, r2
 430 0021 EF A1                   		mov.L	r10, r1
 431 0023 05 00 00 00             		bsr	_memset
 448:../src/wolfcrypt/src/random.c **** 
 449:../src/wolfcrypt/src/random.c ****     if (Hash_df(drbg, newV, sizeof(newV), drbgReseed,
 450:../src/wolfcrypt/src/random.c ****                 drbg->V, sizeof(drbg->V), seed, seedSz) != DRBG_SUCCESS) {
 432                             		.loc 2 450 21
 433 0027 ED A5 0E                		mov.L	56[r10], r5
 434 002a 62 85                   		add	#8, r5
 449:../src/wolfcrypt/src/random.c ****                 drbg->V, sizeof(drbg->V), seed, seedSz) != DRBG_SUCCESS) {
 435                             		.loc 2 449 9
 436 002c ED A4 10                		mov.L	64[r10], r4
 437 002f A0 8C                   		mov.L	r4, 12[r0]
 438 0031 ED A4 0F                		mov.L	60[r10], r4
 439 0034 A0 84                   		mov.L	r4, 8[r0]
 440 0036 3E 01 37                		mov.L	#55, 4[r0]
 441 0039 E3 05                   		mov.L	r5, [r0]
 442 003b 66 14                   		mov	#1, r4
 443 003d 75 43 37                		mov.L	#55, r3
 444 0040 EF A2                   		mov.L	r10, r2
 445 0042 ED A1 0E                		mov.L	56[r10], r1
 446 0045 05 00 00 00             		bsr	_Hash_df
 447 0049 EF 15                   		mov.L	r1, r5
 449:../src/wolfcrypt/src/random.c ****                 drbg->V, sizeof(drbg->V), seed, seedSz) != DRBG_SUCCESS) {
 448                             		.loc 2 449 8
 449 004b 61 05                   		cmp	#0, r5
 450 004d 15                      		beq	.L33
 451:../src/wolfcrypt/src/random.c ****         return DRBG_FAILURE;
 451                             		.loc 2 451 16
 452 004e 66 15                   		mov.L	#1, r5
 453 0050 2E 5B                   		bra	.L35
 454                             	.L33:
 452:../src/wolfcrypt/src/random.c ****     }
 453:../src/wolfcrypt/src/random.c **** 
 454:../src/wolfcrypt/src/random.c ****     XMEMCPY(drbg->V, newV, sizeof(drbg->V));
 455                             		.loc 2 454 5
 456 0052 ED A5 0E                		mov.L	56[r10], r5
 457 0055 62 85                   		add	#8, r5
 458 0057 75 44 37                		mov.L	#55, r4
 459 005a EF 51                   		mov.L	r5, r1
 460 005c EF A2                   		mov.L	r10, r2
 461 005e EF 43                   		mov.L	r4, r3
 462 0060 7F 8F                   		smovf
 455:../src/wolfcrypt/src/random.c ****     ForceZero(newV, sizeof(newV));
 463                             		.loc 2 455 5
 464 0062 75 42 37                		mov.L	#55, r2
 465 0065 EF A1                   		mov.L	r10, r1
 466 0067 05 00 00 00             		bsr	_ForceZero
 456:../src/wolfcrypt/src/random.c **** 
 457:../src/wolfcrypt/src/random.c ****     if (Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 467                             		.loc 2 457 27
 468 006b ED A5 0E                		mov.L	56[r10], r5
 469 006e 71 52 3F                		add	#63, r5, r2
 470                             		.loc 2 457 64
 471 0071 ED A5 0E                		mov.L	56[r10], r5
 472 0074 62 85                   		add	#8, r5
 473                             		.loc 2 457 9
 474 0076 3E 03 00                		mov.L	#0, 12[r0]
 475 0079 3E 02 00                		mov.L	#0, 8[r0]
 476 007c 3E 01 37                		mov.L	#55, 4[r0]
 477 007f E3 05                   		mov.L	r5, [r0]
 478 0081 66 04                   		mov	#0, r4
 479 0083 75 43 37                		mov.L	#55, r3
 480 0086 ED A1 0E                		mov.L	56[r10], r1
 481 0089 05 00 00 00             		bsr	_Hash_df
 482 008d EF 15                   		mov.L	r1, r5
 483                             		.loc 2 457 8
 484 008f 61 05                   		cmp	#0, r5
 485 0091 15                      		beq	.L34
 458:../src/wolfcrypt/src/random.c ****                                     sizeof(drbg->V), NULL, 0) != DRBG_SUCCESS) {
 459:../src/wolfcrypt/src/random.c ****         return DRBG_FAILURE;
 486                             		.loc 2 459 16
 487 0092 66 15                   		mov.L	#1, r5
 488 0094 2E 17                   		bra	.L35
 489                             	.L34:
 460:../src/wolfcrypt/src/random.c ****     }
 461:../src/wolfcrypt/src/random.c **** 
 462:../src/wolfcrypt/src/random.c ****     drbg->reseedCtr = 1;
 490                             		.loc 2 462 21
 491 0096 ED A5 0E                		mov.L	56[r10], r5
 492 0099 F8 56 01                		mov.L	#1, [r5]
 463:../src/wolfcrypt/src/random.c ****     drbg->lastBlock = 0;
 493                             		.loc 2 463 21
 494 009c ED A5 0E                		mov.L	56[r10], r5
 495 009f 3E 51 00                		mov.L	#0, 4[r5]
 464:../src/wolfcrypt/src/random.c ****     drbg->matchCount = 0;
 496                             		.loc 2 464 22
 497 00a2 ED A5 0E                		mov.L	56[r10], r5
 498 00a5 F9 54 76 00             		mov.B	#0, 118[r5]
 465:../src/wolfcrypt/src/random.c ****     return DRBG_SUCCESS;
 499                             		.loc 2 465 12
 500 00a9 66 05                   		mov.L	#0, r5
 501                             		.balign 8,3,1
 502                             	.L35:
 466:../src/wolfcrypt/src/random.c **** }
 503                             		.loc 2 466 1 discriminator 1
 504 00ab EF 51                   		mov.L	r5, r1
 505 00ad 3F AA 16                		rtsd	#88, r10-r10
 506                             	.LFE44:
 508                             		.section	.text.wc_RNG_DRBG_Reseed,"ax",@progbits
 509                             		.global	_wc_RNG_DRBG_Reseed
 511                             	_wc_RNG_DRBG_Reseed:
 512                             	.LFB45:
 467:../src/wolfcrypt/src/random.c **** 
 468:../src/wolfcrypt/src/random.c **** /* Returns: DRBG_SUCCESS and DRBG_FAILURE or BAD_FUNC_ARG on fail */
 469:../src/wolfcrypt/src/random.c **** int wc_RNG_DRBG_Reseed(WC_RNG* rng, const byte* seed, word32 seedSz)
 470:../src/wolfcrypt/src/random.c **** {
 513                             		.loc 2 470 1
 514 0000 7E AA                   		push.l	r10
 515                             	.LCFI16:
 516 0002 71 0A F4                		add	#-12, r0, r10
 517                             	.LCFI17:
 518 0005 EF A0                   		mov.L	r10, r0
 519 0007 E3 A1                   		mov.L	r1, [r10]
 520 0009 E7 A2 01                		mov.L	r2, 4[r10]
 521 000c E7 A3 02                		mov.L	r3, 8[r10]
 471:../src/wolfcrypt/src/random.c ****     if (rng == NULL || seed == NULL) {
 522                             		.loc 2 471 8
 523 000f EC A5                   		mov.L	[r10], r5
 524 0011 61 05                   		cmp	#0, r5
 525 0013 17                      		beq	.L37
 526                             		.loc 2 471 21 discriminator 1
 527 0014 ED A5 01                		mov.L	4[r10], r5
 528 0017 61 05                   		cmp	#0, r5
 529 0019 1F                      		bne	.L38
 530                             	.L37:
 472:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
 531                             		.loc 2 472 16
 532 001a FB 5A 53 FF             		mov.L	#-173, r5
 533 001e 2E 14                   		bra	.L39
 534                             	.L38:
 473:../src/wolfcrypt/src/random.c ****     }
 474:../src/wolfcrypt/src/random.c **** 
 475:../src/wolfcrypt/src/random.c ****     if (rng->drbg == NULL) {
 476:../src/wolfcrypt/src/random.c ****     #if defined(HAVE_INTEL_RDSEED) || defined(HAVE_INTEL_RDRAND)
 477:../src/wolfcrypt/src/random.c ****         if (IS_INTEL_RDRAND(intel_flags)) {
 478:../src/wolfcrypt/src/random.c ****             /* using RDRAND not DRBG, so return success */
 479:../src/wolfcrypt/src/random.c ****             return 0;
 480:../src/wolfcrypt/src/random.c ****         }
 481:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
 482:../src/wolfcrypt/src/random.c ****     #endif
 483:../src/wolfcrypt/src/random.c ****     }
 484:../src/wolfcrypt/src/random.c **** 
 485:../src/wolfcrypt/src/random.c ****     return Hash_DRBG_Reseed((DRBG_internal *)rng->drbg, seed, seedSz);
 535                             		.loc 2 485 49
 536 0020 EC A5                   		mov.L	[r10], r5
 537 0022 A8 D5                   		mov.L	8[r5], r5
 538                             		.loc 2 485 12
 539 0024 ED A3 02                		mov.L	8[r10], r3
 540 0027 ED A2 01                		mov.L	4[r10], r2
 541 002a EF 51                   		mov.L	r5, r1
 542 002c 05 00 00 00             		bsr	_Hash_DRBG_Reseed
 543 0030 EF 15                   		mov.L	r1, r5
 544                             	.L39:
 486:../src/wolfcrypt/src/random.c **** }
 545                             		.loc 2 486 1
 546 0032 EF 51                   		mov.L	r5, r1
 547 0034 3F AA 04                		rtsd	#16, r10-r10
 548                             	.LFE45:
 550                             		.section	.text.array_add_one,"ax",@progbits
 552                             	_array_add_one:
 553                             	.LFB46:
 487:../src/wolfcrypt/src/random.c **** 
 488:../src/wolfcrypt/src/random.c **** static WC_INLINE void array_add_one(byte* data, word32 dataSz)
 489:../src/wolfcrypt/src/random.c **** {
 554                             		.loc 2 489 1
 555 0000 7E AA                   		push.l	r10
 556                             	.LCFI18:
 557 0002 71 0A F4                		add	#-12, r0, r10
 558                             	.LCFI19:
 559 0005 EF A0                   		mov.L	r10, r0
 560 0007 E7 A1 01                		mov.L	r1, 4[r10]
 561 000a E7 A2 02                		mov.L	r2, 8[r10]
 490:../src/wolfcrypt/src/random.c ****     int i;
 491:../src/wolfcrypt/src/random.c **** 
 492:../src/wolfcrypt/src/random.c ****     for (i = dataSz - 1; i >= 0; i--)
 562                             		.loc 2 492 21
 563 000d ED A5 02                		mov.L	8[r10], r5
 564 0010 60 15                   		sub	#1, r5
 565                             		.loc 2 492 12
 566 0012 E3 A5                   		mov.L	r5, [r10]
 567                             		.loc 2 492 5
 568 0014 2E 24                   		bra	.L41
 569                             	.L44:
 493:../src/wolfcrypt/src/random.c ****     {
 494:../src/wolfcrypt/src/random.c ****         data[i]++;
 570                             		.loc 2 494 13
 571 0016 EC A5                   		mov.L	[r10], r5
 572 0018 ED A4 01                		mov.L	4[r10], r4
 573 001b 4B 45                   		add	r4, r5
 574 001d CC 54                   		mov.B	[r5], r4
 575                             		.loc 2 494 16
 576 001f 62 14                   		add	#1, r4
 577 0021 C3 54                   		mov.B	r4, [r5]
 495:../src/wolfcrypt/src/random.c ****         if (data[i] != 0) break;
 578                             		.loc 2 495 17
 579 0023 EC A5                   		mov.L	[r10], r5
 580 0025 ED A4 01                		mov.L	4[r10], r4
 581 0028 4B 45                   		add	r4, r5
 582 002a CC 55                   		mov.B	[r5], r5
 583                             		.loc 2 495 12
 584 002c 5B 55                   		movu.B	r5, r5
 585 002e 61 05                   		cmp	#0, r5
 586 0030 21 10                   		bne	.L45
 492:../src/wolfcrypt/src/random.c ****     {
 587                             		.loc 2 492 35 discriminator 2
 588 0032 EC A5                   		mov.L	[r10], r5
 589 0034 60 15                   		sub	#1, r5
 590 0036 E3 A5                   		mov.L	r5, [r10]
 591                             	.L41:
 492:../src/wolfcrypt/src/random.c ****     {
 592                             		.loc 2 492 5 discriminator 1
 593 0038 EC A5                   		mov.L	[r10], r5
 594 003a 61 05                   		cmp	#0, r5
 595 003c 28 DA                   		bge	.L44
 496:../src/wolfcrypt/src/random.c ****     }
 497:../src/wolfcrypt/src/random.c **** }
 596                             		.loc 2 497 1
 597 003e 2E 03                   		bra	.L43
 598                             	.L45:
 495:../src/wolfcrypt/src/random.c ****     }
 599                             		.loc 2 495 9
 600 0040 03                      		nop
 601                             	.L43:
 602                             		.loc 2 497 1
 603 0041 03                      		nop
 604 0042 3F AA 04                		rtsd	#16, r10-r10
 605                             	.LFE46:
 607                             		.section	.text.Hash_gen,"ax",@progbits
 609                             	_Hash_gen:
 610                             	.LFB47:
 498:../src/wolfcrypt/src/random.c **** 
 499:../src/wolfcrypt/src/random.c **** /* Returns: DRBG_SUCCESS or DRBG_FAILURE */
 500:../src/wolfcrypt/src/random.c **** static int Hash_gen(DRBG_internal* drbg, byte* out, word32 outSz, const byte* V)
 501:../src/wolfcrypt/src/random.c **** {
 611                             		.loc 2 501 1
 612 0000 7E AA                   		push.l	r10
 613                             	.LCFI20:
 614 0002 72 0A 18 FF             		add	#-232, r0, r10
 615                             	.LCFI21:
 616 0006 EF A0                   		mov.L	r10, r0
 617 0008 E7 A1 36                		mov.L	r1, 216[r10]
 618 000b E7 A2 37                		mov.L	r2, 220[r10]
 619 000e E7 A3 38                		mov.L	r3, 224[r10]
 620 0011 E7 A4 39                		mov.L	r4, 228[r10]
 502:../src/wolfcrypt/src/random.c ****     int ret = DRBG_FAILURE;
 621                             		.loc 2 502 9
 622 0014 F8 A6 01                		mov.L	#1, [r10]
 503:../src/wolfcrypt/src/random.c ****     byte data[DRBG_SEED_LEN];
 504:../src/wolfcrypt/src/random.c ****     int i;
 505:../src/wolfcrypt/src/random.c ****     int len;
 506:../src/wolfcrypt/src/random.c ****     word32 checkBlock;
 507:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
 508:../src/wolfcrypt/src/random.c ****     wc_Sha256* sha = &drbg->sha256;
 509:../src/wolfcrypt/src/random.c **** #else
 510:../src/wolfcrypt/src/random.c ****     wc_Sha256 sha[1];
 511:../src/wolfcrypt/src/random.c **** #endif
 512:../src/wolfcrypt/src/random.c **** #ifdef WC_ASYNC_ENABLE_SHA256
 513:../src/wolfcrypt/src/random.c ****     WC_DECLARE_VAR(digest, byte, WC_SHA256_DIGEST_SIZE, drbg->heap);
 514:../src/wolfcrypt/src/random.c ****     if (digest == NULL)
 515:../src/wolfcrypt/src/random.c ****         return MEMORY_E;
 516:../src/wolfcrypt/src/random.c **** #else
 517:../src/wolfcrypt/src/random.c ****     byte digest[WC_SHA256_DIGEST_SIZE];
 518:../src/wolfcrypt/src/random.c **** #endif
 519:../src/wolfcrypt/src/random.c **** 
 520:../src/wolfcrypt/src/random.c ****     /* Special case: outSz is 0 and out is NULL. wc_Generate a block to save for
 521:../src/wolfcrypt/src/random.c ****      * the continuous test. */
 522:../src/wolfcrypt/src/random.c **** 
 523:../src/wolfcrypt/src/random.c ****     if (outSz == 0) outSz = 1;
 623                             		.loc 2 523 8
 624 0017 ED A5 38                		mov.L	224[r10], r5
 625 001a 61 05                   		cmp	#0, r5
 626 001c 1D                      		bne	.L47
 627                             		.loc 2 523 27 discriminator 1
 628 001d F9 A6 38 01             		mov.L	#1, 224[r10]
 629                             	.L47:
 524:../src/wolfcrypt/src/random.c **** 
 525:../src/wolfcrypt/src/random.c ****     len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 630                             		.loc 2 525 18
 631 0021 ED A5 38                		mov.L	224[r10], r5
 632 0024 FD 85 54                		shlr	#5, r5, r4
 633                             		.loc 2 525 48
 634 0027 ED A5 38                		mov.L	224[r10], r5
 635 002a 75 25 1F                		and	#31, r5
 636                             		.loc 2 525 72
 637 002d 61 05                   		cmp	#0, r5
 638 002f 14                      		beq	.L48
 639                             		.loc 2 525 72 is_stmt 0 discriminator 1
 640 0030 66 15                   		mov.L	#1, r5
 641 0032 0B                      		bra	.L49
 642                             	.L48:
 643                             		.loc 2 525 72 discriminator 2
 644 0033 66 05                   		mov.L	#0, r5
 645                             	.L49:
 646                             		.loc 2 525 38 is_stmt 1 discriminator 4
 647 0035 4B 45                   		add	r4, r5
 648                             		.loc 2 525 9 discriminator 4
 649 0037 E7 A5 02                		mov.L	r5, 8[r10]
 526:../src/wolfcrypt/src/random.c **** 
 527:../src/wolfcrypt/src/random.c ****     XMEMCPY(data, V, sizeof(data));
 650                             		.loc 2 527 5 discriminator 4
 651 003a ED A3 39                		mov.L	228[r10], r3
 652 003d 75 44 37                		mov.L	#55, r4
 653 0040 71 A5 0C                		add	#12, r10, r5
 654 0043 EF 51                   		mov.L	r5, r1
 655 0045 EF 32                   		mov.L	r3, r2
 656 0047 EF 43                   		mov.L	r4, r3
 657 0049 7F 8F                   		smovf
 528:../src/wolfcrypt/src/random.c ****     for (i = 0; i < len; i++) {
 658                             		.loc 2 528 12 discriminator 4
 659 004b F9 A6 01 00             		mov.L	#0, 4[r10]
 660                             		.loc 2 528 5 discriminator 4
 661 004f 38 09 01                		bra	.L50
 662                             	.L63:
 529:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 530:../src/wolfcrypt/src/random.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
 531:../src/wolfcrypt/src/random.c ****         ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
 532:../src/wolfcrypt/src/random.c ****     #else
 533:../src/wolfcrypt/src/random.c ****         ret = wc_InitSha256(sha);
 663                             		.loc 2 533 15
 664 0052 71 A5 48                		add	#0x48, r10, r5
 665 0055 EF 51                   		mov.L	r5, r1
 666 0057 05 00 00 00             		bsr	_wc_InitSha256
 667 005b E3 A1                   		mov.L	r1, [r10]
 534:../src/wolfcrypt/src/random.c ****     #endif
 535:../src/wolfcrypt/src/random.c ****         if (ret == 0)
 668                             		.loc 2 535 12
 669 005d EC A5                   		mov.L	[r10], r5
 670 005f 61 05                   		cmp	#0, r5
 671 0061 21 15                   		bne	.L51
 536:../src/wolfcrypt/src/random.c **** #endif
 537:../src/wolfcrypt/src/random.c ****             ret = wc_Sha256Update(sha, data, sizeof(data));
 672                             		.loc 2 537 19
 673 0063 71 A4 0C                		add	#12, r10, r4
 674 0066 71 A5 48                		add	#0x48, r10, r5
 675 0069 75 43 37                		mov.L	#55, r3
 676 006c EF 42                   		mov.L	r4, r2
 677 006e EF 51                   		mov.L	r5, r1
 678 0070 05 00 00 00             		bsr	_wc_Sha256Update
 679 0074 E3 A1                   		mov.L	r1, [r10]
 680                             	.L51:
 538:../src/wolfcrypt/src/random.c ****         if (ret == 0)
 681                             		.loc 2 538 12
 682 0076 EC A5                   		mov.L	[r10], r5
 683 0078 61 05                   		cmp	#0, r5
 684 007a 21 13                   		bne	.L52
 539:../src/wolfcrypt/src/random.c ****             ret = wc_Sha256Final(sha, digest);
 685                             		.loc 2 539 19
 686 007c 72 A4 B8 00             		add	#0xb8, r10, r4
 687 0080 71 A5 48                		add	#0x48, r10, r5
 688 0083 EF 42                   		mov.L	r4, r2
 689 0085 EF 51                   		mov.L	r5, r1
 690 0087 05 00 00 00             		bsr	_wc_Sha256Final
 691 008b E3 A1                   		mov.L	r1, [r10]
 692                             	.L52:
 540:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 541:../src/wolfcrypt/src/random.c ****         wc_Sha256Free(sha);
 693                             		.loc 2 541 9
 694 008d 71 A5 48                		add	#0x48, r10, r5
 695 0090 EF 51                   		mov.L	r5, r1
 696 0092 05 00 00 00             		bsr	_wc_Sha256Free
 542:../src/wolfcrypt/src/random.c **** #endif
 543:../src/wolfcrypt/src/random.c **** 
 544:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
 697                             		.loc 2 544 12
 698 0096 EC A5                   		mov.L	[r10], r5
 699 0098 61 05                   		cmp	#0, r5
 700 009a 3B CD 00                		bne	.L65
 545:../src/wolfcrypt/src/random.c ****             XMEMCPY(&checkBlock, digest, sizeof(word32));
 701                             		.loc 2 545 13
 702 009d ED A5 2E                		mov.L	184[r10], r5
 703 00a0 E7 A5 11                		mov.L	r5, 68[r10]
 546:../src/wolfcrypt/src/random.c ****             if (drbg->reseedCtr > 1 && checkBlock == drbg->lastBlock) {
 704                             		.loc 2 546 21
 705 00a3 ED A5 36                		mov.L	216[r10], r5
 706 00a6 EC 55                   		mov.L	[r5], r5
 707                             		.loc 2 546 16
 708 00a8 61 15                   		cmp	#1, r5
 709 00aa 25 3A                   		bleu	.L54
 710                             		.loc 2 546 58 discriminator 1
 711 00ac ED A5 36                		mov.L	216[r10], r5
 712 00af A8 5C                   		mov.L	4[r5], r4
 713                             		.loc 2 546 51 discriminator 1
 714 00b1 ED A5 11                		mov.L	68[r10], r5
 715                             		.loc 2 546 37 discriminator 1
 716 00b4 47 54                   		cmp	r5, r4
 717 00b6 21 2E                   		bne	.L54
 547:../src/wolfcrypt/src/random.c ****                 if (drbg->matchCount == 1) {
 718                             		.loc 2 547 25
 719 00b8 ED A5 36                		mov.L	216[r10], r5
 720 00bb CD 55 76                		mov.B	118[r5], r5
 721                             		.loc 2 547 20
 722 00be 5B 55                   		movu.B	r5, r5
 723 00c0 61 15                   		cmp	#1, r5
 724 00c2 1E                      		bne	.L55
 548:../src/wolfcrypt/src/random.c ****                     return DRBG_CONT_FAILURE;
 725                             		.loc 2 548 28
 726 00c3 66 35                   		mov.L	#3, r5
 727 00c5 38 B8 00                		bra	.L64
 728                             	.L55:
 549:../src/wolfcrypt/src/random.c ****                 }
 550:../src/wolfcrypt/src/random.c ****                 else {
 551:../src/wolfcrypt/src/random.c ****                     if (i == (len-1)) {
 729                             		.loc 2 551 34
 730 00c8 ED A5 02                		mov.L	8[r10], r5
 731 00cb 60 15                   		sub	#1, r5
 732                             		.loc 2 551 24
 733 00cd ED A4 01                		mov.L	4[r10], r4
 734 00d0 47 54                   		cmp	r5, r4
 735 00d2 19                      		bne	.L57
 552:../src/wolfcrypt/src/random.c ****                         len++;
 736                             		.loc 2 552 28
 737 00d3 ED A5 02                		mov.L	8[r10], r5
 738 00d6 62 15                   		add	#1, r5
 739 00d8 E7 A5 02                		mov.L	r5, 8[r10]
 740                             	.L57:
 553:../src/wolfcrypt/src/random.c ****                     }
 554:../src/wolfcrypt/src/random.c ****                     drbg->matchCount = 1;
 741                             		.loc 2 554 38
 742 00db ED A5 36                		mov.L	216[r10], r5
 743 00de F9 54 76 01             		mov.B	#1, 118[r5]
 547:../src/wolfcrypt/src/random.c ****                     return DRBG_CONT_FAILURE;
 744                             		.loc 2 547 20
 745 00e2 2E 11                   		bra	.L58
 746                             	.L54:
 555:../src/wolfcrypt/src/random.c ****                 }
 556:../src/wolfcrypt/src/random.c ****             }
 557:../src/wolfcrypt/src/random.c ****             else {
 558:../src/wolfcrypt/src/random.c ****                 drbg->matchCount = 0;
 747                             		.loc 2 558 34
 748 00e4 ED A5 36                		mov.L	216[r10], r5
 749 00e7 F9 54 76 00             		mov.B	#0, 118[r5]
 559:../src/wolfcrypt/src/random.c ****                 drbg->lastBlock = checkBlock;
 750                             		.loc 2 559 33
 751 00eb ED A4 11                		mov.L	68[r10], r4
 752 00ee ED A5 36                		mov.L	216[r10], r5
 753 00f1 A0 5C                   		mov.L	r4, 4[r5]
 754                             	.L58:
 560:../src/wolfcrypt/src/random.c ****             }
 561:../src/wolfcrypt/src/random.c **** 
 562:../src/wolfcrypt/src/random.c ****             if (out != NULL && outSz != 0) {
 755                             		.loc 2 562 16
 756 00f3 ED A5 37                		mov.L	220[r10], r5
 757 00f6 61 05                   		cmp	#0, r5
 758 00f8 20 58                   		beq	.L61
 759                             		.loc 2 562 29 discriminator 1
 760 00fa ED A5 38                		mov.L	224[r10], r5
 761 00fd 61 05                   		cmp	#0, r5
 762 00ff 20 51                   		beq	.L61
 563:../src/wolfcrypt/src/random.c ****                 if (outSz >= OUTPUT_BLOCK_LEN) {
 763                             		.loc 2 563 20
 764 0101 ED A5 38                		mov.L	224[r10], r5
 765 0104 75 55 1F                		cmp	#31, r5
 766 0107 25 34                   		bleu	.L60
 564:../src/wolfcrypt/src/random.c ****                     XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 767                             		.loc 2 564 21
 768 0109 ED A5 37                		mov.L	220[r10], r5
 769 010c 75 44 20                		mov.L	#32, r4
 770 010f EF 51                   		mov.L	r5, r1
 771 0111 72 A5 B8 00             		add	#0xb8, r10, r5
 772 0115 EF 52                   		mov.L	r5, r2
 773 0117 EF 43                   		mov.L	r4, r3
 774 0119 7F 8F                   		smovf
 565:../src/wolfcrypt/src/random.c ****                     outSz -= OUTPUT_BLOCK_LEN;
 775                             		.loc 2 565 27
 776 011b ED A5 38                		mov.L	224[r10], r5
 777 011e 71 55 E0                		add	#-32, r5
 778 0121 E7 A5 38                		mov.L	r5, 224[r10]
 566:../src/wolfcrypt/src/random.c ****                     out += OUTPUT_BLOCK_LEN;
 779                             		.loc 2 566 25
 780 0124 ED A5 37                		mov.L	220[r10], r5
 781 0127 71 55 20                		add	#32, r5
 782 012a E7 A5 37                		mov.L	r5, 220[r10]
 567:../src/wolfcrypt/src/random.c ****                     array_add_one(data, DRBG_SEED_LEN);
 783                             		.loc 2 567 21
 784 012d 71 A5 0C                		add	#12, r10, r5
 785 0130 75 42 37                		mov.L	#55, r2
 786 0133 EF 51                   		mov.L	r5, r1
 787 0135 05 00 00 00             		bsr	_array_add_one
 788 0139 2E 17                   		bra	.L61
 789                             	.L60:
 568:../src/wolfcrypt/src/random.c ****                 }
 569:../src/wolfcrypt/src/random.c ****                 else {
 570:../src/wolfcrypt/src/random.c ****                     XMEMCPY(out, digest, outSz);
 790                             		.loc 2 570 21
 791 013b 72 A5 B8 00             		add	#0xb8, r10, r5
 792 013f ED A3 38                		mov.L	224[r10], r3
 793 0142 EF 52                   		mov.L	r5, r2
 794 0144 ED A1 37                		mov.L	220[r10], r1
 795 0147 05 00 00 00             		bsr	_memcpy
 571:../src/wolfcrypt/src/random.c ****                     outSz = 0;
 796                             		.loc 2 571 27
 797 014b F9 A6 38 00             		mov.L	#0, 224[r10]
 798 014f 03                      		.balign 8,3,1
 799                             	.L61:
 528:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 800                             		.loc 2 528 27 discriminator 2
 801 0150 ED A5 01                		mov.L	4[r10], r5
 802 0153 62 15                   		add	#1, r5
 803 0155 E7 A5 01                		mov.L	r5, 4[r10]
 804                             	.L50:
 528:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 805                             		.loc 2 528 5 discriminator 1
 806 0158 ED A4 01                		mov.L	4[r10], r4
 807 015b ED A5 02                		mov.L	8[r10], r5
 808 015e 47 54                   		cmp	r5, r4
 809 0160 28 05 38 F0 FE          		blt	.L63
 810 0165 2E 03                   		bra	.L62
 811                             	.L65:
 572:../src/wolfcrypt/src/random.c ****                 }
 573:../src/wolfcrypt/src/random.c ****             }
 574:../src/wolfcrypt/src/random.c ****         }
 575:../src/wolfcrypt/src/random.c ****         else {
 576:../src/wolfcrypt/src/random.c ****             /* wc_Sha256Update or wc_Sha256Final returned error */
 577:../src/wolfcrypt/src/random.c ****             break;
 812                             		.loc 2 577 13
 813 0167 03                      		nop
 814                             	.L62:
 578:../src/wolfcrypt/src/random.c ****         }
 579:../src/wolfcrypt/src/random.c ****     }
 580:../src/wolfcrypt/src/random.c ****     ForceZero(data, sizeof(data));
 815                             		.loc 2 580 5
 816 0168 71 A5 0C                		add	#12, r10, r5
 817 016b 75 42 37                		mov.L	#55, r2
 818 016e EF 51                   		mov.L	r5, r1
 819 0170 05 00 00 00             		bsr	_ForceZero
 581:../src/wolfcrypt/src/random.c **** 
 582:../src/wolfcrypt/src/random.c **** #ifdef WC_ASYNC_ENABLE_SHA256
 583:../src/wolfcrypt/src/random.c ****     WC_FREE_VAR(digest, drbg->heap);
 584:../src/wolfcrypt/src/random.c **** #endif
 585:../src/wolfcrypt/src/random.c **** 
 586:../src/wolfcrypt/src/random.c ****     return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 820                             		.loc 2 586 38
 821 0174 EC A5                   		mov.L	[r10], r5
 822 0176 61 05                   		cmp	#0, r5
 823 0178 FC DB 51                		scne.L	r5
 824 017b 5B 55                   		movu.B	r5, r5
 825                             	.L64:
 587:../src/wolfcrypt/src/random.c **** }
 826                             		.loc 2 587 1 discriminator 1
 827 017d EF 51                   		mov.L	r5, r1
 828 017f 3F AA 3B                		rtsd	#236, r10-r10
 829                             	.LFE47:
 831 0182 74 10 01 00 00 00       		.section	.text.array_add,"ax",@progbits
 833                             	_array_add:
 834                             	.LFB48:
 588:../src/wolfcrypt/src/random.c **** 
 589:../src/wolfcrypt/src/random.c **** static WC_INLINE void array_add(byte* d, word32 dLen, const byte* s, word32 sLen)
 590:../src/wolfcrypt/src/random.c **** {
 835                             		.loc 2 590 1
 836 0000 7E AA                   		push.l	r10
 837                             	.LCFI22:
 838 0002 71 0A E4                		add	#-28, r0, r10
 839                             	.LCFI23:
 840 0005 EF A0                   		mov.L	r10, r0
 841 0007 E7 A1 03                		mov.L	r1, 12[r10]
 842 000a E7 A2 04                		mov.L	r2, 16[r10]
 843 000d E7 A3 05                		mov.L	r3, 20[r10]
 844 0010 E7 A4 06                		mov.L	r4, 24[r10]
 591:../src/wolfcrypt/src/random.c ****     word16 carry = 0;
 845                             		.loc 2 591 12
 846 0013 F8 A5 00                		mov.W	#0, [r10]
 592:../src/wolfcrypt/src/random.c **** 
 593:../src/wolfcrypt/src/random.c ****     if (dLen > 0 && sLen > 0 && dLen >= sLen) {
 847                             		.loc 2 593 8
 848 0016 ED A5 04                		mov.L	16[r10], r5
 849 0019 61 05                   		cmp	#0, r5
 850 001b 3A AA 00                		beq	.L72
 851                             		.loc 2 593 18 discriminator 1
 852 001e ED A5 06                		mov.L	24[r10], r5
 853 0021 61 05                   		cmp	#0, r5
 854 0023 3A A2 00                		beq	.L72
 855                             		.loc 2 593 30 discriminator 2
 856 0026 ED A4 04                		mov.L	16[r10], r4
 857 0029 ED A5 06                		mov.L	24[r10], r5
 858 002c 47 54                   		cmp	r5, r4
 859 002e 22 05 38 95 00          		bltu	.L72
 860                             	.LBB2:
 594:../src/wolfcrypt/src/random.c ****         int sIdx, dIdx;
 595:../src/wolfcrypt/src/random.c **** 
 596:../src/wolfcrypt/src/random.c ****         dIdx = dLen - 1;
 861                             		.loc 2 596 21
 862 0033 ED A5 04                		mov.L	16[r10], r5
 863 0036 60 15                   		sub	#1, r5
 864                             		.loc 2 596 14
 865 0038 E7 A5 02                		mov.L	r5, 8[r10]
 597:../src/wolfcrypt/src/random.c ****         for (sIdx = sLen - 1; sIdx >= 0; sIdx--) {
 866                             		.loc 2 597 26
 867 003b ED A5 06                		mov.L	24[r10], r5
 868 003e 60 15                   		sub	#1, r5
 869                             		.loc 2 597 19
 870 0040 E7 A5 01                		mov.L	r5, 4[r10]
 871                             		.loc 2 597 9
 872 0043 2E 46                   		bra	.L68
 873                             	.L69:
 598:../src/wolfcrypt/src/random.c ****             carry += (word16)d[dIdx] + (word16)s[sIdx];
 874                             		.loc 2 598 31 discriminator 3
 875 0045 ED A5 02                		mov.L	8[r10], r5
 876 0048 ED A4 03                		mov.L	12[r10], r4
 877 004b 4B 45                   		add	r4, r5
 878 004d CC 55                   		mov.B	[r5], r5
 879 004f 5B 55                   		movu.B	r5, r5
 880 0051 DF 54                   		mov.W	r5, r4
 881                             		.loc 2 598 49 discriminator 3
 882 0053 ED A5 01                		mov.L	4[r10], r5
 883 0056 ED A3 05                		mov.L	20[r10], r3
 884 0059 4B 35                   		add	r3, r5
 885 005b CC 55                   		mov.B	[r5], r5
 886 005d 5B 55                   		movu.B	r5, r5
 887                             		.loc 2 598 38 discriminator 3
 888 005f 4B 45                   		add	r4, r5
 889                             		.loc 2 598 19 discriminator 3
 890 0061 DC A4                   		mov.W	[r10], r4
 891 0063 4B 45                   		add	r4, r5
 892 0065 D3 A5                   		mov.W	r5, [r10]
 599:../src/wolfcrypt/src/random.c ****             d[dIdx] = (byte)carry;
 893                             		.loc 2 599 14 discriminator 3
 894 0067 ED A5 02                		mov.L	8[r10], r5
 895 006a ED A4 03                		mov.L	12[r10], r4
 896 006d 4B 45                   		add	r4, r5
 897                             		.loc 2 599 23 discriminator 3
 898 006f DC A4                   		mov.W	[r10], r4
 899                             		.loc 2 599 21 discriminator 3
 900 0071 C3 54                   		mov.B	r4, [r5]
 600:../src/wolfcrypt/src/random.c ****             carry >>= 8;
 901                             		.loc 2 600 19 discriminator 3
 902 0073 5C A5                   		movu.W	[r10], r5
 903 0075 68 85                   		shlr	#8, r5
 904 0077 D3 A5                   		mov.W	r5, [r10]
 601:../src/wolfcrypt/src/random.c ****             dIdx--;
 905                             		.loc 2 601 17 discriminator 3
 906 0079 ED A5 02                		mov.L	8[r10], r5
 907 007c 60 15                   		sub	#1, r5
 908 007e E7 A5 02                		mov.L	r5, 8[r10]
 597:../src/wolfcrypt/src/random.c ****             carry += (word16)d[dIdx] + (word16)s[sIdx];
 909                             		.loc 2 597 46 discriminator 3
 910 0081 ED A5 01                		mov.L	4[r10], r5
 911 0084 60 15                   		sub	#1, r5
 912 0086 E7 A5 01                		mov.L	r5, 4[r10]
 913                             	.L68:
 597:../src/wolfcrypt/src/random.c ****             carry += (word16)d[dIdx] + (word16)s[sIdx];
 914                             		.loc 2 597 9 discriminator 1
 915 0089 ED A5 01                		mov.L	4[r10], r5
 916 008c 61 05                   		cmp	#0, r5
 917 008e 28 B7                   		bge	.L69
 602:../src/wolfcrypt/src/random.c ****         }
 603:../src/wolfcrypt/src/random.c **** 
 604:../src/wolfcrypt/src/random.c ****         for (; dIdx >= 0; dIdx--) {
 918                             		.loc 2 604 9
 919 0090 2E 2E                   		bra	.L70
 920                             	.L71:
 605:../src/wolfcrypt/src/random.c ****             carry += (word16)d[dIdx];
 921                             		.loc 2 605 31 discriminator 2
 922 0092 ED A5 02                		mov.L	8[r10], r5
 923 0095 ED A4 03                		mov.L	12[r10], r4
 924 0098 4B 45                   		add	r4, r5
 925 009a CC 55                   		mov.B	[r5], r5
 926 009c 5B 55                   		movu.B	r5, r5
 927                             		.loc 2 605 19 discriminator 2
 928 009e DC A4                   		mov.W	[r10], r4
 929 00a0 4B 45                   		add	r4, r5
 930 00a2 D3 A5                   		mov.W	r5, [r10]
 606:../src/wolfcrypt/src/random.c ****             d[dIdx] = (byte)carry;
 931                             		.loc 2 606 14 discriminator 2
 932 00a4 ED A5 02                		mov.L	8[r10], r5
 933 00a7 ED A4 03                		mov.L	12[r10], r4
 934 00aa 4B 45                   		add	r4, r5
 935                             		.loc 2 606 23 discriminator 2
 936 00ac DC A4                   		mov.W	[r10], r4
 937                             		.loc 2 606 21 discriminator 2
 938 00ae C3 54                   		mov.B	r4, [r5]
 607:../src/wolfcrypt/src/random.c ****             carry >>= 8;
 939                             		.loc 2 607 19 discriminator 2
 940 00b0 5C A5                   		movu.W	[r10], r5
 941 00b2 68 85                   		shlr	#8, r5
 942 00b4 D3 A5                   		mov.W	r5, [r10]
 604:../src/wolfcrypt/src/random.c ****             carry += (word16)d[dIdx];
 943                             		.loc 2 604 31 discriminator 2
 944 00b6 ED A5 02                		mov.L	8[r10], r5
 945 00b9 60 15                   		sub	#1, r5
 946 00bb E7 A5 02                		mov.L	r5, 8[r10]
 947                             	.L70:
 604:../src/wolfcrypt/src/random.c ****             carry += (word16)d[dIdx];
 948                             		.loc 2 604 9 discriminator 1
 949 00be ED A5 02                		mov.L	8[r10], r5
 950 00c1 61 05                   		cmp	#0, r5
 951 00c3 28 CF                   		bge	.L71
 952                             	.L72:
 953                             	.LBE2:
 608:../src/wolfcrypt/src/random.c ****         }
 609:../src/wolfcrypt/src/random.c ****     }
 610:../src/wolfcrypt/src/random.c **** }
 954                             		.loc 2 610 1
 955 00c5 03                      		nop
 956 00c6 3F AA 08                		rtsd	#32, r10-r10
 957                             	.LFE48:
 959                             		.section	.text.Hash_DRBG_Generate,"ax",@progbits
 961                             	_Hash_DRBG_Generate:
 962                             	.LFB49:
 611:../src/wolfcrypt/src/random.c **** 
 612:../src/wolfcrypt/src/random.c **** /* Returns: DRBG_SUCCESS, DRBG_NEED_RESEED, or DRBG_FAILURE */
 613:../src/wolfcrypt/src/random.c **** static int Hash_DRBG_Generate(DRBG_internal* drbg, byte* out, word32 outSz)
 614:../src/wolfcrypt/src/random.c **** {
 963                             		.loc 2 614 1
 964 0000 7E AA                   		push.l	r10
 965                             	.LCFI24:
 966 0002 72 0A 58 FF             		add	#-168, r0, r10
 967                             	.LCFI25:
 968 0006 EF A0                   		mov.L	r10, r0
 969 0008 E7 A1 27                		mov.L	r1, 156[r10]
 970 000b E7 A2 28                		mov.L	r2, 160[r10]
 971 000e E7 A3 29                		mov.L	r3, 164[r10]
 615:../src/wolfcrypt/src/random.c ****     int ret;
 616:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
 617:../src/wolfcrypt/src/random.c ****     wc_Sha256* sha = &drbg->sha256;
 618:../src/wolfcrypt/src/random.c **** #else
 619:../src/wolfcrypt/src/random.c ****     wc_Sha256 sha[1];
 620:../src/wolfcrypt/src/random.c **** #endif
 621:../src/wolfcrypt/src/random.c ****     byte type;
 622:../src/wolfcrypt/src/random.c ****     word32 reseedCtr;
 623:../src/wolfcrypt/src/random.c **** 
 624:../src/wolfcrypt/src/random.c ****     if (drbg == NULL) {
 972                             		.loc 2 624 8
 973 0011 ED A5 27                		mov.L	156[r10], r5
 974 0014 61 05                   		cmp	#0, r5
 975 0016 1E                      		bne	.L74
 625:../src/wolfcrypt/src/random.c ****         return DRBG_FAILURE;
 976                             		.loc 2 625 16
 977 0017 66 15                   		mov.L	#1, r5
 978 0019 38 12 01                		bra	.L82
 979                             	.L74:
 626:../src/wolfcrypt/src/random.c ****     }
 627:../src/wolfcrypt/src/random.c **** 
 628:../src/wolfcrypt/src/random.c ****     if (drbg->reseedCtr == RESEED_INTERVAL) {
 980                             		.loc 2 628 13
 981 001c ED A5 27                		mov.L	156[r10], r5
 982 001f EC 55                   		mov.L	[r5], r5
 983                             		.loc 2 628 8
 984 0021 77 05 40 42 0F          		cmp	#0xf4240, r5
 985 0026 1E                      		bne	.L76
 629:../src/wolfcrypt/src/random.c ****         return DRBG_NEED_RESEED;
 986                             		.loc 2 629 16
 987 0027 66 25                   		mov.L	#2, r5
 988 0029 38 02 01                		bra	.L82
 989                             	.L76:
 990                             	.LBB3:
 630:../src/wolfcrypt/src/random.c ****     } else {
 631:../src/wolfcrypt/src/random.c ****     #ifdef WC_ASYNC_ENABLE_SHA256
 632:../src/wolfcrypt/src/random.c ****         WC_DECLARE_VAR(digest, byte, WC_SHA256_DIGEST_SIZE, drbg->heap);
 633:../src/wolfcrypt/src/random.c ****         if (digest == NULL)
 634:../src/wolfcrypt/src/random.c ****             return MEMORY_E;
 635:../src/wolfcrypt/src/random.c ****     #else
 636:../src/wolfcrypt/src/random.c ****         byte digest[WC_SHA256_DIGEST_SIZE];
 637:../src/wolfcrypt/src/random.c ****     #endif
 638:../src/wolfcrypt/src/random.c ****         type = drbgGenerateH;
 991                             		.loc 2 638 14
 992 002c F9 A4 74 03             		mov.B	#3, 116[r10]
 639:../src/wolfcrypt/src/random.c ****         reseedCtr = drbg->reseedCtr;
 993                             		.loc 2 639 25
 994 0030 ED A5 27                		mov.L	156[r10], r5
 995 0033 EC 55                   		mov.L	[r5], r5
 996                             		.loc 2 639 19
 997 0035 E7 A5 1E                		mov.L	r5, 120[r10]
 640:../src/wolfcrypt/src/random.c **** 
 641:../src/wolfcrypt/src/random.c ****         ret = Hash_gen(drbg, out, outSz, drbg->V);
 998                             		.loc 2 641 46
 999 0038 ED A5 27                		mov.L	156[r10], r5
 1000 003b 62 85                   		add	#8, r5
 1001                             		.loc 2 641 15
 1002 003d EF 54                   		mov.L	r5, r4
 1003 003f ED A3 29                		mov.L	164[r10], r3
 1004 0042 ED A2 28                		mov.L	160[r10], r2
 1005 0045 ED A1 27                		mov.L	156[r10], r1
 1006 0048 05 00 00 00             		bsr	_Hash_gen
 1007 004c E3 A1                   		mov.L	r1, [r10]
 642:../src/wolfcrypt/src/random.c ****         if (ret == DRBG_SUCCESS) {
 1008                             		.loc 2 642 12
 1009 004e EC A5                   		mov.L	[r10], r5
 1010 0050 61 05                   		cmp	#0, r5
 1011 0052 3B C4 00                		bne	.L77
 643:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 644:../src/wolfcrypt/src/random.c ****         #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
 645:../src/wolfcrypt/src/random.c ****             ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
 646:../src/wolfcrypt/src/random.c ****         #else
 647:../src/wolfcrypt/src/random.c ****             ret = wc_InitSha256(sha);
 1012                             		.loc 2 647 19
 1013 0055 71 A5 04                		add	#4, r10, r5
 1014 0058 EF 51                   		mov.L	r5, r1
 1015 005a 05 00 00 00             		bsr	_wc_InitSha256
 1016 005e E3 A1                   		mov.L	r1, [r10]
 648:../src/wolfcrypt/src/random.c ****         #endif
 649:../src/wolfcrypt/src/random.c ****             if (ret == 0)
 1017                             		.loc 2 649 16
 1018 0060 EC A5                   		mov.L	[r10], r5
 1019 0062 61 05                   		cmp	#0, r5
 1020 0064 21 14                   		bne	.L78
 650:../src/wolfcrypt/src/random.c **** #endif
 651:../src/wolfcrypt/src/random.c ****                 ret = wc_Sha256Update(sha, &type, sizeof(type));
 1021                             		.loc 2 651 23
 1022 0066 71 A4 74                		add	#0x74, r10, r4
 1023 0069 71 A5 04                		add	#4, r10, r5
 1024 006c 66 13                   		mov.L	#1, r3
 1025 006e EF 42                   		mov.L	r4, r2
 1026 0070 EF 51                   		mov.L	r5, r1
 1027 0072 05 00 00 00             		bsr	_wc_Sha256Update
 1028 0076 E3 A1                   		mov.L	r1, [r10]
 1029                             	.L78:
 652:../src/wolfcrypt/src/random.c ****             if (ret == 0)
 1030                             		.loc 2 652 16
 1031 0078 EC A5                   		mov.L	[r10], r5
 1032 007a 61 05                   		cmp	#0, r5
 1033 007c 21 18                   		bne	.L79
 653:../src/wolfcrypt/src/random.c ****                 ret = wc_Sha256Update(sha, drbg->V, sizeof(drbg->V));
 1034                             		.loc 2 653 48
 1035 007e ED A5 27                		mov.L	156[r10], r5
 1036 0081 71 54 08                		add	#8, r5, r4
 1037                             		.loc 2 653 23
 1038 0084 71 A5 04                		add	#4, r10, r5
 1039 0087 75 43 37                		mov.L	#55, r3
 1040 008a EF 42                   		mov.L	r4, r2
 1041 008c EF 51                   		mov.L	r5, r1
 1042 008e 05 00 00 00             		bsr	_wc_Sha256Update
 1043 0092 E3 A1                   		mov.L	r1, [r10]
 1044                             	.L79:
 654:../src/wolfcrypt/src/random.c ****             if (ret == 0)
 1045                             		.loc 2 654 16
 1046 0094 EC A5                   		mov.L	[r10], r5
 1047 0096 61 05                   		cmp	#0, r5
 1048 0098 21 12                   		bne	.L80
 655:../src/wolfcrypt/src/random.c ****                 ret = wc_Sha256Final(sha, digest);
 1049                             		.loc 2 655 23
 1050 009a 71 A4 7C                		add	#0x7c, r10, r4
 1051 009d 71 A5 04                		add	#4, r10, r5
 1052 00a0 EF 42                   		mov.L	r4, r2
 1053 00a2 EF 51                   		mov.L	r5, r1
 1054 00a4 05 00 00 00             		bsr	_wc_Sha256Final
 1055 00a8 E3 A1                   		mov.L	r1, [r10]
 1056                             	.L80:
 656:../src/wolfcrypt/src/random.c **** 
 657:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK_CACHE
 658:../src/wolfcrypt/src/random.c ****             wc_Sha256Free(sha);
 1057                             		.loc 2 658 13
 1058 00aa 71 A5 04                		add	#4, r10, r5
 1059 00ad EF 51                   		mov.L	r5, r1
 1060 00af 05 00 00 00             		bsr	_wc_Sha256Free
 659:../src/wolfcrypt/src/random.c **** #endif
 660:../src/wolfcrypt/src/random.c **** 
 661:../src/wolfcrypt/src/random.c ****             if (ret == 0) {
 1061                             		.loc 2 661 16
 1062 00b3 EC A5                   		mov.L	[r10], r5
 1063 00b5 61 05                   		cmp	#0, r5
 1064 00b7 21 52                   		bne	.L81
 662:../src/wolfcrypt/src/random.c ****                 array_add(drbg->V, sizeof(drbg->V), digest, WC_SHA256_DIGEST_SIZE);
 1065                             		.loc 2 662 31
 1066 00b9 ED A5 27                		mov.L	156[r10], r5
 1067 00bc 62 85                   		add	#8, r5
 1068                             		.loc 2 662 17
 1069 00be 71 A3 7C                		add	#0x7c, r10, r3
 1070 00c1 75 44 20                		mov.L	#32, r4
 1071 00c4 75 42 37                		mov.L	#55, r2
 1072 00c7 EF 51                   		mov.L	r5, r1
 1073 00c9 05 00 00 00             		bsr	_array_add
 663:../src/wolfcrypt/src/random.c ****                 array_add(drbg->V, sizeof(drbg->V), drbg->C, sizeof(drbg->C));
 1074                             		.loc 2 663 31
 1075 00cd ED A5 27                		mov.L	156[r10], r5
 1076 00d0 71 51 08                		add	#8, r5, r1
 1077                             		.loc 2 663 57
 1078 00d3 ED A5 27                		mov.L	156[r10], r5
 1079 00d6 71 55 3F                		add	#63, r5
 1080                             		.loc 2 663 17
 1081 00d9 75 44 37                		mov.L	#55, r4
 1082 00dc EF 53                   		mov.L	r5, r3
 1083 00de 75 42 37                		mov.L	#55, r2
 1084 00e1 05 00 00 00             		bsr	_array_add
 664:../src/wolfcrypt/src/random.c ****             #ifdef LITTLE_ENDIAN_ORDER
 665:../src/wolfcrypt/src/random.c ****                 reseedCtr = ByteReverseWord32(reseedCtr);
 1085                             		.loc 2 665 29
 1086 00e5 ED A5 1E                		mov.L	120[r10], r5
 1087 00e8 EF 51                   		mov.L	r5, r1
 1088 00ea 05 00 00 00             		bsr	_ByteReverseWord32
 1089 00ee EF 15                   		mov.L	r1, r5
 1090                             		.loc 2 665 27
 1091 00f0 E7 A5 1E                		mov.L	r5, 120[r10]
 666:../src/wolfcrypt/src/random.c ****             #endif
 667:../src/wolfcrypt/src/random.c ****                 array_add(drbg->V, sizeof(drbg->V),
 1092                             		.loc 2 667 31
 1093 00f3 ED A5 27                		mov.L	156[r10], r5
 1094 00f6 62 85                   		add	#8, r5
 1095                             		.loc 2 667 17
 1096 00f8 71 A3 78                		add	#0x78, r10, r3
 1097 00fb 66 44                   		mov.L	#4, r4
 1098 00fd 75 42 37                		mov.L	#55, r2
 1099 0100 EF 51                   		mov.L	r5, r1
 1100 0102 05 00 00 00             		bsr	_array_add
 668:../src/wolfcrypt/src/random.c ****                                           (byte*)&reseedCtr, sizeof(reseedCtr));
 669:../src/wolfcrypt/src/random.c ****                 ret = DRBG_SUCCESS;
 1101                             		.loc 2 669 21
 1102 0106 F8 A6 00                		mov.L	#0, [r10]
 1103                             	.L81:
 670:../src/wolfcrypt/src/random.c ****             }
 671:../src/wolfcrypt/src/random.c ****             drbg->reseedCtr++;
 1104                             		.loc 2 671 17
 1105 0109 ED A5 27                		mov.L	156[r10], r5
 1106 010c EC 55                   		mov.L	[r5], r5
 1107                             		.loc 2 671 28
 1108 010e 71 54 01                		add	#1, r5, r4
 1109 0111 ED A5 27                		mov.L	156[r10], r5
 1110 0114 E3 54                   		mov.L	r4, [r5]
 1111                             	.L77:
 672:../src/wolfcrypt/src/random.c ****         }
 673:../src/wolfcrypt/src/random.c ****         ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 1112                             		.loc 2 673 9
 1113 0116 71 A5 7C                		add	#0x7c, r10, r5
 1114 0119 75 42 20                		mov.L	#32, r2
 1115 011c EF 51                   		mov.L	r5, r1
 1116 011e 05 00 00 00             		bsr	_ForceZero
 1117                             	.LBE3:
 674:../src/wolfcrypt/src/random.c ****     #ifdef WC_ASYNC_ENABLE_SHA256
 675:../src/wolfcrypt/src/random.c ****         WC_FREE_VAR(digest, drbg->heap);
 676:../src/wolfcrypt/src/random.c ****     #endif
 677:../src/wolfcrypt/src/random.c ****     }
 678:../src/wolfcrypt/src/random.c **** 
 679:../src/wolfcrypt/src/random.c ****     return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 1118                             		.loc 2 679 38
 1119 0122 EC A5                   		mov.L	[r10], r5
 1120 0124 61 05                   		cmp	#0, r5
 1121 0126 FC DB 51                		scne.L	r5
 1122 0129 5B 55                   		movu.B	r5, r5
 1123                             	.L82:
 680:../src/wolfcrypt/src/random.c **** }
 1124                             		.loc 2 680 1 discriminator 1
 1125 012b EF 51                   		mov.L	r5, r1
 1126 012d 3F AA 2B                		rtsd	#172, r10-r10
 1127                             	.LFE49:
 1129                             		.section	.text.Hash_DRBG_Instantiate,"ax",@progbits
 1131                             	_Hash_DRBG_Instantiate:
 1132                             	.LFB50:
 681:../src/wolfcrypt/src/random.c **** 
 682:../src/wolfcrypt/src/random.c **** /* Returns: DRBG_SUCCESS or DRBG_FAILURE */
 683:../src/wolfcrypt/src/random.c **** static int Hash_DRBG_Instantiate(DRBG_internal* drbg, const byte* seed, word32 seedSz,
 684:../src/wolfcrypt/src/random.c ****                                              const byte* nonce, word32 nonceSz,
 685:../src/wolfcrypt/src/random.c ****                                              void* heap, int devId)
 686:../src/wolfcrypt/src/random.c **** {
 1133                             		.loc 2 686 1
 1134 0000 7E AA                   		push.l	r10
 1135                             	.LCFI26:
 1136 0002 7E A6                   		push.l	r6
 1137                             	.LCFI27:
 1138 0004 71 0A E0                		add	#-32, r0, r10
 1139                             	.LCFI28:
 1140 0007 71 A0 F0                		add	#-16, r10, r0
 1141                             	.LCFI29:
 1142 000a 75 46 2C                		mov.L	#44, r6
 1143 000d 4B A6                   		add	r10, r6
 1144 000f E7 A1 01                		mov.L	r1, 4[r10]
 1145 0012 E7 A2 02                		mov.L	r2, 8[r10]
 1146 0015 E7 A3 03                		mov.L	r3, 12[r10]
 1147 0018 E7 A4 04                		mov.L	r4, 16[r10]
 687:../src/wolfcrypt/src/random.c ****     int ret = DRBG_FAILURE;
 1148                             		.loc 2 687 9
 1149 001b F8 A6 01                		mov.L	#1, [r10]
 688:../src/wolfcrypt/src/random.c **** 
 689:../src/wolfcrypt/src/random.c ****     XMEMSET(drbg, 0, sizeof(DRBG_internal));
 1150                             		.loc 2 689 5
 1151 001e 75 43 78                		mov.L	#0x78, r3
 1152 0021 66 02                   		mov.L	#0, r2
 1153 0023 ED A1 01                		mov.L	4[r10], r1
 1154 0026 05 00 00 00             		bsr	_memset
 690:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
 691:../src/wolfcrypt/src/random.c ****     drbg->heap = heap;
 692:../src/wolfcrypt/src/random.c ****     drbg->devId = devId;
 693:../src/wolfcrypt/src/random.c **** #else
 694:../src/wolfcrypt/src/random.c ****     (void)heap;
 695:../src/wolfcrypt/src/random.c ****     (void)devId;
 696:../src/wolfcrypt/src/random.c **** #endif
 697:../src/wolfcrypt/src/random.c **** 
 698:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
 699:../src/wolfcrypt/src/random.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
 700:../src/wolfcrypt/src/random.c ****         ret = wc_InitSha256_ex(&drbg->sha256, drbg->heap, drbg->devId);
 701:../src/wolfcrypt/src/random.c ****     #else
 702:../src/wolfcrypt/src/random.c ****         ret = wc_InitSha256(&drbg->sha256);
 703:../src/wolfcrypt/src/random.c ****     #endif
 704:../src/wolfcrypt/src/random.c ****     if (ret != 0)
 705:../src/wolfcrypt/src/random.c ****         return ret;
 706:../src/wolfcrypt/src/random.c **** #endif
 707:../src/wolfcrypt/src/random.c **** 
 708:../src/wolfcrypt/src/random.c ****     if (Hash_df(drbg, drbg->V, sizeof(drbg->V), drbgInitV, seed, seedSz,
 1155                             		.loc 2 708 27
 1156 002a ED A5 01                		mov.L	4[r10], r5
 1157 002d 62 85                   		add	#8, r5
 1158                             		.loc 2 708 9
 1159 002f EC 64                   		mov.L	[r6], r4
 1160 0031 A0 8C                   		mov.L	r4, 12[r0]
 1161 0033 ED A4 04                		mov.L	16[r10], r4
 1162 0036 A0 84                   		mov.L	r4, 8[r0]
 1163 0038 ED A4 03                		mov.L	12[r10], r4
 1164 003b A0 0C                   		mov.L	r4, 4[r0]
 1165 003d ED A4 02                		mov.L	8[r10], r4
 1166 0040 E3 04                   		mov.L	r4, [r0]
 1167 0042 66 44                   		mov	#4, r4
 1168 0044 75 43 37                		mov.L	#55, r3
 1169 0047 EF 52                   		mov.L	r5, r2
 1170 0049 ED A1 01                		mov.L	4[r10], r1
 1171 004c 05 00 00 00             		bsr	_Hash_df
 1172 0050 EF 15                   		mov.L	r1, r5
 1173                             		.loc 2 708 8
 1174 0052 61 05                   		cmp	#0, r5
 1175 0054 21 40                   		bne	.L84
 709:../src/wolfcrypt/src/random.c ****                                               nonce, nonceSz) == DRBG_SUCCESS &&
 710:../src/wolfcrypt/src/random.c ****         Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 1176                             		.loc 2 710 27
 1177 0056 ED A5 01                		mov.L	4[r10], r5
 1178 0059 71 52 3F                		add	#63, r5, r2
 1179                             		.loc 2 710 64
 1180 005c ED A5 01                		mov.L	4[r10], r5
 1181 005f 62 85                   		add	#8, r5
 1182                             		.loc 2 710 9
 1183 0061 3E 03 00                		mov.L	#0, 12[r0]
 1184 0064 3E 02 00                		mov.L	#0, 8[r0]
 1185 0067 3E 01 37                		mov.L	#55, 4[r0]
 1186 006a E3 05                   		mov.L	r5, [r0]
 1187 006c 66 04                   		mov	#0, r4
 1188 006e 75 43 37                		mov.L	#55, r3
 1189 0071 ED A1 01                		mov.L	4[r10], r1
 1190 0074 05 00 00 00             		bsr	_Hash_df
 1191 0078 EF 15                   		mov.L	r1, r5
 709:../src/wolfcrypt/src/random.c ****                                               nonce, nonceSz) == DRBG_SUCCESS &&
 1192                             		.loc 2 709 79
 1193 007a 61 05                   		cmp	#0, r5
 1194 007c 21 18                   		bne	.L84
 711:../src/wolfcrypt/src/random.c ****                                     sizeof(drbg->V), NULL, 0) == DRBG_SUCCESS) {
 712:../src/wolfcrypt/src/random.c **** 
 713:../src/wolfcrypt/src/random.c ****         drbg->reseedCtr = 1;
 1195                             		.loc 2 713 25
 1196 007e ED A5 01                		mov.L	4[r10], r5
 1197 0081 F8 56 01                		mov.L	#1, [r5]
 714:../src/wolfcrypt/src/random.c ****         drbg->lastBlock = 0;
 1198                             		.loc 2 714 25
 1199 0084 ED A5 01                		mov.L	4[r10], r5
 1200 0087 3E 51 00                		mov.L	#0, 4[r5]
 715:../src/wolfcrypt/src/random.c ****         drbg->matchCount = 0;
 1201                             		.loc 2 715 26
 1202 008a ED A5 01                		mov.L	4[r10], r5
 1203 008d F9 54 76 00             		mov.B	#0, 118[r5]
 716:../src/wolfcrypt/src/random.c ****         ret = DRBG_SUCCESS;
 1204                             		.loc 2 716 13
 1205 0091 F8 A6 00                		mov.L	#0, [r10]
 1206                             	.L84:
 717:../src/wolfcrypt/src/random.c ****     }
 718:../src/wolfcrypt/src/random.c **** 
 719:../src/wolfcrypt/src/random.c ****     return ret;
 1207                             		.loc 2 719 12
 1208 0094 EC A5                   		mov.L	[r10], r5
 720:../src/wolfcrypt/src/random.c **** }
 1209                             		.loc 2 720 1
 1210 0096 EF 51                   		mov.L	r5, r1
 1211 0098 71 00 30                		add	#48, r0
 1212 009b 7E B6                   		pop	r6
 1213 009d 7E BA                   		pop	r10
 1214 009f 02                      		rts
 1215                             	.LFE50:
 1217                             		.section	.text.Hash_DRBG_Uninstantiate,"ax",@progbits
 1219                             	_Hash_DRBG_Uninstantiate:
 1220                             	.LFB51:
 721:../src/wolfcrypt/src/random.c **** 
 722:../src/wolfcrypt/src/random.c **** /* Returns: DRBG_SUCCESS or DRBG_FAILURE */
 723:../src/wolfcrypt/src/random.c **** static int Hash_DRBG_Uninstantiate(DRBG_internal* drbg)
 724:../src/wolfcrypt/src/random.c **** {
 1221                             		.loc 2 724 1
 1222 0000 7E AA                   		push.l	r10
 1223                             	.LCFI30:
 1224 0002 71 0A F0                		add	#-16, r0, r10
 1225                             	.LCFI31:
 1226 0005 EF A0                   		mov.L	r10, r0
 1227 0007 E7 A1 03                		mov.L	r1, 12[r10]
 725:../src/wolfcrypt/src/random.c ****     word32 i;
 726:../src/wolfcrypt/src/random.c ****     int    compareSum = 0;
 1228                             		.loc 2 726 12
 1229 000a F9 A6 01 00             		mov.L	#0, 4[r10]
 727:../src/wolfcrypt/src/random.c ****     byte*  compareDrbg = (byte*)drbg;
 1230                             		.loc 2 727 12
 1231 000e ED A5 03                		mov.L	12[r10], r5
 1232 0011 E7 A5 02                		mov.L	r5, 8[r10]
 728:../src/wolfcrypt/src/random.c **** 
 729:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
 730:../src/wolfcrypt/src/random.c ****     wc_Sha256Free(&drbg->sha256);
 731:../src/wolfcrypt/src/random.c **** #endif
 732:../src/wolfcrypt/src/random.c **** 
 733:../src/wolfcrypt/src/random.c ****     ForceZero(drbg, sizeof(DRBG_internal));
 1233                             		.loc 2 733 5
 1234 0014 75 42 78                		mov.L	#0x78, r2
 1235 0017 ED A1 03                		mov.L	12[r10], r1
 1236 001a 05 00 00 00             		bsr	_ForceZero
 734:../src/wolfcrypt/src/random.c **** 
 735:../src/wolfcrypt/src/random.c ****     for (i = 0; i < sizeof(DRBG_internal); i++)
 1237                             		.loc 2 735 12
 1238 001e F8 A6 00                		mov.L	#0, [r10]
 1239                             		.loc 2 735 5
 1240 0021 2E 1A                   		bra	.L87
 1241                             	.L88:
 736:../src/wolfcrypt/src/random.c ****         compareSum |= compareDrbg[i] ^ 0;
 1242                             		.loc 2 736 34 discriminator 3
 1243 0023 ED A5 02                		mov.L	8[r10], r5
 1244 0026 06 88 A5                		add	[r10].L, r5
 1245 0029 CC 55                   		mov.B	[r5], r5
 1246                             		.loc 2 736 38 discriminator 3
 1247 002b 5B 55                   		movu.B	r5, r5
 1248                             		.loc 2 736 20 discriminator 3
 1249 002d ED A4 01                		mov.L	4[r10], r4
 1250 0030 57 45                   		or	r4, r5
 1251 0032 E7 A5 01                		mov.L	r5, 4[r10]
 735:../src/wolfcrypt/src/random.c ****         compareSum |= compareDrbg[i] ^ 0;
 1252                             		.loc 2 735 45 discriminator 3
 1253 0035 EC A5                   		mov.L	[r10], r5
 1254 0037 62 15                   		add	#1, r5
 1255 0039 E3 A5                   		mov.L	r5, [r10]
 1256                             	.L87:
 735:../src/wolfcrypt/src/random.c ****         compareSum |= compareDrbg[i] ^ 0;
 1257                             		.loc 2 735 5 discriminator 1
 1258 003b EC A5                   		mov.L	[r10], r5
 1259 003d 75 55 77                		cmp	#0x77, r5
 1260 0040 25 E3                   		bleu	.L88
 737:../src/wolfcrypt/src/random.c **** 
 738:../src/wolfcrypt/src/random.c ****     return (compareSum == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 1261                             		.loc 2 738 45
 1262 0042 ED A5 01                		mov.L	4[r10], r5
 1263 0045 61 05                   		cmp	#0, r5
 1264 0047 FC DB 51                		scne.L	r5
 1265 004a 5B 55                   		movu.B	r5, r5
 739:../src/wolfcrypt/src/random.c **** }
 1266                             		.loc 2 739 1
 1267 004c EF 51                   		mov.L	r5, r1
 1268 004e 3F AA 05                		rtsd	#20, r10-r10
 1269                             	.LFE51:
 1271                             		.section	.text.wc_RNG_TestSeed,"ax",@progbits
 1272                             		.global	_wc_RNG_TestSeed
 1274                             	_wc_RNG_TestSeed:
 1275                             	.LFB52:
 740:../src/wolfcrypt/src/random.c **** 
 741:../src/wolfcrypt/src/random.c **** 
 742:../src/wolfcrypt/src/random.c **** int wc_RNG_TestSeed(const byte* seed, word32 seedSz)
 743:../src/wolfcrypt/src/random.c **** {
 1276                             		.loc 2 743 1
 1277 0000 7E AA                   		push.l	r10
 1278                             	.LCFI32:
 1279 0002 71 0A EC                		add	#-20, r0, r10
 1280                             	.LCFI33:
 1281 0005 EF A0                   		mov.L	r10, r0
 1282 0007 E7 A1 03                		mov.L	r1, 12[r10]
 1283 000a E7 A2 04                		mov.L	r2, 16[r10]
 744:../src/wolfcrypt/src/random.c ****     int ret = 0;
 1284                             		.loc 2 744 9
 1285 000d F8 A6 00                		mov.L	#0, [r10]
 745:../src/wolfcrypt/src/random.c **** 
 746:../src/wolfcrypt/src/random.c ****     /* Check the seed for duplicate words. */
 747:../src/wolfcrypt/src/random.c ****     word32 seedIdx = 0;
 1286                             		.loc 2 747 12
 1287 0010 F9 A6 01 00             		mov.L	#0, 4[r10]
 748:../src/wolfcrypt/src/random.c ****     word32 scratchSz = min(SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ);
 1288                             		.loc 2 748 24
 1289 0014 ED A5 04                		mov.L	16[r10], r5
 1290 0017 60 45                   		sub	#4, r5
 1291 0019 EF 52                   		mov.L	r5, r2
 1292 001b 66 41                   		mov.L	#4, r1
 1293 001d 05 00 00 00             		bsr	_min
 1294 0021 E7 A1 02                		mov.L	r1, 8[r10]
 749:../src/wolfcrypt/src/random.c **** 
 750:../src/wolfcrypt/src/random.c ****     while (seedIdx < seedSz - SEED_BLOCK_SZ) {
 1295                             		.loc 2 750 11
 1296 0024 2E 46                   		bra	.L91
 1297                             	.L93:
 751:../src/wolfcrypt/src/random.c ****         if (ConstantCompare(seed + seedIdx,
 1298                             		.loc 2 751 13
 1299 0026 ED A5 03                		mov.L	12[r10], r5
 1300 0029 EF 51                   		mov.L	r5, r1
 1301 002b 06 89 A1 01             		add	4[r10].L, r1
 752:../src/wolfcrypt/src/random.c ****                             seed + seedIdx + scratchSz,
 1302                             		.loc 2 752 44
 1303 002f ED A5 01                		mov.L	4[r10], r5
 1304 0032 06 89 A5 02             		add	8[r10].L, r5
 751:../src/wolfcrypt/src/random.c ****         if (ConstantCompare(seed + seedIdx,
 1305                             		.loc 2 751 13
 1306 0036 ED A4 03                		mov.L	12[r10], r4
 1307 0039 4B 45                   		add	r4, r5
 1308 003b ED A4 02                		mov.L	8[r10], r4
 1309 003e EF 43                   		mov.L	r4, r3
 1310 0040 EF 52                   		mov.L	r5, r2
 1311 0042 05 00 00 00             		bsr	_ConstantCompare
 1312 0046 EF 15                   		mov.L	r1, r5
 751:../src/wolfcrypt/src/random.c ****         if (ConstantCompare(seed + seedIdx,
 1313                             		.loc 2 751 12
 1314 0048 61 05                   		cmp	#0, r5
 1315 004a 1C                      		bne	.L92
 753:../src/wolfcrypt/src/random.c ****                             scratchSz) == 0) {
 754:../src/wolfcrypt/src/random.c **** 
 755:../src/wolfcrypt/src/random.c ****             ret = DRBG_CONT_FAILURE;
 1316                             		.loc 2 755 17
 1317 004b F8 A6 03                		mov.L	#3, [r10]
 1318                             	.L92:
 756:../src/wolfcrypt/src/random.c ****         }
 757:../src/wolfcrypt/src/random.c ****         seedIdx += SEED_BLOCK_SZ;
 1319                             		.loc 2 757 17
 1320 004e ED A5 01                		mov.L	4[r10], r5
 1321 0051 62 45                   		add	#4, r5
 1322 0053 E7 A5 01                		mov.L	r5, 4[r10]
 758:../src/wolfcrypt/src/random.c ****         scratchSz = min(SEED_BLOCK_SZ, (seedSz - seedIdx));
 1323                             		.loc 2 758 21
 1324 0056 ED A4 04                		mov.L	16[r10], r4
 1325 0059 ED A5 01                		mov.L	4[r10], r5
 1326 005c FF 05 54                		sub	r5, r4, r5
 1327 005f EF 52                   		mov.L	r5, r2
 1328 0061 66 41                   		mov.L	#4, r1
 1329 0063 05 00 00 00             		bsr	_min
 1330 0067 E7 A1 02                		mov.L	r1, 8[r10]
 1331                             	.L91:
 750:../src/wolfcrypt/src/random.c ****         if (ConstantCompare(seed + seedIdx,
 1332                             		.loc 2 750 29
 1333 006a ED A5 04                		mov.L	16[r10], r5
 1334 006d 60 45                   		sub	#4, r5
 750:../src/wolfcrypt/src/random.c ****         if (ConstantCompare(seed + seedIdx,
 1335                             		.loc 2 750 11
 1336 006f ED A4 01                		mov.L	4[r10], r4
 1337 0072 47 54                   		cmp	r5, r4
 1338 0074 23 B2                   		bltu	.L93
 759:../src/wolfcrypt/src/random.c ****     }
 760:../src/wolfcrypt/src/random.c **** 
 761:../src/wolfcrypt/src/random.c ****     return ret;
 1339                             		.loc 2 761 12
 1340 0076 EC A5                   		mov.L	[r10], r5
 762:../src/wolfcrypt/src/random.c **** }
 1341                             		.loc 2 762 1
 1342 0078 EF 51                   		mov.L	r5, r1
 1343 007a 3F AA 06                		rtsd	#24, r10-r10
 1344                             	.LFE52:
 1346                             		.section	.text._InitRng,"ax",@progbits
 1348                             	__InitRng:
 1349                             	.LFB53:
 763:../src/wolfcrypt/src/random.c **** #endif /* HAVE_HASHDRBG */
 764:../src/wolfcrypt/src/random.c **** /* End NIST DRBG Code */
 765:../src/wolfcrypt/src/random.c **** 
 766:../src/wolfcrypt/src/random.c **** 
 767:../src/wolfcrypt/src/random.c **** static int _InitRng(WC_RNG* rng, byte* nonce, word32 nonceSz,
 768:../src/wolfcrypt/src/random.c ****                     void* heap, int devId)
 769:../src/wolfcrypt/src/random.c **** {
 1350                             		.loc 2 769 1
 1351 0000 7E AA                   		push.l	r10
 1352                             	.LCFI34:
 1353 0002 7E A6                   		push.l	r6
 1354                             	.LCFI35:
 1355 0004 71 0A AC                		add	#-84, r0, r10
 1356                             	.LCFI36:
 1357 0007 71 A0 F4                		add	#-12, r10, r0
 1358                             	.LCFI37:
 1359 000a 75 46 60                		mov.L	#0x60, r6
 1360 000d 4B A6                   		add	r10, r6
 1361 000f E7 A1 10                		mov.L	r1, 64[r10]
 1362 0012 E7 A2 11                		mov.L	r2, 68[r10]
 1363 0015 E7 A3 12                		mov.L	r3, 72[r10]
 1364 0018 E7 A4 13                		mov.L	r4, 76[r10]
 770:../src/wolfcrypt/src/random.c ****     int ret = 0;
 1365                             		.loc 2 770 9
 1366 001b F8 A6 00                		mov.L	#0, [r10]
 771:../src/wolfcrypt/src/random.c **** #ifdef HAVE_HASHDRBG
 772:../src/wolfcrypt/src/random.c ****     word32 seedSz = SEED_SZ + SEED_BLOCK_SZ;
 1367                             		.loc 2 772 12
 1368 001e F9 A6 01 24             		mov.L	#36, 4[r10]
 773:../src/wolfcrypt/src/random.c **** #endif
 774:../src/wolfcrypt/src/random.c **** 
 775:../src/wolfcrypt/src/random.c ****     (void)nonce;
 776:../src/wolfcrypt/src/random.c ****     (void)nonceSz;
 777:../src/wolfcrypt/src/random.c **** 
 778:../src/wolfcrypt/src/random.c ****     if (rng == NULL)
 1369                             		.loc 2 778 8
 1370 0022 ED A5 10                		mov.L	64[r10], r5
 1371 0025 61 05                   		cmp	#0, r5
 1372 0027 18                      		bne	.L96
 779:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
 1373                             		.loc 2 779 16
 1374 0028 FB 5A 53 FF             		mov.L	#-173, r5
 1375 002c 38 37 01                		bra	.L97
 1376                             	.L96:
 780:../src/wolfcrypt/src/random.c ****     if (nonce == NULL && nonceSz != 0)
 1377                             		.loc 2 780 8
 1378 002f ED A5 11                		mov.L	68[r10], r5
 1379 0032 61 05                   		cmp	#0, r5
 1380 0034 21 0F                   		bne	.L98
 1381                             		.loc 2 780 23 discriminator 1
 1382 0036 ED A5 12                		mov.L	72[r10], r5
 1383 0039 61 05                   		cmp	#0, r5
 1384 003b 10                      		beq	.L98
 781:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
 1385                             		.loc 2 781 16
 1386 003c FB 5A 53 FF             		mov.L	#-173, r5
 1387 0040 38 23 01                		bra	.L97
 1388                             	.L98:
 782:../src/wolfcrypt/src/random.c **** 
 783:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_HEAP_TEST
 784:../src/wolfcrypt/src/random.c ****     rng->heap = (void*)WOLFSSL_HEAP_TEST;
 785:../src/wolfcrypt/src/random.c ****     (void)heap;
 786:../src/wolfcrypt/src/random.c **** #else
 787:../src/wolfcrypt/src/random.c ****     rng->heap = heap;
 1389                             		.loc 2 787 15
 1390 0043 ED A5 10                		mov.L	64[r10], r5
 1391 0046 ED A4 13                		mov.L	76[r10], r4
 1392 0049 A0 5C                   		mov.L	r4, 4[r5]
 788:../src/wolfcrypt/src/random.c **** #endif
 789:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
 790:../src/wolfcrypt/src/random.c ****     rng->devId = devId;
 791:../src/wolfcrypt/src/random.c ****     #if defined(WOLF_CRYPTO_CB)
 792:../src/wolfcrypt/src/random.c ****         rng->seed.devId = devId;
 793:../src/wolfcrypt/src/random.c ****     #endif
 794:../src/wolfcrypt/src/random.c **** #else
 795:../src/wolfcrypt/src/random.c ****     (void)devId;
 796:../src/wolfcrypt/src/random.c **** #endif
 797:../src/wolfcrypt/src/random.c **** 
 798:../src/wolfcrypt/src/random.c **** #ifdef HAVE_HASHDRBG
 799:../src/wolfcrypt/src/random.c ****     /* init the DBRG to known values */
 800:../src/wolfcrypt/src/random.c ****     rng->drbg = NULL;
 1393                             		.loc 2 800 15
 1394 004b ED A5 10                		mov.L	64[r10], r5
 1395 004e 3E 52 00                		mov.L	#0, 8[r5]
 801:../src/wolfcrypt/src/random.c ****     rng->status = DRBG_NOT_INIT;
 1396                             		.loc 2 801 17
 1397 0051 ED A5 10                		mov.L	64[r10], r5
 1398 0054 3C 5C 00                		mov.B	#0, 12[r5]
 802:../src/wolfcrypt/src/random.c **** #endif
 803:../src/wolfcrypt/src/random.c **** 
 804:../src/wolfcrypt/src/random.c **** #if defined(HAVE_INTEL_RDSEED) || defined(HAVE_INTEL_RDRAND) || \
 805:../src/wolfcrypt/src/random.c ****     defined(HAVE_AMD_RDSEED)
 806:../src/wolfcrypt/src/random.c ****     /* init the intel RD seed and/or rand */
 807:../src/wolfcrypt/src/random.c ****     wc_InitRng_IntelRD();
 808:../src/wolfcrypt/src/random.c **** #endif
 809:../src/wolfcrypt/src/random.c **** 
 810:../src/wolfcrypt/src/random.c ****     /* configure async RNG source if available */
 811:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_ASYNC_CRYPT
 812:../src/wolfcrypt/src/random.c ****     ret = wolfAsync_DevCtxInit(&rng->asyncDev, WOLFSSL_ASYNC_MARKER_RNG,
 813:../src/wolfcrypt/src/random.c ****                                                         rng->heap, rng->devId);
 814:../src/wolfcrypt/src/random.c ****     if (ret != 0)
 815:../src/wolfcrypt/src/random.c ****         return ret;
 816:../src/wolfcrypt/src/random.c **** #endif
 817:../src/wolfcrypt/src/random.c **** 
 818:../src/wolfcrypt/src/random.c **** #ifdef HAVE_INTEL_RDRAND
 819:../src/wolfcrypt/src/random.c ****     /* if CPU supports RDRAND, use it directly and by-pass DRBG init */
 820:../src/wolfcrypt/src/random.c ****     if (IS_INTEL_RDRAND(intel_flags))
 821:../src/wolfcrypt/src/random.c ****         return 0;
 822:../src/wolfcrypt/src/random.c **** #endif
 823:../src/wolfcrypt/src/random.c **** 
 824:../src/wolfcrypt/src/random.c **** #ifdef CUSTOM_RAND_GENERATE_BLOCK
 825:../src/wolfcrypt/src/random.c ****     ret = 0; /* success */
 826:../src/wolfcrypt/src/random.c **** #else
 827:../src/wolfcrypt/src/random.c **** #ifdef HAVE_HASHDRBG
 828:../src/wolfcrypt/src/random.c ****     if (nonceSz == 0)
 1399                             		.loc 2 828 8
 1400 0057 ED A5 12                		mov.L	72[r10], r5
 1401 005a 61 05                   		cmp	#0, r5
 1402 005c 1D                      		bne	.L99
 829:../src/wolfcrypt/src/random.c ****         seedSz = MAX_SEED_SZ;
 1403                             		.loc 2 829 16
 1404 005d F9 A6 01 34             		mov.L	#52, 4[r10]
 1405                             	.L99:
 830:../src/wolfcrypt/src/random.c **** 
 831:../src/wolfcrypt/src/random.c ****     if (wc_RNG_HealthTestLocal(0) == 0) {
 1406                             		.loc 2 831 9
 1407 0061 66 01                   		mov.L	#0, r1
 1408 0063 05 00 00 00             		bsr	_wc_RNG_HealthTestLocal
 1409 0067 EF 15                   		mov.L	r1, r5
 1410                             		.loc 2 831 8
 1411 0069 61 05                   		cmp	#0, r5
 1412 006b 3B B9 00                		bne	.L100
 1413                             	.LBB4:
 832:../src/wolfcrypt/src/random.c ****     #ifdef WC_ASYNC_ENABLE_SHA256
 833:../src/wolfcrypt/src/random.c ****         WC_DECLARE_VAR(seed, byte, MAX_SEED_SZ, rng->heap);
 834:../src/wolfcrypt/src/random.c ****         if (seed == NULL)
 835:../src/wolfcrypt/src/random.c ****             return MEMORY_E;
 836:../src/wolfcrypt/src/random.c ****     #else
 837:../src/wolfcrypt/src/random.c ****         byte seed[MAX_SEED_SZ];
 838:../src/wolfcrypt/src/random.c ****     #endif
 839:../src/wolfcrypt/src/random.c **** 
 840:../src/wolfcrypt/src/random.c **** #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
 841:../src/wolfcrypt/src/random.c ****         rng->drbg =
 842:../src/wolfcrypt/src/random.c ****                 (struct DRBG*)XMALLOC(sizeof(DRBG_internal), rng->heap,
 1414                             		.loc 2 842 31
 1415 006e 75 41 78                		mov.L	#0x78, r1
 1416 0071 05 00 00 00             		bsr	_wolfSSL_Malloc
 1417 0075 EF 14                   		mov.L	r1, r4
 841:../src/wolfcrypt/src/random.c ****                 (struct DRBG*)XMALLOC(sizeof(DRBG_internal), rng->heap,
 1418                             		.loc 2 841 19
 1419 0077 ED A5 10                		mov.L	64[r10], r5
 1420 007a A0 D4                   		mov.L	r4, 8[r5]
 843:../src/wolfcrypt/src/random.c ****                                                           DYNAMIC_TYPE_RNG);
 844:../src/wolfcrypt/src/random.c ****         if (rng->drbg == NULL) {
 1421                             		.loc 2 844 16
 1422 007c ED A5 10                		mov.L	64[r10], r5
 1423 007f A8 D5                   		mov.L	8[r5], r5
 1424                             		.loc 2 844 12
 1425 0081 61 05                   		cmp	#0, r5
 1426 0083 1A                      		bne	.L101
 845:../src/wolfcrypt/src/random.c ****             ret = MEMORY_E;
 1427                             		.loc 2 845 17
 1428 0084 F8 A6 83                		mov.L	#-125, [r10]
 846:../src/wolfcrypt/src/random.c ****             rng->status = DRBG_FAILED;
 1429                             		.loc 2 846 25
 1430 0087 ED A5 10                		mov.L	64[r10], r5
 1431 008a 3C 5C 02                		mov.B	#2, 12[r5]
 1432                             	.L101:
 847:../src/wolfcrypt/src/random.c ****         }
 848:../src/wolfcrypt/src/random.c **** #else
 849:../src/wolfcrypt/src/random.c ****         rng->drbg = (struct DRBG*)&rng->drbg_data;
 850:../src/wolfcrypt/src/random.c **** #endif
 851:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
 1433                             		.loc 2 851 12
 1434 008d EC A5                   		mov.L	[r10], r5
 1435 008f 61 05                   		cmp	#0, r5
 1436 0091 3B 86 00                		bne	.L102
 852:../src/wolfcrypt/src/random.c **** #ifdef WC_RNG_SEED_CB
 853:../src/wolfcrypt/src/random.c ****             if (seedCb == NULL) {
 854:../src/wolfcrypt/src/random.c ****                 ret = DRBG_NO_SEED_CB;
 855:../src/wolfcrypt/src/random.c ****             }
 856:../src/wolfcrypt/src/random.c ****             else {
 857:../src/wolfcrypt/src/random.c ****                 ret = seedCb(&rng->seed, seed, seedSz);
 858:../src/wolfcrypt/src/random.c ****                 if (ret != 0) {
 859:../src/wolfcrypt/src/random.c ****                     ret = DRBG_FAILURE;
 860:../src/wolfcrypt/src/random.c ****                 }
 861:../src/wolfcrypt/src/random.c ****             }
 862:../src/wolfcrypt/src/random.c **** #else
 863:../src/wolfcrypt/src/random.c ****             ret = wc_GenerateSeed(&rng->seed, seed, seedSz);
 1437                             		.loc 2 863 35
 1438 0094 ED A4 10                		mov.L	64[r10], r4
 1439                             		.loc 2 863 19
 1440 0097 71 A5 0C                		add	#12, r10, r5
 1441 009a ED A3 01                		mov.L	4[r10], r3
 1442 009d EF 52                   		mov.L	r5, r2
 1443 009f EF 41                   		mov.L	r4, r1
 1444 00a1 05 00 00 00             		bsr	_wc_GenerateSeed
 1445 00a5 E3 A1                   		mov.L	r1, [r10]
 864:../src/wolfcrypt/src/random.c **** #endif
 865:../src/wolfcrypt/src/random.c ****             if (ret == 0)
 1446                             		.loc 2 865 16
 1447 00a7 EC A5                   		mov.L	[r10], r5
 1448 00a9 61 05                   		cmp	#0, r5
 1449 00ab 21 11                   		bne	.L103
 866:../src/wolfcrypt/src/random.c ****                 ret = wc_RNG_TestSeed(seed, seedSz);
 1450                             		.loc 2 866 23
 1451 00ad 71 A5 0C                		add	#12, r10, r5
 1452 00b0 ED A2 01                		mov.L	4[r10], r2
 1453 00b3 EF 51                   		mov.L	r5, r1
 1454 00b5 05 00 00 00             		bsr	_wc_RNG_TestSeed
 1455 00b9 E3 A1                   		mov.L	r1, [r10]
 1456 00bb 0A                      		bra	.L104
 1457                             	.L103:
 867:../src/wolfcrypt/src/random.c ****             else {
 868:../src/wolfcrypt/src/random.c ****                 ret = DRBG_FAILURE;
 1458                             		.loc 2 868 21
 1459 00bc F8 A6 01                		mov.L	#1, [r10]
 869:../src/wolfcrypt/src/random.c ****                 rng->status = DRBG_FAILED;
 1460                             		.loc 2 869 29
 1461 00bf ED A5 10                		mov.L	64[r10], r5
 1462 00c2 3C 5C 02                		mov.B	#2, 12[r5]
 1463                             	.L104:
 870:../src/wolfcrypt/src/random.c ****             }
 871:../src/wolfcrypt/src/random.c **** 
 872:../src/wolfcrypt/src/random.c ****             if (ret == DRBG_SUCCESS)
 1464                             		.loc 2 872 16
 1465 00c5 EC A5                   		mov.L	[r10], r5
 1466 00c7 61 05                   		cmp	#0, r5
 1467 00c9 21 2D                   		bne	.L105
 873:../src/wolfcrypt/src/random.c ****                 ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
 1468                             		.loc 2 873 65
 1469 00cb ED A5 10                		mov.L	64[r10], r5
 1470 00ce A8 D1                   		mov.L	8[r5], r1
 1471                             		.loc 2 873 23
 1472 00d0 71 A5 0C                		add	#12, r10, r5
 1473 00d3 62 45                   		add	#4, r5
 1474 00d5 ED A4 01                		mov.L	4[r10], r4
 1475 00d8 71 43 FC                		add	#-4, r4, r3
 1476 00db ED A4 10                		mov.L	64[r10], r4
 1477 00de A8 4C                   		mov.L	4[r4], r4
 1478 00e0 EC 62                   		mov.L	[r6], r2
 1479 00e2 A0 82                   		mov.L	r2, 8[r0]
 1480 00e4 A0 0C                   		mov.L	r4, 4[r0]
 1481 00e6 ED A4 12                		mov.L	72[r10], r4
 1482 00e9 E3 04                   		mov.L	r4, [r0]
 1483 00eb ED A4 11                		mov.L	68[r10], r4
 1484 00ee EF 52                   		mov.L	r5, r2
 1485 00f0 05 00 00 00             		bsr	_Hash_DRBG_Instantiate
 1486 00f4 E3 A1                   		mov.L	r1, [r10]
 1487                             	.L105:
 874:../src/wolfcrypt/src/random.c ****                             seed + SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ,
 875:../src/wolfcrypt/src/random.c ****                             nonce, nonceSz, rng->heap, devId);
 876:../src/wolfcrypt/src/random.c **** 
 877:../src/wolfcrypt/src/random.c ****             if (ret != DRBG_SUCCESS) {
 1488                             		.loc 2 877 16
 1489 00f6 EC A5                   		mov.L	[r10], r5
 1490 00f8 61 05                   		cmp	#0, r5
 1491 00fa 20 1D                   		beq	.L102
 1492                             	.LBB5:
 878:../src/wolfcrypt/src/random.c ****             #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
 879:../src/wolfcrypt/src/random.c ****                 XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 1493                             		.loc 2 879 17
 1494 00fc ED A5 10                		mov.L	64[r10], r5
 1495 00ff A8 D5                   		mov.L	8[r5], r5
 1496 0101 E7 A5 02                		mov.L	r5, 8[r10]
 1497 0104 ED A5 02                		mov.L	8[r10], r5
 1498 0107 61 05                   		cmp	#0, r5
 1499 0109 10                      		beq	.L106
 1500                             		.loc 2 879 17 is_stmt 0 discriminator 1
 1501 010a ED A1 02                		mov.L	8[r10], r1
 1502 010d 05 00 00 00             		bsr	_wolfSSL_Free
 1503                             	.L106:
 1504                             	.LBE5:
 880:../src/wolfcrypt/src/random.c ****             #endif
 881:../src/wolfcrypt/src/random.c ****                 rng->drbg = NULL;
 1505                             		.loc 2 881 27 is_stmt 1
 1506 0111 ED A5 10                		mov.L	64[r10], r5
 1507 0114 3E 52 00                		mov.L	#0, 8[r5]
 1508                             	.L102:
 882:../src/wolfcrypt/src/random.c ****             }
 883:../src/wolfcrypt/src/random.c ****         }
 884:../src/wolfcrypt/src/random.c **** 
 885:../src/wolfcrypt/src/random.c ****         ForceZero(seed, seedSz);
 1509                             		.loc 2 885 9
 1510 0117 71 A5 0C                		add	#12, r10, r5
 1511 011a ED A2 01                		mov.L	4[r10], r2
 1512 011d EF 51                   		mov.L	r5, r1
 1513 011f 05 00 00 00             		bsr	_ForceZero
 1514                             	.LBE4:
 1515 0123 0C                      		bra	.L107
 1516                             	.L100:
 886:../src/wolfcrypt/src/random.c ****     #ifdef WC_ASYNC_ENABLE_SHA256
 887:../src/wolfcrypt/src/random.c ****         WC_FREE_VAR(seed, rng->heap);
 888:../src/wolfcrypt/src/random.c ****     #endif
 889:../src/wolfcrypt/src/random.c ****     }
 890:../src/wolfcrypt/src/random.c ****     else
 891:../src/wolfcrypt/src/random.c ****         ret = DRBG_CONT_FAILURE;
 1517                             		.loc 2 891 13
 1518 0124 F8 A6 03                		mov.L	#3, [r10]
 1519                             	.L107:
 892:../src/wolfcrypt/src/random.c **** 
 893:../src/wolfcrypt/src/random.c ****     if (ret == DRBG_SUCCESS) {
 1520                             		.loc 2 893 8
 1521 0127 EC A5                   		mov.L	[r10], r5
 1522 0129 61 05                   		cmp	#0, r5
 1523 012b 21 0D                   		bne	.L108
 894:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
 895:../src/wolfcrypt/src/random.c **** #ifdef HAVE_HASHDRBG
 896:../src/wolfcrypt/src/random.c ****         struct DRBG_internal* drbg = (struct DRBG_internal*)rng->drbg;
 897:../src/wolfcrypt/src/random.c ****         wc_MemZero_Add("DRBG V", &drbg->V, sizeof(drbg->V));
 898:../src/wolfcrypt/src/random.c ****         wc_MemZero_Add("DRBG C", &drbg->C, sizeof(drbg->C));
 899:../src/wolfcrypt/src/random.c **** #endif
 900:../src/wolfcrypt/src/random.c **** #endif
 901:../src/wolfcrypt/src/random.c **** 
 902:../src/wolfcrypt/src/random.c ****         rng->status = DRBG_OK;
 1524                             		.loc 2 902 21
 1525 012d ED A5 10                		mov.L	64[r10], r5
 1526 0130 3C 5C 01                		mov.B	#1, 12[r5]
 903:../src/wolfcrypt/src/random.c ****         ret = 0;
 1527                             		.loc 2 903 13
 1528 0133 F8 A6 00                		mov.L	#0, [r10]
 1529 0136 2E 2B                   		bra	.L109
 1530                             	.L108:
 904:../src/wolfcrypt/src/random.c ****     }
 905:../src/wolfcrypt/src/random.c ****     else if (ret == DRBG_CONT_FAILURE) {
 1531                             		.loc 2 905 13
 1532 0138 EC A5                   		mov.L	[r10], r5
 1533 013a 61 35                   		cmp	#3, r5
 1534 013c 21 0E                   		bne	.L110
 906:../src/wolfcrypt/src/random.c ****         rng->status = DRBG_CONT_FAILED;
 1535                             		.loc 2 906 21
 1536 013e ED A5 10                		mov.L	64[r10], r5
 1537 0141 3C 5C 03                		mov.B	#3, 12[r5]
 907:../src/wolfcrypt/src/random.c ****         ret = DRBG_CONT_FIPS_E;
 1538                             		.loc 2 907 13
 1539 0144 F8 AA 2F FF             		mov.L	#-209, [r10]
 1540 0148 2E 19                   		bra	.L109
 1541                             	.L110:
 908:../src/wolfcrypt/src/random.c ****     }
 909:../src/wolfcrypt/src/random.c ****     else if (ret == DRBG_FAILURE) {
 1542                             		.loc 2 909 13
 1543 014a EC A5                   		mov.L	[r10], r5
 1544 014c 61 15                   		cmp	#1, r5
 1545 014e 21 0D                   		bne	.L111
 910:../src/wolfcrypt/src/random.c ****         rng->status = DRBG_FAILED;
 1546                             		.loc 2 910 21
 1547 0150 ED A5 10                		mov.L	64[r10], r5
 1548 0153 3C 5C 02                		mov.B	#2, 12[r5]
 911:../src/wolfcrypt/src/random.c ****         ret = RNG_FAILURE_E;
 1549                             		.loc 2 911 13
 1550 0156 F8 AA 39 FF             		mov.L	#-199, [r10]
 1551 015a 0F                      		bra	.L109
 1552                             	.L111:
 912:../src/wolfcrypt/src/random.c ****     }
 913:../src/wolfcrypt/src/random.c ****     else {
 914:../src/wolfcrypt/src/random.c ****         rng->status = DRBG_FAILED;
 1553                             		.loc 2 914 21
 1554 015b ED A5 10                		mov.L	64[r10], r5
 1555 015e 3C 5C 02                		mov.B	#2, 12[r5]
 1556                             		.balign 8,3,1
 1557                             	.L109:
 915:../src/wolfcrypt/src/random.c ****     }
 916:../src/wolfcrypt/src/random.c **** #endif /* HAVE_HASHDRBG */
 917:../src/wolfcrypt/src/random.c **** #endif /* CUSTOM_RAND_GENERATE_BLOCK */
 918:../src/wolfcrypt/src/random.c **** 
 919:../src/wolfcrypt/src/random.c ****     return ret;
 1558                             		.loc 2 919 12
 1559 0161 EC A5                   		mov.L	[r10], r5
 1560                             	.L97:
 920:../src/wolfcrypt/src/random.c **** }
 1561                             		.loc 2 920 1
 1562 0163 EF 51                   		mov.L	r5, r1
 1563 0165 71 00 60                		add	#0x60, r0
 1564 0168 7E B6                   		pop	r6
 1565 016a 7E BA                   		pop	r10
 1566 016c 02                      		rts
 1567                             	.LFE53:
 1569 016d FC 13 00                		.section	.text.wc_rng_new,"ax",@progbits
 1570                             		.global	_wc_rng_new
 1572                             	_wc_rng_new:
 1573                             	.LFB54:
 921:../src/wolfcrypt/src/random.c **** 
 922:../src/wolfcrypt/src/random.c **** 
 923:../src/wolfcrypt/src/random.c **** WOLFSSL_ABI
 924:../src/wolfcrypt/src/random.c **** WC_RNG* wc_rng_new(byte* nonce, word32 nonceSz, void* heap)
 925:../src/wolfcrypt/src/random.c **** {
 1574                             		.loc 2 925 1
 1575 0000 7E AA                   		push.l	r10
 1576                             	.LCFI38:
 1577 0002 71 0A E8                		add	#-24, r0, r10
 1578                             	.LCFI39:
 1579 0005 71 A0 FC                		add	#-4, r10, r0
 1580                             	.LCFI40:
 1581 0008 E7 A1 03                		mov.L	r1, 12[r10]
 1582 000b E7 A2 04                		mov.L	r2, 16[r10]
 1583 000e E7 A3 05                		mov.L	r3, 20[r10]
 926:../src/wolfcrypt/src/random.c ****     WC_RNG* rng;
 927:../src/wolfcrypt/src/random.c **** 
 928:../src/wolfcrypt/src/random.c ****     rng = (WC_RNG*)XMALLOC(sizeof(WC_RNG), heap, DYNAMIC_TYPE_RNG);
 1584                             		.loc 2 928 20
 1585 0011 75 41 10                		mov.L	#16, r1
 1586 0014 05 00 00 00             		bsr	_wolfSSL_Malloc
 1587 0018 E3 A1                   		mov.L	r1, [r10]
 929:../src/wolfcrypt/src/random.c ****     if (rng) {
 1588                             		.loc 2 929 8
 1589 001a EC A5                   		mov.L	[r10], r5
 1590 001c 61 05                   		cmp	#0, r5
 1591 001e 20 3C                   		beq	.L113
 1592                             	.LBB6:
 930:../src/wolfcrypt/src/random.c ****         int error = _InitRng(rng, nonce, nonceSz, heap, INVALID_DEVID) != 0;
 1593                             		.loc 2 930 21
 1594 0020 F8 06 FE                		mov.L	#-2, [r0]
 1595 0023 ED A4 05                		mov.L	20[r10], r4
 1596 0026 ED A3 04                		mov.L	16[r10], r3
 1597 0029 ED A2 03                		mov.L	12[r10], r2
 1598 002c EC A1                   		mov.L	[r10], r1
 1599 002e 05 00 00 00             		bsr	__InitRng
 1600 0032 EF 15                   		mov.L	r1, r5
 1601                             		.loc 2 930 72
 1602 0034 61 05                   		cmp	#0, r5
 1603 0036 FC DB 51                		scne.L	r5
 1604                             		.loc 2 930 13
 1605 0039 5B 55                   		movu.B	r5, r5
 1606 003b E7 A5 01                		mov.L	r5, 4[r10]
 931:../src/wolfcrypt/src/random.c ****         if (error) {
 1607                             		.loc 2 931 12
 1608 003e ED A5 01                		mov.L	4[r10], r5
 1609 0041 61 05                   		cmp	#0, r5
 1610 0043 20 17                   		beq	.L113
 1611                             	.LBB7:
 932:../src/wolfcrypt/src/random.c ****             XFREE(rng, heap, DYNAMIC_TYPE_RNG);
 1612                             		.loc 2 932 13
 1613 0045 EC A5                   		mov.L	[r10], r5
 1614 0047 E7 A5 02                		mov.L	r5, 8[r10]
 1615 004a ED A5 02                		mov.L	8[r10], r5
 1616 004d 61 05                   		cmp	#0, r5
 1617 004f 10                      		beq	.L114
 1618                             		.loc 2 932 13 is_stmt 0 discriminator 1
 1619 0050 ED A1 02                		mov.L	8[r10], r1
 1620 0053 05 00 00 00             		bsr	_wolfSSL_Free
 1621                             	.L114:
 1622                             	.LBE7:
 933:../src/wolfcrypt/src/random.c ****             rng = NULL;
 1623                             		.loc 2 933 17 is_stmt 1
 1624 0057 F8 A6 00                		mov.L	#0, [r10]
 1625                             	.L113:
 1626                             	.LBE6:
 934:../src/wolfcrypt/src/random.c ****         }
 935:../src/wolfcrypt/src/random.c ****     }
 936:../src/wolfcrypt/src/random.c **** 
 937:../src/wolfcrypt/src/random.c ****     return rng;
 1627                             		.loc 2 937 12
 1628 005a EC A5                   		mov.L	[r10], r5
 938:../src/wolfcrypt/src/random.c **** }
 1629                             		.loc 2 938 1
 1630 005c EF 51                   		mov.L	r5, r1
 1631 005e 3F AA 08                		rtsd	#32, r10-r10
 1632                             	.LFE54:
 1634                             		.section	.text.wc_rng_free,"ax",@progbits
 1635                             		.global	_wc_rng_free
 1637                             	_wc_rng_free:
 1638                             	.LFB55:
 939:../src/wolfcrypt/src/random.c **** 
 940:../src/wolfcrypt/src/random.c **** 
 941:../src/wolfcrypt/src/random.c **** WOLFSSL_ABI
 942:../src/wolfcrypt/src/random.c **** void wc_rng_free(WC_RNG* rng)
 943:../src/wolfcrypt/src/random.c **** {
 1639                             		.loc 2 943 1
 1640 0000 7E AA                   		push.l	r10
 1641                             	.LCFI41:
 1642 0002 71 0A F4                		add	#-12, r0, r10
 1643                             	.LCFI42:
 1644 0005 EF A0                   		mov.L	r10, r0
 1645 0007 E7 A1 02                		mov.L	r1, 8[r10]
 944:../src/wolfcrypt/src/random.c ****     if (rng) {
 1646                             		.loc 2 944 8
 1647 000a ED A5 02                		mov.L	8[r10], r5
 1648 000d 61 05                   		cmp	#0, r5
 1649 000f 20 2D                   		beq	.L118
 1650                             	.LBB8:
 945:../src/wolfcrypt/src/random.c ****         void* heap = rng->heap;
 1651                             		.loc 2 945 15
 1652 0011 ED A5 02                		mov.L	8[r10], r5
 1653 0014 A8 5D                   		mov.L	4[r5], r5
 1654 0016 E3 A5                   		mov.L	r5, [r10]
 946:../src/wolfcrypt/src/random.c **** 
 947:../src/wolfcrypt/src/random.c ****         wc_FreeRng(rng);
 1655                             		.loc 2 947 9
 1656 0018 ED A1 02                		mov.L	8[r10], r1
 1657 001b 05 00 00 00             		bsr	_wc_FreeRng
 948:../src/wolfcrypt/src/random.c ****         ForceZero(rng, sizeof(WC_RNG));
 1658                             		.loc 2 948 9
 1659 001f 75 42 10                		mov.L	#16, r2
 1660 0022 ED A1 02                		mov.L	8[r10], r1
 1661 0025 05 00 00 00             		bsr	_ForceZero
 1662                             	.LBB9:
 949:../src/wolfcrypt/src/random.c ****         XFREE(rng, heap, DYNAMIC_TYPE_RNG);
 1663                             		.loc 2 949 9
 1664 0029 ED A5 02                		mov.L	8[r10], r5
 1665 002c E7 A5 01                		mov.L	r5, 4[r10]
 1666 002f ED A5 01                		mov.L	4[r10], r5
 1667 0032 61 05                   		cmp	#0, r5
 1668 0034 10                      		beq	.L118
 1669                             		.loc 2 949 9 is_stmt 0 discriminator 1
 1670 0035 ED A1 01                		mov.L	4[r10], r1
 1671 0038 05 00 00 00             		bsr	_wolfSSL_Free
 1672                             	.L118:
 1673                             	.LBE9:
 1674                             	.LBE8:
 950:../src/wolfcrypt/src/random.c ****         (void)heap;
 951:../src/wolfcrypt/src/random.c ****     }
 952:../src/wolfcrypt/src/random.c **** }
 1675                             		.loc 2 952 1 is_stmt 1
 1676 003c 03                      		nop
 1677 003d 3F AA 04                		rtsd	#16, r10-r10
 1678                             	.LFE55:
 1680                             		.section	.text.wc_InitRng,"ax",@progbits
 1681                             		.global	_wc_InitRng
 1683                             	_wc_InitRng:
 1684                             	.LFB56:
 953:../src/wolfcrypt/src/random.c **** 
 954:../src/wolfcrypt/src/random.c **** 
 955:../src/wolfcrypt/src/random.c **** int wc_InitRng(WC_RNG* rng)
 956:../src/wolfcrypt/src/random.c **** {
 1685                             		.loc 2 956 1
 1686 0000 7E AA                   		push.l	r10
 1687                             	.LCFI43:
 1688 0002 71 0A FC                		add	#-4, r0, r10
 1689                             	.LCFI44:
 1690 0005 71 A0 FC                		add	#-4, r10, r0
 1691                             	.LCFI45:
 1692 0008 E3 A1                   		mov.L	r1, [r10]
 957:../src/wolfcrypt/src/random.c ****     return _InitRng(rng, NULL, 0, NULL, INVALID_DEVID);
 1693                             		.loc 2 957 12
 1694 000a F8 06 FE                		mov.L	#-2, [r0]
 1695 000d 66 04                   		mov.L	#0, r4
 1696 000f 66 03                   		mov.L	#0, r3
 1697 0011 66 02                   		mov.L	#0, r2
 1698 0013 EC A1                   		mov.L	[r10], r1
 1699 0015 05 00 00 00             		bsr	__InitRng
 1700 0019 EF 15                   		mov.L	r1, r5
 958:../src/wolfcrypt/src/random.c **** }
 1701                             		.loc 2 958 1
 1702 001b EF 51                   		mov.L	r5, r1
 1703 001d 3F AA 03                		rtsd	#12, r10-r10
 1704                             	.LFE56:
 1706                             		.section	.text.wc_InitRng_ex,"ax",@progbits
 1707                             		.global	_wc_InitRng_ex
 1709                             	_wc_InitRng_ex:
 1710                             	.LFB57:
 959:../src/wolfcrypt/src/random.c **** 
 960:../src/wolfcrypt/src/random.c **** 
 961:../src/wolfcrypt/src/random.c **** int wc_InitRng_ex(WC_RNG* rng, void* heap, int devId)
 962:../src/wolfcrypt/src/random.c **** {
 1711                             		.loc 2 962 1
 1712 0000 7E AA                   		push.l	r10
 1713                             	.LCFI46:
 1714 0002 71 0A F4                		add	#-12, r0, r10
 1715                             	.LCFI47:
 1716 0005 71 A0 FC                		add	#-4, r10, r0
 1717                             	.LCFI48:
 1718 0008 E3 A1                   		mov.L	r1, [r10]
 1719 000a E7 A2 01                		mov.L	r2, 4[r10]
 1720 000d E7 A3 02                		mov.L	r3, 8[r10]
 963:../src/wolfcrypt/src/random.c ****     return _InitRng(rng, NULL, 0, heap, devId);
 1721                             		.loc 2 963 12
 1722 0010 ED A5 02                		mov.L	8[r10], r5
 1723 0013 E3 05                   		mov.L	r5, [r0]
 1724 0015 ED A4 01                		mov.L	4[r10], r4
 1725 0018 66 03                   		mov.L	#0, r3
 1726 001a 66 02                   		mov.L	#0, r2
 1727 001c EC A1                   		mov.L	[r10], r1
 1728 001e 05 00 00 00             		bsr	__InitRng
 1729 0022 EF 15                   		mov.L	r1, r5
 964:../src/wolfcrypt/src/random.c **** }
 1730                             		.loc 2 964 1
 1731 0024 EF 51                   		mov.L	r5, r1
 1732 0026 3F AA 05                		rtsd	#20, r10-r10
 1733                             	.LFE57:
 1735                             		.section	.text.wc_InitRngNonce,"ax",@progbits
 1736                             		.global	_wc_InitRngNonce
 1738                             	_wc_InitRngNonce:
 1739                             	.LFB58:
 965:../src/wolfcrypt/src/random.c **** 
 966:../src/wolfcrypt/src/random.c **** 
 967:../src/wolfcrypt/src/random.c **** int wc_InitRngNonce(WC_RNG* rng, byte* nonce, word32 nonceSz)
 968:../src/wolfcrypt/src/random.c **** {
 1740                             		.loc 2 968 1
 1741 0000 7E AA                   		push.l	r10
 1742                             	.LCFI49:
 1743 0002 71 0A F4                		add	#-12, r0, r10
 1744                             	.LCFI50:
 1745 0005 71 A0 FC                		add	#-4, r10, r0
 1746                             	.LCFI51:
 1747 0008 E3 A1                   		mov.L	r1, [r10]
 1748 000a E7 A2 01                		mov.L	r2, 4[r10]
 1749 000d E7 A3 02                		mov.L	r3, 8[r10]
 969:../src/wolfcrypt/src/random.c ****     return _InitRng(rng, nonce, nonceSz, NULL, INVALID_DEVID);
 1750                             		.loc 2 969 12
 1751 0010 F8 06 FE                		mov.L	#-2, [r0]
 1752 0013 66 04                   		mov.L	#0, r4
 1753 0015 ED A3 02                		mov.L	8[r10], r3
 1754 0018 ED A2 01                		mov.L	4[r10], r2
 1755 001b EC A1                   		mov.L	[r10], r1
 1756 001d 05 00 00 00             		bsr	__InitRng
 1757 0021 EF 15                   		mov.L	r1, r5
 970:../src/wolfcrypt/src/random.c **** }
 1758                             		.loc 2 970 1
 1759 0023 EF 51                   		mov.L	r5, r1
 1760 0025 3F AA 05                		rtsd	#20, r10-r10
 1761                             	.LFE58:
 1763                             		.section	.text.wc_InitRngNonce_ex,"ax",@progbits
 1764                             		.global	_wc_InitRngNonce_ex
 1766                             	_wc_InitRngNonce_ex:
 1767                             	.LFB59:
 971:../src/wolfcrypt/src/random.c **** 
 972:../src/wolfcrypt/src/random.c **** 
 973:../src/wolfcrypt/src/random.c **** int wc_InitRngNonce_ex(WC_RNG* rng, byte* nonce, word32 nonceSz,
 974:../src/wolfcrypt/src/random.c ****                        void* heap, int devId)
 975:../src/wolfcrypt/src/random.c **** {
 1768                             		.loc 2 975 1
 1769 0000 7E AA                   		push.l	r10
 1770                             	.LCFI52:
 1771 0002 71 0A EC                		add	#-20, r0, r10
 1772                             	.LCFI53:
 1773 0005 71 A0 FC                		add	#-4, r10, r0
 1774                             	.LCFI54:
 1775 0008 75 45 1C                		mov.L	#28, r5
 1776 000b 4B A5                   		add	r10, r5
 1777 000d E3 A1                   		mov.L	r1, [r10]
 1778 000f E7 A2 01                		mov.L	r2, 4[r10]
 1779 0012 E7 A3 02                		mov.L	r3, 8[r10]
 1780 0015 E7 A4 03                		mov.L	r4, 12[r10]
 976:../src/wolfcrypt/src/random.c ****     return _InitRng(rng, nonce, nonceSz, heap, devId);
 1781                             		.loc 2 976 12
 1782 0018 EC 55                   		mov.L	[r5], r5
 1783 001a E3 05                   		mov.L	r5, [r0]
 1784 001c ED A4 03                		mov.L	12[r10], r4
 1785 001f ED A3 02                		mov.L	8[r10], r3
 1786 0022 ED A2 01                		mov.L	4[r10], r2
 1787 0025 EC A1                   		mov.L	[r10], r1
 1788 0027 05 00 00 00             		bsr	__InitRng
 1789 002b EF 15                   		mov.L	r1, r5
 977:../src/wolfcrypt/src/random.c **** }
 1790                             		.loc 2 977 1
 1791 002d EF 51                   		mov.L	r5, r1
 1792 002f 3F AA 07                		rtsd	#28, r10-r10
 1793                             	.LFE59:
 1795                             		.section	.text.wc_RNG_GenerateBlock,"ax",@progbits
 1796                             		.global	_wc_RNG_GenerateBlock
 1798                             	_wc_RNG_GenerateBlock:
 1799                             	.LFB60:
 978:../src/wolfcrypt/src/random.c **** 
 979:../src/wolfcrypt/src/random.c **** 
 980:../src/wolfcrypt/src/random.c **** /* place a generated block in output */
 981:../src/wolfcrypt/src/random.c **** WOLFSSL_ABI
 982:../src/wolfcrypt/src/random.c **** int wc_RNG_GenerateBlock(WC_RNG* rng, byte* output, word32 sz)
 983:../src/wolfcrypt/src/random.c **** {
 1800                             		.loc 2 983 1
 1801 0000 7E AA                   		push.l	r10
 1802                             	.LCFI55:
 1803 0002 71 0A CC                		add	#-52, r0, r10
 1804                             	.LCFI56:
 1805 0005 EF A0                   		mov.L	r10, r0
 1806 0007 E7 A1 0A                		mov.L	r1, 40[r10]
 1807 000a E7 A2 0B                		mov.L	r2, 44[r10]
 1808 000d E7 A3 0C                		mov.L	r3, 48[r10]
 984:../src/wolfcrypt/src/random.c ****     int ret;
 985:../src/wolfcrypt/src/random.c **** 
 986:../src/wolfcrypt/src/random.c ****     if (rng == NULL || output == NULL)
 1809                             		.loc 2 986 8
 1810 0010 ED A5 0A                		mov.L	40[r10], r5
 1811 0013 61 05                   		cmp	#0, r5
 1812 0015 17                      		beq	.L128
 1813                             		.loc 2 986 21 discriminator 1
 1814 0016 ED A5 0B                		mov.L	44[r10], r5
 1815 0019 61 05                   		cmp	#0, r5
 1816 001b 18                      		bne	.L129
 1817                             	.L128:
 987:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
 1818                             		.loc 2 987 16
 1819 001c FB 5A 53 FF             		mov.L	#-173, r5
 1820 0020 38 EE 00                		bra	.L130
 1821                             	.L129:
 988:../src/wolfcrypt/src/random.c **** 
 989:../src/wolfcrypt/src/random.c ****     if (sz == 0)
 1822                             		.loc 2 989 8
 1823 0023 ED A5 0C                		mov.L	48[r10], r5
 1824 0026 61 05                   		cmp	#0, r5
 1825 0028 1E                      		bne	.L131
 990:../src/wolfcrypt/src/random.c ****         return 0;
 1826                             		.loc 2 990 16
 1827 0029 66 05                   		mov.L	#0, r5
 1828 002b 38 E3 00                		bra	.L130
 1829                             	.L131:
 991:../src/wolfcrypt/src/random.c **** 
 992:../src/wolfcrypt/src/random.c **** #ifdef WOLF_CRYPTO_CB
 993:../src/wolfcrypt/src/random.c ****     if (rng->devId != INVALID_DEVID) {
 994:../src/wolfcrypt/src/random.c ****         ret = wc_CryptoCb_RandomBlock(rng, output, sz);
 995:../src/wolfcrypt/src/random.c ****         if (ret != CRYPTOCB_UNAVAILABLE)
 996:../src/wolfcrypt/src/random.c ****             return ret;
 997:../src/wolfcrypt/src/random.c ****         /* fall-through when unavailable */
 998:../src/wolfcrypt/src/random.c ****     }
 999:../src/wolfcrypt/src/random.c **** #endif
1000:../src/wolfcrypt/src/random.c **** 
1001:../src/wolfcrypt/src/random.c **** #ifdef HAVE_INTEL_RDRAND
1002:../src/wolfcrypt/src/random.c ****     if (IS_INTEL_RDRAND(intel_flags))
1003:../src/wolfcrypt/src/random.c ****         return wc_GenerateRand_IntelRD(NULL, output, sz);
1004:../src/wolfcrypt/src/random.c **** #endif
1005:../src/wolfcrypt/src/random.c **** 
1006:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_SILABS_SE_ACCEL) && defined(WOLFSSL_SILABS_TRNG)
1007:../src/wolfcrypt/src/random.c ****     return silabs_GenerateRand(output, sz);
1008:../src/wolfcrypt/src/random.c **** #endif
1009:../src/wolfcrypt/src/random.c **** 
1010:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_ASYNC_CRYPT)
1011:../src/wolfcrypt/src/random.c ****     if (rng->asyncDev.marker == WOLFSSL_ASYNC_MARKER_RNG) {
1012:../src/wolfcrypt/src/random.c ****         /* these are blocking */
1013:../src/wolfcrypt/src/random.c ****     #ifdef HAVE_CAVIUM
1014:../src/wolfcrypt/src/random.c ****         return NitroxRngGenerateBlock(rng, output, sz);
1015:../src/wolfcrypt/src/random.c ****     #elif defined(HAVE_INTEL_QA) && defined(QAT_ENABLE_RNG)
1016:../src/wolfcrypt/src/random.c ****         return IntelQaDrbg(&rng->asyncDev, output, sz);
1017:../src/wolfcrypt/src/random.c ****     #else
1018:../src/wolfcrypt/src/random.c ****         /* simulator not supported */
1019:../src/wolfcrypt/src/random.c ****     #endif
1020:../src/wolfcrypt/src/random.c ****     }
1021:../src/wolfcrypt/src/random.c **** #endif
1022:../src/wolfcrypt/src/random.c **** 
1023:../src/wolfcrypt/src/random.c **** #ifdef CUSTOM_RAND_GENERATE_BLOCK
1024:../src/wolfcrypt/src/random.c ****     XMEMSET(output, 0, sz);
1025:../src/wolfcrypt/src/random.c ****     ret = CUSTOM_RAND_GENERATE_BLOCK(output, sz);
1026:../src/wolfcrypt/src/random.c **** #else
1027:../src/wolfcrypt/src/random.c **** 
1028:../src/wolfcrypt/src/random.c **** #ifdef HAVE_HASHDRBG
1029:../src/wolfcrypt/src/random.c ****     if (sz > RNG_MAX_BLOCK_LEN)
 1830                             		.loc 2 1029 8
 1831 002e ED A5 0C                		mov.L	48[r10], r5
 1832 0031 77 05 00 00 01          		cmp	#0x10000, r5
 1833 0036 25 09                   		bleu	.L132
1030:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
 1834                             		.loc 2 1030 16
 1835 0038 FB 5A 53 FF             		mov.L	#-173, r5
 1836 003c 38 D2 00                		bra	.L130
 1837                             	.L132:
1031:../src/wolfcrypt/src/random.c **** 
1032:../src/wolfcrypt/src/random.c ****     if (rng->status != DRBG_OK)
 1838                             		.loc 2 1032 12
 1839 003f ED A5 0A                		mov.L	40[r10], r5
 1840 0042 8B 55                   		mov.B	12[r5], r5
 1841                             		.loc 2 1032 8
 1842 0044 5B 55                   		movu.B	r5, r5
 1843 0046 61 15                   		cmp	#1, r5
 1844 0048 10                      		beq	.L133
1033:../src/wolfcrypt/src/random.c ****         return RNG_FAILURE_E;
 1845                             		.loc 2 1033 16
 1846 0049 FB 5A 39 FF             		mov.L	#-199, r5
 1847 004d 38 C1 00                		bra	.L130
 1848                             	.L133:
1034:../src/wolfcrypt/src/random.c **** 
1035:../src/wolfcrypt/src/random.c ****     ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
 1849                             		.loc 2 1035 50
 1850 0050 ED A5 0A                		mov.L	40[r10], r5
 1851 0053 A8 D5                   		mov.L	8[r5], r5
 1852                             		.loc 2 1035 11
 1853 0055 ED A3 0C                		mov.L	48[r10], r3
 1854 0058 ED A2 0B                		mov.L	44[r10], r2
 1855 005b EF 51                   		mov.L	r5, r1
 1856 005d 05 00 00 00             		bsr	_Hash_DRBG_Generate
 1857 0061 E3 A1                   		mov.L	r1, [r10]
1036:../src/wolfcrypt/src/random.c ****     if (ret == DRBG_NEED_RESEED) {
 1858                             		.loc 2 1036 8
 1859 0063 EC A5                   		mov.L	[r10], r5
 1860 0065 61 25                   		cmp	#2, r5
 1861 0067 21 7F                   		bne	.L134
1037:../src/wolfcrypt/src/random.c ****         if (wc_RNG_HealthTestLocal(1) == 0) {
 1862                             		.loc 2 1037 13
 1863 0069 66 11                   		mov.L	#1, r1
 1864 006b 05 00 00 00             		bsr	_wc_RNG_HealthTestLocal
 1865 006f EF 15                   		mov.L	r1, r5
 1866                             		.loc 2 1037 12
 1867 0071 61 05                   		cmp	#0, r5
 1868 0073 21 70                   		bne	.L135
 1869                             	.LBB10:
1038:../src/wolfcrypt/src/random.c ****             byte newSeed[SEED_SZ + SEED_BLOCK_SZ];
1039:../src/wolfcrypt/src/random.c **** 
1040:../src/wolfcrypt/src/random.c ****             ret = wc_GenerateSeed(&rng->seed, newSeed,
 1870                             		.loc 2 1040 35
 1871 0075 ED A4 0A                		mov.L	40[r10], r4
 1872                             		.loc 2 1040 19
 1873 0078 71 A5 04                		add	#4, r10, r5
 1874 007b 75 43 24                		mov.L	#36, r3
 1875 007e EF 52                   		mov.L	r5, r2
 1876 0080 EF 41                   		mov.L	r4, r1
 1877 0082 05 00 00 00             		bsr	_wc_GenerateSeed
 1878 0086 E3 A1                   		mov.L	r1, [r10]
1041:../src/wolfcrypt/src/random.c ****                                   SEED_SZ + SEED_BLOCK_SZ);
1042:../src/wolfcrypt/src/random.c ****             if (ret != 0)
 1879                             		.loc 2 1042 16
 1880 0088 EC A5                   		mov.L	[r10], r5
 1881 008a 61 05                   		cmp	#0, r5
 1882 008c 16                      		beq	.L136
1043:../src/wolfcrypt/src/random.c ****                 ret = DRBG_FAILURE;
 1883                             		.loc 2 1043 21
 1884 008d F8 A6 01                		mov.L	#1, [r10]
 1885 0090 2E 10                   		bra	.L137
 1886                             	.L136:
1044:../src/wolfcrypt/src/random.c ****             else
1045:../src/wolfcrypt/src/random.c ****                 ret = wc_RNG_TestSeed(newSeed, SEED_SZ + SEED_BLOCK_SZ);
 1887                             		.loc 2 1045 23
 1888 0092 71 A5 04                		add	#4, r10, r5
 1889 0095 75 42 24                		mov.L	#36, r2
 1890 0098 EF 51                   		mov.L	r5, r1
 1891 009a 05 00 00 00             		bsr	_wc_RNG_TestSeed
 1892 009e E3 A1                   		mov.L	r1, [r10]
 1893                             	.L137:
1046:../src/wolfcrypt/src/random.c **** 
1047:../src/wolfcrypt/src/random.c ****             if (ret == DRBG_SUCCESS)
 1894                             		.loc 2 1047 16
 1895 00a0 EC A5                   		mov.L	[r10], r5
 1896 00a2 61 05                   		cmp	#0, r5
 1897 00a4 21 19                   		bne	.L138
1048:../src/wolfcrypt/src/random.c ****                 ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg,
 1898                             		.loc 2 1048 60
 1899 00a6 ED A5 0A                		mov.L	40[r10], r5
 1900 00a9 A8 D4                   		mov.L	8[r5], r4
 1901                             		.loc 2 1048 23
 1902 00ab 71 A5 04                		add	#4, r10, r5
 1903 00ae 62 45                   		add	#4, r5
 1904 00b0 75 43 20                		mov.L	#32, r3
 1905 00b3 EF 52                   		mov.L	r5, r2
 1906 00b5 EF 41                   		mov.L	r4, r1
 1907 00b7 05 00 00 00             		bsr	_Hash_DRBG_Reseed
 1908 00bb E3 A1                   		mov.L	r1, [r10]
 1909                             	.L138:
1049:../src/wolfcrypt/src/random.c ****                                        newSeed + SEED_BLOCK_SZ, SEED_SZ);
1050:../src/wolfcrypt/src/random.c ****             if (ret == DRBG_SUCCESS)
 1910                             		.loc 2 1050 16
 1911 00bd EC A5                   		mov.L	[r10], r5
 1912 00bf 61 05                   		cmp	#0, r5
 1913 00c1 21 15                   		bne	.L139
1051:../src/wolfcrypt/src/random.c ****                 ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
 1914                             		.loc 2 1051 62
 1915 00c3 ED A5 0A                		mov.L	40[r10], r5
 1916 00c6 A8 D5                   		mov.L	8[r5], r5
 1917                             		.loc 2 1051 23
 1918 00c8 ED A3 0C                		mov.L	48[r10], r3
 1919 00cb ED A2 0B                		mov.L	44[r10], r2
 1920 00ce EF 51                   		mov.L	r5, r1
 1921 00d0 05 00 00 00             		bsr	_Hash_DRBG_Generate
 1922 00d4 E3 A1                   		mov.L	r1, [r10]
 1923                             	.L139:
1052:../src/wolfcrypt/src/random.c **** 
1053:../src/wolfcrypt/src/random.c ****             ForceZero(newSeed, sizeof(newSeed));
 1924                             		.loc 2 1053 13
 1925 00d6 71 A5 04                		add	#4, r10, r5
 1926 00d9 75 42 24                		mov.L	#36, r2
 1927 00dc EF 51                   		mov.L	r5, r1
 1928 00de 05 00 00 00             		bsr	_ForceZero
 1929                             	.LBE10:
 1930 00e2 0C                      		bra	.L134
 1931                             	.L135:
1054:../src/wolfcrypt/src/random.c ****         }
1055:../src/wolfcrypt/src/random.c ****         else
1056:../src/wolfcrypt/src/random.c ****             ret = DRBG_CONT_FAILURE;
 1932                             		.loc 2 1056 17
 1933 00e3 F8 A6 03                		mov.L	#3, [r10]
 1934                             	.L134:
1057:../src/wolfcrypt/src/random.c ****     }
1058:../src/wolfcrypt/src/random.c **** 
1059:../src/wolfcrypt/src/random.c ****     if (ret == DRBG_SUCCESS) {
 1935                             		.loc 2 1059 8
 1936 00e6 EC A5                   		mov.L	[r10], r5
 1937 00e8 61 05                   		cmp	#0, r5
 1938 00ea 1E                      		bne	.L140
1060:../src/wolfcrypt/src/random.c ****         ret = 0;
 1939                             		.loc 2 1060 13
 1940 00eb F8 A6 00                		mov.L	#0, [r10]
 1941 00ee 2E 1E                   		bra	.L141
 1942                             	.L140:
1061:../src/wolfcrypt/src/random.c ****     }
1062:../src/wolfcrypt/src/random.c ****     else if (ret == DRBG_CONT_FAILURE) {
 1943                             		.loc 2 1062 13
 1944 00f0 EC A5                   		mov.L	[r10], r5
 1945 00f2 61 35                   		cmp	#3, r5
 1946 00f4 21 0E                   		bne	.L142
1063:../src/wolfcrypt/src/random.c ****         ret = DRBG_CONT_FIPS_E;
 1947                             		.loc 2 1063 13
 1948 00f6 F8 AA 2F FF             		mov.L	#-209, [r10]
1064:../src/wolfcrypt/src/random.c ****         rng->status = DRBG_CONT_FAILED;
 1949                             		.loc 2 1064 21
 1950 00fa ED A5 0A                		mov.L	40[r10], r5
 1951 00fd 3C 5C 03                		mov.B	#3, 12[r5]
 1952 0100 2E 0C                   		bra	.L141
 1953                             	.L142:
1065:../src/wolfcrypt/src/random.c ****     }
1066:../src/wolfcrypt/src/random.c ****     else {
1067:../src/wolfcrypt/src/random.c ****         ret = RNG_FAILURE_E;
 1954                             		.loc 2 1067 13
 1955 0102 F8 AA 39 FF             		mov.L	#-199, [r10]
1068:../src/wolfcrypt/src/random.c ****         rng->status = DRBG_FAILED;
 1956                             		.loc 2 1068 21
 1957 0106 ED A5 0A                		mov.L	40[r10], r5
 1958 0109 3C 5C 02                		mov.B	#2, 12[r5]
 1959                             	.L141:
1069:../src/wolfcrypt/src/random.c ****     }
1070:../src/wolfcrypt/src/random.c **** #else
1071:../src/wolfcrypt/src/random.c **** 
1072:../src/wolfcrypt/src/random.c ****     /* if we get here then there is an RNG configuration error */
1073:../src/wolfcrypt/src/random.c ****     ret = RNG_FAILURE_E;
1074:../src/wolfcrypt/src/random.c **** 
1075:../src/wolfcrypt/src/random.c **** #endif /* HAVE_HASHDRBG */
1076:../src/wolfcrypt/src/random.c **** #endif /* CUSTOM_RAND_GENERATE_BLOCK */
1077:../src/wolfcrypt/src/random.c **** 
1078:../src/wolfcrypt/src/random.c ****     return ret;
 1960                             		.loc 2 1078 12
 1961 010c EC A5                   		mov.L	[r10], r5
 1962                             		.balign 8,3,1
 1963                             	.L130:
1079:../src/wolfcrypt/src/random.c **** }
 1964                             		.loc 2 1079 1
 1965 010e EF 51                   		mov.L	r5, r1
 1966 0110 3F AA 0E                		rtsd	#56, r10-r10
 1967                             	.LFE60:
 1969 0113 77 10 01 00 00          		.section	.text.wc_RNG_GenerateByte,"ax",@progbits
 1970                             		.global	_wc_RNG_GenerateByte
 1972                             	_wc_RNG_GenerateByte:
 1973                             	.LFB61:
1080:../src/wolfcrypt/src/random.c **** 
1081:../src/wolfcrypt/src/random.c **** 
1082:../src/wolfcrypt/src/random.c **** int wc_RNG_GenerateByte(WC_RNG* rng, byte* b)
1083:../src/wolfcrypt/src/random.c **** {
 1974                             		.loc 2 1083 1
 1975 0000 7E AA                   		push.l	r10
 1976                             	.LCFI57:
 1977 0002 71 0A F8                		add	#-8, r0, r10
 1978                             	.LCFI58:
 1979 0005 EF A0                   		mov.L	r10, r0
 1980 0007 E3 A1                   		mov.L	r1, [r10]
 1981 0009 E7 A2 01                		mov.L	r2, 4[r10]
1084:../src/wolfcrypt/src/random.c ****     return wc_RNG_GenerateBlock(rng, b, 1);
 1982                             		.loc 2 1084 12
 1983 000c 66 13                   		mov.L	#1, r3
 1984 000e ED A2 01                		mov.L	4[r10], r2
 1985 0011 EC A1                   		mov.L	[r10], r1
 1986 0013 05 00 00 00             		bsr	_wc_RNG_GenerateBlock
 1987 0017 EF 15                   		mov.L	r1, r5
1085:../src/wolfcrypt/src/random.c **** }
 1988                             		.loc 2 1085 1
 1989 0019 EF 51                   		mov.L	r5, r1
 1990 001b 3F AA 03                		rtsd	#12, r10-r10
 1991                             	.LFE61:
 1993                             		.section	.text.wc_FreeRng,"ax",@progbits
 1994                             		.global	_wc_FreeRng
 1996                             	_wc_FreeRng:
 1997                             	.LFB62:
1086:../src/wolfcrypt/src/random.c **** 
1087:../src/wolfcrypt/src/random.c **** 
1088:../src/wolfcrypt/src/random.c **** int wc_FreeRng(WC_RNG* rng)
1089:../src/wolfcrypt/src/random.c **** {
 1998                             		.loc 2 1089 1
 1999 0000 7E AA                   		push.l	r10
 2000                             	.LCFI59:
 2001 0002 71 0A F4                		add	#-12, r0, r10
 2002                             	.LCFI60:
 2003 0005 EF A0                   		mov.L	r10, r0
 2004 0007 E7 A1 02                		mov.L	r1, 8[r10]
1090:../src/wolfcrypt/src/random.c ****     int ret = 0;
 2005                             		.loc 2 1090 9
 2006 000a F8 A6 00                		mov.L	#0, [r10]
1091:../src/wolfcrypt/src/random.c **** 
1092:../src/wolfcrypt/src/random.c ****     if (rng == NULL)
 2007                             		.loc 2 1092 8
 2008 000d ED A5 02                		mov.L	8[r10], r5
 2009 0010 61 05                   		cmp	#0, r5
 2010 0012 1F                      		bne	.L146
1093:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
 2011                             		.loc 2 1093 16
 2012 0013 FB 5A 53 FF             		mov.L	#-173, r5
 2013 0017 2E 42                   		bra	.L147
 2014                             	.L146:
1094:../src/wolfcrypt/src/random.c **** 
1095:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_ASYNC_CRYPT)
1096:../src/wolfcrypt/src/random.c ****     wolfAsync_DevCtxFree(&rng->asyncDev, WOLFSSL_ASYNC_MARKER_RNG);
1097:../src/wolfcrypt/src/random.c **** #endif
1098:../src/wolfcrypt/src/random.c **** 
1099:../src/wolfcrypt/src/random.c **** #ifdef HAVE_HASHDRBG
1100:../src/wolfcrypt/src/random.c ****     if (rng->drbg != NULL) {
 2015                             		.loc 2 1100 12
 2016 0019 ED A5 02                		mov.L	8[r10], r5
 2017 001c A8 D5                   		mov.L	8[r5], r5
 2018                             		.loc 2 1100 8
 2019 001e 61 05                   		cmp	#0, r5
 2020 0020 20 31                   		beq	.L148
1101:../src/wolfcrypt/src/random.c ****       if (Hash_DRBG_Uninstantiate((DRBG_internal *)rng->drbg) != DRBG_SUCCESS)
 2021                             		.loc 2 1101 55
 2022 0022 ED A5 02                		mov.L	8[r10], r5
 2023 0025 A8 D5                   		mov.L	8[r5], r5
 2024                             		.loc 2 1101 11
 2025 0027 EF 51                   		mov.L	r5, r1
 2026 0029 05 00 00 00             		bsr	_Hash_DRBG_Uninstantiate
 2027 002d EF 15                   		mov.L	r1, r5
 2028                             		.loc 2 1101 10
 2029 002f 61 05                   		cmp	#0, r5
 2030 0031 15                      		beq	.L149
1102:../src/wolfcrypt/src/random.c ****             ret = RNG_FAILURE_E;
 2031                             		.loc 2 1102 17
 2032 0032 F8 AA 39 FF             		mov.L	#-199, [r10]
 2033                             	.L149:
 2034                             	.LBB11:
1103:../src/wolfcrypt/src/random.c **** 
1104:../src/wolfcrypt/src/random.c ****     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
1105:../src/wolfcrypt/src/random.c ****         XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 2035                             		.loc 2 1105 9
 2036 0036 ED A5 02                		mov.L	8[r10], r5
 2037 0039 A8 D5                   		mov.L	8[r5], r5
 2038 003b E7 A5 01                		mov.L	r5, 4[r10]
 2039 003e ED A5 01                		mov.L	4[r10], r5
 2040 0041 61 05                   		cmp	#0, r5
 2041 0043 10                      		beq	.L150
 2042                             		.loc 2 1105 9 is_stmt 0 discriminator 1
 2043 0044 ED A1 01                		mov.L	4[r10], r1
 2044 0047 05 00 00 00             		bsr	_wolfSSL_Free
 2045                             	.L150:
 2046                             	.LBE11:
1106:../src/wolfcrypt/src/random.c ****     #elif defined(WOLFSSL_CHECK_MEM_ZERO)
1107:../src/wolfcrypt/src/random.c ****         wc_MemZero_Check(rng->drbg, sizeof(DRBG_internal));
1108:../src/wolfcrypt/src/random.c ****     #endif
1109:../src/wolfcrypt/src/random.c ****         rng->drbg = NULL;
 2047                             		.loc 2 1109 19 is_stmt 1
 2048 004b ED A5 02                		mov.L	8[r10], r5
 2049 004e 3E 52 00                		mov.L	#0, 8[r5]
 2050                             	.L148:
1110:../src/wolfcrypt/src/random.c ****     }
1111:../src/wolfcrypt/src/random.c **** 
1112:../src/wolfcrypt/src/random.c ****     rng->status = DRBG_NOT_INIT;
 2051                             		.loc 2 1112 17
 2052 0051 ED A5 02                		mov.L	8[r10], r5
 2053 0054 3C 5C 00                		mov.B	#0, 12[r5]
1113:../src/wolfcrypt/src/random.c **** #endif /* HAVE_HASHDRBG */
1114:../src/wolfcrypt/src/random.c **** 
1115:../src/wolfcrypt/src/random.c ****     return ret;
 2054                             		.loc 2 1115 12
 2055 0057 EC A5                   		mov.L	[r10], r5
 2056                             	.L147:
1116:../src/wolfcrypt/src/random.c **** }
 2057                             		.loc 2 1116 1
 2058 0059 EF 51                   		mov.L	r5, r1
 2059 005b 3F AA 04                		rtsd	#16, r10-r10
 2060                             	.LFE62:
 2062                             		.section	.text.wc_RNG_HealthTest,"ax",@progbits
 2063                             		.global	_wc_RNG_HealthTest
 2065                             	_wc_RNG_HealthTest:
 2066                             	.LFB63:
1117:../src/wolfcrypt/src/random.c **** 
1118:../src/wolfcrypt/src/random.c **** #ifdef HAVE_HASHDRBG
1119:../src/wolfcrypt/src/random.c **** int wc_RNG_HealthTest(int reseed, const byte* seedA, word32 seedASz,
1120:../src/wolfcrypt/src/random.c ****                                   const byte* seedB, word32 seedBSz,
1121:../src/wolfcrypt/src/random.c ****                                   byte* output, word32 outputSz)
1122:../src/wolfcrypt/src/random.c **** {
 2067                             		.loc 2 1122 1
 2068 0000 7E AA                   		push.l	r10
 2069                             	.LCFI61:
 2070 0002 71 0A E4                		add	#-28, r0, r10
 2071                             	.LCFI62:
 2072 0005 71 A0 E4                		add	#-28, r10, r0
 2073                             	.LCFI63:
 2074 0008 75 45 24                		mov.L	#36, r5
 2075 000b 4B A5                   		add	r10, r5
 2076 000d E3 A1                   		mov.L	r1, [r10]
 2077 000f E7 A2 01                		mov.L	r2, 4[r10]
 2078 0012 E7 A3 02                		mov.L	r3, 8[r10]
 2079 0015 E7 A4 03                		mov.L	r4, 12[r10]
1123:../src/wolfcrypt/src/random.c ****     return wc_RNG_HealthTest_ex(reseed, NULL, 0,
 2080                             		.loc 2 1123 12
 2081 0018 F9 06 06 FE             		mov.L	#-2, 24[r0]
 2082 001c 3E 05 00                		mov.L	#0, 20[r0]
 2083 001f A8 D4                   		mov.L	8[r5], r4
 2084 0021 A1 04                   		mov.L	r4, 16[r0]
 2085 0023 A8 5C                   		mov.L	4[r5], r4
 2086 0025 A0 8C                   		mov.L	r4, 12[r0]
 2087 0027 EC 55                   		mov.L	[r5], r5
 2088 0029 A0 85                   		mov.L	r5, 8[r0]
 2089 002b ED A5 03                		mov.L	12[r10], r5
 2090 002e A0 0D                   		mov.L	r5, 4[r0]
 2091 0030 ED A5 02                		mov.L	8[r10], r5
 2092 0033 E3 05                   		mov.L	r5, [r0]
 2093 0035 ED A4 01                		mov.L	4[r10], r4
 2094 0038 66 03                   		mov.L	#0, r3
 2095 003a 66 02                   		mov.L	#0, r2
 2096 003c EC A1                   		mov.L	[r10], r1
 2097 003e 05 00 00 00             		bsr	_wc_RNG_HealthTest_ex
 2098 0042 EF 15                   		mov.L	r1, r5
1124:../src/wolfcrypt/src/random.c ****                                 seedA, seedASz, seedB, seedBSz,
1125:../src/wolfcrypt/src/random.c ****                                 output, outputSz,
1126:../src/wolfcrypt/src/random.c ****                                 NULL, INVALID_DEVID);
1127:../src/wolfcrypt/src/random.c **** }
 2099                             		.loc 2 1127 1
 2100 0044 EF 51                   		mov.L	r5, r1
 2101 0046 3F AA 0F                		rtsd	#60, r10-r10
 2102                             	.LFE63:
 2104                             		.section	.text.wc_RNG_HealthTest_ex,"ax",@progbits
 2105                             		.global	_wc_RNG_HealthTest_ex
 2107                             	_wc_RNG_HealthTest_ex:
 2108                             	.LFB64:
1128:../src/wolfcrypt/src/random.c **** 
1129:../src/wolfcrypt/src/random.c **** 
1130:../src/wolfcrypt/src/random.c **** int wc_RNG_HealthTest_ex(int reseed, const byte* nonce, word32 nonceSz,
1131:../src/wolfcrypt/src/random.c ****                                   const byte* seedA, word32 seedASz,
1132:../src/wolfcrypt/src/random.c ****                                   const byte* seedB, word32 seedBSz,
1133:../src/wolfcrypt/src/random.c ****                                   byte* output, word32 outputSz,
1134:../src/wolfcrypt/src/random.c ****                                   void* heap, int devId)
1135:../src/wolfcrypt/src/random.c **** {
 2109                             		.loc 2 1135 1
 2110 0000 7E AA                   		push.l	r10
 2111                             	.LCFI64:
 2112 0002 7E A6                   		push.l	r6
 2113                             	.LCFI65:
 2114 0004 71 0A C8                		add	#-56, r0, r10
 2115                             	.LCFI66:
 2116 0007 71 A0 F4                		add	#-12, r10, r0
 2117                             	.LCFI67:
 2118 000a 75 46 44                		mov.L	#0x44, r6
 2119 000d 4B A6                   		add	r10, r6
 2120 000f E7 A1 03                		mov.L	r1, 12[r10]
 2121 0012 E7 A2 04                		mov.L	r2, 16[r10]
 2122 0015 E7 A3 05                		mov.L	r3, 20[r10]
 2123 0018 E7 A4 06                		mov.L	r4, 24[r10]
1136:../src/wolfcrypt/src/random.c ****     int ret = -1;
 2124                             		.loc 2 1136 9
 2125 001b F8 A6 FF                		mov.L	#-1, [r10]
1137:../src/wolfcrypt/src/random.c ****     DRBG_internal* drbg;
1138:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_SMALL_STACK
1139:../src/wolfcrypt/src/random.c ****     DRBG_internal  drbg_var;
1140:../src/wolfcrypt/src/random.c **** #endif
1141:../src/wolfcrypt/src/random.c **** 
1142:../src/wolfcrypt/src/random.c ****     if (seedA == NULL || output == NULL) {
 2126                             		.loc 2 1142 8
 2127 001e ED A5 06                		mov.L	24[r10], r5
 2128 0021 61 05                   		cmp	#0, r5
 2129 0023 16                      		beq	.L154
 2130                             		.loc 2 1142 23 discriminator 1
 2131 0024 A8 ED                   		mov.L	12[r6], r5
 2132 0026 61 05                   		cmp	#0, r5
 2133 0028 18                      		bne	.L155
 2134                             	.L154:
1143:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
 2135                             		.loc 2 1143 16
 2136 0029 FB 5A 53 FF             		mov.L	#-173, r5
 2137 002d 38 C3 00                		bra	.L156
 2138                             	.L155:
1144:../src/wolfcrypt/src/random.c ****     }
1145:../src/wolfcrypt/src/random.c **** 
1146:../src/wolfcrypt/src/random.c ****     if (reseed != 0 && seedB == NULL) {
 2139                             		.loc 2 1146 8
 2140 0030 ED A5 03                		mov.L	12[r10], r5
 2141 0033 61 05                   		cmp	#0, r5
 2142 0035 20 0E                   		beq	.L157
 2143                             		.loc 2 1146 21 discriminator 1
 2144 0037 A8 6D                   		mov.L	4[r6], r5
 2145 0039 61 05                   		cmp	#0, r5
 2146 003b 18                      		bne	.L157
1147:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
 2147                             		.loc 2 1147 16
 2148 003c FB 5A 53 FF             		mov.L	#-173, r5
 2149 0040 38 B0 00                		bra	.L156
 2150                             	.L157:
1148:../src/wolfcrypt/src/random.c ****     }
1149:../src/wolfcrypt/src/random.c **** 
1150:../src/wolfcrypt/src/random.c ****     if (outputSz != RNG_HEALTH_TEST_CHECK_SIZE) {
 2151                             		.loc 2 1150 8
 2152 0043 A9 65                   		mov.L	16[r6], r5
 2153 0045 75 55 80                		cmp	#0x80, r5
 2154 0048 16                      		beq	.L158
1151:../src/wolfcrypt/src/random.c ****         return ret;
 2155                             		.loc 2 1151 16
 2156 0049 EC A5                   		mov.L	[r10], r5
 2157 004b 38 A5 00                		bra	.L156
 2158                             	.L158:
1152:../src/wolfcrypt/src/random.c ****     }
1153:../src/wolfcrypt/src/random.c **** 
1154:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK
1155:../src/wolfcrypt/src/random.c ****     drbg = (DRBG_internal*)XMALLOC(sizeof(DRBG_internal), NULL, DYNAMIC_TYPE_RNG);
 2159                             		.loc 2 1155 28
 2160 004e 75 41 78                		mov.L	#0x78, r1
 2161 0051 05 00 00 00             		bsr	_wolfSSL_Malloc
 2162 0055 E7 A1 01                		mov.L	r1, 4[r10]
1156:../src/wolfcrypt/src/random.c ****     if (drbg == NULL) {
 2163                             		.loc 2 1156 8
 2164 0058 ED A5 01                		mov.L	4[r10], r5
 2165 005b 61 05                   		cmp	#0, r5
 2166 005d 1F                      		bne	.L159
1157:../src/wolfcrypt/src/random.c ****         return MEMORY_E;
 2167                             		.loc 2 1157 16
 2168 005e FB 56 83                		mov.L	#-125, r5
 2169 0061 38 8F 00                		bra	.L156
 2170                             	.L159:
1158:../src/wolfcrypt/src/random.c ****     }
1159:../src/wolfcrypt/src/random.c **** #else
1160:../src/wolfcrypt/src/random.c ****     drbg = &drbg_var;
1161:../src/wolfcrypt/src/random.c **** #endif
1162:../src/wolfcrypt/src/random.c **** 
1163:../src/wolfcrypt/src/random.c ****     if (Hash_DRBG_Instantiate(drbg, seedA, seedASz, nonce, nonceSz,
 2171                             		.loc 2 1163 9
 2172 0064 A9 E5                   		mov.L	24[r6], r5
 2173 0066 A0 85                   		mov.L	r5, 8[r0]
 2174 0068 A9 6D                   		mov.L	20[r6], r5
 2175 006a A0 0D                   		mov.L	r5, 4[r0]
 2176 006c ED A5 05                		mov.L	20[r10], r5
 2177 006f E3 05                   		mov.L	r5, [r0]
 2178 0071 ED A4 04                		mov.L	16[r10], r4
 2179 0074 EC 63                   		mov.L	[r6], r3
 2180 0076 ED A2 06                		mov.L	24[r10], r2
 2181 0079 ED A1 01                		mov.L	4[r10], r1
 2182 007c 05 00 00 00             		bsr	_Hash_DRBG_Instantiate
 2183 0080 EF 15                   		mov.L	r1, r5
 2184                             		.loc 2 1163 8
 2185 0082 61 05                   		cmp	#0, r5
 2186 0084 21 40                   		bne	.L167
1164:../src/wolfcrypt/src/random.c ****                               heap, devId) != 0) {
1165:../src/wolfcrypt/src/random.c ****         goto exit_rng_ht;
1166:../src/wolfcrypt/src/random.c ****     }
1167:../src/wolfcrypt/src/random.c **** 
1168:../src/wolfcrypt/src/random.c ****     if (reseed) {
 2187                             		.loc 2 1168 8
 2188 0086 ED A5 03                		mov.L	12[r10], r5
 2189 0089 61 05                   		cmp	#0, r5
 2190 008b 20 13                   		beq	.L162
1169:../src/wolfcrypt/src/random.c ****         if (Hash_DRBG_Reseed(drbg, seedB, seedBSz) != 0) {
 2191                             		.loc 2 1169 13
 2192 008d A8 E3                   		mov.L	8[r6], r3
 2193 008f A8 6A                   		mov.L	4[r6], r2
 2194 0091 ED A1 01                		mov.L	4[r10], r1
 2195 0094 05 00 00 00             		bsr	_Hash_DRBG_Reseed
 2196 0098 EF 15                   		mov.L	r1, r5
 2197                             		.loc 2 1169 12
 2198 009a 61 05                   		cmp	#0, r5
 2199 009c 21 2A                   		bne	.L168
 2200                             	.L162:
1170:../src/wolfcrypt/src/random.c ****             goto exit_rng_ht;
1171:../src/wolfcrypt/src/random.c ****         }
1172:../src/wolfcrypt/src/random.c ****     }
1173:../src/wolfcrypt/src/random.c **** 
1174:../src/wolfcrypt/src/random.c ****     /* This call to generate is prescribed by the NIST DRBGVS
1175:../src/wolfcrypt/src/random.c ****      * procedure. The results are thrown away. The known
1176:../src/wolfcrypt/src/random.c ****      * answer test checks the second block of DRBG out of
1177:../src/wolfcrypt/src/random.c ****      * the generator to ensure the internal state is updated
1178:../src/wolfcrypt/src/random.c ****      * as expected. */
1179:../src/wolfcrypt/src/random.c ****     if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 2201                             		.loc 2 1179 9
 2202 009e A9 63                   		mov.L	16[r6], r3
 2203 00a0 A8 EA                   		mov.L	12[r6], r2
 2204 00a2 ED A1 01                		mov.L	4[r10], r1
 2205 00a5 05 00 00 00             		bsr	_Hash_DRBG_Generate
 2206 00a9 EF 15                   		mov.L	r1, r5
 2207                             		.loc 2 1179 8
 2208 00ab 61 05                   		cmp	#0, r5
 2209 00ad 21 1B                   		bne	.L169
1180:../src/wolfcrypt/src/random.c ****         goto exit_rng_ht;
1181:../src/wolfcrypt/src/random.c ****     }
1182:../src/wolfcrypt/src/random.c **** 
1183:../src/wolfcrypt/src/random.c ****     if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 2210                             		.loc 2 1183 9
 2211 00af A9 63                   		mov.L	16[r6], r3
 2212 00b1 A8 EA                   		mov.L	12[r6], r2
 2213 00b3 ED A1 01                		mov.L	4[r10], r1
 2214 00b6 05 00 00 00             		bsr	_Hash_DRBG_Generate
 2215 00ba EF 15                   		mov.L	r1, r5
 2216                             		.loc 2 1183 8
 2217 00bc 61 05                   		cmp	#0, r5
 2218 00be 21 0D                   		bne	.L170
1184:../src/wolfcrypt/src/random.c ****         goto exit_rng_ht;
1185:../src/wolfcrypt/src/random.c ****     }
1186:../src/wolfcrypt/src/random.c **** 
1187:../src/wolfcrypt/src/random.c ****     /* Mark success */
1188:../src/wolfcrypt/src/random.c ****     ret = 0;
 2219                             		.loc 2 1188 9
 2220 00c0 F8 A6 00                		mov.L	#0, [r10]
 2221 00c3 09                      		bra	.L161
 2222                             	.L167:
1165:../src/wolfcrypt/src/random.c ****     }
 2223                             		.loc 2 1165 9
 2224 00c4 03                      		nop
 2225 00c5 0F                      		bra	.L161
 2226                             	.L168:
1170:../src/wolfcrypt/src/random.c ****         }
 2227                             		.loc 2 1170 13
 2228 00c6 03                      		nop
 2229 00c7 0D                      		bra	.L161
 2230                             	.L169:
1180:../src/wolfcrypt/src/random.c ****     }
 2231                             		.loc 2 1180 9
 2232 00c8 03                      		nop
 2233 00c9 2E 03                   		bra	.L161
 2234                             	.L170:
1184:../src/wolfcrypt/src/random.c ****     }
 2235                             		.loc 2 1184 9
 2236 00cb 03                      		nop
 2237                             		.balign 8,3,1
 2238                             	.L161:
1189:../src/wolfcrypt/src/random.c **** 
1190:../src/wolfcrypt/src/random.c **** exit_rng_ht:
1191:../src/wolfcrypt/src/random.c **** 
1192:../src/wolfcrypt/src/random.c ****     /* This is safe to call even if Hash_DRBG_Instantiate fails */
1193:../src/wolfcrypt/src/random.c ****     if (Hash_DRBG_Uninstantiate(drbg) != 0) {
 2239                             		.loc 2 1193 9
 2240 00cc ED A1 01                		mov.L	4[r10], r1
 2241 00cf 05 00 00 00             		bsr	_Hash_DRBG_Uninstantiate
 2242 00d3 EF 15                   		mov.L	r1, r5
 2243                             		.loc 2 1193 8
 2244 00d5 61 05                   		cmp	#0, r5
 2245 00d7 14                      		beq	.L165
1194:../src/wolfcrypt/src/random.c ****         ret = -1;
 2246                             		.loc 2 1194 13
 2247 00d8 F8 A6 FF                		mov.L	#-1, [r10]
 2248                             	.L165:
 2249                             	.LBB12:
1195:../src/wolfcrypt/src/random.c ****     }
1196:../src/wolfcrypt/src/random.c **** 
1197:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK
1198:../src/wolfcrypt/src/random.c ****     XFREE(drbg, NULL, DYNAMIC_TYPE_RNG);
 2250                             		.loc 2 1198 5
 2251 00db ED A5 01                		mov.L	4[r10], r5
 2252 00de E7 A5 02                		mov.L	r5, 8[r10]
 2253 00e1 ED A5 02                		mov.L	8[r10], r5
 2254 00e4 61 05                   		cmp	#0, r5
 2255 00e6 10                      		beq	.L166
 2256                             		.loc 2 1198 5 is_stmt 0 discriminator 1
 2257 00e7 ED A1 02                		mov.L	8[r10], r1
 2258 00ea 05 00 00 00             		bsr	_wolfSSL_Free
 2259                             	.L166:
 2260                             	.LBE12:
1199:../src/wolfcrypt/src/random.c **** #endif
1200:../src/wolfcrypt/src/random.c **** 
1201:../src/wolfcrypt/src/random.c ****     return ret;
 2261                             		.loc 2 1201 12 is_stmt 1
 2262 00ee EC A5                   		mov.L	[r10], r5
 2263                             		.balign 8,3,1
 2264                             	.L156:
1202:../src/wolfcrypt/src/random.c **** }
 2265                             		.loc 2 1202 1
 2266 00f0 EF 51                   		mov.L	r5, r1
 2267 00f2 71 00 44                		add	#0x44, r0
 2268 00f5 7E B6                   		pop	r6
 2269 00f7 7E BA                   		pop	r10
 2270 00f9 02                      		rts
 2271                             	.LFE64:
 2273                             		.global	_seedA_data
 2274 00fa 74 10 01 00 00 00       		.section	.rodata.seedA_data,"a"
 2277                             	_seedA_data:
 2278 0000 63                      		.byte	0x63
 2279 0001 36                      		.byte	54
 2280 0002 33                      		.byte	51
 2281 0003 77                      		.byte	0x77
 2282 0004 E4                      		.byte	-28
 2283 0005 1E                      		.byte	30
 2284 0006 86                      		.byte	-122
 2285 0007 46                      		.byte	0x46
 2286 0008 8D                      		.byte	-115
 2287 0009 EB                      		.byte	-21
 2288 000a 0A                      		.byte	10
 2289 000b B4                      		.byte	-76
 2290 000c A8                      		.byte	-88
 2291 000d ED                      		.byte	-19
 2292 000e 68                      		.byte	0x68
 2293 000f 3F                      		.byte	63
 2294 0010 6A                      		.byte	0x6a
 2295 0011 13                      		.byte	19
 2296 0012 4E                      		.byte	0x4e
 2297 0013 47                      		.byte	0x47
 2298 0014 E0                      		.byte	-32
 2299 0015 14                      		.byte	20
 2300 0016 C7                      		.byte	-57
 2301 0017 00                      		.byte	0
 2302 0018 45                      		.byte	0x45
 2303 0019 4E                      		.byte	0x4e
 2304 001a 81                      		.byte	-127
 2305 001b E9                      		.byte	-23
 2306 001c 53                      		.byte	0x53
 2307 001d 58                      		.byte	0x58
 2308 001e A5                      		.byte	-91
 2309 001f 69                      		.byte	0x69
 2310 0020 80                      		.byte	-128
 2311 0021 8A                      		.byte	-118
 2312 0022 A3                      		.byte	-93
 2313 0023 8F                      		.byte	-113
 2314 0024 2A                      		.byte	42
 2315 0025 72                      		.byte	0x72
 2316 0026 A6                      		.byte	-90
 2317 0027 23                      		.byte	35
 2318 0028 59                      		.byte	0x59
 2319 0029 91                      		.byte	-111
 2320 002a 5A                      		.byte	0x5a
 2321 002b 9F                      		.byte	-97
 2322 002c 8A                      		.byte	-118
 2323 002d 04                      		.byte	4
 2324 002e CA                      		.byte	-54
 2325 002f 68                      		.byte	0x68
 2326                             		.global	_reseedSeedA_data
 2327                             		.section	.rodata.reseedSeedA_data,"a"
 2330                             	_reseedSeedA_data:
 2331 0000 E6                      		.byte	-26
 2332 0001 2B                      		.byte	43
 2333 0002 8A                      		.byte	-118
 2334 0003 8E                      		.byte	-114
 2335 0004 E8                      		.byte	-24
 2336 0005 F1                      		.byte	-15
 2337 0006 41                      		.byte	0x41
 2338 0007 B6                      		.byte	-74
 2339 0008 98                      		.byte	-104
 2340 0009 05                      		.byte	5
 2341 000a 66                      		.byte	0x66
 2342 000b E3                      		.byte	-29
 2343 000c BF                      		.byte	-65
 2344 000d E3                      		.byte	-29
 2345 000e C0                      		.byte	-64
 2346 000f 49                      		.byte	0x49
 2347 0010 03                      		.byte	3
 2348 0011 DA                      		.byte	-38
 2349 0012 D4                      		.byte	-44
 2350 0013 AC                      		.byte	-84
 2351 0014 2C                      		.byte	44
 2352 0015 DF                      		.byte	-33
 2353 0016 9F                      		.byte	-97
 2354 0017 22                      		.byte	34
 2355 0018 80                      		.byte	-128
 2356 0019 01                      		.byte	1
 2357 001a 0A                      		.byte	10
 2358 001b 67                      		.byte	0x67
 2359 001c 39                      		.byte	57
 2360 001d BC                      		.byte	-68
 2361 001e 83                      		.byte	-125
 2362 001f D3                      		.byte	-45
 2363                             		.global	_outputA_data
 2364                             		.section	.rodata.outputA_data,"a"
 2367                             	_outputA_data:
 2368 0000 04                      		.byte	4
 2369 0001 EE                      		.byte	-18
 2370 0002 C6                      		.byte	-58
 2371 0003 3B                      		.byte	59
 2372 0004 B2                      		.byte	-78
 2373 0005 31                      		.byte	49
 2374 0006 DF                      		.byte	-33
 2375 0007 2C                      		.byte	44
 2376 0008 63                      		.byte	0x63
 2377 0009 0A                      		.byte	10
 2378 000a 1A                      		.byte	26
 2379 000b FB                      		.byte	-5
 2380 000c E7                      		.byte	-25
 2381 000d 24                      		.byte	36
 2382 000e 94                      		.byte	-108
 2383 000f 9D                      		.byte	-99
 2384 0010 00                      		.byte	0
 2385 0011 5A                      		.byte	0x5a
 2386 0012 58                      		.byte	0x58
 2387 0013 78                      		.byte	0x78
 2388 0014 51                      		.byte	0x51
 2389 0015 E1                      		.byte	-31
 2390 0016 AA                      		.byte	-86
 2391 0017 79                      		.byte	0x79
 2392 0018 5E                      		.byte	0x5e
 2393 0019 47                      		.byte	0x47
 2394 001a 73                      		.byte	0x73
 2395 001b 47                      		.byte	0x47
 2396 001c C8                      		.byte	-56
 2397 001d B0                      		.byte	-80
 2398 001e 56                      		.byte	0x56
 2399 001f 62                      		.byte	0x62
 2400 0020 1C                      		.byte	28
 2401 0021 18                      		.byte	24
 2402 0022 BD                      		.byte	-67
 2403 0023 DC                      		.byte	-36
 2404 0024 DD                      		.byte	-35
 2405 0025 8D                      		.byte	-115
 2406 0026 99                      		.byte	-103
 2407 0027 FC                      		.byte	-4
 2408 0028 5F                      		.byte	0x5f
 2409 0029 C2                      		.byte	-62
 2410 002a B9                      		.byte	-71
 2411 002b 20                      		.byte	32
 2412 002c 53                      		.byte	0x53
 2413 002d D8                      		.byte	-40
 2414 002e CF                      		.byte	-49
 2415 002f AC                      		.byte	-84
 2416 0030 FB                      		.byte	-5
 2417 0031 0B                      		.byte	11
 2418 0032 B8                      		.byte	-72
 2419 0033 83                      		.byte	-125
 2420 0034 12                      		.byte	18
 2421 0035 05                      		.byte	5
 2422 0036 FA                      		.byte	-6
 2423 0037 D1                      		.byte	-47
 2424 0038 DD                      		.byte	-35
 2425 0039 D6                      		.byte	-42
 2426 003a C0                      		.byte	-64
 2427 003b 71                      		.byte	0x71
 2428 003c 31                      		.byte	49
 2429 003d 8A                      		.byte	-118
 2430 003e 60                      		.byte	0x60
 2431 003f 18                      		.byte	24
 2432 0040 F0                      		.byte	-16
 2433 0041 3B                      		.byte	59
 2434 0042 73                      		.byte	0x73
 2435 0043 F5                      		.byte	-11
 2436 0044 ED                      		.byte	-19
 2437 0045 E4                      		.byte	-28
 2438 0046 D4                      		.byte	-44
 2439 0047 D0                      		.byte	-48
 2440 0048 71                      		.byte	0x71
 2441 0049 F9                      		.byte	-7
 2442 004a DE                      		.byte	-34
 2443 004b 03                      		.byte	3
 2444 004c FD                      		.byte	-3
 2445 004d 7A                      		.byte	0x7a
 2446 004e EA                      		.byte	-22
 2447 004f 10                      		.byte	16
 2448 0050 5D                      		.byte	0x5d
 2449 0051 92                      		.byte	-110
 2450 0052 99                      		.byte	-103
 2451 0053 B8                      		.byte	-72
 2452 0054 AF                      		.byte	-81
 2453 0055 99                      		.byte	-103
 2454 0056 AA                      		.byte	-86
 2455 0057 07                      		.byte	7
 2456 0058 5B                      		.byte	0x5b
 2457 0059 DB                      		.byte	-37
 2458 005a 4D                      		.byte	0x4d
 2459 005b B9                      		.byte	-71
 2460 005c AA                      		.byte	-86
 2461 005d 28                      		.byte	40
 2462 005e C1                      		.byte	-63
 2463 005f 8D                      		.byte	-115
 2464 0060 17                      		.byte	23
 2465 0061 4B                      		.byte	0x4b
 2466 0062 56                      		.byte	0x56
 2467 0063 EE                      		.byte	-18
 2468 0064 2A                      		.byte	42
 2469 0065 01                      		.byte	1
 2470 0066 4D                      		.byte	0x4d
 2471 0067 09                      		.byte	9
 2472 0068 88                      		.byte	-120
 2473 0069 96                      		.byte	-106
 2474 006a FF                      		.byte	-1
 2475 006b 22                      		.byte	34
 2476 006c 82                      		.byte	-126
 2477 006d C9                      		.byte	-55
 2478 006e 55                      		.byte	0x55
 2479 006f A8                      		.byte	-88
 2480 0070 19                      		.byte	25
 2481 0071 69                      		.byte	0x69
 2482 0072 E0                      		.byte	-32
 2483 0073 69                      		.byte	0x69
 2484 0074 FA                      		.byte	-6
 2485 0075 8C                      		.byte	-116
 2486 0076 E0                      		.byte	-32
 2487 0077 07                      		.byte	7
 2488 0078 A1                      		.byte	-95
 2489 0079 80                      		.byte	-128
 2490 007a 18                      		.byte	24
 2491 007b 3A                      		.byte	58
 2492 007c 07                      		.byte	7
 2493 007d DF                      		.byte	-33
 2494 007e AE                      		.byte	-82
 2495 007f 17                      		.byte	23
 2496                             		.global	_seedB_data
 2497                             		.section	.rodata.seedB_data,"a"
 2500                             	_seedB_data:
 2501 0000 A6                      		.byte	-90
 2502 0001 5A                      		.byte	0x5a
 2503 0002 D0                      		.byte	-48
 2504 0003 F3                      		.byte	-13
 2505 0004 45                      		.byte	0x45
 2506 0005 DB                      		.byte	-37
 2507 0006 4E                      		.byte	0x4e
 2508 0007 0E                      		.byte	14
 2509 0008 FF                      		.byte	-1
 2510 0009 E8                      		.byte	-24
 2511 000a 75                      		.byte	0x75
 2512 000b C3                      		.byte	-61
 2513 000c A2                      		.byte	-94
 2514 000d E7                      		.byte	-25
 2515 000e 1F                      		.byte	31
 2516 000f 42                      		.byte	0x42
 2517 0010 C7                      		.byte	-57
 2518 0011 12                      		.byte	18
 2519 0012 9D                      		.byte	-99
 2520 0013 62                      		.byte	0x62
 2521 0014 0F                      		.byte	15
 2522 0015 F5                      		.byte	-11
 2523 0016 C1                      		.byte	-63
 2524 0017 19                      		.byte	25
 2525 0018 A9                      		.byte	-87
 2526 0019 EF                      		.byte	-17
 2527 001a 55                      		.byte	0x55
 2528 001b F0                      		.byte	-16
 2529 001c 51                      		.byte	0x51
 2530 001d 85                      		.byte	-123
 2531 001e E0                      		.byte	-32
 2532 001f FB                      		.byte	-5
 2533 0020 85                      		.byte	-123
 2534 0021 81                      		.byte	-127
 2535 0022 F9                      		.byte	-7
 2536 0023 31                      		.byte	49
 2537 0024 75                      		.byte	0x75
 2538 0025 17                      		.byte	23
 2539 0026 27                      		.byte	39
 2540 0027 6E                      		.byte	0x6e
 2541 0028 06                      		.byte	6
 2542 0029 E9                      		.byte	-23
 2543 002a 60                      		.byte	0x60
 2544 002b 7D                      		.byte	0x7d
 2545 002c DB                      		.byte	-37
 2546 002d CB                      		.byte	-53
 2547 002e CC                      		.byte	-52
 2548 002f 2E                      		.byte	46
 2549                             		.global	_outputB_data
 2550                             		.section	.rodata.outputB_data,"a"
 2553                             	_outputB_data:
 2554 0000 D3                      		.byte	-45
 2555 0001 E1                      		.byte	-31
 2556 0002 60                      		.byte	0x60
 2557 0003 C3                      		.byte	-61
 2558 0004 5B                      		.byte	0x5b
 2559 0005 99                      		.byte	-103
 2560 0006 F3                      		.byte	-13
 2561 0007 40                      		.byte	0x40
 2562 0008 B2                      		.byte	-78
 2563 0009 62                      		.byte	0x62
 2564 000a 82                      		.byte	-126
 2565 000b 64                      		.byte	0x64
 2566 000c D1                      		.byte	-47
 2567 000d 75                      		.byte	0x75
 2568 000e 10                      		.byte	16
 2569 000f 60                      		.byte	0x60
 2570 0010 E0                      		.byte	-32
 2571 0011 04                      		.byte	4
 2572 0012 5D                      		.byte	0x5d
 2573 0013 A3                      		.byte	-93
 2574 0014 83                      		.byte	-125
 2575 0015 FF                      		.byte	-1
 2576 0016 57                      		.byte	0x57
 2577 0017 A5                      		.byte	-91
 2578 0018 7D                      		.byte	0x7d
 2579 0019 73                      		.byte	0x73
 2580 001a A6                      		.byte	-90
 2581 001b 73                      		.byte	0x73
 2582 001c D2                      		.byte	-46
 2583 001d B8                      		.byte	-72
 2584 001e D8                      		.byte	-40
 2585 001f 0D                      		.byte	13
 2586 0020 AA                      		.byte	-86
 2587 0021 F6                      		.byte	-10
 2588 0022 A6                      		.byte	-90
 2589 0023 C3                      		.byte	-61
 2590 0024 5A                      		.byte	0x5a
 2591 0025 91                      		.byte	-111
 2592 0026 BB                      		.byte	-69
 2593 0027 45                      		.byte	0x45
 2594 0028 79                      		.byte	0x79
 2595 0029 D7                      		.byte	-41
 2596 002a 3F                      		.byte	63
 2597 002b D0                      		.byte	-48
 2598 002c C8                      		.byte	-56
 2599 002d FE                      		.byte	-2
 2600 002e D1                      		.byte	-47
 2601 002f 11                      		.byte	17
 2602 0030 B0                      		.byte	-80
 2603 0031 39                      		.byte	57
 2604 0032 13                      		.byte	19
 2605 0033 06                      		.byte	6
 2606 0034 82                      		.byte	-126
 2607 0035 8A                      		.byte	-118
 2608 0036 DF                      		.byte	-33
 2609 0037 ED                      		.byte	-19
 2610 0038 52                      		.byte	0x52
 2611 0039 8F                      		.byte	-113
 2612 003a 01                      		.byte	1
 2613 003b 81                      		.byte	-127
 2614 003c 21                      		.byte	33
 2615 003d B3                      		.byte	-77
 2616 003e FE                      		.byte	-2
 2617 003f BD                      		.byte	-67
 2618 0040 C3                      		.byte	-61
 2619 0041 43                      		.byte	0x43
 2620 0042 E7                      		.byte	-25
 2621 0043 97                      		.byte	-105
 2622 0044 B8                      		.byte	-72
 2623 0045 7D                      		.byte	0x7d
 2624 0046 BB                      		.byte	-69
 2625 0047 63                      		.byte	0x63
 2626 0048 DB                      		.byte	-37
 2627 0049 13                      		.byte	19
 2628 004a 33                      		.byte	51
 2629 004b DE                      		.byte	-34
 2630 004c D9                      		.byte	-39
 2631 004d D1                      		.byte	-47
 2632 004e EC                      		.byte	-20
 2633 004f E1                      		.byte	-31
 2634 0050 77                      		.byte	0x77
 2635 0051 CF                      		.byte	-49
 2636 0052 A6                      		.byte	-90
 2637 0053 B7                      		.byte	-73
 2638 0054 1F                      		.byte	31
 2639 0055 E8                      		.byte	-24
 2640 0056 AB                      		.byte	-85
 2641 0057 1D                      		.byte	29
 2642 0058 A4                      		.byte	-92
 2643 0059 66                      		.byte	0x66
 2644 005a 24                      		.byte	36
 2645 005b ED                      		.byte	-19
 2646 005c 64                      		.byte	0x64
 2647 005d 15                      		.byte	21
 2648 005e E5                      		.byte	-27
 2649 005f 1C                      		.byte	28
 2650 0060 CD                      		.byte	-51
 2651 0061 E2                      		.byte	-30
 2652 0062 C7                      		.byte	-57
 2653 0063 CA                      		.byte	-54
 2654 0064 86                      		.byte	-122
 2655 0065 E2                      		.byte	-30
 2656 0066 83                      		.byte	-125
 2657 0067 99                      		.byte	-103
 2658 0068 0E                      		.byte	14
 2659 0069 EA                      		.byte	-22
 2660 006a EB                      		.byte	-21
 2661 006b 91                      		.byte	-111
 2662 006c 12                      		.byte	18
 2663 006d 04                      		.byte	4
 2664 006e 15                      		.byte	21
 2665 006f 52                      		.byte	0x52
 2666 0070 8B                      		.byte	-117
 2667 0071 22                      		.byte	34
 2668 0072 95                      		.byte	-107
 2669 0073 91                      		.byte	-111
 2670 0074 02                      		.byte	2
 2671 0075 81                      		.byte	-127
 2672 0076 B0                      		.byte	-80
 2673 0077 2D                      		.byte	45
 2674 0078 D4                      		.byte	-44
 2675 0079 31                      		.byte	49
 2676 007a F4                      		.byte	-12
 2677 007b C9                      		.byte	-55
 2678 007c F7                      		.byte	-9
 2679 007d 04                      		.byte	4
 2680 007e 27                      		.byte	39
 2681 007f DF                      		.byte	-33
 2682                             		.section	.text.wc_RNG_HealthTestLocal,"ax",@progbits
 2684                             	_wc_RNG_HealthTestLocal:
 2685                             	.LFB65:
1203:../src/wolfcrypt/src/random.c **** 
1204:../src/wolfcrypt/src/random.c **** 
1205:../src/wolfcrypt/src/random.c **** const FLASH_QUALIFIER byte seedA_data[] = {
1206:../src/wolfcrypt/src/random.c ****     0x63, 0x36, 0x33, 0x77, 0xe4, 0x1e, 0x86, 0x46, 0x8d, 0xeb, 0x0a, 0xb4,
1207:../src/wolfcrypt/src/random.c ****     0xa8, 0xed, 0x68, 0x3f, 0x6a, 0x13, 0x4e, 0x47, 0xe0, 0x14, 0xc7, 0x00,
1208:../src/wolfcrypt/src/random.c ****     0x45, 0x4e, 0x81, 0xe9, 0x53, 0x58, 0xa5, 0x69, 0x80, 0x8a, 0xa3, 0x8f,
1209:../src/wolfcrypt/src/random.c ****     0x2a, 0x72, 0xa6, 0x23, 0x59, 0x91, 0x5a, 0x9f, 0x8a, 0x04, 0xca, 0x68
1210:../src/wolfcrypt/src/random.c **** };
1211:../src/wolfcrypt/src/random.c **** 
1212:../src/wolfcrypt/src/random.c **** const FLASH_QUALIFIER byte reseedSeedA_data[] = {
1213:../src/wolfcrypt/src/random.c ****     0xe6, 0x2b, 0x8a, 0x8e, 0xe8, 0xf1, 0x41, 0xb6, 0x98, 0x05, 0x66, 0xe3,
1214:../src/wolfcrypt/src/random.c ****     0xbf, 0xe3, 0xc0, 0x49, 0x03, 0xda, 0xd4, 0xac, 0x2c, 0xdf, 0x9f, 0x22,
1215:../src/wolfcrypt/src/random.c ****     0x80, 0x01, 0x0a, 0x67, 0x39, 0xbc, 0x83, 0xd3
1216:../src/wolfcrypt/src/random.c **** };
1217:../src/wolfcrypt/src/random.c **** 
1218:../src/wolfcrypt/src/random.c **** const FLASH_QUALIFIER byte outputA_data[] = {
1219:../src/wolfcrypt/src/random.c ****     0x04, 0xee, 0xc6, 0x3b, 0xb2, 0x31, 0xdf, 0x2c, 0x63, 0x0a, 0x1a, 0xfb,
1220:../src/wolfcrypt/src/random.c ****     0xe7, 0x24, 0x94, 0x9d, 0x00, 0x5a, 0x58, 0x78, 0x51, 0xe1, 0xaa, 0x79,
1221:../src/wolfcrypt/src/random.c ****     0x5e, 0x47, 0x73, 0x47, 0xc8, 0xb0, 0x56, 0x62, 0x1c, 0x18, 0xbd, 0xdc,
1222:../src/wolfcrypt/src/random.c ****     0xdd, 0x8d, 0x99, 0xfc, 0x5f, 0xc2, 0xb9, 0x20, 0x53, 0xd8, 0xcf, 0xac,
1223:../src/wolfcrypt/src/random.c ****     0xfb, 0x0b, 0xb8, 0x83, 0x12, 0x05, 0xfa, 0xd1, 0xdd, 0xd6, 0xc0, 0x71,
1224:../src/wolfcrypt/src/random.c ****     0x31, 0x8a, 0x60, 0x18, 0xf0, 0x3b, 0x73, 0xf5, 0xed, 0xe4, 0xd4, 0xd0,
1225:../src/wolfcrypt/src/random.c ****     0x71, 0xf9, 0xde, 0x03, 0xfd, 0x7a, 0xea, 0x10, 0x5d, 0x92, 0x99, 0xb8,
1226:../src/wolfcrypt/src/random.c ****     0xaf, 0x99, 0xaa, 0x07, 0x5b, 0xdb, 0x4d, 0xb9, 0xaa, 0x28, 0xc1, 0x8d,
1227:../src/wolfcrypt/src/random.c ****     0x17, 0x4b, 0x56, 0xee, 0x2a, 0x01, 0x4d, 0x09, 0x88, 0x96, 0xff, 0x22,
1228:../src/wolfcrypt/src/random.c ****     0x82, 0xc9, 0x55, 0xa8, 0x19, 0x69, 0xe0, 0x69, 0xfa, 0x8c, 0xe0, 0x07,
1229:../src/wolfcrypt/src/random.c ****     0xa1, 0x80, 0x18, 0x3a, 0x07, 0xdf, 0xae, 0x17
1230:../src/wolfcrypt/src/random.c **** };
1231:../src/wolfcrypt/src/random.c **** 
1232:../src/wolfcrypt/src/random.c **** const FLASH_QUALIFIER byte seedB_data[] = {
1233:../src/wolfcrypt/src/random.c ****     0xa6, 0x5a, 0xd0, 0xf3, 0x45, 0xdb, 0x4e, 0x0e, 0xff, 0xe8, 0x75, 0xc3,
1234:../src/wolfcrypt/src/random.c ****     0xa2, 0xe7, 0x1f, 0x42, 0xc7, 0x12, 0x9d, 0x62, 0x0f, 0xf5, 0xc1, 0x19,
1235:../src/wolfcrypt/src/random.c ****     0xa9, 0xef, 0x55, 0xf0, 0x51, 0x85, 0xe0, 0xfb, /* nonce next */
1236:../src/wolfcrypt/src/random.c ****     0x85, 0x81, 0xf9, 0x31, 0x75, 0x17, 0x27, 0x6e, 0x06, 0xe9, 0x60, 0x7d,
1237:../src/wolfcrypt/src/random.c ****     0xdb, 0xcb, 0xcc, 0x2e
1238:../src/wolfcrypt/src/random.c **** };
1239:../src/wolfcrypt/src/random.c **** 
1240:../src/wolfcrypt/src/random.c **** const FLASH_QUALIFIER byte outputB_data[] = {
1241:../src/wolfcrypt/src/random.c ****     0xd3, 0xe1, 0x60, 0xc3, 0x5b, 0x99, 0xf3, 0x40, 0xb2, 0x62, 0x82, 0x64,
1242:../src/wolfcrypt/src/random.c ****     0xd1, 0x75, 0x10, 0x60, 0xe0, 0x04, 0x5d, 0xa3, 0x83, 0xff, 0x57, 0xa5,
1243:../src/wolfcrypt/src/random.c ****     0x7d, 0x73, 0xa6, 0x73, 0xd2, 0xb8, 0xd8, 0x0d, 0xaa, 0xf6, 0xa6, 0xc3,
1244:../src/wolfcrypt/src/random.c ****     0x5a, 0x91, 0xbb, 0x45, 0x79, 0xd7, 0x3f, 0xd0, 0xc8, 0xfe, 0xd1, 0x11,
1245:../src/wolfcrypt/src/random.c ****     0xb0, 0x39, 0x13, 0x06, 0x82, 0x8a, 0xdf, 0xed, 0x52, 0x8f, 0x01, 0x81,
1246:../src/wolfcrypt/src/random.c ****     0x21, 0xb3, 0xfe, 0xbd, 0xc3, 0x43, 0xe7, 0x97, 0xb8, 0x7d, 0xbb, 0x63,
1247:../src/wolfcrypt/src/random.c ****     0xdb, 0x13, 0x33, 0xde, 0xd9, 0xd1, 0xec, 0xe1, 0x77, 0xcf, 0xa6, 0xb7,
1248:../src/wolfcrypt/src/random.c ****     0x1f, 0xe8, 0xab, 0x1d, 0xa4, 0x66, 0x24, 0xed, 0x64, 0x15, 0xe5, 0x1c,
1249:../src/wolfcrypt/src/random.c ****     0xcd, 0xe2, 0xc7, 0xca, 0x86, 0xe2, 0x83, 0x99, 0x0e, 0xea, 0xeb, 0x91,
1250:../src/wolfcrypt/src/random.c ****     0x12, 0x04, 0x15, 0x52, 0x8b, 0x22, 0x95, 0x91, 0x02, 0x81, 0xb0, 0x2d,
1251:../src/wolfcrypt/src/random.c ****     0xd4, 0x31, 0xf4, 0xc9, 0xf7, 0x04, 0x27, 0xdf
1252:../src/wolfcrypt/src/random.c **** };
1253:../src/wolfcrypt/src/random.c **** 
1254:../src/wolfcrypt/src/random.c **** 
1255:../src/wolfcrypt/src/random.c **** static int wc_RNG_HealthTestLocal(int reseed)
1256:../src/wolfcrypt/src/random.c **** {
 2686                             		.loc 2 1256 1
 2687 0000 7E AA                   		push.l	r10
 2688                             	.LCFI68:
 2689 0002 71 0A DC                		add	#-36, r0, r10
 2690                             	.LCFI69:
 2691 0005 71 A0 E4                		add	#-28, r10, r0
 2692                             	.LCFI70:
 2693 0008 E7 A1 08                		mov.L	r1, 32[r10]
1257:../src/wolfcrypt/src/random.c ****     int ret = 0;
 2694                             		.loc 2 1257 9
 2695 000b F8 A6 00                		mov.L	#0, [r10]
1258:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK
1259:../src/wolfcrypt/src/random.c ****     byte* check;
1260:../src/wolfcrypt/src/random.c **** #else
1261:../src/wolfcrypt/src/random.c ****     byte  check[RNG_HEALTH_TEST_CHECK_SIZE];
1262:../src/wolfcrypt/src/random.c **** #endif
1263:../src/wolfcrypt/src/random.c **** 
1264:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK
1265:../src/wolfcrypt/src/random.c ****     check = (byte*)XMALLOC(RNG_HEALTH_TEST_CHECK_SIZE, NULL,
 2696                             		.loc 2 1265 20
 2697 000e 75 41 80                		mov.L	#0x80, r1
 2698 0011 05 00 00 00             		bsr	_wolfSSL_Malloc
 2699 0015 E7 A1 01                		mov.L	r1, 4[r10]
1266:../src/wolfcrypt/src/random.c ****                            DYNAMIC_TYPE_TMP_BUFFER);
1267:../src/wolfcrypt/src/random.c ****     if (check == NULL) {
 2700                             		.loc 2 1267 8
 2701 0018 ED A5 01                		mov.L	4[r10], r5
 2702 001b 61 05                   		cmp	#0, r5
 2703 001d 1F                      		bne	.L172
1268:../src/wolfcrypt/src/random.c ****         return MEMORY_E;
 2704                             		.loc 2 1268 16
 2705 001e FB 56 83                		mov.L	#-125, r5
 2706 0021 38 04 01                		bra	.L173
 2707                             	.L172:
1269:../src/wolfcrypt/src/random.c ****     }
1270:../src/wolfcrypt/src/random.c **** #endif
1271:../src/wolfcrypt/src/random.c **** 
1272:../src/wolfcrypt/src/random.c ****     if (reseed) {
 2708                             		.loc 2 1272 8
 2709 0024 ED A5 08                		mov.L	32[r10], r5
 2710 0027 61 05                   		cmp	#0, r5
 2711 0029 20 54                   		beq	.L174
 2712                             	.LBB13:
1273:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_USE_FLASHMEM
1274:../src/wolfcrypt/src/random.c ****         byte* seedA = (byte*)XMALLOC(sizeof(seedA_data), NULL,
1275:../src/wolfcrypt/src/random.c ****                              DYNAMIC_TYPE_TMP_BUFFER);
1276:../src/wolfcrypt/src/random.c ****         byte* reseedSeedA = (byte*)XMALLOC(sizeof(reseedSeedA_data), NULL,
1277:../src/wolfcrypt/src/random.c ****                              DYNAMIC_TYPE_TMP_BUFFER);
1278:../src/wolfcrypt/src/random.c ****         byte* outputA = (byte*)XMALLOC(sizeof(outputA_data), NULL,
1279:../src/wolfcrypt/src/random.c ****                              DYNAMIC_TYPE_TMP_BUFFER);
1280:../src/wolfcrypt/src/random.c **** 
1281:../src/wolfcrypt/src/random.c ****         if (!seedA || !reseedSeedA || !outputA) {
1282:../src/wolfcrypt/src/random.c ****             XFREE(seedA, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1283:../src/wolfcrypt/src/random.c ****             XFREE(reseedSeedA, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1284:../src/wolfcrypt/src/random.c ****             XFREE(outputA, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1285:../src/wolfcrypt/src/random.c ****             ret = MEMORY_E;
1286:../src/wolfcrypt/src/random.c ****         }
1287:../src/wolfcrypt/src/random.c ****         else {
1288:../src/wolfcrypt/src/random.c ****             XMEMCPY_P(seedA, seedA_data, sizeof(seedA_data));
1289:../src/wolfcrypt/src/random.c ****             XMEMCPY_P(reseedSeedA, reseedSeedA_data, sizeof(reseedSeedA_data));
1290:../src/wolfcrypt/src/random.c ****             XMEMCPY_P(outputA, outputA_data, sizeof(outputA_data));
1291:../src/wolfcrypt/src/random.c **** #else
1292:../src/wolfcrypt/src/random.c ****         const byte* seedA = seedA_data;
 2713                             		.loc 2 1292 21
 2714 002b F9 A2 02 00 00 00 00    		mov.L	#_seedA_data, 8[r10]
1293:../src/wolfcrypt/src/random.c ****         const byte* reseedSeedA = reseedSeedA_data;
 2715                             		.loc 2 1293 21
 2716 0032 F9 A2 03 00 00 00 00    		mov.L	#_reseedSeedA_data, 12[r10]
1294:../src/wolfcrypt/src/random.c ****         const byte* outputA = outputA_data;
 2717                             		.loc 2 1294 21
 2718 0039 F9 A2 04 00 00 00 00    		mov.L	#_outputA_data, 16[r10]
1295:../src/wolfcrypt/src/random.c **** #endif
1296:../src/wolfcrypt/src/random.c ****         ret = wc_RNG_HealthTest(1, seedA, sizeof(seedA_data),
 2719                             		.loc 2 1296 15
 2720 0040 3E 02 80                		mov.L	#0x80, 8[r0]
 2721 0043 ED A5 01                		mov.L	4[r10], r5
 2722 0046 A0 0D                   		mov.L	r5, 4[r0]
 2723 0048 F8 06 20                		mov.L	#32, [r0]
 2724 004b ED A4 03                		mov.L	12[r10], r4
 2725 004e 75 43 30                		mov.L	#48, r3
 2726 0051 ED A2 02                		mov.L	8[r10], r2
 2727 0054 66 11                   		mov.L	#1, r1
 2728 0056 05 00 00 00             		bsr	_wc_RNG_HealthTest
 2729 005a E3 A1                   		mov.L	r1, [r10]
1297:../src/wolfcrypt/src/random.c ****                                 reseedSeedA, sizeof(reseedSeedA_data),
1298:../src/wolfcrypt/src/random.c ****                                 check, RNG_HEALTH_TEST_CHECK_SIZE);
1299:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
 2730                             		.loc 2 1299 12
 2731 005c EC A5                   		mov.L	[r10], r5
 2732 005e 61 05                   		cmp	#0, r5
 2733 0060 3B B0 00                		bne	.L176
1300:../src/wolfcrypt/src/random.c ****             if (ConstantCompare(check, outputA,
 2734                             		.loc 2 1300 17
 2735 0063 75 43 80                		mov.L	#0x80, r3
 2736 0066 ED A2 04                		mov.L	16[r10], r2
 2737 0069 ED A1 01                		mov.L	4[r10], r1
 2738 006c 05 00 00 00             		bsr	_ConstantCompare
 2739 0070 EF 15                   		mov.L	r1, r5
 2740                             		.loc 2 1300 16
 2741 0072 61 05                   		cmp	#0, r5
 2742 0074 3A 9C 00                		beq	.L176
1301:../src/wolfcrypt/src/random.c ****                                 RNG_HEALTH_TEST_CHECK_SIZE) != 0)
1302:../src/wolfcrypt/src/random.c ****                 ret = -1;
 2743                             		.loc 2 1302 21
 2744 0077 F8 A6 FF                		mov.L	#-1, [r10]
 2745 007a 38 96 00                		bra	.L176
 2746                             	.L174:
 2747                             	.LBE13:
 2748                             	.LBB14:
1303:../src/wolfcrypt/src/random.c ****         }
1304:../src/wolfcrypt/src/random.c **** 
1305:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_USE_FLASHMEM
1306:../src/wolfcrypt/src/random.c ****             XFREE(seedA, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1307:../src/wolfcrypt/src/random.c ****             XFREE(reseedSeedA, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1308:../src/wolfcrypt/src/random.c ****             XFREE(outputA, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1309:../src/wolfcrypt/src/random.c ****         }
1310:../src/wolfcrypt/src/random.c **** #endif
1311:../src/wolfcrypt/src/random.c ****     }
1312:../src/wolfcrypt/src/random.c ****     else {
1313:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_USE_FLASHMEM
1314:../src/wolfcrypt/src/random.c ****         byte* seedB = (byte*)XMALLOC(sizeof(seedB_data), NULL,
1315:../src/wolfcrypt/src/random.c ****                              DYNAMIC_TYPE_TMP_BUFFER);
1316:../src/wolfcrypt/src/random.c ****         byte* outputB = (byte*)XMALLOC(sizeof(outputB_data), NULL,
1317:../src/wolfcrypt/src/random.c ****                                DYNAMIC_TYPE_TMP_BUFFER);
1318:../src/wolfcrypt/src/random.c **** 
1319:../src/wolfcrypt/src/random.c ****         if (!seedB || !outputB) {
1320:../src/wolfcrypt/src/random.c ****             XFREE(seedB, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1321:../src/wolfcrypt/src/random.c ****             XFREE(outputB, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1322:../src/wolfcrypt/src/random.c ****             ret = MEMORY_E;
1323:../src/wolfcrypt/src/random.c ****         }
1324:../src/wolfcrypt/src/random.c ****         else {
1325:../src/wolfcrypt/src/random.c ****             XMEMCPY_P(seedB, seedB_data, sizeof(seedB_data));
1326:../src/wolfcrypt/src/random.c ****             XMEMCPY_P(outputB, outputB_data, sizeof(outputB_data));
1327:../src/wolfcrypt/src/random.c **** #else
1328:../src/wolfcrypt/src/random.c ****         const byte* seedB = seedB_data;
 2749                             		.loc 2 1328 21
 2750 007d F9 A2 05 00 00 00 00    		mov.L	#_seedB_data, 20[r10]
1329:../src/wolfcrypt/src/random.c ****         const byte* outputB = outputB_data;
 2751                             		.loc 2 1329 21
 2752 0084 F9 A2 06 00 00 00 00    		mov.L	#_outputB_data, 24[r10]
1330:../src/wolfcrypt/src/random.c **** #endif
1331:../src/wolfcrypt/src/random.c ****         ret = wc_RNG_HealthTest(0, seedB, sizeof(seedB_data),
 2753                             		.loc 2 1331 15
 2754 008b 3E 02 80                		mov.L	#0x80, 8[r0]
 2755 008e ED A5 01                		mov.L	4[r10], r5
 2756 0091 A0 0D                   		mov.L	r5, 4[r0]
 2757 0093 F8 06 00                		mov.L	#0, [r0]
 2758 0096 66 04                   		mov.L	#0, r4
 2759 0098 75 43 30                		mov.L	#48, r3
 2760 009b ED A2 05                		mov.L	20[r10], r2
 2761 009e 66 01                   		mov.L	#0, r1
 2762 00a0 05 00 00 00             		bsr	_wc_RNG_HealthTest
 2763 00a4 E3 A1                   		mov.L	r1, [r10]
1332:../src/wolfcrypt/src/random.c ****                                 NULL, 0,
1333:../src/wolfcrypt/src/random.c ****                                 check, RNG_HEALTH_TEST_CHECK_SIZE);
1334:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
 2764                             		.loc 2 1334 12
 2765 00a6 EC A5                   		mov.L	[r10], r5
 2766 00a8 61 05                   		cmp	#0, r5
 2767 00aa 21 17                   		bne	.L177
1335:../src/wolfcrypt/src/random.c ****             if (ConstantCompare(check, outputB,
 2768                             		.loc 2 1335 17
 2769 00ac 75 43 80                		mov.L	#0x80, r3
 2770 00af ED A2 06                		mov.L	24[r10], r2
 2771 00b2 ED A1 01                		mov.L	4[r10], r1
 2772 00b5 05 00 00 00             		bsr	_ConstantCompare
 2773 00b9 EF 15                   		mov.L	r1, r5
 2774                             		.loc 2 1335 16
 2775 00bb 61 05                   		cmp	#0, r5
 2776 00bd 14                      		beq	.L177
1336:../src/wolfcrypt/src/random.c ****                                 RNG_HEALTH_TEST_CHECK_SIZE) != 0)
1337:../src/wolfcrypt/src/random.c ****                 ret = -1;
 2777                             		.loc 2 1337 21
 2778 00be F8 A6 FF                		mov.L	#-1, [r10]
 2779                             	.L177:
1338:../src/wolfcrypt/src/random.c ****         }
1339:../src/wolfcrypt/src/random.c **** 
1340:../src/wolfcrypt/src/random.c ****         /* The previous test cases use a large seed instead of a seed and nonce.
1341:../src/wolfcrypt/src/random.c ****          * seedB is actually from a test case with a seed and nonce, and
1342:../src/wolfcrypt/src/random.c ****          * just concatenates them. The pivot point between seed and nonce is
1343:../src/wolfcrypt/src/random.c ****          * byte 32, feed them into the health test separately. */
1344:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
 2780                             		.loc 2 1344 12
 2781 00c1 EC A5                   		mov.L	[r10], r5
 2782 00c3 61 05                   		cmp	#0, r5
 2783 00c5 21 4B                   		bne	.L176
1345:../src/wolfcrypt/src/random.c ****             ret = wc_RNG_HealthTest_ex(0,
 2784                             		.loc 2 1345 19
 2785 00c7 ED A5 05                		mov.L	20[r10], r5
 2786 00ca 71 55 20                		add	#32, r5
 2787 00cd F9 06 06 FE             		mov.L	#-2, 24[r0]
 2788 00d1 3E 05 00                		mov.L	#0, 20[r0]
 2789 00d4 3E 04 80                		mov.L	#0x80, 16[r0]
 2790 00d7 ED A4 01                		mov.L	4[r10], r4
 2791 00da A0 8C                   		mov.L	r4, 12[r0]
 2792 00dc 3E 02 00                		mov.L	#0, 8[r0]
 2793 00df 3E 01 00                		mov.L	#0, 4[r0]
 2794 00e2 F8 06 20                		mov.L	#32, [r0]
 2795 00e5 ED A4 05                		mov.L	20[r10], r4
 2796 00e8 75 43 10                		mov.L	#16, r3
 2797 00eb EF 52                   		mov.L	r5, r2
 2798 00ed 66 01                   		mov.L	#0, r1
 2799 00ef 05 00 00 00             		bsr	_wc_RNG_HealthTest_ex
 2800 00f3 E3 A1                   		mov.L	r1, [r10]
1346:../src/wolfcrypt/src/random.c ****                                     seedB + 32, sizeof(seedB_data) - 32,
1347:../src/wolfcrypt/src/random.c ****                                     seedB, 32,
1348:../src/wolfcrypt/src/random.c ****                                     NULL, 0,
1349:../src/wolfcrypt/src/random.c ****                                     check, RNG_HEALTH_TEST_CHECK_SIZE,
1350:../src/wolfcrypt/src/random.c ****                                     NULL, INVALID_DEVID);
1351:../src/wolfcrypt/src/random.c ****             if (ret == 0) {
 2801                             		.loc 2 1351 16
 2802 00f5 EC A5                   		mov.L	[r10], r5
 2803 00f7 61 05                   		cmp	#0, r5
 2804 00f9 21 17                   		bne	.L176
1352:../src/wolfcrypt/src/random.c ****                 if (ConstantCompare(check, outputB, sizeof(outputB_data)) != 0)
 2805                             		.loc 2 1352 21
 2806 00fb 75 43 80                		mov.L	#0x80, r3
 2807 00fe ED A2 06                		mov.L	24[r10], r2
 2808 0101 ED A1 01                		mov.L	4[r10], r1
 2809 0104 05 00 00 00             		bsr	_ConstantCompare
 2810 0108 EF 15                   		mov.L	r1, r5
 2811                             		.loc 2 1352 20
 2812 010a 61 05                   		cmp	#0, r5
 2813 010c 14                      		beq	.L176
1353:../src/wolfcrypt/src/random.c ****                     ret = -1;
 2814                             		.loc 2 1353 25
 2815 010d F8 A6 FF                		mov.L	#-1, [r10]
 2816                             		.balign 8,3,1
 2817                             	.L176:
 2818                             	.LBE14:
 2819                             	.LBB15:
1354:../src/wolfcrypt/src/random.c ****             }
1355:../src/wolfcrypt/src/random.c ****         }
1356:../src/wolfcrypt/src/random.c **** 
1357:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_USE_FLASHMEM
1358:../src/wolfcrypt/src/random.c ****             XFREE(seedB, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1359:../src/wolfcrypt/src/random.c ****             XFREE(outputB, NULL, DYNAMIC_TYPE_TMP_BUFFER);
1360:../src/wolfcrypt/src/random.c ****         }
1361:../src/wolfcrypt/src/random.c **** #endif
1362:../src/wolfcrypt/src/random.c ****     }
1363:../src/wolfcrypt/src/random.c **** 
1364:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_SMALL_STACK
1365:../src/wolfcrypt/src/random.c ****     XFREE(check, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 2820                             		.loc 2 1365 5
 2821 0110 ED A5 01                		mov.L	4[r10], r5
 2822 0113 E7 A5 07                		mov.L	r5, 28[r10]
 2823 0116 ED A5 07                		mov.L	28[r10], r5
 2824 0119 61 05                   		cmp	#0, r5
 2825 011b 10                      		beq	.L178
 2826                             		.loc 2 1365 5 is_stmt 0 discriminator 1
 2827 011c ED A1 07                		mov.L	28[r10], r1
 2828 011f 05 00 00 00             		bsr	_wolfSSL_Free
 2829                             	.L178:
 2830                             	.LBE15:
1366:../src/wolfcrypt/src/random.c **** #endif
1367:../src/wolfcrypt/src/random.c **** 
1368:../src/wolfcrypt/src/random.c ****     return ret;
 2831                             		.loc 2 1368 12 is_stmt 1
 2832 0123 EC A5                   		mov.L	[r10], r5
 2833                             	.L173:
1369:../src/wolfcrypt/src/random.c **** }
 2834                             		.loc 2 1369 1
 2835 0125 EF 51                   		mov.L	r5, r1
 2836 0127 3F AA 11                		rtsd	#68, r10-r10
 2837                             	.LFE65:
 2839 012a 74 10 01 00 00 00       		.section	.text.wc_GenerateSeed,"ax",@progbits
 2840                             		.global	_wc_GenerateSeed
 2842                             	_wc_GenerateSeed:
 2843                             	.LFB66:
1370:../src/wolfcrypt/src/random.c **** 
1371:../src/wolfcrypt/src/random.c **** #endif /* HAVE_HASHDRBG */
1372:../src/wolfcrypt/src/random.c **** 
1373:../src/wolfcrypt/src/random.c **** 
1374:../src/wolfcrypt/src/random.c **** #ifdef HAVE_WNR
1375:../src/wolfcrypt/src/random.c **** 
1376:../src/wolfcrypt/src/random.c **** /*
1377:../src/wolfcrypt/src/random.c ****  * Init global Whitewood netRandom context
1378:../src/wolfcrypt/src/random.c ****  * Returns 0 on success, negative on error
1379:../src/wolfcrypt/src/random.c ****  */
1380:../src/wolfcrypt/src/random.c **** int wc_InitNetRandom(const char* configFile, wnr_hmac_key hmac_cb, int timeout)
1381:../src/wolfcrypt/src/random.c **** {
1382:../src/wolfcrypt/src/random.c ****     if (configFile == NULL || timeout < 0)
1383:../src/wolfcrypt/src/random.c ****         return BAD_FUNC_ARG;
1384:../src/wolfcrypt/src/random.c **** 
1385:../src/wolfcrypt/src/random.c ****     if (wnr_mutex_init > 0) {
1386:../src/wolfcrypt/src/random.c ****         WOLFSSL_MSG("netRandom context already created, skipping");
1387:../src/wolfcrypt/src/random.c ****         return 0;
1388:../src/wolfcrypt/src/random.c ****     }
1389:../src/wolfcrypt/src/random.c **** 
1390:../src/wolfcrypt/src/random.c ****     if (wc_InitMutex(&wnr_mutex) != 0) {
1391:../src/wolfcrypt/src/random.c ****         WOLFSSL_MSG("Bad Init Mutex wnr_mutex");
1392:../src/wolfcrypt/src/random.c ****         return BAD_MUTEX_E;
1393:../src/wolfcrypt/src/random.c ****     }
1394:../src/wolfcrypt/src/random.c ****     wnr_mutex_init = 1;
1395:../src/wolfcrypt/src/random.c **** 
1396:../src/wolfcrypt/src/random.c ****     if (wc_LockMutex(&wnr_mutex) != 0) {
1397:../src/wolfcrypt/src/random.c ****         WOLFSSL_MSG("Bad Lock Mutex wnr_mutex");
1398:../src/wolfcrypt/src/random.c ****         return BAD_MUTEX_E;
1399:../src/wolfcrypt/src/random.c ****     }
1400:../src/wolfcrypt/src/random.c **** 
1401:../src/wolfcrypt/src/random.c ****     /* store entropy timeout */
1402:../src/wolfcrypt/src/random.c ****     wnr_timeout = timeout;
1403:../src/wolfcrypt/src/random.c **** 
1404:../src/wolfcrypt/src/random.c ****     /* create global wnr_context struct */
1405:../src/wolfcrypt/src/random.c ****     if (wnr_create(&wnr_ctx) != WNR_ERROR_NONE) {
1406:../src/wolfcrypt/src/random.c ****         WOLFSSL_MSG("Error creating global netRandom context");
1407:../src/wolfcrypt/src/random.c ****         return RNG_FAILURE_E;
1408:../src/wolfcrypt/src/random.c ****     }
1409:../src/wolfcrypt/src/random.c **** 
1410:../src/wolfcrypt/src/random.c ****     /* load config file */
1411:../src/wolfcrypt/src/random.c ****     if (wnr_config_loadf(wnr_ctx, (char*)configFile) != WNR_ERROR_NONE) {
1412:../src/wolfcrypt/src/random.c ****         WOLFSSL_MSG("Error loading config file into netRandom context");
1413:../src/wolfcrypt/src/random.c ****         wnr_destroy(wnr_ctx);
1414:../src/wolfcrypt/src/random.c ****         wnr_ctx = NULL;
1415:../src/wolfcrypt/src/random.c ****         return RNG_FAILURE_E;
1416:../src/wolfcrypt/src/random.c ****     }
1417:../src/wolfcrypt/src/random.c **** 
1418:../src/wolfcrypt/src/random.c ****     /* create/init polling mechanism */
1419:../src/wolfcrypt/src/random.c ****     if (wnr_poll_create() != WNR_ERROR_NONE) {
1420:../src/wolfcrypt/src/random.c ****         WOLFSSL_MSG("Error initializing netRandom polling mechanism");
1421:../src/wolfcrypt/src/random.c ****         wnr_destroy(wnr_ctx);
1422:../src/wolfcrypt/src/random.c ****         wnr_ctx = NULL;
1423:../src/wolfcrypt/src/random.c ****         return RNG_FAILURE_E;
1424:../src/wolfcrypt/src/random.c ****     }
1425:../src/wolfcrypt/src/random.c **** 
1426:../src/wolfcrypt/src/random.c ****     /* validate config, set HMAC callback (optional) */
1427:../src/wolfcrypt/src/random.c ****     if (wnr_setup(wnr_ctx, hmac_cb) != WNR_ERROR_NONE) {
1428:../src/wolfcrypt/src/random.c ****         WOLFSSL_MSG("Error setting up netRandom context");
1429:../src/wolfcrypt/src/random.c ****         wnr_destroy(wnr_ctx);
1430:../src/wolfcrypt/src/random.c ****         wnr_ctx = NULL;
1431:../src/wolfcrypt/src/random.c ****         wnr_poll_destroy();
1432:../src/wolfcrypt/src/random.c ****         return RNG_FAILURE_E;
1433:../src/wolfcrypt/src/random.c ****     }
1434:../src/wolfcrypt/src/random.c **** 
1435:../src/wolfcrypt/src/random.c ****     wc_UnLockMutex(&wnr_mutex);
1436:../src/wolfcrypt/src/random.c **** 
1437:../src/wolfcrypt/src/random.c ****     return 0;
1438:../src/wolfcrypt/src/random.c **** }
1439:../src/wolfcrypt/src/random.c **** 
1440:../src/wolfcrypt/src/random.c **** /*
1441:../src/wolfcrypt/src/random.c ****  * Free global Whitewood netRandom context
1442:../src/wolfcrypt/src/random.c ****  * Returns 0 on success, negative on error
1443:../src/wolfcrypt/src/random.c ****  */
1444:../src/wolfcrypt/src/random.c **** int wc_FreeNetRandom(void)
1445:../src/wolfcrypt/src/random.c **** {
1446:../src/wolfcrypt/src/random.c ****     if (wnr_mutex_init > 0) {
1447:../src/wolfcrypt/src/random.c **** 
1448:../src/wolfcrypt/src/random.c ****         if (wc_LockMutex(&wnr_mutex) != 0) {
1449:../src/wolfcrypt/src/random.c ****             WOLFSSL_MSG("Bad Lock Mutex wnr_mutex");
1450:../src/wolfcrypt/src/random.c ****             return BAD_MUTEX_E;
1451:../src/wolfcrypt/src/random.c ****         }
1452:../src/wolfcrypt/src/random.c **** 
1453:../src/wolfcrypt/src/random.c ****         if (wnr_ctx != NULL) {
1454:../src/wolfcrypt/src/random.c ****             wnr_destroy(wnr_ctx);
1455:../src/wolfcrypt/src/random.c ****             wnr_ctx = NULL;
1456:../src/wolfcrypt/src/random.c ****         }
1457:../src/wolfcrypt/src/random.c ****         wnr_poll_destroy();
1458:../src/wolfcrypt/src/random.c **** 
1459:../src/wolfcrypt/src/random.c ****         wc_UnLockMutex(&wnr_mutex);
1460:../src/wolfcrypt/src/random.c **** 
1461:../src/wolfcrypt/src/random.c ****         wc_FreeMutex(&wnr_mutex);
1462:../src/wolfcrypt/src/random.c ****         wnr_mutex_init = 0;
1463:../src/wolfcrypt/src/random.c ****     }
1464:../src/wolfcrypt/src/random.c **** 
1465:../src/wolfcrypt/src/random.c ****     return 0;
1466:../src/wolfcrypt/src/random.c **** }
1467:../src/wolfcrypt/src/random.c **** 
1468:../src/wolfcrypt/src/random.c **** #endif /* HAVE_WNR */
1469:../src/wolfcrypt/src/random.c **** 
1470:../src/wolfcrypt/src/random.c **** 
1471:../src/wolfcrypt/src/random.c **** #if defined(HAVE_INTEL_RDRAND) || defined(HAVE_INTEL_RDSEED) || \
1472:../src/wolfcrypt/src/random.c ****     defined(HAVE_AMD_RDSEED)
1473:../src/wolfcrypt/src/random.c **** 
1474:../src/wolfcrypt/src/random.c **** #ifdef WOLFSSL_ASYNC_CRYPT
1475:../src/wolfcrypt/src/random.c ****     /* need more retries if multiple cores */
1476:../src/wolfcrypt/src/random.c ****     #define INTELRD_RETRY (32 * 8)
1477:../src/wolfcrypt/src/random.c **** #else
1478:../src/wolfcrypt/src/random.c ****     #define INTELRD_RETRY 32
1479:../src/wolfcrypt/src/random.c **** #endif
1480:../src/wolfcrypt/src/random.c **** 
1481:../src/wolfcrypt/src/random.c **** #if defined(HAVE_INTEL_RDSEED) || defined(HAVE_AMD_RDSEED)
1482:../src/wolfcrypt/src/random.c **** 
1483:../src/wolfcrypt/src/random.c **** #ifndef USE_INTEL_INTRINSICS
1484:../src/wolfcrypt/src/random.c **** 
1485:../src/wolfcrypt/src/random.c ****     /* return 0 on success */
1486:../src/wolfcrypt/src/random.c ****     static WC_INLINE int IntelRDseed64(word64* seed)
1487:../src/wolfcrypt/src/random.c ****     {
1488:../src/wolfcrypt/src/random.c ****         unsigned char ok;
1489:../src/wolfcrypt/src/random.c **** 
1490:../src/wolfcrypt/src/random.c ****         __asm__ volatile("rdseed %0; setc %1":"=r"(*seed), "=qm"(ok));
1491:../src/wolfcrypt/src/random.c ****         return (ok) ? 0 : -1;
1492:../src/wolfcrypt/src/random.c ****     }
1493:../src/wolfcrypt/src/random.c **** 
1494:../src/wolfcrypt/src/random.c **** #else /* USE_INTEL_INTRINSICS */
1495:../src/wolfcrypt/src/random.c ****     /* The compiler Visual Studio uses does not allow inline assembly.
1496:../src/wolfcrypt/src/random.c ****      * It does allow for Intel intrinsic functions. */
1497:../src/wolfcrypt/src/random.c **** 
1498:../src/wolfcrypt/src/random.c ****     /* return 0 on success */
1499:../src/wolfcrypt/src/random.c **** # ifdef __GNUC__
1500:../src/wolfcrypt/src/random.c ****     __attribute__((target("rdseed")))
1501:../src/wolfcrypt/src/random.c **** # endif
1502:../src/wolfcrypt/src/random.c ****     static WC_INLINE int IntelRDseed64(word64* seed)
1503:../src/wolfcrypt/src/random.c ****     {
1504:../src/wolfcrypt/src/random.c ****         int ok;
1505:../src/wolfcrypt/src/random.c **** 
1506:../src/wolfcrypt/src/random.c ****         ok = _rdseed64_step((unsigned long long*) seed);
1507:../src/wolfcrypt/src/random.c ****         return (ok) ? 0 : -1;
1508:../src/wolfcrypt/src/random.c ****     }
1509:../src/wolfcrypt/src/random.c **** 
1510:../src/wolfcrypt/src/random.c **** #endif /* USE_INTEL_INTRINSICS */
1511:../src/wolfcrypt/src/random.c **** 
1512:../src/wolfcrypt/src/random.c **** /* return 0 on success */
1513:../src/wolfcrypt/src/random.c **** static WC_INLINE int IntelRDseed64_r(word64* rnd)
1514:../src/wolfcrypt/src/random.c **** {
1515:../src/wolfcrypt/src/random.c ****     int i;
1516:../src/wolfcrypt/src/random.c ****     for (i = 0; i < INTELRD_RETRY; i++) {
1517:../src/wolfcrypt/src/random.c ****         if (IntelRDseed64(rnd) == 0)
1518:../src/wolfcrypt/src/random.c ****             return 0;
1519:../src/wolfcrypt/src/random.c ****     }
1520:../src/wolfcrypt/src/random.c ****     return -1;
1521:../src/wolfcrypt/src/random.c **** }
1522:../src/wolfcrypt/src/random.c **** 
1523:../src/wolfcrypt/src/random.c **** #ifndef WOLFSSL_LINUXKM
1524:../src/wolfcrypt/src/random.c **** /* return 0 on success */
1525:../src/wolfcrypt/src/random.c **** static int wc_GenerateSeed_IntelRD(OS_Seed* os, byte* output, word32 sz)
1526:../src/wolfcrypt/src/random.c **** {
1527:../src/wolfcrypt/src/random.c ****     int ret;
1528:../src/wolfcrypt/src/random.c ****     word64 rndTmp;
1529:../src/wolfcrypt/src/random.c **** 
1530:../src/wolfcrypt/src/random.c ****     (void)os;
1531:../src/wolfcrypt/src/random.c **** 
1532:../src/wolfcrypt/src/random.c ****     if (!IS_INTEL_RDSEED(intel_flags))
1533:../src/wolfcrypt/src/random.c ****         return -1;
1534:../src/wolfcrypt/src/random.c **** 
1535:../src/wolfcrypt/src/random.c ****     for (; (sz / sizeof(word64)) > 0; sz -= sizeof(word64),
1536:../src/wolfcrypt/src/random.c ****                                                     output += sizeof(word64)) {
1537:../src/wolfcrypt/src/random.c ****         ret = IntelRDseed64_r((word64*)output);
1538:../src/wolfcrypt/src/random.c ****         if (ret != 0)
1539:../src/wolfcrypt/src/random.c ****             return ret;
1540:../src/wolfcrypt/src/random.c ****     }
1541:../src/wolfcrypt/src/random.c ****     if (sz == 0)
1542:../src/wolfcrypt/src/random.c ****         return 0;
1543:../src/wolfcrypt/src/random.c **** 
1544:../src/wolfcrypt/src/random.c ****     /* handle unaligned remainder */
1545:../src/wolfcrypt/src/random.c ****     ret = IntelRDseed64_r(&rndTmp);
1546:../src/wolfcrypt/src/random.c ****     if (ret != 0)
1547:../src/wolfcrypt/src/random.c ****         return ret;
1548:../src/wolfcrypt/src/random.c **** 
1549:../src/wolfcrypt/src/random.c ****     XMEMCPY(output, &rndTmp, sz);
1550:../src/wolfcrypt/src/random.c ****     ForceZero(&rndTmp, sizeof(rndTmp));
1551:../src/wolfcrypt/src/random.c **** 
1552:../src/wolfcrypt/src/random.c ****     return 0;
1553:../src/wolfcrypt/src/random.c **** }
1554:../src/wolfcrypt/src/random.c **** #endif
1555:../src/wolfcrypt/src/random.c **** 
1556:../src/wolfcrypt/src/random.c **** #endif /* HAVE_INTEL_RDSEED || HAVE_AMD_RDSEED */
1557:../src/wolfcrypt/src/random.c **** 
1558:../src/wolfcrypt/src/random.c **** #ifdef HAVE_INTEL_RDRAND
1559:../src/wolfcrypt/src/random.c **** 
1560:../src/wolfcrypt/src/random.c **** #ifndef USE_INTEL_INTRINSICS
1561:../src/wolfcrypt/src/random.c **** 
1562:../src/wolfcrypt/src/random.c **** /* return 0 on success */
1563:../src/wolfcrypt/src/random.c **** static WC_INLINE int IntelRDrand64(word64 *rnd)
1564:../src/wolfcrypt/src/random.c **** {
1565:../src/wolfcrypt/src/random.c ****     unsigned char ok;
1566:../src/wolfcrypt/src/random.c **** 
1567:../src/wolfcrypt/src/random.c ****     __asm__ volatile("rdrand %0; setc %1":"=r"(*rnd), "=qm"(ok));
1568:../src/wolfcrypt/src/random.c **** 
1569:../src/wolfcrypt/src/random.c ****     return (ok) ? 0 : -1;
1570:../src/wolfcrypt/src/random.c **** }
1571:../src/wolfcrypt/src/random.c **** 
1572:../src/wolfcrypt/src/random.c **** #else /* USE_INTEL_INTRINSICS */
1573:../src/wolfcrypt/src/random.c ****     /* The compiler Visual Studio uses does not allow inline assembly.
1574:../src/wolfcrypt/src/random.c ****      * It does allow for Intel intrinsic functions. */
1575:../src/wolfcrypt/src/random.c **** 
1576:../src/wolfcrypt/src/random.c **** /* return 0 on success */
1577:../src/wolfcrypt/src/random.c **** # ifdef __GNUC__
1578:../src/wolfcrypt/src/random.c **** __attribute__((target("rdrnd")))
1579:../src/wolfcrypt/src/random.c **** # endif
1580:../src/wolfcrypt/src/random.c **** static WC_INLINE int IntelRDrand64(word64 *rnd)
1581:../src/wolfcrypt/src/random.c **** {
1582:../src/wolfcrypt/src/random.c ****     int ok;
1583:../src/wolfcrypt/src/random.c **** 
1584:../src/wolfcrypt/src/random.c ****     ok = _rdrand64_step((unsigned long long*) rnd);
1585:../src/wolfcrypt/src/random.c **** 
1586:../src/wolfcrypt/src/random.c ****     return (ok) ? 0 : -1;
1587:../src/wolfcrypt/src/random.c **** }
1588:../src/wolfcrypt/src/random.c **** 
1589:../src/wolfcrypt/src/random.c **** #endif /* USE_INTEL_INTRINSICS */
1590:../src/wolfcrypt/src/random.c **** 
1591:../src/wolfcrypt/src/random.c **** /* return 0 on success */
1592:../src/wolfcrypt/src/random.c **** static WC_INLINE int IntelRDrand64_r(word64 *rnd)
1593:../src/wolfcrypt/src/random.c **** {
1594:../src/wolfcrypt/src/random.c ****     int i;
1595:../src/wolfcrypt/src/random.c ****     for (i = 0; i < INTELRD_RETRY; i++) {
1596:../src/wolfcrypt/src/random.c ****         if (IntelRDrand64(rnd) == 0)
1597:../src/wolfcrypt/src/random.c ****             return 0;
1598:../src/wolfcrypt/src/random.c ****     }
1599:../src/wolfcrypt/src/random.c ****     return -1;
1600:../src/wolfcrypt/src/random.c **** }
1601:../src/wolfcrypt/src/random.c **** 
1602:../src/wolfcrypt/src/random.c **** /* return 0 on success */
1603:../src/wolfcrypt/src/random.c **** static int wc_GenerateRand_IntelRD(OS_Seed* os, byte* output, word32 sz)
1604:../src/wolfcrypt/src/random.c **** {
1605:../src/wolfcrypt/src/random.c ****     int ret;
1606:../src/wolfcrypt/src/random.c ****     word64 rndTmp;
1607:../src/wolfcrypt/src/random.c **** 
1608:../src/wolfcrypt/src/random.c ****     (void)os;
1609:../src/wolfcrypt/src/random.c **** 
1610:../src/wolfcrypt/src/random.c ****     if (!IS_INTEL_RDRAND(intel_flags))
1611:../src/wolfcrypt/src/random.c ****         return -1;
1612:../src/wolfcrypt/src/random.c **** 
1613:../src/wolfcrypt/src/random.c ****     for (; (sz / sizeof(word64)) > 0; sz -= sizeof(word64),
1614:../src/wolfcrypt/src/random.c ****                                                     output += sizeof(word64)) {
1615:../src/wolfcrypt/src/random.c ****         ret = IntelRDrand64_r((word64 *)output);
1616:../src/wolfcrypt/src/random.c ****         if (ret != 0)
1617:../src/wolfcrypt/src/random.c ****             return ret;
1618:../src/wolfcrypt/src/random.c ****     }
1619:../src/wolfcrypt/src/random.c ****     if (sz == 0)
1620:../src/wolfcrypt/src/random.c ****         return 0;
1621:../src/wolfcrypt/src/random.c **** 
1622:../src/wolfcrypt/src/random.c ****     /* handle unaligned remainder */
1623:../src/wolfcrypt/src/random.c ****     ret = IntelRDrand64_r(&rndTmp);
1624:../src/wolfcrypt/src/random.c ****     if (ret != 0)
1625:../src/wolfcrypt/src/random.c ****         return ret;
1626:../src/wolfcrypt/src/random.c **** 
1627:../src/wolfcrypt/src/random.c ****     XMEMCPY(output, &rndTmp, sz);
1628:../src/wolfcrypt/src/random.c **** 
1629:../src/wolfcrypt/src/random.c ****     return 0;
1630:../src/wolfcrypt/src/random.c **** }
1631:../src/wolfcrypt/src/random.c **** 
1632:../src/wolfcrypt/src/random.c **** #endif /* HAVE_INTEL_RDRAND */
1633:../src/wolfcrypt/src/random.c **** #endif /* HAVE_INTEL_RDRAND || HAVE_INTEL_RDSEED || HAVE_AMD_RDSEED */
1634:../src/wolfcrypt/src/random.c **** 
1635:../src/wolfcrypt/src/random.c **** 
1636:../src/wolfcrypt/src/random.c **** /* Begin wc_GenerateSeed Implementations */
1637:../src/wolfcrypt/src/random.c **** #if defined(CUSTOM_RAND_GENERATE_SEED)
1638:../src/wolfcrypt/src/random.c **** 
1639:../src/wolfcrypt/src/random.c ****     /* Implement your own random generation function
1640:../src/wolfcrypt/src/random.c ****      * Return 0 to indicate success
1641:../src/wolfcrypt/src/random.c ****      * int rand_gen_seed(byte* output, word32 sz);
1642:../src/wolfcrypt/src/random.c ****      * #define CUSTOM_RAND_GENERATE_SEED  rand_gen_seed */
1643:../src/wolfcrypt/src/random.c **** 
1644:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1645:../src/wolfcrypt/src/random.c ****     {
1646:../src/wolfcrypt/src/random.c ****         (void)os; /* Suppress unused arg warning */
1647:../src/wolfcrypt/src/random.c ****         return CUSTOM_RAND_GENERATE_SEED(output, sz);
1648:../src/wolfcrypt/src/random.c ****     }
1649:../src/wolfcrypt/src/random.c **** 
1650:../src/wolfcrypt/src/random.c **** #elif defined(CUSTOM_RAND_GENERATE_SEED_OS)
1651:../src/wolfcrypt/src/random.c **** 
1652:../src/wolfcrypt/src/random.c ****     /* Implement your own random generation function,
1653:../src/wolfcrypt/src/random.c ****      *  which includes OS_Seed.
1654:../src/wolfcrypt/src/random.c ****      * Return 0 to indicate success
1655:../src/wolfcrypt/src/random.c ****      * int rand_gen_seed(OS_Seed* os, byte* output, word32 sz);
1656:../src/wolfcrypt/src/random.c ****      * #define CUSTOM_RAND_GENERATE_SEED_OS  rand_gen_seed */
1657:../src/wolfcrypt/src/random.c **** 
1658:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1659:../src/wolfcrypt/src/random.c ****     {
1660:../src/wolfcrypt/src/random.c ****         return CUSTOM_RAND_GENERATE_SEED_OS(os, output, sz);
1661:../src/wolfcrypt/src/random.c ****     }
1662:../src/wolfcrypt/src/random.c **** 
1663:../src/wolfcrypt/src/random.c **** #elif defined(CUSTOM_RAND_GENERATE)
1664:../src/wolfcrypt/src/random.c **** 
1665:../src/wolfcrypt/src/random.c ****    /* Implement your own random generation function
1666:../src/wolfcrypt/src/random.c ****     * word32 rand_gen(void);
1667:../src/wolfcrypt/src/random.c ****     * #define CUSTOM_RAND_GENERATE  rand_gen  */
1668:../src/wolfcrypt/src/random.c **** 
1669:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1670:../src/wolfcrypt/src/random.c ****     {
1671:../src/wolfcrypt/src/random.c ****         word32 i = 0;
1672:../src/wolfcrypt/src/random.c **** 
1673:../src/wolfcrypt/src/random.c ****         (void)os;
1674:../src/wolfcrypt/src/random.c **** 
1675:../src/wolfcrypt/src/random.c ****         while (i < sz)
1676:../src/wolfcrypt/src/random.c ****         {
1677:../src/wolfcrypt/src/random.c ****             /* If not aligned or there is odd/remainder */
1678:../src/wolfcrypt/src/random.c ****             if( (i + sizeof(CUSTOM_RAND_TYPE)) > sz ||
1679:../src/wolfcrypt/src/random.c ****                 ((wc_ptr_t)&output[i] % sizeof(CUSTOM_RAND_TYPE)) != 0
1680:../src/wolfcrypt/src/random.c ****             ) {
1681:../src/wolfcrypt/src/random.c ****                 /* Single byte at a time */
1682:../src/wolfcrypt/src/random.c ****                 output[i++] = (byte)CUSTOM_RAND_GENERATE();
1683:../src/wolfcrypt/src/random.c ****             }
1684:../src/wolfcrypt/src/random.c ****             else {
1685:../src/wolfcrypt/src/random.c ****                 /* Use native 8, 16, 32 or 64 copy instruction */
1686:../src/wolfcrypt/src/random.c ****                 *((CUSTOM_RAND_TYPE*)&output[i]) = CUSTOM_RAND_GENERATE();
1687:../src/wolfcrypt/src/random.c ****                 i += sizeof(CUSTOM_RAND_TYPE);
1688:../src/wolfcrypt/src/random.c ****             }
1689:../src/wolfcrypt/src/random.c ****         }
1690:../src/wolfcrypt/src/random.c **** 
1691:../src/wolfcrypt/src/random.c ****         return 0;
1692:../src/wolfcrypt/src/random.c ****     }
1693:../src/wolfcrypt/src/random.c **** 
1694:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_SGX)
1695:../src/wolfcrypt/src/random.c **** 
1696:../src/wolfcrypt/src/random.c **** int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1697:../src/wolfcrypt/src/random.c **** {
1698:../src/wolfcrypt/src/random.c ****     int ret = !SGX_SUCCESS;
1699:../src/wolfcrypt/src/random.c ****     int i, read_max = 10;
1700:../src/wolfcrypt/src/random.c **** 
1701:../src/wolfcrypt/src/random.c ****     for (i = 0; i < read_max && ret != SGX_SUCCESS; i++) {
1702:../src/wolfcrypt/src/random.c ****         ret = sgx_read_rand(output, sz);
1703:../src/wolfcrypt/src/random.c ****     }
1704:../src/wolfcrypt/src/random.c **** 
1705:../src/wolfcrypt/src/random.c ****     (void)os;
1706:../src/wolfcrypt/src/random.c ****     return (ret == SGX_SUCCESS) ? 0 : 1;
1707:../src/wolfcrypt/src/random.c **** }
1708:../src/wolfcrypt/src/random.c **** 
1709:../src/wolfcrypt/src/random.c **** #elif defined(USE_WINDOWS_API)
1710:../src/wolfcrypt/src/random.c **** 
1711:../src/wolfcrypt/src/random.c **** int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1712:../src/wolfcrypt/src/random.c **** {
1713:../src/wolfcrypt/src/random.c **** #ifdef WOLF_CRYPTO_CB
1714:../src/wolfcrypt/src/random.c ****     int ret;
1715:../src/wolfcrypt/src/random.c **** 
1716:../src/wolfcrypt/src/random.c ****     if (os != NULL && os->devId != INVALID_DEVID) {
1717:../src/wolfcrypt/src/random.c ****         ret = wc_CryptoCb_RandomSeed(os, output, sz);
1718:../src/wolfcrypt/src/random.c ****         if (ret != CRYPTOCB_UNAVAILABLE)
1719:../src/wolfcrypt/src/random.c ****             return ret;
1720:../src/wolfcrypt/src/random.c ****         /* fall-through when unavailable */
1721:../src/wolfcrypt/src/random.c ****     }
1722:../src/wolfcrypt/src/random.c **** #endif
1723:../src/wolfcrypt/src/random.c **** 
1724:../src/wolfcrypt/src/random.c ****     #ifdef HAVE_INTEL_RDSEED
1725:../src/wolfcrypt/src/random.c ****         if (IS_INTEL_RDSEED(intel_flags)) {
1726:../src/wolfcrypt/src/random.c ****              if (!wc_GenerateSeed_IntelRD(NULL, output, sz)) {
1727:../src/wolfcrypt/src/random.c ****                  /* success, we're done */
1728:../src/wolfcrypt/src/random.c ****                  return 0;
1729:../src/wolfcrypt/src/random.c ****              }
1730:../src/wolfcrypt/src/random.c ****         #ifdef FORCE_FAILURE_RDSEED
1731:../src/wolfcrypt/src/random.c ****              /* don't fall back to CryptoAPI */
1732:../src/wolfcrypt/src/random.c ****              return READ_RAN_E;
1733:../src/wolfcrypt/src/random.c ****         #endif
1734:../src/wolfcrypt/src/random.c ****         }
1735:../src/wolfcrypt/src/random.c ****     #endif /* HAVE_INTEL_RDSEED */
1736:../src/wolfcrypt/src/random.c **** 
1737:../src/wolfcrypt/src/random.c ****     if(!CryptAcquireContext(&os->handle, 0, 0, PROV_RSA_FULL,
1738:../src/wolfcrypt/src/random.c ****                             CRYPT_VERIFYCONTEXT))
1739:../src/wolfcrypt/src/random.c ****         return WINCRYPT_E;
1740:../src/wolfcrypt/src/random.c **** 
1741:../src/wolfcrypt/src/random.c ****     if (!CryptGenRandom(os->handle, sz, output))
1742:../src/wolfcrypt/src/random.c ****         return CRYPTGEN_E;
1743:../src/wolfcrypt/src/random.c **** 
1744:../src/wolfcrypt/src/random.c ****     CryptReleaseContext(os->handle, 0);
1745:../src/wolfcrypt/src/random.c **** 
1746:../src/wolfcrypt/src/random.c ****     return 0;
1747:../src/wolfcrypt/src/random.c **** }
1748:../src/wolfcrypt/src/random.c **** 
1749:../src/wolfcrypt/src/random.c **** 
1750:../src/wolfcrypt/src/random.c **** #elif defined(HAVE_RTP_SYS) || defined(EBSNET)
1751:../src/wolfcrypt/src/random.c **** 
1752:../src/wolfcrypt/src/random.c **** #include "rtprand.h"   /* rtp_rand () */
1753:../src/wolfcrypt/src/random.c **** #include "rtptime.h"   /* rtp_get_system_msec() */
1754:../src/wolfcrypt/src/random.c **** 
1755:../src/wolfcrypt/src/random.c **** int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1756:../src/wolfcrypt/src/random.c **** {
1757:../src/wolfcrypt/src/random.c ****     word32 i;
1758:../src/wolfcrypt/src/random.c **** 
1759:../src/wolfcrypt/src/random.c ****     rtp_srand(rtp_get_system_msec());
1760:../src/wolfcrypt/src/random.c ****     for (i = 0; i < sz; i++ ) {
1761:../src/wolfcrypt/src/random.c ****         output[i] = rtp_rand() % 256;
1762:../src/wolfcrypt/src/random.c ****     }
1763:../src/wolfcrypt/src/random.c **** 
1764:../src/wolfcrypt/src/random.c ****     return 0;
1765:../src/wolfcrypt/src/random.c **** }
1766:../src/wolfcrypt/src/random.c **** 
1767:../src/wolfcrypt/src/random.c **** #elif (defined(WOLFSSL_ATMEL) || defined(WOLFSSL_ATECC_RNG)) && \
1768:../src/wolfcrypt/src/random.c ****       !defined(WOLFSSL_PIC32MZ_RNG)
1769:../src/wolfcrypt/src/random.c ****     /* enable ATECC RNG unless using PIC32MZ one instead */
1770:../src/wolfcrypt/src/random.c ****     #include <wolfssl/wolfcrypt/port/atmel/atmel.h>
1771:../src/wolfcrypt/src/random.c **** 
1772:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1773:../src/wolfcrypt/src/random.c ****     {
1774:../src/wolfcrypt/src/random.c ****         int ret = 0;
1775:../src/wolfcrypt/src/random.c **** 
1776:../src/wolfcrypt/src/random.c ****         (void)os;
1777:../src/wolfcrypt/src/random.c ****         if (output == NULL) {
1778:../src/wolfcrypt/src/random.c ****             return BUFFER_E;
1779:../src/wolfcrypt/src/random.c ****         }
1780:../src/wolfcrypt/src/random.c **** 
1781:../src/wolfcrypt/src/random.c ****         ret = atmel_get_random_number(sz, output);
1782:../src/wolfcrypt/src/random.c **** 
1783:../src/wolfcrypt/src/random.c ****         return ret;
1784:../src/wolfcrypt/src/random.c ****     }
1785:../src/wolfcrypt/src/random.c **** 
1786:../src/wolfcrypt/src/random.c **** #elif defined(MICROCHIP_PIC32)
1787:../src/wolfcrypt/src/random.c **** 
1788:../src/wolfcrypt/src/random.c ****     #ifdef MICROCHIP_MPLAB_HARMONY
1789:../src/wolfcrypt/src/random.c ****         #ifdef MICROCHIP_MPLAB_HARMONY_3
1790:../src/wolfcrypt/src/random.c ****             #include "system/time/sys_time.h"
1791:../src/wolfcrypt/src/random.c ****             #define PIC32_SEED_COUNT SYS_TIME_CounterGet
1792:../src/wolfcrypt/src/random.c ****         #else
1793:../src/wolfcrypt/src/random.c ****             #define PIC32_SEED_COUNT _CP0_GET_COUNT
1794:../src/wolfcrypt/src/random.c ****         #endif
1795:../src/wolfcrypt/src/random.c ****     #else
1796:../src/wolfcrypt/src/random.c ****         #if !defined(WOLFSSL_MICROCHIP_PIC32MZ)
1797:../src/wolfcrypt/src/random.c ****             #include <peripheral/timer.h>
1798:../src/wolfcrypt/src/random.c ****         #endif
1799:../src/wolfcrypt/src/random.c ****         extern word32 ReadCoreTimer(void);
1800:../src/wolfcrypt/src/random.c ****         #define PIC32_SEED_COUNT ReadCoreTimer
1801:../src/wolfcrypt/src/random.c ****     #endif
1802:../src/wolfcrypt/src/random.c **** 
1803:../src/wolfcrypt/src/random.c ****     #ifdef WOLFSSL_PIC32MZ_RNG
1804:../src/wolfcrypt/src/random.c ****         #include "xc.h"
1805:../src/wolfcrypt/src/random.c ****         int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1806:../src/wolfcrypt/src/random.c ****         {
1807:../src/wolfcrypt/src/random.c ****             int i;
1808:../src/wolfcrypt/src/random.c ****             byte rnd[8];
1809:../src/wolfcrypt/src/random.c ****             word32 *rnd32 = (word32 *)rnd;
1810:../src/wolfcrypt/src/random.c ****             word32 size = sz;
1811:../src/wolfcrypt/src/random.c ****             byte* op = output;
1812:../src/wolfcrypt/src/random.c **** 
1813:../src/wolfcrypt/src/random.c **** #if ((__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C'))
1814:../src/wolfcrypt/src/random.c ****             RNGNUMGEN1 = _CP0_GET_COUNT();
1815:../src/wolfcrypt/src/random.c ****             RNGPOLY1 = _CP0_GET_COUNT();
1816:../src/wolfcrypt/src/random.c ****             RNGPOLY2 = _CP0_GET_COUNT();
1817:../src/wolfcrypt/src/random.c ****             RNGNUMGEN2 = _CP0_GET_COUNT();
1818:../src/wolfcrypt/src/random.c **** #else
1819:../src/wolfcrypt/src/random.c ****             /* All others can be seeded from the TRNG */
1820:../src/wolfcrypt/src/random.c ****             RNGCONbits.TRNGMODE = 1;
1821:../src/wolfcrypt/src/random.c ****             RNGCONbits.TRNGEN = 1;
1822:../src/wolfcrypt/src/random.c ****             while (RNGCNT < 64);
1823:../src/wolfcrypt/src/random.c ****             RNGCONbits.LOAD = 1;
1824:../src/wolfcrypt/src/random.c ****             while (RNGCONbits.LOAD == 1);
1825:../src/wolfcrypt/src/random.c ****             while (RNGCNT < 64);
1826:../src/wolfcrypt/src/random.c ****             RNGPOLY2 = RNGSEED2;
1827:../src/wolfcrypt/src/random.c ****             RNGPOLY1 = RNGSEED1;
1828:../src/wolfcrypt/src/random.c **** #endif
1829:../src/wolfcrypt/src/random.c **** 
1830:../src/wolfcrypt/src/random.c ****             RNGCONbits.PLEN = 0x40;
1831:../src/wolfcrypt/src/random.c ****             RNGCONbits.PRNGEN = 1;
1832:../src/wolfcrypt/src/random.c ****             for (i=0; i<5; i++) { /* wait for RNGNUMGEN ready */
1833:../src/wolfcrypt/src/random.c ****                 volatile int x, y;
1834:../src/wolfcrypt/src/random.c ****                 x = RNGNUMGEN1;
1835:../src/wolfcrypt/src/random.c ****                 y = RNGNUMGEN2;
1836:../src/wolfcrypt/src/random.c ****                 (void)x;
1837:../src/wolfcrypt/src/random.c ****                 (void)y;
1838:../src/wolfcrypt/src/random.c ****             }
1839:../src/wolfcrypt/src/random.c ****             do {
1840:../src/wolfcrypt/src/random.c ****                 rnd32[0] = RNGNUMGEN1;
1841:../src/wolfcrypt/src/random.c ****                 rnd32[1] = RNGNUMGEN2;
1842:../src/wolfcrypt/src/random.c **** 
1843:../src/wolfcrypt/src/random.c ****                 for(i=0; i<8; i++, op++) {
1844:../src/wolfcrypt/src/random.c ****                     *op = rnd[i];
1845:../src/wolfcrypt/src/random.c ****                     size --;
1846:../src/wolfcrypt/src/random.c ****                     if(size==0)break;
1847:../src/wolfcrypt/src/random.c ****                 }
1848:../src/wolfcrypt/src/random.c ****             } while(size);
1849:../src/wolfcrypt/src/random.c ****             return 0;
1850:../src/wolfcrypt/src/random.c ****         }
1851:../src/wolfcrypt/src/random.c ****     #else  /* WOLFSSL_PIC32MZ_RNG */
1852:../src/wolfcrypt/src/random.c ****         /* uses the core timer, in nanoseconds to seed srand */
1853:../src/wolfcrypt/src/random.c ****         int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1854:../src/wolfcrypt/src/random.c ****         {
1855:../src/wolfcrypt/src/random.c ****             int i;
1856:../src/wolfcrypt/src/random.c ****             srand(PIC32_SEED_COUNT() * 25);
1857:../src/wolfcrypt/src/random.c **** 
1858:../src/wolfcrypt/src/random.c ****             for (i = 0; i < sz; i++ ) {
1859:../src/wolfcrypt/src/random.c ****                 output[i] = rand() % 256;
1860:../src/wolfcrypt/src/random.c ****                 if ( (i % 8) == 7)
1861:../src/wolfcrypt/src/random.c ****                     srand(PIC32_SEED_COUNT() * 25);
1862:../src/wolfcrypt/src/random.c ****             }
1863:../src/wolfcrypt/src/random.c ****             return 0;
1864:../src/wolfcrypt/src/random.c ****         }
1865:../src/wolfcrypt/src/random.c ****     #endif /* WOLFSSL_PIC32MZ_RNG */
1866:../src/wolfcrypt/src/random.c **** 
1867:../src/wolfcrypt/src/random.c **** #elif defined(FREESCALE_K70_RNGA) || defined(FREESCALE_RNGA)
1868:../src/wolfcrypt/src/random.c ****     /*
1869:../src/wolfcrypt/src/random.c ****      * wc_Generates a RNG seed using the Random Number Generator Accelerator
1870:../src/wolfcrypt/src/random.c ****      * on the Kinetis K70. Documentation located in Chapter 37 of
1871:../src/wolfcrypt/src/random.c ****      * K70 Sub-Family Reference Manual (see Note 3 in the README for link).
1872:../src/wolfcrypt/src/random.c ****      */
1873:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1874:../src/wolfcrypt/src/random.c ****     {
1875:../src/wolfcrypt/src/random.c ****         word32 i;
1876:../src/wolfcrypt/src/random.c **** 
1877:../src/wolfcrypt/src/random.c ****         /* turn on RNGA module */
1878:../src/wolfcrypt/src/random.c ****         #if defined(SIM_SCGC3_RNGA_MASK)
1879:../src/wolfcrypt/src/random.c ****             SIM_SCGC3 |= SIM_SCGC3_RNGA_MASK;
1880:../src/wolfcrypt/src/random.c ****         #endif
1881:../src/wolfcrypt/src/random.c ****         #if defined(SIM_SCGC6_RNGA_MASK)
1882:../src/wolfcrypt/src/random.c ****             /* additionally needed for at least K64F */
1883:../src/wolfcrypt/src/random.c ****             SIM_SCGC6 |= SIM_SCGC6_RNGA_MASK;
1884:../src/wolfcrypt/src/random.c ****         #endif
1885:../src/wolfcrypt/src/random.c **** 
1886:../src/wolfcrypt/src/random.c ****         /* set SLP bit to 0 - "RNGA is not in sleep mode" */
1887:../src/wolfcrypt/src/random.c ****         RNG_CR &= ~RNG_CR_SLP_MASK;
1888:../src/wolfcrypt/src/random.c **** 
1889:../src/wolfcrypt/src/random.c ****         /* set HA bit to 1 - "security violations masked" */
1890:../src/wolfcrypt/src/random.c ****         RNG_CR |= RNG_CR_HA_MASK;
1891:../src/wolfcrypt/src/random.c **** 
1892:../src/wolfcrypt/src/random.c ****         /* set GO bit to 1 - "output register loaded with data" */
1893:../src/wolfcrypt/src/random.c ****         RNG_CR |= RNG_CR_GO_MASK;
1894:../src/wolfcrypt/src/random.c **** 
1895:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++) {
1896:../src/wolfcrypt/src/random.c **** 
1897:../src/wolfcrypt/src/random.c ****             /* wait for RNG FIFO to be full */
1898:../src/wolfcrypt/src/random.c ****             while((RNG_SR & RNG_SR_OREG_LVL(0xF)) == 0) {}
1899:../src/wolfcrypt/src/random.c **** 
1900:../src/wolfcrypt/src/random.c ****             /* get value */
1901:../src/wolfcrypt/src/random.c ****             output[i] = RNG_OR;
1902:../src/wolfcrypt/src/random.c ****         }
1903:../src/wolfcrypt/src/random.c **** 
1904:../src/wolfcrypt/src/random.c ****         return 0;
1905:../src/wolfcrypt/src/random.c ****     }
1906:../src/wolfcrypt/src/random.c **** 
1907:../src/wolfcrypt/src/random.c **** #elif defined(FREESCALE_K53_RNGB) || defined(FREESCALE_RNGB)
1908:../src/wolfcrypt/src/random.c ****     /*
1909:../src/wolfcrypt/src/random.c ****      * wc_Generates a RNG seed using the Random Number Generator (RNGB)
1910:../src/wolfcrypt/src/random.c ****      * on the Kinetis K53. Documentation located in Chapter 33 of
1911:../src/wolfcrypt/src/random.c ****      * K53 Sub-Family Reference Manual (see note in the README for link).
1912:../src/wolfcrypt/src/random.c ****      */
1913:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1914:../src/wolfcrypt/src/random.c ****     {
1915:../src/wolfcrypt/src/random.c ****         int i;
1916:../src/wolfcrypt/src/random.c **** 
1917:../src/wolfcrypt/src/random.c ****         /* turn on RNGB module */
1918:../src/wolfcrypt/src/random.c ****         SIM_SCGC3 |= SIM_SCGC3_RNGB_MASK;
1919:../src/wolfcrypt/src/random.c **** 
1920:../src/wolfcrypt/src/random.c ****         /* reset RNGB */
1921:../src/wolfcrypt/src/random.c ****         RNG_CMD |= RNG_CMD_SR_MASK;
1922:../src/wolfcrypt/src/random.c **** 
1923:../src/wolfcrypt/src/random.c ****         /* FIFO generate interrupt, return all zeros on underflow,
1924:../src/wolfcrypt/src/random.c ****          * set auto reseed */
1925:../src/wolfcrypt/src/random.c ****         RNG_CR |= (RNG_CR_FUFMOD_MASK | RNG_CR_AR_MASK);
1926:../src/wolfcrypt/src/random.c **** 
1927:../src/wolfcrypt/src/random.c ****         /* gen seed, clear interrupts, clear errors */
1928:../src/wolfcrypt/src/random.c ****         RNG_CMD |= (RNG_CMD_GS_MASK | RNG_CMD_CI_MASK | RNG_CMD_CE_MASK);
1929:../src/wolfcrypt/src/random.c **** 
1930:../src/wolfcrypt/src/random.c ****         /* wait for seeding to complete */
1931:../src/wolfcrypt/src/random.c ****         while ((RNG_SR & RNG_SR_SDN_MASK) == 0) {}
1932:../src/wolfcrypt/src/random.c **** 
1933:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++) {
1934:../src/wolfcrypt/src/random.c **** 
1935:../src/wolfcrypt/src/random.c ****             /* wait for a word to be available from FIFO */
1936:../src/wolfcrypt/src/random.c ****             while((RNG_SR & RNG_SR_FIFO_LVL_MASK) == 0) {}
1937:../src/wolfcrypt/src/random.c **** 
1938:../src/wolfcrypt/src/random.c ****             /* get value */
1939:../src/wolfcrypt/src/random.c ****             output[i] = RNG_OUT;
1940:../src/wolfcrypt/src/random.c ****         }
1941:../src/wolfcrypt/src/random.c **** 
1942:../src/wolfcrypt/src/random.c ****         return 0;
1943:../src/wolfcrypt/src/random.c ****     }
1944:../src/wolfcrypt/src/random.c **** 
1945:../src/wolfcrypt/src/random.c **** #elif defined(FREESCALE_KSDK_2_0_TRNG)
1946:../src/wolfcrypt/src/random.c ****     #ifndef TRNG0
1947:../src/wolfcrypt/src/random.c ****     #define TRNG0 TRNG
1948:../src/wolfcrypt/src/random.c ****     #endif
1949:../src/wolfcrypt/src/random.c **** 
1950:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1951:../src/wolfcrypt/src/random.c ****     {
1952:../src/wolfcrypt/src/random.c ****         status_t status;
1953:../src/wolfcrypt/src/random.c ****         status = TRNG_GetRandomData(TRNG0, output, sz);
1954:../src/wolfcrypt/src/random.c ****         (void)os;
1955:../src/wolfcrypt/src/random.c ****         if (status == kStatus_Success)
1956:../src/wolfcrypt/src/random.c ****         {
1957:../src/wolfcrypt/src/random.c ****             return(0);
1958:../src/wolfcrypt/src/random.c ****         }
1959:../src/wolfcrypt/src/random.c ****         return RAN_BLOCK_E;
1960:../src/wolfcrypt/src/random.c ****     }
1961:../src/wolfcrypt/src/random.c **** 
1962:../src/wolfcrypt/src/random.c **** #elif defined(FREESCALE_KSDK_2_0_RNGA)
1963:../src/wolfcrypt/src/random.c **** 
1964:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1965:../src/wolfcrypt/src/random.c ****     {
1966:../src/wolfcrypt/src/random.c ****         status_t status;
1967:../src/wolfcrypt/src/random.c ****         status = RNGA_GetRandomData(RNG, output, sz);
1968:../src/wolfcrypt/src/random.c ****         (void)os;
1969:../src/wolfcrypt/src/random.c ****         if (status == kStatus_Success)
1970:../src/wolfcrypt/src/random.c ****         {
1971:../src/wolfcrypt/src/random.c ****             return(0);
1972:../src/wolfcrypt/src/random.c ****         }
1973:../src/wolfcrypt/src/random.c ****         return RAN_BLOCK_E;
1974:../src/wolfcrypt/src/random.c ****     }
1975:../src/wolfcrypt/src/random.c **** 
1976:../src/wolfcrypt/src/random.c **** 
1977:../src/wolfcrypt/src/random.c **** #elif defined(FREESCALE_RNGA)
1978:../src/wolfcrypt/src/random.c **** 
1979:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
1980:../src/wolfcrypt/src/random.c ****     {
1981:../src/wolfcrypt/src/random.c ****         status_t status;
1982:../src/wolfcrypt/src/random.c ****         status = RNGA_GetRandomData(RNG, output, sz);
1983:../src/wolfcrypt/src/random.c ****         (void)os;
1984:../src/wolfcrypt/src/random.c ****         if (status == kStatus_Success)
1985:../src/wolfcrypt/src/random.c ****         {
1986:../src/wolfcrypt/src/random.c ****             return(0);
1987:../src/wolfcrypt/src/random.c ****         }
1988:../src/wolfcrypt/src/random.c ****         return RAN_BLOCK_E;
1989:../src/wolfcrypt/src/random.c ****     }
1990:../src/wolfcrypt/src/random.c **** 
1991:../src/wolfcrypt/src/random.c **** #elif defined(FREESCALE_MQX) || defined(FREESCALE_KSDK_MQX) || \
1992:../src/wolfcrypt/src/random.c ****     defined(FREESCALE_KSDK_BM) || defined(FREESCALE_FREE_RTOS)
1993:../src/wolfcrypt/src/random.c ****     /*
1994:../src/wolfcrypt/src/random.c ****      * Fallback to USE_TEST_GENSEED if a FREESCALE platform did not match any
1995:../src/wolfcrypt/src/random.c ****      * of the TRNG/RNGA/RNGB support
1996:../src/wolfcrypt/src/random.c ****      */
1997:../src/wolfcrypt/src/random.c ****     #define USE_TEST_GENSEED
1998:../src/wolfcrypt/src/random.c **** 
1999:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
2000:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2001:../src/wolfcrypt/src/random.c ****     {
2002:../src/wolfcrypt/src/random.c ****         (void)os;
2003:../src/wolfcrypt/src/random.c ****         return silabs_GenerateRand(output, sz);
2004:../src/wolfcrypt/src/random.c ****     }
2005:../src/wolfcrypt/src/random.c **** 
2006:../src/wolfcrypt/src/random.c **** #elif defined(STM32_RNG)
2007:../src/wolfcrypt/src/random.c ****      /* Generate a RNG seed using the hardware random number generator
2008:../src/wolfcrypt/src/random.c ****       * on the STM32F2/F4/F7/L4. */
2009:../src/wolfcrypt/src/random.c **** 
2010:../src/wolfcrypt/src/random.c ****     #ifdef WOLFSSL_STM32_CUBEMX
2011:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2012:../src/wolfcrypt/src/random.c ****     {
2013:../src/wolfcrypt/src/random.c ****         int ret;
2014:../src/wolfcrypt/src/random.c ****         RNG_HandleTypeDef hrng;
2015:../src/wolfcrypt/src/random.c ****         word32 i = 0;
2016:../src/wolfcrypt/src/random.c ****         (void)os;
2017:../src/wolfcrypt/src/random.c **** 
2018:../src/wolfcrypt/src/random.c ****         ret = wolfSSL_CryptHwMutexLock();
2019:../src/wolfcrypt/src/random.c ****         if (ret != 0) {
2020:../src/wolfcrypt/src/random.c ****             return ret;
2021:../src/wolfcrypt/src/random.c ****         }
2022:../src/wolfcrypt/src/random.c **** 
2023:../src/wolfcrypt/src/random.c ****         /* enable RNG clock source */
2024:../src/wolfcrypt/src/random.c ****         __HAL_RCC_RNG_CLK_ENABLE();
2025:../src/wolfcrypt/src/random.c **** 
2026:../src/wolfcrypt/src/random.c ****         /* enable RNG peripheral */
2027:../src/wolfcrypt/src/random.c ****         XMEMSET(&hrng, 0, sizeof(hrng));
2028:../src/wolfcrypt/src/random.c ****         hrng.Instance = RNG;
2029:../src/wolfcrypt/src/random.c ****         HAL_RNG_Init(&hrng);
2030:../src/wolfcrypt/src/random.c **** 
2031:../src/wolfcrypt/src/random.c ****         while (i < sz) {
2032:../src/wolfcrypt/src/random.c ****             /* If not aligned or there is odd/remainder */
2033:../src/wolfcrypt/src/random.c ****             if( (i + sizeof(word32)) > sz ||
2034:../src/wolfcrypt/src/random.c ****                 ((wc_ptr_t)&output[i] % sizeof(word32)) != 0
2035:../src/wolfcrypt/src/random.c ****             ) {
2036:../src/wolfcrypt/src/random.c ****                 /* Single byte at a time */
2037:../src/wolfcrypt/src/random.c ****                 uint32_t tmpRng = 0;
2038:../src/wolfcrypt/src/random.c ****                 if (HAL_RNG_GenerateRandomNumber(&hrng, &tmpRng) != HAL_OK) {
2039:../src/wolfcrypt/src/random.c ****                     wolfSSL_CryptHwMutexUnLock();
2040:../src/wolfcrypt/src/random.c ****                     return RAN_BLOCK_E;
2041:../src/wolfcrypt/src/random.c ****                 }
2042:../src/wolfcrypt/src/random.c ****                 output[i++] = (byte)tmpRng;
2043:../src/wolfcrypt/src/random.c ****             }
2044:../src/wolfcrypt/src/random.c ****             else {
2045:../src/wolfcrypt/src/random.c ****                 /* Use native 32 instruction */
2046:../src/wolfcrypt/src/random.c ****                 if (HAL_RNG_GenerateRandomNumber(&hrng, (uint32_t*)&output[i]) != HAL_OK) {
2047:../src/wolfcrypt/src/random.c ****                     wolfSSL_CryptHwMutexUnLock();
2048:../src/wolfcrypt/src/random.c ****                     return RAN_BLOCK_E;
2049:../src/wolfcrypt/src/random.c ****                 }
2050:../src/wolfcrypt/src/random.c ****                 i += sizeof(word32);
2051:../src/wolfcrypt/src/random.c ****             }
2052:../src/wolfcrypt/src/random.c ****         }
2053:../src/wolfcrypt/src/random.c **** 
2054:../src/wolfcrypt/src/random.c ****         HAL_RNG_DeInit(&hrng);
2055:../src/wolfcrypt/src/random.c **** 
2056:../src/wolfcrypt/src/random.c ****         wolfSSL_CryptHwMutexUnLock();
2057:../src/wolfcrypt/src/random.c **** 
2058:../src/wolfcrypt/src/random.c ****         return 0;
2059:../src/wolfcrypt/src/random.c ****     }
2060:../src/wolfcrypt/src/random.c ****     #elif defined(WOLFSSL_STM32F427_RNG) || defined(WOLFSSL_STM32_RNG_NOLIB)
2061:../src/wolfcrypt/src/random.c **** 
2062:../src/wolfcrypt/src/random.c ****     /* Generate a RNG seed using the hardware RNG on the STM32F427
2063:../src/wolfcrypt/src/random.c ****      * directly, following steps outlined in STM32F4 Reference
2064:../src/wolfcrypt/src/random.c ****      * Manual (Chapter 24) for STM32F4xx family. */
2065:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2066:../src/wolfcrypt/src/random.c ****     {
2067:../src/wolfcrypt/src/random.c ****         int ret;
2068:../src/wolfcrypt/src/random.c ****         word32 i;
2069:../src/wolfcrypt/src/random.c ****         (void)os;
2070:../src/wolfcrypt/src/random.c **** 
2071:../src/wolfcrypt/src/random.c ****         ret = wolfSSL_CryptHwMutexLock();
2072:../src/wolfcrypt/src/random.c ****         if (ret != 0) {
2073:../src/wolfcrypt/src/random.c ****             return ret;
2074:../src/wolfcrypt/src/random.c ****         }
2075:../src/wolfcrypt/src/random.c **** 
2076:../src/wolfcrypt/src/random.c ****         /* enable RNG peripheral clock */
2077:../src/wolfcrypt/src/random.c ****         RCC->AHB2ENR |= RCC_AHB2ENR_RNGEN;
2078:../src/wolfcrypt/src/random.c **** 
2079:../src/wolfcrypt/src/random.c ****         /* enable RNG interrupt, set IE bit in RNG->CR register */
2080:../src/wolfcrypt/src/random.c ****         RNG->CR |= RNG_CR_IE;
2081:../src/wolfcrypt/src/random.c **** 
2082:../src/wolfcrypt/src/random.c ****         /* enable RNG, set RNGEN bit in RNG->CR. Activates RNG,
2083:../src/wolfcrypt/src/random.c ****          * RNG_LFSR, and error detector */
2084:../src/wolfcrypt/src/random.c ****         RNG->CR |= RNG_CR_RNGEN;
2085:../src/wolfcrypt/src/random.c **** 
2086:../src/wolfcrypt/src/random.c ****         /* verify no errors, make sure SEIS and CEIS bits are 0
2087:../src/wolfcrypt/src/random.c ****          * in RNG->SR register */
2088:../src/wolfcrypt/src/random.c ****         if (RNG->SR & (RNG_SR_SECS | RNG_SR_CECS)) {
2089:../src/wolfcrypt/src/random.c ****             wolfSSL_CryptHwMutexUnLock();
2090:../src/wolfcrypt/src/random.c ****             return RNG_FAILURE_E;
2091:../src/wolfcrypt/src/random.c ****         }
2092:../src/wolfcrypt/src/random.c **** 
2093:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++) {
2094:../src/wolfcrypt/src/random.c ****             /* wait until RNG number is ready */
2095:../src/wolfcrypt/src/random.c ****             while ((RNG->SR & RNG_SR_DRDY) == 0) { }
2096:../src/wolfcrypt/src/random.c **** 
2097:../src/wolfcrypt/src/random.c ****             /* get value */
2098:../src/wolfcrypt/src/random.c ****             output[i] = RNG->DR;
2099:../src/wolfcrypt/src/random.c ****         }
2100:../src/wolfcrypt/src/random.c **** 
2101:../src/wolfcrypt/src/random.c ****         wolfSSL_CryptHwMutexUnLock();
2102:../src/wolfcrypt/src/random.c **** 
2103:../src/wolfcrypt/src/random.c ****         return 0;
2104:../src/wolfcrypt/src/random.c ****     }
2105:../src/wolfcrypt/src/random.c **** 
2106:../src/wolfcrypt/src/random.c ****     #else
2107:../src/wolfcrypt/src/random.c **** 
2108:../src/wolfcrypt/src/random.c ****     /* Generate a RNG seed using the STM32 Standard Peripheral Library */
2109:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2110:../src/wolfcrypt/src/random.c ****     {
2111:../src/wolfcrypt/src/random.c ****         int ret;
2112:../src/wolfcrypt/src/random.c ****         word32 i;
2113:../src/wolfcrypt/src/random.c ****         (void)os;
2114:../src/wolfcrypt/src/random.c **** 
2115:../src/wolfcrypt/src/random.c ****         ret = wolfSSL_CryptHwMutexLock();
2116:../src/wolfcrypt/src/random.c ****         if (ret != 0) {
2117:../src/wolfcrypt/src/random.c ****             return ret;
2118:../src/wolfcrypt/src/random.c ****         }
2119:../src/wolfcrypt/src/random.c **** 
2120:../src/wolfcrypt/src/random.c ****         /* enable RNG clock source */
2121:../src/wolfcrypt/src/random.c ****         RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, ENABLE);
2122:../src/wolfcrypt/src/random.c **** 
2123:../src/wolfcrypt/src/random.c ****         /* reset RNG */
2124:../src/wolfcrypt/src/random.c ****         RNG_DeInit();
2125:../src/wolfcrypt/src/random.c **** 
2126:../src/wolfcrypt/src/random.c ****         /* enable RNG peripheral */
2127:../src/wolfcrypt/src/random.c ****         RNG_Cmd(ENABLE);
2128:../src/wolfcrypt/src/random.c **** 
2129:../src/wolfcrypt/src/random.c ****         /* verify no errors with RNG_CLK or Seed */
2130:../src/wolfcrypt/src/random.c ****         if (RNG_GetFlagStatus(RNG_FLAG_SECS | RNG_FLAG_CECS) != RESET) {
2131:../src/wolfcrypt/src/random.c ****             wolfSSL_CryptHwMutexUnLock();
2132:../src/wolfcrypt/src/random.c ****             return RNG_FAILURE_E;
2133:../src/wolfcrypt/src/random.c ****         }
2134:../src/wolfcrypt/src/random.c **** 
2135:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++) {
2136:../src/wolfcrypt/src/random.c ****             /* wait until RNG number is ready */
2137:../src/wolfcrypt/src/random.c ****             while (RNG_GetFlagStatus(RNG_FLAG_DRDY) == RESET) { }
2138:../src/wolfcrypt/src/random.c **** 
2139:../src/wolfcrypt/src/random.c ****             /* get value */
2140:../src/wolfcrypt/src/random.c ****             output[i] = RNG_GetRandomNumber();
2141:../src/wolfcrypt/src/random.c ****         }
2142:../src/wolfcrypt/src/random.c **** 
2143:../src/wolfcrypt/src/random.c ****         wolfSSL_CryptHwMutexUnLock();
2144:../src/wolfcrypt/src/random.c **** 
2145:../src/wolfcrypt/src/random.c ****         return 0;
2146:../src/wolfcrypt/src/random.c ****     }
2147:../src/wolfcrypt/src/random.c ****     #endif /* WOLFSSL_STM32_CUBEMX */
2148:../src/wolfcrypt/src/random.c **** 
2149:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_TIRTOS)
2150:../src/wolfcrypt/src/random.c ****     #warning "potential for not enough entropy, currently being used for testing"
2151:../src/wolfcrypt/src/random.c ****     #include <xdc/runtime/Timestamp.h>
2152:../src/wolfcrypt/src/random.c ****     #include <stdlib.h>
2153:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2154:../src/wolfcrypt/src/random.c ****     {
2155:../src/wolfcrypt/src/random.c ****         int i;
2156:../src/wolfcrypt/src/random.c ****         srand(xdc_runtime_Timestamp_get32());
2157:../src/wolfcrypt/src/random.c **** 
2158:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++ ) {
2159:../src/wolfcrypt/src/random.c ****             output[i] = rand() % 256;
2160:../src/wolfcrypt/src/random.c ****             if ((i % 8) == 7) {
2161:../src/wolfcrypt/src/random.c ****                 srand(xdc_runtime_Timestamp_get32());
2162:../src/wolfcrypt/src/random.c ****             }
2163:../src/wolfcrypt/src/random.c ****         }
2164:../src/wolfcrypt/src/random.c **** 
2165:../src/wolfcrypt/src/random.c ****         return 0;
2166:../src/wolfcrypt/src/random.c ****     }
2167:../src/wolfcrypt/src/random.c **** 
2168:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_PB)
2169:../src/wolfcrypt/src/random.c **** 
2170:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2171:../src/wolfcrypt/src/random.c ****     {
2172:../src/wolfcrypt/src/random.c ****         word32 i;
2173:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++)
2174:../src/wolfcrypt/src/random.c ****             output[i] = UTL_Rand();
2175:../src/wolfcrypt/src/random.c **** 
2176:../src/wolfcrypt/src/random.c ****         (void)os;
2177:../src/wolfcrypt/src/random.c **** 
2178:../src/wolfcrypt/src/random.c ****         return 0;
2179:../src/wolfcrypt/src/random.c ****     }
2180:../src/wolfcrypt/src/random.c **** 
2181:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_NUCLEUS)
2182:../src/wolfcrypt/src/random.c **** #include "nucleus.h"
2183:../src/wolfcrypt/src/random.c **** #include "kernel/plus_common.h"
2184:../src/wolfcrypt/src/random.c **** 
2185:../src/wolfcrypt/src/random.c **** #warning "potential for not enough entropy, currently being used for testing"
2186:../src/wolfcrypt/src/random.c **** int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2187:../src/wolfcrypt/src/random.c **** {
2188:../src/wolfcrypt/src/random.c ****     int i;
2189:../src/wolfcrypt/src/random.c ****     srand(NU_Get_Time_Stamp());
2190:../src/wolfcrypt/src/random.c **** 
2191:../src/wolfcrypt/src/random.c ****     for (i = 0; i < sz; i++ ) {
2192:../src/wolfcrypt/src/random.c ****         output[i] = rand() % 256;
2193:../src/wolfcrypt/src/random.c ****         if ((i % 8) == 7) {
2194:../src/wolfcrypt/src/random.c ****             srand(NU_Get_Time_Stamp());
2195:../src/wolfcrypt/src/random.c ****         }
2196:../src/wolfcrypt/src/random.c ****     }
2197:../src/wolfcrypt/src/random.c **** 
2198:../src/wolfcrypt/src/random.c ****     return 0;
2199:../src/wolfcrypt/src/random.c **** }
2200:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_DEOS) && !defined(CUSTOM_RAND_GENERATE)
2201:../src/wolfcrypt/src/random.c ****     #include "stdlib.h"
2202:../src/wolfcrypt/src/random.c **** 
2203:../src/wolfcrypt/src/random.c ****     #warning "potential for not enough entropy, currently being used for testing Deos"
2204:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2205:../src/wolfcrypt/src/random.c ****     {
2206:../src/wolfcrypt/src/random.c ****         int i;
2207:../src/wolfcrypt/src/random.c ****         int seed = XTIME(0);
2208:../src/wolfcrypt/src/random.c ****         (void)os;
2209:../src/wolfcrypt/src/random.c **** 
2210:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++ ) {
2211:../src/wolfcrypt/src/random.c ****             output[i] = rand_r(&seed) % 256;
2212:../src/wolfcrypt/src/random.c ****             if ((i % 8) == 7) {
2213:../src/wolfcrypt/src/random.c ****                 seed = XTIME(0);
2214:../src/wolfcrypt/src/random.c ****                 rand_r(&seed);
2215:../src/wolfcrypt/src/random.c ****             }
2216:../src/wolfcrypt/src/random.c ****         }
2217:../src/wolfcrypt/src/random.c **** 
2218:../src/wolfcrypt/src/random.c ****         return 0;
2219:../src/wolfcrypt/src/random.c ****     }
2220:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_VXWORKS)
2221:../src/wolfcrypt/src/random.c ****     #ifdef WOLFSSL_VXWORKS_6_x
2222:../src/wolfcrypt/src/random.c ****         #include "stdlib.h"
2223:../src/wolfcrypt/src/random.c ****         #warning "potential for not enough entropy, currently being used for testing"
2224:../src/wolfcrypt/src/random.c ****         int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2225:../src/wolfcrypt/src/random.c ****         {
2226:../src/wolfcrypt/src/random.c ****             int i;
2227:../src/wolfcrypt/src/random.c ****             unsigned int seed = (unsigned int)XTIME(0);
2228:../src/wolfcrypt/src/random.c ****             (void)os;
2229:../src/wolfcrypt/src/random.c **** 
2230:../src/wolfcrypt/src/random.c ****             for (i = 0; i < sz; i++ ) {
2231:../src/wolfcrypt/src/random.c ****                 output[i] = rand_r(&seed) % 256;
2232:../src/wolfcrypt/src/random.c ****                 if ((i % 8) == 7) {
2233:../src/wolfcrypt/src/random.c ****                     seed = (unsigned int)XTIME(0);
2234:../src/wolfcrypt/src/random.c ****                     rand_r(&seed);
2235:../src/wolfcrypt/src/random.c ****                 }
2236:../src/wolfcrypt/src/random.c ****             }
2237:../src/wolfcrypt/src/random.c **** 
2238:../src/wolfcrypt/src/random.c ****             return 0;
2239:../src/wolfcrypt/src/random.c ****         }
2240:../src/wolfcrypt/src/random.c ****     #else
2241:../src/wolfcrypt/src/random.c ****         #include <randomNumGen.h>
2242:../src/wolfcrypt/src/random.c **** 
2243:../src/wolfcrypt/src/random.c ****         int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz) {
2244:../src/wolfcrypt/src/random.c ****             STATUS        status;
2245:../src/wolfcrypt/src/random.c **** 
2246:../src/wolfcrypt/src/random.c ****             #ifdef VXWORKS_SIM
2247:../src/wolfcrypt/src/random.c ****                 /* cannot generate true entropy with VxWorks simulator */
2248:../src/wolfcrypt/src/random.c ****                 #warning "not enough entropy, simulator for testing only"
2249:../src/wolfcrypt/src/random.c ****                 int i = 0;
2250:../src/wolfcrypt/src/random.c **** 
2251:../src/wolfcrypt/src/random.c ****                 for (i = 0; i < 1000; i++) {
2252:../src/wolfcrypt/src/random.c ****                     randomAddTimeStamp();
2253:../src/wolfcrypt/src/random.c ****                 }
2254:../src/wolfcrypt/src/random.c ****             #endif
2255:../src/wolfcrypt/src/random.c **** 
2256:../src/wolfcrypt/src/random.c ****             status = randBytes (output, sz);
2257:../src/wolfcrypt/src/random.c ****             if (status == ERROR) {
2258:../src/wolfcrypt/src/random.c ****                 return RNG_FAILURE_E;
2259:../src/wolfcrypt/src/random.c ****             }
2260:../src/wolfcrypt/src/random.c **** 
2261:../src/wolfcrypt/src/random.c ****             return 0;
2262:../src/wolfcrypt/src/random.c ****         }
2263:../src/wolfcrypt/src/random.c ****     #endif
2264:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_NRF51) || defined(WOLFSSL_NRF5x)
2265:../src/wolfcrypt/src/random.c ****     #include "app_error.h"
2266:../src/wolfcrypt/src/random.c ****     #include "nrf_drv_rng.h"
2267:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2268:../src/wolfcrypt/src/random.c ****     {
2269:../src/wolfcrypt/src/random.c ****         int remaining = sz, length, pos = 0;
2270:../src/wolfcrypt/src/random.c ****         word32 err_code;
2271:../src/wolfcrypt/src/random.c ****         byte available;
2272:../src/wolfcrypt/src/random.c ****         static byte initialized = 0;
2273:../src/wolfcrypt/src/random.c **** 
2274:../src/wolfcrypt/src/random.c ****         (void)os;
2275:../src/wolfcrypt/src/random.c **** 
2276:../src/wolfcrypt/src/random.c ****         /* Make sure RNG is running */
2277:../src/wolfcrypt/src/random.c ****         if (!initialized) {
2278:../src/wolfcrypt/src/random.c ****             err_code = nrf_drv_rng_init(NULL);
2279:../src/wolfcrypt/src/random.c ****             if (err_code != NRF_SUCCESS && err_code != NRF_ERROR_INVALID_STATE
2280:../src/wolfcrypt/src/random.c ****             #ifdef NRF_ERROR_MODULE_ALREADY_INITIALIZED
2281:../src/wolfcrypt/src/random.c ****                 && err_code != NRF_ERROR_MODULE_ALREADY_INITIALIZED
2282:../src/wolfcrypt/src/random.c ****             #endif
2283:../src/wolfcrypt/src/random.c ****             ) {
2284:../src/wolfcrypt/src/random.c ****                 return -1;
2285:../src/wolfcrypt/src/random.c ****             }
2286:../src/wolfcrypt/src/random.c ****             initialized = 1;
2287:../src/wolfcrypt/src/random.c ****         }
2288:../src/wolfcrypt/src/random.c **** 
2289:../src/wolfcrypt/src/random.c ****         while (remaining > 0) {
2290:../src/wolfcrypt/src/random.c ****             available = 0;
2291:../src/wolfcrypt/src/random.c ****             nrf_drv_rng_bytes_available(&available); /* void func */
2292:../src/wolfcrypt/src/random.c ****             length = (remaining < available) ? remaining : available;
2293:../src/wolfcrypt/src/random.c ****             if (length > 0) {
2294:../src/wolfcrypt/src/random.c ****                 err_code = nrf_drv_rng_rand(&output[pos], length);
2295:../src/wolfcrypt/src/random.c ****                 if (err_code != NRF_SUCCESS) {
2296:../src/wolfcrypt/src/random.c ****                     break;
2297:../src/wolfcrypt/src/random.c ****                 }
2298:../src/wolfcrypt/src/random.c ****                 remaining -= length;
2299:../src/wolfcrypt/src/random.c ****                 pos += length;
2300:../src/wolfcrypt/src/random.c ****             }
2301:../src/wolfcrypt/src/random.c ****         }
2302:../src/wolfcrypt/src/random.c **** 
2303:../src/wolfcrypt/src/random.c ****         return (err_code == NRF_SUCCESS) ? 0 : -1;
2304:../src/wolfcrypt/src/random.c ****     }
2305:../src/wolfcrypt/src/random.c **** 
2306:../src/wolfcrypt/src/random.c **** #elif defined(HAVE_WNR)
2307:../src/wolfcrypt/src/random.c **** 
2308:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2309:../src/wolfcrypt/src/random.c ****     {
2310:../src/wolfcrypt/src/random.c ****         if (os == NULL || output == NULL || wnr_ctx == NULL ||
2311:../src/wolfcrypt/src/random.c ****                 wnr_timeout < 0) {
2312:../src/wolfcrypt/src/random.c ****             return BAD_FUNC_ARG;
2313:../src/wolfcrypt/src/random.c ****         }
2314:../src/wolfcrypt/src/random.c **** 
2315:../src/wolfcrypt/src/random.c ****         if (wnr_mutex_init == 0) {
2316:../src/wolfcrypt/src/random.c ****             WOLFSSL_MSG("netRandom context must be created before use");
2317:../src/wolfcrypt/src/random.c ****             return RNG_FAILURE_E;
2318:../src/wolfcrypt/src/random.c ****         }
2319:../src/wolfcrypt/src/random.c **** 
2320:../src/wolfcrypt/src/random.c ****         if (wc_LockMutex(&wnr_mutex) != 0) {
2321:../src/wolfcrypt/src/random.c ****             WOLFSSL_MSG("Bad Lock Mutex wnr_mutex");
2322:../src/wolfcrypt/src/random.c ****             return BAD_MUTEX_E;
2323:../src/wolfcrypt/src/random.c ****         }
2324:../src/wolfcrypt/src/random.c **** 
2325:../src/wolfcrypt/src/random.c ****         if (wnr_get_entropy(wnr_ctx, wnr_timeout, output, sz, sz) !=
2326:../src/wolfcrypt/src/random.c ****                 WNR_ERROR_NONE)
2327:../src/wolfcrypt/src/random.c ****             return RNG_FAILURE_E;
2328:../src/wolfcrypt/src/random.c **** 
2329:../src/wolfcrypt/src/random.c ****         wc_UnLockMutex(&wnr_mutex);
2330:../src/wolfcrypt/src/random.c **** 
2331:../src/wolfcrypt/src/random.c ****         return 0;
2332:../src/wolfcrypt/src/random.c ****     }
2333:../src/wolfcrypt/src/random.c **** 
2334:../src/wolfcrypt/src/random.c **** #elif defined(INTIME_RTOS)
2335:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2336:../src/wolfcrypt/src/random.c ****     {
2337:../src/wolfcrypt/src/random.c ****         uint32_t randval;
2338:../src/wolfcrypt/src/random.c ****         word32 len;
2339:../src/wolfcrypt/src/random.c **** 
2340:../src/wolfcrypt/src/random.c ****         if (output == NULL) {
2341:../src/wolfcrypt/src/random.c ****             return BUFFER_E;
2342:../src/wolfcrypt/src/random.c ****         }
2343:../src/wolfcrypt/src/random.c **** 
2344:../src/wolfcrypt/src/random.c ****     #ifdef INTIMEVER
2345:../src/wolfcrypt/src/random.c ****         /* If INTIMEVER exists then it is INTIME RTOS v6 or later */
2346:../src/wolfcrypt/src/random.c ****         #define INTIME_RAND_FUNC arc4random
2347:../src/wolfcrypt/src/random.c ****         len = 4;
2348:../src/wolfcrypt/src/random.c ****     #else
2349:../src/wolfcrypt/src/random.c ****         /* v5 and older */
2350:../src/wolfcrypt/src/random.c ****         #define INTIME_RAND_FUNC rand
2351:../src/wolfcrypt/src/random.c ****         srand(time(0));
2352:../src/wolfcrypt/src/random.c ****         len = 2; /* don't use all 31 returned bits */
2353:../src/wolfcrypt/src/random.c ****     #endif
2354:../src/wolfcrypt/src/random.c **** 
2355:../src/wolfcrypt/src/random.c ****         while (sz > 0) {
2356:../src/wolfcrypt/src/random.c ****             if (sz < len)
2357:../src/wolfcrypt/src/random.c ****                 len = sz;
2358:../src/wolfcrypt/src/random.c ****             randval = INTIME_RAND_FUNC();
2359:../src/wolfcrypt/src/random.c ****             XMEMCPY(output, &randval, len);
2360:../src/wolfcrypt/src/random.c ****             output += len;
2361:../src/wolfcrypt/src/random.c ****             sz -= len;
2362:../src/wolfcrypt/src/random.c ****         }
2363:../src/wolfcrypt/src/random.c ****         (void)os;
2364:../src/wolfcrypt/src/random.c **** 
2365:../src/wolfcrypt/src/random.c ****         return 0;
2366:../src/wolfcrypt/src/random.c ****     }
2367:../src/wolfcrypt/src/random.c **** 
2368:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_WICED)
2369:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2370:../src/wolfcrypt/src/random.c ****     {
2371:../src/wolfcrypt/src/random.c ****         int ret;
2372:../src/wolfcrypt/src/random.c ****         (void)os;
2373:../src/wolfcrypt/src/random.c **** 
2374:../src/wolfcrypt/src/random.c ****         if (output == NULL || UINT16_MAX < sz) {
2375:../src/wolfcrypt/src/random.c ****             return BUFFER_E;
2376:../src/wolfcrypt/src/random.c ****         }
2377:../src/wolfcrypt/src/random.c **** 
2378:../src/wolfcrypt/src/random.c ****         if ((ret = wiced_crypto_get_random((void*) output, sz) )
2379:../src/wolfcrypt/src/random.c ****                          != WICED_SUCCESS) {
2380:../src/wolfcrypt/src/random.c ****             return ret;
2381:../src/wolfcrypt/src/random.c ****         }
2382:../src/wolfcrypt/src/random.c **** 
2383:../src/wolfcrypt/src/random.c ****         return ret;
2384:../src/wolfcrypt/src/random.c ****     }
2385:../src/wolfcrypt/src/random.c **** 
2386:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_NETBURNER)
2387:../src/wolfcrypt/src/random.c ****     #warning using NetBurner pseudo random GetRandomByte for seed
2388:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2389:../src/wolfcrypt/src/random.c ****     {
2390:../src/wolfcrypt/src/random.c ****         word32 i;
2391:../src/wolfcrypt/src/random.c ****         (void)os;
2392:../src/wolfcrypt/src/random.c **** 
2393:../src/wolfcrypt/src/random.c ****         if (output == NULL) {
2394:../src/wolfcrypt/src/random.c ****             return BUFFER_E;
2395:../src/wolfcrypt/src/random.c ****         }
2396:../src/wolfcrypt/src/random.c **** 
2397:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++) {
2398:../src/wolfcrypt/src/random.c ****             output[i] = GetRandomByte();
2399:../src/wolfcrypt/src/random.c **** 
2400:../src/wolfcrypt/src/random.c ****             /* check if was a valid random number */
2401:../src/wolfcrypt/src/random.c ****             if (!RandomValid())
2402:../src/wolfcrypt/src/random.c ****                 return RNG_FAILURE_E;
2403:../src/wolfcrypt/src/random.c ****         }
2404:../src/wolfcrypt/src/random.c **** 
2405:../src/wolfcrypt/src/random.c ****         return 0;
2406:../src/wolfcrypt/src/random.c ****     }
2407:../src/wolfcrypt/src/random.c **** #elif defined(IDIRECT_DEV_RANDOM)
2408:../src/wolfcrypt/src/random.c **** 
2409:../src/wolfcrypt/src/random.c ****     extern int getRandom( int sz, unsigned char *output );
2410:../src/wolfcrypt/src/random.c **** 
2411:../src/wolfcrypt/src/random.c ****     int GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2412:../src/wolfcrypt/src/random.c ****     {
2413:../src/wolfcrypt/src/random.c ****         int num_bytes_returned = 0;
2414:../src/wolfcrypt/src/random.c **** 
2415:../src/wolfcrypt/src/random.c ****         num_bytes_returned = getRandom( (int) sz, (unsigned char *) output );
2416:../src/wolfcrypt/src/random.c **** 
2417:../src/wolfcrypt/src/random.c ****         return 0;
2418:../src/wolfcrypt/src/random.c ****     }
2419:../src/wolfcrypt/src/random.c **** 
2420:../src/wolfcrypt/src/random.c **** #elif (defined(WOLFSSL_IMX6_CAAM) || defined(WOLFSSL_IMX6_CAAM_RNG) || \
2421:../src/wolfcrypt/src/random.c ****        defined(WOLFSSL_SECO_CAAM) || defined(WOLFSSL_QNX_CAAM))
2422:../src/wolfcrypt/src/random.c **** 
2423:../src/wolfcrypt/src/random.c ****     #include <wolfssl/wolfcrypt/port/caam/wolfcaam.h>
2424:../src/wolfcrypt/src/random.c **** 
2425:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2426:../src/wolfcrypt/src/random.c ****     {
2427:../src/wolfcrypt/src/random.c ****         unsigned int args[4] = {0};
2428:../src/wolfcrypt/src/random.c ****         CAAM_BUFFER buf[1];
2429:../src/wolfcrypt/src/random.c ****         int ret    = 0;
2430:../src/wolfcrypt/src/random.c ****         int times  = 1000, i; /* 1000 is an arbitrary number chosen */
2431:../src/wolfcrypt/src/random.c ****         word32 idx = 0;
2432:../src/wolfcrypt/src/random.c **** 
2433:../src/wolfcrypt/src/random.c ****         (void)os;
2434:../src/wolfcrypt/src/random.c **** 
2435:../src/wolfcrypt/src/random.c ****         if (output == NULL) {
2436:../src/wolfcrypt/src/random.c ****             return BUFFER_E;
2437:../src/wolfcrypt/src/random.c ****         }
2438:../src/wolfcrypt/src/random.c **** 
2439:../src/wolfcrypt/src/random.c ****         /* Check Waiting to make sure entropy is ready */
2440:../src/wolfcrypt/src/random.c ****         for (i = 0; i < times; i++) {
2441:../src/wolfcrypt/src/random.c ****             buf[0].BufferType = DataBuffer | LastBuffer;
2442:../src/wolfcrypt/src/random.c ****             buf[0].TheAddress = (CAAM_ADDRESS)(output + idx);
2443:../src/wolfcrypt/src/random.c ****             buf[0].Length     = ((sz - idx) < WC_CAAM_MAX_ENTROPY)?
2444:../src/wolfcrypt/src/random.c ****                                 sz - idx : WC_CAAM_MAX_ENTROPY;
2445:../src/wolfcrypt/src/random.c **** 
2446:../src/wolfcrypt/src/random.c ****             args[0] = buf[0].Length;
2447:../src/wolfcrypt/src/random.c ****             ret = wc_caamAddAndWait(buf, 1, args, CAAM_ENTROPY);
2448:../src/wolfcrypt/src/random.c ****             if (ret == 0) {
2449:../src/wolfcrypt/src/random.c ****                 idx += buf[0].Length;
2450:../src/wolfcrypt/src/random.c ****                 if (idx == sz)
2451:../src/wolfcrypt/src/random.c ****                     break;
2452:../src/wolfcrypt/src/random.c ****             }
2453:../src/wolfcrypt/src/random.c **** 
2454:../src/wolfcrypt/src/random.c ****             /* driver could be waiting for entropy */
2455:../src/wolfcrypt/src/random.c ****             if (ret != RAN_BLOCK_E && ret != 0) {
2456:../src/wolfcrypt/src/random.c ****                 return ret;
2457:../src/wolfcrypt/src/random.c ****             }
2458:../src/wolfcrypt/src/random.c ****             usleep(100);
2459:../src/wolfcrypt/src/random.c ****         }
2460:../src/wolfcrypt/src/random.c **** 
2461:../src/wolfcrypt/src/random.c ****         if (i == times && ret != 0) {
2462:../src/wolfcrypt/src/random.c ****              return RNG_FAILURE_E;
2463:../src/wolfcrypt/src/random.c ****         }
2464:../src/wolfcrypt/src/random.c ****         else { /* Success case */
2465:../src/wolfcrypt/src/random.c ****             ret = 0;
2466:../src/wolfcrypt/src/random.c ****         }
2467:../src/wolfcrypt/src/random.c **** 
2468:../src/wolfcrypt/src/random.c ****         return ret;
2469:../src/wolfcrypt/src/random.c ****     }
2470:../src/wolfcrypt/src/random.c **** 
2471:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_APACHE_MYNEWT)
2472:../src/wolfcrypt/src/random.c **** 
2473:../src/wolfcrypt/src/random.c ****     #include <stdlib.h>
2474:../src/wolfcrypt/src/random.c ****     #include "os/os_time.h"
2475:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2476:../src/wolfcrypt/src/random.c ****     {
2477:../src/wolfcrypt/src/random.c ****         int i;
2478:../src/wolfcrypt/src/random.c ****         srand(os_time_get());
2479:../src/wolfcrypt/src/random.c **** 
2480:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++ ) {
2481:../src/wolfcrypt/src/random.c ****             output[i] = rand() % 256;
2482:../src/wolfcrypt/src/random.c ****             if ((i % 8) == 7) {
2483:../src/wolfcrypt/src/random.c ****                 srand(os_time_get());
2484:../src/wolfcrypt/src/random.c ****             }
2485:../src/wolfcrypt/src/random.c ****         }
2486:../src/wolfcrypt/src/random.c **** 
2487:../src/wolfcrypt/src/random.c ****         return 0;
2488:../src/wolfcrypt/src/random.c ****     }
2489:../src/wolfcrypt/src/random.c **** 
2490:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_ESPIDF)
2491:../src/wolfcrypt/src/random.c **** 
2492:../src/wolfcrypt/src/random.c ****     /* Espressif */
2493:../src/wolfcrypt/src/random.c ****     #if defined(WOLFSSL_ESPWROOM32) || defined(WOLFSSL_ESPWROOM32SE)
2494:../src/wolfcrypt/src/random.c **** 
2495:../src/wolfcrypt/src/random.c ****         /* Espressif ESP32 */
2496:../src/wolfcrypt/src/random.c ****         #include <esp_system.h>
2497:../src/wolfcrypt/src/random.c **** 
2498:../src/wolfcrypt/src/random.c ****         int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2499:../src/wolfcrypt/src/random.c ****         {
2500:../src/wolfcrypt/src/random.c ****             word32 rand;
2501:../src/wolfcrypt/src/random.c ****             while (sz > 0) {
2502:../src/wolfcrypt/src/random.c ****                 word32 len = sizeof(rand);
2503:../src/wolfcrypt/src/random.c ****                 if (sz < len)
2504:../src/wolfcrypt/src/random.c ****                     len = sz;
2505:../src/wolfcrypt/src/random.c ****                 /* Get one random 32-bit word from hw RNG */
2506:../src/wolfcrypt/src/random.c ****                 rand = esp_random( );
2507:../src/wolfcrypt/src/random.c ****                 XMEMCPY(output, &rand, len);
2508:../src/wolfcrypt/src/random.c ****                 output += len;
2509:../src/wolfcrypt/src/random.c ****                 sz -= len;
2510:../src/wolfcrypt/src/random.c ****             }
2511:../src/wolfcrypt/src/random.c **** 
2512:../src/wolfcrypt/src/random.c ****             return 0;
2513:../src/wolfcrypt/src/random.c ****         }
2514:../src/wolfcrypt/src/random.c **** 
2515:../src/wolfcrypt/src/random.c ****     #elif defined(WOLFSSL_ESP8266)
2516:../src/wolfcrypt/src/random.c **** 
2517:../src/wolfcrypt/src/random.c ****         /* Espressif ESP8266 */
2518:../src/wolfcrypt/src/random.c ****         #include <esp_system.h>
2519:../src/wolfcrypt/src/random.c **** 
2520:../src/wolfcrypt/src/random.c ****         int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2521:../src/wolfcrypt/src/random.c ****         {
2522:../src/wolfcrypt/src/random.c ****             word32 rand;
2523:../src/wolfcrypt/src/random.c ****             while (sz > 0) {
2524:../src/wolfcrypt/src/random.c ****                 word32 len = sizeof(rand);
2525:../src/wolfcrypt/src/random.c ****                 if (sz < len)
2526:../src/wolfcrypt/src/random.c ****                     len = sz;
2527:../src/wolfcrypt/src/random.c ****                 /* Get one random 32-bit word from hw RNG */
2528:../src/wolfcrypt/src/random.c ****                 rand = esp_random( );
2529:../src/wolfcrypt/src/random.c ****                 XMEMCPY(output, &rand, len);
2530:../src/wolfcrypt/src/random.c ****                 output += len;
2531:../src/wolfcrypt/src/random.c ****                 sz -= len;
2532:../src/wolfcrypt/src/random.c ****             }
2533:../src/wolfcrypt/src/random.c **** 
2534:../src/wolfcrypt/src/random.c ****             return 0;
2535:../src/wolfcrypt/src/random.c ****         }
2536:../src/wolfcrypt/src/random.c ****     #endif /* end WOLFSSL_ESPWROOM32 */
2537:../src/wolfcrypt/src/random.c **** 
2538:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_LINUXKM)
2539:../src/wolfcrypt/src/random.c ****     #include <linux/random.h>
2540:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2541:../src/wolfcrypt/src/random.c ****     {
2542:../src/wolfcrypt/src/random.c ****         (void)os;
2543:../src/wolfcrypt/src/random.c **** 
2544:../src/wolfcrypt/src/random.c ****         get_random_bytes(output, sz);
2545:../src/wolfcrypt/src/random.c **** 
2546:../src/wolfcrypt/src/random.c ****         return 0;
2547:../src/wolfcrypt/src/random.c ****     }
2548:../src/wolfcrypt/src/random.c **** 
2549:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_RENESAS_TSIP)
2550:../src/wolfcrypt/src/random.c **** #if defined(WOLFSSL_RENESA_TSIP_IAREWRX)
2551:../src/wolfcrypt/src/random.c ****    #include "r_bsp/mcu/all/r_rx_compiler.h"
2552:../src/wolfcrypt/src/random.c **** #endif
2553:../src/wolfcrypt/src/random.c ****    #include "r_bsp/platform.h"
2554:../src/wolfcrypt/src/random.c ****     #include "r_tsip_rx_if.h"
2555:../src/wolfcrypt/src/random.c **** 
2556:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2557:../src/wolfcrypt/src/random.c ****     {
2558:../src/wolfcrypt/src/random.c ****         int ret = 0;
2559:../src/wolfcrypt/src/random.c ****         word32 buffer[4];
2560:../src/wolfcrypt/src/random.c **** 
2561:../src/wolfcrypt/src/random.c ****         while (sz > 0) {
2562:../src/wolfcrypt/src/random.c ****             word32 len = sizeof(buffer);
2563:../src/wolfcrypt/src/random.c **** 
2564:../src/wolfcrypt/src/random.c ****             if (sz < len) {
2565:../src/wolfcrypt/src/random.c ****                 len = sz;
2566:../src/wolfcrypt/src/random.c ****             }
2567:../src/wolfcrypt/src/random.c ****             /* return 4 words random number*/
2568:../src/wolfcrypt/src/random.c ****             ret = R_TSIP_GenerateRandomNumber((uint32_t*)buffer);
2569:../src/wolfcrypt/src/random.c ****             if(ret == TSIP_SUCCESS) {
2570:../src/wolfcrypt/src/random.c ****                 XMEMCPY(output, &buffer, len);
2571:../src/wolfcrypt/src/random.c ****                 output += len;
2572:../src/wolfcrypt/src/random.c ****                 sz -= len;
2573:../src/wolfcrypt/src/random.c ****             } else
2574:../src/wolfcrypt/src/random.c ****                 return ret;
2575:../src/wolfcrypt/src/random.c ****         }
2576:../src/wolfcrypt/src/random.c ****         return ret;
2577:../src/wolfcrypt/src/random.c ****     }
2578:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_RENESAS_SCEPROTECT)
2579:../src/wolfcrypt/src/random.c ****     #include "r_sce.h"
2580:../src/wolfcrypt/src/random.c **** 
2581:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2582:../src/wolfcrypt/src/random.c ****     {
2583:../src/wolfcrypt/src/random.c ****         int ret = 0;
2584:../src/wolfcrypt/src/random.c ****         word32 buffer[4];
2585:../src/wolfcrypt/src/random.c **** 
2586:../src/wolfcrypt/src/random.c ****         while (sz > 0) {
2587:../src/wolfcrypt/src/random.c ****             word32 len = sizeof(buffer);
2588:../src/wolfcrypt/src/random.c **** 
2589:../src/wolfcrypt/src/random.c ****             if (sz < len) {
2590:../src/wolfcrypt/src/random.c ****                 len = sz;
2591:../src/wolfcrypt/src/random.c ****             }
2592:../src/wolfcrypt/src/random.c ****             /* return 4 words random number*/
2593:../src/wolfcrypt/src/random.c ****             ret = R_SCE_RandomNumberGenerate(buffer);
2594:../src/wolfcrypt/src/random.c ****             if(ret == FSP_SUCCESS) {
2595:../src/wolfcrypt/src/random.c ****                 XMEMCPY(output, &buffer, len);
2596:../src/wolfcrypt/src/random.c ****                 output += len;
2597:../src/wolfcrypt/src/random.c ****                 sz -= len;
2598:../src/wolfcrypt/src/random.c ****             } else
2599:../src/wolfcrypt/src/random.c ****                 return ret;
2600:../src/wolfcrypt/src/random.c ****         }
2601:../src/wolfcrypt/src/random.c ****         return ret;
2602:../src/wolfcrypt/src/random.c ****     }
2603:../src/wolfcrypt/src/random.c **** 
2604:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_SCE) && !defined(WOLFSSL_SCE_NO_TRNG)
2605:../src/wolfcrypt/src/random.c ****     #include "hal_data.h"
2606:../src/wolfcrypt/src/random.c **** 
2607:../src/wolfcrypt/src/random.c ****     #ifndef WOLFSSL_SCE_TRNG_HANDLE
2608:../src/wolfcrypt/src/random.c ****         #define WOLFSSL_SCE_TRNG_HANDLE g_sce_trng
2609:../src/wolfcrypt/src/random.c ****     #endif
2610:../src/wolfcrypt/src/random.c **** 
2611:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2612:../src/wolfcrypt/src/random.c ****     {
2613:../src/wolfcrypt/src/random.c ****         word32 ret;
2614:../src/wolfcrypt/src/random.c ****         word32 blocks;
2615:../src/wolfcrypt/src/random.c ****         word32 len = sz;
2616:../src/wolfcrypt/src/random.c **** 
2617:../src/wolfcrypt/src/random.c ****         ret = WOLFSSL_SCE_TRNG_HANDLE.p_api->open(WOLFSSL_SCE_TRNG_HANDLE.p_ctrl,
2618:../src/wolfcrypt/src/random.c ****                                                   WOLFSSL_SCE_TRNG_HANDLE.p_cfg);
2619:../src/wolfcrypt/src/random.c ****         if (ret != SSP_SUCCESS && ret != SSP_ERR_CRYPTO_ALREADY_OPEN) {
2620:../src/wolfcrypt/src/random.c ****             /* error opening TRNG driver */
2621:../src/wolfcrypt/src/random.c ****             return -1;
2622:../src/wolfcrypt/src/random.c ****         }
2623:../src/wolfcrypt/src/random.c **** 
2624:../src/wolfcrypt/src/random.c ****         blocks = sz / sizeof(word32);
2625:../src/wolfcrypt/src/random.c ****         if (blocks > 0) {
2626:../src/wolfcrypt/src/random.c ****             ret = WOLFSSL_SCE_TRNG_HANDLE.p_api->read(WOLFSSL_SCE_TRNG_HANDLE.p_ctrl,
2627:../src/wolfcrypt/src/random.c ****                                                        (word32*)output, blocks);
2628:../src/wolfcrypt/src/random.c ****             if (ret != SSP_SUCCESS) {
2629:../src/wolfcrypt/src/random.c ****                 return -1;
2630:../src/wolfcrypt/src/random.c ****             }
2631:../src/wolfcrypt/src/random.c ****         }
2632:../src/wolfcrypt/src/random.c **** 
2633:../src/wolfcrypt/src/random.c ****         len = len - (blocks * sizeof(word32));
2634:../src/wolfcrypt/src/random.c ****         if (len > 0) {
2635:../src/wolfcrypt/src/random.c ****             word32 tmp;
2636:../src/wolfcrypt/src/random.c **** 
2637:../src/wolfcrypt/src/random.c ****             if (len > sizeof(word32)) {
2638:../src/wolfcrypt/src/random.c ****                 return -1;
2639:../src/wolfcrypt/src/random.c ****             }
2640:../src/wolfcrypt/src/random.c ****             ret = WOLFSSL_SCE_TRNG_HANDLE.p_api->read(WOLFSSL_SCE_TRNG_HANDLE.p_ctrl,
2641:../src/wolfcrypt/src/random.c ****                                                       (word32*)&tmp, 1);
2642:../src/wolfcrypt/src/random.c ****             if (ret != SSP_SUCCESS) {
2643:../src/wolfcrypt/src/random.c ****                 return -1;
2644:../src/wolfcrypt/src/random.c ****             }
2645:../src/wolfcrypt/src/random.c ****             XMEMCPY(output + (blocks * sizeof(word32)), (byte*)&tmp, len);
2646:../src/wolfcrypt/src/random.c ****         }
2647:../src/wolfcrypt/src/random.c **** 
2648:../src/wolfcrypt/src/random.c ****         ret = WOLFSSL_SCE_TRNG_HANDLE.p_api->close(WOLFSSL_SCE_TRNG_HANDLE.p_ctrl);
2649:../src/wolfcrypt/src/random.c ****         if (ret != SSP_SUCCESS) {
2650:../src/wolfcrypt/src/random.c ****             /* error opening TRNG driver */
2651:../src/wolfcrypt/src/random.c ****             return -1;
2652:../src/wolfcrypt/src/random.c ****         }
2653:../src/wolfcrypt/src/random.c ****         return 0;
2654:../src/wolfcrypt/src/random.c ****     }
2655:../src/wolfcrypt/src/random.c **** #elif defined(CUSTOM_RAND_GENERATE_BLOCK)
2656:../src/wolfcrypt/src/random.c ****     /* #define CUSTOM_RAND_GENERATE_BLOCK myRngFunc
2657:../src/wolfcrypt/src/random.c ****      * extern int myRngFunc(byte* output, word32 sz);
2658:../src/wolfcrypt/src/random.c ****      */
2659:../src/wolfcrypt/src/random.c **** 
2660:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_SAFERTOS) || defined(WOLFSSL_LEANPSK) || \
2661:../src/wolfcrypt/src/random.c ****       defined(WOLFSSL_IAR_ARM)  || defined(WOLFSSL_MDK_ARM) || \
2662:../src/wolfcrypt/src/random.c ****       defined(WOLFSSL_uITRON4)  || defined(WOLFSSL_uTKERNEL2) || \
2663:../src/wolfcrypt/src/random.c ****       defined(WOLFSSL_LPC43xx)  || defined(NO_STM32_RNG) || \
2664:../src/wolfcrypt/src/random.c ****       defined(MBED)             || defined(WOLFSSL_EMBOS) || \
2665:../src/wolfcrypt/src/random.c ****       defined(WOLFSSL_GENSEED_FORTEST) || defined(WOLFSSL_CHIBIOS) || \
2666:../src/wolfcrypt/src/random.c ****       defined(WOLFSSL_CONTIKI)  || defined(WOLFSSL_AZSPHERE)
2667:../src/wolfcrypt/src/random.c **** 
2668:../src/wolfcrypt/src/random.c ****     /* these platforms do not have a default random seed and
2669:../src/wolfcrypt/src/random.c ****        you'll need to implement your own wc_GenerateSeed or define via
2670:../src/wolfcrypt/src/random.c ****        CUSTOM_RAND_GENERATE_BLOCK */
2671:../src/wolfcrypt/src/random.c **** 
2672:../src/wolfcrypt/src/random.c ****     #define USE_TEST_GENSEED
2673:../src/wolfcrypt/src/random.c **** 
2674:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_ZEPHYR)
2675:../src/wolfcrypt/src/random.c **** 
2676:../src/wolfcrypt/src/random.c ****         #include <random/rand32.h>
2677:../src/wolfcrypt/src/random.c ****     #ifndef _POSIX_C_SOURCE
2678:../src/wolfcrypt/src/random.c ****         #include <posix/time.h>
2679:../src/wolfcrypt/src/random.c ****     #else
2680:../src/wolfcrypt/src/random.c ****         #include <sys/time.h>
2681:../src/wolfcrypt/src/random.c ****     #endif
2682:../src/wolfcrypt/src/random.c **** 
2683:../src/wolfcrypt/src/random.c ****         int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2684:../src/wolfcrypt/src/random.c ****         {
2685:../src/wolfcrypt/src/random.c ****             sys_rand_get(output, sz);
2686:../src/wolfcrypt/src/random.c ****             return 0;
2687:../src/wolfcrypt/src/random.c ****         }
2688:../src/wolfcrypt/src/random.c **** 
2689:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_TELIT_M2MB)
2690:../src/wolfcrypt/src/random.c **** 
2691:../src/wolfcrypt/src/random.c ****         #include "stdlib.h"
2692:../src/wolfcrypt/src/random.c ****         static long get_timestamp(void) {
2693:../src/wolfcrypt/src/random.c ****             long myTime = 0;
2694:../src/wolfcrypt/src/random.c ****             INT32 fd = m2mb_rtc_open("/dev/rtc0", 0);
2695:../src/wolfcrypt/src/random.c ****             if (fd >= 0) {
2696:../src/wolfcrypt/src/random.c ****                 M2MB_RTC_TIMEVAL_T timeval;
2697:../src/wolfcrypt/src/random.c ****                 m2mb_rtc_ioctl(fd, M2MB_RTC_IOCTL_GET_TIMEVAL, &timeval);
2698:../src/wolfcrypt/src/random.c ****                 myTime = timeval.msec;
2699:../src/wolfcrypt/src/random.c ****                 m2mb_rtc_close(fd);
2700:../src/wolfcrypt/src/random.c ****             }
2701:../src/wolfcrypt/src/random.c ****             return myTime;
2702:../src/wolfcrypt/src/random.c ****         }
2703:../src/wolfcrypt/src/random.c ****         int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2704:../src/wolfcrypt/src/random.c ****         {
2705:../src/wolfcrypt/src/random.c ****             int i;
2706:../src/wolfcrypt/src/random.c ****             srand(get_timestamp());
2707:../src/wolfcrypt/src/random.c ****             for (i = 0; i < sz; i++ ) {
2708:../src/wolfcrypt/src/random.c ****                 output[i] = rand() % 256;
2709:../src/wolfcrypt/src/random.c ****                 if ((i % 8) == 7) {
2710:../src/wolfcrypt/src/random.c ****                     srand(get_timestamp());
2711:../src/wolfcrypt/src/random.c ****                 }
2712:../src/wolfcrypt/src/random.c ****             }
2713:../src/wolfcrypt/src/random.c ****             return 0;
2714:../src/wolfcrypt/src/random.c ****         }
2715:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_SE050)
2716:../src/wolfcrypt/src/random.c ****      #include <wolfssl/wolfcrypt/port/nxp/se050_port.h>
2717:../src/wolfcrypt/src/random.c **** 
2718:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz){
2719:../src/wolfcrypt/src/random.c ****         int ret = 0;
2720:../src/wolfcrypt/src/random.c **** 
2721:../src/wolfcrypt/src/random.c ****         (void)os;
2722:../src/wolfcrypt/src/random.c **** 
2723:../src/wolfcrypt/src/random.c ****         if (output == NULL) {
2724:../src/wolfcrypt/src/random.c ****             return BUFFER_E;
2725:../src/wolfcrypt/src/random.c ****         }
2726:../src/wolfcrypt/src/random.c ****         ret = wolfSSL_CryptHwMutexLock();
2727:../src/wolfcrypt/src/random.c ****         if (ret == 0) {
2728:../src/wolfcrypt/src/random.c ****             ret = se050_get_random_number(sz, output);
2729:../src/wolfcrypt/src/random.c ****             wolfSSL_CryptHwMutexUnLock();
2730:../src/wolfcrypt/src/random.c ****         }
2731:../src/wolfcrypt/src/random.c ****         return ret;
2732:../src/wolfcrypt/src/random.c ****     }
2733:../src/wolfcrypt/src/random.c **** 
2734:../src/wolfcrypt/src/random.c **** #elif defined(DOLPHIN_EMULATOR)
2735:../src/wolfcrypt/src/random.c **** 
2736:../src/wolfcrypt/src/random.c ****         int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2737:../src/wolfcrypt/src/random.c ****         {
2738:../src/wolfcrypt/src/random.c ****             word32 i;
2739:../src/wolfcrypt/src/random.c ****             (void)os;
2740:../src/wolfcrypt/src/random.c ****             srand(time(NULL));
2741:../src/wolfcrypt/src/random.c ****             for (i = 0; i < sz; i++)
2742:../src/wolfcrypt/src/random.c ****                 output[i] = (byte)rand();
2743:../src/wolfcrypt/src/random.c ****             return 0;
2744:../src/wolfcrypt/src/random.c ****         }
2745:../src/wolfcrypt/src/random.c **** 
2746:../src/wolfcrypt/src/random.c **** #elif defined(WOLFSSL_GETRANDOM)
2747:../src/wolfcrypt/src/random.c **** 
2748:../src/wolfcrypt/src/random.c ****     /* getrandom() was added to the Linux kernel in version 3.17.
2749:../src/wolfcrypt/src/random.c ****      * Added to glibc in version 2.25. */
2750:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2751:../src/wolfcrypt/src/random.c ****     {
2752:../src/wolfcrypt/src/random.c ****         int ret = 0;
2753:../src/wolfcrypt/src/random.c ****         int len = 0;
2754:../src/wolfcrypt/src/random.c ****         (void)os;
2755:../src/wolfcrypt/src/random.c **** 
2756:../src/wolfcrypt/src/random.c ****         while (sz) {
2757:../src/wolfcrypt/src/random.c ****             errno = 0;
2758:../src/wolfcrypt/src/random.c ****             len = (int)getrandom(output, sz, 0);
2759:../src/wolfcrypt/src/random.c ****             if (len == -1) {
2760:../src/wolfcrypt/src/random.c ****                 if (errno == EINTR) {
2761:../src/wolfcrypt/src/random.c ****                     /* interrupted, call getrandom again */
2762:../src/wolfcrypt/src/random.c ****                     continue;
2763:../src/wolfcrypt/src/random.c ****                 }
2764:../src/wolfcrypt/src/random.c ****                 else {
2765:../src/wolfcrypt/src/random.c ****                     ret = READ_RAN_E;
2766:../src/wolfcrypt/src/random.c ****                 }
2767:../src/wolfcrypt/src/random.c ****                 break;
2768:../src/wolfcrypt/src/random.c ****             }
2769:../src/wolfcrypt/src/random.c **** 
2770:../src/wolfcrypt/src/random.c ****             sz     -= len;
2771:../src/wolfcrypt/src/random.c ****             output += len;
2772:../src/wolfcrypt/src/random.c ****         }
2773:../src/wolfcrypt/src/random.c ****         return ret;
2774:../src/wolfcrypt/src/random.c ****     }
2775:../src/wolfcrypt/src/random.c **** 
2776:../src/wolfcrypt/src/random.c **** #elif defined(NO_DEV_RANDOM)
2777:../src/wolfcrypt/src/random.c **** 
2778:../src/wolfcrypt/src/random.c ****     #error "you need to write an os specific wc_GenerateSeed() here"
2779:../src/wolfcrypt/src/random.c **** 
2780:../src/wolfcrypt/src/random.c ****     /*
2781:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2782:../src/wolfcrypt/src/random.c ****     {
2783:../src/wolfcrypt/src/random.c ****         return 0;
2784:../src/wolfcrypt/src/random.c ****     }
2785:../src/wolfcrypt/src/random.c ****     */
2786:../src/wolfcrypt/src/random.c **** 
2787:../src/wolfcrypt/src/random.c **** #else
2788:../src/wolfcrypt/src/random.c **** 
2789:../src/wolfcrypt/src/random.c ****     /* may block */
2790:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2791:../src/wolfcrypt/src/random.c ****     {
2792:../src/wolfcrypt/src/random.c ****         int ret = 0;
2793:../src/wolfcrypt/src/random.c **** 
2794:../src/wolfcrypt/src/random.c ****         if (os == NULL) {
2795:../src/wolfcrypt/src/random.c ****             return BAD_FUNC_ARG;
2796:../src/wolfcrypt/src/random.c ****         }
2797:../src/wolfcrypt/src/random.c **** 
2798:../src/wolfcrypt/src/random.c ****     #ifdef WOLF_CRYPTO_CB
2799:../src/wolfcrypt/src/random.c ****         if (os->devId != INVALID_DEVID) {
2800:../src/wolfcrypt/src/random.c ****             ret = wc_CryptoCb_RandomSeed(os, output, sz);
2801:../src/wolfcrypt/src/random.c ****             if (ret != CRYPTOCB_UNAVAILABLE)
2802:../src/wolfcrypt/src/random.c ****                 return ret;
2803:../src/wolfcrypt/src/random.c ****             /* fall-through when unavailable */
2804:../src/wolfcrypt/src/random.c ****             ret = 0; /* reset error code */
2805:../src/wolfcrypt/src/random.c ****         }
2806:../src/wolfcrypt/src/random.c ****     #endif
2807:../src/wolfcrypt/src/random.c **** 
2808:../src/wolfcrypt/src/random.c ****     #if defined(HAVE_INTEL_RDSEED) || defined(HAVE_AMD_RDSEED)
2809:../src/wolfcrypt/src/random.c ****         if (IS_INTEL_RDSEED(intel_flags)) {
2810:../src/wolfcrypt/src/random.c ****              ret = wc_GenerateSeed_IntelRD(NULL, output, sz);
2811:../src/wolfcrypt/src/random.c ****              if (ret == 0) {
2812:../src/wolfcrypt/src/random.c ****                  /* success, we're done */
2813:../src/wolfcrypt/src/random.c ****                  return ret;
2814:../src/wolfcrypt/src/random.c ****              }
2815:../src/wolfcrypt/src/random.c ****         #ifdef FORCE_FAILURE_RDSEED
2816:../src/wolfcrypt/src/random.c ****              /* don't fallback to /dev/urandom */
2817:../src/wolfcrypt/src/random.c ****              return ret;
2818:../src/wolfcrypt/src/random.c ****         #else
2819:../src/wolfcrypt/src/random.c ****              /* reset error and fallback to using /dev/urandom */
2820:../src/wolfcrypt/src/random.c ****              ret = 0;
2821:../src/wolfcrypt/src/random.c ****         #endif
2822:../src/wolfcrypt/src/random.c ****         }
2823:../src/wolfcrypt/src/random.c ****     #endif /* HAVE_INTEL_RDSEED || HAVE_AMD_RDSEED */
2824:../src/wolfcrypt/src/random.c **** 
2825:../src/wolfcrypt/src/random.c ****     #ifndef NO_DEV_URANDOM /* way to disable use of /dev/urandom */
2826:../src/wolfcrypt/src/random.c ****         os->fd = open("/dev/urandom", O_RDONLY);
2827:../src/wolfcrypt/src/random.c ****         if (os->fd == -1)
2828:../src/wolfcrypt/src/random.c ****     #endif
2829:../src/wolfcrypt/src/random.c ****         {
2830:../src/wolfcrypt/src/random.c ****             /* may still have /dev/random */
2831:../src/wolfcrypt/src/random.c ****             os->fd = open("/dev/random", O_RDONLY);
2832:../src/wolfcrypt/src/random.c ****             if (os->fd == -1)
2833:../src/wolfcrypt/src/random.c ****                 return OPEN_RAN_E;
2834:../src/wolfcrypt/src/random.c ****         }
2835:../src/wolfcrypt/src/random.c **** 
2836:../src/wolfcrypt/src/random.c ****         while (sz) {
2837:../src/wolfcrypt/src/random.c ****             int len = (int)read(os->fd, output, sz);
2838:../src/wolfcrypt/src/random.c ****             if (len == -1) {
2839:../src/wolfcrypt/src/random.c ****                 ret = READ_RAN_E;
2840:../src/wolfcrypt/src/random.c ****                 break;
2841:../src/wolfcrypt/src/random.c ****             }
2842:../src/wolfcrypt/src/random.c **** 
2843:../src/wolfcrypt/src/random.c ****             sz     -= len;
2844:../src/wolfcrypt/src/random.c ****             output += len;
2845:../src/wolfcrypt/src/random.c **** 
2846:../src/wolfcrypt/src/random.c ****             if (sz) {
2847:../src/wolfcrypt/src/random.c ****     #if defined(BLOCKING) || defined(WC_RNG_BLOCKING)
2848:../src/wolfcrypt/src/random.c ****                 sleep(0);             /* context switch */
2849:../src/wolfcrypt/src/random.c ****     #else
2850:../src/wolfcrypt/src/random.c ****                 ret = RAN_BLOCK_E;
2851:../src/wolfcrypt/src/random.c ****                 break;
2852:../src/wolfcrypt/src/random.c ****     #endif
2853:../src/wolfcrypt/src/random.c ****             }
2854:../src/wolfcrypt/src/random.c ****         }
2855:../src/wolfcrypt/src/random.c ****         close(os->fd);
2856:../src/wolfcrypt/src/random.c **** 
2857:../src/wolfcrypt/src/random.c ****         return ret;
2858:../src/wolfcrypt/src/random.c ****     }
2859:../src/wolfcrypt/src/random.c **** 
2860:../src/wolfcrypt/src/random.c **** #endif
2861:../src/wolfcrypt/src/random.c **** 
2862:../src/wolfcrypt/src/random.c **** #ifdef USE_TEST_GENSEED
2863:../src/wolfcrypt/src/random.c ****     #ifndef _MSC_VER
2864:../src/wolfcrypt/src/random.c ****         #warning "write a real random seed!!!!, just for testing now"
2865:../src/wolfcrypt/src/random.c ****     #else
2866:../src/wolfcrypt/src/random.c ****         #pragma message("Warning: write a real random seed!!!!, just for testing now")
2867:../src/wolfcrypt/src/random.c ****     #endif
2868:../src/wolfcrypt/src/random.c ****     int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
2869:../src/wolfcrypt/src/random.c ****     {
 2844                             		.loc 2 2869 5
 2845 0000 7E AA                   		push.l	r10
 2846                             	.LCFI71:
 2847 0002 71 0A F0                		add	#-16, r0, r10
 2848                             	.LCFI72:
 2849 0005 EF A0                   		mov.L	r10, r0
 2850 0007 E7 A1 01                		mov.L	r1, 4[r10]
 2851 000a E7 A2 02                		mov.L	r2, 8[r10]
 2852 000d E7 A3 03                		mov.L	r3, 12[r10]
2870:../src/wolfcrypt/src/random.c ****         word32 i;
2871:../src/wolfcrypt/src/random.c ****         for (i = 0; i < sz; i++ )
 2853                             		.loc 2 2871 16
 2854 0010 F8 A6 00                		mov.L	#0, [r10]
 2855                             		.loc 2 2871 9
 2856 0013 2E 12                   		bra	.L180
 2857                             	.L181:
2872:../src/wolfcrypt/src/random.c ****             output[i] = i;
 2858                             		.loc 2 2872 19 discriminator 3
 2859 0015 ED A5 02                		mov.L	8[r10], r5
 2860 0018 06 88 A5                		add	[r10].L, r5
 2861                             		.loc 2 2872 23 discriminator 3
 2862 001b EC A4                   		mov.L	[r10], r4
 2863 001d C3 54                   		mov.B	r4, [r5]
2871:../src/wolfcrypt/src/random.c ****             output[i] = i;
 2864                             		.loc 2 2871 30 discriminator 3
 2865 001f EC A5                   		mov.L	[r10], r5
 2866 0021 62 15                   		add	#1, r5
 2867 0023 E3 A5                   		mov.L	r5, [r10]
 2868                             	.L180:
2871:../src/wolfcrypt/src/random.c ****             output[i] = i;
 2869                             		.loc 2 2871 9 discriminator 1
 2870 0025 EC A4                   		mov.L	[r10], r4
 2871 0027 ED A5 03                		mov.L	12[r10], r5
 2872 002a 47 54                   		cmp	r5, r4
 2873 002c 23 E9                   		bltu	.L181
2873:../src/wolfcrypt/src/random.c **** 
2874:../src/wolfcrypt/src/random.c ****         (void)os;
2875:../src/wolfcrypt/src/random.c **** 
2876:../src/wolfcrypt/src/random.c ****         return 0;
 2874                             		.loc 2 2876 16
 2875 002e 66 05                   		mov.L	#0, r5
2877:../src/wolfcrypt/src/random.c ****     }
 2876                             		.loc 2 2877 5
 2877 0030 EF 51                   		mov.L	r5, r1
 2878 0032 3F AA 05                		rtsd	#20, r10-r10
 2879                             	.LFE66:
 3535                             	.Letext0:
 3536                             		.file 3 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\lib\\gcc\\rx-
 3537                             		.file 4 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 3538                             		.file 5 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 3539                             		.file 6 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 3540                             		.file 7 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 3541                             		.file 8 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/types.h"
 3542                             		.file 9 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 3543                             		.file 10 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\incl
 3544                             		.file 11 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/error-crypt.h"
 3545                             		.file 12 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha256.h"
 3546                             		.file 13 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/random.h"
