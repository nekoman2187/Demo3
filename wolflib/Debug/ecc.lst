   1                             		.file	"ecc.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.section	.text.ForceZero,"ax",@progbits
   6                             	_ForceZero:
   7                             	.LFB13:
   8                             		.file 1 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfcrypt/src/misc.c"
   1:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* misc.c
   2:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   3:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   5:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * This file is part of wolfSSL.
   6:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
   7:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * it under the terms of the GNU General Public License as published by
   9:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * (at your option) any later version.
  11:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  12:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * GNU General Public License for more details.
  16:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  *
  17:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * You should have received a copy of the GNU General Public License
  18:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * along with this program; if not, write to the Free Software
  19:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  21:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /*
  22:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  23:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** DESCRIPTION
  24:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** This module implements the arithmetic-shift right, left, byte swapping, XOR,
  25:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** masking and clearing memory logic.
  26:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  27:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** */
  28:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef HAVE_CONFIG_H
  29:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <config.h>
  30:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  31:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  32:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/settings.h>
  33:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  34:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLF_CRYPT_MISC_C
  35:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #define WOLF_CRYPT_MISC_C
  36:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  37:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #include <wolfssl/wolfcrypt/misc.h>
  38:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  39:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* inlining these functions is a huge speed increase and a small size decrease,
  40:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    because the functions are smaller than function call setup/cleanup, e.g.,
  41:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    md5 benchmark is twice as fast with inline.  If you don't want it, then
  42:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    define NO_INLINE and compile this file into wolfssl, otherwise it's used as
  43:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    a source header
  44:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****  */
  45:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  46:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef NO_INLINE
  47:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC
  48:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  49:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define WC_STATIC static
  50:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  51:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  52:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* Check for if compiling misc.c when not needed. */
  53:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if !defined(WOLFSSL_MISC_INCLUDED) && !defined(NO_INLINE)
  54:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_IGNORE_FILE_WARN
  55:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         #warning misc.c does not need to be compiled when using inline (NO_INLINE not defined)
  56:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
  57:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  58:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
  59:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  60:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  61:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__ICCARM__)
  62:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <intrinsics.h>
  63:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
  64:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  65:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  66:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef INTEL_INTRINSICS
  67:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  68:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <stdlib.h>      /* get intrinsic definitions */
  69:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  70:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* for non visual studio probably need no long version, 32 bit only
  71:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****      * i.e., _rotl and _rotr */
  72:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #pragma intrinsic(_lrotl, _lrotr)
  73:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  74:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  75:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  76:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotl(x, y) : x;
  77:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  78:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  79:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
  80:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  81:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return y ? _lrotr(x, y) : x;
  82:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
  83:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  84:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
  85:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  86:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #include <builtin.h>      /* get intrinsic definitions */
  87:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  88:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #if !defined(NO_INLINE)
  89:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  90:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotlFixed(x, y) _builtin_rotl(x, y)
  91:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  92:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define rotrFixed(x, y) _builtin_rotr(x, y)
  93:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  94:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #else /* create real function */
  95:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
  96:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
  97:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
  98:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotl(x, y);
  99:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 100:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 101:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 102:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 103:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return _builtin_rotr(x, y);
 104:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 105:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 106:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 107:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 108:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else /* generic */
 109:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value. */
 110:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 111:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotlFixed(word32 x, word32 y)
 112:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 113:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x << y) | (x >> (sizeof(y) * 8 - y));
 114:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 115:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 116:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value. */
 117:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
 118:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     {
 119:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         return (x >> y) | (x << (sizeof(y) * 8 - y));
 120:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 121:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 122:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 123:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 124:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef WC_RC2
 125:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 126:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a left circular arithmetic shift of <x> by <y> value */
 127:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotlFixed16(word16 x, word16 y)
 128:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 129:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 130:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 131:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 132:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 133:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a right circular arithmetic shift of <x> by <y> value */
 134:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word16 rotrFixed16(word16 x, word16 y)
 135:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 136:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 137:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 138:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 139:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WC_RC2 */
 140:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 141:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of 32-bit word value. */
 142:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(__CCRX__) && !defined(NO_INLINE) /* shortest version for CC-RX */
 143:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #define ByteReverseWord32(value) _builtin_revl(value)
 144:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 145:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word32 ByteReverseWord32(word32 value)
 146:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 147:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifdef PPC_INTRINSICS
 148:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* PPC: load reverse indexed instruction */
 149:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__lwbrx(&value,0);
 150:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__ICCARM__)
 151:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__REV(value);
 152:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(KEIL_INTRINSICS)
 153:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__rev(value);
 154:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(__CCRX__)
 155:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)_builtin_revl(value);
 156:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLF_ALLOW_BUILTIN) && \
 157:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 158:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word32)__builtin_bswap32(value);
 159:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 160:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       defined(__aarch64__)
 161:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 162:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV32 %0, %0  \n"
 163:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 164:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 165:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 166:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 167:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFSSL_BYTESWAP32_ASM) && defined(__GNUC__) && \
 168:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****       (defined(__thumb__) || defined(__arm__))
 169:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     __asm__ volatile (
 170:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         "REV %0, %0  \n"
 171:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         : "+r" (value)
 172:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         :
 173:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     );
 174:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return value;
 175:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(FAST_ROTATE)
 176:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 5 instructions with rotate instruction, 9 without */
 177:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (rotrFixed(value, 8U) & 0xff00ff00) |
 178:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****            (rotlFixed(value, 8U) & 0x00ff00ff);
 179:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 180:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     /* 6 instructions with rotate instruction, 8 without */
 181:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 182:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed(value, 16U);
 183:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 184:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 185:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* __CCRX__ */
 186:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a byte swap of words array of a given count. */
 187:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords(word32* out, const word32* in,
 188:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                     word32 byteCount)
 189:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 190:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word32), i;
 191:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 192:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 193:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord32(in[i]);
 194:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 195:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 196:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 197:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WORD64_AVAILABLE) && !defined(WOLFSSL_NO_WORD64_OPS)
 198:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 199:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 200:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotlFixed64(word64 x, word64 y)
 201:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 202:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x << y) | (x >> (sizeof(y) * 8 - y));
 203:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 204:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 205:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 206:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 rotrFixed64(word64 x, word64 y)
 207:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 208:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (x >> y) | (x << (sizeof(y) * 8 - y));
 209:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 210:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 211:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 212:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE word64 ByteReverseWord64(word64 value)
 213:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 214:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if defined(WOLF_ALLOW_BUILTIN) && defined(__GNUC_PREREQ) && __GNUC_PREREQ(4, 3)
 215:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)__builtin_bswap64(value);
 216:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #elif defined(WOLFCRYPT_SLOW_WORD64)
 217:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return (word64)((word64)ByteReverseWord32((word32) value)) << 32 |
 218:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         (word64)ByteReverseWord32((word32)(value   >> 32));
 219:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #else
 220:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) |
 221:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
 222:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) |
 223:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
 224:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     return rotlFixed64(value, 32U);
 225:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 226:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 227:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 228:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 229:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ByteReverseWords64(word64* out, const word64* in,
 230:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                       word32 byteCount)
 231:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 232:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 count = byteCount/(word32)sizeof(word64), i;
 233:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 234:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < count; i++)
 235:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         out[i] = ByteReverseWord64(in[i]);
 236:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 237:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 238:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 239:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif /* WORD64_AVAILABLE && !WOLFSSL_NO_WORD64_OPS */
 240:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 241:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_XOR_OPS
 242:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 243:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 244:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWordsOut(wolfssl_word* r, const wolfssl_word* a,
 245:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                      const wolfssl_word* b, word32 n)
 246:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 247:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 248:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 249:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] = a[i] ^ b[i];
 250:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 251:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 252:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 253:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 254:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 255:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbufout(void*out, const void* buf, const void* mask,
 256:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                    word32 count)
 257:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 258:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)out | (wc_ptr_t)buf | (wc_ptr_t)mask | count) %
 259:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                          WOLFSSL_WORD_SIZE == 0)
 260:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWordsOut( (wolfssl_word*)out, (wolfssl_word*)buf,
 261:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                      (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 262:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 263:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 264:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       o = (byte*)out;
 265:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 266:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 267:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 268:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) o[i] = b[i] ^ m[i];
 269:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 270:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 271:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 272:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*r> and <*a> for <n> number
 273:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** of wolfssl_words, placing the result in <*r>. */
 274:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void XorWords(wolfssl_word* r, const wolfssl_word* a, word32 n)
 275:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 276:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     word32 i;
 277:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 278:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (i = 0; i < n; i++) r[i] ^= a[i];
 279:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 280:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 281:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
 282:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** counts, placing the result in <*buf>. */
 283:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 284:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void xorbuf(void* buf, const void* mask, word32 count)
 285:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
 286:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     if (((wc_ptr_t)buf | (wc_ptr_t)mask | count) % WOLFSSL_WORD_SIZE == 0)
 287:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         XorWords( (wolfssl_word*)buf,
 288:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                   (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
 289:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     else {
 290:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 i;
 291:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         byte*       b = (byte*)buf;
 292:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         const byte* m = (const byte*)mask;
 293:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 294:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         for (i = 0; i < count; i++) b[i] ^= m[i];
 295:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     }
 296:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
 297:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 298:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 299:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #ifndef WOLFSSL_NO_FORCE_ZERO
 300:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** /* This routine fills the first len bytes of the memory area pointed by mem
 301:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****    with zeros. It ensures compiler optimizations doesn't skip it  */
 302:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** WC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
 303:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** {
   9                             		.loc 1 303 1
  10 0000 7E AA                   		push.l	r10
  11                             	.LCFI0:
  12 0002 71 0A F4                		add	#-12, r0, r10
  13                             	.LCFI1:
  14 0005 EF A0                   		mov.L	r10, r0
  15 0007 E7 A1 01                		mov.L	r1, 4[r10]
  16 000a E7 A2 02                		mov.L	r2, 8[r10]
 304:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile byte* z = (volatile byte*)mem;
  17                             		.loc 1 304 20
  18 000d ED A5 01                		mov.L	4[r10], r5
  19 0010 E3 A5                   		mov.L	r5, [r10]
 305:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 306:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #if (defined(WOLFSSL_X86_64_BUILD) || defined(WOLFSSL_AARCH64_BUILD)) \
 307:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****             && defined(WORD64_AVAILABLE)
 308:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     volatile word64* w;
 309:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #ifndef WOLFSSL_UNALIGNED_64BIT_ACCESS
 310:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         word32 l = (sizeof(word64) - ((size_t)z & (sizeof(word64)-1))) &
 311:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****                                                              (sizeof(word64)-1);
 312:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 313:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         if (len < l) l = len;
 314:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         len -= l;
 315:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         while (l--) *z++ = 0;
 316:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     #endif
 317:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
 318:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****         *w++ = 0;
 319:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     z = (volatile byte*)w;
 320:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** #endif
 321:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** 
 322:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c ****     while (len--) *z++ = 0;
  20                             		.loc 1 322 11
  21 0012 2E 0C                   		bra	.L2
  22                             	.L3:
  23                             		.loc 1 322 21 discriminator 2
  24 0014 EC A5                   		mov.L	[r10], r5
  25 0016 71 54 01                		add	#1, r5, r4
  26 0019 E3 A4                   		mov.L	r4, [r10]
  27                             		.loc 1 322 24 discriminator 2
  28 001b F8 54 00                		mov.B	#0, [r5]
  29                             	.L2:
  30                             		.loc 1 322 15 discriminator 1
  31 001e ED A5 02                		mov.L	8[r10], r5
  32 0021 71 54 FF                		add	#-1, r5, r4
  33 0024 E7 A4 02                		mov.L	r4, 8[r10]
  34                             		.loc 1 322 11 discriminator 1
  35 0027 61 05                   		cmp	#0, r5
  36 0029 21 EB                   		bne	.L3
 323:C:\Users\nekom\e2_studio\e2sss_proj\wolflib\src/wolfcrypt/src\misc.c **** }
  37                             		.loc 1 323 1
  38 002b 03                      		nop
  39 002c 3F AA 04                		rtsd	#16, r10-r10
  40                             	.LFE13:
  42                             		.section	.rodata.ecc_oid_secp224r1,"a"
  45                             	_ecc_oid_secp224r1:
  46 0000 2B                      		.byte	43
  47 0001 81                      		.byte	-127
  48 0002 04                      		.byte	4
  49 0003 00                      		.byte	0
  50 0004 21                      		.byte	33
  51                             		.section	.rodata.ecc_oid_prime239v1,"a"
  54                             	_ecc_oid_prime239v1:
  55 0000 2A                      		.byte	42
  56 0001 86                      		.byte	-122
  57 0002 48                      		.byte	0x48
  58 0003 CE                      		.byte	-50
  59 0004 3D                      		.byte	61
  60 0005 03                      		.byte	3
  61 0006 01                      		.byte	1
  62 0007 04                      		.byte	4
  63                             		.section	.rodata.ecc_oid_secp256r1,"a"
  66                             	_ecc_oid_secp256r1:
  67 0000 2A                      		.byte	42
  68 0001 86                      		.byte	-122
  69 0002 48                      		.byte	0x48
  70 0003 CE                      		.byte	-50
  71 0004 3D                      		.byte	61
  72 0005 03                      		.byte	3
  73 0006 01                      		.byte	1
  74 0007 07                      		.byte	7
  75                             		.section	.rodata.ecc_oid_secp384r1,"a"
  78                             	_ecc_oid_secp384r1:
  79 0000 2B                      		.byte	43
  80 0001 81                      		.byte	-127
  81 0002 04                      		.byte	4
  82 0003 00                      		.byte	0
  83 0004 22                      		.byte	34
  84                             		.section	.rodata.ecc_oid_secp521r1,"a"
  87                             	_ecc_oid_secp521r1:
  88 0000 2B                      		.byte	43
  89 0001 81                      		.byte	-127
  90 0002 04                      		.byte	4
  91 0003 00                      		.byte	0
  92 0004 23                      		.byte	35
  93                             		.global	_ecc_sets
  94                             		.section C,"a",@progbits
  95                             		.p2align 2
  96                             	.LC0:
  97 0000 53 45 43 50 32 32 34 52 		.string	"SECP224R1"
  97      31 00 
  98                             	.LC1:
  99 000a 46 46 46 46 46 46 46 46 		.string	"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001"
  99      46 46 46 46 46 46 46 46 
  99      46 46 46 46 46 46 46 46 
  99      46 46 46 46 46 46 46 46 
  99      30 30 30 30 30 30 30 30 
 100                             	.LC2:
 101 0043 46 46 46 46 46 46 46 46 		.string	"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE"
 101      46 46 46 46 46 46 46 46 
 101      46 46 46 46 46 46 46 46 
 101      46 46 46 46 46 46 46 45 
 101      46 46 46 46 46 46 46 46 
 102                             	.LC3:
 103 007c 42 34 30 35 30 41 38 35 		.string	"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4"
 103      30 43 30 34 42 33 41 42 
 103      46 35 34 31 33 32 35 36 
 103      35 30 34 34 42 30 42 37 
 103      44 37 42 46 44 38 42 41 
 104                             	.LC4:
 105 00b5 46 46 46 46 46 46 46 46 		.string	"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D"
 105      46 46 46 46 46 46 46 46 
 105      46 46 46 46 46 46 46 46 
 105      46 46 46 46 31 36 41 32 
 105      45 30 42 38 46 30 33 45 
 106                             	.LC5:
 107 00ee 42 37 30 45 30 43 42 44 		.string	"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"
 107      36 42 42 34 42 46 37 46 
 107      33 32 31 33 39 30 42 39 
 107      34 41 30 33 43 31 44 33 
 107      35 36 43 32 31 31 32 32 
 108                             	.LC6:
 109 0127 42 44 33 37 36 33 38 38 		.string	"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34"
 109      42 35 46 37 32 33 46 42 
 109      34 43 32 32 44 46 45 36 
 109      43 44 34 33 37 35 41 30 
 109      35 41 30 37 34 37 36 34 
 110                             	.LC7:
 111 0160 50 52 49 4D 45 32 33 39 		.string	"PRIME239V1"
 111      56 31 00 
 112                             	.LC8:
 113 016b 37 46 46 46 46 46 46 46 		.string	"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF"
 113      46 46 46 46 46 46 46 46 
 113      46 46 46 46 46 46 46 46 
 113      37 46 46 46 46 46 46 46 
 113      46 46 46 46 38 30 30 30 
 114                             	.LC9:
 115 01a8 37 46 46 46 46 46 46 46 		.string	"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC"
 115      46 46 46 46 46 46 46 46 
 115      46 46 46 46 46 46 46 46 
 115      37 46 46 46 46 46 46 46 
 115      46 46 46 46 38 30 30 30 
 116                             	.LC10:
 117 01e5 36 42 30 31 36 43 33 42 		.string	"6B016C3BDCF18941D0D654921475CA71A9DB2FB27D1D37796185C2942C0A"
 117      44 43 46 31 38 39 34 31 
 117      44 30 44 36 35 34 39 32 
 117      31 34 37 35 43 41 37 31 
 117      41 39 44 42 32 46 42 32 
 118                             	.LC11:
 119 0222 37 46 46 46 46 46 46 46 		.string	"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFF9E5E9A9F5D9071FBD1522688909D0B"
 119      46 46 46 46 46 46 46 46 
 119      46 46 46 46 46 46 46 46 
 119      37 46 46 46 46 46 39 45 
 119      35 45 39 41 39 46 35 44 
 120                             	.LC12:
 121 025f 30 46 46 41 39 36 33 43 		.string	"0FFA963CDCA8816CCC33B8642BEDF905C3D358573D3F27FBBD3B3CB9AAAF"
 121      44 43 41 38 38 31 36 43 
 121      43 43 33 33 42 38 36 34 
 121      32 42 45 44 46 39 30 35 
 121      43 33 44 33 35 38 35 37 
 122                             	.LC13:
 123 029c 37 44 45 42 45 38 45 34 		.string	"7DEBE8E4E90A5DAE6E4054CA530BA04654B36818CE226B39FCCB7B02F1AE"
 123      45 39 30 41 35 44 41 45 
 123      36 45 34 30 35 34 43 41 
 123      35 33 30 42 41 30 34 36 
 123      35 34 42 33 36 38 31 38 
 124                             	.LC14:
 125 02d9 53 45 43 50 32 35 36 52 		.string	"SECP256R1"
 125      31 00 
 126                             	.LC15:
 127 02e3 46 46 46 46 46 46 46 46 		.string	"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF"
 127      30 30 30 30 30 30 30 31 
 127      30 30 30 30 30 30 30 30 
 127      30 30 30 30 30 30 30 30 
 127      30 30 30 30 30 30 30 30 
 128                             	.LC16:
 129 0324 46 46 46 46 46 46 46 46 		.string	"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC"
 129      30 30 30 30 30 30 30 31 
 129      30 30 30 30 30 30 30 30 
 129      30 30 30 30 30 30 30 30 
 129      30 30 30 30 30 30 30 30 
 130                             	.LC17:
 131 0365 35 41 43 36 33 35 44 38 		.string	"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B"
 131      41 41 33 41 39 33 45 37 
 131      42 33 45 42 42 44 35 35 
 131      37 36 39 38 38 36 42 43 
 131      36 35 31 44 30 36 42 30 
 132                             	.LC18:
 133 03a6 46 46 46 46 46 46 46 46 		.string	"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551"
 133      30 30 30 30 30 30 30 30 
 133      46 46 46 46 46 46 46 46 
 133      46 46 46 46 46 46 46 46 
 133      42 43 45 36 46 41 41 44 
 134                             	.LC19:
 135 03e7 36 42 31 37 44 31 46 32 		.string	"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"
 135      45 31 32 43 34 32 34 37 
 135      46 38 42 43 45 36 45 35 
 135      36 33 41 34 34 30 46 32 
 135      37 37 30 33 37 44 38 31 
 136                             	.LC20:
 137 0428 34 46 45 33 34 32 45 32 		.string	"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5"
 137      46 45 31 41 37 46 39 42 
 137      38 45 45 37 45 42 34 41 
 137      37 43 30 46 39 45 31 36 
 137      32 42 43 45 33 33 35 37 
 138                             	.LC21:
 139 0469 53 45 43 50 33 38 34 52 		.string	"SECP384R1"
 139      31 00 
 140                             	.LC22:
 141 0473 46 46 46 46 46 46 46 46 		.string	"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000F
 141      46 46 46 46 46 46 46 46 
 141      46 46 46 46 46 46 46 46 
 141      46 46 46 46 46 46 46 46 
 141      46 46 46 46 46 46 46 46 
 142                             	.LC23:
 143 04d4 46 46 46 46 46 46 46 46 		.string	"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000F
 143      46 46 46 46 46 46 46 46 
 143      46 46 46 46 46 46 46 46 
 143      46 46 46 46 46 46 46 46 
 143      46 46 46 46 46 46 46 46 
 144                             	.LC24:
 145 0535 42 33 33 31 32 46 41 37 		.string	"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD
 145      45 32 33 45 45 37 45 34 
 145      39 38 38 45 30 35 36 42 
 145      45 33 46 38 32 44 31 39 
 145      31 38 31 44 39 43 36 45 
 146                             	.LC25:
 147 0596 46 46 46 46 46 46 46 46 		.string	"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196AC
 147      46 46 46 46 46 46 46 46 
 147      46 46 46 46 46 46 46 46 
 147      46 46 46 46 46 46 46 46 
 147      46 46 46 46 46 46 46 46 
 148                             	.LC26:
 149 05f7 41 41 38 37 43 41 32 32 		.string	"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E387
 149      42 45 38 42 30 35 33 37 
 149      38 45 42 31 43 37 31 45 
 149      46 33 32 30 41 44 37 34 
 149      36 45 31 44 33 42 36 32 
 150                             	.LC27:
 151 0658 33 36 31 37 44 45 34 41 		.string	"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C9
 151      39 36 32 36 32 43 36 46 
 151      35 44 39 45 39 38 42 46 
 151      39 32 39 32 44 43 32 39 
 151      46 38 46 34 31 44 42 44 
 152                             	.LC28:
 153 06b9 53 45 43 50 35 32 31 52 		.string	"SECP521R1"
 153      31 00 
 154                             	.LC29:
 155 06c3 31 46 46 46 46 46 46 46 		.string	"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 155      46 46 46 46 46 46 46 46 
 155      46 46 46 46 46 46 46 46 
 155      46 46 46 46 46 46 46 46 
 155      46 46 46 46 46 46 46 46 
 156                             	.LC30:
 157 0747 31 46 46 46 46 46 46 46 		.string	"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 157      46 46 46 46 46 46 46 46 
 157      46 46 46 46 46 46 46 46 
 157      46 46 46 46 46 46 46 46 
 157      46 46 46 46 46 46 46 46 
 158                             	.LC31:
 159 07cb 35 31 39 35 33 45 42 39 		.string	"51953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0B
 159      36 31 38 45 31 43 39 41 
 159      31 46 39 32 39 41 32 31 
 159      41 30 42 36 38 35 34 30 
 159      45 45 41 32 44 41 37 32 
 160                             	.LC32:
 161 084e 31 46 46 46 46 46 46 46 		.string	"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC01
 161      46 46 46 46 46 46 46 46 
 161      46 46 46 46 46 46 46 46 
 161      46 46 46 46 46 46 46 46 
 161      46 46 46 46 46 46 46 46 
 162                             	.LC33:
 163 08d2 43 36 38 35 38 45 30 36 		.string	"C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC12
 163      42 37 30 34 30 34 45 39 
 163      43 44 39 45 33 45 43 42 
 163      36 36 32 33 39 35 42 34 
 163      34 32 39 43 36 34 38 31 
 164                             	.LC34:
 165 0955 31 31 38 33 39 32 39 36 		.string	"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9
 165      41 37 38 39 41 33 42 43 
 165      30 30 34 35 43 38 41 35 
 165      46 42 34 32 43 37 44 31 
 165      42 44 39 39 38 46 35 34 
 166                             		.section	.rodata.ecc_sets,"a"
 167                             		.balign 4
 170                             	_ecc_sets:
 171 0000 1C 00 00 00             		.long	28
 172 0004 0E 00 00 00             		.long	14
 173 0008 00 00 00 00             		.long	.LC0
 174 000c 0A 00 00 00             		.long	.LC1
 175 0010 43 00 00 00             		.long	.LC2
 176 0014 7C 00 00 00             		.long	.LC3
 177 0018 B5 00 00 00             		.long	.LC4
 178 001c EE 00 00 00             		.long	.LC5
 179 0020 27 01 00 00             		.long	.LC6
 180 0024 00 00 00 00             		.long	_ecc_oid_secp224r1
 181 0028 05 00 00 00             		.long	5
 182 002c D1 00 00 00             		.long	0xd1
 183 0030 01 00 00 00             		.long	1
 184 0034 1E 00 00 00             		.long	30
 185 0038 04 00 00 00             		.long	4
 186 003c 60 01 00 00             		.long	.LC7
 187 0040 6B 01 00 00             		.long	.LC8
 188 0044 A8 01 00 00             		.long	.LC9
 189 0048 E5 01 00 00             		.long	.LC10
 190 004c 22 02 00 00             		.long	.LC11
 191 0050 5F 02 00 00             		.long	.LC12
 192 0054 9C 02 00 00             		.long	.LC13
 193 0058 00 00 00 00             		.long	_ecc_oid_prime239v1
 194 005c 08 00 00 00             		.long	8
 195 0060 0B 02 00 00             		.long	0x20b
 196 0064 01 00 00 00             		.long	1
 197 0068 20 00 00 00             		.long	32
 198 006c 07 00 00 00             		.long	7
 199 0070 D9 02 00 00             		.long	.LC14
 200 0074 E3 02 00 00             		.long	.LC15
 201 0078 24 03 00 00             		.long	.LC16
 202 007c 65 03 00 00             		.long	.LC17
 203 0080 A6 03 00 00             		.long	.LC18
 204 0084 E7 03 00 00             		.long	.LC19
 205 0088 28 04 00 00             		.long	.LC20
 206 008c 00 00 00 00             		.long	_ecc_oid_secp256r1
 207 0090 08 00 00 00             		.long	8
 208 0094 0E 02 00 00             		.long	0x20e
 209 0098 01 00 00 00             		.long	1
 210 009c 30 00 00 00             		.long	48
 211 00a0 0F 00 00 00             		.long	15
 212 00a4 69 04 00 00             		.long	.LC21
 213 00a8 73 04 00 00             		.long	.LC22
 214 00ac D4 04 00 00             		.long	.LC23
 215 00b0 35 05 00 00             		.long	.LC24
 216 00b4 96 05 00 00             		.long	.LC25
 217 00b8 F7 05 00 00             		.long	.LC26
 218 00bc 58 06 00 00             		.long	.LC27
 219 00c0 00 00 00 00             		.long	_ecc_oid_secp384r1
 220 00c4 05 00 00 00             		.long	5
 221 00c8 D2 00 00 00             		.long	0xd2
 222 00cc 01 00 00 00             		.long	1
 223 00d0 42 00 00 00             		.long	0x42
 224 00d4 10 00 00 00             		.long	16
 225 00d8 B9 06 00 00             		.long	.LC28
 226 00dc C3 06 00 00             		.long	.LC29
 227 00e0 47 07 00 00             		.long	.LC30
 228 00e4 CB 07 00 00             		.long	.LC31
 229 00e8 4E 08 00 00             		.long	.LC32
 230 00ec D2 08 00 00             		.long	.LC33
 231 00f0 55 09 00 00             		.long	.LC34
 232 00f4 00 00 00 00             		.long	_ecc_oid_secp521r1
 233 00f8 05 00 00 00             		.long	5
 234 00fc D3 00 00 00             		.long	0xd3
 235 0100 01 00 00 00             		.long	1
 236 0104 00 00 00 00             		.long	0
 237 0108 FF FF FF FF             		.long	-1
 238 010c 00 00 00 00             		.long	0
 239 0110 00 00 00 00             		.long	0
 240 0114 00 00 00 00             		.long	0
 241 0118 00 00 00 00             		.long	0
 242 011c 00 00 00 00             		.long	0
 243 0120 00 00 00 00             		.long	0
 244 0124 00 00 00 00             		.long	0
 245 0128 00 00 00 00             		.long	0
 246 012c 00 00 00 00             		.long	0
 247 0130 00 00 00 00             		.long	0
 248 0134 00 00 00 00             		.long	0
 249                             		.global	_ecc_sets_count
 250                             		.section	.rodata.ecc_sets_count,"a"
 251                             		.balign 4
 254                             	_ecc_sets_count:
 255 0000 05 00 00 00             		.long	5
 256                             		.section	.text.wc_ecc_curve_cache_free_spec_item,"ax",@progbits
 258                             	_wc_ecc_curve_cache_free_spec_item:
 259                             	.LFB43:
 260                             		.file 2 "../src/wolfcrypt/src/ecc.c"
   1:../src/wolfcrypt/src/ecc.c **** /* ecc.c
   2:../src/wolfcrypt/src/ecc.c ****  *
   3:../src/wolfcrypt/src/ecc.c ****  * Copyright (C) 2006-2021 wolfSSL Inc.
   4:../src/wolfcrypt/src/ecc.c ****  *
   5:../src/wolfcrypt/src/ecc.c ****  * This file is part of wolfSSL.
   6:../src/wolfcrypt/src/ecc.c ****  *
   7:../src/wolfcrypt/src/ecc.c ****  * wolfSSL is free software; you can redistribute it and/or modify
   8:../src/wolfcrypt/src/ecc.c ****  * it under the terms of the GNU General Public License as published by
   9:../src/wolfcrypt/src/ecc.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:../src/wolfcrypt/src/ecc.c ****  * (at your option) any later version.
  11:../src/wolfcrypt/src/ecc.c ****  *
  12:../src/wolfcrypt/src/ecc.c ****  * wolfSSL is distributed in the hope that it will be useful,
  13:../src/wolfcrypt/src/ecc.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../src/wolfcrypt/src/ecc.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../src/wolfcrypt/src/ecc.c ****  * GNU General Public License for more details.
  16:../src/wolfcrypt/src/ecc.c ****  *
  17:../src/wolfcrypt/src/ecc.c ****  * You should have received a copy of the GNU General Public License
  18:../src/wolfcrypt/src/ecc.c ****  * along with this program; if not, write to the Free Software
  19:../src/wolfcrypt/src/ecc.c ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  20:../src/wolfcrypt/src/ecc.c ****  */
  21:../src/wolfcrypt/src/ecc.c **** 
  22:../src/wolfcrypt/src/ecc.c **** 
  23:../src/wolfcrypt/src/ecc.c **** 
  24:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_CONFIG_H
  25:../src/wolfcrypt/src/ecc.c ****     #include <config.h>
  26:../src/wolfcrypt/src/ecc.c **** #endif
  27:../src/wolfcrypt/src/ecc.c **** 
  28:../src/wolfcrypt/src/ecc.c **** /* in case user set HAVE_ECC there */
  29:../src/wolfcrypt/src/ecc.c **** #include <wolfssl/wolfcrypt/settings.h>
  30:../src/wolfcrypt/src/ecc.c **** 
  31:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_ECC_NO_SMALL_STACK
  32:../src/wolfcrypt/src/ecc.c **** #undef WOLFSSL_SMALL_STACK
  33:../src/wolfcrypt/src/ecc.c **** #undef WOLFSSL_SMALL_STACK_CACHE
  34:../src/wolfcrypt/src/ecc.c **** #endif
  35:../src/wolfcrypt/src/ecc.c **** 
  36:../src/wolfcrypt/src/ecc.c **** /*
  37:../src/wolfcrypt/src/ecc.c **** Possible ECC enable options:
  38:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC:            Overall control of ECC                  default: on
  39:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_ENCRYPT:    ECC encrypt/decrypt w/AES and HKDF      default: off
  40:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_SIGN:       ECC sign                                default: on
  41:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_VERIFY:     ECC verify                              default: on
  42:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_DHE:        ECC build shared secret                 default: on
  43:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_CDH:        ECC cofactor DH shared secret           default: off
  44:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_KEY_IMPORT: ECC Key import                          default: on
  45:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_KEY_EXPORT: ECC Key export                          default: on
  46:../src/wolfcrypt/src/ecc.c ****  * ECC_SHAMIR:          Enables Shamir calc method              default: on
  47:../src/wolfcrypt/src/ecc.c ****  * HAVE_COMP_KEY:       Enables compressed key                  default: off
  48:../src/wolfcrypt/src/ecc.c ****  * WOLFSSL_VALIDATE_ECC_IMPORT: Validate ECC key on import      default: off
  49:../src/wolfcrypt/src/ecc.c ****  * WOLFSSL_VALIDATE_ECC_KEYGEN: Validate ECC key gen            default: off
  50:../src/wolfcrypt/src/ecc.c ****  * WOLFSSL_CUSTOM_CURVES: Allow non-standard curves.            default: off
  51:../src/wolfcrypt/src/ecc.c ****  *                        Includes the curve "a" variable in calculation
  52:../src/wolfcrypt/src/ecc.c ****  * ECC_DUMP_OID:        Enables dump of OID encoding and sum    default: off
  53:../src/wolfcrypt/src/ecc.c ****  * ECC_CACHE_CURVE:     Enables cache of curve info to improve performance
  54:../src/wolfcrypt/src/ecc.c ****  *                                                              default: off
  55:../src/wolfcrypt/src/ecc.c ****  * FP_ECC:              ECC Fixed Point Cache                   default: off
  56:../src/wolfcrypt/src/ecc.c ****  *                      FP cache is not supported for SECP160R1, SECP160R2,
  57:../src/wolfcrypt/src/ecc.c ****  *                      SECP160K1 and SECP224K1. These do not work with scalars
  58:../src/wolfcrypt/src/ecc.c ****  *                      that are the length of the order when the order is
  59:../src/wolfcrypt/src/ecc.c ****  *                      longer than the prime.
  60:../src/wolfcrypt/src/ecc.c ****  * USE_ECC_B_PARAM:     Enable ECC curve B param                default: off
  61:../src/wolfcrypt/src/ecc.c ****  *                      (on for HAVE_COMP_KEY)
  62:../src/wolfcrypt/src/ecc.c ****  * WOLFSSL_ECC_CURVE_STATIC:                                    default off (on for windows)
  63:../src/wolfcrypt/src/ecc.c ****  *                      For the ECC curve parameters `ecc_set_type` use fixed
  64:../src/wolfcrypt/src/ecc.c ****  *                      array for hex string
  65:../src/wolfcrypt/src/ecc.c ****  * WC_ECC_NONBLOCK:     Enable non-blocking support for sign/verify.
  66:../src/wolfcrypt/src/ecc.c ****  *                      Requires SP with WOLFSSL_SP_NONBLOCK
  67:../src/wolfcrypt/src/ecc.c ****  * WC_ECC_NONBLOCK_ONLY Enable the non-blocking function only, no fall-back to
  68:../src/wolfcrypt/src/ecc.c ****  *                      normal blocking API's
  69:../src/wolfcrypt/src/ecc.c ****  * WOLFSSL_ECDSA_SET_K: Enables the setting of the 'k' value to use during ECDSA
  70:../src/wolfcrypt/src/ecc.c ****  *                      signing. If the value is invalid, a new random 'k' is
  71:../src/wolfcrypt/src/ecc.c ****  *                      generated in the loop. (For testing)
  72:../src/wolfcrypt/src/ecc.c ****  *                                                              default: off
  73:../src/wolfcrypt/src/ecc.c ****  * WOLFSSL_ECDSA_SET_K_ONE_LOOP:
  74:../src/wolfcrypt/src/ecc.c ****  *                      Enables the setting of the 'k' value to use during ECDSA
  75:../src/wolfcrypt/src/ecc.c ****  *                      signing. If the value is invalid then an error is
  76:../src/wolfcrypt/src/ecc.c ****  *                      returned rather than generating a new 'k'. (For testing)
  77:../src/wolfcrypt/src/ecc.c ****  *                                                              default: off
  78:../src/wolfcrypt/src/ecc.c ****  * WOLFSSL_ECDSA_DETERMINISTIC_K: Enables RFC6979 implementation of
  79:../src/wolfcrypt/src/ecc.c ****  *                      deterministic ECC signatures. The following function
  80:../src/wolfcrypt/src/ecc.c ****  *                      can be used to set the deterministic signing flag in the
  81:../src/wolfcrypt/src/ecc.c ****  *                      ecc key structure.
  82:../src/wolfcrypt/src/ecc.c ****  *                      int wc_ecc_set_deterministic(ecc_key* key, byte flag)
  83:../src/wolfcrypt/src/ecc.c ****  *                                                              default: off
  84:../src/wolfcrypt/src/ecc.c ****  *
  85:../src/wolfcrypt/src/ecc.c ****  * WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT: RFC6979 lists a variant that uses the
  86:../src/wolfcrypt/src/ecc.c ****  *                      hash directly instead of doing bits2octets(H(m)), when
  87:../src/wolfcrypt/src/ecc.c ****  *                      the variant macro is used the bits2octets operation on
  88:../src/wolfcrypt/src/ecc.c ****  *                      the hash is removed.
  89:../src/wolfcrypt/src/ecc.c ****  *                                                              default: off
  90:../src/wolfcrypt/src/ecc.c ****  *
  91:../src/wolfcrypt/src/ecc.c ****  * WC_PROTECT_ENCRYPTED_MEM:
  92:../src/wolfcrypt/src/ecc.c ****  *                      Enables implementations that protect data that is in
  93:../src/wolfcrypt/src/ecc.c ****  *                      encrypted memory.
  94:../src/wolfcrypt/src/ecc.c ****  *                                                              default: off
  95:../src/wolfcrypt/src/ecc.c ****  */
  96:../src/wolfcrypt/src/ecc.c **** 
  97:../src/wolfcrypt/src/ecc.c **** /*
  98:../src/wolfcrypt/src/ecc.c **** ECC Curve Types:
  99:../src/wolfcrypt/src/ecc.c ****  * NO_ECC_SECP          Disables SECP curves                    default: off (not defined)
 100:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_SECPR2      Enables SECP R2 curves                  default: off
 101:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_SECPR3      Enables SECP R3 curves                  default: off
 102:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_BRAINPOOL   Enables Brainpool curves                default: off
 103:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC_KOBLITZ     Enables Koblitz curves                  default: off
 104:../src/wolfcrypt/src/ecc.c ****  */
 105:../src/wolfcrypt/src/ecc.c **** 
 106:../src/wolfcrypt/src/ecc.c **** /*
 107:../src/wolfcrypt/src/ecc.c **** ECC Curve Sizes:
 108:../src/wolfcrypt/src/ecc.c ****  * ECC_USER_CURVES: Allows custom combination of key sizes below
 109:../src/wolfcrypt/src/ecc.c ****  * HAVE_ALL_CURVES: Enable all key sizes (on unless ECC_USER_CURVES is defined)
 110:../src/wolfcrypt/src/ecc.c ****  * ECC_MIN_KEY_SZ: Minimum supported ECC key size
 111:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC112: 112 bit key
 112:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC128: 128 bit key
 113:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC160: 160 bit key
 114:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC192: 192 bit key
 115:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC224: 224 bit key
 116:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC239: 239 bit key
 117:../src/wolfcrypt/src/ecc.c ****  * NO_ECC256: Disables 256 bit key (on by default)
 118:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC320: 320 bit key
 119:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC384: 384 bit key
 120:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC512: 512 bit key
 121:../src/wolfcrypt/src/ecc.c ****  * HAVE_ECC521: 521 bit key
 122:../src/wolfcrypt/src/ecc.c ****  */
 123:../src/wolfcrypt/src/ecc.c **** 
 124:../src/wolfcrypt/src/ecc.c **** 
 125:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC
 126:../src/wolfcrypt/src/ecc.c **** 
 127:../src/wolfcrypt/src/ecc.c **** /* Make sure custom curves is enabled for Brainpool or Koblitz curve types */
 128:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC_BRAINPOOL) || defined(HAVE_ECC_KOBLITZ)) &&\
 129:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CUSTOM_CURVES)
 130:../src/wolfcrypt/src/ecc.c ****     #error Brainpool and Koblitz curves requires WOLFSSL_CUSTOM_CURVES
 131:../src/wolfcrypt/src/ecc.c **** #endif
 132:../src/wolfcrypt/src/ecc.c **** 
 133:../src/wolfcrypt/src/ecc.c **** #if defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)
 134:../src/wolfcrypt/src/ecc.c ****     /* set NO_WRAPPERS before headers, use direct internal f()s not wrappers */
 135:../src/wolfcrypt/src/ecc.c ****     #define FIPS_NO_WRAPPERS
 136:../src/wolfcrypt/src/ecc.c **** 
 137:../src/wolfcrypt/src/ecc.c ****     #ifdef USE_WINDOWS_API
 138:../src/wolfcrypt/src/ecc.c ****         #pragma code_seg(".fipsA$f")
 139:../src/wolfcrypt/src/ecc.c ****         #pragma const_seg(".fipsB$f")
 140:../src/wolfcrypt/src/ecc.c ****     #endif
 141:../src/wolfcrypt/src/ecc.c **** #endif
 142:../src/wolfcrypt/src/ecc.c **** 
 143:../src/wolfcrypt/src/ecc.c **** /* public ASN interface */
 144:../src/wolfcrypt/src/ecc.c **** #include <wolfssl/wolfcrypt/asn_public.h>
 145:../src/wolfcrypt/src/ecc.c **** 
 146:../src/wolfcrypt/src/ecc.c **** #include <wolfssl/wolfcrypt/ecc.h>
 147:../src/wolfcrypt/src/ecc.c **** #include <wolfssl/wolfcrypt/asn.h>
 148:../src/wolfcrypt/src/ecc.c **** #include <wolfssl/wolfcrypt/error-crypt.h>
 149:../src/wolfcrypt/src/ecc.c **** #include <wolfssl/wolfcrypt/logging.h>
 150:../src/wolfcrypt/src/ecc.c **** #include <wolfssl/wolfcrypt/types.h>
 151:../src/wolfcrypt/src/ecc.c **** 
 152:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
 153:../src/wolfcrypt/src/ecc.c **** #include <wolfssl/wolfcrypt/sp.h>
 154:../src/wolfcrypt/src/ecc.c **** #endif
 155:../src/wolfcrypt/src/ecc.c **** 
 156:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_ENCRYPT
 157:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/kdf.h>
 158:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/aes.h>
 159:../src/wolfcrypt/src/ecc.c **** #endif
 160:../src/wolfcrypt/src/ecc.c **** 
 161:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_X963_KDF
 162:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/hash.h>
 163:../src/wolfcrypt/src/ecc.c **** #endif
 164:../src/wolfcrypt/src/ecc.c **** 
 165:../src/wolfcrypt/src/ecc.c **** #ifdef WOLF_CRYPTO_CB
 166:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/cryptocb.h>
 167:../src/wolfcrypt/src/ecc.c **** #endif
 168:../src/wolfcrypt/src/ecc.c **** 
 169:../src/wolfcrypt/src/ecc.c **** #ifdef NO_INLINE
 170:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/misc.h>
 171:../src/wolfcrypt/src/ecc.c **** #else
 172:../src/wolfcrypt/src/ecc.c ****     #define WOLFSSL_MISC_INCLUDED
 173:../src/wolfcrypt/src/ecc.c ****     #include <wolfcrypt/src/misc.c>
 174:../src/wolfcrypt/src/ecc.c **** #endif
 175:../src/wolfcrypt/src/ecc.c **** 
 176:../src/wolfcrypt/src/ecc.c **** #if defined(FREESCALE_LTC_ECC)
 177:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/port/nxp/ksdk_port.h>
 178:../src/wolfcrypt/src/ecc.c **** #endif
 179:../src/wolfcrypt/src/ecc.c **** 
 180:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_STM32_PKA)
 181:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/port/st/stm32.h>
 182:../src/wolfcrypt/src/ecc.c **** #endif
 183:../src/wolfcrypt/src/ecc.c **** 
 184:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_PSOC6_CRYPTO)
 185:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/port/cypress/psoc6_crypto.h>
 186:../src/wolfcrypt/src/ecc.c **** #endif
 187:../src/wolfcrypt/src/ecc.c **** 
 188:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_CAAM)
 189:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/port/caam/wolfcaam.h>
 190:../src/wolfcrypt/src/ecc.c **** #endif
 191:../src/wolfcrypt/src/ecc.c **** 
 192:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_KCAPI_ECC)
 193:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/port/kcapi/kcapi_ecc.h>
 194:../src/wolfcrypt/src/ecc.c **** #endif
 195:../src/wolfcrypt/src/ecc.c **** 
 196:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SE050
 197:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/port/nxp/se050_port.h>
 198:../src/wolfcrypt/src/ecc.c **** #endif
 199:../src/wolfcrypt/src/ecc.c **** 
 200:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECDSA_DETERMINISTIC_K) || \
 201:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT)
 202:../src/wolfcrypt/src/ecc.c ****     #include <wolfssl/wolfcrypt/hmac.h>
 203:../src/wolfcrypt/src/ecc.c **** #endif
 204:../src/wolfcrypt/src/ecc.c **** 
 205:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_SP_MATH_ALL)
 206:../src/wolfcrypt/src/ecc.c ****     #define GEN_MEM_ERR MP_MEM
 207:../src/wolfcrypt/src/ecc.c **** #elif defined(USE_FAST_MATH)
 208:../src/wolfcrypt/src/ecc.c ****     #define GEN_MEM_ERR FP_MEM
 209:../src/wolfcrypt/src/ecc.c **** #else
 210:../src/wolfcrypt/src/ecc.c ****     #define GEN_MEM_ERR MP_MEM
 211:../src/wolfcrypt/src/ecc.c **** #endif
 212:../src/wolfcrypt/src/ecc.c **** 
 213:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
 214:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_SILABS_SE_ACCEL) && !defined(WOLFSSL_KCAPI_ECC) && \
 215:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL) && !defined(NO_ECC_MAKE_PUB) && \
 216:../src/wolfcrypt/src/ecc.c ****     !defined(WOLF_CRYPTO_CB_ONLY_ECC)
 217:../src/wolfcrypt/src/ecc.c ****     #undef  HAVE_ECC_MAKE_PUB
 218:../src/wolfcrypt/src/ecc.c ****     #define HAVE_ECC_MAKE_PUB
 219:../src/wolfcrypt/src/ecc.c **** #endif
 220:../src/wolfcrypt/src/ecc.c **** 
 221:../src/wolfcrypt/src/ecc.c **** /* forward declarations */
 222:../src/wolfcrypt/src/ecc.c **** static int  wc_ecc_new_point_ex(ecc_point** point, void* heap);
 223:../src/wolfcrypt/src/ecc.c **** static void wc_ecc_del_point_ex(ecc_point* p, void* heap);
 224:../src/wolfcrypt/src/ecc.c **** 
 225:../src/wolfcrypt/src/ecc.c **** /* internal ECC states */
 226:../src/wolfcrypt/src/ecc.c **** enum {
 227:../src/wolfcrypt/src/ecc.c ****     ECC_STATE_NONE = 0,
 228:../src/wolfcrypt/src/ecc.c **** 
 229:../src/wolfcrypt/src/ecc.c ****     ECC_STATE_SHARED_SEC_GEN,
 230:../src/wolfcrypt/src/ecc.c ****     ECC_STATE_SHARED_SEC_RES,
 231:../src/wolfcrypt/src/ecc.c **** 
 232:../src/wolfcrypt/src/ecc.c ****     ECC_STATE_SIGN_DO,
 233:../src/wolfcrypt/src/ecc.c ****     ECC_STATE_SIGN_ENCODE,
 234:../src/wolfcrypt/src/ecc.c **** 
 235:../src/wolfcrypt/src/ecc.c ****     ECC_STATE_VERIFY_DECODE,
 236:../src/wolfcrypt/src/ecc.c ****     ECC_STATE_VERIFY_DO,
 237:../src/wolfcrypt/src/ecc.c ****     ECC_STATE_VERIFY_RES,
 238:../src/wolfcrypt/src/ecc.c **** };
 239:../src/wolfcrypt/src/ecc.c **** 
 240:../src/wolfcrypt/src/ecc.c **** 
 241:../src/wolfcrypt/src/ecc.c **** /* map
 242:../src/wolfcrypt/src/ecc.c ****    ptmul -> mulmod
 243:../src/wolfcrypt/src/ecc.c **** */
 244:../src/wolfcrypt/src/ecc.c **** 
 245:../src/wolfcrypt/src/ecc.c **** /* 256-bit curve on by default whether user curves or not */
 246:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC112) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 112
 247:../src/wolfcrypt/src/ecc.c ****     #define ECC112
 248:../src/wolfcrypt/src/ecc.c **** #endif
 249:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC128) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 128
 250:../src/wolfcrypt/src/ecc.c ****     #define ECC128
 251:../src/wolfcrypt/src/ecc.c **** #endif
 252:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 160
 253:../src/wolfcrypt/src/ecc.c ****     #define ECC160
 254:../src/wolfcrypt/src/ecc.c **** #endif
 255:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 192
 256:../src/wolfcrypt/src/ecc.c ****     #define ECC192
 257:../src/wolfcrypt/src/ecc.c **** #endif
 258:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 224
 259:../src/wolfcrypt/src/ecc.c ****     #define ECC224
 260:../src/wolfcrypt/src/ecc.c **** #endif
 261:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC239) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 239
 262:../src/wolfcrypt/src/ecc.c ****     #define ECC239
 263:../src/wolfcrypt/src/ecc.c **** #endif
 264:../src/wolfcrypt/src/ecc.c **** #if (!defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
 265:../src/wolfcrypt/src/ecc.c ****     #define ECC256
 266:../src/wolfcrypt/src/ecc.c **** #endif
 267:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC320) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 320
 268:../src/wolfcrypt/src/ecc.c ****     #define ECC320
 269:../src/wolfcrypt/src/ecc.c **** #endif
 270:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 384
 271:../src/wolfcrypt/src/ecc.c ****     #define ECC384
 272:../src/wolfcrypt/src/ecc.c **** #endif
 273:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 512
 274:../src/wolfcrypt/src/ecc.c ****     #define ECC512
 275:../src/wolfcrypt/src/ecc.c **** #endif
 276:../src/wolfcrypt/src/ecc.c **** #if (defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 521
 277:../src/wolfcrypt/src/ecc.c ****     #define ECC521
 278:../src/wolfcrypt/src/ecc.c **** #endif
 279:../src/wolfcrypt/src/ecc.c **** 
 280:../src/wolfcrypt/src/ecc.c **** /* The encoded OID's for ECC curves */
 281:../src/wolfcrypt/src/ecc.c **** #ifdef ECC112
 282:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 283:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 284:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP112R1    {1,3,132,0,6}
 285:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP112R1_SZ 5
 286:../src/wolfcrypt/src/ecc.c ****         #else
 287:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP112R1    {0x2B,0x81,0x04,0x00,0x06}
 288:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP112R1_SZ 5
 289:../src/wolfcrypt/src/ecc.c ****         #endif
 290:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 291:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp112r1[] = CODED_SECP112R1;
 292:../src/wolfcrypt/src/ecc.c ****         #else
 293:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp112r1 CODED_SECP112R1
 294:../src/wolfcrypt/src/ecc.c ****         #endif
 295:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp112r1_sz CODED_SECP112R1_SZ
 296:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 297:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
 298:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 299:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP112R2    {1,3,132,0,7}
 300:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP112R2_SZ 5
 301:../src/wolfcrypt/src/ecc.c ****         #else
 302:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP112R2    {0x2B,0x81,0x04,0x00,0x07}
 303:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP112R2_SZ 5
 304:../src/wolfcrypt/src/ecc.c ****         #endif
 305:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 306:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp112r2[] = CODED_SECP112R2;
 307:../src/wolfcrypt/src/ecc.c ****         #else
 308:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp112r2 CODED_SECP112R2
 309:../src/wolfcrypt/src/ecc.c ****         #endif
 310:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp112r2_sz CODED_SECP112R2_SZ
 311:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
 312:../src/wolfcrypt/src/ecc.c **** #endif /* ECC112 */
 313:../src/wolfcrypt/src/ecc.c **** #ifdef ECC128
 314:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 315:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 316:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP128R1    {1,3,132,0,28}
 317:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP128R1_SZ 5
 318:../src/wolfcrypt/src/ecc.c ****         #else
 319:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP128R1    {0x2B,0x81,0x04,0x00,0x1C}
 320:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP128R1_SZ 5
 321:../src/wolfcrypt/src/ecc.c ****         #endif
 322:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 323:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp128r1[] = CODED_SECP128R1;
 324:../src/wolfcrypt/src/ecc.c ****         #else
 325:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp128r1 CODED_SECP128R1
 326:../src/wolfcrypt/src/ecc.c ****         #endif
 327:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp128r1_sz CODED_SECP128R1_SZ
 328:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 329:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
 330:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 331:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP128R2    {1,3,132,0,29}
 332:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP128R2_SZ 5
 333:../src/wolfcrypt/src/ecc.c ****         #else
 334:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP128R2    {0x2B,0x81,0x04,0x00,0x1D}
 335:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP128R2_SZ 5
 336:../src/wolfcrypt/src/ecc.c ****         #endif
 337:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 338:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp128r2[] = CODED_SECP128R2;
 339:../src/wolfcrypt/src/ecc.c ****         #else
 340:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp128r2 CODED_SECP128R2
 341:../src/wolfcrypt/src/ecc.c ****         #endif
 342:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp128r2_sz CODED_SECP128R2_SZ
 343:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
 344:../src/wolfcrypt/src/ecc.c **** #endif /* ECC128 */
 345:../src/wolfcrypt/src/ecc.c **** #ifdef ECC160
 346:../src/wolfcrypt/src/ecc.c **** #ifndef FP_ECC
 347:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 348:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 349:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160R1    {1,3,132,0,8}
 350:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160R1_SZ 5
 351:../src/wolfcrypt/src/ecc.c ****         #else
 352:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160R1    {0x2B,0x81,0x04,0x00,0x08}
 353:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160R1_SZ 5
 354:../src/wolfcrypt/src/ecc.c ****         #endif
 355:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 356:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp160r1[] = CODED_SECP160R1;
 357:../src/wolfcrypt/src/ecc.c ****         #else
 358:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp160r1 CODED_SECP160R1
 359:../src/wolfcrypt/src/ecc.c ****         #endif
 360:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp160r1_sz CODED_SECP160R1_SZ
 361:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 362:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
 363:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 364:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160R2    {1,3,132,0,30}
 365:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160R2_SZ 5
 366:../src/wolfcrypt/src/ecc.c ****         #else
 367:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160R2    {0x2B,0x81,0x04,0x00,0x1E}
 368:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160R2_SZ 5
 369:../src/wolfcrypt/src/ecc.c ****         #endif
 370:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 371:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp160r2[] = CODED_SECP160R2;
 372:../src/wolfcrypt/src/ecc.c ****         #else
 373:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp160r2 CODED_SECP160R2
 374:../src/wolfcrypt/src/ecc.c ****         #endif
 375:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp160r2_sz CODED_SECP160R2_SZ
 376:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
 377:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_KOBLITZ
 378:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 379:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160K1    {1,3,132,0,9}
 380:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160K1_SZ 5
 381:../src/wolfcrypt/src/ecc.c ****         #else
 382:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160K1    {0x2B,0x81,0x04,0x00,0x09}
 383:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP160K1_SZ 5
 384:../src/wolfcrypt/src/ecc.c ****         #endif
 385:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 386:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp160k1[] = CODED_SECP160K1;
 387:../src/wolfcrypt/src/ecc.c ****         #else
 388:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp160k1 CODED_SECP160K1
 389:../src/wolfcrypt/src/ecc.c ****         #endif
 390:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp160k1_sz CODED_SECP160K1_SZ
 391:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_KOBLITZ */
 392:../src/wolfcrypt/src/ecc.c **** #endif /* !FP_ECC */
 393:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 394:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 395:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP160R1    {1,3,36,3,3,2,8,1,1,1}
 396:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP160R1_SZ 10
 397:../src/wolfcrypt/src/ecc.c ****         #else
 398:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP160R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x01}
 399:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP160R1_SZ 9
 400:../src/wolfcrypt/src/ecc.c ****         #endif
 401:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 402:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_brainpoolp160r1[] = CODED_BRAINPOOLP160R1;
 403:../src/wolfcrypt/src/ecc.c ****         #else
 404:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_brainpoolp160r1 CODED_BRAINPOOLP160R1
 405:../src/wolfcrypt/src/ecc.c ****         #endif
 406:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_brainpoolp160r1_sz CODED_BRAINPOOLP160R1_SZ
 407:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
 408:../src/wolfcrypt/src/ecc.c **** #endif /* ECC160 */
 409:../src/wolfcrypt/src/ecc.c **** #ifdef ECC192
 410:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 411:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 412:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP192R1    {1,2,840,10045,3,1,1}
 413:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP192R1_SZ 7
 414:../src/wolfcrypt/src/ecc.c ****         #else
 415:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP192R1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x01}
 416:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP192R1_SZ 8
 417:../src/wolfcrypt/src/ecc.c ****         #endif
 418:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 419:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp192r1[] = CODED_SECP192R1;
 420:../src/wolfcrypt/src/ecc.c ****         #else
 421:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp192r1 CODED_SECP192R1
 422:../src/wolfcrypt/src/ecc.c ****         #endif
 423:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp192r1_sz CODED_SECP192R1_SZ
 424:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 425:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
 426:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 427:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME192V2    {1,2,840,10045,3,1,2}
 428:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME192V2_SZ 7
 429:../src/wolfcrypt/src/ecc.c ****         #else
 430:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME192V2    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x02}
 431:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME192V2_SZ 8
 432:../src/wolfcrypt/src/ecc.c ****         #endif
 433:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 434:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_prime192v2[] = CODED_PRIME192V2;
 435:../src/wolfcrypt/src/ecc.c ****         #else
 436:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_prime192v2 CODED_PRIME192V2
 437:../src/wolfcrypt/src/ecc.c ****         #endif
 438:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_prime192v2_sz CODED_PRIME192V2_SZ
 439:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
 440:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR3
 441:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 442:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME192V3    {1,2,840,10045,3,1,3}
 443:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME192V3_SZ 7
 444:../src/wolfcrypt/src/ecc.c ****         #else
 445:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME192V3    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x03}
 446:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME192V3_SZ 8
 447:../src/wolfcrypt/src/ecc.c ****         #endif
 448:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 449:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_prime192v3[] = CODED_PRIME192V3;
 450:../src/wolfcrypt/src/ecc.c ****         #else
 451:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_prime192v3 CODED_PRIME192V3
 452:../src/wolfcrypt/src/ecc.c ****         #endif
 453:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_prime192v3_sz CODED_PRIME192V3_SZ
 454:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR3 */
 455:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_KOBLITZ
 456:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 457:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP192K1    {1,3,132,0,31}
 458:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP192K1_SZ 5
 459:../src/wolfcrypt/src/ecc.c ****         #else
 460:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP192K1    {0x2B,0x81,0x04,0x00,0x1F}
 461:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP192K1_SZ 5
 462:../src/wolfcrypt/src/ecc.c ****         #endif
 463:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 464:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp192k1[] = CODED_SECP192K1;
 465:../src/wolfcrypt/src/ecc.c ****         #else
 466:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp192k1 CODED_SECP192K1
 467:../src/wolfcrypt/src/ecc.c ****         #endif
 468:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp192k1_sz CODED_SECP192K1_SZ
 469:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_KOBLITZ */
 470:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 471:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 472:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP192R1    {1,3,36,3,3,2,8,1,1,3}
 473:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP192R1_SZ 10
 474:../src/wolfcrypt/src/ecc.c ****         #else
 475:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP192R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x03}
 476:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP192R1_SZ 9
 477:../src/wolfcrypt/src/ecc.c ****         #endif
 478:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 479:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_brainpoolp192r1[] = CODED_BRAINPOOLP192R1;
 480:../src/wolfcrypt/src/ecc.c ****         #else
 481:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_brainpoolp192r1 CODED_BRAINPOOLP192R1
 482:../src/wolfcrypt/src/ecc.c ****         #endif
 483:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_brainpoolp192r1_sz CODED_BRAINPOOLP192R1_SZ
 484:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
 485:../src/wolfcrypt/src/ecc.c **** #endif /* ECC192 */
 486:../src/wolfcrypt/src/ecc.c **** #ifdef ECC224
 487:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 488:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 489:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP224R1    {1,3,132,0,33}
 490:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP224R1_SZ 5
 491:../src/wolfcrypt/src/ecc.c ****         #else
 492:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP224R1    {0x2B,0x81,0x04,0x00,0x21}
 493:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP224R1_SZ 5
 494:../src/wolfcrypt/src/ecc.c ****         #endif
 495:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 496:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp224r1[] = CODED_SECP224R1;
 497:../src/wolfcrypt/src/ecc.c ****         #else
 498:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp224r1 CODED_SECP224R1
 499:../src/wolfcrypt/src/ecc.c ****         #endif
 500:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp224r1_sz CODED_SECP224R1_SZ
 501:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 502:../src/wolfcrypt/src/ecc.c ****     #if defined(HAVE_ECC_KOBLITZ) && !defined(FP_ECC)
 503:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 504:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP224K1    {1,3,132,0,32}
 505:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP224K1_SZ 5
 506:../src/wolfcrypt/src/ecc.c ****         #else
 507:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP224K1    {0x2B,0x81,0x04,0x00,0x20}
 508:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP224K1_SZ 5
 509:../src/wolfcrypt/src/ecc.c ****         #endif
 510:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 511:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp224k1[] = CODED_SECP224K1;
 512:../src/wolfcrypt/src/ecc.c ****         #else
 513:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp224k1 CODED_SECP224K1
 514:../src/wolfcrypt/src/ecc.c ****         #endif
 515:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp224k1_sz CODED_SECP224K1_SZ
 516:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_KOBLITZ && !FP_ECC */
 517:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 518:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 519:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP224R1    {1,3,36,3,3,2,8,1,1,5}
 520:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP224R1_SZ 10
 521:../src/wolfcrypt/src/ecc.c ****         #else
 522:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP224R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x05}
 523:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP224R1_SZ 9
 524:../src/wolfcrypt/src/ecc.c ****         #endif
 525:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 526:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_brainpoolp224r1[] = CODED_BRAINPOOLP224R1;
 527:../src/wolfcrypt/src/ecc.c ****         #else
 528:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_brainpoolp224r1 CODED_BRAINPOOLP224R1
 529:../src/wolfcrypt/src/ecc.c ****         #endif
 530:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_brainpoolp224r1_sz CODED_BRAINPOOLP224R1_SZ
 531:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
 532:../src/wolfcrypt/src/ecc.c **** #endif /* ECC224 */
 533:../src/wolfcrypt/src/ecc.c **** #ifdef ECC239
 534:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 535:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 536:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V1    {1,2,840,10045,3,1,4}
 537:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V1_SZ 7
 538:../src/wolfcrypt/src/ecc.c ****         #else
 539:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x04}
 540:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V1_SZ 8
 541:../src/wolfcrypt/src/ecc.c ****         #endif
 542:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 543:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_prime239v1[] = CODED_PRIME239V1;
 544:../src/wolfcrypt/src/ecc.c ****         #else
 545:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_prime239v1 CODED_PRIME239V1
 546:../src/wolfcrypt/src/ecc.c ****         #endif
 547:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_prime239v1_sz CODED_PRIME239V1_SZ
 548:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 549:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
 550:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 551:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V2    {1,2,840,10045,3,1,5}
 552:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V2_SZ 7
 553:../src/wolfcrypt/src/ecc.c ****         #else
 554:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V2    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x05}
 555:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V2_SZ 8
 556:../src/wolfcrypt/src/ecc.c ****         #endif
 557:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 558:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_prime239v2[] = CODED_PRIME239V2;
 559:../src/wolfcrypt/src/ecc.c ****         #else
 560:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_prime239v2 CODED_PRIME239V2
 561:../src/wolfcrypt/src/ecc.c ****         #endif
 562:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_prime239v2_sz CODED_PRIME239V2_SZ
 563:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
 564:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR3
 565:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 566:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V3    {1,2,840,10045,3,1,6}
 567:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V3_SZ 7
 568:../src/wolfcrypt/src/ecc.c ****         #else
 569:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V3    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x06}
 570:../src/wolfcrypt/src/ecc.c ****             #define CODED_PRIME239V3_SZ 8
 571:../src/wolfcrypt/src/ecc.c ****         #endif
 572:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 573:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_prime239v3[] = CODED_PRIME239V3;
 574:../src/wolfcrypt/src/ecc.c ****         #else
 575:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_prime239v3 CODED_PRIME239V3
 576:../src/wolfcrypt/src/ecc.c ****         #endif
 577:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_prime239v3_sz CODED_PRIME239V3_SZ
 578:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR3 */
 579:../src/wolfcrypt/src/ecc.c **** #endif /* ECC239 */
 580:../src/wolfcrypt/src/ecc.c **** #ifdef ECC256
 581:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 582:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 583:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP256R1    {1,2,840,10045,3,1,7}
 584:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP256R1_SZ 7
 585:../src/wolfcrypt/src/ecc.c ****         #else
 586:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP256R1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07}
 587:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP256R1_SZ 8
 588:../src/wolfcrypt/src/ecc.c ****         #endif
 589:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 590:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp256r1[] = CODED_SECP256R1;
 591:../src/wolfcrypt/src/ecc.c ****         #else
 592:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp256r1 CODED_SECP256R1
 593:../src/wolfcrypt/src/ecc.c ****         #endif
 594:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp256r1_sz CODED_SECP256R1_SZ
 595:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 596:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_KOBLITZ
 597:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 598:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP256K1    {1,3,132,0,10}
 599:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP256K1_SZ 5
 600:../src/wolfcrypt/src/ecc.c ****         #else
 601:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP256K1    {0x2B,0x81,0x04,0x00,0x0A}
 602:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP256K1_SZ 5
 603:../src/wolfcrypt/src/ecc.c ****         #endif
 604:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 605:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp256k1[] = CODED_SECP256K1;
 606:../src/wolfcrypt/src/ecc.c ****         #else
 607:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp256k1 CODED_SECP256K1
 608:../src/wolfcrypt/src/ecc.c ****         #endif
 609:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp256k1_sz CODED_SECP256K1_SZ
 610:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_KOBLITZ */
 611:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 612:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 613:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP256R1    {1,3,36,3,3,2,8,1,1,7}
 614:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP256R1_SZ 10
 615:../src/wolfcrypt/src/ecc.c ****         #else
 616:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP256R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x07}
 617:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP256R1_SZ 9
 618:../src/wolfcrypt/src/ecc.c ****         #endif
 619:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 620:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_brainpoolp256r1[] = CODED_BRAINPOOLP256R1;
 621:../src/wolfcrypt/src/ecc.c ****         #else
 622:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_brainpoolp256r1 CODED_BRAINPOOLP256R1
 623:../src/wolfcrypt/src/ecc.c ****         #endif
 624:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_brainpoolp256r1_sz CODED_BRAINPOOLP256R1_SZ
 625:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
 626:../src/wolfcrypt/src/ecc.c **** #endif /* ECC256 */
 627:../src/wolfcrypt/src/ecc.c **** #ifdef ECC320
 628:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 629:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 630:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP320R1    {1,3,36,3,3,2,8,1,1,9}
 631:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP320R1_SZ 10
 632:../src/wolfcrypt/src/ecc.c ****         #else
 633:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP320R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x09}
 634:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP320R1_SZ 9
 635:../src/wolfcrypt/src/ecc.c ****         #endif
 636:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 637:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_brainpoolp320r1[] = CODED_BRAINPOOLP320R1;
 638:../src/wolfcrypt/src/ecc.c ****         #else
 639:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_brainpoolp320r1 CODED_BRAINPOOLP320R1
 640:../src/wolfcrypt/src/ecc.c ****         #endif
 641:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_brainpoolp320r1_sz CODED_BRAINPOOLP320R1_SZ
 642:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
 643:../src/wolfcrypt/src/ecc.c **** #endif /* ECC320 */
 644:../src/wolfcrypt/src/ecc.c **** #ifdef ECC384
 645:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 646:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 647:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP384R1    {1,3,132,0,34}
 648:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP384R1_SZ 5
 649:../src/wolfcrypt/src/ecc.c ****         #else
 650:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP384R1    {0x2B,0x81,0x04,0x00,0x22}
 651:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP384R1_SZ 5
 652:../src/wolfcrypt/src/ecc.c ****         #endif
 653:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 654:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp384r1[] = CODED_SECP384R1;
 655:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP384R1_OID ecc_oid_secp384r1
 656:../src/wolfcrypt/src/ecc.c ****         #else
 657:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp384r1 CODED_SECP384R1
 658:../src/wolfcrypt/src/ecc.c ****         #endif
 659:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp384r1_sz CODED_SECP384R1_SZ
 660:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 661:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 662:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 663:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP384R1    {1,3,36,3,3,2,8,1,1,11}
 664:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP384R1_SZ 10
 665:../src/wolfcrypt/src/ecc.c ****         #else
 666:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP384R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0B}
 667:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP384R1_SZ 9
 668:../src/wolfcrypt/src/ecc.c ****         #endif
 669:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 670:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_brainpoolp384r1[] = CODED_BRAINPOOLP384R1;
 671:../src/wolfcrypt/src/ecc.c ****         #else
 672:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_brainpoolp384r1 CODED_BRAINPOOLP384R1
 673:../src/wolfcrypt/src/ecc.c ****         #endif
 674:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_brainpoolp384r1_sz CODED_BRAINPOOLP384R1_SZ
 675:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
 676:../src/wolfcrypt/src/ecc.c **** #endif /* ECC384 */
 677:../src/wolfcrypt/src/ecc.c **** #ifdef ECC512
 678:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 679:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 680:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP512R1    {1,3,36,3,3,2,8,1,1,13}
 681:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP512R1_SZ 10
 682:../src/wolfcrypt/src/ecc.c ****         #else
 683:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP512R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0D}
 684:../src/wolfcrypt/src/ecc.c ****             #define CODED_BRAINPOOLP512R1_SZ 9
 685:../src/wolfcrypt/src/ecc.c ****         #endif
 686:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 687:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_brainpoolp512r1[] = CODED_BRAINPOOLP512R1;
 688:../src/wolfcrypt/src/ecc.c ****         #else
 689:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_brainpoolp512r1 CODED_BRAINPOOLP512R1
 690:../src/wolfcrypt/src/ecc.c ****         #endif
 691:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_brainpoolp512r1_sz CODED_BRAINPOOLP512R1_SZ
 692:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
 693:../src/wolfcrypt/src/ecc.c **** #endif /* ECC512 */
 694:../src/wolfcrypt/src/ecc.c **** #ifdef ECC521
 695:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 696:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
 697:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP521R1     {1,3,132,0,35}
 698:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP521R1_SZ 5
 699:../src/wolfcrypt/src/ecc.c ****         #else
 700:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP521R1     {0x2B,0x81,0x04,0x00,0x23}
 701:../src/wolfcrypt/src/ecc.c ****             #define CODED_SECP521R1_SZ 5
 702:../src/wolfcrypt/src/ecc.c ****         #endif
 703:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 704:../src/wolfcrypt/src/ecc.c ****             static const ecc_oid_t ecc_oid_secp521r1[] = CODED_SECP521R1;
 705:../src/wolfcrypt/src/ecc.c ****         #else
 706:../src/wolfcrypt/src/ecc.c ****             #define ecc_oid_secp521r1 CODED_SECP521R1
 707:../src/wolfcrypt/src/ecc.c ****         #endif
 708:../src/wolfcrypt/src/ecc.c ****         #define ecc_oid_secp521r1_sz CODED_SECP521R1_SZ
 709:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 710:../src/wolfcrypt/src/ecc.c **** #endif /* ECC521 */
 711:../src/wolfcrypt/src/ecc.c **** 
 712:../src/wolfcrypt/src/ecc.c **** 
 713:../src/wolfcrypt/src/ecc.c **** /* This holds the key settings.
 714:../src/wolfcrypt/src/ecc.c ****    ***MUST*** be organized by size from smallest to largest. */
 715:../src/wolfcrypt/src/ecc.c **** 
 716:../src/wolfcrypt/src/ecc.c **** const ecc_set_type ecc_sets[] = {
 717:../src/wolfcrypt/src/ecc.c **** #ifdef ECC112
 718:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 719:../src/wolfcrypt/src/ecc.c ****     {
 720:../src/wolfcrypt/src/ecc.c ****         14,                             /* size/bytes */
 721:../src/wolfcrypt/src/ecc.c ****         ECC_SECP112R1,                  /* ID         */
 722:../src/wolfcrypt/src/ecc.c ****         "SECP112R1",                    /* curve name */
 723:../src/wolfcrypt/src/ecc.c ****         "DB7C2ABF62E35E668076BEAD208B", /* prime      */
 724:../src/wolfcrypt/src/ecc.c ****         "DB7C2ABF62E35E668076BEAD2088", /* A          */
 725:../src/wolfcrypt/src/ecc.c ****         "659EF8BA043916EEDE8911702B22", /* B          */
 726:../src/wolfcrypt/src/ecc.c ****         "DB7C2ABF62E35E7628DFAC6561C5", /* order      */
 727:../src/wolfcrypt/src/ecc.c ****         "9487239995A5EE76B55F9C2F098",  /* Gx         */
 728:../src/wolfcrypt/src/ecc.c ****         "A89CE5AF8724C0A23E0E0FF77500", /* Gy         */
 729:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp112r1,              /* oid/oidSz  */
 730:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp112r1_sz,
 731:../src/wolfcrypt/src/ecc.c ****         ECC_SECP112R1_OID,              /* oid sum    */
 732:../src/wolfcrypt/src/ecc.c ****         1,                              /* cofactor   */
 733:../src/wolfcrypt/src/ecc.c ****     },
 734:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 735:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
 736:../src/wolfcrypt/src/ecc.c ****     {
 737:../src/wolfcrypt/src/ecc.c ****         14,                             /* size/bytes */
 738:../src/wolfcrypt/src/ecc.c ****         ECC_SECP112R2,                  /* ID         */
 739:../src/wolfcrypt/src/ecc.c ****         "SECP112R2",                    /* curve name */
 740:../src/wolfcrypt/src/ecc.c ****         "DB7C2ABF62E35E668076BEAD208B", /* prime      */
 741:../src/wolfcrypt/src/ecc.c ****         "6127C24C05F38A0AAAF65C0EF02C", /* A          */
 742:../src/wolfcrypt/src/ecc.c ****         "51DEF1815DB5ED74FCC34C85D709", /* B          */
 743:../src/wolfcrypt/src/ecc.c ****         "36DF0AAFD8B8D7597CA10520D04B", /* order      */
 744:../src/wolfcrypt/src/ecc.c ****         "4BA30AB5E892B4E1649DD0928643", /* Gx         */
 745:../src/wolfcrypt/src/ecc.c ****         "ADCD46F5882E3747DEF36E956E97", /* Gy         */
 746:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp112r2,              /* oid/oidSz  */
 747:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp112r2_sz,
 748:../src/wolfcrypt/src/ecc.c ****         ECC_SECP112R2_OID,              /* oid sum    */
 749:../src/wolfcrypt/src/ecc.c ****         4,                              /* cofactor   */
 750:../src/wolfcrypt/src/ecc.c ****     },
 751:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
 752:../src/wolfcrypt/src/ecc.c **** #endif /* ECC112 */
 753:../src/wolfcrypt/src/ecc.c **** #ifdef ECC128
 754:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 755:../src/wolfcrypt/src/ecc.c ****     {
 756:../src/wolfcrypt/src/ecc.c ****         16,                                 /* size/bytes */
 757:../src/wolfcrypt/src/ecc.c ****         ECC_SECP128R1,                      /* ID         */
 758:../src/wolfcrypt/src/ecc.c ****         "SECP128R1",                        /* curve name */
 759:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF", /* prime      */
 760:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC", /* A          */
 761:../src/wolfcrypt/src/ecc.c ****         "E87579C11079F43DD824993C2CEE5ED3", /* B          */
 762:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFE0000000075A30D1B9038A115", /* order      */
 763:../src/wolfcrypt/src/ecc.c ****         "161FF7528B899B2D0C28607CA52C5B86", /* Gx         */
 764:../src/wolfcrypt/src/ecc.c ****         "CF5AC8395BAFEB13C02DA292DDED7A83", /* Gy         */
 765:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp128r1,                  /* oid/oidSz  */
 766:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp128r1_sz,
 767:../src/wolfcrypt/src/ecc.c ****         ECC_SECP128R1_OID,                  /* oid sum    */
 768:../src/wolfcrypt/src/ecc.c ****         1,                                  /* cofactor   */
 769:../src/wolfcrypt/src/ecc.c ****     },
 770:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 771:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
 772:../src/wolfcrypt/src/ecc.c ****     {
 773:../src/wolfcrypt/src/ecc.c ****         16,                                 /* size/bytes */
 774:../src/wolfcrypt/src/ecc.c ****         ECC_SECP128R2,                      /* ID         */
 775:../src/wolfcrypt/src/ecc.c ****         "SECP128R2",                        /* curve name */
 776:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF", /* prime      */
 777:../src/wolfcrypt/src/ecc.c ****         "D6031998D1B3BBFEBF59CC9BBFF9AEE1", /* A          */
 778:../src/wolfcrypt/src/ecc.c ****         "5EEEFCA380D02919DC2C6558BB6D8A5D", /* B          */
 779:../src/wolfcrypt/src/ecc.c ****         "3FFFFFFF7FFFFFFFBE0024720613B5A3", /* order      */
 780:../src/wolfcrypt/src/ecc.c ****         "7B6AA5D85E572983E6FB32A7CDEBC140", /* Gx         */
 781:../src/wolfcrypt/src/ecc.c ****         "27B6916A894D3AEE7106FE805FC34B44", /* Gy         */
 782:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp128r2,                  /* oid/oidSz  */
 783:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp128r2_sz,
 784:../src/wolfcrypt/src/ecc.c ****         ECC_SECP128R2_OID,                  /* oid sum    */
 785:../src/wolfcrypt/src/ecc.c ****         4,                                  /* cofactor   */
 786:../src/wolfcrypt/src/ecc.c ****     },
 787:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
 788:../src/wolfcrypt/src/ecc.c **** #endif /* ECC128 */
 789:../src/wolfcrypt/src/ecc.c **** #ifdef ECC160
 790:../src/wolfcrypt/src/ecc.c **** #ifndef FP_ECC
 791:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 792:../src/wolfcrypt/src/ecc.c ****     {
 793:../src/wolfcrypt/src/ecc.c ****         20,                                         /* size/bytes */
 794:../src/wolfcrypt/src/ecc.c ****         ECC_SECP160R1,                              /* ID         */
 795:../src/wolfcrypt/src/ecc.c ****         "SECP160R1",                                /* curve name */
 796:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF", /* prime      */
 797:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC", /* A          */
 798:../src/wolfcrypt/src/ecc.c ****         "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45", /* B          */
 799:../src/wolfcrypt/src/ecc.c ****         "100000000000000000001F4C8F927AED3CA752257",/* order      */
 800:../src/wolfcrypt/src/ecc.c ****         "4A96B5688EF573284664698968C38BB913CBFC82", /* Gx         */
 801:../src/wolfcrypt/src/ecc.c ****         "23A628553168947D59DCC912042351377AC5FB32", /* Gy         */
 802:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp160r1,                          /* oid/oidSz  */
 803:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp160r1_sz,
 804:../src/wolfcrypt/src/ecc.c ****         ECC_SECP160R1_OID,                          /* oid sum    */
 805:../src/wolfcrypt/src/ecc.c ****         1,                                          /* cofactor   */
 806:../src/wolfcrypt/src/ecc.c ****     },
 807:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 808:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
 809:../src/wolfcrypt/src/ecc.c ****     {
 810:../src/wolfcrypt/src/ecc.c ****         20,                                         /* size/bytes */
 811:../src/wolfcrypt/src/ecc.c ****         ECC_SECP160R2,                              /* ID         */
 812:../src/wolfcrypt/src/ecc.c ****         "SECP160R2",                                /* curve name */
 813:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73", /* prime      */
 814:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC70", /* A          */
 815:../src/wolfcrypt/src/ecc.c ****         "B4E134D3FB59EB8BAB57274904664D5AF50388BA", /* B          */
 816:../src/wolfcrypt/src/ecc.c ****         "100000000000000000000351EE786A818F3A1A16B",/* order      */
 817:../src/wolfcrypt/src/ecc.c ****         "52DCB034293A117E1F4FF11B30F7199D3144CE6D", /* Gx         */
 818:../src/wolfcrypt/src/ecc.c ****         "FEAFFEF2E331F296E071FA0DF9982CFEA7D43F2E", /* Gy         */
 819:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp160r2,                          /* oid/oidSz  */
 820:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp160r2_sz,
 821:../src/wolfcrypt/src/ecc.c ****         ECC_SECP160R2_OID,                          /* oid sum    */
 822:../src/wolfcrypt/src/ecc.c ****         1,                                          /* cofactor   */
 823:../src/wolfcrypt/src/ecc.c ****     },
 824:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
 825:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_KOBLITZ
 826:../src/wolfcrypt/src/ecc.c ****     {
 827:../src/wolfcrypt/src/ecc.c ****         20,                                         /* size/bytes */
 828:../src/wolfcrypt/src/ecc.c ****         ECC_SECP160K1,                              /* ID         */
 829:../src/wolfcrypt/src/ecc.c ****         "SECP160K1",                                /* curve name */
 830:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73", /* prime      */
 831:../src/wolfcrypt/src/ecc.c ****         "0000000000000000000000000000000000000000", /* A          */
 832:../src/wolfcrypt/src/ecc.c ****         "0000000000000000000000000000000000000007", /* B          */
 833:../src/wolfcrypt/src/ecc.c ****         "100000000000000000001B8FA16DFAB9ACA16B6B3",/* order      */
 834:../src/wolfcrypt/src/ecc.c ****         "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB", /* Gx         */
 835:../src/wolfcrypt/src/ecc.c ****         "938CF935318FDCED6BC28286531733C3F03C4FEE", /* Gy         */
 836:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp160k1,                          /* oid/oidSz  */
 837:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp160k1_sz,
 838:../src/wolfcrypt/src/ecc.c ****         ECC_SECP160K1_OID,                          /* oid sum    */
 839:../src/wolfcrypt/src/ecc.c ****         1,                                          /* cofactor   */
 840:../src/wolfcrypt/src/ecc.c ****     },
 841:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_KOBLITZ */
 842:../src/wolfcrypt/src/ecc.c **** #endif /* !FP_ECC */
 843:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 844:../src/wolfcrypt/src/ecc.c ****     {
 845:../src/wolfcrypt/src/ecc.c ****         20,                                         /* size/bytes */
 846:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP160R1,                        /* ID         */
 847:../src/wolfcrypt/src/ecc.c ****         "BRAINPOOLP160R1",                          /* curve name */
 848:../src/wolfcrypt/src/ecc.c ****         "E95E4A5F737059DC60DFC7AD95B3D8139515620F", /* prime      */
 849:../src/wolfcrypt/src/ecc.c ****         "340E7BE2A280EB74E2BE61BADA745D97E8F7C300", /* A          */
 850:../src/wolfcrypt/src/ecc.c ****         "1E589A8595423412134FAA2DBDEC95C8D8675E58", /* B          */
 851:../src/wolfcrypt/src/ecc.c ****         "E95E4A5F737059DC60DF5991D45029409E60FC09", /* order      */
 852:../src/wolfcrypt/src/ecc.c ****         "BED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC3", /* Gx         */
 853:../src/wolfcrypt/src/ecc.c ****         "1667CB477A1A8EC338F94741669C976316DA6321", /* Gy         */
 854:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp160r1,                    /* oid/oidSz  */
 855:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp160r1_sz,
 856:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP160R1_OID,                    /* oid sum    */
 857:../src/wolfcrypt/src/ecc.c ****         1,                                          /* cofactor   */
 858:../src/wolfcrypt/src/ecc.c ****     },
 859:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
 860:../src/wolfcrypt/src/ecc.c **** #endif /* ECC160 */
 861:../src/wolfcrypt/src/ecc.c **** #ifdef ECC192
 862:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 863:../src/wolfcrypt/src/ecc.c ****     {
 864:../src/wolfcrypt/src/ecc.c ****         24,                                                 /* size/bytes */
 865:../src/wolfcrypt/src/ecc.c ****         ECC_SECP192R1,                                      /* ID         */
 866:../src/wolfcrypt/src/ecc.c ****         "SECP192R1",                                        /* curve name */
 867:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", /* prime      */
 868:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", /* A          */
 869:../src/wolfcrypt/src/ecc.c ****         "64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", /* B          */
 870:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", /* order      */
 871:../src/wolfcrypt/src/ecc.c ****         "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", /* Gx         */
 872:../src/wolfcrypt/src/ecc.c ****         "7192B95FFC8DA78631011ED6B24CDD573F977A11E794811",  /* Gy         */
 873:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp192r1,                                  /* oid/oidSz  */
 874:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp192r1_sz,
 875:../src/wolfcrypt/src/ecc.c ****         ECC_SECP192R1_OID,                                  /* oid sum    */
 876:../src/wolfcrypt/src/ecc.c ****         1,                                                  /* cofactor   */
 877:../src/wolfcrypt/src/ecc.c ****     },
 878:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 879:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
 880:../src/wolfcrypt/src/ecc.c ****     {
 881:../src/wolfcrypt/src/ecc.c ****         24,                                                 /* size/bytes */
 882:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME192V2,                                     /* ID         */
 883:../src/wolfcrypt/src/ecc.c ****         "PRIME192V2",                                       /* curve name */
 884:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", /* prime      */
 885:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", /* A          */
 886:../src/wolfcrypt/src/ecc.c ****         "CC22D6DFB95C6B25E49C0D6364A4E5980C393AA21668D953", /* B          */
 887:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFE5FB1A724DC80418648D8DD31", /* order      */
 888:../src/wolfcrypt/src/ecc.c ****         "EEA2BAE7E1497842F2DE7769CFE9C989C072AD696F48034A", /* Gx         */
 889:../src/wolfcrypt/src/ecc.c ****         "6574D11D69B6EC7A672BB82A083DF2F2B0847DE970B2DE15", /* Gy         */
 890:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime192v2,                                 /* oid/oidSz  */
 891:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime192v2_sz,
 892:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME192V2_OID,                                 /* oid sum    */
 893:../src/wolfcrypt/src/ecc.c ****         1,                                                  /* cofactor   */
 894:../src/wolfcrypt/src/ecc.c ****     },
 895:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
 896:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR3
 897:../src/wolfcrypt/src/ecc.c ****     {
 898:../src/wolfcrypt/src/ecc.c ****         24,                                                 /* size/bytes */
 899:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME192V3,                                     /* ID         */
 900:../src/wolfcrypt/src/ecc.c ****         "PRIME192V3",                                       /* curve name */
 901:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", /* prime      */
 902:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", /* A          */
 903:../src/wolfcrypt/src/ecc.c ****         "22123DC2395A05CAA7423DAECCC94760A7D462256BD56916", /* B          */
 904:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFF7A62D031C83F4294F640EC13", /* order      */
 905:../src/wolfcrypt/src/ecc.c ****         "7D29778100C65A1DA1783716588DCE2B8B4AEE8E228F1896", /* Gx         */
 906:../src/wolfcrypt/src/ecc.c ****         "38A90F22637337334B49DCB66A6DC8F9978ACA7648A943B0", /* Gy         */
 907:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime192v3,                                 /* oid/oidSz  */
 908:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime192v3_sz,
 909:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME192V3_OID,                                 /* oid sum    */
 910:../src/wolfcrypt/src/ecc.c ****         1,                                                  /* cofactor   */
 911:../src/wolfcrypt/src/ecc.c ****     },
 912:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR3 */
 913:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_KOBLITZ
 914:../src/wolfcrypt/src/ecc.c ****     {
 915:../src/wolfcrypt/src/ecc.c ****         24,                                                 /* size/bytes */
 916:../src/wolfcrypt/src/ecc.c ****         ECC_SECP192K1,                                      /* ID         */
 917:../src/wolfcrypt/src/ecc.c ****         "SECP192K1",                                        /* curve name */
 918:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37", /* prime      */
 919:../src/wolfcrypt/src/ecc.c ****         "000000000000000000000000000000000000000000000000", /* A          */
 920:../src/wolfcrypt/src/ecc.c ****         "000000000000000000000000000000000000000000000003", /* B          */
 921:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D", /* order      */
 922:../src/wolfcrypt/src/ecc.c ****         "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D", /* Gx         */
 923:../src/wolfcrypt/src/ecc.c ****         "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D", /* Gy         */
 924:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp192k1,                                  /* oid/oidSz  */
 925:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp192k1_sz,
 926:../src/wolfcrypt/src/ecc.c ****         ECC_SECP192K1_OID,                                  /* oid sum    */
 927:../src/wolfcrypt/src/ecc.c ****         1,                                                  /* cofactor   */
 928:../src/wolfcrypt/src/ecc.c ****     },
 929:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_KOBLITZ */
 930:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 931:../src/wolfcrypt/src/ecc.c ****     {
 932:../src/wolfcrypt/src/ecc.c ****         24,                                                 /* size/bytes */
 933:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP192R1,                                /* ID         */
 934:../src/wolfcrypt/src/ecc.c ****         "BRAINPOOLP192R1",                                  /* curve name */
 935:../src/wolfcrypt/src/ecc.c ****         "C302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297", /* prime      */
 936:../src/wolfcrypt/src/ecc.c ****         "6A91174076B1E0E19C39C031FE8685C1CAE040E5C69A28EF", /* A          */
 937:../src/wolfcrypt/src/ecc.c ****         "469A28EF7C28CCA3DC721D044F4496BCCA7EF4146FBF25C9", /* B          */
 938:../src/wolfcrypt/src/ecc.c ****         "C302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1", /* order      */
 939:../src/wolfcrypt/src/ecc.c ****         "C0A0647EAAB6A48753B033C56CB0F0900A2F5C4853375FD6", /* Gx         */
 940:../src/wolfcrypt/src/ecc.c ****         "14B690866ABD5BB88B5F4828C1490002E6773FA2FA299B8F", /* Gy         */
 941:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp192r1,                            /* oid/oidSz  */
 942:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp192r1_sz,
 943:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP192R1_OID,                            /* oid sum    */
 944:../src/wolfcrypt/src/ecc.c ****         1,                                                  /* cofactor   */
 945:../src/wolfcrypt/src/ecc.c ****     },
 946:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
 947:../src/wolfcrypt/src/ecc.c **** #endif /* ECC192 */
 948:../src/wolfcrypt/src/ecc.c **** #ifdef ECC224
 949:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
 950:../src/wolfcrypt/src/ecc.c ****     {
 951:../src/wolfcrypt/src/ecc.c ****         28,                                                         /* size/bytes */
 952:../src/wolfcrypt/src/ecc.c ****         ECC_SECP224R1,                                              /* ID         */
 953:../src/wolfcrypt/src/ecc.c ****         "SECP224R1",                                                /* curve name */
 954:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001", /* prime      */
 955:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE", /* A          */
 956:../src/wolfcrypt/src/ecc.c ****         "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4", /* B          */
 957:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D", /* order      */
 958:../src/wolfcrypt/src/ecc.c ****         "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21", /* Gx         */
 959:../src/wolfcrypt/src/ecc.c ****         "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34", /* Gy         */
 960:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp224r1,                                          /* oid/oidSz  */
 961:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp224r1_sz,
 962:../src/wolfcrypt/src/ecc.c ****         ECC_SECP224R1_OID,                                          /* oid sum    */
 963:../src/wolfcrypt/src/ecc.c ****         1,                                                          /* cofactor   */
 964:../src/wolfcrypt/src/ecc.c ****     },
 965:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
 966:../src/wolfcrypt/src/ecc.c ****     #if defined(HAVE_ECC_KOBLITZ) && !defined(FP_ECC)
 967:../src/wolfcrypt/src/ecc.c ****     {
 968:../src/wolfcrypt/src/ecc.c ****         28,                                                         /* size/bytes */
 969:../src/wolfcrypt/src/ecc.c ****         ECC_SECP224K1,                                              /* ID         */
 970:../src/wolfcrypt/src/ecc.c ****         "SECP224K1",                                                /* curve name */
 971:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFE56D", /* prime      */
 972:../src/wolfcrypt/src/ecc.c ****         "00000000000000000000000000000000000000000000000000000000", /* A          */
 973:../src/wolfcrypt/src/ecc.c ****         "00000000000000000000000000000000000000000000000000000005", /* B          */
 974:../src/wolfcrypt/src/ecc.c ****         "10000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7",/* order      */
 975:../src/wolfcrypt/src/ecc.c ****         "A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C", /* Gx         */
 976:../src/wolfcrypt/src/ecc.c ****         "7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5", /* Gy         */
 977:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp224k1,                                          /* oid/oidSz  */
 978:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp224k1_sz,
 979:../src/wolfcrypt/src/ecc.c ****         ECC_SECP224K1_OID,                                          /* oid sum    */
 980:../src/wolfcrypt/src/ecc.c ****         1,                                                          /* cofactor   */
 981:../src/wolfcrypt/src/ecc.c ****     },
 982:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_KOBLITZ && !FP_ECC */
 983:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
 984:../src/wolfcrypt/src/ecc.c ****     {
 985:../src/wolfcrypt/src/ecc.c ****         28,                                                         /* size/bytes */
 986:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP224R1,                                        /* ID         */
 987:../src/wolfcrypt/src/ecc.c ****         "BRAINPOOLP224R1",                                          /* curve name */
 988:../src/wolfcrypt/src/ecc.c ****         "D7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF", /* prime      */
 989:../src/wolfcrypt/src/ecc.c ****         "68A5E62CA9CE6C1C299803A6C1530B514E182AD8B0042A59CAD29F43", /* A          */
 990:../src/wolfcrypt/src/ecc.c ****         "2580F63CCFE44138870713B1A92369E33E2135D266DBB372386C400B", /* B          */
 991:../src/wolfcrypt/src/ecc.c ****         "D7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F", /* order      */
 992:../src/wolfcrypt/src/ecc.c ****         "0D9029AD2C7E5CF4340823B2A87DC68C9E4CE3174C1E6EFDEE12C07D", /* Gx         */
 993:../src/wolfcrypt/src/ecc.c ****         "58AA56F772C0726F24C6B89E4ECDAC24354B9E99CAA3F6D3761402CD", /* Gy         */
 994:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp224r1,                                    /* oid/oidSz  */
 995:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp224r1_sz,
 996:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP224R1_OID,                                    /* oid sum    */
 997:../src/wolfcrypt/src/ecc.c ****         1,                                                          /* cofactor   */
 998:../src/wolfcrypt/src/ecc.c ****     },
 999:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
1000:../src/wolfcrypt/src/ecc.c **** #endif /* ECC224 */
1001:../src/wolfcrypt/src/ecc.c **** #ifdef ECC239
1002:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
1003:../src/wolfcrypt/src/ecc.c ****     {
1004:../src/wolfcrypt/src/ecc.c ****         30,                                                             /* size/bytes */
1005:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME239V1,                                                 /* ID         */
1006:../src/wolfcrypt/src/ecc.c ****         "PRIME239V1",                                                   /* curve name */
1007:../src/wolfcrypt/src/ecc.c ****         "7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF", /* prime      */
1008:../src/wolfcrypt/src/ecc.c ****         "7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC", /* A          */
1009:../src/wolfcrypt/src/ecc.c ****         "6B016C3BDCF18941D0D654921475CA71A9DB2FB27D1D37796185C2942C0A", /* B          */
1010:../src/wolfcrypt/src/ecc.c ****         "7FFFFFFFFFFFFFFFFFFFFFFF7FFFFF9E5E9A9F5D9071FBD1522688909D0B", /* order      */
1011:../src/wolfcrypt/src/ecc.c ****         "0FFA963CDCA8816CCC33B8642BEDF905C3D358573D3F27FBBD3B3CB9AAAF", /* Gx         */
1012:../src/wolfcrypt/src/ecc.c ****         "7DEBE8E4E90A5DAE6E4054CA530BA04654B36818CE226B39FCCB7B02F1AE", /* Gy         */
1013:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime239v1,                                             /* oid/oidSz  */
1014:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime239v1_sz,
1015:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME239V1_OID,                                             /* oid sum    */
1016:../src/wolfcrypt/src/ecc.c ****         1,                                                              /* cofactor   */
1017:../src/wolfcrypt/src/ecc.c ****     },
1018:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
1019:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR2
1020:../src/wolfcrypt/src/ecc.c ****     {
1021:../src/wolfcrypt/src/ecc.c ****         30,                                                             /* size/bytes */
1022:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME239V2,                                                 /* ID         */
1023:../src/wolfcrypt/src/ecc.c ****         "PRIME239V2",                                                   /* curve name */
1024:../src/wolfcrypt/src/ecc.c ****         "7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF", /* prime      */
1025:../src/wolfcrypt/src/ecc.c ****         "7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC", /* A          */
1026:../src/wolfcrypt/src/ecc.c ****         "617FAB6832576CBBFED50D99F0249C3FEE58B94BA0038C7AE84C8C832F2C", /* B          */
1027:../src/wolfcrypt/src/ecc.c ****         "7FFFFFFFFFFFFFFFFFFFFFFF800000CFA7E8594377D414C03821BC582063", /* order      */
1028:../src/wolfcrypt/src/ecc.c ****         "38AF09D98727705120C921BB5E9E26296A3CDCF2F35757A0EAFD87B830E7", /* Gx         */
1029:../src/wolfcrypt/src/ecc.c ****         "5B0125E4DBEA0EC7206DA0FC01D9B081329FB555DE6EF460237DFF8BE4BA", /* Gy         */
1030:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime239v2,                                             /* oid/oidSz  */
1031:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime239v2_sz,
1032:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME239V2_OID,                                             /* oid sum    */
1033:../src/wolfcrypt/src/ecc.c ****         1,                                                              /* cofactor   */
1034:../src/wolfcrypt/src/ecc.c ****     },
1035:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR2 */
1036:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_SECPR3
1037:../src/wolfcrypt/src/ecc.c ****     {
1038:../src/wolfcrypt/src/ecc.c ****         30,                                                             /* size/bytes */
1039:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME239V3,                                                 /* ID         */
1040:../src/wolfcrypt/src/ecc.c ****         "PRIME239V3",                                                   /* curve name */
1041:../src/wolfcrypt/src/ecc.c ****         "7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF", /* prime      */
1042:../src/wolfcrypt/src/ecc.c ****         "7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC", /* A          */
1043:../src/wolfcrypt/src/ecc.c ****         "255705FA2A306654B1F4CB03D6A750A30C250102D4988717D9BA15AB6D3E", /* B          */
1044:../src/wolfcrypt/src/ecc.c ****         "7FFFFFFFFFFFFFFFFFFFFFFF7FFFFF975DEB41B3A6057C3C432146526551", /* order      */
1045:../src/wolfcrypt/src/ecc.c ****         "6768AE8E18BB92CFCF005C949AA2C6D94853D0E660BBF854B1C9505FE95A", /* Gx         */
1046:../src/wolfcrypt/src/ecc.c ****         "1607E6898F390C06BC1D552BAD226F3B6FCFE48B6E818499AF18E3ED6CF3", /* Gy         */
1047:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime239v3,                                             /* oid/oidSz  */
1048:../src/wolfcrypt/src/ecc.c ****         ecc_oid_prime239v3_sz,
1049:../src/wolfcrypt/src/ecc.c ****         ECC_PRIME239V3_OID,                                             /* oid sum    */
1050:../src/wolfcrypt/src/ecc.c ****         1,                                                              /* cofactor   */
1051:../src/wolfcrypt/src/ecc.c ****     },
1052:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_SECPR3 */
1053:../src/wolfcrypt/src/ecc.c **** #endif /* ECC239 */
1054:../src/wolfcrypt/src/ecc.c **** #ifdef ECC256
1055:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
1056:../src/wolfcrypt/src/ecc.c ****     {
1057:../src/wolfcrypt/src/ecc.c ****         32,                                                                 /* size/bytes */
1058:../src/wolfcrypt/src/ecc.c ****         ECC_SECP256R1,                                                      /* ID         */
1059:../src/wolfcrypt/src/ecc.c ****         "SECP256R1",                                                        /* curve name */
1060:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", /* prime      */
1061:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", /* A          */
1062:../src/wolfcrypt/src/ecc.c ****         "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", /* B          */
1063:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", /* order      */
1064:../src/wolfcrypt/src/ecc.c ****         "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", /* Gx         */
1065:../src/wolfcrypt/src/ecc.c ****         "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", /* Gy         */
1066:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp256r1,                                                  /* oid/oidSz  */
1067:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp256r1_sz,
1068:../src/wolfcrypt/src/ecc.c ****         ECC_SECP256R1_OID,                                                  /* oid sum    */
1069:../src/wolfcrypt/src/ecc.c ****         1,                                                                  /* cofactor   */
1070:../src/wolfcrypt/src/ecc.c ****     },
1071:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
1072:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_KOBLITZ
1073:../src/wolfcrypt/src/ecc.c ****     {
1074:../src/wolfcrypt/src/ecc.c ****         32,                                                                 /* size/bytes */
1075:../src/wolfcrypt/src/ecc.c ****         ECC_SECP256K1,                                                      /* ID         */
1076:../src/wolfcrypt/src/ecc.c ****         "SECP256K1",                                                        /* curve name */
1077:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", /* prime      */
1078:../src/wolfcrypt/src/ecc.c ****         "0000000000000000000000000000000000000000000000000000000000000000", /* A          */
1079:../src/wolfcrypt/src/ecc.c ****         "0000000000000000000000000000000000000000000000000000000000000007", /* B          */
1080:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", /* order      */
1081:../src/wolfcrypt/src/ecc.c ****         "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", /* Gx         */
1082:../src/wolfcrypt/src/ecc.c ****         "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", /* Gy         */
1083:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp256k1,                                                  /* oid/oidSz  */
1084:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp256k1_sz,
1085:../src/wolfcrypt/src/ecc.c ****         ECC_SECP256K1_OID,                                                  /* oid sum    */
1086:../src/wolfcrypt/src/ecc.c ****         1,                                                                  /* cofactor   */
1087:../src/wolfcrypt/src/ecc.c ****     },
1088:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_KOBLITZ */
1089:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
1090:../src/wolfcrypt/src/ecc.c ****     {
1091:../src/wolfcrypt/src/ecc.c ****         32,                                                                 /* size/bytes */
1092:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP256R1,                                                /* ID         */
1093:../src/wolfcrypt/src/ecc.c ****         "BRAINPOOLP256R1",                                                  /* curve name */
1094:../src/wolfcrypt/src/ecc.c ****         "A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377", /* prime      */
1095:../src/wolfcrypt/src/ecc.c ****         "7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330B5D9", /* A          */
1096:../src/wolfcrypt/src/ecc.c ****         "26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C07B6", /* B          */
1097:../src/wolfcrypt/src/ecc.c ****         "A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7", /* order      */
1098:../src/wolfcrypt/src/ecc.c ****         "8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262", /* Gx         */
1099:../src/wolfcrypt/src/ecc.c ****         "547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997", /* Gy         */
1100:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp256r1,                                            /* oid/oidSz  */
1101:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp256r1_sz,
1102:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP256R1_OID,                                            /* oid sum    */
1103:../src/wolfcrypt/src/ecc.c ****         1,                                                                  /* cofactor   */
1104:../src/wolfcrypt/src/ecc.c ****     },
1105:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
1106:../src/wolfcrypt/src/ecc.c **** #endif /* ECC256 */
1107:../src/wolfcrypt/src/ecc.c **** #ifdef ECC320
1108:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
1109:../src/wolfcrypt/src/ecc.c ****     {
1110:../src/wolfcrypt/src/ecc.c ****         40,                                                                                 /* size
1111:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP320R1,                                                                /* ID  
1112:../src/wolfcrypt/src/ecc.c ****         "BRAINPOOLP320R1",                                                                  /* curv
1113:../src/wolfcrypt/src/ecc.c ****         "D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E27", /* prim
1114:../src/wolfcrypt/src/ecc.c ****         "3EE30B568FBAB0F883CCEBD46D3F3BB8A2A73513F5EB79DA66190EB085FFA9F492F375A97D860EB4", /* A   
1115:../src/wolfcrypt/src/ecc.c ****         "520883949DFDBC42D3AD198640688A6FE13F41349554B49ACC31DCCD884539816F5EB4AC8FB1F1A6", /* B   
1116:../src/wolfcrypt/src/ecc.c ****         "D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E98691555B44C59311", /* orde
1117:../src/wolfcrypt/src/ecc.c ****         "43BD7E9AFB53D8B85289BCC48EE5BFE6F20137D10A087EB6E7871E2A10A599C710AF8D0D39E20611", /* Gx  
1118:../src/wolfcrypt/src/ecc.c ****         "14FDD05545EC1CC8AB4093247F77275E0743FFED117182EAA9C77877AAAC6AC7D35245D1692E8EE1", /* Gy  
1119:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp320r1, ecc_oid_brainpoolp320r1_sz,                                /* oid/
1120:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP320R1_OID,                                                            /* oid 
1121:../src/wolfcrypt/src/ecc.c ****         1,                                                                                  /* cofa
1122:../src/wolfcrypt/src/ecc.c ****     },
1123:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
1124:../src/wolfcrypt/src/ecc.c **** #endif /* ECC320 */
1125:../src/wolfcrypt/src/ecc.c **** #ifdef ECC384
1126:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
1127:../src/wolfcrypt/src/ecc.c ****     {
1128:../src/wolfcrypt/src/ecc.c ****         48,                                                                                        
1129:../src/wolfcrypt/src/ecc.c ****         ECC_SECP384R1,                                                                             
1130:../src/wolfcrypt/src/ecc.c ****         "SECP384R1",                                                                               
1131:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FF
1132:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FF
1133:../src/wolfcrypt/src/ecc.c ****         "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3
1134:../src/wolfcrypt/src/ecc.c ****         "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACC
1135:../src/wolfcrypt/src/ecc.c ****         "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872
1136:../src/wolfcrypt/src/ecc.c ****         "3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90
1137:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp384r1, ecc_oid_secp384r1_sz,                                                   
1138:../src/wolfcrypt/src/ecc.c ****         ECC_SECP384R1_OID,                                                                         
1139:../src/wolfcrypt/src/ecc.c ****         1,                                                                                         
1140:../src/wolfcrypt/src/ecc.c ****     },
1141:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
1142:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
1143:../src/wolfcrypt/src/ecc.c ****     {
1144:../src/wolfcrypt/src/ecc.c ****         48,                                                                                        
1145:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP384R1,                                                                       
1146:../src/wolfcrypt/src/ecc.c ****         "BRAINPOOLP384R1",                                                                         
1147:../src/wolfcrypt/src/ecc.c ****         "8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A718747001331
1148:../src/wolfcrypt/src/ecc.c ****         "7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787139165EFBA91F90F8AA5814A503AD4EB04A8C7DD22
1149:../src/wolfcrypt/src/ecc.c ****         "04A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A62E880EA53EEB62D57CB4390295DBC9943AB78696FA
1150:../src/wolfcrypt/src/ecc.c ****         "8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9
1151:../src/wolfcrypt/src/ecc.c ****         "1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247
1152:../src/wolfcrypt/src/ecc.c ****         "8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E464621779181114282034126
1153:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp384r1, ecc_oid_brainpoolp384r1_sz,                                       
1154:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP384R1_OID,                                                                   
1155:../src/wolfcrypt/src/ecc.c ****         1,                                                                                         
1156:../src/wolfcrypt/src/ecc.c ****     },
1157:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
1158:../src/wolfcrypt/src/ecc.c **** #endif /* ECC384 */
1159:../src/wolfcrypt/src/ecc.c **** #ifdef ECC512
1160:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_ECC_BRAINPOOL
1161:../src/wolfcrypt/src/ecc.c ****     {
1162:../src/wolfcrypt/src/ecc.c ****         64,                                                                                        
1163:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP512R1,                                                                       
1164:../src/wolfcrypt/src/ecc.c ****         "BRAINPOOLP512R1",                                                                         
1165:../src/wolfcrypt/src/ecc.c ****         "AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6
1166:../src/wolfcrypt/src/ecc.c ****         "7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B
1167:../src/wolfcrypt/src/ecc.c ****         "3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CADC
1168:../src/wolfcrypt/src/ecc.c ****         "AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870553E5C414CA92619418661197F
1169:../src/wolfcrypt/src/ecc.c ****         "81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93
1170:../src/wolfcrypt/src/ecc.c ****         "7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A
1171:../src/wolfcrypt/src/ecc.c ****         ecc_oid_brainpoolp512r1, ecc_oid_brainpoolp512r1_sz,                                       
1172:../src/wolfcrypt/src/ecc.c ****         ECC_BRAINPOOLP512R1_OID,                                                                   
1173:../src/wolfcrypt/src/ecc.c ****         1,                                                                                         
1174:../src/wolfcrypt/src/ecc.c ****     },
1175:../src/wolfcrypt/src/ecc.c ****     #endif /* HAVE_ECC_BRAINPOOL */
1176:../src/wolfcrypt/src/ecc.c **** #endif /* ECC512 */
1177:../src/wolfcrypt/src/ecc.c **** #ifdef ECC521
1178:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ECC_SECP
1179:../src/wolfcrypt/src/ecc.c ****     {
1180:../src/wolfcrypt/src/ecc.c ****         66,                                                                                        
1181:../src/wolfcrypt/src/ecc.c ****         ECC_SECP521R1,                                                                             
1182:../src/wolfcrypt/src/ecc.c ****         "SECP521R1",                                                                               
1183:../src/wolfcrypt/src/ecc.c ****         "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
1184:../src/wolfcrypt/src/ecc.c ****         "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
1185:../src/wolfcrypt/src/ecc.c ****         "51953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD
1186:../src/wolfcrypt/src/ecc.c ****         "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC014
1187:../src/wolfcrypt/src/ecc.c ****         "C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127
1188:../src/wolfcrypt/src/ecc.c ****         "11839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B90
1189:../src/wolfcrypt/src/ecc.c ****         ecc_oid_secp521r1, ecc_oid_secp521r1_sz,                                                   
1190:../src/wolfcrypt/src/ecc.c ****         ECC_SECP521R1_OID,                                                                         
1191:../src/wolfcrypt/src/ecc.c ****         1,                                                                                         
1192:../src/wolfcrypt/src/ecc.c ****     },
1193:../src/wolfcrypt/src/ecc.c ****     #endif /* !NO_ECC_SECP */
1194:../src/wolfcrypt/src/ecc.c **** #endif /* ECC521 */
1195:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFCRYPT_HAVE_SAKKE
1196:../src/wolfcrypt/src/ecc.c ****     {
1197:../src/wolfcrypt/src/ecc.c ****         128,
1198:../src/wolfcrypt/src/ecc.c ****         ECC_SAKKE_1,
1199:../src/wolfcrypt/src/ecc.c ****         "SAKKE1",
1200:../src/wolfcrypt/src/ecc.c ****         "997ABB1F0A563FDA65C61198DAD0657A416C0CE19CB48261BE9AE358B3E01A2EF40AAB27E2FC0F1B228730D531
1201:../src/wolfcrypt/src/ecc.c ****         "997ABB1F0A563FDA65C61198DAD0657A416C0CE19CB48261BE9AE358B3E01A2EF40AAB27E2FC0F1B228730D531
1202:../src/wolfcrypt/src/ecc.c ****         "0",
1203:../src/wolfcrypt/src/ecc.c ****         "265EAEC7C2958FF69971846636B4195E905B0338672D20986FA6B8D62CF8068BBD02AAC9F8BF03C6C8A1CC354C
1204:../src/wolfcrypt/src/ecc.c ****         "53FC09EE332C29AD0A7990053ED9B52A2B1A2FD60AEC69C698B2F204B6FF7CBFB5EDB6C0F6CE2308AB10DB9030
1205:../src/wolfcrypt/src/ecc.c ****         "0A8249063F6009F1F9F1F0533634A135D3E82016029906963D778D821E141178F5EA69F4654EC2B9E7F7F5E5F0
1206:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
1207:../src/wolfcrypt/src/ecc.c ****             NULL, 0,
1208:../src/wolfcrypt/src/ecc.c ****         #else
1209:../src/wolfcrypt/src/ecc.c ****             {0}, 0,
1210:../src/wolfcrypt/src/ecc.c ****         #endif
1211:../src/wolfcrypt/src/ecc.c ****         0,
1212:../src/wolfcrypt/src/ecc.c ****         4,
1213:../src/wolfcrypt/src/ecc.c ****     },
1214:../src/wolfcrypt/src/ecc.c **** #endif
1215:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_CUSTOM_CURVES) && defined(ECC_CACHE_CURVE)
1216:../src/wolfcrypt/src/ecc.c ****     /* place holder for custom curve index for cache */
1217:../src/wolfcrypt/src/ecc.c ****     {
1218:../src/wolfcrypt/src/ecc.c ****         1, /* non-zero */
1219:../src/wolfcrypt/src/ecc.c ****         ECC_CURVE_CUSTOM,
1220:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
1221:../src/wolfcrypt/src/ecc.c ****             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
1222:../src/wolfcrypt/src/ecc.c ****         #else
1223:../src/wolfcrypt/src/ecc.c ****             {0},{0},{0},{0},{0},{0},{0},{0},
1224:../src/wolfcrypt/src/ecc.c ****         #endif
1225:../src/wolfcrypt/src/ecc.c ****         0, 0, 0
1226:../src/wolfcrypt/src/ecc.c ****     },
1227:../src/wolfcrypt/src/ecc.c **** #endif
1228:../src/wolfcrypt/src/ecc.c ****     {
1229:../src/wolfcrypt/src/ecc.c ****         0,
1230:../src/wolfcrypt/src/ecc.c ****         ECC_CURVE_INVALID,
1231:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
1232:../src/wolfcrypt/src/ecc.c ****             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
1233:../src/wolfcrypt/src/ecc.c ****         #else
1234:../src/wolfcrypt/src/ecc.c ****             {0},{0},{0},{0},{0},{0},{0},{0},
1235:../src/wolfcrypt/src/ecc.c ****         #endif
1236:../src/wolfcrypt/src/ecc.c ****         0, 0, 0
1237:../src/wolfcrypt/src/ecc.c ****     }
1238:../src/wolfcrypt/src/ecc.c **** };
1239:../src/wolfcrypt/src/ecc.c **** #define ECC_SET_COUNT   (sizeof(ecc_sets)/sizeof(ecc_set_type))
1240:../src/wolfcrypt/src/ecc.c **** const size_t ecc_sets_count = ECC_SET_COUNT - 1;
1241:../src/wolfcrypt/src/ecc.c **** 
1242:../src/wolfcrypt/src/ecc.c **** 
1243:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_OID_ENCODING
1244:../src/wolfcrypt/src/ecc.c ****     /* encoded OID cache */
1245:../src/wolfcrypt/src/ecc.c ****     typedef struct {
1246:../src/wolfcrypt/src/ecc.c ****         word32 oidSz;
1247:../src/wolfcrypt/src/ecc.c ****         byte oid[ECC_MAX_OID_LEN];
1248:../src/wolfcrypt/src/ecc.c ****     } oid_cache_t;
1249:../src/wolfcrypt/src/ecc.c ****     static oid_cache_t ecc_oid_cache[ECC_SET_COUNT];
1250:../src/wolfcrypt/src/ecc.c **** #endif
1251:../src/wolfcrypt/src/ecc.c **** 
1252:../src/wolfcrypt/src/ecc.c **** 
1253:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
1254:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_export_x963_compressed(ecc_key* key, byte* out, word32* outLen);
1255:../src/wolfcrypt/src/ecc.c **** #endif
1256:../src/wolfcrypt/src/ecc.c **** 
1257:../src/wolfcrypt/src/ecc.c **** 
1258:../src/wolfcrypt/src/ecc.c **** 
1259:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH) && \
1260:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
1261:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_SILABS_SE_ACCEL) && \
1262:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_SE050) && !defined(WOLF_CRYPTO_CB_ONLY_ECC)
1263:../src/wolfcrypt/src/ecc.c **** static int ecc_check_pubkey_order(ecc_key* key, ecc_point* pubkey, mp_int* a,
1264:../src/wolfcrypt/src/ecc.c ****     mp_int* prime, mp_int* order);
1265:../src/wolfcrypt/src/ecc.c **** #endif
1266:../src/wolfcrypt/src/ecc.c **** static int _ecc_validate_public_key(ecc_key* key, int partial, int priv);
1267:../src/wolfcrypt/src/ecc.c **** #if (FIPS_VERSION_GE(5,0) || defined(WOLFSSL_VALIDATE_ECC_KEYGEN)) && \
1268:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_KCAPI_ECC)
1269:../src/wolfcrypt/src/ecc.c **** static int _ecc_pairwise_consistency_test(ecc_key* key, WC_RNG* rng);
1270:../src/wolfcrypt/src/ecc.c **** #endif
1271:../src/wolfcrypt/src/ecc.c **** 
1272:../src/wolfcrypt/src/ecc.c **** 
1273:../src/wolfcrypt/src/ecc.c **** int mp_jacobi(mp_int* a, mp_int* n, int* c);
1274:../src/wolfcrypt/src/ecc.c **** int mp_sqrtmod_prime(mp_int* n, mp_int* prime, mp_int* ret);
1275:../src/wolfcrypt/src/ecc.c **** 
1276:../src/wolfcrypt/src/ecc.c **** 
1277:../src/wolfcrypt/src/ecc.c **** /* Curve Specs */
1278:../src/wolfcrypt/src/ecc.c **** typedef struct ecc_curve_spec {
1279:../src/wolfcrypt/src/ecc.c ****     const ecc_set_type* dp;
1280:../src/wolfcrypt/src/ecc.c **** 
1281:../src/wolfcrypt/src/ecc.c ****     mp_int* prime;
1282:../src/wolfcrypt/src/ecc.c ****     mp_int* Af;
1283:../src/wolfcrypt/src/ecc.c ****     #ifdef USE_ECC_B_PARAM
1284:../src/wolfcrypt/src/ecc.c ****         mp_int* Bf;
1285:../src/wolfcrypt/src/ecc.c ****     #endif
1286:../src/wolfcrypt/src/ecc.c ****     mp_int* order;
1287:../src/wolfcrypt/src/ecc.c ****     mp_int* Gx;
1288:../src/wolfcrypt/src/ecc.c ****     mp_int* Gy;
1289:../src/wolfcrypt/src/ecc.c **** 
1290:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_CACHE_CURVE
1291:../src/wolfcrypt/src/ecc.c ****     mp_int prime_lcl;
1292:../src/wolfcrypt/src/ecc.c ****     mp_int Af_lcl;
1293:../src/wolfcrypt/src/ecc.c ****     #ifdef USE_ECC_B_PARAM
1294:../src/wolfcrypt/src/ecc.c ****         mp_int Bf_lcl;
1295:../src/wolfcrypt/src/ecc.c ****     #endif
1296:../src/wolfcrypt/src/ecc.c ****     mp_int order_lcl;
1297:../src/wolfcrypt/src/ecc.c ****     mp_int Gx_lcl;
1298:../src/wolfcrypt/src/ecc.c ****     mp_int Gy_lcl;
1299:../src/wolfcrypt/src/ecc.c **** #else
1300:../src/wolfcrypt/src/ecc.c ****     mp_int* spec_ints;
1301:../src/wolfcrypt/src/ecc.c ****     word32 spec_count;
1302:../src/wolfcrypt/src/ecc.c ****     word32 spec_use;
1303:../src/wolfcrypt/src/ecc.c **** #endif
1304:../src/wolfcrypt/src/ecc.c **** 
1305:../src/wolfcrypt/src/ecc.c ****     byte load_mask;
1306:../src/wolfcrypt/src/ecc.c **** } ecc_curve_spec;
1307:../src/wolfcrypt/src/ecc.c **** 
1308:../src/wolfcrypt/src/ecc.c **** enum ecc_curve_load_mask {
1309:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_NONE    = 0x00,
1310:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_PRIME   = 0x01,
1311:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_AF      = 0x02,
1312:../src/wolfcrypt/src/ecc.c **** #ifdef USE_ECC_B_PARAM
1313:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_BF      = 0x04,
1314:../src/wolfcrypt/src/ecc.c **** #endif
1315:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_ORDER   = 0x08,
1316:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_GX      = 0x10,
1317:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_GY      = 0x20,
1318:../src/wolfcrypt/src/ecc.c **** #ifdef USE_ECC_B_PARAM
1319:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_ALL     = 0x3F,
1320:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_COUNT   = 6,
1321:../src/wolfcrypt/src/ecc.c **** #else
1322:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_ALL     = 0x3B,
1323:../src/wolfcrypt/src/ecc.c ****     ECC_CURVE_FIELD_COUNT   = 5,
1324:../src/wolfcrypt/src/ecc.c **** #endif
1325:../src/wolfcrypt/src/ecc.c **** };
1326:../src/wolfcrypt/src/ecc.c **** 
1327:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_CACHE_CURVE
1328:../src/wolfcrypt/src/ecc.c ****     /* cache (mp_int) of the curve parameters */
1329:../src/wolfcrypt/src/ecc.c ****     static ecc_curve_spec* ecc_curve_spec_cache[ECC_SET_COUNT];
1330:../src/wolfcrypt/src/ecc.c ****     #ifndef SINGLE_THREADED
1331:../src/wolfcrypt/src/ecc.c ****         static wolfSSL_Mutex ecc_curve_cache_mutex;
1332:../src/wolfcrypt/src/ecc.c ****     #endif
1333:../src/wolfcrypt/src/ecc.c **** 
1334:../src/wolfcrypt/src/ecc.c ****     #define DECLARE_CURVE_SPECS(intcount) ecc_curve_spec* curve = NULL
1335:../src/wolfcrypt/src/ecc.c ****     #define ALLOC_CURVE_SPECS(intcount, err)
1336:../src/wolfcrypt/src/ecc.c ****     #define FREE_CURVE_SPECS()
1337:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SMALL_STACK)
1338:../src/wolfcrypt/src/ecc.c ****     #define DECLARE_CURVE_SPECS(intcount)                               \
1339:../src/wolfcrypt/src/ecc.c ****         mp_int* spec_ints = NULL;                                       \
1340:../src/wolfcrypt/src/ecc.c ****         ecc_curve_spec curve_lcl;                                       \
1341:../src/wolfcrypt/src/ecc.c ****         ecc_curve_spec* curve = &curve_lcl;                             \
1342:../src/wolfcrypt/src/ecc.c ****         XMEMSET(curve, 0, sizeof(ecc_curve_spec));                      \
1343:../src/wolfcrypt/src/ecc.c ****         curve->spec_count = intcount
1344:../src/wolfcrypt/src/ecc.c **** 
1345:../src/wolfcrypt/src/ecc.c ****     #define ALLOC_CURVE_SPECS(intcount, err)                            \
1346:../src/wolfcrypt/src/ecc.c ****         spec_ints = (mp_int*)XMALLOC(sizeof(mp_int) * (intcount), NULL, \
1347:../src/wolfcrypt/src/ecc.c ****                             DYNAMIC_TYPE_ECC);                          \
1348:../src/wolfcrypt/src/ecc.c ****         if (spec_ints == NULL)                                          \
1349:../src/wolfcrypt/src/ecc.c ****             (err) = MEMORY_E;                                           \
1350:../src/wolfcrypt/src/ecc.c ****         else                                                            \
1351:../src/wolfcrypt/src/ecc.c ****             curve->spec_ints = spec_ints
1352:../src/wolfcrypt/src/ecc.c ****     #define FREE_CURVE_SPECS()                                          \
1353:../src/wolfcrypt/src/ecc.c ****         XFREE(spec_ints, NULL, DYNAMIC_TYPE_ECC)
1354:../src/wolfcrypt/src/ecc.c **** #else
1355:../src/wolfcrypt/src/ecc.c ****     #define DECLARE_CURVE_SPECS(intcount) \
1356:../src/wolfcrypt/src/ecc.c ****         mp_int spec_ints[(intcount)]; \
1357:../src/wolfcrypt/src/ecc.c ****         ecc_curve_spec curve_lcl; \
1358:../src/wolfcrypt/src/ecc.c ****         ecc_curve_spec* curve = &curve_lcl; \
1359:../src/wolfcrypt/src/ecc.c ****         XMEMSET(curve, 0, sizeof(ecc_curve_spec)); \
1360:../src/wolfcrypt/src/ecc.c ****         curve->spec_ints = spec_ints; \
1361:../src/wolfcrypt/src/ecc.c ****         curve->spec_count = (intcount)
1362:../src/wolfcrypt/src/ecc.c ****     #define ALLOC_CURVE_SPECS(intcount, err)
1363:../src/wolfcrypt/src/ecc.c ****     #define FREE_CURVE_SPECS()
1364:../src/wolfcrypt/src/ecc.c **** #endif /* ECC_CACHE_CURVE */
1365:../src/wolfcrypt/src/ecc.c **** 
1366:../src/wolfcrypt/src/ecc.c **** static void wc_ecc_curve_cache_free_spec_item(ecc_curve_spec* curve, mp_int* item,
1367:../src/wolfcrypt/src/ecc.c ****     byte mask)
1368:../src/wolfcrypt/src/ecc.c **** {
 261                             		.loc 2 1368 1
 262 0000 7E AA                   		push.l	r10
 263                             	.LCFI2:
 264 0002 71 0A F4                		add	#-12, r0, r10
 265                             	.LCFI3:
 266 0005 EF A0                   		mov.L	r10, r0
 267 0007 E3 A1                   		mov.L	r1, [r10]
 268 0009 E7 A2 01                		mov.L	r2, 4[r10]
 269 000c C7 A3 08                		mov.B	r3, 8[r10]
1369:../src/wolfcrypt/src/ecc.c ****     if (item) {
 270                             		.loc 2 1369 8
 271 000f ED A5 01                		mov.L	4[r10], r5
 272 0012 61 05                   		cmp	#0, r5
 273 0014 10                      		beq	.L5
1370:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_WOLF_BIGINT
1371:../src/wolfcrypt/src/ecc.c ****         wc_bigint_free(&item->raw);
1372:../src/wolfcrypt/src/ecc.c ****     #endif
1373:../src/wolfcrypt/src/ecc.c ****         mp_clear(item);
 274                             		.loc 2 1373 9
 275 0015 ED A1 01                		mov.L	4[r10], r1
 276 0018 05 00 00 00             		bsr	_sp_clear
 277                             	.L5:
1374:../src/wolfcrypt/src/ecc.c ****     }
1375:../src/wolfcrypt/src/ecc.c ****     curve->load_mask &= ~mask;
 278                             		.loc 2 1375 22
 279 001c EC A5                   		mov.L	[r10], r5
 280 001e CD 55 24                		mov.B	36[r5], r5
 281 0021 CF 54                   		mov.B	r5, r4
 282 0023 CD A5 08                		mov.B	8[r10], r5
 283 0026 7E 05                   		not	r5
 284 0028 53 45                   		and	r4, r5
 285 002a CF 54                   		mov.B	r5, r4
 286 002c EC A5                   		mov.L	[r10], r5
 287 002e C7 54 24                		mov.B	r4, 36[r5]
1376:../src/wolfcrypt/src/ecc.c **** }
 288                             		.loc 2 1376 1
 289 0031 03                      		nop
 290 0032 3F AA 04                		rtsd	#16, r10-r10
 291                             	.LFE43:
 293                             		.section	.text.wc_ecc_curve_cache_free_spec,"ax",@progbits
 295                             	_wc_ecc_curve_cache_free_spec:
 296                             	.LFB44:
1377:../src/wolfcrypt/src/ecc.c **** static void wc_ecc_curve_cache_free_spec(ecc_curve_spec* curve)
1378:../src/wolfcrypt/src/ecc.c **** {
 297                             		.loc 2 1378 1
 298 0000 7E AA                   		push.l	r10
 299                             	.LCFI4:
 300 0002 71 0A FC                		add	#-4, r0, r10
 301                             	.LCFI5:
 302 0005 EF A0                   		mov.L	r10, r0
 303 0007 E3 A1                   		mov.L	r1, [r10]
1379:../src/wolfcrypt/src/ecc.c ****     if (curve == NULL) {
 304                             		.loc 2 1379 8
 305 0009 EC A5                   		mov.L	[r10], r5
 306 000b 61 05                   		cmp	#0, r5
 307 000d 3A 96 00                		beq	.L14
1380:../src/wolfcrypt/src/ecc.c ****         return;
1381:../src/wolfcrypt/src/ecc.c ****     }
1382:../src/wolfcrypt/src/ecc.c **** 
1383:../src/wolfcrypt/src/ecc.c ****     if (curve->load_mask & ECC_CURVE_FIELD_PRIME)
 308                             		.loc 2 1383 14
 309 0010 EC A5                   		mov.L	[r10], r5
 310 0012 CD 55 24                		mov.B	36[r5], r5
 311                             		.loc 2 1383 26
 312 0015 5B 55                   		movu.B	r5, r5
 313 0017 64 15                   		and	#1, r5
 314                             		.loc 2 1383 8
 315 0019 61 05                   		cmp	#0, r5
 316 001b 20 10                   		beq	.L9
1384:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_cache_free_spec_item(curve, curve->prime, ECC_CURVE_FIELD_PRIME);
 317                             		.loc 2 1384 9
 318 001d EC A5                   		mov.L	[r10], r5
 319 001f A8 5D                   		mov.L	4[r5], r5
 320 0021 66 13                   		mov	#1, r3
 321 0023 EF 52                   		mov.L	r5, r2
 322 0025 EC A1                   		mov.L	[r10], r1
 323 0027 05 00 00 00             		bsr	_wc_ecc_curve_cache_free_spec_item
 324                             	.L9:
1385:../src/wolfcrypt/src/ecc.c ****     if (curve->load_mask & ECC_CURVE_FIELD_AF)
 325                             		.loc 2 1385 14
 326 002b EC A5                   		mov.L	[r10], r5
 327 002d CD 55 24                		mov.B	36[r5], r5
 328                             		.loc 2 1385 26
 329 0030 5B 55                   		movu.B	r5, r5
 330 0032 64 25                   		and	#2, r5
 331                             		.loc 2 1385 8
 332 0034 61 05                   		cmp	#0, r5
 333 0036 20 10                   		beq	.L10
1386:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_cache_free_spec_item(curve, curve->Af, ECC_CURVE_FIELD_AF);
 334                             		.loc 2 1386 9
 335 0038 EC A5                   		mov.L	[r10], r5
 336 003a A8 D5                   		mov.L	8[r5], r5
 337 003c 66 23                   		mov	#2, r3
 338 003e EF 52                   		mov.L	r5, r2
 339 0040 EC A1                   		mov.L	[r10], r1
 340 0042 05 00 00 00             		bsr	_wc_ecc_curve_cache_free_spec_item
 341                             	.L10:
1387:../src/wolfcrypt/src/ecc.c **** #ifdef USE_ECC_B_PARAM
1388:../src/wolfcrypt/src/ecc.c ****     if (curve->load_mask & ECC_CURVE_FIELD_BF)
1389:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_cache_free_spec_item(curve, curve->Bf, ECC_CURVE_FIELD_BF);
1390:../src/wolfcrypt/src/ecc.c **** #endif
1391:../src/wolfcrypt/src/ecc.c ****     if (curve->load_mask & ECC_CURVE_FIELD_ORDER)
 342                             		.loc 2 1391 14
 343 0046 EC A5                   		mov.L	[r10], r5
 344 0048 CD 55 24                		mov.B	36[r5], r5
 345                             		.loc 2 1391 26
 346 004b 5B 55                   		movu.B	r5, r5
 347 004d 64 85                   		and	#8, r5
 348                             		.loc 2 1391 8
 349 004f 61 05                   		cmp	#0, r5
 350 0051 20 10                   		beq	.L11
1392:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_cache_free_spec_item(curve, curve->order, ECC_CURVE_FIELD_ORDER);
 351                             		.loc 2 1392 9
 352 0053 EC A5                   		mov.L	[r10], r5
 353 0055 A8 DD                   		mov.L	12[r5], r5
 354 0057 66 83                   		mov	#8, r3
 355 0059 EF 52                   		mov.L	r5, r2
 356 005b EC A1                   		mov.L	[r10], r1
 357 005d 05 00 00 00             		bsr	_wc_ecc_curve_cache_free_spec_item
 358                             	.L11:
1393:../src/wolfcrypt/src/ecc.c ****     if (curve->load_mask & ECC_CURVE_FIELD_GX)
 359                             		.loc 2 1393 14
 360 0061 EC A5                   		mov.L	[r10], r5
 361 0063 CD 55 24                		mov.B	36[r5], r5
 362                             		.loc 2 1393 26
 363 0066 5B 55                   		movu.B	r5, r5
 364 0068 75 25 10                		and	#16, r5
 365                             		.loc 2 1393 8
 366 006b 61 05                   		cmp	#0, r5
 367 006d 20 11                   		beq	.L12
1394:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_cache_free_spec_item(curve, curve->Gx, ECC_CURVE_FIELD_GX);
 368                             		.loc 2 1394 9
 369 006f EC A5                   		mov.L	[r10], r5
 370 0071 A9 55                   		mov.L	16[r5], r5
 371 0073 75 43 10                		mov	#16, r3
 372 0076 EF 52                   		mov.L	r5, r2
 373 0078 EC A1                   		mov.L	[r10], r1
 374 007a 05 00 00 00             		bsr	_wc_ecc_curve_cache_free_spec_item
 375                             	.L12:
1395:../src/wolfcrypt/src/ecc.c ****     if (curve->load_mask & ECC_CURVE_FIELD_GY)
 376                             		.loc 2 1395 14
 377 007e EC A5                   		mov.L	[r10], r5
 378 0080 CD 55 24                		mov.B	36[r5], r5
 379                             		.loc 2 1395 26
 380 0083 5B 55                   		movu.B	r5, r5
 381 0085 75 25 20                		and	#32, r5
 382                             		.loc 2 1395 8
 383 0088 61 05                   		cmp	#0, r5
 384 008a 20 11                   		beq	.L13
1396:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_cache_free_spec_item(curve, curve->Gy, ECC_CURVE_FIELD_GY);
 385                             		.loc 2 1396 9
 386 008c EC A5                   		mov.L	[r10], r5
 387 008e A9 5D                   		mov.L	20[r5], r5
 388 0090 75 43 20                		mov	#32, r3
 389 0093 EF 52                   		mov.L	r5, r2
 390 0095 EC A1                   		mov.L	[r10], r1
 391 0097 05 00 00 00             		bsr	_wc_ecc_curve_cache_free_spec_item
 392                             	.L13:
1397:../src/wolfcrypt/src/ecc.c **** 
1398:../src/wolfcrypt/src/ecc.c ****     curve->load_mask = 0;
 393                             		.loc 2 1398 22
 394 009b EC A5                   		mov.L	[r10], r5
 395 009d F9 54 24 00             		mov.B	#0, 36[r5]
 396 00a1 2E 03                   		bra	.L6
 397                             	.L14:
1380:../src/wolfcrypt/src/ecc.c ****     }
 398                             		.loc 2 1380 9
 399 00a3 03                      		nop
 400                             	.L6:
1399:../src/wolfcrypt/src/ecc.c **** }
 401                             		.loc 2 1399 1
 402 00a4 3F AA 02                		rtsd	#8, r10-r10
 403                             	.LFE44:
 405                             		.section	.text.wc_ecc_curve_free,"ax",@progbits
 407                             	_wc_ecc_curve_free:
 408                             	.LFB45:
1400:../src/wolfcrypt/src/ecc.c **** 
1401:../src/wolfcrypt/src/ecc.c **** static void wc_ecc_curve_free(ecc_curve_spec* curve)
1402:../src/wolfcrypt/src/ecc.c **** {
 409                             		.loc 2 1402 1
 410 0000 7E AA                   		push.l	r10
 411                             	.LCFI6:
 412 0002 71 0A FC                		add	#-4, r0, r10
 413                             	.LCFI7:
 414 0005 EF A0                   		mov.L	r10, r0
 415 0007 E3 A1                   		mov.L	r1, [r10]
1403:../src/wolfcrypt/src/ecc.c ****     if (curve) {
 416                             		.loc 2 1403 8
 417 0009 EC A5                   		mov.L	[r10], r5
 418 000b 61 05                   		cmp	#0, r5
 419 000d 17                      		beq	.L17
1404:../src/wolfcrypt/src/ecc.c ****     #ifdef ECC_CACHE_CURVE
1405:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_CUSTOM_CURVES
1406:../src/wolfcrypt/src/ecc.c ****         /* only free custom curves (rest are globally cached) */
1407:../src/wolfcrypt/src/ecc.c ****         if (curve->dp && curve->dp->id == ECC_CURVE_CUSTOM) {
1408:../src/wolfcrypt/src/ecc.c ****             wc_ecc_curve_cache_free_spec(curve);
1409:../src/wolfcrypt/src/ecc.c ****             XFREE(curve, NULL, DYNAMIC_TYPE_ECC);
1410:../src/wolfcrypt/src/ecc.c ****         }
1411:../src/wolfcrypt/src/ecc.c ****         #endif
1412:../src/wolfcrypt/src/ecc.c ****     #else
1413:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_cache_free_spec(curve);
 420                             		.loc 2 1413 9
 421 000e EC A1                   		mov.L	[r10], r1
 422 0010 05 00 00 00             		bsr	_wc_ecc_curve_cache_free_spec
 423                             	.L17:
1414:../src/wolfcrypt/src/ecc.c ****     #endif
1415:../src/wolfcrypt/src/ecc.c ****     }
1416:../src/wolfcrypt/src/ecc.c **** }
 424                             		.loc 2 1416 1
 425 0014 03                      		nop
 426 0015 3F AA 02                		rtsd	#8, r10-r10
 427                             	.LFE45:
 429                             		.section C,"a",@progbits
 430 09d9 00 00 00                		.p2align 2
 431                             	.LC35:
 432 09dc 49 6E 76 61 6C 69 64 20 		.string	"Invalid DECLARE_CURVE_SPECS count"
 432      44 45 43 4C 41 52 45 5F 
 432      43 55 52 56 45 5F 53 50 
 432      45 43 53 20 63 6F 75 6E 
 432      74 00 
 433                             		.section	.text.wc_ecc_curve_cache_load_item,"ax",@progbits
 435                             	_wc_ecc_curve_cache_load_item:
 436                             	.LFB46:
1417:../src/wolfcrypt/src/ecc.c **** 
1418:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_curve_cache_load_item(ecc_curve_spec* curve, const char* src,
1419:../src/wolfcrypt/src/ecc.c ****     mp_int** dst, byte mask)
1420:../src/wolfcrypt/src/ecc.c **** {
 437                             		.loc 2 1420 1
 438 0000 7E AA                   		push.l	r10
 439                             	.LCFI8:
 440 0002 71 0A EC                		add	#-20, r0, r10
 441                             	.LCFI9:
 442 0005 EF A0                   		mov.L	r10, r0
 443 0007 E7 A1 01                		mov.L	r1, 4[r10]
 444 000a E7 A2 02                		mov.L	r2, 8[r10]
 445 000d E7 A3 03                		mov.L	r3, 12[r10]
 446 0010 C7 A4 10                		mov.B	r4, 16[r10]
1421:../src/wolfcrypt/src/ecc.c ****     int err;
1422:../src/wolfcrypt/src/ecc.c **** 
1423:../src/wolfcrypt/src/ecc.c **** #ifndef ECC_CACHE_CURVE
1424:../src/wolfcrypt/src/ecc.c ****     /* get mp_int from temp */
1425:../src/wolfcrypt/src/ecc.c ****     if (curve->spec_use >= curve->spec_count) {
 447                             		.loc 2 1425 14
 448 0013 ED A5 01                		mov.L	4[r10], r5
 449 0016 AA 54                   		mov.L	32[r5], r4
 450                             		.loc 2 1425 33
 451 0018 ED A5 01                		mov.L	4[r10], r5
 452 001b A9 DD                   		mov.L	28[r5], r5
 453                             		.loc 2 1425 8
 454 001d 47 54                   		cmp	r5, r4
 455 001f 23 12                   		bltu	.L19
1426:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("Invalid DECLARE_CURVE_SPECS count");
 456                             		.loc 2 1426 9
 457 0021 FB 12 DC 09 00 00       		mov.L	#.LC35, r1
 458 0027 05 00 00 00             		bsr	_WOLFSSL_MSG
1427:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 459                             		.loc 2 1427 16
 460 002b FB 5A 56 FF             		mov.L	#-170, r5
 461 002f 2E 5B                   		bra	.L20
 462                             	.L19:
1428:../src/wolfcrypt/src/ecc.c ****     }
1429:../src/wolfcrypt/src/ecc.c ****     *dst = &curve->spec_ints[curve->spec_use++];
 463                             		.loc 2 1429 18
 464 0031 ED A5 01                		mov.L	4[r10], r5
 465 0034 A9 D3                   		mov.L	24[r5], r3
 466                             		.loc 2 1429 35
 467 0036 ED A5 01                		mov.L	4[r10], r5
 468 0039 AA 55                   		mov.L	32[r5], r5
 469                             		.loc 2 1429 45
 470 003b 71 52 01                		add	#1, r5, r2
 471 003e ED A4 01                		mov.L	4[r10], r4
 472 0041 A2 42                   		mov.L	r2, 32[r4]
 473                             		.loc 2 1429 29
 474 0043 76 15 10 03             		mul	#0x310, r5
 475                             		.loc 2 1429 12
 476 0047 FF 24 53                		add	r5, r3, r4
 477                             		.loc 2 1429 10
 478 004a ED A5 03                		mov.L	12[r10], r5
 479 004d E3 54                   		mov.L	r4, [r5]
1430:../src/wolfcrypt/src/ecc.c **** #endif
1431:../src/wolfcrypt/src/ecc.c **** 
1432:../src/wolfcrypt/src/ecc.c ****     err = mp_init(*dst);
 480                             		.loc 2 1432 11
 481 004f ED A5 03                		mov.L	12[r10], r5
 482 0052 EC 55                   		mov.L	[r5], r5
 483 0054 EF 51                   		mov.L	r5, r1
 484 0056 05 00 00 00             		bsr	_sp_init
 485 005a E3 A1                   		mov.L	r1, [r10]
1433:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 486                             		.loc 2 1433 8
 487 005c EC A5                   		mov.L	[r10], r5
 488 005e 61 05                   		cmp	#0, r5
 489 0060 21 28                   		bne	.L21
1434:../src/wolfcrypt/src/ecc.c ****         curve->load_mask |= mask;
 490                             		.loc 2 1434 26
 491 0062 ED A5 01                		mov.L	4[r10], r5
 492 0065 CD 55 24                		mov.B	36[r5], r5
 493 0068 CD A4 10                		mov.B	16[r10], r4
 494 006b 57 45                   		or	r4, r5
 495 006d CF 54                   		mov.B	r5, r4
 496 006f ED A5 01                		mov.L	4[r10], r5
 497 0072 C7 54 24                		mov.B	r4, 36[r5]
1435:../src/wolfcrypt/src/ecc.c **** 
1436:../src/wolfcrypt/src/ecc.c ****         err = mp_read_radix(*dst, src, MP_RADIX_HEX);
 498                             		.loc 2 1436 15
 499 0075 ED A5 03                		mov.L	12[r10], r5
 500 0078 EC 55                   		mov.L	[r5], r5
 501 007a 75 43 10                		mov.L	#16, r3
 502 007d ED A2 02                		mov.L	8[r10], r2
 503 0080 EF 51                   		mov.L	r5, r1
 504 0082 05 00 00 00             		bsr	_sp_read_radix
 505 0086 E3 A1                   		mov.L	r1, [r10]
 506                             	.L21:
1437:../src/wolfcrypt/src/ecc.c **** 
1438:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_WOLF_BIGINT
1439:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
1440:../src/wolfcrypt/src/ecc.c ****             err = wc_mp_to_bigint(*dst, &(*dst)->raw);
1441:../src/wolfcrypt/src/ecc.c ****     #endif
1442:../src/wolfcrypt/src/ecc.c ****     }
1443:../src/wolfcrypt/src/ecc.c ****     return err;
 507                             		.loc 2 1443 12
 508 0088 EC A5                   		mov.L	[r10], r5
 509                             	.L20:
1444:../src/wolfcrypt/src/ecc.c **** }
 510                             		.loc 2 1444 1
 511 008a EF 51                   		mov.L	r5, r1
 512 008c 3F AA 06                		rtsd	#24, r10-r10
 513                             	.LFE46:
 515                             		.section	.text.wc_ecc_curve_load,"ax",@progbits
 517                             	_wc_ecc_curve_load:
 518                             	.LFB47:
1445:../src/wolfcrypt/src/ecc.c **** 
1446:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_curve_load(const ecc_set_type* dp, ecc_curve_spec** pCurve,
1447:../src/wolfcrypt/src/ecc.c ****     byte load_mask)
1448:../src/wolfcrypt/src/ecc.c **** {
 519                             		.loc 2 1448 1
 520 0000 7E AA                   		push.l	r10
 521                             	.LCFI10:
 522 0002 71 0A E8                		add	#-24, r0, r10
 523                             	.LCFI11:
 524 0005 EF A0                   		mov.L	r10, r0
 525 0007 E7 A1 03                		mov.L	r1, 12[r10]
 526 000a E7 A2 04                		mov.L	r2, 16[r10]
 527 000d C7 A3 14                		mov.B	r3, 20[r10]
1449:../src/wolfcrypt/src/ecc.c ****     int ret = 0;
 528                             		.loc 2 1449 9
 529 0010 F8 A6 00                		mov.L	#0, [r10]
1450:../src/wolfcrypt/src/ecc.c ****     ecc_curve_spec* curve;
1451:../src/wolfcrypt/src/ecc.c ****     byte load_items = 0; /* mask of items to load */
 530                             		.loc 2 1451 10
 531 0013 F9 A4 04 00             		mov.B	#0, 4[r10]
1452:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_CACHE_CURVE
1453:../src/wolfcrypt/src/ecc.c ****     int x;
1454:../src/wolfcrypt/src/ecc.c **** #endif
1455:../src/wolfcrypt/src/ecc.c **** 
1456:../src/wolfcrypt/src/ecc.c ****     if (dp == NULL || pCurve == NULL)
 532                             		.loc 2 1456 8
 533 0017 ED A5 03                		mov.L	12[r10], r5
 534 001a 61 05                   		cmp	#0, r5
 535 001c 17                      		beq	.L23
 536                             		.loc 2 1456 20 discriminator 1
 537 001d ED A5 04                		mov.L	16[r10], r5
 538 0020 61 05                   		cmp	#0, r5
 539 0022 18                      		bne	.L24
 540                             	.L23:
1457:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 541                             		.loc 2 1457 16
 542 0023 FB 5A 53 FF             		mov.L	#-173, r5
 543 0027 38 1E 01                		bra	.L25
 544                             	.L24:
1458:../src/wolfcrypt/src/ecc.c **** 
1459:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_CACHE_CURVE
1460:../src/wolfcrypt/src/ecc.c ****     x = wc_ecc_get_curve_idx(dp->id);
1461:../src/wolfcrypt/src/ecc.c ****     if (x == ECC_CURVE_INVALID)
1462:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
1463:../src/wolfcrypt/src/ecc.c **** 
1464:../src/wolfcrypt/src/ecc.c **** #if !defined(SINGLE_THREADED)
1465:../src/wolfcrypt/src/ecc.c ****     ret = wc_LockMutex(&ecc_curve_cache_mutex);
1466:../src/wolfcrypt/src/ecc.c ****     if (ret != 0) {
1467:../src/wolfcrypt/src/ecc.c ****         return ret;
1468:../src/wolfcrypt/src/ecc.c ****     }
1469:../src/wolfcrypt/src/ecc.c **** #endif
1470:../src/wolfcrypt/src/ecc.c **** 
1471:../src/wolfcrypt/src/ecc.c ****     /* make sure cache has been allocated */
1472:../src/wolfcrypt/src/ecc.c ****     if (ecc_curve_spec_cache[x] == NULL
1473:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_CUSTOM_CURVES
1474:../src/wolfcrypt/src/ecc.c ****         || dp->id == ECC_CURVE_CUSTOM
1475:../src/wolfcrypt/src/ecc.c ****     #endif
1476:../src/wolfcrypt/src/ecc.c ****     ) {
1477:../src/wolfcrypt/src/ecc.c ****         curve = (ecc_curve_spec*)XMALLOC(sizeof(ecc_curve_spec), NULL, DYNAMIC_TYPE_ECC);
1478:../src/wolfcrypt/src/ecc.c ****         if (curve == NULL) {
1479:../src/wolfcrypt/src/ecc.c ****         #if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)
1480:../src/wolfcrypt/src/ecc.c ****             wc_UnLockMutex(&ecc_curve_cache_mutex);
1481:../src/wolfcrypt/src/ecc.c ****         #endif
1482:../src/wolfcrypt/src/ecc.c ****             return MEMORY_E;
1483:../src/wolfcrypt/src/ecc.c ****         }
1484:../src/wolfcrypt/src/ecc.c ****         XMEMSET(curve, 0, sizeof(ecc_curve_spec));
1485:../src/wolfcrypt/src/ecc.c **** 
1486:../src/wolfcrypt/src/ecc.c ****         /* set curve pointer to cache */
1487:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_CUSTOM_CURVES
1488:../src/wolfcrypt/src/ecc.c ****         if (dp->id != ECC_CURVE_CUSTOM)
1489:../src/wolfcrypt/src/ecc.c ****     #endif
1490:../src/wolfcrypt/src/ecc.c ****         {
1491:../src/wolfcrypt/src/ecc.c ****             ecc_curve_spec_cache[x] = curve;
1492:../src/wolfcrypt/src/ecc.c ****         }
1493:../src/wolfcrypt/src/ecc.c ****     }
1494:../src/wolfcrypt/src/ecc.c ****     else {
1495:../src/wolfcrypt/src/ecc.c ****         curve = ecc_curve_spec_cache[x];
1496:../src/wolfcrypt/src/ecc.c ****     }
1497:../src/wolfcrypt/src/ecc.c ****     /* return new or cached curve */
1498:../src/wolfcrypt/src/ecc.c ****     *pCurve = curve;
1499:../src/wolfcrypt/src/ecc.c **** #else
1500:../src/wolfcrypt/src/ecc.c ****     curve = *pCurve;
 545                             		.loc 2 1500 11
 546 002a ED A5 04                		mov.L	16[r10], r5
 547 002d EC 55                   		mov.L	[r5], r5
 548 002f E7 A5 02                		mov.L	r5, 8[r10]
1501:../src/wolfcrypt/src/ecc.c **** #endif /* ECC_CACHE_CURVE */
1502:../src/wolfcrypt/src/ecc.c **** 
1503:../src/wolfcrypt/src/ecc.c ****     /* make sure the curve is initialized */
1504:../src/wolfcrypt/src/ecc.c ****     if (curve->dp != dp) {
 549                             		.loc 2 1504 14
 550 0032 ED A5 02                		mov.L	8[r10], r5
 551 0035 EC 55                   		mov.L	[r5], r5
 552                             		.loc 2 1504 8
 553 0037 ED A4 03                		mov.L	12[r10], r4
 554 003a 47 54                   		cmp	r5, r4
 555 003c 10                      		beq	.L26
1505:../src/wolfcrypt/src/ecc.c ****         curve->load_mask = 0;
 556                             		.loc 2 1505 26
 557 003d ED A5 02                		mov.L	8[r10], r5
 558 0040 F9 54 24 00             		mov.B	#0, 36[r5]
 559                             	.L26:
1506:../src/wolfcrypt/src/ecc.c **** 
1507:../src/wolfcrypt/src/ecc.c ****     #ifdef ECC_CACHE_CURVE
1508:../src/wolfcrypt/src/ecc.c ****         curve->prime = &curve->prime_lcl;
1509:../src/wolfcrypt/src/ecc.c ****         curve->Af = &curve->Af_lcl;
1510:../src/wolfcrypt/src/ecc.c ****         #ifdef USE_ECC_B_PARAM
1511:../src/wolfcrypt/src/ecc.c ****             curve->Bf = &curve->Bf_lcl;
1512:../src/wolfcrypt/src/ecc.c ****         #endif
1513:../src/wolfcrypt/src/ecc.c ****         curve->order = &curve->order_lcl;
1514:../src/wolfcrypt/src/ecc.c ****         curve->Gx = &curve->Gx_lcl;
1515:../src/wolfcrypt/src/ecc.c ****         curve->Gy = &curve->Gy_lcl;
1516:../src/wolfcrypt/src/ecc.c ****     #endif
1517:../src/wolfcrypt/src/ecc.c ****     }
1518:../src/wolfcrypt/src/ecc.c ****     curve->dp = dp; /* set dp info */
 560                             		.loc 2 1518 15
 561 0044 ED A5 02                		mov.L	8[r10], r5
 562 0047 ED A4 03                		mov.L	12[r10], r4
 563 004a E3 54                   		mov.L	r4, [r5]
1519:../src/wolfcrypt/src/ecc.c **** 
1520:../src/wolfcrypt/src/ecc.c ****     /* determine items to load */
1521:../src/wolfcrypt/src/ecc.c ****     load_items = (((byte)~(word32)curve->load_mask) & load_mask);
 564                             		.loc 2 1521 40
 565 004c ED A5 02                		mov.L	8[r10], r5
 566 004f CD 55 24                		mov.B	36[r5], r5
 567                             		.loc 2 1521 20
 568 0052 7E 05                   		not	r5
 569                             		.loc 2 1521 16
 570 0054 CD A4 14                		mov.B	20[r10], r4
 571 0057 53 45                   		and	r4, r5
 572 0059 C7 A5 04                		mov.B	r5, 4[r10]
1522:../src/wolfcrypt/src/ecc.c ****     curve->load_mask |= load_items;
 573                             		.loc 2 1522 22
 574 005c ED A5 02                		mov.L	8[r10], r5
 575 005f CD 55 24                		mov.B	36[r5], r5
 576 0062 CD A4 04                		mov.B	4[r10], r4
 577 0065 57 45                   		or	r4, r5
 578 0067 CF 54                   		mov.B	r5, r4
 579 0069 ED A5 02                		mov.L	8[r10], r5
 580 006c C7 54 24                		mov.B	r4, 36[r5]
1523:../src/wolfcrypt/src/ecc.c **** 
1524:../src/wolfcrypt/src/ecc.c ****     /* load items */
1525:../src/wolfcrypt/src/ecc.c ****     if (load_items & ECC_CURVE_FIELD_PRIME)
 581                             		.loc 2 1525 20
 582 006f 59 A5 04                		movu.B	4[r10], r5
 583 0072 64 15                   		and	#1, r5
 584                             		.loc 2 1525 8
 585 0074 61 05                   		cmp	#0, r5
 586 0076 20 1F                   		beq	.L27
1526:../src/wolfcrypt/src/ecc.c ****         ret += wc_ecc_curve_cache_load_item(curve, dp->prime, &curve->prime,
 587                             		.loc 2 1526 16
 588 0078 ED A5 03                		mov.L	12[r10], r5
 589 007b A8 DA                   		mov.L	12[r5], r2
 590 007d ED A5 02                		mov.L	8[r10], r5
 591 0080 62 45                   		add	#4, r5
 592 0082 66 14                   		mov	#1, r4
 593 0084 EF 53                   		mov.L	r5, r3
 594 0086 ED A1 02                		mov.L	8[r10], r1
 595 0089 05 00 00 00             		bsr	_wc_ecc_curve_cache_load_item
 596 008d EF 15                   		mov.L	r1, r5
 597                             		.loc 2 1526 13
 598 008f EC A4                   		mov.L	[r10], r4
 599 0091 4B 45                   		add	r4, r5
 600 0093 E3 A5                   		mov.L	r5, [r10]
 601                             	.L27:
1527:../src/wolfcrypt/src/ecc.c ****             ECC_CURVE_FIELD_PRIME);
1528:../src/wolfcrypt/src/ecc.c ****     if (load_items & ECC_CURVE_FIELD_AF)
 602                             		.loc 2 1528 20
 603 0095 59 A5 04                		movu.B	4[r10], r5
 604 0098 64 25                   		and	#2, r5
 605                             		.loc 2 1528 8
 606 009a 61 05                   		cmp	#0, r5
 607 009c 20 1F                   		beq	.L28
1529:../src/wolfcrypt/src/ecc.c ****         ret += wc_ecc_curve_cache_load_item(curve, dp->Af, &curve->Af,
 608                             		.loc 2 1529 16
 609 009e ED A5 03                		mov.L	12[r10], r5
 610 00a1 A9 52                   		mov.L	16[r5], r2
 611 00a3 ED A5 02                		mov.L	8[r10], r5
 612 00a6 62 85                   		add	#8, r5
 613 00a8 66 24                   		mov	#2, r4
 614 00aa EF 53                   		mov.L	r5, r3
 615 00ac ED A1 02                		mov.L	8[r10], r1
 616 00af 05 00 00 00             		bsr	_wc_ecc_curve_cache_load_item
 617 00b3 EF 15                   		mov.L	r1, r5
 618                             		.loc 2 1529 13
 619 00b5 EC A4                   		mov.L	[r10], r4
 620 00b7 4B 45                   		add	r4, r5
 621 00b9 E3 A5                   		mov.L	r5, [r10]
 622                             	.L28:
1530:../src/wolfcrypt/src/ecc.c ****             ECC_CURVE_FIELD_AF);
1531:../src/wolfcrypt/src/ecc.c **** #ifdef USE_ECC_B_PARAM
1532:../src/wolfcrypt/src/ecc.c ****     if (load_items & ECC_CURVE_FIELD_BF)
1533:../src/wolfcrypt/src/ecc.c ****         ret += wc_ecc_curve_cache_load_item(curve, dp->Bf, &curve->Bf,
1534:../src/wolfcrypt/src/ecc.c ****             ECC_CURVE_FIELD_BF);
1535:../src/wolfcrypt/src/ecc.c **** #endif
1536:../src/wolfcrypt/src/ecc.c ****     if (load_items & ECC_CURVE_FIELD_ORDER)
 623                             		.loc 2 1536 20
 624 00bb 59 A5 04                		movu.B	4[r10], r5
 625 00be 64 85                   		and	#8, r5
 626                             		.loc 2 1536 8
 627 00c0 61 05                   		cmp	#0, r5
 628 00c2 20 1F                   		beq	.L29
1537:../src/wolfcrypt/src/ecc.c ****         ret += wc_ecc_curve_cache_load_item(curve, dp->order, &curve->order,
 629                             		.loc 2 1537 16
 630 00c4 ED A5 03                		mov.L	12[r10], r5
 631 00c7 A9 D2                   		mov.L	24[r5], r2
 632 00c9 ED A5 02                		mov.L	8[r10], r5
 633 00cc 62 C5                   		add	#12, r5
 634 00ce 66 84                   		mov	#8, r4
 635 00d0 EF 53                   		mov.L	r5, r3
 636 00d2 ED A1 02                		mov.L	8[r10], r1
 637 00d5 05 00 00 00             		bsr	_wc_ecc_curve_cache_load_item
 638 00d9 EF 15                   		mov.L	r1, r5
 639                             		.loc 2 1537 13
 640 00db EC A4                   		mov.L	[r10], r4
 641 00dd 4B 45                   		add	r4, r5
 642 00df E3 A5                   		mov.L	r5, [r10]
 643                             	.L29:
1538:../src/wolfcrypt/src/ecc.c ****             ECC_CURVE_FIELD_ORDER);
1539:../src/wolfcrypt/src/ecc.c ****     if (load_items & ECC_CURVE_FIELD_GX)
 644                             		.loc 2 1539 20
 645 00e1 59 A5 04                		movu.B	4[r10], r5
 646 00e4 75 25 10                		and	#16, r5
 647                             		.loc 2 1539 8
 648 00e7 61 05                   		cmp	#0, r5
 649 00e9 20 21                   		beq	.L30
1540:../src/wolfcrypt/src/ecc.c ****         ret += wc_ecc_curve_cache_load_item(curve, dp->Gx, &curve->Gx,
 650                             		.loc 2 1540 16
 651 00eb ED A5 03                		mov.L	12[r10], r5
 652 00ee A9 DA                   		mov.L	28[r5], r2
 653 00f0 ED A5 02                		mov.L	8[r10], r5
 654 00f3 71 55 10                		add	#16, r5
 655 00f6 75 44 10                		mov	#16, r4
 656 00f9 EF 53                   		mov.L	r5, r3
 657 00fb ED A1 02                		mov.L	8[r10], r1
 658 00fe 05 00 00 00             		bsr	_wc_ecc_curve_cache_load_item
 659 0102 EF 15                   		mov.L	r1, r5
 660                             		.loc 2 1540 13
 661 0104 EC A4                   		mov.L	[r10], r4
 662 0106 4B 45                   		add	r4, r5
 663 0108 E3 A5                   		mov.L	r5, [r10]
 664                             	.L30:
1541:../src/wolfcrypt/src/ecc.c ****             ECC_CURVE_FIELD_GX);
1542:../src/wolfcrypt/src/ecc.c ****     if (load_items & ECC_CURVE_FIELD_GY)
 665                             		.loc 2 1542 20
 666 010a 59 A5 04                		movu.B	4[r10], r5
 667 010d 75 25 20                		and	#32, r5
 668                             		.loc 2 1542 8
 669 0110 61 05                   		cmp	#0, r5
 670 0112 20 21                   		beq	.L31
1543:../src/wolfcrypt/src/ecc.c ****         ret += wc_ecc_curve_cache_load_item(curve, dp->Gy, &curve->Gy,
 671                             		.loc 2 1543 16
 672 0114 ED A5 03                		mov.L	12[r10], r5
 673 0117 AA 52                   		mov.L	32[r5], r2
 674 0119 ED A5 02                		mov.L	8[r10], r5
 675 011c 71 55 14                		add	#20, r5
 676 011f 75 44 20                		mov	#32, r4
 677 0122 EF 53                   		mov.L	r5, r3
 678 0124 ED A1 02                		mov.L	8[r10], r1
 679 0127 05 00 00 00             		bsr	_wc_ecc_curve_cache_load_item
 680 012b EF 15                   		mov.L	r1, r5
 681                             		.loc 2 1543 13
 682 012d EC A4                   		mov.L	[r10], r4
 683 012f 4B 45                   		add	r4, r5
 684 0131 E3 A5                   		mov.L	r5, [r10]
 685                             	.L31:
1544:../src/wolfcrypt/src/ecc.c ****             ECC_CURVE_FIELD_GY);
1545:../src/wolfcrypt/src/ecc.c **** 
1546:../src/wolfcrypt/src/ecc.c ****     /* check for error */
1547:../src/wolfcrypt/src/ecc.c ****     if (ret != 0) {
 686                             		.loc 2 1547 8
 687 0133 EC A5                   		mov.L	[r10], r5
 688 0135 61 05                   		cmp	#0, r5
 689 0137 20 0C                   		beq	.L32
1548:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_free(curve);
 690                             		.loc 2 1548 9
 691 0139 ED A1 02                		mov.L	8[r10], r1
 692 013c 05 00 00 00             		bsr	_wc_ecc_curve_free
1549:../src/wolfcrypt/src/ecc.c ****         ret = MP_READ_E;
 693                             		.loc 2 1549 13
 694 0140 F8 A6 91                		mov.L	#-111, [r10]
 695                             	.L32:
1550:../src/wolfcrypt/src/ecc.c ****     }
1551:../src/wolfcrypt/src/ecc.c **** 
1552:../src/wolfcrypt/src/ecc.c **** #if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)
1553:../src/wolfcrypt/src/ecc.c ****     wc_UnLockMutex(&ecc_curve_cache_mutex);
1554:../src/wolfcrypt/src/ecc.c **** #endif
1555:../src/wolfcrypt/src/ecc.c **** 
1556:../src/wolfcrypt/src/ecc.c ****     return ret;
 696                             		.loc 2 1556 12
 697 0143 EC A5                   		mov.L	[r10], r5
 698                             	.L25:
1557:../src/wolfcrypt/src/ecc.c **** }
 699                             		.loc 2 1557 1
 700 0145 EF 51                   		mov.L	r5, r1
 701 0147 3F AA 07                		rtsd	#28, r10-r10
 702                             	.LFE47:
 704                             		.section	.text.wc_ecc_get_name,"ax",@progbits
 705                             		.global	_wc_ecc_get_name
 707                             	_wc_ecc_get_name:
 708                             	.LFB48:
1558:../src/wolfcrypt/src/ecc.c **** 
1559:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_CACHE_CURVE
1560:../src/wolfcrypt/src/ecc.c **** int wc_ecc_curve_cache_init(void)
1561:../src/wolfcrypt/src/ecc.c **** {
1562:../src/wolfcrypt/src/ecc.c ****     int ret = 0;
1563:../src/wolfcrypt/src/ecc.c **** #if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)
1564:../src/wolfcrypt/src/ecc.c ****     ret = wc_InitMutex(&ecc_curve_cache_mutex);
1565:../src/wolfcrypt/src/ecc.c **** #endif
1566:../src/wolfcrypt/src/ecc.c ****     return ret;
1567:../src/wolfcrypt/src/ecc.c **** }
1568:../src/wolfcrypt/src/ecc.c **** 
1569:../src/wolfcrypt/src/ecc.c **** void wc_ecc_curve_cache_free(void)
1570:../src/wolfcrypt/src/ecc.c **** {
1571:../src/wolfcrypt/src/ecc.c ****     int x;
1572:../src/wolfcrypt/src/ecc.c **** 
1573:../src/wolfcrypt/src/ecc.c ****     /* free all ECC curve caches */
1574:../src/wolfcrypt/src/ecc.c ****     for (x = 0; x < (int)ECC_SET_COUNT; x++) {
1575:../src/wolfcrypt/src/ecc.c ****         if (ecc_curve_spec_cache[x]) {
1576:../src/wolfcrypt/src/ecc.c ****             wc_ecc_curve_cache_free_spec(ecc_curve_spec_cache[x]);
1577:../src/wolfcrypt/src/ecc.c ****             XFREE(ecc_curve_spec_cache[x], NULL, DYNAMIC_TYPE_ECC);
1578:../src/wolfcrypt/src/ecc.c ****             ecc_curve_spec_cache[x] = NULL;
1579:../src/wolfcrypt/src/ecc.c ****         }
1580:../src/wolfcrypt/src/ecc.c ****     }
1581:../src/wolfcrypt/src/ecc.c **** 
1582:../src/wolfcrypt/src/ecc.c **** #if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)
1583:../src/wolfcrypt/src/ecc.c ****     wc_FreeMutex(&ecc_curve_cache_mutex);
1584:../src/wolfcrypt/src/ecc.c **** #endif
1585:../src/wolfcrypt/src/ecc.c **** }
1586:../src/wolfcrypt/src/ecc.c **** #endif /* ECC_CACHE_CURVE */
1587:../src/wolfcrypt/src/ecc.c **** 
1588:../src/wolfcrypt/src/ecc.c **** 
1589:../src/wolfcrypt/src/ecc.c **** /* Retrieve the curve name for the ECC curve id.
1590:../src/wolfcrypt/src/ecc.c ****  *
1591:../src/wolfcrypt/src/ecc.c ****  * curve_id  The id of the curve.
1592:../src/wolfcrypt/src/ecc.c ****  * returns the name stored from the curve if available, otherwise NULL.
1593:../src/wolfcrypt/src/ecc.c ****  */
1594:../src/wolfcrypt/src/ecc.c **** const char* wc_ecc_get_name(int curve_id)
1595:../src/wolfcrypt/src/ecc.c **** {
 709                             		.loc 2 1595 1
 710 0000 7E AA                   		push.l	r10
 711                             	.LCFI12:
 712 0002 71 0A F8                		add	#-8, r0, r10
 713                             	.LCFI13:
 714 0005 EF A0                   		mov.L	r10, r0
 715 0007 E7 A1 01                		mov.L	r1, 4[r10]
1596:../src/wolfcrypt/src/ecc.c ****     int curve_idx = wc_ecc_get_curve_idx(curve_id);
 716                             		.loc 2 1596 21
 717 000a ED A1 01                		mov.L	4[r10], r1
 718 000d 05 00 00 00             		bsr	_wc_ecc_get_curve_idx
 719 0011 E3 A1                   		mov.L	r1, [r10]
1597:../src/wolfcrypt/src/ecc.c ****     if (curve_idx == ECC_CURVE_INVALID)
 720                             		.loc 2 1597 8
 721 0013 EC A5                   		mov.L	[r10], r5
 722 0015 75 05 FF                		cmp	#-1, r5
 723 0018 1D                      		bne	.L34
1598:../src/wolfcrypt/src/ecc.c ****         return NULL;
 724                             		.loc 2 1598 16
 725 0019 66 05                   		mov.L	#0, r5
 726 001b 2E 13                   		bra	.L35
 727                             	.L34:
1599:../src/wolfcrypt/src/ecc.c ****     return ecc_sets[curve_idx].name;
 728                             		.loc 2 1599 31
 729 001d FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 730 0023 EC A5                   		mov.L	[r10], r5
 731 0025 75 15 34                		mul	#52, r5
 732 0028 4B 45                   		add	r4, r5
 733 002a 62 85                   		add	#8, r5
 734 002c EC 55                   		mov.L	[r5], r5
 735                             	.L35:
1600:../src/wolfcrypt/src/ecc.c **** }
 736                             		.loc 2 1600 1
 737 002e EF 51                   		mov.L	r5, r1
 738 0030 3F AA 03                		rtsd	#12, r10-r10
 739                             	.LFE48:
 741                             		.section C,"a",@progbits
 742 09fe 00 00                   		.p2align 2
 743                             	.LC36:
 744 0a00 45 43 43 20 43 75 72 76 		.string	"ECC Curve not found"
 744      65 20 6E 6F 74 20 66 6F 
 744      75 6E 64 00 
 745                             		.section	.text.wc_ecc_set_curve,"ax",@progbits
 746                             		.global	_wc_ecc_set_curve
 748                             	_wc_ecc_set_curve:
 749                             	.LFB49:
1601:../src/wolfcrypt/src/ecc.c **** 
1602:../src/wolfcrypt/src/ecc.c **** int wc_ecc_set_curve(ecc_key* key, int keysize, int curve_id)
1603:../src/wolfcrypt/src/ecc.c **** {
 750                             		.loc 2 1603 1
 751 0000 7E AA                   		push.l	r10
 752                             	.LCFI14:
 753 0002 71 0A F0                		add	#-16, r0, r10
 754                             	.LCFI15:
 755 0005 EF A0                   		mov.L	r10, r0
 756 0007 E7 A1 01                		mov.L	r1, 4[r10]
 757 000a E7 A2 02                		mov.L	r2, 8[r10]
 758 000d E7 A3 03                		mov.L	r3, 12[r10]
1604:../src/wolfcrypt/src/ecc.c ****     if (key == NULL || (keysize <= 0 && curve_id < 0)) {
 759                             		.loc 2 1604 8
 760 0010 ED A5 01                		mov.L	4[r10], r5
 761 0013 61 05                   		cmp	#0, r5
 762 0015 20 10                   		beq	.L37
 763                             		.loc 2 1604 21 discriminator 1
 764 0017 ED A5 02                		mov.L	8[r10], r5
 765 001a 61 05                   		cmp	#0, r5
 766 001c 2A 10                   		bgt	.L38
 767                             		.loc 2 1604 38 discriminator 2
 768 001e ED A5 03                		mov.L	12[r10], r5
 769 0021 61 05                   		cmp	#0, r5
 770 0023 28 09                   		bge	.L38
 771                             	.L37:
1605:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 772                             		.loc 2 1605 16
 773 0025 FB 5A 53 FF             		mov.L	#-173, r5
 774 0029 38 BD 00                		bra	.L39
 775                             	.L38:
1606:../src/wolfcrypt/src/ecc.c ****     }
1607:../src/wolfcrypt/src/ecc.c **** 
1608:../src/wolfcrypt/src/ecc.c ****     if (keysize > ECC_MAXSIZE) {
 776                             		.loc 2 1608 8
 777 002c ED A5 02                		mov.L	8[r10], r5
 778 002f 75 55 42                		cmp	#0x42, r5
 779 0032 2B 09                   		ble	.L40
1609:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 780                             		.loc 2 1609 16
 781 0034 FB 5A 56 FF             		mov.L	#-170, r5
 782 0038 38 AE 00                		bra	.L39
 783                             	.L40:
1610:../src/wolfcrypt/src/ecc.c ****     }
1611:../src/wolfcrypt/src/ecc.c **** 
1612:../src/wolfcrypt/src/ecc.c ****     /* handle custom case */
1613:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX) {
 784                             		.loc 2 1613 12
 785 003b ED A5 01                		mov.L	4[r10], r5
 786 003e A8 5D                   		mov.L	4[r5], r5
 787                             		.loc 2 1613 8
 788 0040 75 05 FF                		cmp	#-1, r5
 789 0043 3A A1 00                		beq	.L41
 790                             	.LBB2:
1614:../src/wolfcrypt/src/ecc.c ****         int x;
1615:../src/wolfcrypt/src/ecc.c **** 
1616:../src/wolfcrypt/src/ecc.c ****         /* default values */
1617:../src/wolfcrypt/src/ecc.c ****         key->idx = 0;
 791                             		.loc 2 1617 18
 792 0046 ED A5 01                		mov.L	4[r10], r5
 793 0049 3E 51 00                		mov.L	#0, 4[r5]
1618:../src/wolfcrypt/src/ecc.c ****         key->dp = NULL;
 794                             		.loc 2 1618 17
 795 004c ED A5 01                		mov.L	4[r10], r5
 796 004f 3E 54 00                		mov.L	#0, 16[r5]
1619:../src/wolfcrypt/src/ecc.c **** 
1620:../src/wolfcrypt/src/ecc.c ****         /* find ecc_set based on curve_id or key size */
1621:../src/wolfcrypt/src/ecc.c ****         for (x = 0; ecc_sets[x].size != 0; x++) {
 797                             		.loc 2 1621 16
 798 0052 F8 A6 00                		mov.L	#0, [r10]
 799                             		.loc 2 1621 9
 800 0055 2E 3F                   		bra	.L42
 801                             	.L46:
1622:../src/wolfcrypt/src/ecc.c ****             if (curve_id > ECC_CURVE_DEF) {
 802                             		.loc 2 1622 16
 803 0057 ED A5 03                		mov.L	12[r10], r5
 804 005a 61 05                   		cmp	#0, r5
 805 005c 2B 1C                   		ble	.L43
1623:../src/wolfcrypt/src/ecc.c ****                 if (curve_id == ecc_sets[x].id)
 806                             		.loc 2 1623 44
 807 005e FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 808 0064 EC A5                   		mov.L	[r10], r5
 809 0066 75 15 34                		mul	#52, r5
 810 0069 4B 45                   		add	r4, r5
 811 006b 62 45                   		add	#4, r5
 812 006d EC 55                   		mov.L	[r5], r5
 813                             		.loc 2 1623 20
 814 006f ED A4 03                		mov.L	12[r10], r4
 815 0072 47 54                   		cmp	r5, r4
 816 0074 21 1A                   		bne	.L44
1624:../src/wolfcrypt/src/ecc.c ****                   break;
 817                             		.loc 2 1624 19
 818 0076 2E 34                   		bra	.L45
 819                             	.L43:
1625:../src/wolfcrypt/src/ecc.c ****             }
1626:../src/wolfcrypt/src/ecc.c ****             else if (keysize <= ecc_sets[x].size) {
 820                             		.loc 2 1626 44
 821 0078 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 822 007e EC A5                   		mov.L	[r10], r5
 823 0080 75 15 34                		mul	#52, r5
 824 0083 4B 45                   		add	r4, r5
 825 0085 EC 55                   		mov.L	[r5], r5
 826                             		.loc 2 1626 21
 827 0087 ED A4 02                		mov.L	8[r10], r4
 828 008a 47 54                   		cmp	r5, r4
 829 008c 2B 1D                   		ble	.L48
 830                             	.L44:
1621:../src/wolfcrypt/src/ecc.c ****             if (curve_id > ECC_CURVE_DEF) {
 831                             		.loc 2 1621 45 discriminator 2
 832 008e EC A5                   		mov.L	[r10], r5
 833 0090 62 15                   		add	#1, r5
 834 0092 E3 A5                   		mov.L	r5, [r10]
 835                             	.L42:
1621:../src/wolfcrypt/src/ecc.c ****             if (curve_id > ECC_CURVE_DEF) {
 836                             		.loc 2 1621 32 discriminator 1
 837 0094 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 838 009a EC A5                   		mov.L	[r10], r5
 839 009c 75 15 34                		mul	#52, r5
 840 009f 4B 45                   		add	r4, r5
 841 00a1 EC 55                   		mov.L	[r5], r5
1621:../src/wolfcrypt/src/ecc.c ****             if (curve_id > ECC_CURVE_DEF) {
 842                             		.loc 2 1621 9 discriminator 1
 843 00a3 61 05                   		cmp	#0, r5
 844 00a5 21 B2                   		bne	.L46
 845 00a7 2E 03                   		bra	.L45
 846                             	.L48:
1627:../src/wolfcrypt/src/ecc.c ****                 break;
 847                             		.loc 2 1627 17
 848 00a9 03                      		nop
 849                             	.L45:
1628:../src/wolfcrypt/src/ecc.c ****             }
1629:../src/wolfcrypt/src/ecc.c ****         }
1630:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[x].size == 0) {
 850                             		.loc 2 1630 24
 851 00aa FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 852 00b0 EC A5                   		mov.L	[r10], r5
 853 00b2 75 15 34                		mul	#52, r5
 854 00b5 4B 45                   		add	r4, r5
 855 00b7 EC 55                   		mov.L	[r5], r5
 856                             		.loc 2 1630 12
 857 00b9 61 05                   		cmp	#0, r5
 858 00bb 21 12                   		bne	.L47
1631:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("ECC Curve not found");
 859                             		.loc 2 1631 13
 860 00bd FB 12 00 0A 00 00       		mov.L	#.LC36, r1
 861 00c3 05 00 00 00             		bsr	_WOLFSSL_MSG
1632:../src/wolfcrypt/src/ecc.c ****             return ECC_CURVE_OID_E;
 862                             		.loc 2 1632 20
 863 00c7 FB 5A 54 FF             		mov.L	#-172, r5
 864 00cb 2E 1B                   		bra	.L39
 865                             	.L47:
1633:../src/wolfcrypt/src/ecc.c ****         }
1634:../src/wolfcrypt/src/ecc.c **** 
1635:../src/wolfcrypt/src/ecc.c ****         key->idx = x;
 866                             		.loc 2 1635 18
 867 00cd ED A5 01                		mov.L	4[r10], r5
 868 00d0 EC A4                   		mov.L	[r10], r4
 869 00d2 A0 5C                   		mov.L	r4, 4[r5]
1636:../src/wolfcrypt/src/ecc.c ****         key->dp  = &ecc_sets[x];
 870                             		.loc 2 1636 20
 871 00d4 EC A5                   		mov.L	[r10], r5
 872 00d6 75 15 34                		mul	#52, r5
 873 00d9 70 54 00 00 00 00       		add	#_ecc_sets, r5, r4
 874                             		.loc 2 1636 18
 875 00df ED A5 01                		mov.L	4[r10], r5
 876 00e2 A1 54                   		mov.L	r4, 16[r5]
 877                             	.L41:
 878                             	.LBE2:
1637:../src/wolfcrypt/src/ecc.c ****     }
1638:../src/wolfcrypt/src/ecc.c **** 
1639:../src/wolfcrypt/src/ecc.c ****     return 0;
 879                             		.loc 2 1639 12
 880 00e4 66 05                   		mov.L	#0, r5
 881                             		.balign 8,3,1
 882                             	.L39:
1640:../src/wolfcrypt/src/ecc.c **** }
 883                             		.loc 2 1640 1
 884 00e6 EF 51                   		mov.L	r5, r1
 885 00e8 3F AA 05                		rtsd	#20, r10-r10
 886                             	.LFE49:
 888 00eb 77 10 01 00 00          		.section	.text._ecc_projective_add_point,"ax",@progbits
 890                             	__ecc_projective_add_point:
 891                             	.LFB50:
1641:../src/wolfcrypt/src/ecc.c **** 
1642:../src/wolfcrypt/src/ecc.c **** 
1643:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
1644:../src/wolfcrypt/src/ecc.c **** static void alt_fp_init(mp_int* a)
1645:../src/wolfcrypt/src/ecc.c **** {
1646:../src/wolfcrypt/src/ecc.c ****     a->size = FP_SIZE_ECC;
1647:../src/wolfcrypt/src/ecc.c ****     mp_zero(a);
1648:../src/wolfcrypt/src/ecc.c **** }
1649:../src/wolfcrypt/src/ecc.c **** #endif /* ALT_ECC_SIZE */
1650:../src/wolfcrypt/src/ecc.c **** 
1651:../src/wolfcrypt/src/ecc.c **** 
1652:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
1653:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLF_CRYPTO_CB_ONLY_ECC)
1654:../src/wolfcrypt/src/ecc.c **** 
1655:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_PUBLIC_ECC_ADD_DBL)
1656:../src/wolfcrypt/src/ecc.c **** static int _ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,
1657:../src/wolfcrypt/src/ecc.c ****                                      mp_int* modulus, mp_digit mp);
1658:../src/wolfcrypt/src/ecc.c **** 
1659:../src/wolfcrypt/src/ecc.c **** /**
1660:../src/wolfcrypt/src/ecc.c ****    Add two ECC points
1661:../src/wolfcrypt/src/ecc.c ****    P        The point to add
1662:../src/wolfcrypt/src/ecc.c ****    Q        The point to add
1663:../src/wolfcrypt/src/ecc.c ****    R        [out] The destination of the double
1664:../src/wolfcrypt/src/ecc.c ****    a        ECC curve parameter a
1665:../src/wolfcrypt/src/ecc.c ****    modulus  The modulus of the field the ECC curve is in
1666:../src/wolfcrypt/src/ecc.c ****    mp       The "b" value from montgomery_setup()
1667:../src/wolfcrypt/src/ecc.c ****    return   MP_OKAY on success
1668:../src/wolfcrypt/src/ecc.c **** */
1669:../src/wolfcrypt/src/ecc.c **** static int _ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,
1670:../src/wolfcrypt/src/ecc.c ****                                      mp_int* a, mp_int* modulus, mp_digit mp)
1671:../src/wolfcrypt/src/ecc.c **** {
 892                             		.loc 2 1671 1
 893 0000 7E AA                   		push.l	r10
 894                             	.LCFI16:
 895 0002 7E A6                   		push.l	r6
 896                             	.LCFI17:
 897 0004 71 0A AC                		add	#-84, r0, r10
 898                             	.LCFI18:
 899 0007 71 A0 F8                		add	#-8, r10, r0
 900                             	.LCFI19:
 901 000a 75 46 60                		mov.L	#0x60, r6
 902 000d 4B A6                   		add	r10, r6
 903 000f E7 A1 0F                		mov.L	r1, 60[r10]
 904 0012 E7 A2 10                		mov.L	r2, 64[r10]
 905 0015 E7 A3 11                		mov.L	r3, 68[r10]
 906 0018 E7 A4 12                		mov.L	r4, 72[r10]
1672:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
1673:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
1674:../src/wolfcrypt/src/ecc.c ****    mp_int* t1 = NULL;
 907                             		.loc 2 1674 12
 908 001b F9 A6 01 00             		mov.L	#0, 4[r10]
1675:../src/wolfcrypt/src/ecc.c ****    mp_int* t2 = NULL;
 909                             		.loc 2 1675 12
 910 001f F9 A6 02 00             		mov.L	#0, 8[r10]
1676:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
1677:../src/wolfcrypt/src/ecc.c ****    mp_int* rx = NULL;
1678:../src/wolfcrypt/src/ecc.c ****    mp_int* ry = NULL;
1679:../src/wolfcrypt/src/ecc.c ****    mp_int* rz = NULL;
1680:../src/wolfcrypt/src/ecc.c **** #endif
1681:../src/wolfcrypt/src/ecc.c **** #else
1682:../src/wolfcrypt/src/ecc.c ****    mp_int  t1[1], t2[1];
1683:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
1684:../src/wolfcrypt/src/ecc.c ****    mp_int  rx[1], ry[1], rz[1];
1685:../src/wolfcrypt/src/ecc.c **** #endif
1686:../src/wolfcrypt/src/ecc.c **** #endif
1687:../src/wolfcrypt/src/ecc.c ****    mp_int  *x, *y, *z;
1688:../src/wolfcrypt/src/ecc.c ****    int     err;
1689:../src/wolfcrypt/src/ecc.c **** 
1690:../src/wolfcrypt/src/ecc.c ****    /* if Q == R then swap P and Q, so we don't require a local x,y,z */
1691:../src/wolfcrypt/src/ecc.c ****    if (Q == R) {
 911                             		.loc 2 1691 7
 912 0023 ED A4 10                		mov.L	64[r10], r4
 913 0026 ED A5 11                		mov.L	68[r10], r5
 914 0029 47 54                   		cmp	r5, r4
 915 002b 21 14                   		bne	.L50
 916                             	.LBB3:
1692:../src/wolfcrypt/src/ecc.c ****       ecc_point* tPt  = P;
 917                             		.loc 2 1692 18
 918 002d ED A5 0F                		mov.L	60[r10], r5
 919 0030 E7 A5 03                		mov.L	r5, 12[r10]
1693:../src/wolfcrypt/src/ecc.c ****       P = Q;
 920                             		.loc 2 1693 9
 921 0033 ED A5 10                		mov.L	64[r10], r5
 922 0036 E7 A5 0F                		mov.L	r5, 60[r10]
1694:../src/wolfcrypt/src/ecc.c ****       Q = tPt;
 923                             		.loc 2 1694 9
 924 0039 ED A5 03                		mov.L	12[r10], r5
 925 003c E7 A5 10                		mov.L	r5, 64[r10]
 926                             	.L50:
 927                             	.LBE3:
1695:../src/wolfcrypt/src/ecc.c ****    }
1696:../src/wolfcrypt/src/ecc.c **** 
1697:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
1698:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
1699:../src/wolfcrypt/src/ecc.c ****    if (R->key != NULL) {
1700:../src/wolfcrypt/src/ecc.c ****        t1 = R->key->t1;
1701:../src/wolfcrypt/src/ecc.c ****        t2 = R->key->t2;
1702:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
1703:../src/wolfcrypt/src/ecc.c ****        rx = R->key->x;
1704:../src/wolfcrypt/src/ecc.c ****        ry = R->key->y;
1705:../src/wolfcrypt/src/ecc.c ****        rz = R->key->z;
1706:../src/wolfcrypt/src/ecc.c **** #endif
1707:../src/wolfcrypt/src/ecc.c ****    }
1708:../src/wolfcrypt/src/ecc.c ****    else
1709:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK_CACHE */
1710:../src/wolfcrypt/src/ecc.c ****    {
1711:../src/wolfcrypt/src/ecc.c ****        t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 928                             		.loc 2 1711 22
 929 003f FB 1A 10 03             		mov.L	#0x310, r1
 930 0043 05 00 00 00             		bsr	_wolfSSL_Malloc
 931 0047 E7 A1 01                		mov.L	r1, 4[r10]
1712:../src/wolfcrypt/src/ecc.c ****        t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 932                             		.loc 2 1712 22
 933 004a FB 1A 10 03             		mov.L	#0x310, r1
 934 004e 05 00 00 00             		bsr	_wolfSSL_Malloc
 935 0052 E7 A1 02                		mov.L	r1, 8[r10]
1713:../src/wolfcrypt/src/ecc.c ****        if (t1 == NULL || t2 == NULL) {
 936                             		.loc 2 1713 11
 937 0055 ED A5 01                		mov.L	4[r10], r5
 938 0058 61 05                   		cmp	#0, r5
 939 005a 10                      		beq	.L51
 940                             		.loc 2 1713 23 discriminator 1
 941 005b ED A5 02                		mov.L	8[r10], r5
 942 005e 61 05                   		cmp	#0, r5
 943 0060 21 2E                   		bne	.L52
 944                             	.L51:
 945                             	.LBB4:
1714:../src/wolfcrypt/src/ecc.c ****            XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 946                             		.loc 2 1714 12
 947 0062 ED A5 01                		mov.L	4[r10], r5
 948 0065 E7 A5 0D                		mov.L	r5, 52[r10]
 949 0068 ED A5 0D                		mov.L	52[r10], r5
 950 006b 61 05                   		cmp	#0, r5
 951 006d 10                      		beq	.L53
 952                             		.loc 2 1714 12 is_stmt 0 discriminator 1
 953 006e ED A1 0D                		mov.L	52[r10], r1
 954 0071 05 00 00 00             		bsr	_wolfSSL_Free
 955                             	.L53:
 956                             	.LBE4:
 957                             	.LBB5:
1715:../src/wolfcrypt/src/ecc.c ****            XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 958                             		.loc 2 1715 12 is_stmt 1
 959 0075 ED A5 02                		mov.L	8[r10], r5
 960 0078 E7 A5 0E                		mov.L	r5, 56[r10]
 961 007b ED A5 0E                		mov.L	56[r10], r5
 962 007e 61 05                   		cmp	#0, r5
 963 0080 10                      		beq	.L54
 964                             		.loc 2 1715 12 is_stmt 0 discriminator 1
 965 0081 ED A1 0E                		mov.L	56[r10], r1
 966 0084 05 00 00 00             		bsr	_wolfSSL_Free
 967                             	.L54:
 968                             	.LBE5:
1716:../src/wolfcrypt/src/ecc.c ****            return MEMORY_E;
 969                             		.loc 2 1716 19 is_stmt 1
 970 0088 FB 56 83                		mov.L	#-125, r5
 971 008b 38 72 05                		bra	.L55
 972                             	.L52:
1717:../src/wolfcrypt/src/ecc.c ****        }
1718:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
1719:../src/wolfcrypt/src/ecc.c ****        rx = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
1720:../src/wolfcrypt/src/ecc.c ****        ry = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
1721:../src/wolfcrypt/src/ecc.c ****        rz = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
1722:../src/wolfcrypt/src/ecc.c ****        if (rx == NULL || ry == NULL || rz == NULL) {
1723:../src/wolfcrypt/src/ecc.c ****            XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
1724:../src/wolfcrypt/src/ecc.c ****            XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
1725:../src/wolfcrypt/src/ecc.c ****            XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
1726:../src/wolfcrypt/src/ecc.c ****            XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
1727:../src/wolfcrypt/src/ecc.c ****            XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
1728:../src/wolfcrypt/src/ecc.c ****            return MEMORY_E;
1729:../src/wolfcrypt/src/ecc.c ****        }
1730:../src/wolfcrypt/src/ecc.c **** #endif
1731:../src/wolfcrypt/src/ecc.c ****    }
1732:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK */
1733:../src/wolfcrypt/src/ecc.c **** 
1734:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {
 973                             		.loc 2 1734 15
 974 008e 3E 01 00                		mov.L	#0, 4[r0]
 975 0091 F8 06 00                		mov.L	#0, [r0]
 976 0094 66 04                   		mov.L	#0, r4
 977 0096 66 03                   		mov.L	#0, r3
 978 0098 ED A2 02                		mov.L	8[r10], r2
 979 009b ED A1 01                		mov.L	4[r10], r1
 980 009e 05 00 00 00             		bsr	_sp_init_multi
 981 00a2 E3 A1                   		mov.L	r1, [r10]
 982                             		.loc 2 1734 7
 983 00a4 EC A5                   		mov.L	[r10], r5
 984 00a6 61 05                   		cmp	#0, r5
 985 00a8 20 2D                   		beq	.L56
 986                             	.LBB6:
1735:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
1736:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_SMALL_STACK_CACHE
1737:../src/wolfcrypt/src/ecc.c ****        if (R->key == NULL)
1738:../src/wolfcrypt/src/ecc.c ****    #endif
1739:../src/wolfcrypt/src/ecc.c ****        {
1740:../src/wolfcrypt/src/ecc.c ****        #ifdef ALT_ECC_SIZE
1741:../src/wolfcrypt/src/ecc.c ****           XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
1742:../src/wolfcrypt/src/ecc.c ****           XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
1743:../src/wolfcrypt/src/ecc.c ****           XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
1744:../src/wolfcrypt/src/ecc.c ****        #endif
1745:../src/wolfcrypt/src/ecc.c ****           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 987                             		.loc 2 1745 11
 988 00aa ED A5 02                		mov.L	8[r10], r5
 989 00ad E7 A5 04                		mov.L	r5, 16[r10]
 990 00b0 ED A5 04                		mov.L	16[r10], r5
 991 00b3 61 05                   		cmp	#0, r5
 992 00b5 10                      		beq	.L57
 993                             		.loc 2 1745 11 is_stmt 0 discriminator 1
 994 00b6 ED A1 04                		mov.L	16[r10], r1
 995 00b9 05 00 00 00             		bsr	_wolfSSL_Free
 996                             	.L57:
 997                             	.LBE6:
 998                             	.LBB7:
1746:../src/wolfcrypt/src/ecc.c ****           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 999                             		.loc 2 1746 11 is_stmt 1
 1000 00bd ED A5 01                		mov.L	4[r10], r5
 1001 00c0 E7 A5 05                		mov.L	r5, 20[r10]
 1002 00c3 ED A5 05                		mov.L	20[r10], r5
 1003 00c6 61 05                   		cmp	#0, r5
 1004 00c8 10                      		beq	.L58
 1005                             		.loc 2 1746 11 is_stmt 0 discriminator 1
 1006 00c9 ED A1 05                		mov.L	20[r10], r1
 1007 00cc 05 00 00 00             		bsr	_wolfSSL_Free
 1008                             	.L58:
 1009                             	.LBE7:
1747:../src/wolfcrypt/src/ecc.c ****        }
1748:../src/wolfcrypt/src/ecc.c **** #endif
1749:../src/wolfcrypt/src/ecc.c ****       return err;
 1010                             		.loc 2 1749 14 is_stmt 1
 1011 00d0 EC A5                   		mov.L	[r10], r5
 1012 00d2 38 2B 05                		bra	.L55
 1013                             	.L56:
1750:../src/wolfcrypt/src/ecc.c ****    }
1751:../src/wolfcrypt/src/ecc.c **** 
1752:../src/wolfcrypt/src/ecc.c ****    /* should we dbl instead? */
1753:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 1014                             		.loc 2 1753 7
 1015 00d5 EC A5                   		mov.L	[r10], r5
 1016 00d7 61 05                   		cmp	#0, r5
 1017 00d9 21 18                   		bne	.L59
1754:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
1755:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(modulus, Q->y, modulus, t1);
 1018                             		.loc 2 1755 37
 1019 00db ED A5 10                		mov.L	64[r10], r5
 1020 00de 72 55 10 03             		add	#0x310, r5
 1021                             		.loc 2 1755 14
 1022 00e2 ED A4 01                		mov.L	4[r10], r4
 1023 00e5 EC 63                   		mov.L	[r6], r3
 1024 00e7 EF 52                   		mov.L	r5, r2
 1025 00e9 EC 61                   		mov.L	[r6], r1
 1026 00eb 05 00 00 00             		bsr	_sp_submod_ct
 1027 00ef E3 A1                   		mov.L	r1, [r10]
 1028                             	.L59:
1756:../src/wolfcrypt/src/ecc.c **** #else
1757:../src/wolfcrypt/src/ecc.c ****        err = mp_sub(modulus, Q->y, t1);
1758:../src/wolfcrypt/src/ecc.c **** #endif
1759:../src/wolfcrypt/src/ecc.c ****    }
1760:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 1029                             		.loc 2 1760 7
 1030 00f1 EC A5                   		mov.L	[r10], r5
 1031 00f3 61 05                   		cmp	#0, r5
 1032 00f5 3B C7 00                		bne	.L60
1761:../src/wolfcrypt/src/ecc.c ****        if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
 1033                             		.loc 2 1761 22
 1034 00f8 ED A5 0F                		mov.L	60[r10], r5
 1035                             		.loc 2 1761 28
 1036 00fb ED A4 10                		mov.L	64[r10], r4
 1037                             		.loc 2 1761 14
 1038 00fe EF 42                   		mov.L	r4, r2
 1039 0100 EF 51                   		mov.L	r5, r1
 1040 0102 05 00 00 00             		bsr	_sp_cmp
 1041 0106 EF 15                   		mov.L	r1, r5
 1042                             		.loc 2 1761 11
 1043 0108 61 05                   		cmp	#0, r5
 1044 010a 3B B2 00                		bne	.L60
1762:../src/wolfcrypt/src/ecc.c ****             (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 1045                             		.loc 2 1762 31 discriminator 1
 1046 010d ED A5 10                		mov.L	64[r10], r5
 1047 0110 72 55 20 06             		add	#0x620, r5
 1048                             		.loc 2 1762 14 discriminator 1
 1049 0114 EF 51                   		mov.L	r5, r1
 1050 0116 05 00 00 00             		bsr	_get_digit_count
 1051 011a EF 15                   		mov.L	r1, r5
1761:../src/wolfcrypt/src/ecc.c ****        if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
 1052                             		.loc 2 1761 43 discriminator 1
 1053 011c 61 05                   		cmp	#0, r5
 1054 011e 3A 9E 00                		beq	.L60
 1055                             		.loc 2 1762 47
 1056 0121 ED A5 0F                		mov.L	60[r10], r5
 1057 0124 72 54 20 06             		add	#0x620, r5, r4
 1058                             		.loc 2 1762 53
 1059 0128 ED A5 10                		mov.L	64[r10], r5
 1060 012b 72 55 20 06             		add	#0x620, r5
 1061                             		.loc 2 1762 39
 1062 012f EF 52                   		mov.L	r5, r2
 1063 0131 EF 41                   		mov.L	r4, r1
 1064 0133 05 00 00 00             		bsr	_sp_cmp
 1065 0137 EF 15                   		mov.L	r1, r5
 1066                             		.loc 2 1762 36
 1067 0139 61 05                   		cmp	#0, r5
 1068 013b 3B 81 00                		bne	.L60
1763:../src/wolfcrypt/src/ecc.c ****             (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {
 1069                             		.loc 2 1763 22 discriminator 1
 1070 013e ED A5 0F                		mov.L	60[r10], r5
 1071 0141 72 54 10 03             		add	#0x310, r5, r4
 1072                             		.loc 2 1763 28 discriminator 1
 1073 0145 ED A5 10                		mov.L	64[r10], r5
 1074 0148 72 55 10 03             		add	#0x310, r5
 1075                             		.loc 2 1763 14 discriminator 1
 1076 014c EF 52                   		mov.L	r5, r2
 1077 014e EF 41                   		mov.L	r4, r1
 1078 0150 05 00 00 00             		bsr	_sp_cmp
 1079 0154 EF 15                   		mov.L	r1, r5
1762:../src/wolfcrypt/src/ecc.c ****             (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 1080                             		.loc 2 1762 68 discriminator 1
 1081 0156 61 05                   		cmp	#0, r5
 1082 0158 20 18                   		beq	.L61
 1083                             		.loc 2 1763 53
 1084 015a ED A5 0F                		mov.L	60[r10], r5
 1085 015d 72 55 10 03             		add	#0x310, r5
 1086                             		.loc 2 1763 45
 1087 0161 ED A2 01                		mov.L	4[r10], r2
 1088 0164 EF 51                   		mov.L	r5, r1
 1089 0166 05 00 00 00             		bsr	_sp_cmp
 1090 016a EF 15                   		mov.L	r1, r5
 1091                             		.loc 2 1763 42
 1092 016c 61 05                   		cmp	#0, r5
 1093 016e 21 4E                   		bne	.L60
 1094                             	.L61:
1764:../src/wolfcrypt/src/ecc.c ****            mp_clear(t1);
 1095                             		.loc 2 1764 12
 1096 0170 ED A1 01                		mov.L	4[r10], r1
 1097 0173 05 00 00 00             		bsr	_sp_clear
1765:../src/wolfcrypt/src/ecc.c ****            mp_clear(t2);
 1098                             		.loc 2 1765 12
 1099 0177 ED A1 02                		mov.L	8[r10], r1
 1100 017a 05 00 00 00             		bsr	_sp_clear
 1101                             	.LBB8:
1766:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
1767:../src/wolfcrypt/src/ecc.c ****        #ifdef WOLFSSL_SMALL_STACK_CACHE
1768:../src/wolfcrypt/src/ecc.c ****            if (R->key == NULL)
1769:../src/wolfcrypt/src/ecc.c ****        #endif
1770:../src/wolfcrypt/src/ecc.c ****            {
1771:../src/wolfcrypt/src/ecc.c ****             #ifdef ALT_ECC_SIZE
1772:../src/wolfcrypt/src/ecc.c ****                XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
1773:../src/wolfcrypt/src/ecc.c ****                XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
1774:../src/wolfcrypt/src/ecc.c ****                XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
1775:../src/wolfcrypt/src/ecc.c ****             #endif
1776:../src/wolfcrypt/src/ecc.c ****                XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 1102                             		.loc 2 1776 16
 1103 017e ED A5 02                		mov.L	8[r10], r5
 1104 0181 E7 A5 06                		mov.L	r5, 24[r10]
 1105 0184 ED A5 06                		mov.L	24[r10], r5
 1106 0187 61 05                   		cmp	#0, r5
 1107 0189 10                      		beq	.L62
 1108                             		.loc 2 1776 16 is_stmt 0 discriminator 1
 1109 018a ED A1 06                		mov.L	24[r10], r1
 1110 018d 05 00 00 00             		bsr	_wolfSSL_Free
 1111                             	.L62:
 1112                             	.LBE8:
 1113                             	.LBB9:
1777:../src/wolfcrypt/src/ecc.c ****                XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 1114                             		.loc 2 1777 16 is_stmt 1
 1115 0191 ED A5 01                		mov.L	4[r10], r5
 1116 0194 E7 A5 07                		mov.L	r5, 28[r10]
 1117 0197 ED A5 07                		mov.L	28[r10], r5
 1118 019a 61 05                   		cmp	#0, r5
 1119 019c 10                      		beq	.L63
 1120                             		.loc 2 1777 16 is_stmt 0 discriminator 1
 1121 019d ED A1 07                		mov.L	28[r10], r1
 1122 01a0 05 00 00 00             		bsr	_wolfSSL_Free
 1123                             	.L63:
 1124                             	.LBE9:
1778:../src/wolfcrypt/src/ecc.c ****            }
1779:../src/wolfcrypt/src/ecc.c ****         #endif
1780:../src/wolfcrypt/src/ecc.c ****           return _ecc_projective_dbl_point(P, R, a, modulus, mp);
 1125                             		.loc 2 1780 18 is_stmt 1
 1126 01a4 A8 6D                   		mov.L	4[r6], r5
 1127 01a6 E3 05                   		mov.L	r5, [r0]
 1128 01a8 EC 64                   		mov.L	[r6], r4
 1129 01aa ED A3 12                		mov.L	72[r10], r3
 1130 01ad ED A2 11                		mov.L	68[r10], r2
 1131 01b0 ED A1 0F                		mov.L	60[r10], r1
 1132 01b3 05 00 00 00             		bsr	__ecc_projective_dbl_point
 1133 01b7 EF 15                   		mov.L	r1, r5
 1134 01b9 38 44 04                		bra	.L55
 1135                             	.L60:
1781:../src/wolfcrypt/src/ecc.c ****        }
1782:../src/wolfcrypt/src/ecc.c ****    }
1783:../src/wolfcrypt/src/ecc.c **** 
1784:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY) {
 1136                             		.loc 2 1784 7
 1137 01bc EC A5                   		mov.L	[r10], r5
 1138 01be 61 05                   		cmp	#0, r5
 1139 01c0 3B 03 04                		bne	.L111
1785:../src/wolfcrypt/src/ecc.c ****       goto done;
1786:../src/wolfcrypt/src/ecc.c ****    }
1787:../src/wolfcrypt/src/ecc.c **** 
1788:../src/wolfcrypt/src/ecc.c **** /* If use ALT_ECC_SIZE we need to use local stack variable since
1789:../src/wolfcrypt/src/ecc.c ****    ecc_point x,y,z is reduced size */
1790:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
1791:../src/wolfcrypt/src/ecc.c ****    /* Use local stack variable */
1792:../src/wolfcrypt/src/ecc.c ****    x = rx;
1793:../src/wolfcrypt/src/ecc.c ****    y = ry;
1794:../src/wolfcrypt/src/ecc.c ****    z = rz;
1795:../src/wolfcrypt/src/ecc.c **** 
1796:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_init_multi(x, y, z, NULL, NULL, NULL)) != MP_OKAY) {
1797:../src/wolfcrypt/src/ecc.c ****       goto done;
1798:../src/wolfcrypt/src/ecc.c ****    }
1799:../src/wolfcrypt/src/ecc.c **** #else
1800:../src/wolfcrypt/src/ecc.c ****    /* Use destination directly */
1801:../src/wolfcrypt/src/ecc.c ****    x = R->x;
 1140                             		.loc 2 1801 6
 1141 01c3 ED A5 11                		mov.L	68[r10], r5
 1142 01c6 E7 A5 08                		mov.L	r5, 32[r10]
1802:../src/wolfcrypt/src/ecc.c ****    y = R->y;
 1143                             		.loc 2 1802 6
 1144 01c9 ED A5 11                		mov.L	68[r10], r5
 1145 01cc 72 55 10 03             		add	#0x310, r5
 1146 01d0 E7 A5 09                		mov.L	r5, 36[r10]
1803:../src/wolfcrypt/src/ecc.c ****    z = R->z;
 1147                             		.loc 2 1803 6
 1148 01d3 ED A5 11                		mov.L	68[r10], r5
 1149 01d6 72 55 20 06             		add	#0x620, r5
 1150 01da E7 A5 0A                		mov.L	r5, 40[r10]
1804:../src/wolfcrypt/src/ecc.c **** #endif
1805:../src/wolfcrypt/src/ecc.c **** 
1806:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1151                             		.loc 2 1806 7
 1152 01dd EC A5                   		mov.L	[r10], r5
 1153 01df 61 05                   		cmp	#0, r5
 1154 01e1 21 10                   		bne	.L66
1807:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(P->x, x);
 1155                             		.loc 2 1807 23
 1156 01e3 ED A5 0F                		mov.L	60[r10], r5
 1157                             		.loc 2 1807 14
 1158 01e6 ED A2 08                		mov.L	32[r10], r2
 1159 01e9 EF 51                   		mov.L	r5, r1
 1160 01eb 05 00 00 00             		bsr	_sp_copy
 1161 01ef E3 A1                   		mov.L	r1, [r10]
 1162                             	.L66:
1808:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1163                             		.loc 2 1808 7
 1164 01f1 EC A5                   		mov.L	[r10], r5
 1165 01f3 61 05                   		cmp	#0, r5
 1166 01f5 21 14                   		bne	.L67
1809:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(P->y, y);
 1167                             		.loc 2 1809 23
 1168 01f7 ED A5 0F                		mov.L	60[r10], r5
 1169 01fa 72 55 10 03             		add	#0x310, r5
 1170                             		.loc 2 1809 14
 1171 01fe ED A2 09                		mov.L	36[r10], r2
 1172 0201 EF 51                   		mov.L	r5, r1
 1173 0203 05 00 00 00             		bsr	_sp_copy
 1174 0207 E3 A1                   		mov.L	r1, [r10]
 1175                             	.L67:
1810:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1176                             		.loc 2 1810 7
 1177 0209 EC A5                   		mov.L	[r10], r5
 1178 020b 61 05                   		cmp	#0, r5
 1179 020d 21 14                   		bne	.L68
1811:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(P->z, z);
 1180                             		.loc 2 1811 23
 1181 020f ED A5 0F                		mov.L	60[r10], r5
 1182 0212 72 55 20 06             		add	#0x620, r5
 1183                             		.loc 2 1811 14
 1184 0216 ED A2 0A                		mov.L	40[r10], r2
 1185 0219 EF 51                   		mov.L	r5, r1
 1186 021b 05 00 00 00             		bsr	_sp_copy
 1187 021f E3 A1                   		mov.L	r1, [r10]
 1188                             	.L68:
1812:../src/wolfcrypt/src/ecc.c **** 
1813:../src/wolfcrypt/src/ecc.c ****    /* if Z is one then these are no-operations */
1814:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 1189                             		.loc 2 1814 7
 1190 0221 EC A5                   		mov.L	[r10], r5
 1191 0223 61 05                   		cmp	#0, r5
 1192 0225 3B B3 00                		bne	.L69
1815:../src/wolfcrypt/src/ecc.c ****        if (!mp_iszero(Q->z)) {
 1193                             		.loc 2 1815 13
 1194 0228 ED A5 10                		mov.L	64[r10], r5
 1195 022b EE 55 88 01             		mov.L	1568[r5], r5
 1196                             		.loc 2 1815 11
 1197 022f 61 05                   		cmp	#0, r5
 1198 0231 3A A7 00                		beq	.L69
1816:../src/wolfcrypt/src/ecc.c ****            /* T1 = Z' * Z' */
1817:../src/wolfcrypt/src/ecc.c ****            err = mp_sqr(Q->z, t1);
 1199                             		.loc 2 1817 26
 1200 0234 ED A5 10                		mov.L	64[r10], r5
 1201 0237 72 55 20 06             		add	#0x620, r5
 1202                             		.loc 2 1817 18
 1203 023b ED A2 01                		mov.L	4[r10], r2
 1204 023e EF 51                   		mov.L	r5, r1
 1205 0240 05 00 00 00             		bsr	_sp_sqr
 1206 0244 E3 A1                   		mov.L	r1, [r10]
1818:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 1207                             		.loc 2 1818 15
 1208 0246 EC A5                   		mov.L	[r10], r5
 1209 0248 61 05                   		cmp	#0, r5
 1210 024a 21 0F                   		bne	.L70
1819:../src/wolfcrypt/src/ecc.c ****                err = mp_montgomery_reduce(t1, modulus, mp);
 1211                             		.loc 2 1819 22
 1212 024c A8 6B                   		mov.L	4[r6], r3
 1213 024e EC 62                   		mov.L	[r6], r2
 1214 0250 ED A1 01                		mov.L	4[r10], r1
 1215 0253 05 00 00 00             		bsr	_sp_mont_red
 1216 0257 E3 A1                   		mov.L	r1, [r10]
 1217                             	.L70:
1820:../src/wolfcrypt/src/ecc.c **** 
1821:../src/wolfcrypt/src/ecc.c ****            /* X = X * T1 */
1822:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 1218                             		.loc 2 1822 15
 1219 0259 EC A5                   		mov.L	[r10], r5
 1220 025b 61 05                   		cmp	#0, r5
 1221 025d 21 11                   		bne	.L71
1823:../src/wolfcrypt/src/ecc.c ****                err = mp_mul(t1, x, x);
 1222                             		.loc 2 1823 22
 1223 025f ED A3 08                		mov.L	32[r10], r3
 1224 0262 ED A2 08                		mov.L	32[r10], r2
 1225 0265 ED A1 01                		mov.L	4[r10], r1
 1226 0268 05 00 00 00             		bsr	_sp_mul
 1227 026c E3 A1                   		mov.L	r1, [r10]
 1228                             	.L71:
1824:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 1229                             		.loc 2 1824 15
 1230 026e EC A5                   		mov.L	[r10], r5
 1231 0270 61 05                   		cmp	#0, r5
 1232 0272 21 0F                   		bne	.L72
1825:../src/wolfcrypt/src/ecc.c ****                err = mp_montgomery_reduce(x, modulus, mp);
 1233                             		.loc 2 1825 22
 1234 0274 A8 6B                   		mov.L	4[r6], r3
 1235 0276 EC 62                   		mov.L	[r6], r2
 1236 0278 ED A1 08                		mov.L	32[r10], r1
 1237 027b 05 00 00 00             		bsr	_sp_mont_red
 1238 027f E3 A1                   		mov.L	r1, [r10]
 1239                             	.L72:
1826:../src/wolfcrypt/src/ecc.c **** 
1827:../src/wolfcrypt/src/ecc.c ****            /* T1 = Z' * T1 */
1828:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 1240                             		.loc 2 1828 15
 1241 0281 EC A5                   		mov.L	[r10], r5
 1242 0283 61 05                   		cmp	#0, r5
 1243 0285 21 17                   		bne	.L73
1829:../src/wolfcrypt/src/ecc.c ****                err = mp_mul(Q->z, t1, t1);
 1244                             		.loc 2 1829 30
 1245 0287 ED A5 10                		mov.L	64[r10], r5
 1246 028a 72 55 20 06             		add	#0x620, r5
 1247                             		.loc 2 1829 22
 1248 028e ED A3 01                		mov.L	4[r10], r3
 1249 0291 ED A2 01                		mov.L	4[r10], r2
 1250 0294 EF 51                   		mov.L	r5, r1
 1251 0296 05 00 00 00             		bsr	_sp_mul
 1252 029a E3 A1                   		mov.L	r1, [r10]
 1253                             	.L73:
1830:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 1254                             		.loc 2 1830 15
 1255 029c EC A5                   		mov.L	[r10], r5
 1256 029e 61 05                   		cmp	#0, r5
 1257 02a0 21 0F                   		bne	.L74
1831:../src/wolfcrypt/src/ecc.c ****                err = mp_montgomery_reduce(t1, modulus, mp);
 1258                             		.loc 2 1831 22
 1259 02a2 A8 6B                   		mov.L	4[r6], r3
 1260 02a4 EC 62                   		mov.L	[r6], r2
 1261 02a6 ED A1 01                		mov.L	4[r10], r1
 1262 02a9 05 00 00 00             		bsr	_sp_mont_red
 1263 02ad E3 A1                   		mov.L	r1, [r10]
 1264                             	.L74:
1832:../src/wolfcrypt/src/ecc.c **** 
1833:../src/wolfcrypt/src/ecc.c ****            /* Y = Y * T1 */
1834:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 1265                             		.loc 2 1834 15
 1266 02af EC A5                   		mov.L	[r10], r5
 1267 02b1 61 05                   		cmp	#0, r5
 1268 02b3 21 11                   		bne	.L75
1835:../src/wolfcrypt/src/ecc.c ****                err = mp_mul(t1, y, y);
 1269                             		.loc 2 1835 22
 1270 02b5 ED A3 09                		mov.L	36[r10], r3
 1271 02b8 ED A2 09                		mov.L	36[r10], r2
 1272 02bb ED A1 01                		mov.L	4[r10], r1
 1273 02be 05 00 00 00             		bsr	_sp_mul
 1274 02c2 E3 A1                   		mov.L	r1, [r10]
 1275                             	.L75:
1836:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 1276                             		.loc 2 1836 15
 1277 02c4 EC A5                   		mov.L	[r10], r5
 1278 02c6 61 05                   		cmp	#0, r5
 1279 02c8 21 10                   		bne	.L69
1837:../src/wolfcrypt/src/ecc.c ****                err = mp_montgomery_reduce(y, modulus, mp);
 1280                             		.loc 2 1837 22
 1281 02ca A8 6B                   		mov.L	4[r6], r3
 1282 02cc EC 62                   		mov.L	[r6], r2
 1283 02ce ED A1 09                		mov.L	36[r10], r1
 1284 02d1 05 00 00 00             		bsr	_sp_mont_red
 1285 02d5 E3 A1                   		mov.L	r1, [r10]
 1286 02d7 03                      		.balign 8,3,1
 1287                             	.L69:
1838:../src/wolfcrypt/src/ecc.c ****        }
1839:../src/wolfcrypt/src/ecc.c ****    }
1840:../src/wolfcrypt/src/ecc.c **** 
1841:../src/wolfcrypt/src/ecc.c ****    /* T1 = Z*Z */
1842:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1288                             		.loc 2 1842 7
 1289 02d8 EC A5                   		mov.L	[r10], r5
 1290 02da 61 05                   		cmp	#0, r5
 1291 02dc 21 0E                   		bne	.L76
1843:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(z, t1);
 1292                             		.loc 2 1843 14
 1293 02de ED A2 01                		mov.L	4[r10], r2
 1294 02e1 ED A1 0A                		mov.L	40[r10], r1
 1295 02e4 05 00 00 00             		bsr	_sp_sqr
 1296 02e8 E3 A1                   		mov.L	r1, [r10]
 1297                             	.L76:
1844:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1298                             		.loc 2 1844 7
 1299 02ea EC A5                   		mov.L	[r10], r5
 1300 02ec 61 05                   		cmp	#0, r5
 1301 02ee 21 0F                   		bne	.L77
1845:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t1, modulus, mp);
 1302                             		.loc 2 1845 14
 1303 02f0 A8 6B                   		mov.L	4[r6], r3
 1304 02f2 EC 62                   		mov.L	[r6], r2
 1305 02f4 ED A1 01                		mov.L	4[r10], r1
 1306 02f7 05 00 00 00             		bsr	_sp_mont_red
 1307 02fb E3 A1                   		mov.L	r1, [r10]
 1308                             	.L77:
1846:../src/wolfcrypt/src/ecc.c **** 
1847:../src/wolfcrypt/src/ecc.c ****    /* T2 = X' * T1 */
1848:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1309                             		.loc 2 1848 7
 1310 02fd EC A5                   		mov.L	[r10], r5
 1311 02ff 61 05                   		cmp	#0, r5
 1312 0301 21 13                   		bne	.L78
1849:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(Q->x, t1, t2);
 1313                             		.loc 2 1849 22
 1314 0303 ED A5 10                		mov.L	64[r10], r5
 1315                             		.loc 2 1849 14
 1316 0306 ED A3 02                		mov.L	8[r10], r3
 1317 0309 ED A2 01                		mov.L	4[r10], r2
 1318 030c EF 51                   		mov.L	r5, r1
 1319 030e 05 00 00 00             		bsr	_sp_mul
 1320 0312 E3 A1                   		mov.L	r1, [r10]
 1321                             	.L78:
1850:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1322                             		.loc 2 1850 7
 1323 0314 EC A5                   		mov.L	[r10], r5
 1324 0316 61 05                   		cmp	#0, r5
 1325 0318 21 0F                   		bne	.L79
1851:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t2, modulus, mp);
 1326                             		.loc 2 1851 14
 1327 031a A8 6B                   		mov.L	4[r6], r3
 1328 031c EC 62                   		mov.L	[r6], r2
 1329 031e ED A1 02                		mov.L	8[r10], r1
 1330 0321 05 00 00 00             		bsr	_sp_mont_red
 1331 0325 E3 A1                   		mov.L	r1, [r10]
 1332                             	.L79:
1852:../src/wolfcrypt/src/ecc.c **** 
1853:../src/wolfcrypt/src/ecc.c ****    /* T1 = Z * T1 */
1854:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1333                             		.loc 2 1854 7
 1334 0327 EC A5                   		mov.L	[r10], r5
 1335 0329 61 05                   		cmp	#0, r5
 1336 032b 21 11                   		bne	.L80
1855:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(z, t1, t1);
 1337                             		.loc 2 1855 14
 1338 032d ED A3 01                		mov.L	4[r10], r3
 1339 0330 ED A2 01                		mov.L	4[r10], r2
 1340 0333 ED A1 0A                		mov.L	40[r10], r1
 1341 0336 05 00 00 00             		bsr	_sp_mul
 1342 033a E3 A1                   		mov.L	r1, [r10]
 1343                             	.L80:
1856:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1344                             		.loc 2 1856 7
 1345 033c EC A5                   		mov.L	[r10], r5
 1346 033e 61 05                   		cmp	#0, r5
 1347 0340 21 0F                   		bne	.L81
1857:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t1, modulus, mp);
 1348                             		.loc 2 1857 14
 1349 0342 A8 6B                   		mov.L	4[r6], r3
 1350 0344 EC 62                   		mov.L	[r6], r2
 1351 0346 ED A1 01                		mov.L	4[r10], r1
 1352 0349 05 00 00 00             		bsr	_sp_mont_red
 1353 034d E3 A1                   		mov.L	r1, [r10]
 1354                             	.L81:
1858:../src/wolfcrypt/src/ecc.c **** 
1859:../src/wolfcrypt/src/ecc.c ****    /* T1 = Y' * T1 */
1860:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1355                             		.loc 2 1860 7
 1356 034f EC A5                   		mov.L	[r10], r5
 1357 0351 61 05                   		cmp	#0, r5
 1358 0353 21 17                   		bne	.L82
1861:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(Q->y, t1, t1);
 1359                             		.loc 2 1861 22
 1360 0355 ED A5 10                		mov.L	64[r10], r5
 1361 0358 72 55 10 03             		add	#0x310, r5
 1362                             		.loc 2 1861 14
 1363 035c ED A3 01                		mov.L	4[r10], r3
 1364 035f ED A2 01                		mov.L	4[r10], r2
 1365 0362 EF 51                   		mov.L	r5, r1
 1366 0364 05 00 00 00             		bsr	_sp_mul
 1367 0368 E3 A1                   		mov.L	r1, [r10]
 1368                             	.L82:
1862:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1369                             		.loc 2 1862 7
 1370 036a EC A5                   		mov.L	[r10], r5
 1371 036c 61 05                   		cmp	#0, r5
 1372 036e 21 0F                   		bne	.L83
1863:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t1, modulus, mp);
 1373                             		.loc 2 1863 14
 1374 0370 A8 6B                   		mov.L	4[r6], r3
 1375 0372 EC 62                   		mov.L	[r6], r2
 1376 0374 ED A1 01                		mov.L	4[r10], r1
 1377 0377 05 00 00 00             		bsr	_sp_mont_red
 1378 037b E3 A1                   		mov.L	r1, [r10]
 1379                             	.L83:
1864:../src/wolfcrypt/src/ecc.c **** 
1865:../src/wolfcrypt/src/ecc.c ****    /* Y = Y - T1 */
1866:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1380                             		.loc 2 1866 7
 1381 037d EC A5                   		mov.L	[r10], r5
 1382 037f 61 05                   		cmp	#0, r5
 1383 0381 21 13                   		bne	.L84
1867:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(y, t1, modulus, y);
 1384                             		.loc 2 1867 14
 1385 0383 ED A4 09                		mov.L	36[r10], r4
 1386 0386 EC 63                   		mov.L	[r6], r3
 1387 0388 ED A2 01                		mov.L	4[r10], r2
 1388 038b ED A1 09                		mov.L	36[r10], r1
 1389 038e 05 00 00 00             		bsr	_sp_submod_ct
 1390 0392 E3 A1                   		mov.L	r1, [r10]
 1391                             	.L84:
1868:../src/wolfcrypt/src/ecc.c ****    /* T1 = 2T1 */
1869:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1392                             		.loc 2 1869 7
 1393 0394 EC A5                   		mov.L	[r10], r5
 1394 0396 61 05                   		cmp	#0, r5
 1395 0398 21 13                   		bne	.L85
1870:../src/wolfcrypt/src/ecc.c ****        err = mp_addmod_ct(t1, t1, modulus, t1);
 1396                             		.loc 2 1870 14
 1397 039a ED A4 01                		mov.L	4[r10], r4
 1398 039d EC 63                   		mov.L	[r6], r3
 1399 039f ED A2 01                		mov.L	4[r10], r2
 1400 03a2 ED A1 01                		mov.L	4[r10], r1
 1401 03a5 05 00 00 00             		bsr	_sp_addmod_ct
 1402 03a9 E3 A1                   		mov.L	r1, [r10]
 1403                             	.L85:
1871:../src/wolfcrypt/src/ecc.c ****    /* T1 = Y + T1 */
1872:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1404                             		.loc 2 1872 7
 1405 03ab EC A5                   		mov.L	[r10], r5
 1406 03ad 61 05                   		cmp	#0, r5
 1407 03af 21 13                   		bne	.L86
1873:../src/wolfcrypt/src/ecc.c ****        err = mp_addmod_ct(t1, y, modulus, t1);
 1408                             		.loc 2 1873 14
 1409 03b1 ED A4 01                		mov.L	4[r10], r4
 1410 03b4 EC 63                   		mov.L	[r6], r3
 1411 03b6 ED A2 09                		mov.L	36[r10], r2
 1412 03b9 ED A1 01                		mov.L	4[r10], r1
 1413 03bc 05 00 00 00             		bsr	_sp_addmod_ct
 1414 03c0 E3 A1                   		mov.L	r1, [r10]
 1415                             	.L86:
1874:../src/wolfcrypt/src/ecc.c ****    /* X = X - T2 */
1875:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1416                             		.loc 2 1875 7
 1417 03c2 EC A5                   		mov.L	[r10], r5
 1418 03c4 61 05                   		cmp	#0, r5
 1419 03c6 21 13                   		bne	.L87
1876:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(x, t2, modulus, x);
 1420                             		.loc 2 1876 14
 1421 03c8 ED A4 08                		mov.L	32[r10], r4
 1422 03cb EC 63                   		mov.L	[r6], r3
 1423 03cd ED A2 02                		mov.L	8[r10], r2
 1424 03d0 ED A1 08                		mov.L	32[r10], r1
 1425 03d3 05 00 00 00             		bsr	_sp_submod_ct
 1426 03d7 E3 A1                   		mov.L	r1, [r10]
 1427                             	.L87:
1877:../src/wolfcrypt/src/ecc.c ****    /* T2 = 2T2 */
1878:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1428                             		.loc 2 1878 7
 1429 03d9 EC A5                   		mov.L	[r10], r5
 1430 03db 61 05                   		cmp	#0, r5
 1431 03dd 21 13                   		bne	.L88
1879:../src/wolfcrypt/src/ecc.c ****        err = mp_addmod_ct(t2, t2, modulus, t2);
 1432                             		.loc 2 1879 14
 1433 03df ED A4 02                		mov.L	8[r10], r4
 1434 03e2 EC 63                   		mov.L	[r6], r3
 1435 03e4 ED A2 02                		mov.L	8[r10], r2
 1436 03e7 ED A1 02                		mov.L	8[r10], r1
 1437 03ea 05 00 00 00             		bsr	_sp_addmod_ct
 1438 03ee E3 A1                   		mov.L	r1, [r10]
 1439                             	.L88:
1880:../src/wolfcrypt/src/ecc.c ****    /* T2 = X + T2 */
1881:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1440                             		.loc 2 1881 7
 1441 03f0 EC A5                   		mov.L	[r10], r5
 1442 03f2 61 05                   		cmp	#0, r5
 1443 03f4 21 13                   		bne	.L89
1882:../src/wolfcrypt/src/ecc.c ****        err = mp_addmod_ct(t2, x, modulus, t2);
 1444                             		.loc 2 1882 14
 1445 03f6 ED A4 02                		mov.L	8[r10], r4
 1446 03f9 EC 63                   		mov.L	[r6], r3
 1447 03fb ED A2 08                		mov.L	32[r10], r2
 1448 03fe ED A1 02                		mov.L	8[r10], r1
 1449 0401 05 00 00 00             		bsr	_sp_addmod_ct
 1450 0405 E3 A1                   		mov.L	r1, [r10]
 1451                             	.L89:
1883:../src/wolfcrypt/src/ecc.c **** 
1884:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 1452                             		.loc 2 1884 7
 1453 0407 EC A5                   		mov.L	[r10], r5
 1454 0409 61 05                   		cmp	#0, r5
 1455 040b 21 35                   		bne	.L90
1885:../src/wolfcrypt/src/ecc.c ****        if (!mp_iszero(Q->z)) {
 1456                             		.loc 2 1885 13
 1457 040d ED A5 10                		mov.L	64[r10], r5
 1458 0410 EE 55 88 01             		mov.L	1568[r5], r5
 1459                             		.loc 2 1885 11
 1460 0414 61 05                   		cmp	#0, r5
 1461 0416 20 2A                   		beq	.L90
1886:../src/wolfcrypt/src/ecc.c ****            /* Z = Z * Z' */
1887:../src/wolfcrypt/src/ecc.c ****            err = mp_mul(z, Q->z, z);
 1462                             		.loc 2 1887 29
 1463 0418 ED A5 10                		mov.L	64[r10], r5
 1464 041b 72 55 20 06             		add	#0x620, r5
 1465                             		.loc 2 1887 18
 1466 041f ED A3 0A                		mov.L	40[r10], r3
 1467 0422 EF 52                   		mov.L	r5, r2
 1468 0424 ED A1 0A                		mov.L	40[r10], r1
 1469 0427 05 00 00 00             		bsr	_sp_mul
 1470 042b E3 A1                   		mov.L	r1, [r10]
1888:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 1471                             		.loc 2 1888 15
 1472 042d EC A5                   		mov.L	[r10], r5
 1473 042f 61 05                   		cmp	#0, r5
 1474 0431 21 0F                   		bne	.L90
1889:../src/wolfcrypt/src/ecc.c ****                err = mp_montgomery_reduce(z, modulus, mp);
 1475                             		.loc 2 1889 22
 1476 0433 A8 6B                   		mov.L	4[r6], r3
 1477 0435 EC 62                   		mov.L	[r6], r2
 1478 0437 ED A1 0A                		mov.L	40[r10], r1
 1479 043a 05 00 00 00             		bsr	_sp_mont_red
 1480 043e E3 A1                   		mov.L	r1, [r10]
 1481                             		.balign 8,3,1
 1482                             	.L90:
1890:../src/wolfcrypt/src/ecc.c ****        }
1891:../src/wolfcrypt/src/ecc.c ****    }
1892:../src/wolfcrypt/src/ecc.c **** 
1893:../src/wolfcrypt/src/ecc.c ****    /* Z = Z * X */
1894:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1483                             		.loc 2 1894 7
 1484 0440 EC A5                   		mov.L	[r10], r5
 1485 0442 61 05                   		cmp	#0, r5
 1486 0444 21 11                   		bne	.L91
1895:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(z, x, z);
 1487                             		.loc 2 1895 14
 1488 0446 ED A3 0A                		mov.L	40[r10], r3
 1489 0449 ED A2 08                		mov.L	32[r10], r2
 1490 044c ED A1 0A                		mov.L	40[r10], r1
 1491 044f 05 00 00 00             		bsr	_sp_mul
 1492 0453 E3 A1                   		mov.L	r1, [r10]
 1493                             	.L91:
1896:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1494                             		.loc 2 1896 7
 1495 0455 EC A5                   		mov.L	[r10], r5
 1496 0457 61 05                   		cmp	#0, r5
 1497 0459 21 0F                   		bne	.L92
1897:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(z, modulus, mp);
 1498                             		.loc 2 1897 14
 1499 045b A8 6B                   		mov.L	4[r6], r3
 1500 045d EC 62                   		mov.L	[r6], r2
 1501 045f ED A1 0A                		mov.L	40[r10], r1
 1502 0462 05 00 00 00             		bsr	_sp_mont_red
 1503 0466 E3 A1                   		mov.L	r1, [r10]
 1504                             	.L92:
1898:../src/wolfcrypt/src/ecc.c **** 
1899:../src/wolfcrypt/src/ecc.c ****    /* T1 = T1 * X  */
1900:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1505                             		.loc 2 1900 7
 1506 0468 EC A5                   		mov.L	[r10], r5
 1507 046a 61 05                   		cmp	#0, r5
 1508 046c 21 11                   		bne	.L93
1901:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(t1, x, t1);
 1509                             		.loc 2 1901 14
 1510 046e ED A3 01                		mov.L	4[r10], r3
 1511 0471 ED A2 08                		mov.L	32[r10], r2
 1512 0474 ED A1 01                		mov.L	4[r10], r1
 1513 0477 05 00 00 00             		bsr	_sp_mul
 1514 047b E3 A1                   		mov.L	r1, [r10]
 1515                             	.L93:
1902:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1516                             		.loc 2 1902 7
 1517 047d EC A5                   		mov.L	[r10], r5
 1518 047f 61 05                   		cmp	#0, r5
 1519 0481 21 0F                   		bne	.L94
1903:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t1, modulus, mp);
 1520                             		.loc 2 1903 14
 1521 0483 A8 6B                   		mov.L	4[r6], r3
 1522 0485 EC 62                   		mov.L	[r6], r2
 1523 0487 ED A1 01                		mov.L	4[r10], r1
 1524 048a 05 00 00 00             		bsr	_sp_mont_red
 1525 048e E3 A1                   		mov.L	r1, [r10]
 1526                             	.L94:
1904:../src/wolfcrypt/src/ecc.c **** 
1905:../src/wolfcrypt/src/ecc.c ****    /* X = X * X */
1906:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1527                             		.loc 2 1906 7
 1528 0490 EC A5                   		mov.L	[r10], r5
 1529 0492 61 05                   		cmp	#0, r5
 1530 0494 21 0E                   		bne	.L95
1907:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(x, x);
 1531                             		.loc 2 1907 14
 1532 0496 ED A2 08                		mov.L	32[r10], r2
 1533 0499 ED A1 08                		mov.L	32[r10], r1
 1534 049c 05 00 00 00             		bsr	_sp_sqr
 1535 04a0 E3 A1                   		mov.L	r1, [r10]
 1536                             	.L95:
1908:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1537                             		.loc 2 1908 7
 1538 04a2 EC A5                   		mov.L	[r10], r5
 1539 04a4 61 05                   		cmp	#0, r5
 1540 04a6 21 0F                   		bne	.L96
1909:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(x, modulus, mp);
 1541                             		.loc 2 1909 14
 1542 04a8 A8 6B                   		mov.L	4[r6], r3
 1543 04aa EC 62                   		mov.L	[r6], r2
 1544 04ac ED A1 08                		mov.L	32[r10], r1
 1545 04af 05 00 00 00             		bsr	_sp_mont_red
 1546 04b3 E3 A1                   		mov.L	r1, [r10]
 1547                             	.L96:
1910:../src/wolfcrypt/src/ecc.c **** 
1911:../src/wolfcrypt/src/ecc.c ****    /* T2 = T2 * x */
1912:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1548                             		.loc 2 1912 7
 1549 04b5 EC A5                   		mov.L	[r10], r5
 1550 04b7 61 05                   		cmp	#0, r5
 1551 04b9 21 11                   		bne	.L97
1913:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(t2, x, t2);
 1552                             		.loc 2 1913 14
 1553 04bb ED A3 02                		mov.L	8[r10], r3
 1554 04be ED A2 08                		mov.L	32[r10], r2
 1555 04c1 ED A1 02                		mov.L	8[r10], r1
 1556 04c4 05 00 00 00             		bsr	_sp_mul
 1557 04c8 E3 A1                   		mov.L	r1, [r10]
 1558                             	.L97:
1914:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1559                             		.loc 2 1914 7
 1560 04ca EC A5                   		mov.L	[r10], r5
 1561 04cc 61 05                   		cmp	#0, r5
 1562 04ce 21 0F                   		bne	.L98
1915:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t2, modulus, mp);
 1563                             		.loc 2 1915 14
 1564 04d0 A8 6B                   		mov.L	4[r6], r3
 1565 04d2 EC 62                   		mov.L	[r6], r2
 1566 04d4 ED A1 02                		mov.L	8[r10], r1
 1567 04d7 05 00 00 00             		bsr	_sp_mont_red
 1568 04db E3 A1                   		mov.L	r1, [r10]
 1569                             	.L98:
1916:../src/wolfcrypt/src/ecc.c **** 
1917:../src/wolfcrypt/src/ecc.c ****    /* T1 = T1 * X  */
1918:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1570                             		.loc 2 1918 7
 1571 04dd EC A5                   		mov.L	[r10], r5
 1572 04df 61 05                   		cmp	#0, r5
 1573 04e1 21 11                   		bne	.L99
1919:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(t1, x, t1);
 1574                             		.loc 2 1919 14
 1575 04e3 ED A3 01                		mov.L	4[r10], r3
 1576 04e6 ED A2 08                		mov.L	32[r10], r2
 1577 04e9 ED A1 01                		mov.L	4[r10], r1
 1578 04ec 05 00 00 00             		bsr	_sp_mul
 1579 04f0 E3 A1                   		mov.L	r1, [r10]
 1580                             	.L99:
1920:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1581                             		.loc 2 1920 7
 1582 04f2 EC A5                   		mov.L	[r10], r5
 1583 04f4 61 05                   		cmp	#0, r5
 1584 04f6 21 0F                   		bne	.L100
1921:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t1, modulus, mp);
 1585                             		.loc 2 1921 14
 1586 04f8 A8 6B                   		mov.L	4[r6], r3
 1587 04fa EC 62                   		mov.L	[r6], r2
 1588 04fc ED A1 01                		mov.L	4[r10], r1
 1589 04ff 05 00 00 00             		bsr	_sp_mont_red
 1590 0503 E3 A1                   		mov.L	r1, [r10]
 1591                             	.L100:
1922:../src/wolfcrypt/src/ecc.c **** 
1923:../src/wolfcrypt/src/ecc.c ****    /* X = Y*Y */
1924:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1592                             		.loc 2 1924 7
 1593 0505 EC A5                   		mov.L	[r10], r5
 1594 0507 61 05                   		cmp	#0, r5
 1595 0509 21 0E                   		bne	.L101
1925:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(y, x);
 1596                             		.loc 2 1925 14
 1597 050b ED A2 08                		mov.L	32[r10], r2
 1598 050e ED A1 09                		mov.L	36[r10], r1
 1599 0511 05 00 00 00             		bsr	_sp_sqr
 1600 0515 E3 A1                   		mov.L	r1, [r10]
 1601                             	.L101:
1926:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1602                             		.loc 2 1926 7
 1603 0517 EC A5                   		mov.L	[r10], r5
 1604 0519 61 05                   		cmp	#0, r5
 1605 051b 21 0F                   		bne	.L102
1927:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(x, modulus, mp);
 1606                             		.loc 2 1927 14
 1607 051d A8 6B                   		mov.L	4[r6], r3
 1608 051f EC 62                   		mov.L	[r6], r2
 1609 0521 ED A1 08                		mov.L	32[r10], r1
 1610 0524 05 00 00 00             		bsr	_sp_mont_red
 1611 0528 E3 A1                   		mov.L	r1, [r10]
 1612                             	.L102:
1928:../src/wolfcrypt/src/ecc.c **** 
1929:../src/wolfcrypt/src/ecc.c ****    /* X = X - T2 */
1930:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1613                             		.loc 2 1930 7
 1614 052a EC A5                   		mov.L	[r10], r5
 1615 052c 61 05                   		cmp	#0, r5
 1616 052e 21 13                   		bne	.L103
1931:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(x, t2, modulus, x);
 1617                             		.loc 2 1931 14
 1618 0530 ED A4 08                		mov.L	32[r10], r4
 1619 0533 EC 63                   		mov.L	[r6], r3
 1620 0535 ED A2 02                		mov.L	8[r10], r2
 1621 0538 ED A1 08                		mov.L	32[r10], r1
 1622 053b 05 00 00 00             		bsr	_sp_submod_ct
 1623 053f E3 A1                   		mov.L	r1, [r10]
 1624                             	.L103:
1932:../src/wolfcrypt/src/ecc.c ****    /* T2 = T2 - X */
1933:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1625                             		.loc 2 1933 7
 1626 0541 EC A5                   		mov.L	[r10], r5
 1627 0543 61 05                   		cmp	#0, r5
 1628 0545 21 13                   		bne	.L104
1934:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(t2, x, modulus, t2);
 1629                             		.loc 2 1934 14
 1630 0547 ED A4 02                		mov.L	8[r10], r4
 1631 054a EC 63                   		mov.L	[r6], r3
 1632 054c ED A2 08                		mov.L	32[r10], r2
 1633 054f ED A1 02                		mov.L	8[r10], r1
 1634 0552 05 00 00 00             		bsr	_sp_submod_ct
 1635 0556 E3 A1                   		mov.L	r1, [r10]
 1636                             	.L104:
1935:../src/wolfcrypt/src/ecc.c ****    /* T2 = T2 - X */
1936:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1637                             		.loc 2 1936 7
 1638 0558 EC A5                   		mov.L	[r10], r5
 1639 055a 61 05                   		cmp	#0, r5
 1640 055c 21 13                   		bne	.L105
1937:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(t2, x, modulus, t2);
 1641                             		.loc 2 1937 14
 1642 055e ED A4 02                		mov.L	8[r10], r4
 1643 0561 EC 63                   		mov.L	[r6], r3
 1644 0563 ED A2 08                		mov.L	32[r10], r2
 1645 0566 ED A1 02                		mov.L	8[r10], r1
 1646 0569 05 00 00 00             		bsr	_sp_submod_ct
 1647 056d E3 A1                   		mov.L	r1, [r10]
 1648                             	.L105:
1938:../src/wolfcrypt/src/ecc.c ****    /* T2 = T2 * Y */
1939:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1649                             		.loc 2 1939 7
 1650 056f EC A5                   		mov.L	[r10], r5
 1651 0571 61 05                   		cmp	#0, r5
 1652 0573 21 11                   		bne	.L106
1940:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(t2, y, t2);
 1653                             		.loc 2 1940 14
 1654 0575 ED A3 02                		mov.L	8[r10], r3
 1655 0578 ED A2 09                		mov.L	36[r10], r2
 1656 057b ED A1 02                		mov.L	8[r10], r1
 1657 057e 05 00 00 00             		bsr	_sp_mul
 1658 0582 E3 A1                   		mov.L	r1, [r10]
 1659                             	.L106:
1941:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1660                             		.loc 2 1941 7
 1661 0584 EC A5                   		mov.L	[r10], r5
 1662 0586 61 05                   		cmp	#0, r5
 1663 0588 21 0F                   		bne	.L107
1942:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t2, modulus, mp);
 1664                             		.loc 2 1942 14
 1665 058a A8 6B                   		mov.L	4[r6], r3
 1666 058c EC 62                   		mov.L	[r6], r2
 1667 058e ED A1 02                		mov.L	8[r10], r1
 1668 0591 05 00 00 00             		bsr	_sp_mont_red
 1669 0595 E3 A1                   		mov.L	r1, [r10]
 1670                             	.L107:
1943:../src/wolfcrypt/src/ecc.c **** 
1944:../src/wolfcrypt/src/ecc.c ****    /* Y = T2 - T1 */
1945:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1671                             		.loc 2 1945 7
 1672 0597 EC A5                   		mov.L	[r10], r5
 1673 0599 61 05                   		cmp	#0, r5
 1674 059b 21 13                   		bne	.L108
1946:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(t2, t1, modulus, y);
 1675                             		.loc 2 1946 14
 1676 059d ED A4 09                		mov.L	36[r10], r4
 1677 05a0 EC 63                   		mov.L	[r6], r3
 1678 05a2 ED A2 01                		mov.L	4[r10], r2
 1679 05a5 ED A1 02                		mov.L	8[r10], r1
 1680 05a8 05 00 00 00             		bsr	_sp_submod_ct
 1681 05ac E3 A1                   		mov.L	r1, [r10]
 1682                             	.L108:
1947:../src/wolfcrypt/src/ecc.c ****    /* Y = Y/2 */
1948:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1683                             		.loc 2 1948 7
 1684 05ae EC A5                   		mov.L	[r10], r5
 1685 05b0 61 05                   		cmp	#0, r5
 1686 05b2 21 14                   		bne	.L112
1949:../src/wolfcrypt/src/ecc.c ****        err = mp_div_2_mod_ct(y, modulus, y);
 1687                             		.loc 2 1949 14
 1688 05b4 ED A3 09                		mov.L	36[r10], r3
 1689 05b7 EC 62                   		mov.L	[r6], r2
 1690 05b9 ED A1 09                		mov.L	36[r10], r1
 1691 05bc 05 00 00 00             		bsr	_sp_div_2_mod_ct
 1692 05c0 E3 A1                   		mov.L	r1, [r10]
 1693 05c2 0D                      		bra	.L65
 1694                             	.L111:
1785:../src/wolfcrypt/src/ecc.c ****    }
 1695                             		.loc 2 1785 7
 1696 05c3 03                      		nop
 1697 05c4 2E 03                   		bra	.L65
 1698                             	.L112:
1950:../src/wolfcrypt/src/ecc.c **** 
1951:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
1952:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
1953:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(x, R->x);
1954:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
1955:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(y, R->y);
1956:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
1957:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(z, R->z);
1958:../src/wolfcrypt/src/ecc.c **** #endif
1959:../src/wolfcrypt/src/ecc.c **** 
1960:../src/wolfcrypt/src/ecc.c **** done:
 1699                             		.loc 2 1960 1
 1700 05c6 03                      		nop
 1701                             	.L65:
1961:../src/wolfcrypt/src/ecc.c **** 
1962:../src/wolfcrypt/src/ecc.c ****    /* clean up */
1963:../src/wolfcrypt/src/ecc.c ****    mp_clear(t1);
 1702                             		.loc 2 1963 4
 1703 05c7 ED A1 01                		mov.L	4[r10], r1
 1704 05ca 05 00 00 00             		bsr	_sp_clear
1964:../src/wolfcrypt/src/ecc.c ****    mp_clear(t2);
 1705                             		.loc 2 1964 4
 1706 05ce ED A1 02                		mov.L	8[r10], r1
 1707 05d1 05 00 00 00             		bsr	_sp_clear
 1708                             	.LBB10:
1965:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
1966:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
1967:../src/wolfcrypt/src/ecc.c ****    if (R->key == NULL)
1968:../src/wolfcrypt/src/ecc.c **** #endif
1969:../src/wolfcrypt/src/ecc.c ****    {
1970:../src/wolfcrypt/src/ecc.c ****    #ifdef ALT_ECC_SIZE
1971:../src/wolfcrypt/src/ecc.c ****       XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
1972:../src/wolfcrypt/src/ecc.c ****       XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
1973:../src/wolfcrypt/src/ecc.c ****       XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
1974:../src/wolfcrypt/src/ecc.c ****    #endif
1975:../src/wolfcrypt/src/ecc.c ****       XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 1709                             		.loc 2 1975 7
 1710 05d5 ED A5 02                		mov.L	8[r10], r5
 1711 05d8 E7 A5 0B                		mov.L	r5, 44[r10]
 1712 05db ED A5 0B                		mov.L	44[r10], r5
 1713 05de 61 05                   		cmp	#0, r5
 1714 05e0 10                      		beq	.L109
 1715                             		.loc 2 1975 7 is_stmt 0 discriminator 1
 1716 05e1 ED A1 0B                		mov.L	44[r10], r1
 1717 05e4 05 00 00 00             		bsr	_wolfSSL_Free
 1718                             	.L109:
 1719                             	.LBE10:
 1720                             	.LBB11:
1976:../src/wolfcrypt/src/ecc.c ****       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 1721                             		.loc 2 1976 7 is_stmt 1
 1722 05e8 ED A5 01                		mov.L	4[r10], r5
 1723 05eb E7 A5 0C                		mov.L	r5, 48[r10]
 1724 05ee ED A5 0C                		mov.L	48[r10], r5
 1725 05f1 61 05                   		cmp	#0, r5
 1726 05f3 10                      		beq	.L110
 1727                             		.loc 2 1976 7 is_stmt 0 discriminator 1
 1728 05f4 ED A1 0C                		mov.L	48[r10], r1
 1729 05f7 05 00 00 00             		bsr	_wolfSSL_Free
 1730                             	.L110:
 1731                             	.LBE11:
1977:../src/wolfcrypt/src/ecc.c ****    }
1978:../src/wolfcrypt/src/ecc.c **** #endif
1979:../src/wolfcrypt/src/ecc.c **** 
1980:../src/wolfcrypt/src/ecc.c ****    return err;
 1732                             		.loc 2 1980 11 is_stmt 1
 1733 05fb EC A5                   		mov.L	[r10], r5
 1734                             		.balign 8,3,1
 1735                             	.L55:
1981:../src/wolfcrypt/src/ecc.c **** #else
1982:../src/wolfcrypt/src/ecc.c ****     int modBits = mp_count_bits(modulus);
1983:../src/wolfcrypt/src/ecc.c **** 
1984:../src/wolfcrypt/src/ecc.c ****     (void)a;
1985:../src/wolfcrypt/src/ecc.c ****     (void)mp;
1986:../src/wolfcrypt/src/ecc.c **** 
1987:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
1988:../src/wolfcrypt/src/ecc.c ****     if (modBits == 256) {
1989:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_proj_add_point_256(P->x, P->y, P->z, Q->x, Q->y, Q->z,
1990:../src/wolfcrypt/src/ecc.c ****                                          R->x, R->y, R->z);
1991:../src/wolfcrypt/src/ecc.c ****     }
1992:../src/wolfcrypt/src/ecc.c **** #endif
1993:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
1994:../src/wolfcrypt/src/ecc.c ****     if (modBits == 384) {
1995:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_proj_add_point_384(P->x, P->y, P->z, Q->x, Q->y, Q->z,
1996:../src/wolfcrypt/src/ecc.c ****                                          R->x, R->y, R->z);
1997:../src/wolfcrypt/src/ecc.c ****     }
1998:../src/wolfcrypt/src/ecc.c **** #endif
1999:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
2000:../src/wolfcrypt/src/ecc.c ****     if (modBits == 521) {
2001:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_proj_add_point_521(P->x, P->y, P->z, Q->x, Q->y, Q->z,
2002:../src/wolfcrypt/src/ecc.c ****                                          R->x, R->y, R->z);
2003:../src/wolfcrypt/src/ecc.c ****     }
2004:../src/wolfcrypt/src/ecc.c **** #endif
2005:../src/wolfcrypt/src/ecc.c ****     return ECC_BAD_ARG_E;
2006:../src/wolfcrypt/src/ecc.c **** #endif
2007:../src/wolfcrypt/src/ecc.c **** }
 1736                             		.loc 2 2007 1
 1737 05fd EF 51                   		mov.L	r5, r1
 1738 05ff 71 00 5C                		add	#0x5c, r0
 1739 0602 7E B6                   		pop	r6
 1740 0604 7E BA                   		pop	r10
 1741 0606 02                      		rts
 1742                             	.LFE50:
 1744 0607 03                      		.section	.text.ecc_projective_add_point,"ax",@progbits
 1745                             		.global	_ecc_projective_add_point
 1747                             	_ecc_projective_add_point:
 1748                             	.LFB51:
2008:../src/wolfcrypt/src/ecc.c **** 
2009:../src/wolfcrypt/src/ecc.c **** int ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,
2010:../src/wolfcrypt/src/ecc.c ****                              mp_int* a, mp_int* modulus, mp_digit mp)
2011:../src/wolfcrypt/src/ecc.c **** {
 1749                             		.loc 2 2011 1
 1750 0000 7E AA                   		push.l	r10
 1751                             	.LCFI20:
 1752 0002 7E A6                   		push.l	r6
 1753                             	.LCFI21:
 1754 0004 71 0A E8                		add	#-24, r0, r10
 1755                             	.LCFI22:
 1756 0007 71 A0 F8                		add	#-8, r10, r0
 1757                             	.LCFI23:
 1758 000a 75 46 24                		mov.L	#36, r6
 1759 000d 4B A6                   		add	r10, r6
 1760 000f E3 A1                   		mov.L	r1, [r10]
 1761 0011 E7 A2 01                		mov.L	r2, 4[r10]
 1762 0014 E7 A3 02                		mov.L	r3, 8[r10]
 1763 0017 E7 A4 03                		mov.L	r4, 12[r10]
2012:../src/wolfcrypt/src/ecc.c ****     if (P == NULL || Q == NULL || R == NULL || modulus == NULL) {
 1764                             		.loc 2 2012 8
 1765 001a EC A5                   		mov.L	[r10], r5
 1766 001c 61 05                   		cmp	#0, r5
 1767 001e 20 14                   		beq	.L114
 1768                             		.loc 2 2012 19 discriminator 1
 1769 0020 ED A5 01                		mov.L	4[r10], r5
 1770 0023 61 05                   		cmp	#0, r5
 1771 0025 20 0D                   		beq	.L114
 1772                             		.loc 2 2012 32 discriminator 2
 1773 0027 ED A5 02                		mov.L	8[r10], r5
 1774 002a 61 05                   		cmp	#0, r5
 1775 002c 16                      		beq	.L114
 1776                             		.loc 2 2012 45 discriminator 3
 1777 002d EC 65                   		mov.L	[r6], r5
 1778 002f 61 05                   		cmp	#0, r5
 1779 0031 18                      		bne	.L115
 1780                             		.balign 8,3,2
 1781                             	.L114:
2013:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 1782                             		.loc 2 2013 16
 1783 0032 FB 5A 56 FF             		mov.L	#-170, r5
 1784 0036 38 9A 00                		bra	.L116
 1785                             	.L115:
2014:../src/wolfcrypt/src/ecc.c ****     }
2015:../src/wolfcrypt/src/ecc.c **** 
2016:../src/wolfcrypt/src/ecc.c ****     if (mp_cmp(P->x, modulus) != MP_LT ||
 1786                             		.loc 2 2016 17
 1787 0039 EC A5                   		mov.L	[r10], r5
 1788                             		.loc 2 2016 9
 1789 003b EC 62                   		mov.L	[r6], r2
 1790 003d EF 51                   		mov.L	r5, r1
 1791 003f 05 00 00 00             		bsr	_sp_cmp
 1792 0043 EF 15                   		mov.L	r1, r5
 1793                             		.loc 2 2016 8
 1794 0045 75 05 FF                		cmp	#-1, r5
 1795 0048 21 69                   		bne	.L117
2017:../src/wolfcrypt/src/ecc.c ****         mp_cmp(P->y, modulus) != MP_LT ||
 1796                             		.loc 2 2017 17 discriminator 1
 1797 004a EC A5                   		mov.L	[r10], r5
 1798 004c 72 55 10 03             		add	#0x310, r5
 1799                             		.loc 2 2017 9 discriminator 1
 1800 0050 EC 62                   		mov.L	[r6], r2
 1801 0052 EF 51                   		mov.L	r5, r1
 1802 0054 05 00 00 00             		bsr	_sp_cmp
 1803 0058 EF 15                   		mov.L	r1, r5
2016:../src/wolfcrypt/src/ecc.c ****         mp_cmp(P->y, modulus) != MP_LT ||
 1804                             		.loc 2 2016 40 discriminator 1
 1805 005a 75 05 FF                		cmp	#-1, r5
 1806 005d 21 54                   		bne	.L117
2018:../src/wolfcrypt/src/ecc.c ****         mp_cmp(P->z, modulus) != MP_LT ||
 1807                             		.loc 2 2018 17
 1808 005f EC A5                   		mov.L	[r10], r5
 1809 0061 72 55 20 06             		add	#0x620, r5
 1810                             		.loc 2 2018 9
 1811 0065 EC 62                   		mov.L	[r6], r2
 1812 0067 EF 51                   		mov.L	r5, r1
 1813 0069 05 00 00 00             		bsr	_sp_cmp
 1814 006d EF 15                   		mov.L	r1, r5
2017:../src/wolfcrypt/src/ecc.c ****         mp_cmp(P->y, modulus) != MP_LT ||
 1815                             		.loc 2 2017 40
 1816 006f 75 05 FF                		cmp	#-1, r5
 1817 0072 21 3F                   		bne	.L117
2019:../src/wolfcrypt/src/ecc.c ****         mp_cmp(Q->x, modulus) != MP_LT ||
 1818                             		.loc 2 2019 17
 1819 0074 ED A5 01                		mov.L	4[r10], r5
 1820                             		.loc 2 2019 9
 1821 0077 EC 62                   		mov.L	[r6], r2
 1822 0079 EF 51                   		mov.L	r5, r1
 1823 007b 05 00 00 00             		bsr	_sp_cmp
 1824 007f EF 15                   		mov.L	r1, r5
2018:../src/wolfcrypt/src/ecc.c ****         mp_cmp(P->z, modulus) != MP_LT ||
 1825                             		.loc 2 2018 40
 1826 0081 75 05 FF                		cmp	#-1, r5
 1827 0084 21 2D                   		bne	.L117
2020:../src/wolfcrypt/src/ecc.c ****         mp_cmp(Q->y, modulus) != MP_LT ||
 1828                             		.loc 2 2020 17
 1829 0086 ED A5 01                		mov.L	4[r10], r5
 1830 0089 72 55 10 03             		add	#0x310, r5
 1831                             		.loc 2 2020 9
 1832 008d EC 62                   		mov.L	[r6], r2
 1833 008f EF 51                   		mov.L	r5, r1
 1834 0091 05 00 00 00             		bsr	_sp_cmp
 1835 0095 EF 15                   		mov.L	r1, r5
2019:../src/wolfcrypt/src/ecc.c ****         mp_cmp(Q->x, modulus) != MP_LT ||
 1836                             		.loc 2 2019 40
 1837 0097 75 05 FF                		cmp	#-1, r5
 1838 009a 21 17                   		bne	.L117
2021:../src/wolfcrypt/src/ecc.c ****         mp_cmp(Q->z, modulus) != MP_LT) {
 1839                             		.loc 2 2021 17
 1840 009c ED A5 01                		mov.L	4[r10], r5
 1841 009f 72 55 20 06             		add	#0x620, r5
 1842                             		.loc 2 2021 9
 1843 00a3 EC 62                   		mov.L	[r6], r2
 1844 00a5 EF 51                   		mov.L	r5, r1
 1845 00a7 05 00 00 00             		bsr	_sp_cmp
 1846 00ab EF 15                   		mov.L	r1, r5
2020:../src/wolfcrypt/src/ecc.c ****         mp_cmp(Q->y, modulus) != MP_LT ||
 1847                             		.loc 2 2020 40
 1848 00ad 75 05 FF                		cmp	#-1, r5
 1849 00b0 17                      		beq	.L118
 1850                             		.balign 8,3,2
 1851                             	.L117:
2022:../src/wolfcrypt/src/ecc.c ****         return ECC_OUT_OF_RANGE_E;
 1852                             		.loc 2 2022 16
 1853 00b1 FB 5A 27 FF             		mov.L	#-217, r5
 1854 00b5 2E 1B                   		bra	.L116
 1855                             	.L118:
2023:../src/wolfcrypt/src/ecc.c ****     }
2024:../src/wolfcrypt/src/ecc.c **** 
2025:../src/wolfcrypt/src/ecc.c ****     return _ecc_projective_add_point(P, Q, R, a, modulus, mp);
 1856                             		.loc 2 2025 12
 1857 00b7 A8 6D                   		mov.L	4[r6], r5
 1858 00b9 A0 0D                   		mov.L	r5, 4[r0]
 1859 00bb EC 65                   		mov.L	[r6], r5
 1860 00bd E3 05                   		mov.L	r5, [r0]
 1861 00bf ED A4 03                		mov.L	12[r10], r4
 1862 00c2 ED A3 02                		mov.L	8[r10], r3
 1863 00c5 ED A2 01                		mov.L	4[r10], r2
 1864 00c8 EC A1                   		mov.L	[r10], r1
 1865 00ca 05 00 00 00             		bsr	__ecc_projective_add_point
 1866 00ce EF 15                   		mov.L	r1, r5
 1867                             	.L116:
2026:../src/wolfcrypt/src/ecc.c **** }
 1868                             		.loc 2 2026 1
 1869 00d0 EF 51                   		mov.L	r5, r1
 1870 00d2 71 00 20                		add	#32, r0
 1871 00d5 7E B6                   		pop	r6
 1872 00d7 7E BA                   		pop	r10
 1873 00d9 02                      		rts
 1874                             	.LFE51:
 1876 00da 74 10 01 00 00 00       		.section	.text._ecc_projective_dbl_point,"ax",@progbits
 1878                             	__ecc_projective_dbl_point:
 1879                             	.LFB52:
2027:../src/wolfcrypt/src/ecc.c **** 
2028:../src/wolfcrypt/src/ecc.c **** /* ### Point doubling in Jacobian coordinate system ###
2029:../src/wolfcrypt/src/ecc.c ****  *
2030:../src/wolfcrypt/src/ecc.c ****  * let us have a curve:                 y^2 = x^3 + a*x + b
2031:../src/wolfcrypt/src/ecc.c ****  * in Jacobian coordinates it becomes:  y^2 = x^3 + a*x*z^4 + b*z^6
2032:../src/wolfcrypt/src/ecc.c ****  *
2033:../src/wolfcrypt/src/ecc.c ****  * The doubling of P = (Xp, Yp, Zp) is given by R = (Xr, Yr, Zr) where:
2034:../src/wolfcrypt/src/ecc.c ****  * Xr = M^2 - 2*S
2035:../src/wolfcrypt/src/ecc.c ****  * Yr = M * (S - Xr) - 8*T
2036:../src/wolfcrypt/src/ecc.c ****  * Zr = 2 * Yp * Zp
2037:../src/wolfcrypt/src/ecc.c ****  *
2038:../src/wolfcrypt/src/ecc.c ****  * M = 3 * Xp^2 + a*Zp^4
2039:../src/wolfcrypt/src/ecc.c ****  * T = Yp^4
2040:../src/wolfcrypt/src/ecc.c ****  * S = 4 * Xp * Yp^2
2041:../src/wolfcrypt/src/ecc.c ****  *
2042:../src/wolfcrypt/src/ecc.c ****  * SPECIAL CASE: when a == 3 we can compute M as
2043:../src/wolfcrypt/src/ecc.c ****  * M = 3 * (Xp^2 - Zp^4) = 3 * (Xp + Zp^2) * (Xp - Zp^2)
2044:../src/wolfcrypt/src/ecc.c ****  */
2045:../src/wolfcrypt/src/ecc.c **** 
2046:../src/wolfcrypt/src/ecc.c **** /**
2047:../src/wolfcrypt/src/ecc.c ****    Double an ECC point
2048:../src/wolfcrypt/src/ecc.c ****    P   The point to double
2049:../src/wolfcrypt/src/ecc.c ****    R   [out] The destination of the double
2050:../src/wolfcrypt/src/ecc.c ****    a   ECC curve parameter a
2051:../src/wolfcrypt/src/ecc.c ****    modulus  The modulus of the field the ECC curve is in
2052:../src/wolfcrypt/src/ecc.c ****    mp       The "b" value from montgomery_setup()
2053:../src/wolfcrypt/src/ecc.c ****    return   MP_OKAY on success
2054:../src/wolfcrypt/src/ecc.c **** */
2055:../src/wolfcrypt/src/ecc.c **** static int _ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,
2056:../src/wolfcrypt/src/ecc.c ****                                      mp_int* modulus, mp_digit mp)
2057:../src/wolfcrypt/src/ecc.c **** {
 1880                             		.loc 2 2057 1
 1881 0000 7E AA                   		push.l	r10
 1882                             	.LCFI24:
 1883 0002 7E A6                   		push.l	r6
 1884                             	.LCFI25:
 1885 0004 71 0A BC                		add	#-68, r0, r10
 1886                             	.LCFI26:
 1887 0007 71 A0 F8                		add	#-8, r10, r0
 1888                             	.LCFI27:
 1889 000a 75 46 50                		mov.L	#0x50, r6
 1890 000d 4B A6                   		add	r10, r6
 1891 000f E7 A1 0C                		mov.L	r1, 48[r10]
 1892 0012 E7 A2 0D                		mov.L	r2, 52[r10]
 1893 0015 E7 A3 0E                		mov.L	r3, 56[r10]
 1894 0018 E7 A4 0F                		mov.L	r4, 60[r10]
2058:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
2059:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2060:../src/wolfcrypt/src/ecc.c ****    mp_int* t1 = NULL;
 1895                             		.loc 2 2060 12
 1896 001b F9 A6 01 00             		mov.L	#0, 4[r10]
2061:../src/wolfcrypt/src/ecc.c ****    mp_int* t2 = NULL;
 1897                             		.loc 2 2061 12
 1898 001f F9 A6 02 00             		mov.L	#0, 8[r10]
2062:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
2063:../src/wolfcrypt/src/ecc.c ****    mp_int* rx = NULL;
2064:../src/wolfcrypt/src/ecc.c ****    mp_int* ry = NULL;
2065:../src/wolfcrypt/src/ecc.c ****    mp_int* rz = NULL;
2066:../src/wolfcrypt/src/ecc.c **** #endif
2067:../src/wolfcrypt/src/ecc.c **** #else
2068:../src/wolfcrypt/src/ecc.c ****    mp_int  t1[1], t2[1];
2069:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
2070:../src/wolfcrypt/src/ecc.c ****    mp_int  rx[1], ry[1], rz[1];
2071:../src/wolfcrypt/src/ecc.c **** #endif
2072:../src/wolfcrypt/src/ecc.c **** #endif
2073:../src/wolfcrypt/src/ecc.c ****    mp_int *x, *y, *z;
2074:../src/wolfcrypt/src/ecc.c ****    int    err;
2075:../src/wolfcrypt/src/ecc.c **** 
2076:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2077:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
2078:../src/wolfcrypt/src/ecc.c ****    if (R->key != NULL) {
2079:../src/wolfcrypt/src/ecc.c ****        t1 = R->key->t1;
2080:../src/wolfcrypt/src/ecc.c ****        t2 = R->key->t2;
2081:../src/wolfcrypt/src/ecc.c ****    #ifdef ALT_ECC_SIZE
2082:../src/wolfcrypt/src/ecc.c ****        rx = R->key->x;
2083:../src/wolfcrypt/src/ecc.c ****        ry = R->key->y;
2084:../src/wolfcrypt/src/ecc.c ****        rz = R->key->z;
2085:../src/wolfcrypt/src/ecc.c ****    #endif
2086:../src/wolfcrypt/src/ecc.c ****    }
2087:../src/wolfcrypt/src/ecc.c ****    else
2088:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK_CACHE */
2089:../src/wolfcrypt/src/ecc.c ****    {
2090:../src/wolfcrypt/src/ecc.c ****        t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 1899                             		.loc 2 2090 22
 1900 0023 FB 1A 10 03             		mov.L	#0x310, r1
 1901 0027 05 00 00 00             		bsr	_wolfSSL_Malloc
 1902 002b E7 A1 01                		mov.L	r1, 4[r10]
2091:../src/wolfcrypt/src/ecc.c ****        t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 1903                             		.loc 2 2091 22
 1904 002e FB 1A 10 03             		mov.L	#0x310, r1
 1905 0032 05 00 00 00             		bsr	_wolfSSL_Malloc
 1906 0036 E7 A1 02                		mov.L	r1, 8[r10]
2092:../src/wolfcrypt/src/ecc.c ****        if (t1 == NULL || t2 == NULL) {
 1907                             		.loc 2 2092 11
 1908 0039 ED A5 01                		mov.L	4[r10], r5
 1909 003c 61 05                   		cmp	#0, r5
 1910 003e 10                      		beq	.L120
 1911                             		.loc 2 2092 23 discriminator 1
 1912 003f ED A5 02                		mov.L	8[r10], r5
 1913 0042 61 05                   		cmp	#0, r5
 1914 0044 21 2E                   		bne	.L121
 1915                             	.L120:
 1916                             	.LBB12:
2093:../src/wolfcrypt/src/ecc.c ****            XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 1917                             		.loc 2 2093 12
 1918 0046 ED A5 02                		mov.L	8[r10], r5
 1919 0049 E7 A5 0A                		mov.L	r5, 40[r10]
 1920 004c ED A5 0A                		mov.L	40[r10], r5
 1921 004f 61 05                   		cmp	#0, r5
 1922 0051 10                      		beq	.L122
 1923                             		.loc 2 2093 12 is_stmt 0 discriminator 1
 1924 0052 ED A1 0A                		mov.L	40[r10], r1
 1925 0055 05 00 00 00             		bsr	_wolfSSL_Free
 1926                             	.L122:
 1927                             	.LBE12:
 1928                             	.LBB13:
2094:../src/wolfcrypt/src/ecc.c ****            XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 1929                             		.loc 2 2094 12 is_stmt 1
 1930 0059 ED A5 01                		mov.L	4[r10], r5
 1931 005c E7 A5 0B                		mov.L	r5, 44[r10]
 1932 005f ED A5 0B                		mov.L	44[r10], r5
 1933 0062 61 05                   		cmp	#0, r5
 1934 0064 10                      		beq	.L123
 1935                             		.loc 2 2094 12 is_stmt 0 discriminator 1
 1936 0065 ED A1 0B                		mov.L	44[r10], r1
 1937 0068 05 00 00 00             		bsr	_wolfSSL_Free
 1938                             	.L123:
 1939                             	.LBE13:
2095:../src/wolfcrypt/src/ecc.c ****            return MEMORY_E;
 1940                             		.loc 2 2095 19 is_stmt 1
 1941 006c FB 56 83                		mov.L	#-125, r5
 1942 006f 38 1F 03                		bra	.L124
 1943                             	.L121:
2096:../src/wolfcrypt/src/ecc.c ****        }
2097:../src/wolfcrypt/src/ecc.c ****     #ifdef ALT_ECC_SIZE
2098:../src/wolfcrypt/src/ecc.c ****        rx = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
2099:../src/wolfcrypt/src/ecc.c ****        ry = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
2100:../src/wolfcrypt/src/ecc.c ****        rz = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
2101:../src/wolfcrypt/src/ecc.c ****        if (rx == NULL || ry == NULL || rz == NULL) {
2102:../src/wolfcrypt/src/ecc.c ****            XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
2103:../src/wolfcrypt/src/ecc.c ****            XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
2104:../src/wolfcrypt/src/ecc.c ****            XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
2105:../src/wolfcrypt/src/ecc.c ****            XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
2106:../src/wolfcrypt/src/ecc.c ****            XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
2107:../src/wolfcrypt/src/ecc.c ****            return MEMORY_E;
2108:../src/wolfcrypt/src/ecc.c ****        }
2109:../src/wolfcrypt/src/ecc.c ****     #endif
2110:../src/wolfcrypt/src/ecc.c ****     }
2111:../src/wolfcrypt/src/ecc.c **** #endif
2112:../src/wolfcrypt/src/ecc.c **** 
2113:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {
 1944                             		.loc 2 2113 15
 1945 0072 3E 01 00                		mov.L	#0, 4[r0]
 1946 0075 F8 06 00                		mov.L	#0, [r0]
 1947 0078 66 04                   		mov.L	#0, r4
 1948 007a 66 03                   		mov.L	#0, r3
 1949 007c ED A2 02                		mov.L	8[r10], r2
 1950 007f ED A1 01                		mov.L	4[r10], r1
 1951 0082 05 00 00 00             		bsr	_sp_init_multi
 1952 0086 E3 A1                   		mov.L	r1, [r10]
 1953                             		.loc 2 2113 7
 1954 0088 EC A5                   		mov.L	[r10], r5
 1955 008a 61 05                   		cmp	#0, r5
 1956 008c 20 2D                   		beq	.L125
 1957                             	.LBB14:
2114:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2115:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
2116:../src/wolfcrypt/src/ecc.c ****     if (R->key == NULL)
2117:../src/wolfcrypt/src/ecc.c **** #endif
2118:../src/wolfcrypt/src/ecc.c ****     {
2119:../src/wolfcrypt/src/ecc.c ****     #ifdef ALT_ECC_SIZE
2120:../src/wolfcrypt/src/ecc.c ****        XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
2121:../src/wolfcrypt/src/ecc.c ****        XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
2122:../src/wolfcrypt/src/ecc.c ****        XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
2123:../src/wolfcrypt/src/ecc.c ****     #endif
2124:../src/wolfcrypt/src/ecc.c ****        XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 1958                             		.loc 2 2124 8
 1959 008e ED A5 02                		mov.L	8[r10], r5
 1960 0091 E7 A5 03                		mov.L	r5, 12[r10]
 1961 0094 ED A5 03                		mov.L	12[r10], r5
 1962 0097 61 05                   		cmp	#0, r5
 1963 0099 10                      		beq	.L126
 1964                             		.loc 2 2124 8 is_stmt 0 discriminator 1
 1965 009a ED A1 03                		mov.L	12[r10], r1
 1966 009d 05 00 00 00             		bsr	_wolfSSL_Free
 1967                             	.L126:
 1968                             	.LBE14:
 1969                             	.LBB15:
2125:../src/wolfcrypt/src/ecc.c ****        XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 1970                             		.loc 2 2125 8 is_stmt 1
 1971 00a1 ED A5 01                		mov.L	4[r10], r5
 1972 00a4 E7 A5 04                		mov.L	r5, 16[r10]
 1973 00a7 ED A5 04                		mov.L	16[r10], r5
 1974 00aa 61 05                   		cmp	#0, r5
 1975 00ac 10                      		beq	.L127
 1976                             		.loc 2 2125 8 is_stmt 0 discriminator 1
 1977 00ad ED A1 04                		mov.L	16[r10], r1
 1978 00b0 05 00 00 00             		bsr	_wolfSSL_Free
 1979                             	.L127:
 1980                             	.LBE15:
2126:../src/wolfcrypt/src/ecc.c ****      }
2127:../src/wolfcrypt/src/ecc.c **** #endif
2128:../src/wolfcrypt/src/ecc.c ****       return err;
 1981                             		.loc 2 2128 14 is_stmt 1
 1982 00b4 EC A5                   		mov.L	[r10], r5
 1983 00b6 38 D8 02                		bra	.L124
 1984                             	.L125:
2129:../src/wolfcrypt/src/ecc.c ****    }
2130:../src/wolfcrypt/src/ecc.c **** 
2131:../src/wolfcrypt/src/ecc.c **** /* If use ALT_ECC_SIZE we need to use local stack variable since
2132:../src/wolfcrypt/src/ecc.c ****    ecc_point x,y,z is reduced size */
2133:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
2134:../src/wolfcrypt/src/ecc.c ****    /* Use local stack variable */
2135:../src/wolfcrypt/src/ecc.c ****    x = rx;
2136:../src/wolfcrypt/src/ecc.c ****    y = ry;
2137:../src/wolfcrypt/src/ecc.c ****    z = rz;
2138:../src/wolfcrypt/src/ecc.c **** 
2139:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_init_multi(x, y, z, NULL, NULL, NULL)) != MP_OKAY) {
2140:../src/wolfcrypt/src/ecc.c ****        mp_clear(t1);
2141:../src/wolfcrypt/src/ecc.c ****        mp_clear(t2);
2142:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
2143:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK_CACHE
2144:../src/wolfcrypt/src/ecc.c ****        if (R->key == NULL)
2145:../src/wolfcrypt/src/ecc.c ****     #endif
2146:../src/wolfcrypt/src/ecc.c ****        {
2147:../src/wolfcrypt/src/ecc.c ****        #ifdef ALT_ECC_SIZE
2148:../src/wolfcrypt/src/ecc.c ****           XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
2149:../src/wolfcrypt/src/ecc.c ****           XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
2150:../src/wolfcrypt/src/ecc.c ****           XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
2151:../src/wolfcrypt/src/ecc.c ****        #endif
2152:../src/wolfcrypt/src/ecc.c ****           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
2153:../src/wolfcrypt/src/ecc.c ****           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
2154:../src/wolfcrypt/src/ecc.c ****        }
2155:../src/wolfcrypt/src/ecc.c ****     #endif
2156:../src/wolfcrypt/src/ecc.c ****        return err;
2157:../src/wolfcrypt/src/ecc.c ****    }
2158:../src/wolfcrypt/src/ecc.c **** #else
2159:../src/wolfcrypt/src/ecc.c ****    /* Use destination directly */
2160:../src/wolfcrypt/src/ecc.c ****    x = R->x;
 1985                             		.loc 2 2160 6
 1986 00b9 ED A5 0D                		mov.L	52[r10], r5
 1987 00bc E7 A5 05                		mov.L	r5, 20[r10]
2161:../src/wolfcrypt/src/ecc.c ****    y = R->y;
 1988                             		.loc 2 2161 6
 1989 00bf ED A5 0D                		mov.L	52[r10], r5
 1990 00c2 72 55 10 03             		add	#0x310, r5
 1991 00c6 E7 A5 06                		mov.L	r5, 24[r10]
2162:../src/wolfcrypt/src/ecc.c ****    z = R->z;
 1992                             		.loc 2 2162 6
 1993 00c9 ED A5 0D                		mov.L	52[r10], r5
 1994 00cc 72 55 20 06             		add	#0x620, r5
 1995 00d0 E7 A5 07                		mov.L	r5, 28[r10]
2163:../src/wolfcrypt/src/ecc.c **** #endif
2164:../src/wolfcrypt/src/ecc.c **** 
2165:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 1996                             		.loc 2 2165 7
 1997 00d3 EC A5                   		mov.L	[r10], r5
 1998 00d5 61 05                   		cmp	#0, r5
 1999 00d7 21 10                   		bne	.L128
2166:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(P->x, x);
 2000                             		.loc 2 2166 23
 2001 00d9 ED A5 0C                		mov.L	48[r10], r5
 2002                             		.loc 2 2166 14
 2003 00dc ED A2 05                		mov.L	20[r10], r2
 2004 00df EF 51                   		mov.L	r5, r1
 2005 00e1 05 00 00 00             		bsr	_sp_copy
 2006 00e5 E3 A1                   		mov.L	r1, [r10]
 2007                             	.L128:
2167:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2008                             		.loc 2 2167 7
 2009 00e7 EC A5                   		mov.L	[r10], r5
 2010 00e9 61 05                   		cmp	#0, r5
 2011 00eb 21 14                   		bne	.L129
2168:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(P->y, y);
 2012                             		.loc 2 2168 23
 2013 00ed ED A5 0C                		mov.L	48[r10], r5
 2014 00f0 72 55 10 03             		add	#0x310, r5
 2015                             		.loc 2 2168 14
 2016 00f4 ED A2 06                		mov.L	24[r10], r2
 2017 00f7 EF 51                   		mov.L	r5, r1
 2018 00f9 05 00 00 00             		bsr	_sp_copy
 2019 00fd E3 A1                   		mov.L	r1, [r10]
 2020                             	.L129:
2169:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2021                             		.loc 2 2169 7
 2022 00ff EC A5                   		mov.L	[r10], r5
 2023 0101 61 05                   		cmp	#0, r5
 2024 0103 21 14                   		bne	.L130
2170:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(P->z, z);
 2025                             		.loc 2 2170 23
 2026 0105 ED A5 0C                		mov.L	48[r10], r5
 2027 0108 72 55 20 06             		add	#0x620, r5
 2028                             		.loc 2 2170 14
 2029 010c ED A2 07                		mov.L	28[r10], r2
 2030 010f EF 51                   		mov.L	r5, r1
 2031 0111 05 00 00 00             		bsr	_sp_copy
 2032 0115 E3 A1                   		mov.L	r1, [r10]
 2033                             	.L130:
2171:../src/wolfcrypt/src/ecc.c **** 
2172:../src/wolfcrypt/src/ecc.c ****    /* T1 = Z * Z */
2173:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2034                             		.loc 2 2173 7
 2035 0117 EC A5                   		mov.L	[r10], r5
 2036 0119 61 05                   		cmp	#0, r5
 2037 011b 21 0E                   		bne	.L131
2174:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(z, t1);
 2038                             		.loc 2 2174 14
 2039 011d ED A2 01                		mov.L	4[r10], r2
 2040 0120 ED A1 07                		mov.L	28[r10], r1
 2041 0123 05 00 00 00             		bsr	_sp_sqr
 2042 0127 E3 A1                   		mov.L	r1, [r10]
 2043                             	.L131:
2175:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2044                             		.loc 2 2175 7
 2045 0129 EC A5                   		mov.L	[r10], r5
 2046 012b 61 05                   		cmp	#0, r5
 2047 012d 21 10                   		bne	.L132
2176:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t1, modulus, mp);
 2048                             		.loc 2 2176 14
 2049 012f EC 63                   		mov.L	[r6], r3
 2050 0131 ED A2 0F                		mov.L	60[r10], r2
 2051 0134 ED A1 01                		mov.L	4[r10], r1
 2052 0137 05 00 00 00             		bsr	_sp_mont_red
 2053 013b E3 A1                   		mov.L	r1, [r10]
 2054                             	.L132:
2177:../src/wolfcrypt/src/ecc.c **** 
2178:../src/wolfcrypt/src/ecc.c ****    /* Z = Y * Z */
2179:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2055                             		.loc 2 2179 7
 2056 013d EC A5                   		mov.L	[r10], r5
 2057 013f 61 05                   		cmp	#0, r5
 2058 0141 21 11                   		bne	.L133
2180:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(z, y, z);
 2059                             		.loc 2 2180 14
 2060 0143 ED A3 07                		mov.L	28[r10], r3
 2061 0146 ED A2 06                		mov.L	24[r10], r2
 2062 0149 ED A1 07                		mov.L	28[r10], r1
 2063 014c 05 00 00 00             		bsr	_sp_mul
 2064 0150 E3 A1                   		mov.L	r1, [r10]
 2065                             	.L133:
2181:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2066                             		.loc 2 2181 7
 2067 0152 EC A5                   		mov.L	[r10], r5
 2068 0154 61 05                   		cmp	#0, r5
 2069 0156 21 10                   		bne	.L134
2182:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(z, modulus, mp);
 2070                             		.loc 2 2182 14
 2071 0158 EC 63                   		mov.L	[r6], r3
 2072 015a ED A2 0F                		mov.L	60[r10], r2
 2073 015d ED A1 07                		mov.L	28[r10], r1
 2074 0160 05 00 00 00             		bsr	_sp_mont_red
 2075 0164 E3 A1                   		mov.L	r1, [r10]
 2076                             	.L134:
2183:../src/wolfcrypt/src/ecc.c **** 
2184:../src/wolfcrypt/src/ecc.c ****    /* Z = 2Z */
2185:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2077                             		.loc 2 2185 7
 2078 0166 EC A5                   		mov.L	[r10], r5
 2079 0168 61 05                   		cmp	#0, r5
 2080 016a 21 14                   		bne	.L135
2186:../src/wolfcrypt/src/ecc.c ****        err = mp_addmod_ct(z, z, modulus, z);
 2081                             		.loc 2 2186 14
 2082 016c ED A4 07                		mov.L	28[r10], r4
 2083 016f ED A3 0F                		mov.L	60[r10], r3
 2084 0172 ED A2 07                		mov.L	28[r10], r2
 2085 0175 ED A1 07                		mov.L	28[r10], r1
 2086 0178 05 00 00 00             		bsr	_sp_addmod_ct
 2087 017c E3 A1                   		mov.L	r1, [r10]
 2088                             	.L135:
2187:../src/wolfcrypt/src/ecc.c **** 
2188:../src/wolfcrypt/src/ecc.c ****    /* Determine if curve "a" should be used in calc */
2189:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CUSTOM_CURVES
2190:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
2191:../src/wolfcrypt/src/ecc.c ****       /* Use a and prime to determine if a == 3 */
2192:../src/wolfcrypt/src/ecc.c ****       err = mp_submod(modulus, a, modulus, t2);
2193:../src/wolfcrypt/src/ecc.c ****    }
2194:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY && mp_iszero(t2)) {
2195:../src/wolfcrypt/src/ecc.c ****       /* T2 = X * X */
2196:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2197:../src/wolfcrypt/src/ecc.c ****           err = mp_sqr(x, t2);
2198:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2199:../src/wolfcrypt/src/ecc.c ****           err = mp_montgomery_reduce(t2, modulus, mp);
2200:../src/wolfcrypt/src/ecc.c ****       /* T1 = T2 + T1 */
2201:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2202:../src/wolfcrypt/src/ecc.c ****           err = mp_addmod_ct(t2, t2, modulus, t1);
2203:../src/wolfcrypt/src/ecc.c ****       /* T1 = T2 + T1 */
2204:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2205:../src/wolfcrypt/src/ecc.c ****           err = mp_addmod_ct(t1, t2, modulus, t1);
2206:../src/wolfcrypt/src/ecc.c ****    }
2207:../src/wolfcrypt/src/ecc.c ****    else if (err == MP_OKAY && mp_cmp_d(t2, 3) != MP_EQ) {
2208:../src/wolfcrypt/src/ecc.c ****       /* use "a" in calc */
2209:../src/wolfcrypt/src/ecc.c **** 
2210:../src/wolfcrypt/src/ecc.c ****       /* T2 = T1 * T1 */
2211:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2212:../src/wolfcrypt/src/ecc.c ****           err = mp_sqr(t1, t2);
2213:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2214:../src/wolfcrypt/src/ecc.c ****           err = mp_montgomery_reduce(t2, modulus, mp);
2215:../src/wolfcrypt/src/ecc.c ****       /* T1 = T2 * a */
2216:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2217:../src/wolfcrypt/src/ecc.c ****           err = mp_mulmod(t2, a, modulus, t1);
2218:../src/wolfcrypt/src/ecc.c ****       /* T2 = X * X */
2219:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2220:../src/wolfcrypt/src/ecc.c ****           err = mp_sqr(x, t2);
2221:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2222:../src/wolfcrypt/src/ecc.c ****           err = mp_montgomery_reduce(t2, modulus, mp);
2223:../src/wolfcrypt/src/ecc.c ****       /* T1 = T2 + T1 */
2224:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2225:../src/wolfcrypt/src/ecc.c ****           err = mp_addmod_ct(t1, t2, modulus, t1);
2226:../src/wolfcrypt/src/ecc.c ****       /* T1 = T2 + T1 */
2227:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2228:../src/wolfcrypt/src/ecc.c ****           err = mp_addmod_ct(t1, t2, modulus, t1);
2229:../src/wolfcrypt/src/ecc.c ****       /* T1 = T2 + T1 */
2230:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
2231:../src/wolfcrypt/src/ecc.c ****           err = mp_addmod_ct(t1, t2, modulus, t1);
2232:../src/wolfcrypt/src/ecc.c ****    }
2233:../src/wolfcrypt/src/ecc.c ****    else
2234:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_CUSTOM_CURVES */
2235:../src/wolfcrypt/src/ecc.c ****    {
2236:../src/wolfcrypt/src/ecc.c ****       /* assumes "a" == 3 */
2237:../src/wolfcrypt/src/ecc.c ****       (void)a;
2238:../src/wolfcrypt/src/ecc.c **** 
2239:../src/wolfcrypt/src/ecc.c ****       /* T2 = X - T1 */
2240:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 2089                             		.loc 2 2240 10
 2090 017e EC A5                   		mov.L	[r10], r5
 2091 0180 61 05                   		cmp	#0, r5
 2092 0182 21 14                   		bne	.L136
2241:../src/wolfcrypt/src/ecc.c ****           err = mp_submod_ct(x, t1, modulus, t2);
 2093                             		.loc 2 2241 17
 2094 0184 ED A4 02                		mov.L	8[r10], r4
 2095 0187 ED A3 0F                		mov.L	60[r10], r3
 2096 018a ED A2 01                		mov.L	4[r10], r2
 2097 018d ED A1 05                		mov.L	20[r10], r1
 2098 0190 05 00 00 00             		bsr	_sp_submod_ct
 2099 0194 E3 A1                   		mov.L	r1, [r10]
 2100                             	.L136:
2242:../src/wolfcrypt/src/ecc.c ****       /* T1 = X + T1 */
2243:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 2101                             		.loc 2 2243 10
 2102 0196 EC A5                   		mov.L	[r10], r5
 2103 0198 61 05                   		cmp	#0, r5
 2104 019a 21 14                   		bne	.L137
2244:../src/wolfcrypt/src/ecc.c ****           err = mp_addmod_ct(t1, x, modulus, t1);
 2105                             		.loc 2 2244 17
 2106 019c ED A4 01                		mov.L	4[r10], r4
 2107 019f ED A3 0F                		mov.L	60[r10], r3
 2108 01a2 ED A2 05                		mov.L	20[r10], r2
 2109 01a5 ED A1 01                		mov.L	4[r10], r1
 2110 01a8 05 00 00 00             		bsr	_sp_addmod_ct
 2111 01ac E3 A1                   		mov.L	r1, [r10]
 2112                             	.L137:
2245:../src/wolfcrypt/src/ecc.c ****       /* T2 = T1 * T2 */
2246:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 2113                             		.loc 2 2246 10
 2114 01ae EC A5                   		mov.L	[r10], r5
 2115 01b0 61 05                   		cmp	#0, r5
 2116 01b2 21 11                   		bne	.L138
2247:../src/wolfcrypt/src/ecc.c ****           err = mp_mul(t1, t2, t2);
 2117                             		.loc 2 2247 17
 2118 01b4 ED A3 02                		mov.L	8[r10], r3
 2119 01b7 ED A2 02                		mov.L	8[r10], r2
 2120 01ba ED A1 01                		mov.L	4[r10], r1
 2121 01bd 05 00 00 00             		bsr	_sp_mul
 2122 01c1 E3 A1                   		mov.L	r1, [r10]
 2123                             	.L138:
2248:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 2124                             		.loc 2 2248 10
 2125 01c3 EC A5                   		mov.L	[r10], r5
 2126 01c5 61 05                   		cmp	#0, r5
 2127 01c7 21 10                   		bne	.L139
2249:../src/wolfcrypt/src/ecc.c ****           err = mp_montgomery_reduce(t2, modulus, mp);
 2128                             		.loc 2 2249 17
 2129 01c9 EC 63                   		mov.L	[r6], r3
 2130 01cb ED A2 0F                		mov.L	60[r10], r2
 2131 01ce ED A1 02                		mov.L	8[r10], r1
 2132 01d1 05 00 00 00             		bsr	_sp_mont_red
 2133 01d5 E3 A1                   		mov.L	r1, [r10]
 2134                             	.L139:
2250:../src/wolfcrypt/src/ecc.c **** 
2251:../src/wolfcrypt/src/ecc.c ****       /* T1 = 2T2 */
2252:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 2135                             		.loc 2 2252 10
 2136 01d7 EC A5                   		mov.L	[r10], r5
 2137 01d9 61 05                   		cmp	#0, r5
 2138 01db 21 14                   		bne	.L140
2253:../src/wolfcrypt/src/ecc.c ****           err = mp_addmod_ct(t2, t2, modulus, t1);
 2139                             		.loc 2 2253 17
 2140 01dd ED A4 01                		mov.L	4[r10], r4
 2141 01e0 ED A3 0F                		mov.L	60[r10], r3
 2142 01e3 ED A2 02                		mov.L	8[r10], r2
 2143 01e6 ED A1 02                		mov.L	8[r10], r1
 2144 01e9 05 00 00 00             		bsr	_sp_addmod_ct
 2145 01ed E3 A1                   		mov.L	r1, [r10]
 2146                             	.L140:
2254:../src/wolfcrypt/src/ecc.c ****       /* T1 = T1 + T2 */
2255:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 2147                             		.loc 2 2255 10
 2148 01ef EC A5                   		mov.L	[r10], r5
 2149 01f1 61 05                   		cmp	#0, r5
 2150 01f3 21 14                   		bne	.L141
2256:../src/wolfcrypt/src/ecc.c ****           err = mp_addmod_ct(t1, t2, modulus, t1);
 2151                             		.loc 2 2256 17
 2152 01f5 ED A4 01                		mov.L	4[r10], r4
 2153 01f8 ED A3 0F                		mov.L	60[r10], r3
 2154 01fb ED A2 02                		mov.L	8[r10], r2
 2155 01fe ED A1 01                		mov.L	4[r10], r1
 2156 0201 05 00 00 00             		bsr	_sp_addmod_ct
 2157 0205 E3 A1                   		mov.L	r1, [r10]
 2158                             	.L141:
2257:../src/wolfcrypt/src/ecc.c ****    }
2258:../src/wolfcrypt/src/ecc.c **** 
2259:../src/wolfcrypt/src/ecc.c ****    /* Y = 2Y */
2260:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2159                             		.loc 2 2260 7
 2160 0207 EC A5                   		mov.L	[r10], r5
 2161 0209 61 05                   		cmp	#0, r5
 2162 020b 21 14                   		bne	.L142
2261:../src/wolfcrypt/src/ecc.c ****        err = mp_addmod_ct(y, y, modulus, y);
 2163                             		.loc 2 2261 14
 2164 020d ED A4 06                		mov.L	24[r10], r4
 2165 0210 ED A3 0F                		mov.L	60[r10], r3
 2166 0213 ED A2 06                		mov.L	24[r10], r2
 2167 0216 ED A1 06                		mov.L	24[r10], r1
 2168 0219 05 00 00 00             		bsr	_sp_addmod_ct
 2169 021d E3 A1                   		mov.L	r1, [r10]
 2170                             	.L142:
2262:../src/wolfcrypt/src/ecc.c ****    /* Y = Y * Y */
2263:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2171                             		.loc 2 2263 7
 2172 021f EC A5                   		mov.L	[r10], r5
 2173 0221 61 05                   		cmp	#0, r5
 2174 0223 21 0E                   		bne	.L143
2264:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(y, y);
 2175                             		.loc 2 2264 14
 2176 0225 ED A2 06                		mov.L	24[r10], r2
 2177 0228 ED A1 06                		mov.L	24[r10], r1
 2178 022b 05 00 00 00             		bsr	_sp_sqr
 2179 022f E3 A1                   		mov.L	r1, [r10]
 2180                             	.L143:
2265:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2181                             		.loc 2 2265 7
 2182 0231 EC A5                   		mov.L	[r10], r5
 2183 0233 61 05                   		cmp	#0, r5
 2184 0235 21 10                   		bne	.L144
2266:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(y, modulus, mp);
 2185                             		.loc 2 2266 14
 2186 0237 EC 63                   		mov.L	[r6], r3
 2187 0239 ED A2 0F                		mov.L	60[r10], r2
 2188 023c ED A1 06                		mov.L	24[r10], r1
 2189 023f 05 00 00 00             		bsr	_sp_mont_red
 2190 0243 E3 A1                   		mov.L	r1, [r10]
 2191                             	.L144:
2267:../src/wolfcrypt/src/ecc.c **** 
2268:../src/wolfcrypt/src/ecc.c ****    /* T2 = Y * Y */
2269:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2192                             		.loc 2 2269 7
 2193 0245 EC A5                   		mov.L	[r10], r5
 2194 0247 61 05                   		cmp	#0, r5
 2195 0249 21 0E                   		bne	.L145
2270:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(y, t2);
 2196                             		.loc 2 2270 14
 2197 024b ED A2 02                		mov.L	8[r10], r2
 2198 024e ED A1 06                		mov.L	24[r10], r1
 2199 0251 05 00 00 00             		bsr	_sp_sqr
 2200 0255 E3 A1                   		mov.L	r1, [r10]
 2201                             	.L145:
2271:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2202                             		.loc 2 2271 7
 2203 0257 EC A5                   		mov.L	[r10], r5
 2204 0259 61 05                   		cmp	#0, r5
 2205 025b 21 10                   		bne	.L146
2272:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(t2, modulus, mp);
 2206                             		.loc 2 2272 14
 2207 025d EC 63                   		mov.L	[r6], r3
 2208 025f ED A2 0F                		mov.L	60[r10], r2
 2209 0262 ED A1 02                		mov.L	8[r10], r1
 2210 0265 05 00 00 00             		bsr	_sp_mont_red
 2211 0269 E3 A1                   		mov.L	r1, [r10]
 2212                             	.L146:
2273:../src/wolfcrypt/src/ecc.c **** 
2274:../src/wolfcrypt/src/ecc.c ****    /* T2 = T2/2 */
2275:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2213                             		.loc 2 2275 7
 2214 026b EC A5                   		mov.L	[r10], r5
 2215 026d 61 05                   		cmp	#0, r5
 2216 026f 21 11                   		bne	.L147
2276:../src/wolfcrypt/src/ecc.c ****        err = mp_div_2_mod_ct(t2, modulus, t2);
 2217                             		.loc 2 2276 14
 2218 0271 ED A3 02                		mov.L	8[r10], r3
 2219 0274 ED A2 0F                		mov.L	60[r10], r2
 2220 0277 ED A1 02                		mov.L	8[r10], r1
 2221 027a 05 00 00 00             		bsr	_sp_div_2_mod_ct
 2222 027e E3 A1                   		mov.L	r1, [r10]
 2223                             	.L147:
2277:../src/wolfcrypt/src/ecc.c **** 
2278:../src/wolfcrypt/src/ecc.c ****    /* Y = Y * X */
2279:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2224                             		.loc 2 2279 7
 2225 0280 EC A5                   		mov.L	[r10], r5
 2226 0282 61 05                   		cmp	#0, r5
 2227 0284 21 11                   		bne	.L148
2280:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(y, x, y);
 2228                             		.loc 2 2280 14
 2229 0286 ED A3 06                		mov.L	24[r10], r3
 2230 0289 ED A2 05                		mov.L	20[r10], r2
 2231 028c ED A1 06                		mov.L	24[r10], r1
 2232 028f 05 00 00 00             		bsr	_sp_mul
 2233 0293 E3 A1                   		mov.L	r1, [r10]
 2234                             	.L148:
2281:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2235                             		.loc 2 2281 7
 2236 0295 EC A5                   		mov.L	[r10], r5
 2237 0297 61 05                   		cmp	#0, r5
 2238 0299 21 10                   		bne	.L149
2282:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(y, modulus, mp);
 2239                             		.loc 2 2282 14
 2240 029b EC 63                   		mov.L	[r6], r3
 2241 029d ED A2 0F                		mov.L	60[r10], r2
 2242 02a0 ED A1 06                		mov.L	24[r10], r1
 2243 02a3 05 00 00 00             		bsr	_sp_mont_red
 2244 02a7 E3 A1                   		mov.L	r1, [r10]
 2245                             	.L149:
2283:../src/wolfcrypt/src/ecc.c **** 
2284:../src/wolfcrypt/src/ecc.c ****    /* X = T1 * T1 */
2285:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2246                             		.loc 2 2285 7
 2247 02a9 EC A5                   		mov.L	[r10], r5
 2248 02ab 61 05                   		cmp	#0, r5
 2249 02ad 21 0E                   		bne	.L150
2286:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(t1, x);
 2250                             		.loc 2 2286 14
 2251 02af ED A2 05                		mov.L	20[r10], r2
 2252 02b2 ED A1 01                		mov.L	4[r10], r1
 2253 02b5 05 00 00 00             		bsr	_sp_sqr
 2254 02b9 E3 A1                   		mov.L	r1, [r10]
 2255                             	.L150:
2287:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2256                             		.loc 2 2287 7
 2257 02bb EC A5                   		mov.L	[r10], r5
 2258 02bd 61 05                   		cmp	#0, r5
 2259 02bf 21 10                   		bne	.L151
2288:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(x, modulus, mp);
 2260                             		.loc 2 2288 14
 2261 02c1 EC 63                   		mov.L	[r6], r3
 2262 02c3 ED A2 0F                		mov.L	60[r10], r2
 2263 02c6 ED A1 05                		mov.L	20[r10], r1
 2264 02c9 05 00 00 00             		bsr	_sp_mont_red
 2265 02cd E3 A1                   		mov.L	r1, [r10]
 2266                             	.L151:
2289:../src/wolfcrypt/src/ecc.c **** 
2290:../src/wolfcrypt/src/ecc.c ****    /* X = X - Y */
2291:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2267                             		.loc 2 2291 7
 2268 02cf EC A5                   		mov.L	[r10], r5
 2269 02d1 61 05                   		cmp	#0, r5
 2270 02d3 21 14                   		bne	.L152
2292:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(x, y, modulus, x);
 2271                             		.loc 2 2292 14
 2272 02d5 ED A4 05                		mov.L	20[r10], r4
 2273 02d8 ED A3 0F                		mov.L	60[r10], r3
 2274 02db ED A2 06                		mov.L	24[r10], r2
 2275 02de ED A1 05                		mov.L	20[r10], r1
 2276 02e1 05 00 00 00             		bsr	_sp_submod_ct
 2277 02e5 E3 A1                   		mov.L	r1, [r10]
 2278                             	.L152:
2293:../src/wolfcrypt/src/ecc.c ****    /* X = X - Y */
2294:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2279                             		.loc 2 2294 7
 2280 02e7 EC A5                   		mov.L	[r10], r5
 2281 02e9 61 05                   		cmp	#0, r5
 2282 02eb 21 14                   		bne	.L153
2295:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(x, y, modulus, x);
 2283                             		.loc 2 2295 14
 2284 02ed ED A4 05                		mov.L	20[r10], r4
 2285 02f0 ED A3 0F                		mov.L	60[r10], r3
 2286 02f3 ED A2 06                		mov.L	24[r10], r2
 2287 02f6 ED A1 05                		mov.L	20[r10], r1
 2288 02f9 05 00 00 00             		bsr	_sp_submod_ct
 2289 02fd E3 A1                   		mov.L	r1, [r10]
 2290                             	.L153:
2296:../src/wolfcrypt/src/ecc.c **** 
2297:../src/wolfcrypt/src/ecc.c ****    /* Y = Y - X */
2298:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2291                             		.loc 2 2298 7
 2292 02ff EC A5                   		mov.L	[r10], r5
 2293 0301 61 05                   		cmp	#0, r5
 2294 0303 21 14                   		bne	.L154
2299:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(y, x, modulus, y);
 2295                             		.loc 2 2299 14
 2296 0305 ED A4 06                		mov.L	24[r10], r4
 2297 0308 ED A3 0F                		mov.L	60[r10], r3
 2298 030b ED A2 05                		mov.L	20[r10], r2
 2299 030e ED A1 06                		mov.L	24[r10], r1
 2300 0311 05 00 00 00             		bsr	_sp_submod_ct
 2301 0315 E3 A1                   		mov.L	r1, [r10]
 2302                             	.L154:
2300:../src/wolfcrypt/src/ecc.c ****    /* Y = Y * T1 */
2301:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2303                             		.loc 2 2301 7
 2304 0317 EC A5                   		mov.L	[r10], r5
 2305 0319 61 05                   		cmp	#0, r5
 2306 031b 21 11                   		bne	.L155
2302:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(y, t1, y);
 2307                             		.loc 2 2302 14
 2308 031d ED A3 06                		mov.L	24[r10], r3
 2309 0320 ED A2 01                		mov.L	4[r10], r2
 2310 0323 ED A1 06                		mov.L	24[r10], r1
 2311 0326 05 00 00 00             		bsr	_sp_mul
 2312 032a E3 A1                   		mov.L	r1, [r10]
 2313                             	.L155:
2303:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2314                             		.loc 2 2303 7
 2315 032c EC A5                   		mov.L	[r10], r5
 2316 032e 61 05                   		cmp	#0, r5
 2317 0330 21 10                   		bne	.L156
2304:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(y, modulus, mp);
 2318                             		.loc 2 2304 14
 2319 0332 EC 63                   		mov.L	[r6], r3
 2320 0334 ED A2 0F                		mov.L	60[r10], r2
 2321 0337 ED A1 06                		mov.L	24[r10], r1
 2322 033a 05 00 00 00             		bsr	_sp_mont_red
 2323 033e E3 A1                   		mov.L	r1, [r10]
 2324                             	.L156:
2305:../src/wolfcrypt/src/ecc.c **** 
2306:../src/wolfcrypt/src/ecc.c ****    /* Y = Y - T2 */
2307:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2325                             		.loc 2 2307 7
 2326 0340 EC A5                   		mov.L	[r10], r5
 2327 0342 61 05                   		cmp	#0, r5
 2328 0344 21 14                   		bne	.L157
2308:../src/wolfcrypt/src/ecc.c ****        err = mp_submod_ct(y, t2, modulus, y);
 2329                             		.loc 2 2308 14
 2330 0346 ED A4 06                		mov.L	24[r10], r4
 2331 0349 ED A3 0F                		mov.L	60[r10], r3
 2332 034c ED A2 02                		mov.L	8[r10], r2
 2333 034f ED A1 06                		mov.L	24[r10], r1
 2334 0352 05 00 00 00             		bsr	_sp_submod_ct
 2335 0356 E3 A1                   		mov.L	r1, [r10]
 2336                             	.L157:
2309:../src/wolfcrypt/src/ecc.c **** 
2310:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
2311:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2312:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(x, R->x);
2313:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2314:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(y, R->y);
2315:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2316:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(z, R->z);
2317:../src/wolfcrypt/src/ecc.c **** #endif
2318:../src/wolfcrypt/src/ecc.c **** 
2319:../src/wolfcrypt/src/ecc.c ****    /* clean up */
2320:../src/wolfcrypt/src/ecc.c ****    mp_clear(t1);
 2337                             		.loc 2 2320 4
 2338 0358 ED A1 01                		mov.L	4[r10], r1
 2339 035b 05 00 00 00             		bsr	_sp_clear
2321:../src/wolfcrypt/src/ecc.c ****    mp_clear(t2);
 2340                             		.loc 2 2321 4
 2341 035f ED A1 02                		mov.L	8[r10], r1
 2342 0362 05 00 00 00             		bsr	_sp_clear
 2343                             	.LBB16:
2322:../src/wolfcrypt/src/ecc.c **** 
2323:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2324:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
2325:../src/wolfcrypt/src/ecc.c ****    if (R->key == NULL)
2326:../src/wolfcrypt/src/ecc.c **** #endif
2327:../src/wolfcrypt/src/ecc.c ****    {
2328:../src/wolfcrypt/src/ecc.c ****     #ifdef ALT_ECC_SIZE
2329:../src/wolfcrypt/src/ecc.c ****        XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
2330:../src/wolfcrypt/src/ecc.c ****        XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
2331:../src/wolfcrypt/src/ecc.c ****        XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
2332:../src/wolfcrypt/src/ecc.c ****     #endif
2333:../src/wolfcrypt/src/ecc.c ****        XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 2344                             		.loc 2 2333 8
 2345 0366 ED A5 02                		mov.L	8[r10], r5
 2346 0369 E7 A5 08                		mov.L	r5, 32[r10]
 2347 036c ED A5 08                		mov.L	32[r10], r5
 2348 036f 61 05                   		cmp	#0, r5
 2349 0371 10                      		beq	.L158
 2350                             		.loc 2 2333 8 is_stmt 0 discriminator 1
 2351 0372 ED A1 08                		mov.L	32[r10], r1
 2352 0375 05 00 00 00             		bsr	_wolfSSL_Free
 2353                             	.L158:
 2354                             	.LBE16:
 2355                             	.LBB17:
2334:../src/wolfcrypt/src/ecc.c ****        XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 2356                             		.loc 2 2334 8 is_stmt 1
 2357 0379 ED A5 01                		mov.L	4[r10], r5
 2358 037c E7 A5 09                		mov.L	r5, 36[r10]
 2359 037f ED A5 09                		mov.L	36[r10], r5
 2360 0382 61 05                   		cmp	#0, r5
 2361 0384 10                      		beq	.L159
 2362                             		.loc 2 2334 8 is_stmt 0 discriminator 1
 2363 0385 ED A1 09                		mov.L	36[r10], r1
 2364 0388 05 00 00 00             		bsr	_wolfSSL_Free
 2365                             	.L159:
 2366                             	.LBE17:
2335:../src/wolfcrypt/src/ecc.c ****     }
2336:../src/wolfcrypt/src/ecc.c **** #endif
2337:../src/wolfcrypt/src/ecc.c **** 
2338:../src/wolfcrypt/src/ecc.c ****    return err;
 2367                             		.loc 2 2338 11 is_stmt 1
 2368 038c EC A5                   		mov.L	[r10], r5
 2369                             	.L124:
2339:../src/wolfcrypt/src/ecc.c **** #else
2340:../src/wolfcrypt/src/ecc.c ****     int modBits = mp_count_bits(modulus);
2341:../src/wolfcrypt/src/ecc.c **** 
2342:../src/wolfcrypt/src/ecc.c ****     (void)a;
2343:../src/wolfcrypt/src/ecc.c ****     (void)mp;
2344:../src/wolfcrypt/src/ecc.c **** 
2345:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
2346:../src/wolfcrypt/src/ecc.c ****     if (modBits == 256) {
2347:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_proj_dbl_point_256(P->x, P->y, P->z, R->x, R->y, R->z);
2348:../src/wolfcrypt/src/ecc.c ****     }
2349:../src/wolfcrypt/src/ecc.c **** #endif
2350:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
2351:../src/wolfcrypt/src/ecc.c ****     if (modBits == 384) {
2352:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_proj_dbl_point_384(P->x, P->y, P->z, R->x, R->y, R->z);
2353:../src/wolfcrypt/src/ecc.c ****     }
2354:../src/wolfcrypt/src/ecc.c **** #endif
2355:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
2356:../src/wolfcrypt/src/ecc.c ****     if (modBits == 521) {
2357:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_proj_dbl_point_521(P->x, P->y, P->z, R->x, R->y, R->z);
2358:../src/wolfcrypt/src/ecc.c ****     }
2359:../src/wolfcrypt/src/ecc.c **** #endif
2360:../src/wolfcrypt/src/ecc.c ****     return ECC_BAD_ARG_E;
2361:../src/wolfcrypt/src/ecc.c **** #endif
2362:../src/wolfcrypt/src/ecc.c **** }
 2370                             		.loc 2 2362 1
 2371 038e EF 51                   		mov.L	r5, r1
 2372 0390 71 00 4C                		add	#0x4c, r0
 2373 0393 7E B6                   		pop	r6
 2374 0395 7E BA                   		pop	r10
 2375 0397 02                      		rts
 2376                             	.LFE52:
 2378                             		.section	.text.ecc_projective_dbl_point,"ax",@progbits
 2379                             		.global	_ecc_projective_dbl_point
 2381                             	_ecc_projective_dbl_point:
 2382                             	.LFB53:
2363:../src/wolfcrypt/src/ecc.c **** 
2364:../src/wolfcrypt/src/ecc.c **** int ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,
2365:../src/wolfcrypt/src/ecc.c ****                              mp_int* modulus, mp_digit mp)
2366:../src/wolfcrypt/src/ecc.c **** {
 2383                             		.loc 2 2366 1
 2384 0000 7E AA                   		push.l	r10
 2385                             	.LCFI28:
 2386 0002 7E A6                   		push.l	r6
 2387                             	.LCFI29:
 2388 0004 71 0A EC                		add	#-20, r0, r10
 2389                             	.LCFI30:
 2390 0007 71 A0 FC                		add	#-4, r10, r0
 2391                             	.LCFI31:
 2392 000a 75 46 20                		mov.L	#32, r6
 2393 000d 4B A6                   		add	r10, r6
 2394 000f E3 A1                   		mov.L	r1, [r10]
 2395 0011 E7 A2 01                		mov.L	r2, 4[r10]
 2396 0014 E7 A3 02                		mov.L	r3, 8[r10]
 2397 0017 E7 A4 03                		mov.L	r4, 12[r10]
2367:../src/wolfcrypt/src/ecc.c ****     if (P == NULL || R == NULL || modulus == NULL)
 2398                             		.loc 2 2367 8
 2399 001a EC A5                   		mov.L	[r10], r5
 2400 001c 61 05                   		cmp	#0, r5
 2401 001e 20 0E                   		beq	.L161
 2402                             		.loc 2 2367 19 discriminator 1
 2403 0020 ED A5 01                		mov.L	4[r10], r5
 2404 0023 61 05                   		cmp	#0, r5
 2405 0025 17                      		beq	.L161
 2406                             		.loc 2 2367 32 discriminator 2
 2407 0026 ED A5 03                		mov.L	12[r10], r5
 2408 0029 61 05                   		cmp	#0, r5
 2409 002b 1F                      		bne	.L162
 2410                             	.L161:
2368:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 2411                             		.loc 2 2368 16
 2412 002c FB 5A 56 FF             		mov.L	#-170, r5
 2413 0030 2E 5A                   		bra	.L163
 2414                             	.L162:
2369:../src/wolfcrypt/src/ecc.c **** 
2370:../src/wolfcrypt/src/ecc.c ****     if (mp_cmp(P->x, modulus) != MP_LT ||
 2415                             		.loc 2 2370 17
 2416 0032 EC A5                   		mov.L	[r10], r5
 2417                             		.loc 2 2370 9
 2418 0034 ED A2 03                		mov.L	12[r10], r2
 2419 0037 EF 51                   		mov.L	r5, r1
 2420 0039 05 00 00 00             		bsr	_sp_cmp
 2421 003d EF 15                   		mov.L	r1, r5
 2422                             		.loc 2 2370 8
 2423 003f 75 05 FF                		cmp	#-1, r5
 2424 0042 21 2D                   		bne	.L164
2371:../src/wolfcrypt/src/ecc.c ****         mp_cmp(P->y, modulus) != MP_LT ||
 2425                             		.loc 2 2371 17 discriminator 1
 2426 0044 EC A5                   		mov.L	[r10], r5
 2427 0046 72 55 10 03             		add	#0x310, r5
 2428                             		.loc 2 2371 9 discriminator 1
 2429 004a ED A2 03                		mov.L	12[r10], r2
 2430 004d EF 51                   		mov.L	r5, r1
 2431 004f 05 00 00 00             		bsr	_sp_cmp
 2432 0053 EF 15                   		mov.L	r1, r5
2370:../src/wolfcrypt/src/ecc.c ****         mp_cmp(P->y, modulus) != MP_LT ||
 2433                             		.loc 2 2370 40 discriminator 1
 2434 0055 75 05 FF                		cmp	#-1, r5
 2435 0058 21 17                   		bne	.L164
2372:../src/wolfcrypt/src/ecc.c ****         mp_cmp(P->z, modulus) != MP_LT) {
 2436                             		.loc 2 2372 17
 2437 005a EC A5                   		mov.L	[r10], r5
 2438 005c 72 55 20 06             		add	#0x620, r5
 2439                             		.loc 2 2372 9
 2440 0060 ED A2 03                		mov.L	12[r10], r2
 2441 0063 EF 51                   		mov.L	r5, r1
 2442 0065 05 00 00 00             		bsr	_sp_cmp
 2443 0069 EF 15                   		mov.L	r1, r5
2371:../src/wolfcrypt/src/ecc.c ****         mp_cmp(P->y, modulus) != MP_LT ||
 2444                             		.loc 2 2371 40
 2445 006b 75 05 FF                		cmp	#-1, r5
 2446 006e 17                      		beq	.L165
 2447                             	.L164:
2373:../src/wolfcrypt/src/ecc.c ****         return ECC_OUT_OF_RANGE_E;
 2448                             		.loc 2 2373 16
 2449 006f FB 5A 27 FF             		mov.L	#-217, r5
 2450 0073 2E 17                   		bra	.L163
 2451                             	.L165:
2374:../src/wolfcrypt/src/ecc.c ****     }
2375:../src/wolfcrypt/src/ecc.c **** 
2376:../src/wolfcrypt/src/ecc.c ****     return _ecc_projective_dbl_point(P, R, a, modulus, mp);
 2452                             		.loc 2 2376 12
 2453 0075 EC 65                   		mov.L	[r6], r5
 2454 0077 E3 05                   		mov.L	r5, [r0]
 2455 0079 ED A4 03                		mov.L	12[r10], r4
 2456 007c ED A3 02                		mov.L	8[r10], r3
 2457 007f ED A2 01                		mov.L	4[r10], r2
 2458 0082 EC A1                   		mov.L	[r10], r1
 2459 0084 05 00 00 00             		bsr	__ecc_projective_dbl_point
 2460 0088 EF 15                   		mov.L	r1, r5
 2461                             	.L163:
2377:../src/wolfcrypt/src/ecc.c **** }
 2462                             		.loc 2 2377 1
 2463 008a EF 51                   		mov.L	r5, r1
 2464 008c 71 00 18                		add	#24, r0
 2465 008f 7E B6                   		pop	r6
 2466 0091 7E BA                   		pop	r10
 2467 0093 02                      		rts
 2468                             	.LFE53:
 2470                             		.section	.text.ecc_map_ex,"ax",@progbits
 2471                             		.global	_ecc_map_ex
 2473                             	_ecc_map_ex:
 2474                             	.LFB54:
2378:../src/wolfcrypt/src/ecc.c **** 
2379:../src/wolfcrypt/src/ecc.c **** #if !defined(FREESCALE_LTC_ECC) && !defined(WOLFSSL_STM32_PKA) && \
2380:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL)
2381:../src/wolfcrypt/src/ecc.c **** 
2382:../src/wolfcrypt/src/ecc.c **** 
2383:../src/wolfcrypt/src/ecc.c **** /**
2384:../src/wolfcrypt/src/ecc.c ****   Map a projective Jacobian point back to affine space
2385:../src/wolfcrypt/src/ecc.c ****   P        [in/out] The point to map
2386:../src/wolfcrypt/src/ecc.c ****   modulus  The modulus of the field the ECC curve is in
2387:../src/wolfcrypt/src/ecc.c ****   mp       The "b" value from montgomery_setup()
2388:../src/wolfcrypt/src/ecc.c ****   ct       Operation should be constant time.
2389:../src/wolfcrypt/src/ecc.c ****   return   MP_OKAY on success
2390:../src/wolfcrypt/src/ecc.c **** */
2391:../src/wolfcrypt/src/ecc.c **** int ecc_map_ex(ecc_point* P, mp_int* modulus, mp_digit mp, int ct)
2392:../src/wolfcrypt/src/ecc.c **** {
 2475                             		.loc 2 2392 1
 2476 0000 7E AA                   		push.l	r10
 2477                             	.LCFI32:
 2478 0002 71 0A C0                		add	#-64, r0, r10
 2479                             	.LCFI33:
 2480 0005 71 A0 F8                		add	#-8, r10, r0
 2481                             	.LCFI34:
 2482 0008 E7 A1 0C                		mov.L	r1, 48[r10]
 2483 000b E7 A2 0D                		mov.L	r2, 52[r10]
 2484 000e E7 A3 0E                		mov.L	r3, 56[r10]
 2485 0011 E7 A4 0F                		mov.L	r4, 60[r10]
2393:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
2394:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2395:../src/wolfcrypt/src/ecc.c ****    mp_int* t1 = NULL;
 2486                             		.loc 2 2395 12
 2487 0014 F9 A6 01 00             		mov.L	#0, 4[r10]
2396:../src/wolfcrypt/src/ecc.c ****    mp_int* t2 = NULL;
 2488                             		.loc 2 2396 12
 2489 0018 F9 A6 02 00             		mov.L	#0, 8[r10]
2397:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
2398:../src/wolfcrypt/src/ecc.c ****    mp_int* rx = NULL;
2399:../src/wolfcrypt/src/ecc.c ****    mp_int* ry = NULL;
2400:../src/wolfcrypt/src/ecc.c ****    mp_int* rz = NULL;
2401:../src/wolfcrypt/src/ecc.c **** #endif
2402:../src/wolfcrypt/src/ecc.c **** #else
2403:../src/wolfcrypt/src/ecc.c ****    mp_int  t1[1], t2[1];
2404:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
2405:../src/wolfcrypt/src/ecc.c ****    mp_int  rx[1], ry[1], rz[1];
2406:../src/wolfcrypt/src/ecc.c **** #endif
2407:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK */
2408:../src/wolfcrypt/src/ecc.c ****    mp_int *x, *y, *z;
2409:../src/wolfcrypt/src/ecc.c ****    int    err;
2410:../src/wolfcrypt/src/ecc.c **** 
2411:../src/wolfcrypt/src/ecc.c ****    (void)ct;
2412:../src/wolfcrypt/src/ecc.c **** 
2413:../src/wolfcrypt/src/ecc.c ****    if (P == NULL || modulus == NULL)
 2490                             		.loc 2 2413 7
 2491 001c ED A5 0C                		mov.L	48[r10], r5
 2492 001f 61 05                   		cmp	#0, r5
 2493 0021 17                      		beq	.L167
 2494                             		.loc 2 2413 18 discriminator 1
 2495 0022 ED A5 0D                		mov.L	52[r10], r5
 2496 0025 61 05                   		cmp	#0, r5
 2497 0027 18                      		bne	.L168
 2498                             	.L167:
2414:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
 2499                             		.loc 2 2414 15
 2500 0028 FB 5A 56 FF             		mov.L	#-170, r5
 2501 002c 38 50 02                		bra	.L169
 2502                             	.L168:
2415:../src/wolfcrypt/src/ecc.c **** 
2416:../src/wolfcrypt/src/ecc.c ****    /* special case for point at infinity */
2417:../src/wolfcrypt/src/ecc.c ****    if (mp_cmp_d(P->z, 0) == MP_EQ) {
 2503                             		.loc 2 2417 18
 2504 002f ED A5 0C                		mov.L	48[r10], r5
 2505 0032 72 55 20 06             		add	#0x620, r5
 2506                             		.loc 2 2417 8
 2507 0036 66 02                   		mov.L	#0, r2
 2508 0038 EF 51                   		mov.L	r5, r1
 2509 003a 05 00 00 00             		bsr	_sp_cmp_d
 2510 003e EF 15                   		mov.L	r1, r5
 2511                             		.loc 2 2417 7
 2512 0040 61 05                   		cmp	#0, r5
 2513 0042 21 42                   		bne	.L170
2418:../src/wolfcrypt/src/ecc.c ****        err = mp_set(P->x, 0);
 2514                             		.loc 2 2418 22
 2515 0044 ED A5 0C                		mov.L	48[r10], r5
 2516                             		.loc 2 2418 14
 2517 0047 66 02                   		mov.L	#0, r2
 2518 0049 EF 51                   		mov.L	r5, r1
 2519 004b 05 00 00 00             		bsr	_sp_set
 2520 004f E3 A1                   		mov.L	r1, [r10]
2419:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY)
 2521                             		.loc 2 2419 11
 2522 0051 EC A5                   		mov.L	[r10], r5
 2523 0053 61 05                   		cmp	#0, r5
 2524 0055 21 13                   		bne	.L171
2420:../src/wolfcrypt/src/ecc.c ****            err = mp_set(P->y, 0);
 2525                             		.loc 2 2420 26
 2526 0057 ED A5 0C                		mov.L	48[r10], r5
 2527 005a 72 55 10 03             		add	#0x310, r5
 2528                             		.loc 2 2420 18
 2529 005e 66 02                   		mov.L	#0, r2
 2530 0060 EF 51                   		mov.L	r5, r1
 2531 0062 05 00 00 00             		bsr	_sp_set
 2532 0066 E3 A1                   		mov.L	r1, [r10]
 2533                             	.L171:
2421:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY)
 2534                             		.loc 2 2421 11
 2535 0068 EC A5                   		mov.L	[r10], r5
 2536 006a 61 05                   		cmp	#0, r5
 2537 006c 21 13                   		bne	.L172
2422:../src/wolfcrypt/src/ecc.c ****            err = mp_set(P->z, 1);
 2538                             		.loc 2 2422 26
 2539 006e ED A5 0C                		mov.L	48[r10], r5
 2540 0071 72 55 20 06             		add	#0x620, r5
 2541                             		.loc 2 2422 18
 2542 0075 66 12                   		mov.L	#1, r2
 2543 0077 EF 51                   		mov.L	r5, r1
 2544 0079 05 00 00 00             		bsr	_sp_set
 2545 007d E3 A1                   		mov.L	r1, [r10]
 2546                             	.L172:
2423:../src/wolfcrypt/src/ecc.c ****        return err;
 2547                             		.loc 2 2423 15
 2548 007f EC A5                   		mov.L	[r10], r5
 2549 0081 38 FB 01                		bra	.L169
 2550                             	.L170:
2424:../src/wolfcrypt/src/ecc.c ****    }
2425:../src/wolfcrypt/src/ecc.c **** 
2426:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2427:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
2428:../src/wolfcrypt/src/ecc.c ****    if (P->key != NULL) {
2429:../src/wolfcrypt/src/ecc.c ****        t1 = P->key->t1;
2430:../src/wolfcrypt/src/ecc.c ****        t2 = P->key->t2;
2431:../src/wolfcrypt/src/ecc.c ****    #ifdef ALT_ECC_SIZE
2432:../src/wolfcrypt/src/ecc.c ****        rx = P->key->x;
2433:../src/wolfcrypt/src/ecc.c ****        ry = P->key->y;
2434:../src/wolfcrypt/src/ecc.c ****        rz = P->key->z;
2435:../src/wolfcrypt/src/ecc.c ****    #endif
2436:../src/wolfcrypt/src/ecc.c ****    }
2437:../src/wolfcrypt/src/ecc.c ****    else
2438:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK_CACHE */
2439:../src/wolfcrypt/src/ecc.c ****    {
2440:../src/wolfcrypt/src/ecc.c ****        t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 2551                             		.loc 2 2440 22
 2552 0084 FB 1A 10 03             		mov.L	#0x310, r1
 2553 0088 05 00 00 00             		bsr	_wolfSSL_Malloc
 2554 008c E7 A1 01                		mov.L	r1, 4[r10]
2441:../src/wolfcrypt/src/ecc.c ****        t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 2555                             		.loc 2 2441 22
 2556 008f FB 1A 10 03             		mov.L	#0x310, r1
 2557 0093 05 00 00 00             		bsr	_wolfSSL_Malloc
 2558 0097 E7 A1 02                		mov.L	r1, 8[r10]
2442:../src/wolfcrypt/src/ecc.c ****        if (t1 == NULL || t2 == NULL) {
 2559                             		.loc 2 2442 11
 2560 009a ED A5 01                		mov.L	4[r10], r5
 2561 009d 61 05                   		cmp	#0, r5
 2562 009f 10                      		beq	.L173
 2563                             		.loc 2 2442 23 discriminator 1
 2564 00a0 ED A5 02                		mov.L	8[r10], r5
 2565 00a3 61 05                   		cmp	#0, r5
 2566 00a5 21 2E                   		bne	.L174
 2567                             	.L173:
 2568                             	.LBB18:
2443:../src/wolfcrypt/src/ecc.c ****            XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 2569                             		.loc 2 2443 12
 2570 00a7 ED A5 02                		mov.L	8[r10], r5
 2571 00aa E7 A5 0A                		mov.L	r5, 40[r10]
 2572 00ad ED A5 0A                		mov.L	40[r10], r5
 2573 00b0 61 05                   		cmp	#0, r5
 2574 00b2 10                      		beq	.L175
 2575                             		.loc 2 2443 12 is_stmt 0 discriminator 1
 2576 00b3 ED A1 0A                		mov.L	40[r10], r1
 2577 00b6 05 00 00 00             		bsr	_wolfSSL_Free
 2578                             	.L175:
 2579                             	.LBE18:
 2580                             	.LBB19:
2444:../src/wolfcrypt/src/ecc.c ****            XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 2581                             		.loc 2 2444 12 is_stmt 1
 2582 00ba ED A5 01                		mov.L	4[r10], r5
 2583 00bd E7 A5 0B                		mov.L	r5, 44[r10]
 2584 00c0 ED A5 0B                		mov.L	44[r10], r5
 2585 00c3 61 05                   		cmp	#0, r5
 2586 00c5 10                      		beq	.L176
 2587                             		.loc 2 2444 12 is_stmt 0 discriminator 1
 2588 00c6 ED A1 0B                		mov.L	44[r10], r1
 2589 00c9 05 00 00 00             		bsr	_wolfSSL_Free
 2590                             	.L176:
 2591                             	.LBE19:
2445:../src/wolfcrypt/src/ecc.c ****            return MEMORY_E;
 2592                             		.loc 2 2445 19 is_stmt 1
 2593 00cd FB 56 83                		mov.L	#-125, r5
 2594 00d0 38 AC 01                		bra	.L169
 2595                             	.L174:
2446:../src/wolfcrypt/src/ecc.c ****        }
2447:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
2448:../src/wolfcrypt/src/ecc.c ****        rx = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
2449:../src/wolfcrypt/src/ecc.c ****        ry = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
2450:../src/wolfcrypt/src/ecc.c ****        rz = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
2451:../src/wolfcrypt/src/ecc.c ****        if (rx == NULL || ry == NULL || rz == NULL) {
2452:../src/wolfcrypt/src/ecc.c ****            XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
2453:../src/wolfcrypt/src/ecc.c ****            XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
2454:../src/wolfcrypt/src/ecc.c ****            XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
2455:../src/wolfcrypt/src/ecc.c ****            XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
2456:../src/wolfcrypt/src/ecc.c ****            XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
2457:../src/wolfcrypt/src/ecc.c ****            return MEMORY_E;
2458:../src/wolfcrypt/src/ecc.c ****        }
2459:../src/wolfcrypt/src/ecc.c **** #endif
2460:../src/wolfcrypt/src/ecc.c ****    }
2461:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK */
2462:../src/wolfcrypt/src/ecc.c **** 
2463:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {
 2596                             		.loc 2 2463 15
 2597 00d3 3E 01 00                		mov.L	#0, 4[r0]
 2598 00d6 F8 06 00                		mov.L	#0, [r0]
 2599 00d9 66 04                   		mov.L	#0, r4
 2600 00db 66 03                   		mov.L	#0, r3
 2601 00dd ED A2 02                		mov.L	8[r10], r2
 2602 00e0 ED A1 01                		mov.L	4[r10], r1
 2603 00e3 05 00 00 00             		bsr	_sp_init_multi
 2604 00e7 E3 A1                   		mov.L	r1, [r10]
 2605                             		.loc 2 2463 7
 2606 00e9 EC A5                   		mov.L	[r10], r5
 2607 00eb 61 05                   		cmp	#0, r5
 2608 00ed 20 2E                   		beq	.L177
 2609                             	.LBB20:
2464:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2465:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
2466:../src/wolfcrypt/src/ecc.c ****       if (P->key == NULL)
2467:../src/wolfcrypt/src/ecc.c **** #endif
2468:../src/wolfcrypt/src/ecc.c ****       {
2469:../src/wolfcrypt/src/ecc.c ****       #ifdef ALT_ECC_SIZE
2470:../src/wolfcrypt/src/ecc.c ****          XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
2471:../src/wolfcrypt/src/ecc.c ****          XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
2472:../src/wolfcrypt/src/ecc.c ****          XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
2473:../src/wolfcrypt/src/ecc.c ****       #endif
2474:../src/wolfcrypt/src/ecc.c ****          XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 2610                             		.loc 2 2474 10
 2611 00ef ED A5 02                		mov.L	8[r10], r5
 2612 00f2 E7 A5 03                		mov.L	r5, 12[r10]
 2613 00f5 ED A5 03                		mov.L	12[r10], r5
 2614 00f8 61 05                   		cmp	#0, r5
 2615 00fa 10                      		beq	.L178
 2616                             		.loc 2 2474 10 is_stmt 0 discriminator 1
 2617 00fb ED A1 03                		mov.L	12[r10], r1
 2618 00fe 05 00 00 00             		bsr	_wolfSSL_Free
 2619                             	.L178:
 2620                             	.LBE20:
 2621                             	.LBB21:
2475:../src/wolfcrypt/src/ecc.c ****          XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 2622                             		.loc 2 2475 10 is_stmt 1
 2623 0102 ED A5 01                		mov.L	4[r10], r5
 2624 0105 E7 A5 04                		mov.L	r5, 16[r10]
 2625 0108 ED A5 04                		mov.L	16[r10], r5
 2626 010b 61 05                   		cmp	#0, r5
 2627 010d 10                      		beq	.L179
 2628                             		.loc 2 2475 10 is_stmt 0 discriminator 1
 2629 010e ED A1 04                		mov.L	16[r10], r1
 2630 0111 05 00 00 00             		bsr	_wolfSSL_Free
 2631                             	.L179:
 2632                             	.LBE21:
2476:../src/wolfcrypt/src/ecc.c ****       }
2477:../src/wolfcrypt/src/ecc.c **** #endif
2478:../src/wolfcrypt/src/ecc.c ****       return MEMORY_E;
 2633                             		.loc 2 2478 14 is_stmt 1
 2634 0115 FB 56 83                		mov.L	#-125, r5
 2635 0118 38 64 01                		bra	.L169
 2636                             	.L177:
2479:../src/wolfcrypt/src/ecc.c ****    }
2480:../src/wolfcrypt/src/ecc.c **** 
2481:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
2482:../src/wolfcrypt/src/ecc.c ****    /* Use local stack variable */
2483:../src/wolfcrypt/src/ecc.c ****    x = rx;
2484:../src/wolfcrypt/src/ecc.c ****    y = ry;
2485:../src/wolfcrypt/src/ecc.c ****    z = rz;
2486:../src/wolfcrypt/src/ecc.c **** 
2487:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_init_multi(x, y, z, NULL, NULL, NULL)) != MP_OKAY) {
2488:../src/wolfcrypt/src/ecc.c ****        goto done;
2489:../src/wolfcrypt/src/ecc.c ****    }
2490:../src/wolfcrypt/src/ecc.c **** 
2491:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2492:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(P->x, x);
2493:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2494:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(P->y, y);
2495:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2496:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(P->z, z);
2497:../src/wolfcrypt/src/ecc.c **** 
2498:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY) {
2499:../src/wolfcrypt/src/ecc.c ****       goto done;
2500:../src/wolfcrypt/src/ecc.c ****    }
2501:../src/wolfcrypt/src/ecc.c **** #else
2502:../src/wolfcrypt/src/ecc.c ****    /* Use destination directly */
2503:../src/wolfcrypt/src/ecc.c ****    x = P->x;
 2637                             		.loc 2 2503 6
 2638 011b ED A5 0C                		mov.L	48[r10], r5
 2639 011e E7 A5 05                		mov.L	r5, 20[r10]
2504:../src/wolfcrypt/src/ecc.c ****    y = P->y;
 2640                             		.loc 2 2504 6
 2641 0121 ED A5 0C                		mov.L	48[r10], r5
 2642 0124 72 55 10 03             		add	#0x310, r5
 2643 0128 E7 A5 06                		mov.L	r5, 24[r10]
2505:../src/wolfcrypt/src/ecc.c ****    z = P->z;
 2644                             		.loc 2 2505 6
 2645 012b ED A5 0C                		mov.L	48[r10], r5
 2646 012e 72 55 20 06             		add	#0x620, r5
 2647 0132 E7 A5 07                		mov.L	r5, 28[r10]
2506:../src/wolfcrypt/src/ecc.c **** #endif
2507:../src/wolfcrypt/src/ecc.c **** 
2508:../src/wolfcrypt/src/ecc.c ****    /* get 1/z */
2509:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 2648                             		.loc 2 2509 7
 2649 0135 EC A5                   		mov.L	[r10], r5
 2650 0137 61 05                   		cmp	#0, r5
 2651 0139 21 57                   		bne	.L180
2510:../src/wolfcrypt/src/ecc.c **** #if defined(ECC_TIMING_RESISTANT) && (defined(USE_FAST_MATH) || \
2511:../src/wolfcrypt/src/ecc.c ****                        defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_SP_MATH_ALL))
2512:../src/wolfcrypt/src/ecc.c ****        if (ct) {
 2652                             		.loc 2 2512 11
 2653 013b ED A5 0F                		mov.L	60[r10], r5
 2654 013e 61 05                   		cmp	#0, r5
 2655 0140 20 2B                   		beq	.L181
2513:../src/wolfcrypt/src/ecc.c ****            err = mp_invmod_mont_ct(z, modulus, t1, mp);
 2656                             		.loc 2 2513 18
 2657 0142 ED A4 0E                		mov.L	56[r10], r4
 2658 0145 ED A3 01                		mov.L	4[r10], r3
 2659 0148 ED A2 0D                		mov.L	52[r10], r2
 2660 014b ED A1 07                		mov.L	28[r10], r1
 2661 014e 05 00 00 00             		bsr	_sp_invmod_mont_ct
 2662 0152 E3 A1                   		mov.L	r1, [r10]
2514:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 2663                             		.loc 2 2514 15
 2664 0154 EC A5                   		mov.L	[r10], r5
 2665 0156 61 05                   		cmp	#0, r5
 2666 0158 21 38                   		bne	.L180
2515:../src/wolfcrypt/src/ecc.c ****                err = mp_montgomery_reduce(t1, modulus, mp);
 2667                             		.loc 2 2515 22
 2668 015a ED A3 0E                		mov.L	56[r10], r3
 2669 015d ED A2 0D                		mov.L	52[r10], r2
 2670 0160 ED A1 01                		mov.L	4[r10], r1
 2671 0163 05 00 00 00             		bsr	_sp_mont_red
 2672 0167 E3 A1                   		mov.L	r1, [r10]
 2673 0169 2E 27                   		bra	.L180
 2674                             	.L181:
2516:../src/wolfcrypt/src/ecc.c ****        }
2517:../src/wolfcrypt/src/ecc.c ****        else
2518:../src/wolfcrypt/src/ecc.c **** #endif
2519:../src/wolfcrypt/src/ecc.c ****        {
2520:../src/wolfcrypt/src/ecc.c ****            /* first map z back to normal */
2521:../src/wolfcrypt/src/ecc.c ****            err = mp_montgomery_reduce(z, modulus, mp);
 2675                             		.loc 2 2521 18
 2676 016b ED A3 0E                		mov.L	56[r10], r3
 2677 016e ED A2 0D                		mov.L	52[r10], r2
 2678 0171 ED A1 07                		mov.L	28[r10], r1
 2679 0174 05 00 00 00             		bsr	_sp_mont_red
 2680 0178 E3 A1                   		mov.L	r1, [r10]
2522:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
 2681                             		.loc 2 2522 15
 2682 017a EC A5                   		mov.L	[r10], r5
 2683 017c 61 05                   		cmp	#0, r5
 2684 017e 21 12                   		bne	.L180
2523:../src/wolfcrypt/src/ecc.c ****                err = mp_invmod(z, modulus, t1);
 2685                             		.loc 2 2523 22
 2686 0180 ED A3 01                		mov.L	4[r10], r3
 2687 0183 ED A2 0D                		mov.L	52[r10], r2
 2688 0186 ED A1 07                		mov.L	28[r10], r1
 2689 0189 05 00 00 00             		bsr	_sp_invmod
 2690 018d E3 A1                   		mov.L	r1, [r10]
 2691 018f 03                      		.balign 8,3,1
 2692                             	.L180:
2524:../src/wolfcrypt/src/ecc.c ****        }
2525:../src/wolfcrypt/src/ecc.c ****    }
2526:../src/wolfcrypt/src/ecc.c **** 
2527:../src/wolfcrypt/src/ecc.c ****    /* get 1/z^2 and 1/z^3 */
2528:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2693                             		.loc 2 2528 7
 2694 0190 EC A5                   		mov.L	[r10], r5
 2695 0192 61 05                   		cmp	#0, r5
 2696 0194 21 0E                   		bne	.L183
2529:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(t1, t2);
 2697                             		.loc 2 2529 14
 2698 0196 ED A2 02                		mov.L	8[r10], r2
 2699 0199 ED A1 01                		mov.L	4[r10], r1
 2700 019c 05 00 00 00             		bsr	_sp_sqr
 2701 01a0 E3 A1                   		mov.L	r1, [r10]
 2702                             	.L183:
2530:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2703                             		.loc 2 2530 7
 2704 01a2 EC A5                   		mov.L	[r10], r5
 2705 01a4 61 05                   		cmp	#0, r5
 2706 01a6 21 11                   		bne	.L184
2531:../src/wolfcrypt/src/ecc.c ****        err = mp_mod(t2, modulus, t2);
 2707                             		.loc 2 2531 14
 2708 01a8 ED A3 02                		mov.L	8[r10], r3
 2709 01ab ED A2 0D                		mov.L	52[r10], r2
 2710 01ae ED A1 02                		mov.L	8[r10], r1
 2711 01b1 05 00 00 00             		bsr	_sp_mod
 2712 01b5 E3 A1                   		mov.L	r1, [r10]
 2713                             	.L184:
2532:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2714                             		.loc 2 2532 7
 2715 01b7 EC A5                   		mov.L	[r10], r5
 2716 01b9 61 05                   		cmp	#0, r5
 2717 01bb 21 11                   		bne	.L185
2533:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(t1, t2, t1);
 2718                             		.loc 2 2533 14
 2719 01bd ED A3 01                		mov.L	4[r10], r3
 2720 01c0 ED A2 02                		mov.L	8[r10], r2
 2721 01c3 ED A1 01                		mov.L	4[r10], r1
 2722 01c6 05 00 00 00             		bsr	_sp_mul
 2723 01ca E3 A1                   		mov.L	r1, [r10]
 2724                             	.L185:
2534:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2725                             		.loc 2 2534 7
 2726 01cc EC A5                   		mov.L	[r10], r5
 2727 01ce 61 05                   		cmp	#0, r5
 2728 01d0 21 11                   		bne	.L186
2535:../src/wolfcrypt/src/ecc.c ****        err = mp_mod(t1, modulus, t1);
 2729                             		.loc 2 2535 14
 2730 01d2 ED A3 01                		mov.L	4[r10], r3
 2731 01d5 ED A2 0D                		mov.L	52[r10], r2
 2732 01d8 ED A1 01                		mov.L	4[r10], r1
 2733 01db 05 00 00 00             		bsr	_sp_mod
 2734 01df E3 A1                   		mov.L	r1, [r10]
 2735                             	.L186:
2536:../src/wolfcrypt/src/ecc.c **** 
2537:../src/wolfcrypt/src/ecc.c ****    /* multiply against x/y */
2538:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2736                             		.loc 2 2538 7
 2737 01e1 EC A5                   		mov.L	[r10], r5
 2738 01e3 61 05                   		cmp	#0, r5
 2739 01e5 21 11                   		bne	.L187
2539:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(x, t2, x);
 2740                             		.loc 2 2539 14
 2741 01e7 ED A3 05                		mov.L	20[r10], r3
 2742 01ea ED A2 02                		mov.L	8[r10], r2
 2743 01ed ED A1 05                		mov.L	20[r10], r1
 2744 01f0 05 00 00 00             		bsr	_sp_mul
 2745 01f4 E3 A1                   		mov.L	r1, [r10]
 2746                             	.L187:
2540:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2747                             		.loc 2 2540 7
 2748 01f6 EC A5                   		mov.L	[r10], r5
 2749 01f8 61 05                   		cmp	#0, r5
 2750 01fa 21 11                   		bne	.L188
2541:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(x, modulus, mp);
 2751                             		.loc 2 2541 14
 2752 01fc ED A3 0E                		mov.L	56[r10], r3
 2753 01ff ED A2 0D                		mov.L	52[r10], r2
 2754 0202 ED A1 05                		mov.L	20[r10], r1
 2755 0205 05 00 00 00             		bsr	_sp_mont_red
 2756 0209 E3 A1                   		mov.L	r1, [r10]
 2757                             	.L188:
2542:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2758                             		.loc 2 2542 7
 2759 020b EC A5                   		mov.L	[r10], r5
 2760 020d 61 05                   		cmp	#0, r5
 2761 020f 21 11                   		bne	.L189
2543:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(y, t1, y);
 2762                             		.loc 2 2543 14
 2763 0211 ED A3 06                		mov.L	24[r10], r3
 2764 0214 ED A2 01                		mov.L	4[r10], r2
 2765 0217 ED A1 06                		mov.L	24[r10], r1
 2766 021a 05 00 00 00             		bsr	_sp_mul
 2767 021e E3 A1                   		mov.L	r1, [r10]
 2768                             	.L189:
2544:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2769                             		.loc 2 2544 7
 2770 0220 EC A5                   		mov.L	[r10], r5
 2771 0222 61 05                   		cmp	#0, r5
 2772 0224 21 11                   		bne	.L190
2545:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(y, modulus, mp);
 2773                             		.loc 2 2545 14
 2774 0226 ED A3 0E                		mov.L	56[r10], r3
 2775 0229 ED A2 0D                		mov.L	52[r10], r2
 2776 022c ED A1 06                		mov.L	24[r10], r1
 2777 022f 05 00 00 00             		bsr	_sp_mont_red
 2778 0233 E3 A1                   		mov.L	r1, [r10]
 2779                             	.L190:
2546:../src/wolfcrypt/src/ecc.c **** 
2547:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 2780                             		.loc 2 2547 7
 2781 0235 EC A5                   		mov.L	[r10], r5
 2782 0237 61 05                   		cmp	#0, r5
 2783 0239 21 0D                   		bne	.L191
2548:../src/wolfcrypt/src/ecc.c ****        err = mp_set(z, 1);
 2784                             		.loc 2 2548 14
 2785 023b 66 12                   		mov.L	#1, r2
 2786 023d ED A1 07                		mov.L	28[r10], r1
 2787 0240 05 00 00 00             		bsr	_sp_set
 2788 0244 E3 A1                   		mov.L	r1, [r10]
 2789                             	.L191:
2549:../src/wolfcrypt/src/ecc.c **** 
2550:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
2551:../src/wolfcrypt/src/ecc.c ****    /* return result */
2552:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2553:../src/wolfcrypt/src/ecc.c ****       err = mp_copy(x, P->x);
2554:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2555:../src/wolfcrypt/src/ecc.c ****       err = mp_copy(y, P->y);
2556:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2557:../src/wolfcrypt/src/ecc.c ****       err = mp_copy(z, P->z);
2558:../src/wolfcrypt/src/ecc.c **** 
2559:../src/wolfcrypt/src/ecc.c **** done:
2560:../src/wolfcrypt/src/ecc.c **** #endif
2561:../src/wolfcrypt/src/ecc.c **** 
2562:../src/wolfcrypt/src/ecc.c ****    /* clean up */
2563:../src/wolfcrypt/src/ecc.c ****    mp_clear(t1);
 2790                             		.loc 2 2563 4
 2791 0246 ED A1 01                		mov.L	4[r10], r1
 2792 0249 05 00 00 00             		bsr	_sp_clear
2564:../src/wolfcrypt/src/ecc.c ****    mp_clear(t2);
 2793                             		.loc 2 2564 4
 2794 024d ED A1 02                		mov.L	8[r10], r1
 2795 0250 05 00 00 00             		bsr	_sp_clear
 2796                             	.LBB22:
2565:../src/wolfcrypt/src/ecc.c **** 
2566:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2567:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
2568:../src/wolfcrypt/src/ecc.c ****    if (P->key == NULL)
2569:../src/wolfcrypt/src/ecc.c **** #endif
2570:../src/wolfcrypt/src/ecc.c ****    {
2571:../src/wolfcrypt/src/ecc.c ****    #ifdef ALT_ECC_SIZE
2572:../src/wolfcrypt/src/ecc.c ****       XFREE(rz, NULL, DYNAMIC_TYPE_ECC);
2573:../src/wolfcrypt/src/ecc.c ****       XFREE(ry, NULL, DYNAMIC_TYPE_ECC);
2574:../src/wolfcrypt/src/ecc.c ****       XFREE(rx, NULL, DYNAMIC_TYPE_ECC);
2575:../src/wolfcrypt/src/ecc.c ****    #endif
2576:../src/wolfcrypt/src/ecc.c ****       XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 2797                             		.loc 2 2576 7
 2798 0254 ED A5 02                		mov.L	8[r10], r5
 2799 0257 E7 A5 08                		mov.L	r5, 32[r10]
 2800 025a ED A5 08                		mov.L	32[r10], r5
 2801 025d 61 05                   		cmp	#0, r5
 2802 025f 10                      		beq	.L192
 2803                             		.loc 2 2576 7 is_stmt 0 discriminator 1
 2804 0260 ED A1 08                		mov.L	32[r10], r1
 2805 0263 05 00 00 00             		bsr	_wolfSSL_Free
 2806                             	.L192:
 2807                             	.LBE22:
 2808                             	.LBB23:
2577:../src/wolfcrypt/src/ecc.c ****       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 2809                             		.loc 2 2577 7 is_stmt 1
 2810 0267 ED A5 01                		mov.L	4[r10], r5
 2811 026a E7 A5 09                		mov.L	r5, 36[r10]
 2812 026d ED A5 09                		mov.L	36[r10], r5
 2813 0270 61 05                   		cmp	#0, r5
 2814 0272 10                      		beq	.L193
 2815                             		.loc 2 2577 7 is_stmt 0 discriminator 1
 2816 0273 ED A1 09                		mov.L	36[r10], r1
 2817 0276 05 00 00 00             		bsr	_wolfSSL_Free
 2818                             	.L193:
 2819                             	.LBE23:
2578:../src/wolfcrypt/src/ecc.c ****    }
2579:../src/wolfcrypt/src/ecc.c **** #endif
2580:../src/wolfcrypt/src/ecc.c **** 
2581:../src/wolfcrypt/src/ecc.c ****    return err;
 2820                             		.loc 2 2581 11 is_stmt 1
 2821 027a EC A5                   		mov.L	[r10], r5
 2822                             		.balign 8,3,1
 2823                             	.L169:
2582:../src/wolfcrypt/src/ecc.c **** #else
2583:../src/wolfcrypt/src/ecc.c ****    if (P == NULL || modulus == NULL)
2584:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
2585:../src/wolfcrypt/src/ecc.c **** 
2586:../src/wolfcrypt/src/ecc.c ****    (void)mp;
2587:../src/wolfcrypt/src/ecc.c ****    (void)ct;
2588:../src/wolfcrypt/src/ecc.c **** 
2589:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
2590:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(modulus) == 256) {
2591:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_map_256(P->x, P->y, P->z);
2592:../src/wolfcrypt/src/ecc.c ****    }
2593:../src/wolfcrypt/src/ecc.c **** #endif
2594:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
2595:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(modulus) == 384) {
2596:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_map_384(P->x, P->y, P->z);
2597:../src/wolfcrypt/src/ecc.c ****    }
2598:../src/wolfcrypt/src/ecc.c **** #endif
2599:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
2600:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(modulus) == 521) {
2601:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_map_521(P->x, P->y, P->z);
2602:../src/wolfcrypt/src/ecc.c ****    }
2603:../src/wolfcrypt/src/ecc.c **** #endif
2604:../src/wolfcrypt/src/ecc.c ****    return ECC_BAD_ARG_E;
2605:../src/wolfcrypt/src/ecc.c **** #endif
2606:../src/wolfcrypt/src/ecc.c **** }
 2824                             		.loc 2 2606 1
 2825 027c EF 51                   		mov.L	r5, r1
 2826 027e 3F AA 13                		rtsd	#76, r10-r10
 2827                             	.LFE54:
 2829 0281 FD 70 40 00 00 00 80    		.section	.text.ecc_map,"ax",@progbits
 2830                             		.global	_ecc_map
 2832                             	_ecc_map:
 2833                             	.LFB55:
2607:../src/wolfcrypt/src/ecc.c **** #endif /* !FREESCALE_LTC_ECC && !WOLFSSL_STM32_PKA */
2608:../src/wolfcrypt/src/ecc.c **** 
2609:../src/wolfcrypt/src/ecc.c **** int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)
2610:../src/wolfcrypt/src/ecc.c **** {
 2834                             		.loc 2 2610 1
 2835 0000 7E AA                   		push.l	r10
 2836                             	.LCFI35:
 2837 0002 71 0A F4                		add	#-12, r0, r10
 2838                             	.LCFI36:
 2839 0005 EF A0                   		mov.L	r10, r0
 2840 0007 E3 A1                   		mov.L	r1, [r10]
 2841 0009 E7 A2 01                		mov.L	r2, 4[r10]
 2842 000c E7 A3 02                		mov.L	r3, 8[r10]
2611:../src/wolfcrypt/src/ecc.c ****     return ecc_map_ex(P, modulus, mp, 0);
 2843                             		.loc 2 2611 12
 2844 000f 66 04                   		mov.L	#0, r4
 2845 0011 ED A3 02                		mov.L	8[r10], r3
 2846 0014 ED A2 01                		mov.L	4[r10], r2
 2847 0017 EC A1                   		mov.L	[r10], r1
 2848 0019 05 00 00 00             		bsr	_ecc_map_ex
 2849 001d EF 15                   		mov.L	r1, r5
2612:../src/wolfcrypt/src/ecc.c **** }
 2850                             		.loc 2 2612 1
 2851 001f EF 51                   		mov.L	r5, r1
 2852 0021 3F AA 04                		rtsd	#16, r10-r10
 2853                             	.LFE55:
 2855                             		.section	.text.wc_ecc_gen_z,"ax",@progbits
 2857                             	_wc_ecc_gen_z:
 2858                             	.LFB56:
2613:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH || WOLFSSL_PUBLIC_ECC_ADD_DBL */
2614:../src/wolfcrypt/src/ecc.c **** 
2615:../src/wolfcrypt/src/ecc.c **** #if !defined(FREESCALE_LTC_ECC) && !defined(WOLFSSL_STM32_PKA) && \
2616:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL)
2617:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
2618:../src/wolfcrypt/src/ecc.c **** 
2619:../src/wolfcrypt/src/ecc.c **** #ifndef ECC_TIMING_RESISTANT
2620:../src/wolfcrypt/src/ecc.c **** 
2621:../src/wolfcrypt/src/ecc.c **** /* size of sliding window, don't change this! */
2622:../src/wolfcrypt/src/ecc.c **** #define WINSIZE  4
2623:../src/wolfcrypt/src/ecc.c **** #define M_POINTS 8
2624:../src/wolfcrypt/src/ecc.c **** 
2625:../src/wolfcrypt/src/ecc.c **** static int ecc_mulmod(const mp_int* k, ecc_point* tG, ecc_point* R,
2626:../src/wolfcrypt/src/ecc.c ****     ecc_point** M, mp_int* a, mp_int* modulus, mp_digit mp, WC_RNG* rng)
2627:../src/wolfcrypt/src/ecc.c **** {
2628:../src/wolfcrypt/src/ecc.c ****    int      err = MP_OKAY;
2629:../src/wolfcrypt/src/ecc.c ****    int      i;
2630:../src/wolfcrypt/src/ecc.c ****    int      first = 1, bitbuf = 0, bitcpy = 0, j;
2631:../src/wolfcrypt/src/ecc.c ****    int      bitcnt = 0, mode = 0, digidx = 0;
2632:../src/wolfcrypt/src/ecc.c ****    mp_digit buf;
2633:../src/wolfcrypt/src/ecc.c ****    int      infinity;
2634:../src/wolfcrypt/src/ecc.c **** 
2635:../src/wolfcrypt/src/ecc.c ****    (void)rng;
2636:../src/wolfcrypt/src/ecc.c **** 
2637:../src/wolfcrypt/src/ecc.c ****    /* calc the M tab, which holds kG for k==8..15 */
2638:../src/wolfcrypt/src/ecc.c ****    /* M[0] == 8G */
2639:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2640:../src/wolfcrypt/src/ecc.c ****        err = ecc_projective_dbl_point_safe(tG, M[0], a, modulus, mp);
2641:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2642:../src/wolfcrypt/src/ecc.c ****        err = ecc_projective_dbl_point_safe(M[0], M[0], a, modulus, mp);
2643:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2644:../src/wolfcrypt/src/ecc.c ****        err = ecc_projective_dbl_point_safe(M[0], M[0], a, modulus, mp);
2645:../src/wolfcrypt/src/ecc.c **** 
2646:../src/wolfcrypt/src/ecc.c ****    /* now find (8+k)G for k=1..7 */
2647:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
2648:../src/wolfcrypt/src/ecc.c ****        for (j = 9; j < 16; j++) {
2649:../src/wolfcrypt/src/ecc.c ****            err = ecc_projective_add_point_safe(M[j-9], tG, M[j-M_POINTS], a,
2650:../src/wolfcrypt/src/ecc.c ****                                                         modulus, mp, &infinity);
2651:../src/wolfcrypt/src/ecc.c ****            if (err != MP_OKAY) break;
2652:../src/wolfcrypt/src/ecc.c ****        }
2653:../src/wolfcrypt/src/ecc.c **** 
2654:../src/wolfcrypt/src/ecc.c ****    /* setup sliding window */
2655:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
2656:../src/wolfcrypt/src/ecc.c ****        mode   = 0;
2657:../src/wolfcrypt/src/ecc.c ****        bitcnt = 1;
2658:../src/wolfcrypt/src/ecc.c ****        buf    = 0;
2659:../src/wolfcrypt/src/ecc.c ****        digidx = get_digit_count(k) - 1;
2660:../src/wolfcrypt/src/ecc.c ****        bitcpy = bitbuf = 0;
2661:../src/wolfcrypt/src/ecc.c ****        first  = 1;
2662:../src/wolfcrypt/src/ecc.c **** 
2663:../src/wolfcrypt/src/ecc.c ****        /* perform ops */
2664:../src/wolfcrypt/src/ecc.c ****        for (;;) {
2665:../src/wolfcrypt/src/ecc.c ****            /* grab next digit as required */
2666:../src/wolfcrypt/src/ecc.c ****            if (--bitcnt == 0) {
2667:../src/wolfcrypt/src/ecc.c ****                if (digidx == -1) {
2668:../src/wolfcrypt/src/ecc.c ****                    break;
2669:../src/wolfcrypt/src/ecc.c ****                }
2670:../src/wolfcrypt/src/ecc.c ****                buf    = get_digit(k, digidx);
2671:../src/wolfcrypt/src/ecc.c ****                bitcnt = (int) DIGIT_BIT;
2672:../src/wolfcrypt/src/ecc.c ****                --digidx;
2673:../src/wolfcrypt/src/ecc.c ****            }
2674:../src/wolfcrypt/src/ecc.c **** 
2675:../src/wolfcrypt/src/ecc.c ****            /* grab the next msb from the ltiplicand */
2676:../src/wolfcrypt/src/ecc.c ****            i = (int)(buf >> (DIGIT_BIT - 1)) & 1;
2677:../src/wolfcrypt/src/ecc.c ****            buf <<= 1;
2678:../src/wolfcrypt/src/ecc.c **** 
2679:../src/wolfcrypt/src/ecc.c ****            /* skip leading zero bits */
2680:../src/wolfcrypt/src/ecc.c ****            if (mode == 0 && i == 0)
2681:../src/wolfcrypt/src/ecc.c ****                continue;
2682:../src/wolfcrypt/src/ecc.c **** 
2683:../src/wolfcrypt/src/ecc.c ****            /* if the bit is zero and mode == 1 then we double */
2684:../src/wolfcrypt/src/ecc.c ****            if (mode == 1 && i == 0) {
2685:../src/wolfcrypt/src/ecc.c ****                err = ecc_projective_dbl_point_safe(R, R, a, modulus, mp);
2686:../src/wolfcrypt/src/ecc.c ****                if (err != MP_OKAY) break;
2687:../src/wolfcrypt/src/ecc.c ****                continue;
2688:../src/wolfcrypt/src/ecc.c ****            }
2689:../src/wolfcrypt/src/ecc.c **** 
2690:../src/wolfcrypt/src/ecc.c ****            /* else we add it to the window */
2691:../src/wolfcrypt/src/ecc.c ****            bitbuf |= (i << (WINSIZE - ++bitcpy));
2692:../src/wolfcrypt/src/ecc.c ****            mode = 2;
2693:../src/wolfcrypt/src/ecc.c **** 
2694:../src/wolfcrypt/src/ecc.c ****            if (bitcpy == WINSIZE) {
2695:../src/wolfcrypt/src/ecc.c ****                /* if this is the first window we do a simple copy */
2696:../src/wolfcrypt/src/ecc.c ****                if (first == 1) {
2697:../src/wolfcrypt/src/ecc.c ****                    /* R = kG [k = first window] */
2698:../src/wolfcrypt/src/ecc.c ****                    err = mp_copy(M[bitbuf-M_POINTS]->x, R->x);
2699:../src/wolfcrypt/src/ecc.c ****                    if (err != MP_OKAY) break;
2700:../src/wolfcrypt/src/ecc.c **** 
2701:../src/wolfcrypt/src/ecc.c ****                    err = mp_copy(M[bitbuf-M_POINTS]->y, R->y);
2702:../src/wolfcrypt/src/ecc.c ****                    if (err != MP_OKAY) break;
2703:../src/wolfcrypt/src/ecc.c **** 
2704:../src/wolfcrypt/src/ecc.c ****                    err = mp_copy(M[bitbuf-M_POINTS]->z, R->z);
2705:../src/wolfcrypt/src/ecc.c ****                    first = 0;
2706:../src/wolfcrypt/src/ecc.c ****                } else {
2707:../src/wolfcrypt/src/ecc.c ****                    /* normal window */
2708:../src/wolfcrypt/src/ecc.c ****                    /* ok window is filled so double as required and add  */
2709:../src/wolfcrypt/src/ecc.c ****                    /* double first */
2710:../src/wolfcrypt/src/ecc.c ****                    for (j = 0; j < WINSIZE; j++) {
2711:../src/wolfcrypt/src/ecc.c ****                        err = ecc_projective_dbl_point_safe(R, R, a, modulus,
2712:../src/wolfcrypt/src/ecc.c ****                                                                             mp);
2713:../src/wolfcrypt/src/ecc.c ****                        if (err != MP_OKAY) break;
2714:../src/wolfcrypt/src/ecc.c ****                    }
2715:../src/wolfcrypt/src/ecc.c ****                    if (err != MP_OKAY) break;  /* out of first for(;;) */
2716:../src/wolfcrypt/src/ecc.c **** 
2717:../src/wolfcrypt/src/ecc.c ****                    /* now add, bitbuf will be 8..15 [8..2^WINSIZE] guaranteed */
2718:../src/wolfcrypt/src/ecc.c ****                    err = ecc_projective_add_point_safe(R, M[bitbuf-M_POINTS], R,
2719:../src/wolfcrypt/src/ecc.c ****                                                      a, modulus, mp, &infinity);
2720:../src/wolfcrypt/src/ecc.c ****                }
2721:../src/wolfcrypt/src/ecc.c ****                if (err != MP_OKAY) break;
2722:../src/wolfcrypt/src/ecc.c ****                /* empty window and reset */
2723:../src/wolfcrypt/src/ecc.c ****                bitcpy = bitbuf = 0;
2724:../src/wolfcrypt/src/ecc.c ****                mode = 1;
2725:../src/wolfcrypt/src/ecc.c ****            }
2726:../src/wolfcrypt/src/ecc.c ****        }
2727:../src/wolfcrypt/src/ecc.c ****    }
2728:../src/wolfcrypt/src/ecc.c **** 
2729:../src/wolfcrypt/src/ecc.c ****    /* if bits remain then double/add */
2730:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
2731:../src/wolfcrypt/src/ecc.c ****        if (mode == 2 && bitcpy > 0) {
2732:../src/wolfcrypt/src/ecc.c ****            /* double then add */
2733:../src/wolfcrypt/src/ecc.c ****            for (j = 0; j < bitcpy; j++) {
2734:../src/wolfcrypt/src/ecc.c ****                /* only double if we have had at least one add first */
2735:../src/wolfcrypt/src/ecc.c ****                if (first == 0) {
2736:../src/wolfcrypt/src/ecc.c ****                    err = ecc_projective_dbl_point_safe(R, R, a, modulus, mp);
2737:../src/wolfcrypt/src/ecc.c ****                    if (err != MP_OKAY) break;
2738:../src/wolfcrypt/src/ecc.c ****                }
2739:../src/wolfcrypt/src/ecc.c **** 
2740:../src/wolfcrypt/src/ecc.c ****                bitbuf <<= 1;
2741:../src/wolfcrypt/src/ecc.c ****                if ((bitbuf & (1 << WINSIZE)) != 0) {
2742:../src/wolfcrypt/src/ecc.c ****                    if (first == 1) {
2743:../src/wolfcrypt/src/ecc.c ****                        /* first add, so copy */
2744:../src/wolfcrypt/src/ecc.c ****                        err = mp_copy(tG->x, R->x);
2745:../src/wolfcrypt/src/ecc.c ****                        if (err != MP_OKAY) break;
2746:../src/wolfcrypt/src/ecc.c **** 
2747:../src/wolfcrypt/src/ecc.c ****                        err = mp_copy(tG->y, R->y);
2748:../src/wolfcrypt/src/ecc.c ****                        if (err != MP_OKAY) break;
2749:../src/wolfcrypt/src/ecc.c **** 
2750:../src/wolfcrypt/src/ecc.c ****                        err = mp_copy(tG->z, R->z);
2751:../src/wolfcrypt/src/ecc.c ****                        if (err != MP_OKAY) break;
2752:../src/wolfcrypt/src/ecc.c ****                        first = 0;
2753:../src/wolfcrypt/src/ecc.c ****                    } else {
2754:../src/wolfcrypt/src/ecc.c ****                        /* then add */
2755:../src/wolfcrypt/src/ecc.c ****                        err = ecc_projective_add_point_safe(R, tG, R, a, modulus,
2756:../src/wolfcrypt/src/ecc.c ****                                                                  mp, &infinity);
2757:../src/wolfcrypt/src/ecc.c ****                        if (err != MP_OKAY) break;
2758:../src/wolfcrypt/src/ecc.c ****                    }
2759:../src/wolfcrypt/src/ecc.c ****                }
2760:../src/wolfcrypt/src/ecc.c ****            }
2761:../src/wolfcrypt/src/ecc.c ****        }
2762:../src/wolfcrypt/src/ecc.c ****    }
2763:../src/wolfcrypt/src/ecc.c **** 
2764:../src/wolfcrypt/src/ecc.c ****    #undef WINSIZE
2765:../src/wolfcrypt/src/ecc.c **** 
2766:../src/wolfcrypt/src/ecc.c ****    return err;
2767:../src/wolfcrypt/src/ecc.c **** }
2768:../src/wolfcrypt/src/ecc.c **** 
2769:../src/wolfcrypt/src/ecc.c **** #else
2770:../src/wolfcrypt/src/ecc.c **** 
2771:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_gen_z(WC_RNG* rng, int size, ecc_point* p,
2772:../src/wolfcrypt/src/ecc.c ****         mp_int* modulus, mp_digit mp, mp_int* tx, mp_int* ty)
2773:../src/wolfcrypt/src/ecc.c **** {
 2859                             		.loc 2 2773 1
 2860 0000 7E AA                   		push.l	r10
 2861                             	.LCFI37:
 2862 0002 7E A6                   		push.l	r6
 2863                             	.LCFI38:
 2864 0004 71 0A D8                		add	#-40, r0, r10
 2865                             	.LCFI39:
 2866 0007 EF A0                   		mov.L	r10, r0
 2867 0009 75 46 34                		mov.L	#52, r6
 2868 000c 4B A6                   		add	r10, r6
 2869 000e E7 A1 03                		mov.L	r1, 12[r10]
 2870 0011 E7 A2 04                		mov.L	r2, 16[r10]
 2871 0014 E7 A3 05                		mov.L	r3, 20[r10]
 2872 0017 E7 A4 06                		mov.L	r4, 24[r10]
2774:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 2873                             		.loc 2 2774 9
 2874 001a F8 A6 00                		mov.L	#0, [r10]
2775:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2776:../src/wolfcrypt/src/ecc.c ****     mp_int*       mu = NULL;
 2875                             		.loc 2 2776 19
 2876 001d F9 A6 01 00             		mov.L	#0, 4[r10]
2777:../src/wolfcrypt/src/ecc.c **** #else
2778:../src/wolfcrypt/src/ecc.c ****     mp_int        mu[1];
2779:../src/wolfcrypt/src/ecc.c **** #endif
2780:../src/wolfcrypt/src/ecc.c **** 
2781:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2782:../src/wolfcrypt/src/ecc.c ****     mu = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 2877                             		.loc 2 2782 19
 2878 0021 FB 1A 10 03             		mov.L	#0x310, r1
 2879 0025 05 00 00 00             		bsr	_wolfSSL_Malloc
 2880 0029 E7 A1 01                		mov.L	r1, 4[r10]
2783:../src/wolfcrypt/src/ecc.c ****     if (mu == NULL)
 2881                             		.loc 2 2783 8
 2882 002c ED A5 01                		mov.L	4[r10], r5
 2883 002f 61 05                   		cmp	#0, r5
 2884 0031 1C                      		bne	.L197
2784:../src/wolfcrypt/src/ecc.c ****         err = MEMORY_E;
 2885                             		.loc 2 2784 13
 2886 0032 F8 A6 83                		mov.L	#-125, [r10]
 2887                             	.L197:
2785:../src/wolfcrypt/src/ecc.c **** #endif
2786:../src/wolfcrypt/src/ecc.c **** 
2787:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2888                             		.loc 2 2787 8
 2889 0035 EC A5                   		mov.L	[r10], r5
 2890 0037 61 05                   		cmp	#0, r5
 2891 0039 1A                      		bne	.L198
2788:../src/wolfcrypt/src/ecc.c ****         err = mp_init(mu);
 2892                             		.loc 2 2788 15
 2893 003a ED A1 01                		mov.L	4[r10], r1
 2894 003d 05 00 00 00             		bsr	_sp_init
 2895 0041 E3 A1                   		mov.L	r1, [r10]
 2896                             	.L198:
2789:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2897                             		.loc 2 2789 8
 2898 0043 EC A5                   		mov.L	[r10], r5
 2899 0045 61 05                   		cmp	#0, r5
 2900 0047 21 0E                   		bne	.L199
2790:../src/wolfcrypt/src/ecc.c ****         err = mp_montgomery_calc_normalization(mu, modulus);
 2901                             		.loc 2 2790 15
 2902 0049 ED A2 06                		mov.L	24[r10], r2
 2903 004c ED A1 01                		mov.L	4[r10], r1
 2904 004f 05 00 00 00             		bsr	_sp_mont_norm
 2905 0053 E3 A1                   		mov.L	r1, [r10]
 2906                             	.L199:
2791:../src/wolfcrypt/src/ecc.c ****     /* Generate random value to multiply into p->z. */
2792:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2907                             		.loc 2 2792 8
 2908 0055 EC A5                   		mov.L	[r10], r5
 2909 0057 61 05                   		cmp	#0, r5
 2910 0059 21 13                   		bne	.L200
2793:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_gen_k(rng, size, ty, modulus);
 2911                             		.loc 2 2793 15
 2912 005b ED A4 06                		mov.L	24[r10], r4
 2913 005e A8 E3                   		mov.L	8[r6], r3
 2914 0060 ED A2 04                		mov.L	16[r10], r2
 2915 0063 ED A1 03                		mov.L	12[r10], r1
 2916 0066 05 00 00 00             		bsr	_wc_ecc_gen_k
 2917 006a E3 A1                   		mov.L	r1, [r10]
 2918                             	.L200:
2794:../src/wolfcrypt/src/ecc.c ****     /* Convert to montogmery form. */
2795:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2919                             		.loc 2 2795 8
 2920 006c EC A5                   		mov.L	[r10], r5
 2921 006e 61 05                   		cmp	#0, r5
 2922 0070 21 12                   		bne	.L201
2796:../src/wolfcrypt/src/ecc.c ****         err = mp_mulmod(ty, mu, modulus, ty);
 2923                             		.loc 2 2796 15
 2924 0072 A8 E4                   		mov.L	8[r6], r4
 2925 0074 ED A3 06                		mov.L	24[r10], r3
 2926 0077 ED A2 01                		mov.L	4[r10], r2
 2927 007a A8 E1                   		mov.L	8[r6], r1
 2928 007c 05 00 00 00             		bsr	_sp_mulmod
 2929 0080 E3 A1                   		mov.L	r1, [r10]
 2930                             	.L201:
2797:../src/wolfcrypt/src/ecc.c ****     /* Multiply random value into p->z. */
2798:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2931                             		.loc 2 2798 8
 2932 0082 EC A5                   		mov.L	[r10], r5
 2933 0084 61 05                   		cmp	#0, r5
 2934 0086 21 1C                   		bne	.L202
2799:../src/wolfcrypt/src/ecc.c ****         err = mp_mul(p->z, ty, p->z);
 2935                             		.loc 2 2799 23
 2936 0088 ED A5 05                		mov.L	20[r10], r5
 2937 008b 72 54 20 06             		add	#0x620, r5, r4
 2938                             		.loc 2 2799 33
 2939 008f ED A5 05                		mov.L	20[r10], r5
 2940 0092 72 55 20 06             		add	#0x620, r5
 2941                             		.loc 2 2799 15
 2942 0096 EF 53                   		mov.L	r5, r3
 2943 0098 A8 E2                   		mov.L	8[r6], r2
 2944 009a EF 41                   		mov.L	r4, r1
 2945 009c 05 00 00 00             		bsr	_sp_mul
 2946 00a0 E3 A1                   		mov.L	r1, [r10]
 2947                             	.L202:
2800:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2948                             		.loc 2 2800 8
 2949 00a2 EC A5                   		mov.L	[r10], r5
 2950 00a4 61 05                   		cmp	#0, r5
 2951 00a6 21 16                   		bne	.L203
2801:../src/wolfcrypt/src/ecc.c ****         err = mp_montgomery_reduce(p->z, modulus, mp);
 2952                             		.loc 2 2801 37
 2953 00a8 ED A5 05                		mov.L	20[r10], r5
 2954 00ab 72 55 20 06             		add	#0x620, r5
 2955                             		.loc 2 2801 15
 2956 00af EC 63                   		mov.L	[r6], r3
 2957 00b1 ED A2 06                		mov.L	24[r10], r2
 2958 00b4 EF 51                   		mov.L	r5, r1
 2959 00b6 05 00 00 00             		bsr	_sp_mont_red
 2960 00ba E3 A1                   		mov.L	r1, [r10]
 2961                             	.L203:
2802:../src/wolfcrypt/src/ecc.c ****     /* Square random value for X (X' = X / Z^2). */
2803:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2962                             		.loc 2 2803 8
 2963 00bc EC A5                   		mov.L	[r10], r5
 2964 00be 61 05                   		cmp	#0, r5
 2965 00c0 21 0C                   		bne	.L204
2804:../src/wolfcrypt/src/ecc.c ****         err = mp_sqr(ty, tx);
 2966                             		.loc 2 2804 15
 2967 00c2 A8 6A                   		mov.L	4[r6], r2
 2968 00c4 A8 E1                   		mov.L	8[r6], r1
 2969 00c6 05 00 00 00             		bsr	_sp_sqr
 2970 00ca E3 A1                   		mov.L	r1, [r10]
 2971                             	.L204:
2805:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2972                             		.loc 2 2805 8
 2973 00cc EC A5                   		mov.L	[r10], r5
 2974 00ce 61 05                   		cmp	#0, r5
 2975 00d0 21 0F                   		bne	.L205
2806:../src/wolfcrypt/src/ecc.c ****         err = mp_montgomery_reduce(tx, modulus, mp);
 2976                             		.loc 2 2806 15
 2977 00d2 EC 63                   		mov.L	[r6], r3
 2978 00d4 ED A2 06                		mov.L	24[r10], r2
 2979 00d7 A8 69                   		mov.L	4[r6], r1
 2980 00d9 05 00 00 00             		bsr	_sp_mont_red
 2981 00dd E3 A1                   		mov.L	r1, [r10]
 2982                             	.L205:
2807:../src/wolfcrypt/src/ecc.c ****     /* Multiply square of random by random value for Y. */
2808:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2983                             		.loc 2 2808 8
 2984 00df EC A5                   		mov.L	[r10], r5
 2985 00e1 61 05                   		cmp	#0, r5
 2986 00e3 21 0E                   		bne	.L206
2809:../src/wolfcrypt/src/ecc.c ****         err = mp_mul(ty, tx, ty);
 2987                             		.loc 2 2809 15
 2988 00e5 A8 E3                   		mov.L	8[r6], r3
 2989 00e7 A8 6A                   		mov.L	4[r6], r2
 2990 00e9 A8 E1                   		mov.L	8[r6], r1
 2991 00eb 05 00 00 00             		bsr	_sp_mul
 2992 00ef E3 A1                   		mov.L	r1, [r10]
 2993                             	.L206:
2810:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 2994                             		.loc 2 2810 8
 2995 00f1 EC A5                   		mov.L	[r10], r5
 2996 00f3 61 05                   		cmp	#0, r5
 2997 00f5 21 0F                   		bne	.L207
2811:../src/wolfcrypt/src/ecc.c ****         err = mp_montgomery_reduce(ty, modulus, mp);
 2998                             		.loc 2 2811 15
 2999 00f7 EC 63                   		mov.L	[r6], r3
 3000 00f9 ED A2 06                		mov.L	24[r10], r2
 3001 00fc A8 E1                   		mov.L	8[r6], r1
 3002 00fe 05 00 00 00             		bsr	_sp_mont_red
 3003 0102 E3 A1                   		mov.L	r1, [r10]
 3004                             	.L207:
2812:../src/wolfcrypt/src/ecc.c ****     /* Multiply square into X. */
2813:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3005                             		.loc 2 2813 8
 3006 0104 EC A5                   		mov.L	[r10], r5
 3007 0106 61 05                   		cmp	#0, r5
 3008 0108 21 14                   		bne	.L208
2814:../src/wolfcrypt/src/ecc.c ****         err = mp_mul(p->x, tx, p->x);
 3009                             		.loc 2 2814 23
 3010 010a ED A5 05                		mov.L	20[r10], r5
 3011                             		.loc 2 2814 33
 3012 010d ED A4 05                		mov.L	20[r10], r4
 3013                             		.loc 2 2814 15
 3014 0110 EF 43                   		mov.L	r4, r3
 3015 0112 A8 6A                   		mov.L	4[r6], r2
 3016 0114 EF 51                   		mov.L	r5, r1
 3017 0116 05 00 00 00             		bsr	_sp_mul
 3018 011a E3 A1                   		mov.L	r1, [r10]
 3019                             	.L208:
2815:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3020                             		.loc 2 2815 8
 3021 011c EC A5                   		mov.L	[r10], r5
 3022 011e 61 05                   		cmp	#0, r5
 3023 0120 21 12                   		bne	.L209
2816:../src/wolfcrypt/src/ecc.c ****         err = mp_montgomery_reduce(p->x, modulus, mp);
 3024                             		.loc 2 2816 37
 3025 0122 ED A5 05                		mov.L	20[r10], r5
 3026                             		.loc 2 2816 15
 3027 0125 EC 63                   		mov.L	[r6], r3
 3028 0127 ED A2 06                		mov.L	24[r10], r2
 3029 012a EF 51                   		mov.L	r5, r1
 3030 012c 05 00 00 00             		bsr	_sp_mont_red
 3031 0130 E3 A1                   		mov.L	r1, [r10]
 3032                             	.L209:
2817:../src/wolfcrypt/src/ecc.c ****     /* Multiply cube into Y (Y' = Y / Z^3). */
2818:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3033                             		.loc 2 2818 8
 3034 0132 EC A5                   		mov.L	[r10], r5
 3035 0134 61 05                   		cmp	#0, r5
 3036 0136 21 1C                   		bne	.L210
2819:../src/wolfcrypt/src/ecc.c ****         err = mp_mul(p->y, ty, p->y);
 3037                             		.loc 2 2819 23
 3038 0138 ED A5 05                		mov.L	20[r10], r5
 3039 013b 72 54 10 03             		add	#0x310, r5, r4
 3040                             		.loc 2 2819 33
 3041 013f ED A5 05                		mov.L	20[r10], r5
 3042 0142 72 55 10 03             		add	#0x310, r5
 3043                             		.loc 2 2819 15
 3044 0146 EF 53                   		mov.L	r5, r3
 3045 0148 A8 E2                   		mov.L	8[r6], r2
 3046 014a EF 41                   		mov.L	r4, r1
 3047 014c 05 00 00 00             		bsr	_sp_mul
 3048 0150 E3 A1                   		mov.L	r1, [r10]
 3049                             	.L210:
2820:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3050                             		.loc 2 2820 8
 3051 0152 EC A5                   		mov.L	[r10], r5
 3052 0154 61 05                   		cmp	#0, r5
 3053 0156 21 16                   		bne	.L211
2821:../src/wolfcrypt/src/ecc.c ****         err = mp_montgomery_reduce(p->y, modulus, mp);
 3054                             		.loc 2 2821 37
 3055 0158 ED A5 05                		mov.L	20[r10], r5
 3056 015b 72 55 10 03             		add	#0x310, r5
 3057                             		.loc 2 2821 15
 3058 015f EC 63                   		mov.L	[r6], r3
 3059 0161 ED A2 06                		mov.L	24[r10], r2
 3060 0164 EF 51                   		mov.L	r5, r1
 3061 0166 05 00 00 00             		bsr	_sp_mont_red
 3062 016a E3 A1                   		mov.L	r1, [r10]
 3063                             	.L211:
2822:../src/wolfcrypt/src/ecc.c **** 
2823:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
2824:../src/wolfcrypt/src/ecc.c ****     if (mu != NULL) {
 3064                             		.loc 2 2824 8
 3065 016c ED A5 01                		mov.L	4[r10], r5
 3066 016f 61 05                   		cmp	#0, r5
 3067 0171 20 1C                   		beq	.L212
2825:../src/wolfcrypt/src/ecc.c ****         mp_clear(mu);
 3068                             		.loc 2 2825 9
 3069 0173 ED A1 01                		mov.L	4[r10], r1
 3070 0176 05 00 00 00             		bsr	_sp_clear
 3071                             	.LBB24:
2826:../src/wolfcrypt/src/ecc.c ****         XFREE(mu, NULL, DYNAMIC_TYPE_ECC);
 3072                             		.loc 2 2826 9
 3073 017a ED A5 01                		mov.L	4[r10], r5
 3074 017d E7 A5 02                		mov.L	r5, 8[r10]
 3075 0180 ED A5 02                		mov.L	8[r10], r5
 3076 0183 61 05                   		cmp	#0, r5
 3077 0185 10                      		beq	.L212
 3078                             		.loc 2 2826 9 is_stmt 0 discriminator 1
 3079 0186 ED A1 02                		mov.L	8[r10], r1
 3080 0189 05 00 00 00             		bsr	_wolfSSL_Free
 3081                             	.L212:
 3082                             	.LBE24:
2827:../src/wolfcrypt/src/ecc.c ****     }
2828:../src/wolfcrypt/src/ecc.c **** #else
2829:../src/wolfcrypt/src/ecc.c ****     mp_clear(mu);
2830:../src/wolfcrypt/src/ecc.c **** #endif
2831:../src/wolfcrypt/src/ecc.c **** 
2832:../src/wolfcrypt/src/ecc.c ****     return err;
 3083                             		.loc 2 2832 12 is_stmt 1
 3084 018d EC A5                   		mov.L	[r10], r5
2833:../src/wolfcrypt/src/ecc.c **** }
 3085                             		.loc 2 2833 1
 3086 018f EF 51                   		mov.L	r5, r1
 3087 0191 71 00 28                		add	#40, r0
 3088 0194 7E B6                   		pop	r6
 3089 0196 7E BA                   		pop	r10
 3090 0198 02                      		rts
 3091                             	.LFE56:
 3093                             		.section	.text.ecc_mulmod,"ax",@progbits
 3095                             	_ecc_mulmod:
 3096                             	.LFB57:
2834:../src/wolfcrypt/src/ecc.c **** 
2835:../src/wolfcrypt/src/ecc.c **** #ifndef WC_PROTECT_ENCRYPTED_MEM
2836:../src/wolfcrypt/src/ecc.c **** #define M_POINTS 3
2837:../src/wolfcrypt/src/ecc.c **** 
2838:../src/wolfcrypt/src/ecc.c **** /* Joye double-add ladder.
2839:../src/wolfcrypt/src/ecc.c ****  * "Highly Regular Right-to-Left Algorithms for Scalar Multiplication"
2840:../src/wolfcrypt/src/ecc.c ****  * by Marc Joye (2007)
2841:../src/wolfcrypt/src/ecc.c ****  *
2842:../src/wolfcrypt/src/ecc.c ****  * Algorithm 1':
2843:../src/wolfcrypt/src/ecc.c ****  *   Input: P element of curve, k = (k[t-1],..., k[0]) base 2
2844:../src/wolfcrypt/src/ecc.c ****  *   Output: Q = kP
2845:../src/wolfcrypt/src/ecc.c ****  *   1: R[0] = P; R[1] = P
2846:../src/wolfcrypt/src/ecc.c ****  *   2: for j = 1 to t-1 do
2847:../src/wolfcrypt/src/ecc.c ****  *   3:   b = 1 - k[j]; R[b] = 2*R[b] + R[k[j]]
2848:../src/wolfcrypt/src/ecc.c ****  *   4: end for
2849:../src/wolfcrypt/src/ecc.c ****  *   5: b = k[0]; R[b] = R[b] - P
2850:../src/wolfcrypt/src/ecc.c ****  *   6: return R[0]
2851:../src/wolfcrypt/src/ecc.c ****  *
2852:../src/wolfcrypt/src/ecc.c ****  * Assumes: k < order.
2853:../src/wolfcrypt/src/ecc.c ****  */
2854:../src/wolfcrypt/src/ecc.c **** static int ecc_mulmod(const mp_int* k, ecc_point* P, ecc_point* Q,
2855:../src/wolfcrypt/src/ecc.c ****     ecc_point** R, mp_int* a, mp_int* modulus, mp_digit mp, WC_RNG* rng)
2856:../src/wolfcrypt/src/ecc.c **** {
 3097                             		.loc 2 2856 1
 3098 0000 7E AA                   		push.l	r10
 3099                             	.LCFI40:
 3100 0002 7E A6                   		push.l	r6
 3101                             	.LCFI41:
 3102 0004 71 0A B4                		add	#-76, r0, r10
 3103                             	.LCFI42:
 3104 0007 71 A0 F4                		add	#-12, r10, r0
 3105                             	.LCFI43:
 3106 000a 75 46 58                		mov.L	#0x58, r6
 3107 000d 4B A6                   		add	r10, r6
 3108 000f E7 A1 0B                		mov.L	r1, 44[r10]
 3109 0012 E7 A2 0C                		mov.L	r2, 48[r10]
 3110 0015 E7 A3 0D                		mov.L	r3, 52[r10]
 3111 0018 E7 A4 0E                		mov.L	r4, 56[r10]
2857:../src/wolfcrypt/src/ecc.c ****     int      err = MP_OKAY;
 3112                             		.loc 2 2857 14
 3113 001b F8 A6 00                		mov.L	#0, [r10]
2858:../src/wolfcrypt/src/ecc.c ****     int      bytes = (mp_count_bits(modulus) + 7) / 8;
 3114                             		.loc 2 2858 23
 3115 001e A8 69                   		mov.L	4[r6], r1
 3116 0020 05 00 00 00             		bsr	_sp_count_bits
 3117 0024 EF 15                   		mov.L	r1, r5
 3118                             		.loc 2 2858 46
 3119 0026 62 75                   		add	#7, r5
 3120                             		.loc 2 2858 14
 3121 0028 61 05                   		cmp	#0, r5
 3122 002a 28 04                   		bge	.L215
 3123 002c 62 75                   		add	#7, r5
 3124                             	.L215:
 3125 002e 6A 35                   		shar	#3, r5
 3126 0030 E7 A5 07                		mov.L	r5, 28[r10]
2859:../src/wolfcrypt/src/ecc.c ****     int      i;
2860:../src/wolfcrypt/src/ecc.c ****     int      j = 1;
 3127                             		.loc 2 2860 14
 3128 0033 F9 A6 02 01             		mov.L	#1, 8[r10]
2861:../src/wolfcrypt/src/ecc.c ****     int      cnt = DIGIT_BIT;
 3129                             		.loc 2 2861 14
 3130 0037 F9 A6 03 20             		mov.L	#32, 12[r10]
2862:../src/wolfcrypt/src/ecc.c ****     int      t = 0;
 3131                             		.loc 2 2862 14
 3132 003b F9 A6 04 00             		mov.L	#0, 16[r10]
2863:../src/wolfcrypt/src/ecc.c ****     mp_digit b;
2864:../src/wolfcrypt/src/ecc.c ****     mp_digit v = 0;
 3133                             		.loc 2 2864 14
 3134 003f F9 A6 05 00             		mov.L	#0, 20[r10]
2865:../src/wolfcrypt/src/ecc.c ****     mp_int*  kt = R[2]->x;
 3135                             		.loc 2 2865 20
 3136 0043 ED A5 0E                		mov.L	56[r10], r5
 3137 0046 62 85                   		add	#8, r5
 3138 0048 EC 55                   		mov.L	[r5], r5
 3139                             		.loc 2 2865 14
 3140 004a E7 A5 08                		mov.L	r5, 32[r10]
2866:../src/wolfcrypt/src/ecc.c **** #ifndef WC_NO_CACHE_RESISTANT
2867:../src/wolfcrypt/src/ecc.c ****     /* First bit always 1 (fix at end) and swap equals first bit */
2868:../src/wolfcrypt/src/ecc.c ****     int      swap = 1;
 3141                             		.loc 2 2868 14
 3142 004d F9 A6 06 01             		mov.L	#1, 24[r10]
2869:../src/wolfcrypt/src/ecc.c **** #endif
2870:../src/wolfcrypt/src/ecc.c ****     int      infinity;
2871:../src/wolfcrypt/src/ecc.c **** 
2872:../src/wolfcrypt/src/ecc.c ****     /* Step 1: R[0] = P; R[1] = P */
2873:../src/wolfcrypt/src/ecc.c ****     /* R[0] = P */
2874:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3143                             		.loc 2 2874 8
 3144 0051 EC A5                   		mov.L	[r10], r5
 3145 0053 61 05                   		cmp	#0, r5
 3146 0055 21 14                   		bne	.L216
2875:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->x, R[0]->x);
 3147                             		.loc 2 2875 24
 3148 0057 ED A4 0C                		mov.L	48[r10], r4
 3149                             		.loc 2 2875 30
 3150 005a ED A5 0E                		mov.L	56[r10], r5
 3151 005d EC 55                   		mov.L	[r5], r5
 3152                             		.loc 2 2875 15
 3153 005f EF 52                   		mov.L	r5, r2
 3154 0061 EF 41                   		mov.L	r4, r1
 3155 0063 05 00 00 00             		bsr	_sp_copy
 3156 0067 E3 A1                   		mov.L	r1, [r10]
 3157                             	.L216:
2876:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3158                             		.loc 2 2876 8
 3159 0069 EC A5                   		mov.L	[r10], r5
 3160 006b 61 05                   		cmp	#0, r5
 3161 006d 21 1C                   		bne	.L217
2877:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->y, R[0]->y);
 3162                             		.loc 2 2877 24
 3163 006f ED A5 0C                		mov.L	48[r10], r5
 3164 0072 72 54 10 03             		add	#0x310, r5, r4
 3165                             		.loc 2 2877 30
 3166 0076 ED A5 0E                		mov.L	56[r10], r5
 3167 0079 EC 55                   		mov.L	[r5], r5
 3168                             		.loc 2 2877 33
 3169 007b 72 55 10 03             		add	#0x310, r5
 3170                             		.loc 2 2877 15
 3171 007f EF 52                   		mov.L	r5, r2
 3172 0081 EF 41                   		mov.L	r4, r1
 3173 0083 05 00 00 00             		bsr	_sp_copy
 3174 0087 E3 A1                   		mov.L	r1, [r10]
 3175                             	.L217:
2878:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3176                             		.loc 2 2878 8
 3177 0089 EC A5                   		mov.L	[r10], r5
 3178 008b 61 05                   		cmp	#0, r5
 3179 008d 21 1C                   		bne	.L218
2879:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->z, R[0]->z);
 3180                             		.loc 2 2879 24
 3181 008f ED A5 0C                		mov.L	48[r10], r5
 3182 0092 72 54 20 06             		add	#0x620, r5, r4
 3183                             		.loc 2 2879 30
 3184 0096 ED A5 0E                		mov.L	56[r10], r5
 3185 0099 EC 55                   		mov.L	[r5], r5
 3186                             		.loc 2 2879 33
 3187 009b 72 55 20 06             		add	#0x620, r5
 3188                             		.loc 2 2879 15
 3189 009f EF 52                   		mov.L	r5, r2
 3190 00a1 EF 41                   		mov.L	r4, r1
 3191 00a3 05 00 00 00             		bsr	_sp_copy
 3192 00a7 E3 A1                   		mov.L	r1, [r10]
 3193                             	.L218:
2880:../src/wolfcrypt/src/ecc.c **** 
2881:../src/wolfcrypt/src/ecc.c ****     /* R[1] = P */
2882:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3194                             		.loc 2 2882 8
 3195 00a9 EC A5                   		mov.L	[r10], r5
 3196 00ab 61 05                   		cmp	#0, r5
 3197 00ad 21 16                   		bne	.L219
2883:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->x, R[1]->x);
 3198                             		.loc 2 2883 24
 3199 00af ED A4 0C                		mov.L	48[r10], r4
 3200                             		.loc 2 2883 30
 3201 00b2 ED A5 0E                		mov.L	56[r10], r5
 3202 00b5 62 45                   		add	#4, r5
 3203 00b7 EC 55                   		mov.L	[r5], r5
 3204                             		.loc 2 2883 15
 3205 00b9 EF 52                   		mov.L	r5, r2
 3206 00bb EF 41                   		mov.L	r4, r1
 3207 00bd 05 00 00 00             		bsr	_sp_copy
 3208 00c1 E3 A1                   		mov.L	r1, [r10]
 3209                             	.L219:
2884:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3210                             		.loc 2 2884 8
 3211 00c3 EC A5                   		mov.L	[r10], r5
 3212 00c5 61 05                   		cmp	#0, r5
 3213 00c7 21 1E                   		bne	.L220
2885:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->y, R[1]->y);
 3214                             		.loc 2 2885 24
 3215 00c9 ED A5 0C                		mov.L	48[r10], r5
 3216 00cc 72 54 10 03             		add	#0x310, r5, r4
 3217                             		.loc 2 2885 30
 3218 00d0 ED A5 0E                		mov.L	56[r10], r5
 3219 00d3 62 45                   		add	#4, r5
 3220 00d5 EC 55                   		mov.L	[r5], r5
 3221                             		.loc 2 2885 33
 3222 00d7 72 55 10 03             		add	#0x310, r5
 3223                             		.loc 2 2885 15
 3224 00db EF 52                   		mov.L	r5, r2
 3225 00dd EF 41                   		mov.L	r4, r1
 3226 00df 05 00 00 00             		bsr	_sp_copy
 3227 00e3 E3 A1                   		mov.L	r1, [r10]
 3228                             	.L220:
2886:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3229                             		.loc 2 2886 8
 3230 00e5 EC A5                   		mov.L	[r10], r5
 3231 00e7 61 05                   		cmp	#0, r5
 3232 00e9 21 1E                   		bne	.L221
2887:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->z, R[1]->z);
 3233                             		.loc 2 2887 24
 3234 00eb ED A5 0C                		mov.L	48[r10], r5
 3235 00ee 72 54 20 06             		add	#0x620, r5, r4
 3236                             		.loc 2 2887 30
 3237 00f2 ED A5 0E                		mov.L	56[r10], r5
 3238 00f5 62 45                   		add	#4, r5
 3239 00f7 EC 55                   		mov.L	[r5], r5
 3240                             		.loc 2 2887 33
 3241 00f9 72 55 20 06             		add	#0x620, r5
 3242                             		.loc 2 2887 15
 3243 00fd EF 52                   		mov.L	r5, r2
 3244 00ff EF 41                   		mov.L	r4, r1
 3245 0101 05 00 00 00             		bsr	_sp_copy
 3246 0105 E3 A1                   		mov.L	r1, [r10]
 3247                             	.L221:
2888:../src/wolfcrypt/src/ecc.c **** 
2889:../src/wolfcrypt/src/ecc.c ****     /* Randomize z ordinates to obfuscate timing. */
2890:../src/wolfcrypt/src/ecc.c ****     if ((err == MP_OKAY) && (rng != NULL))
 3248                             		.loc 2 2890 8
 3249 0107 EC A5                   		mov.L	[r10], r5
 3250 0109 61 05                   		cmp	#0, r5
 3251 010b 21 36                   		bne	.L222
 3252                             		.loc 2 2890 26 discriminator 1
 3253 010d A8 ED                   		mov.L	12[r6], r5
 3254 010f 61 05                   		cmp	#0, r5
 3255 0111 20 30                   		beq	.L222
2891:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_gen_z(rng, bytes, R[0], modulus, mp, R[2]->x, R[2]->y);
 3256                             		.loc 2 2891 15
 3257 0113 ED A5 0E                		mov.L	56[r10], r5
 3258 0116 EC 53                   		mov.L	[r5], r3
 3259                             		.loc 2 2891 60
 3260 0118 ED A5 0E                		mov.L	56[r10], r5
 3261 011b 62 85                   		add	#8, r5
 3262 011d EC 55                   		mov.L	[r5], r5
 3263                             		.loc 2 2891 63
 3264 011f EF 54                   		mov.L	r5, r4
 3265                             		.loc 2 2891 69
 3266 0121 ED A5 0E                		mov.L	56[r10], r5
 3267 0124 62 85                   		add	#8, r5
 3268 0126 EC 55                   		mov.L	[r5], r5
 3269                             		.loc 2 2891 72
 3270 0128 72 55 10 03             		add	#0x310, r5
 3271                             		.loc 2 2891 15
 3272 012c A0 85                   		mov.L	r5, 8[r0]
 3273 012e A0 0C                   		mov.L	r4, 4[r0]
 3274 0130 A8 E5                   		mov.L	8[r6], r5
 3275 0132 E3 05                   		mov.L	r5, [r0]
 3276 0134 A8 6C                   		mov.L	4[r6], r4
 3277 0136 ED A2 07                		mov.L	28[r10], r2
 3278 0139 A8 E9                   		mov.L	12[r6], r1
 3279 013b 05 00 00 00             		bsr	_wc_ecc_gen_z
 3280 013f E3 A1                   		mov.L	r1, [r10]
 3281                             	.L222:
2892:../src/wolfcrypt/src/ecc.c ****     if ((err == MP_OKAY) && (rng != NULL))
 3282                             		.loc 2 2892 8
 3283 0141 EC A5                   		mov.L	[r10], r5
 3284 0143 61 05                   		cmp	#0, r5
 3285 0145 21 38                   		bne	.L223
 3286                             		.loc 2 2892 26 discriminator 1
 3287 0147 A8 ED                   		mov.L	12[r6], r5
 3288 0149 61 05                   		cmp	#0, r5
 3289 014b 20 32                   		beq	.L223
2893:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_gen_z(rng, bytes, R[1], modulus, mp, R[2]->x, R[2]->y);
 3290                             		.loc 2 2893 41
 3291 014d ED A5 0E                		mov.L	56[r10], r5
 3292 0150 62 45                   		add	#4, r5
 3293                             		.loc 2 2893 15
 3294 0152 EC 53                   		mov.L	[r5], r3
 3295                             		.loc 2 2893 60
 3296 0154 ED A5 0E                		mov.L	56[r10], r5
 3297 0157 62 85                   		add	#8, r5
 3298 0159 EC 55                   		mov.L	[r5], r5
 3299                             		.loc 2 2893 63
 3300 015b EF 54                   		mov.L	r5, r4
 3301                             		.loc 2 2893 69
 3302 015d ED A5 0E                		mov.L	56[r10], r5
 3303 0160 62 85                   		add	#8, r5
 3304 0162 EC 55                   		mov.L	[r5], r5
 3305                             		.loc 2 2893 72
 3306 0164 72 55 10 03             		add	#0x310, r5
 3307                             		.loc 2 2893 15
 3308 0168 A0 85                   		mov.L	r5, 8[r0]
 3309 016a A0 0C                   		mov.L	r4, 4[r0]
 3310 016c A8 E5                   		mov.L	8[r6], r5
 3311 016e E3 05                   		mov.L	r5, [r0]
 3312 0170 A8 6C                   		mov.L	4[r6], r4
 3313 0172 ED A2 07                		mov.L	28[r10], r2
 3314 0175 A8 E9                   		mov.L	12[r6], r1
 3315 0177 05 00 00 00             		bsr	_wc_ecc_gen_z
 3316 017b E3 A1                   		mov.L	r1, [r10]
 3317                             	.L223:
2894:../src/wolfcrypt/src/ecc.c **** 
2895:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 3318                             		.loc 2 2895 8
 3319 017d EC A5                   		mov.L	[r10], r5
 3320 017f 61 05                   		cmp	#0, r5
 3321 0181 21 35                   		bne	.L224
2896:../src/wolfcrypt/src/ecc.c ****         /* Order could be one greater than the size of the modulus. */
2897:../src/wolfcrypt/src/ecc.c ****         t = mp_count_bits(modulus) + 1;
 3322                             		.loc 2 2897 13
 3323 0183 A8 69                   		mov.L	4[r6], r1
 3324 0185 05 00 00 00             		bsr	_sp_count_bits
 3325 0189 EF 15                   		mov.L	r1, r5
 3326                             		.loc 2 2897 11
 3327 018b 62 15                   		add	#1, r5
 3328 018d E7 A5 04                		mov.L	r5, 16[r10]
2898:../src/wolfcrypt/src/ecc.c ****         v = k->dp[0] >> 1;
 3329                             		.loc 2 2898 18
 3330 0190 ED A5 0B                		mov.L	44[r10], r5
 3331 0193 A8 D5                   		mov.L	8[r5], r5
 3332                             		.loc 2 2898 11
 3333 0195 68 15                   		shlr	#1, r5
 3334 0197 E7 A5 05                		mov.L	r5, 20[r10]
2899:../src/wolfcrypt/src/ecc.c ****         if (cnt > t) {
 3335                             		.loc 2 2899 12
 3336 019a ED A4 03                		mov.L	12[r10], r4
 3337 019d ED A5 04                		mov.L	16[r10], r5
 3338 01a0 47 54                   		cmp	r5, r4
 3339 01a2 2B 08                   		ble	.L225
2900:../src/wolfcrypt/src/ecc.c ****             cnt = t;
 3340                             		.loc 2 2900 17
 3341 01a4 ED A5 04                		mov.L	16[r10], r5
 3342 01a7 E7 A5 03                		mov.L	r5, 12[r10]
 3343                             	.L225:
2901:../src/wolfcrypt/src/ecc.c ****         }
2902:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(k, kt);
 3344                             		.loc 2 2902 15
 3345 01aa ED A2 08                		mov.L	32[r10], r2
 3346 01ad ED A1 0B                		mov.L	44[r10], r1
 3347 01b0 05 00 00 00             		bsr	_sp_copy
 3348 01b4 E3 A1                   		mov.L	r1, [r10]
 3349                             	.L224:
2903:../src/wolfcrypt/src/ecc.c ****     }
2904:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 3350                             		.loc 2 2904 8
 3351 01b6 EC A5                   		mov.L	[r10], r5
 3352 01b8 61 05                   		cmp	#0, r5
 3353 01ba 21 13                   		bne	.L226
2905:../src/wolfcrypt/src/ecc.c ****         err = mp_grow(kt, modulus->used + 1);
 3354                             		.loc 2 2905 34
 3355 01bc A8 6D                   		mov.L	4[r6], r5
 3356 01be EC 55                   		mov.L	[r5], r5
 3357                             		.loc 2 2905 15
 3358 01c0 62 15                   		add	#1, r5
 3359 01c2 EF 52                   		mov.L	r5, r2
 3360 01c4 ED A1 08                		mov.L	32[r10], r1
 3361 01c7 05 00 00 00             		bsr	_sp_grow
 3362 01cb E3 A1                   		mov.L	r1, [r10]
 3363                             	.L226:
2906:../src/wolfcrypt/src/ecc.c ****     }
2907:../src/wolfcrypt/src/ecc.c ****     /* Step 2: for j = 1 to t-1 do */
2908:../src/wolfcrypt/src/ecc.c ****     for (i = 1; (err == MP_OKAY) && (i < t); i++) {
 3364                             		.loc 2 2908 12
 3365 01cd F9 A6 01 01             		mov.L	#1, 4[r10]
 3366                             		.loc 2 2908 5
 3367 01d1 38 16 01                		bra	.L227
 3368                             	.L235:
2909:../src/wolfcrypt/src/ecc.c ****         if (--cnt == 0) {
 3369                             		.loc 2 2909 12
 3370 01d4 ED A5 03                		mov.L	12[r10], r5
 3371 01d7 60 15                   		sub	#1, r5
 3372 01d9 E7 A5 03                		mov.L	r5, 12[r10]
 3373 01dc ED A5 03                		mov.L	12[r10], r5
 3374 01df 61 05                   		cmp	#0, r5
 3375 01e1 21 1A                   		bne	.L228
2910:../src/wolfcrypt/src/ecc.c ****             v = kt->dp[j++];
 3376                             		.loc 2 2910 25
 3377 01e3 ED A5 02                		mov.L	8[r10], r5
 3378 01e6 71 54 01                		add	#1, r5, r4
 3379 01e9 E7 A4 02                		mov.L	r4, 8[r10]
 3380                             		.loc 2 2910 15
 3381 01ec ED A4 08                		mov.L	32[r10], r4
 3382 01ef 62 25                   		add	#2, r5
 3383 01f1 FE 65 45                		mov.L	[r5,r4], r5
 3384 01f4 E7 A5 05                		mov.L	r5, 20[r10]
2911:../src/wolfcrypt/src/ecc.c ****             cnt = DIGIT_BIT;
 3385                             		.loc 2 2911 17
 3386 01f7 F9 A6 03 20             		mov.L	#32, 12[r10]
 3387                             	.L228:
2912:../src/wolfcrypt/src/ecc.c ****         }
2913:../src/wolfcrypt/src/ecc.c **** 
2914:../src/wolfcrypt/src/ecc.c ****         /* Step 3: b = 1 - k[j]; R[b] = 2*R[b] + R[k[j]] */
2915:../src/wolfcrypt/src/ecc.c ****         b = v & 1;
 3388                             		.loc 2 2915 11
 3389 01fb ED A5 05                		mov.L	20[r10], r5
 3390 01fe 64 15                   		and	#1, r5
 3391 0200 E7 A5 09                		mov.L	r5, 36[r10]
2916:../src/wolfcrypt/src/ecc.c ****         v >>= 1;
 3392                             		.loc 2 2916 11
 3393 0203 ED A5 05                		mov.L	20[r10], r5
 3394 0206 68 15                   		shlr	#1, r5
 3395 0208 E7 A5 05                		mov.L	r5, 20[r10]
2917:../src/wolfcrypt/src/ecc.c **** #ifdef WC_NO_CACHE_RESISTANT
2918:../src/wolfcrypt/src/ecc.c ****         err = ecc_projective_dbl_point_safe(R[b^1], R[b^1], a, modulus, mp);
2919:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
2920:../src/wolfcrypt/src/ecc.c ****             err = ecc_projective_add_point_safe(R[b^1], R[b], R[b^1], a,
2921:../src/wolfcrypt/src/ecc.c ****                                                         modulus, mp, &infinity);
2922:../src/wolfcrypt/src/ecc.c ****         }
2923:../src/wolfcrypt/src/ecc.c **** #else
2924:../src/wolfcrypt/src/ecc.c ****         /* Swap R[0] and R[1] if other index is needed. */
2925:../src/wolfcrypt/src/ecc.c ****         swap ^= b;
 3396                             		.loc 2 2925 14
 3397 020b ED A5 06                		mov.L	24[r10], r5
 3398 020e 06 A1 0D A5 09          		xor	36[r10].L, r5
 3399 0213 E7 A5 06                		mov.L	r5, 24[r10]
2926:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3400                             		.loc 2 2926 12
 3401 0216 EC A5                   		mov.L	[r10], r5
 3402 0218 61 05                   		cmp	#0, r5
 3403 021a 21 21                   		bne	.L229
2927:../src/wolfcrypt/src/ecc.c ****             err = mp_cond_swap_ct(R[0]->x, R[1]->x, modulus->used, swap);
 3404                             		.loc 2 2927 36
 3405 021c ED A5 0E                		mov.L	56[r10], r5
 3406 021f EC 55                   		mov.L	[r5], r5
 3407                             		.loc 2 2927 39
 3408 0221 EF 51                   		mov.L	r5, r1
 3409                             		.loc 2 2927 45
 3410 0223 ED A5 0E                		mov.L	56[r10], r5
 3411 0226 62 45                   		add	#4, r5
 3412 0228 EC 55                   		mov.L	[r5], r5
 3413                             		.loc 2 2927 48
 3414 022a EF 52                   		mov.L	r5, r2
 3415                             		.loc 2 2927 19
 3416 022c A8 6D                   		mov.L	4[r6], r5
 3417 022e EC 55                   		mov.L	[r5], r5
 3418 0230 ED A4 06                		mov.L	24[r10], r4
 3419 0233 EF 53                   		mov.L	r5, r3
 3420 0235 05 00 00 00             		bsr	_sp_cond_swap_ct
 3421 0239 E3 A1                   		mov.L	r1, [r10]
 3422                             	.L229:
2928:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3423                             		.loc 2 2928 12
 3424 023b EC A5                   		mov.L	[r10], r5
 3425 023d 61 05                   		cmp	#0, r5
 3426 023f 21 25                   		bne	.L230
2929:../src/wolfcrypt/src/ecc.c ****             err = mp_cond_swap_ct(R[0]->y, R[1]->y, modulus->used, swap);
 3427                             		.loc 2 2929 36
 3428 0241 ED A5 0E                		mov.L	56[r10], r5
 3429 0244 EC 55                   		mov.L	[r5], r5
 3430                             		.loc 2 2929 39
 3431 0246 72 51 10 03             		add	#0x310, r5, r1
 3432                             		.loc 2 2929 45
 3433 024a ED A5 0E                		mov.L	56[r10], r5
 3434 024d 62 45                   		add	#4, r5
 3435 024f EC 55                   		mov.L	[r5], r5
 3436                             		.loc 2 2929 48
 3437 0251 72 52 10 03             		add	#0x310, r5, r2
 3438                             		.loc 2 2929 19
 3439 0255 A8 6D                   		mov.L	4[r6], r5
 3440 0257 EC 55                   		mov.L	[r5], r5
 3441 0259 ED A4 06                		mov.L	24[r10], r4
 3442 025c EF 53                   		mov.L	r5, r3
 3443 025e 05 00 00 00             		bsr	_sp_cond_swap_ct
 3444 0262 E3 A1                   		mov.L	r1, [r10]
 3445                             	.L230:
2930:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3446                             		.loc 2 2930 12
 3447 0264 EC A5                   		mov.L	[r10], r5
 3448 0266 61 05                   		cmp	#0, r5
 3449 0268 21 25                   		bne	.L231
2931:../src/wolfcrypt/src/ecc.c ****             err = mp_cond_swap_ct(R[0]->z, R[1]->z, modulus->used, swap);
 3450                             		.loc 2 2931 36
 3451 026a ED A5 0E                		mov.L	56[r10], r5
 3452 026d EC 55                   		mov.L	[r5], r5
 3453                             		.loc 2 2931 39
 3454 026f 72 51 20 06             		add	#0x620, r5, r1
 3455                             		.loc 2 2931 45
 3456 0273 ED A5 0E                		mov.L	56[r10], r5
 3457 0276 62 45                   		add	#4, r5
 3458 0278 EC 55                   		mov.L	[r5], r5
 3459                             		.loc 2 2931 48
 3460 027a 72 52 20 06             		add	#0x620, r5, r2
 3461                             		.loc 2 2931 19
 3462 027e A8 6D                   		mov.L	4[r6], r5
 3463 0280 EC 55                   		mov.L	[r5], r5
 3464 0282 ED A4 06                		mov.L	24[r10], r4
 3465 0285 EF 53                   		mov.L	r5, r3
 3466 0287 05 00 00 00             		bsr	_sp_cond_swap_ct
 3467 028b E3 A1                   		mov.L	r1, [r10]
 3468                             	.L231:
2932:../src/wolfcrypt/src/ecc.c ****         swap = (int)b;
 3469                             		.loc 2 2932 14
 3470 028d ED A5 09                		mov.L	36[r10], r5
 3471 0290 E7 A5 06                		mov.L	r5, 24[r10]
2933:../src/wolfcrypt/src/ecc.c **** 
2934:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3472                             		.loc 2 2934 12
 3473 0293 EC A5                   		mov.L	[r10], r5
 3474 0295 61 05                   		cmp	#0, r5
 3475 0297 21 1C                   		bne	.L232
2935:../src/wolfcrypt/src/ecc.c ****             err = ecc_projective_dbl_point_safe(R[0], R[0], a, modulus, mp);
 3476                             		.loc 2 2935 19
 3477 0299 ED A5 0E                		mov.L	56[r10], r5
 3478 029c EC 51                   		mov.L	[r5], r1
 3479 029e ED A5 0E                		mov.L	56[r10], r5
 3480 02a1 EC 55                   		mov.L	[r5], r5
 3481 02a3 A8 E4                   		mov.L	8[r6], r4
 3482 02a5 E3 04                   		mov.L	r4, [r0]
 3483 02a7 A8 6C                   		mov.L	4[r6], r4
 3484 02a9 EC 63                   		mov.L	[r6], r3
 3485 02ab EF 52                   		mov.L	r5, r2
 3486 02ad 05 00 00 00             		bsr	_ecc_projective_dbl_point_safe
 3487 02b1 E3 A1                   		mov.L	r1, [r10]
 3488                             	.L232:
2936:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 3489                             		.loc 2 2936 12
 3490 02b3 EC A5                   		mov.L	[r10], r5
 3491 02b5 61 05                   		cmp	#0, r5
 3492 02b7 21 28                   		bne	.L233
2937:../src/wolfcrypt/src/ecc.c ****             err = ecc_projective_add_point_safe(R[0], R[1], R[0], a, modulus,
 3493                             		.loc 2 2937 19
 3494 02b9 ED A5 0E                		mov.L	56[r10], r5
 3495 02bc EC 51                   		mov.L	[r5], r1
 3496                             		.loc 2 2937 56
 3497 02be ED A5 0E                		mov.L	56[r10], r5
 3498 02c1 62 45                   		add	#4, r5
 3499                             		.loc 2 2937 19
 3500 02c3 EC 52                   		mov.L	[r5], r2
 3501 02c5 ED A5 0E                		mov.L	56[r10], r5
 3502 02c8 EC 53                   		mov.L	[r5], r3
 3503 02ca 71 A5 28                		add	#40, r10, r5
 3504 02cd A0 85                   		mov.L	r5, 8[r0]
 3505 02cf A8 E5                   		mov.L	8[r6], r5
 3506 02d1 A0 0D                   		mov.L	r5, 4[r0]
 3507 02d3 A8 6D                   		mov.L	4[r6], r5
 3508 02d5 E3 05                   		mov.L	r5, [r0]
 3509 02d7 EC 64                   		mov.L	[r6], r4
 3510 02d9 05 00 00 00             		bsr	_ecc_projective_add_point_safe
 3511 02dd E3 A1                   		mov.L	r1, [r10]
 3512                             	.L233:
2908:../src/wolfcrypt/src/ecc.c ****         if (--cnt == 0) {
 3513                             		.loc 2 2908 47 discriminator 2
 3514 02df ED A5 01                		mov.L	4[r10], r5
 3515 02e2 62 15                   		add	#1, r5
 3516 02e4 E7 A5 01                		mov.L	r5, 4[r10]
 3517                             	.L227:
2908:../src/wolfcrypt/src/ecc.c ****         if (--cnt == 0) {
 3518                             		.loc 2 2908 5 discriminator 1
 3519 02e7 EC A5                   		mov.L	[r10], r5
 3520 02e9 61 05                   		cmp	#0, r5
 3521 02eb 21 0F                   		bne	.L234
2908:../src/wolfcrypt/src/ecc.c ****         if (--cnt == 0) {
 3522                             		.loc 2 2908 34 discriminator 3
 3523 02ed ED A4 01                		mov.L	4[r10], r4
 3524 02f0 ED A5 04                		mov.L	16[r10], r5
 3525 02f3 47 54                   		cmp	r5, r4
 3526 02f5 28 05 38 DD FE          		blt	.L235
 3527                             	.L234:
2938:../src/wolfcrypt/src/ecc.c ****                                                                  mp, &infinity);
2939:../src/wolfcrypt/src/ecc.c ****         }
2940:../src/wolfcrypt/src/ecc.c **** #endif /* WC_NO_CACHE_RESISTANT */
2941:../src/wolfcrypt/src/ecc.c ****     }
2942:../src/wolfcrypt/src/ecc.c ****     /* Step 4: end for */
2943:../src/wolfcrypt/src/ecc.c **** #ifndef WC_NO_CACHE_RESISTANT
2944:../src/wolfcrypt/src/ecc.c ****     /* Swap back if last bit is 0. */
2945:../src/wolfcrypt/src/ecc.c ****     swap ^= 1;
 3528                             		.loc 2 2945 10
 3529 02fa ED A5 06                		mov.L	24[r10], r5
 3530 02fd FD 74 D5 01             		xor	#1, r5
 3531 0301 E7 A5 06                		mov.L	r5, 24[r10]
2946:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3532                             		.loc 2 2946 8
 3533 0304 EC A5                   		mov.L	[r10], r5
 3534 0306 61 05                   		cmp	#0, r5
 3535 0308 21 21                   		bne	.L236
2947:../src/wolfcrypt/src/ecc.c ****         err = mp_cond_swap_ct(R[0]->x, R[1]->x, modulus->used, swap);
 3536                             		.loc 2 2947 32
 3537 030a ED A5 0E                		mov.L	56[r10], r5
 3538 030d EC 55                   		mov.L	[r5], r5
 3539                             		.loc 2 2947 35
 3540 030f EF 51                   		mov.L	r5, r1
 3541                             		.loc 2 2947 41
 3542 0311 ED A5 0E                		mov.L	56[r10], r5
 3543 0314 62 45                   		add	#4, r5
 3544 0316 EC 55                   		mov.L	[r5], r5
 3545                             		.loc 2 2947 44
 3546 0318 EF 52                   		mov.L	r5, r2
 3547                             		.loc 2 2947 15
 3548 031a A8 6D                   		mov.L	4[r6], r5
 3549 031c EC 55                   		mov.L	[r5], r5
 3550 031e ED A4 06                		mov.L	24[r10], r4
 3551 0321 EF 53                   		mov.L	r5, r3
 3552 0323 05 00 00 00             		bsr	_sp_cond_swap_ct
 3553 0327 E3 A1                   		mov.L	r1, [r10]
 3554                             	.L236:
2948:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3555                             		.loc 2 2948 8
 3556 0329 EC A5                   		mov.L	[r10], r5
 3557 032b 61 05                   		cmp	#0, r5
 3558 032d 21 25                   		bne	.L237
2949:../src/wolfcrypt/src/ecc.c ****         err = mp_cond_swap_ct(R[0]->y, R[1]->y, modulus->used, swap);
 3559                             		.loc 2 2949 32
 3560 032f ED A5 0E                		mov.L	56[r10], r5
 3561 0332 EC 55                   		mov.L	[r5], r5
 3562                             		.loc 2 2949 35
 3563 0334 72 51 10 03             		add	#0x310, r5, r1
 3564                             		.loc 2 2949 41
 3565 0338 ED A5 0E                		mov.L	56[r10], r5
 3566 033b 62 45                   		add	#4, r5
 3567 033d EC 55                   		mov.L	[r5], r5
 3568                             		.loc 2 2949 44
 3569 033f 72 52 10 03             		add	#0x310, r5, r2
 3570                             		.loc 2 2949 15
 3571 0343 A8 6D                   		mov.L	4[r6], r5
 3572 0345 EC 55                   		mov.L	[r5], r5
 3573 0347 ED A4 06                		mov.L	24[r10], r4
 3574 034a EF 53                   		mov.L	r5, r3
 3575 034c 05 00 00 00             		bsr	_sp_cond_swap_ct
 3576 0350 E3 A1                   		mov.L	r1, [r10]
 3577                             	.L237:
2950:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3578                             		.loc 2 2950 8
 3579 0352 EC A5                   		mov.L	[r10], r5
 3580 0354 61 05                   		cmp	#0, r5
 3581 0356 21 25                   		bne	.L238
2951:../src/wolfcrypt/src/ecc.c ****         err = mp_cond_swap_ct(R[0]->z, R[1]->z, modulus->used, swap);
 3582                             		.loc 2 2951 32
 3583 0358 ED A5 0E                		mov.L	56[r10], r5
 3584 035b EC 55                   		mov.L	[r5], r5
 3585                             		.loc 2 2951 35
 3586 035d 72 51 20 06             		add	#0x620, r5, r1
 3587                             		.loc 2 2951 41
 3588 0361 ED A5 0E                		mov.L	56[r10], r5
 3589 0364 62 45                   		add	#4, r5
 3590 0366 EC 55                   		mov.L	[r5], r5
 3591                             		.loc 2 2951 44
 3592 0368 72 52 20 06             		add	#0x620, r5, r2
 3593                             		.loc 2 2951 15
 3594 036c A8 6D                   		mov.L	4[r6], r5
 3595 036e EC 55                   		mov.L	[r5], r5
 3596 0370 ED A4 06                		mov.L	24[r10], r4
 3597 0373 EF 53                   		mov.L	r5, r3
 3598 0375 05 00 00 00             		bsr	_sp_cond_swap_ct
 3599 0379 E3 A1                   		mov.L	r1, [r10]
 3600                             	.L238:
2952:../src/wolfcrypt/src/ecc.c **** #endif
2953:../src/wolfcrypt/src/ecc.c **** 
2954:../src/wolfcrypt/src/ecc.c ****     /* Step 5: b = k[0]; R[b] = R[b] - P */
2955:../src/wolfcrypt/src/ecc.c ****     /* R[2] = -P */
2956:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3601                             		.loc 2 2956 8
 3602 037b EC A5                   		mov.L	[r10], r5
 3603 037d 61 05                   		cmp	#0, r5
 3604 037f 21 16                   		bne	.L239
2957:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->x, R[2]->x);
 3605                             		.loc 2 2957 24
 3606 0381 ED A4 0C                		mov.L	48[r10], r4
 3607                             		.loc 2 2957 30
 3608 0384 ED A5 0E                		mov.L	56[r10], r5
 3609 0387 62 85                   		add	#8, r5
 3610 0389 EC 55                   		mov.L	[r5], r5
 3611                             		.loc 2 2957 15
 3612 038b EF 52                   		mov.L	r5, r2
 3613 038d EF 41                   		mov.L	r4, r1
 3614 038f 05 00 00 00             		bsr	_sp_copy
 3615 0393 E3 A1                   		mov.L	r1, [r10]
 3616                             	.L239:
2958:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3617                             		.loc 2 2958 8
 3618 0395 EC A5                   		mov.L	[r10], r5
 3619 0397 61 05                   		cmp	#0, r5
 3620 0399 21 20                   		bne	.L240
2959:../src/wolfcrypt/src/ecc.c ****         err = mp_sub(modulus, P->y, R[2]->y);
 3621                             		.loc 2 2959 32
 3622 039b ED A5 0C                		mov.L	48[r10], r5
 3623 039e 72 54 10 03             		add	#0x310, r5, r4
 3624                             		.loc 2 2959 38
 3625 03a2 ED A5 0E                		mov.L	56[r10], r5
 3626 03a5 62 85                   		add	#8, r5
 3627 03a7 EC 55                   		mov.L	[r5], r5
 3628                             		.loc 2 2959 41
 3629 03a9 72 55 10 03             		add	#0x310, r5
 3630                             		.loc 2 2959 15
 3631 03ad EF 53                   		mov.L	r5, r3
 3632 03af EF 42                   		mov.L	r4, r2
 3633 03b1 A8 69                   		mov.L	4[r6], r1
 3634 03b3 05 00 00 00             		bsr	_sp_sub
 3635 03b7 E3 A1                   		mov.L	r1, [r10]
 3636                             	.L240:
2960:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3637                             		.loc 2 2960 8
 3638 03b9 EC A5                   		mov.L	[r10], r5
 3639 03bb 61 05                   		cmp	#0, r5
 3640 03bd 21 1E                   		bne	.L241
2961:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->z, R[2]->z);
 3641                             		.loc 2 2961 24
 3642 03bf ED A5 0C                		mov.L	48[r10], r5
 3643 03c2 72 54 20 06             		add	#0x620, r5, r4
 3644                             		.loc 2 2961 30
 3645 03c6 ED A5 0E                		mov.L	56[r10], r5
 3646 03c9 62 85                   		add	#8, r5
 3647 03cb EC 55                   		mov.L	[r5], r5
 3648                             		.loc 2 2961 33
 3649 03cd 72 55 20 06             		add	#0x620, r5
 3650                             		.loc 2 2961 15
 3651 03d1 EF 52                   		mov.L	r5, r2
 3652 03d3 EF 41                   		mov.L	r4, r1
 3653 03d5 05 00 00 00             		bsr	_sp_copy
 3654 03d9 E3 A1                   		mov.L	r1, [r10]
 3655                             	.L241:
2962:../src/wolfcrypt/src/ecc.c ****     /* Subtract point by adding negative. */
2963:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 3656                             		.loc 2 2963 8
 3657 03db EC A5                   		mov.L	[r10], r5
 3658 03dd 61 05                   		cmp	#0, r5
 3659 03df 3B 21 01                		bne	.L242
2964:../src/wolfcrypt/src/ecc.c ****         b = k->dp[0] & 1;
 3660                             		.loc 2 2964 18
 3661 03e2 ED A5 0B                		mov.L	44[r10], r5
 3662 03e5 A8 D5                   		mov.L	8[r5], r5
 3663                             		.loc 2 2964 11
 3664 03e7 64 15                   		and	#1, r5
 3665 03e9 E7 A5 09                		mov.L	r5, 36[r10]
2965:../src/wolfcrypt/src/ecc.c **** #ifdef WC_NO_CACHE_RESISTANT
2966:../src/wolfcrypt/src/ecc.c ****         err = ecc_projective_add_point_safe(R[b], R[2], R[b], a, modulus, mp,
2967:../src/wolfcrypt/src/ecc.c ****                                                                      &infinity);
2968:../src/wolfcrypt/src/ecc.c **** #else
2969:../src/wolfcrypt/src/ecc.c ****         /* Swap R[0] and R[1], if necessary, to operate on the one we want. */
2970:../src/wolfcrypt/src/ecc.c ****         err = mp_cond_swap_ct(R[0]->x, R[1]->x, modulus->used, (int)b);
 3666                             		.loc 2 2970 32
 3667 03ec ED A5 0E                		mov.L	56[r10], r5
 3668 03ef EC 55                   		mov.L	[r5], r5
 3669                             		.loc 2 2970 35
 3670 03f1 EF 51                   		mov.L	r5, r1
 3671                             		.loc 2 2970 41
 3672 03f3 ED A5 0E                		mov.L	56[r10], r5
 3673 03f6 62 45                   		add	#4, r5
 3674 03f8 EC 55                   		mov.L	[r5], r5
 3675                             		.loc 2 2970 44
 3676 03fa EF 52                   		mov.L	r5, r2
 3677                             		.loc 2 2970 15
 3678 03fc A8 6D                   		mov.L	4[r6], r5
 3679 03fe EC 55                   		mov.L	[r5], r5
 3680 0400 ED A4 09                		mov.L	36[r10], r4
 3681 0403 EF 53                   		mov.L	r5, r3
 3682 0405 05 00 00 00             		bsr	_sp_cond_swap_ct
 3683 0409 E3 A1                   		mov.L	r1, [r10]
2971:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3684                             		.loc 2 2971 12
 3685 040b EC A5                   		mov.L	[r10], r5
 3686 040d 61 05                   		cmp	#0, r5
 3687 040f 21 25                   		bne	.L243
2972:../src/wolfcrypt/src/ecc.c ****             err = mp_cond_swap_ct(R[0]->y, R[1]->y, modulus->used, (int)b);
 3688                             		.loc 2 2972 36
 3689 0411 ED A5 0E                		mov.L	56[r10], r5
 3690 0414 EC 55                   		mov.L	[r5], r5
 3691                             		.loc 2 2972 39
 3692 0416 72 51 10 03             		add	#0x310, r5, r1
 3693                             		.loc 2 2972 45
 3694 041a ED A5 0E                		mov.L	56[r10], r5
 3695 041d 62 45                   		add	#4, r5
 3696 041f EC 55                   		mov.L	[r5], r5
 3697                             		.loc 2 2972 48
 3698 0421 72 52 10 03             		add	#0x310, r5, r2
 3699                             		.loc 2 2972 19
 3700 0425 A8 6D                   		mov.L	4[r6], r5
 3701 0427 EC 55                   		mov.L	[r5], r5
 3702 0429 ED A4 09                		mov.L	36[r10], r4
 3703 042c EF 53                   		mov.L	r5, r3
 3704 042e 05 00 00 00             		bsr	_sp_cond_swap_ct
 3705 0432 E3 A1                   		mov.L	r1, [r10]
 3706                             	.L243:
2973:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3707                             		.loc 2 2973 12
 3708 0434 EC A5                   		mov.L	[r10], r5
 3709 0436 61 05                   		cmp	#0, r5
 3710 0438 21 25                   		bne	.L244
2974:../src/wolfcrypt/src/ecc.c ****             err = mp_cond_swap_ct(R[0]->z, R[1]->z, modulus->used, (int)b);
 3711                             		.loc 2 2974 36
 3712 043a ED A5 0E                		mov.L	56[r10], r5
 3713 043d EC 55                   		mov.L	[r5], r5
 3714                             		.loc 2 2974 39
 3715 043f 72 51 20 06             		add	#0x620, r5, r1
 3716                             		.loc 2 2974 45
 3717 0443 ED A5 0E                		mov.L	56[r10], r5
 3718 0446 62 45                   		add	#4, r5
 3719 0448 EC 55                   		mov.L	[r5], r5
 3720                             		.loc 2 2974 48
 3721 044a 72 52 20 06             		add	#0x620, r5, r2
 3722                             		.loc 2 2974 19
 3723 044e A8 6D                   		mov.L	4[r6], r5
 3724 0450 EC 55                   		mov.L	[r5], r5
 3725 0452 ED A4 09                		mov.L	36[r10], r4
 3726 0455 EF 53                   		mov.L	r5, r3
 3727 0457 05 00 00 00             		bsr	_sp_cond_swap_ct
 3728 045b E3 A1                   		mov.L	r1, [r10]
 3729                             	.L244:
2975:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3730                             		.loc 2 2975 12
 3731 045d EC A5                   		mov.L	[r10], r5
 3732 045f 61 05                   		cmp	#0, r5
 3733 0461 21 28                   		bne	.L245
2976:../src/wolfcrypt/src/ecc.c ****             err = ecc_projective_add_point_safe(R[0], R[2], R[0], a, modulus,
 3734                             		.loc 2 2976 19
 3735 0463 ED A5 0E                		mov.L	56[r10], r5
 3736 0466 EC 51                   		mov.L	[r5], r1
 3737                             		.loc 2 2976 56
 3738 0468 ED A5 0E                		mov.L	56[r10], r5
 3739 046b 62 85                   		add	#8, r5
 3740                             		.loc 2 2976 19
 3741 046d EC 52                   		mov.L	[r5], r2
 3742 046f ED A5 0E                		mov.L	56[r10], r5
 3743 0472 EC 53                   		mov.L	[r5], r3
 3744 0474 71 A5 28                		add	#40, r10, r5
 3745 0477 A0 85                   		mov.L	r5, 8[r0]
 3746 0479 A8 E5                   		mov.L	8[r6], r5
 3747 047b A0 0D                   		mov.L	r5, 4[r0]
 3748 047d A8 6D                   		mov.L	4[r6], r5
 3749 047f E3 05                   		mov.L	r5, [r0]
 3750 0481 EC 64                   		mov.L	[r6], r4
 3751 0483 05 00 00 00             		bsr	_ecc_projective_add_point_safe
 3752 0487 E3 A1                   		mov.L	r1, [r10]
 3753                             	.L245:
2977:../src/wolfcrypt/src/ecc.c ****                                                                  mp, &infinity);
2978:../src/wolfcrypt/src/ecc.c ****         /* Swap back if necessary. */
2979:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3754                             		.loc 2 2979 12
 3755 0489 EC A5                   		mov.L	[r10], r5
 3756 048b 61 05                   		cmp	#0, r5
 3757 048d 21 21                   		bne	.L246
2980:../src/wolfcrypt/src/ecc.c ****             err = mp_cond_swap_ct(R[0]->x, R[1]->x, modulus->used, (int)b);
 3758                             		.loc 2 2980 36
 3759 048f ED A5 0E                		mov.L	56[r10], r5
 3760 0492 EC 55                   		mov.L	[r5], r5
 3761                             		.loc 2 2980 39
 3762 0494 EF 51                   		mov.L	r5, r1
 3763                             		.loc 2 2980 45
 3764 0496 ED A5 0E                		mov.L	56[r10], r5
 3765 0499 62 45                   		add	#4, r5
 3766 049b EC 55                   		mov.L	[r5], r5
 3767                             		.loc 2 2980 48
 3768 049d EF 52                   		mov.L	r5, r2
 3769                             		.loc 2 2980 19
 3770 049f A8 6D                   		mov.L	4[r6], r5
 3771 04a1 EC 55                   		mov.L	[r5], r5
 3772 04a3 ED A4 09                		mov.L	36[r10], r4
 3773 04a6 EF 53                   		mov.L	r5, r3
 3774 04a8 05 00 00 00             		bsr	_sp_cond_swap_ct
 3775 04ac E3 A1                   		mov.L	r1, [r10]
 3776                             	.L246:
2981:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3777                             		.loc 2 2981 12
 3778 04ae EC A5                   		mov.L	[r10], r5
 3779 04b0 61 05                   		cmp	#0, r5
 3780 04b2 21 25                   		bne	.L247
2982:../src/wolfcrypt/src/ecc.c ****             err = mp_cond_swap_ct(R[0]->y, R[1]->y, modulus->used, (int)b);
 3781                             		.loc 2 2982 36
 3782 04b4 ED A5 0E                		mov.L	56[r10], r5
 3783 04b7 EC 55                   		mov.L	[r5], r5
 3784                             		.loc 2 2982 39
 3785 04b9 72 51 10 03             		add	#0x310, r5, r1
 3786                             		.loc 2 2982 45
 3787 04bd ED A5 0E                		mov.L	56[r10], r5
 3788 04c0 62 45                   		add	#4, r5
 3789 04c2 EC 55                   		mov.L	[r5], r5
 3790                             		.loc 2 2982 48
 3791 04c4 72 52 10 03             		add	#0x310, r5, r2
 3792                             		.loc 2 2982 19
 3793 04c8 A8 6D                   		mov.L	4[r6], r5
 3794 04ca EC 55                   		mov.L	[r5], r5
 3795 04cc ED A4 09                		mov.L	36[r10], r4
 3796 04cf EF 53                   		mov.L	r5, r3
 3797 04d1 05 00 00 00             		bsr	_sp_cond_swap_ct
 3798 04d5 E3 A1                   		mov.L	r1, [r10]
 3799                             	.L247:
2983:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 3800                             		.loc 2 2983 12
 3801 04d7 EC A5                   		mov.L	[r10], r5
 3802 04d9 61 05                   		cmp	#0, r5
 3803 04db 21 25                   		bne	.L242
2984:../src/wolfcrypt/src/ecc.c ****             err = mp_cond_swap_ct(R[0]->z, R[1]->z, modulus->used, (int)b);
 3804                             		.loc 2 2984 36
 3805 04dd ED A5 0E                		mov.L	56[r10], r5
 3806 04e0 EC 55                   		mov.L	[r5], r5
 3807                             		.loc 2 2984 39
 3808 04e2 72 51 20 06             		add	#0x620, r5, r1
 3809                             		.loc 2 2984 45
 3810 04e6 ED A5 0E                		mov.L	56[r10], r5
 3811 04e9 62 45                   		add	#4, r5
 3812 04eb EC 55                   		mov.L	[r5], r5
 3813                             		.loc 2 2984 48
 3814 04ed 72 52 20 06             		add	#0x620, r5, r2
 3815                             		.loc 2 2984 19
 3816 04f1 A8 6D                   		mov.L	4[r6], r5
 3817 04f3 EC 55                   		mov.L	[r5], r5
 3818 04f5 ED A4 09                		mov.L	36[r10], r4
 3819 04f8 EF 53                   		mov.L	r5, r3
 3820 04fa 05 00 00 00             		bsr	_sp_cond_swap_ct
 3821 04fe E3 A1                   		mov.L	r1, [r10]
 3822                             	.L242:
2985:../src/wolfcrypt/src/ecc.c **** #endif
2986:../src/wolfcrypt/src/ecc.c ****     }
2987:../src/wolfcrypt/src/ecc.c **** 
2988:../src/wolfcrypt/src/ecc.c ****     /* Step 6: return R[0] */
2989:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3823                             		.loc 2 2989 8
 3824 0500 EC A5                   		mov.L	[r10], r5
 3825 0502 61 05                   		cmp	#0, r5
 3826 0504 21 14                   		bne	.L248
2990:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(R[0]->x, Q->x);
 3827                             		.loc 2 2990 24
 3828 0506 ED A5 0E                		mov.L	56[r10], r5
 3829 0509 EC 55                   		mov.L	[r5], r5
 3830                             		.loc 2 2990 33
 3831 050b ED A4 0D                		mov.L	52[r10], r4
 3832                             		.loc 2 2990 15
 3833 050e EF 42                   		mov.L	r4, r2
 3834 0510 EF 51                   		mov.L	r5, r1
 3835 0512 05 00 00 00             		bsr	_sp_copy
 3836 0516 E3 A1                   		mov.L	r1, [r10]
 3837                             	.L248:
2991:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3838                             		.loc 2 2991 8
 3839 0518 EC A5                   		mov.L	[r10], r5
 3840 051a 61 05                   		cmp	#0, r5
 3841 051c 21 1C                   		bne	.L249
2992:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(R[0]->y, Q->y);
 3842                             		.loc 2 2992 24
 3843 051e ED A5 0E                		mov.L	56[r10], r5
 3844 0521 EC 55                   		mov.L	[r5], r5
 3845                             		.loc 2 2992 27
 3846 0523 72 54 10 03             		add	#0x310, r5, r4
 3847                             		.loc 2 2992 33
 3848 0527 ED A5 0D                		mov.L	52[r10], r5
 3849 052a 72 55 10 03             		add	#0x310, r5
 3850                             		.loc 2 2992 15
 3851 052e EF 52                   		mov.L	r5, r2
 3852 0530 EF 41                   		mov.L	r4, r1
 3853 0532 05 00 00 00             		bsr	_sp_copy
 3854 0536 E3 A1                   		mov.L	r1, [r10]
 3855                             	.L249:
2993:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 3856                             		.loc 2 2993 8
 3857 0538 EC A5                   		mov.L	[r10], r5
 3858 053a 61 05                   		cmp	#0, r5
 3859 053c 21 1C                   		bne	.L250
2994:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(R[0]->z, Q->z);
 3860                             		.loc 2 2994 24
 3861 053e ED A5 0E                		mov.L	56[r10], r5
 3862 0541 EC 55                   		mov.L	[r5], r5
 3863                             		.loc 2 2994 27
 3864 0543 72 54 20 06             		add	#0x620, r5, r4
 3865                             		.loc 2 2994 33
 3866 0547 ED A5 0D                		mov.L	52[r10], r5
 3867 054a 72 55 20 06             		add	#0x620, r5
 3868                             		.loc 2 2994 15
 3869 054e EF 52                   		mov.L	r5, r2
 3870 0550 EF 41                   		mov.L	r4, r1
 3871 0552 05 00 00 00             		bsr	_sp_copy
 3872 0556 E3 A1                   		mov.L	r1, [r10]
 3873                             	.L250:
2995:../src/wolfcrypt/src/ecc.c **** 
2996:../src/wolfcrypt/src/ecc.c ****     return err;
 3874                             		.loc 2 2996 12
 3875 0558 EC A5                   		mov.L	[r10], r5
2997:../src/wolfcrypt/src/ecc.c **** }
 3876                             		.loc 2 2997 1
 3877 055a EF 51                   		mov.L	r5, r1
 3878 055c 71 00 58                		add	#0x58, r0
 3879 055f 7E B6                   		pop	r6
 3880 0561 7E BA                   		pop	r10
 3881 0563 02                      		rts
 3882                             	.LFE57:
 3884                             		.section	.text.ecc_point_to_mont,"ax",@progbits
 3886                             	_ecc_point_to_mont:
 3887                             	.LFB58:
2998:../src/wolfcrypt/src/ecc.c **** 
2999:../src/wolfcrypt/src/ecc.c **** #else
3000:../src/wolfcrypt/src/ecc.c **** /* Number of points to allocate for use during scalar multiplication. */
3001:../src/wolfcrypt/src/ecc.c **** #define M_POINTS        5
3002:../src/wolfcrypt/src/ecc.c **** /* Last of the points is used as a temporary during calculations. */
3003:../src/wolfcrypt/src/ecc.c **** #define TMP_IDX         M_POINTS - 1
3004:../src/wolfcrypt/src/ecc.c **** 
3005:../src/wolfcrypt/src/ecc.c **** static void mp_cond_swap_into_ct(mp_int* ra, mp_int* rb, mp_int* a, mp_int* b,
3006:../src/wolfcrypt/src/ecc.c ****     int digits, int m)
3007:../src/wolfcrypt/src/ecc.c **** {
3008:../src/wolfcrypt/src/ecc.c ****     int i;
3009:../src/wolfcrypt/src/ecc.c **** 
3010:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH_ALL) || defined(WOLFSSL_SP_INT_NEGATIVE)
3011:../src/wolfcrypt/src/ecc.c ****     /* Only using positive numbers in ECC operations. */
3012:../src/wolfcrypt/src/ecc.c ****     ra->sign = 0;
3013:../src/wolfcrypt/src/ecc.c ****     rb->sign = 0;
3014:../src/wolfcrypt/src/ecc.c **** #endif
3015:../src/wolfcrypt/src/ecc.c ****     /* Don't store 0 when mask is 0, it will be in a register. */
3016:../src/wolfcrypt/src/ecc.c ****     ra->used = (int)(((a->used ^ b->used) & ((mp_digit)0 - (m & 1))) ^ a->used);
3017:../src/wolfcrypt/src/ecc.c ****     rb->used = (int)(((a->used ^ b->used) & ((mp_digit)0 - (m & 1))) ^ b->used);
3018:../src/wolfcrypt/src/ecc.c ****     for (i = 0; i < digits; i++) {
3019:../src/wolfcrypt/src/ecc.c ****         ra->dp[i] = ((a->dp[i] ^ b->dp[i]) & ((mp_digit)0 - (m & 1))) ^
3020:../src/wolfcrypt/src/ecc.c ****                     a->dp[i];
3021:../src/wolfcrypt/src/ecc.c ****         rb->dp[i] = ((a->dp[i] ^ b->dp[i]) & ((mp_digit)0 - (m & 1))) ^
3022:../src/wolfcrypt/src/ecc.c ****                     b->dp[i];
3023:../src/wolfcrypt/src/ecc.c ****     }
3024:../src/wolfcrypt/src/ecc.c **** }
3025:../src/wolfcrypt/src/ecc.c **** 
3026:../src/wolfcrypt/src/ecc.c **** static void ecc_cond_swap_into_ct(ecc_point* ra, ecc_point* rb, ecc_point* a,
3027:../src/wolfcrypt/src/ecc.c ****     ecc_point* b, int digits, int m)
3028:../src/wolfcrypt/src/ecc.c **** {
3029:../src/wolfcrypt/src/ecc.c ****     /* Conditionally swap each ordinate. */
3030:../src/wolfcrypt/src/ecc.c ****     mp_cond_swap_into_ct(ra->x, rb->x, a->x, b->x, digits, m);
3031:../src/wolfcrypt/src/ecc.c ****     mp_cond_swap_into_ct(ra->y, rb->y, a->y, b->y, digits, m);
3032:../src/wolfcrypt/src/ecc.c ****     mp_cond_swap_into_ct(ra->z, rb->z, a->z, b->z, digits, m);
3033:../src/wolfcrypt/src/ecc.c **** }
3034:../src/wolfcrypt/src/ecc.c **** 
3035:../src/wolfcrypt/src/ecc.c **** /* Joye double-add ladder.
3036:../src/wolfcrypt/src/ecc.c ****  * "Highly Regular Right-to-Left Algorithms for Scalar Multiplication"
3037:../src/wolfcrypt/src/ecc.c ****  * by Marc Joye (2007)
3038:../src/wolfcrypt/src/ecc.c ****  *
3039:../src/wolfcrypt/src/ecc.c ****  * Algorithm 1':
3040:../src/wolfcrypt/src/ecc.c ****  *   Input: P element of curve, k = (k[t-1],..., k[0]) base 2
3041:../src/wolfcrypt/src/ecc.c ****  *   Output: Q = kP
3042:../src/wolfcrypt/src/ecc.c ****  *   1: R[0] = P; R[1] = P
3043:../src/wolfcrypt/src/ecc.c ****  *   2: for j = 1 to t-1 do
3044:../src/wolfcrypt/src/ecc.c ****  *   3:   b = 1 - k[j]; R[b] = 2*R[b] + R[k[j]]
3045:../src/wolfcrypt/src/ecc.c ****  *   4: end for
3046:../src/wolfcrypt/src/ecc.c ****  *   5: b = k[0]; R[b] = R[b] - P
3047:../src/wolfcrypt/src/ecc.c ****  *   6: return R[0]
3048:../src/wolfcrypt/src/ecc.c ****  *
3049:../src/wolfcrypt/src/ecc.c ****  * Assumes: k < order.
3050:../src/wolfcrypt/src/ecc.c ****  */
3051:../src/wolfcrypt/src/ecc.c **** static int ecc_mulmod(const mp_int* k, ecc_point* P, ecc_point* Q,
3052:../src/wolfcrypt/src/ecc.c ****     ecc_point** R, mp_int* a, mp_int* modulus, mp_digit mp, WC_RNG* rng)
3053:../src/wolfcrypt/src/ecc.c **** {
3054:../src/wolfcrypt/src/ecc.c ****     int          err = MP_OKAY;
3055:../src/wolfcrypt/src/ecc.c ****     int          bytes = (mp_count_bits(modulus) + 7) / 8;
3056:../src/wolfcrypt/src/ecc.c ****     int          i;
3057:../src/wolfcrypt/src/ecc.c ****     int          j = 1;
3058:../src/wolfcrypt/src/ecc.c ****     int          cnt;
3059:../src/wolfcrypt/src/ecc.c ****     int          t = 0;
3060:../src/wolfcrypt/src/ecc.c ****     mp_int*      kt = R[TMP_IDX]->x;
3061:../src/wolfcrypt/src/ecc.c ****     /* First bit always 1 (fix at end) and swap equals first bit */
3062:../src/wolfcrypt/src/ecc.c ****     register int swap = 1;
3063:../src/wolfcrypt/src/ecc.c ****     /* Which pair of points has current value. R[0,1] or R[2,3] */
3064:../src/wolfcrypt/src/ecc.c ****     int          set = 0;
3065:../src/wolfcrypt/src/ecc.c ****     int          infinity;
3066:../src/wolfcrypt/src/ecc.c **** 
3067:../src/wolfcrypt/src/ecc.c ****     /* Step 1: R[0] = P; R[1] = P */
3068:../src/wolfcrypt/src/ecc.c ****     /* R[0] = P */
3069:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3070:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->x, R[0]->x);
3071:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3072:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->y, R[0]->y);
3073:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3074:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->z, R[0]->z);
3075:../src/wolfcrypt/src/ecc.c **** 
3076:../src/wolfcrypt/src/ecc.c ****     /* R[1] = P */
3077:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3078:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->x, R[1]->x);
3079:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3080:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->y, R[1]->y);
3081:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3082:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->z, R[1]->z);
3083:../src/wolfcrypt/src/ecc.c **** 
3084:../src/wolfcrypt/src/ecc.c ****     /* Randomize z ordinates to obfuscate timing. */
3085:../src/wolfcrypt/src/ecc.c ****     if ((err == MP_OKAY) && (rng != NULL))
3086:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_gen_z(rng, bytes, R[0], modulus, mp, R[TMP_IDX]->x,
3087:../src/wolfcrypt/src/ecc.c ****                            R[TMP_IDX]->y);
3088:../src/wolfcrypt/src/ecc.c ****     if ((err == MP_OKAY) && (rng != NULL))
3089:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_gen_z(rng, bytes, R[1], modulus, mp, R[TMP_IDX]->x,
3090:../src/wolfcrypt/src/ecc.c ****                            R[TMP_IDX]->y);
3091:../src/wolfcrypt/src/ecc.c **** 
3092:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
3093:../src/wolfcrypt/src/ecc.c ****         /* Order could be one greater than the size of the modulus. */
3094:../src/wolfcrypt/src/ecc.c ****         t = mp_count_bits(modulus) + 1;
3095:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(k, kt);
3096:../src/wolfcrypt/src/ecc.c ****     }
3097:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
3098:../src/wolfcrypt/src/ecc.c ****         err = mp_grow(kt, modulus->used + 1);
3099:../src/wolfcrypt/src/ecc.c ****     }
3100:../src/wolfcrypt/src/ecc.c ****     /* Step 2: for j = 1 to t-1 do */
3101:../src/wolfcrypt/src/ecc.c ****     for (i = 1, j = 0, cnt = 0; (err == MP_OKAY) && (i < t); i++) {
3102:../src/wolfcrypt/src/ecc.c ****         if (++cnt == DIGIT_BIT) {
3103:../src/wolfcrypt/src/ecc.c ****             j++;
3104:../src/wolfcrypt/src/ecc.c ****             cnt = 0;
3105:../src/wolfcrypt/src/ecc.c ****         }
3106:../src/wolfcrypt/src/ecc.c **** 
3107:../src/wolfcrypt/src/ecc.c ****         /* Step 3: b = 1 - k[j]; R[b] = 2*R[b] + R[k[j]] */
3108:../src/wolfcrypt/src/ecc.c ****         /* Swap R[0] and R[1] if other index is needed. */
3109:../src/wolfcrypt/src/ecc.c ****         /* Ensure 'swap' changes when shifted word is 0. */
3110:../src/wolfcrypt/src/ecc.c ****         swap += (kt->dp[j] >> cnt) + 2;
3111:../src/wolfcrypt/src/ecc.c ****         ecc_cond_swap_into_ct(R[(2 - set) + 0], R[(2 - set) + 1],
3112:../src/wolfcrypt/src/ecc.c ****                               R[set + 0], R[set + 1], modulus->used, swap);
3113:../src/wolfcrypt/src/ecc.c ****         /* Change to operate on set copied into. */
3114:../src/wolfcrypt/src/ecc.c ****         set = 2 - set;
3115:../src/wolfcrypt/src/ecc.c ****         /* Ensure 'swap' changes to a previously unseen value. */
3116:../src/wolfcrypt/src/ecc.c ****         swap += (kt->dp[j] >> cnt) + swap;
3117:../src/wolfcrypt/src/ecc.c **** 
3118:../src/wolfcrypt/src/ecc.c ****         /* R[0] = 2*R[0] */
3119:../src/wolfcrypt/src/ecc.c ****         err = ecc_projective_dbl_point_safe(R[set + 0], R[set + 0], a, modulus,
3120:../src/wolfcrypt/src/ecc.c ****                                             mp);
3121:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
3122:../src/wolfcrypt/src/ecc.c ****             /* R[0] = R[1] + R[0] */
3123:../src/wolfcrypt/src/ecc.c ****             err = ecc_projective_add_point_safe(R[set + 0], R[set + 1],
3124:../src/wolfcrypt/src/ecc.c ****                                          R[set + 0], a, modulus, mp, &infinity);
3125:../src/wolfcrypt/src/ecc.c ****         }
3126:../src/wolfcrypt/src/ecc.c ****         /*  R[1]->z * 2 - same point. */
3127:../src/wolfcrypt/src/ecc.c ****         mp_addmod_ct(R[set + 1]->z, R[set + 1]->z, modulus, R[set + 1]->z);
3128:../src/wolfcrypt/src/ecc.c ****         mp_addmod_ct(R[set + 1]->x, R[set + 1]->x, modulus, R[set + 1]->x);
3129:../src/wolfcrypt/src/ecc.c ****         mp_addmod_ct(R[set + 1]->x, R[set + 1]->x, modulus, R[set + 1]->x);
3130:../src/wolfcrypt/src/ecc.c ****         mp_addmod_ct(R[set + 1]->y, R[set + 1]->y, modulus, R[set + 1]->y);
3131:../src/wolfcrypt/src/ecc.c ****         mp_addmod_ct(R[set + 1]->y, R[set + 1]->y, modulus, R[set + 1]->y);
3132:../src/wolfcrypt/src/ecc.c ****         mp_addmod_ct(R[set + 1]->y, R[set + 1]->y, modulus, R[set + 1]->y);
3133:../src/wolfcrypt/src/ecc.c ****     }
3134:../src/wolfcrypt/src/ecc.c ****     /* Step 4: end for */
3135:../src/wolfcrypt/src/ecc.c ****     /* Swap back if last bit is 0. */
3136:../src/wolfcrypt/src/ecc.c ****     /* Ensure 'swap' changes. */
3137:../src/wolfcrypt/src/ecc.c ****     swap += 1;
3138:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
3139:../src/wolfcrypt/src/ecc.c ****         ecc_cond_swap_into_ct(R[(2 - set) + 0], R[(2 - set) + 1],
3140:../src/wolfcrypt/src/ecc.c ****                               R[set + 0], R[set + 1], modulus->used, swap);
3141:../src/wolfcrypt/src/ecc.c ****         set = 2 - set;
3142:../src/wolfcrypt/src/ecc.c ****     }
3143:../src/wolfcrypt/src/ecc.c **** 
3144:../src/wolfcrypt/src/ecc.c ****     /* Step 5: b = k[0]; R[b] = R[b] - P */
3145:../src/wolfcrypt/src/ecc.c ****     /* R[TMP_IDX] = -P */
3146:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3147:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->x, R[TMP_IDX]->x);
3148:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3149:../src/wolfcrypt/src/ecc.c ****         err = mp_sub(modulus, P->y, R[TMP_IDX]->y);
3150:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3151:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(P->z, R[TMP_IDX]->z);
3152:../src/wolfcrypt/src/ecc.c ****     /* Subtract point by adding negative. */
3153:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
3154:../src/wolfcrypt/src/ecc.c ****         /* Swap R[0] and R[1], if necessary, to operate on the one we want.
3155:../src/wolfcrypt/src/ecc.c ****          * Last bit of k->dp[0] is being used to make decision to swap.
3156:../src/wolfcrypt/src/ecc.c ****          */
3157:../src/wolfcrypt/src/ecc.c ****         ecc_cond_swap_into_ct(R[(2 - set) + 0], R[(2 - set) + 1],
3158:../src/wolfcrypt/src/ecc.c ****                               R[set + 0], R[set + 1], modulus->used,
3159:../src/wolfcrypt/src/ecc.c ****                               (int)k->dp[0]);
3160:../src/wolfcrypt/src/ecc.c ****         set = 2 - set;
3161:../src/wolfcrypt/src/ecc.c ****         err = ecc_projective_add_point_safe(R[set + 0], R[TMP_IDX], R[set + 0],
3162:../src/wolfcrypt/src/ecc.c ****                                             a, modulus, mp, &infinity);
3163:../src/wolfcrypt/src/ecc.c ****         /* Swap back if necessary. */
3164:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
3165:../src/wolfcrypt/src/ecc.c ****             ecc_cond_swap_into_ct(R[(2 - set) + 0], R[(2 - set) + 1],
3166:../src/wolfcrypt/src/ecc.c ****                                   R[set + 0], R[set + 1], modulus->used,
3167:../src/wolfcrypt/src/ecc.c ****                                   (int)k->dp[0]);
3168:../src/wolfcrypt/src/ecc.c ****             set = 2 - set;
3169:../src/wolfcrypt/src/ecc.c ****         }
3170:../src/wolfcrypt/src/ecc.c ****     }
3171:../src/wolfcrypt/src/ecc.c **** 
3172:../src/wolfcrypt/src/ecc.c ****     /* Step 6: return R[0] */
3173:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3174:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(R[set + 0]->x, Q->x);
3175:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3176:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(R[set + 0]->y, Q->y);
3177:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
3178:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(R[set + 0]->z, Q->z);
3179:../src/wolfcrypt/src/ecc.c **** 
3180:../src/wolfcrypt/src/ecc.c ****     return err;
3181:../src/wolfcrypt/src/ecc.c **** }
3182:../src/wolfcrypt/src/ecc.c **** 
3183:../src/wolfcrypt/src/ecc.c **** #endif
3184:../src/wolfcrypt/src/ecc.c **** 
3185:../src/wolfcrypt/src/ecc.c **** #endif
3186:../src/wolfcrypt/src/ecc.c **** 
3187:../src/wolfcrypt/src/ecc.c **** /* Convert the point to montgomery form.
3188:../src/wolfcrypt/src/ecc.c ****  *
3189:../src/wolfcrypt/src/ecc.c ****  * @param  [in]   p        Point to convert.
3190:../src/wolfcrypt/src/ecc.c ****  * @param  [out]  r        Point in montgomery form.
3191:../src/wolfcrypt/src/ecc.c ****  * @param  [in]   modulus  Modulus of ordinates.
3192:../src/wolfcrypt/src/ecc.c ****  * @return  0 on success.
3193:../src/wolfcrypt/src/ecc.c ****  * @return  -ve on failure.
3194:../src/wolfcrypt/src/ecc.c ****  */
3195:../src/wolfcrypt/src/ecc.c **** static int ecc_point_to_mont(ecc_point* p, ecc_point* r, mp_int* modulus,
3196:../src/wolfcrypt/src/ecc.c ****                              void* heap)
3197:../src/wolfcrypt/src/ecc.c **** {
 3888                             		.loc 2 3197 1
 3889 0000 7E AA                   		push.l	r10
 3890                             	.LCFI44:
 3891 0002 71 0A E4                		add	#-28, r0, r10
 3892                             	.LCFI45:
 3893 0005 EF A0                   		mov.L	r10, r0
 3894 0007 E7 A1 03                		mov.L	r1, 12[r10]
 3895 000a E7 A2 04                		mov.L	r2, 16[r10]
 3896 000d E7 A3 05                		mov.L	r3, 20[r10]
 3897 0010 E7 A4 06                		mov.L	r4, 24[r10]
3198:../src/wolfcrypt/src/ecc.c ****    int err = MP_OKAY;
 3898                             		.loc 2 3198 8
 3899 0013 F8 A6 00                		mov.L	#0, [r10]
3199:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
3200:../src/wolfcrypt/src/ecc.c ****    mp_int*       mu = NULL;
 3900                             		.loc 2 3200 18
 3901 0016 F9 A6 01 00             		mov.L	#0, 4[r10]
3201:../src/wolfcrypt/src/ecc.c **** #else
3202:../src/wolfcrypt/src/ecc.c ****    mp_int        mu[1];
3203:../src/wolfcrypt/src/ecc.c **** #endif
3204:../src/wolfcrypt/src/ecc.c **** 
3205:../src/wolfcrypt/src/ecc.c ****    (void)heap;
3206:../src/wolfcrypt/src/ecc.c **** 
3207:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
3208:../src/wolfcrypt/src/ecc.c ****    mu = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
 3902                             		.loc 2 3208 18
 3903 001a FB 1A 10 03             		mov.L	#0x310, r1
 3904 001e 05 00 00 00             		bsr	_wolfSSL_Malloc
 3905 0022 E7 A1 01                		mov.L	r1, 4[r10]
3209:../src/wolfcrypt/src/ecc.c ****    if (mu == NULL)
 3906                             		.loc 2 3209 7
 3907 0025 ED A5 01                		mov.L	4[r10], r5
 3908 0028 61 05                   		cmp	#0, r5
 3909 002a 1C                      		bne	.L253
3210:../src/wolfcrypt/src/ecc.c ****        err = MEMORY_E;
 3910                             		.loc 2 3210 12
 3911 002b F8 A6 83                		mov.L	#-125, [r10]
 3912                             	.L253:
3211:../src/wolfcrypt/src/ecc.c **** #endif
3212:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 3913                             		.loc 2 3212 7
 3914 002e EC A5                   		mov.L	[r10], r5
 3915 0030 61 05                   		cmp	#0, r5
 3916 0032 1A                      		bne	.L254
3213:../src/wolfcrypt/src/ecc.c ****        err = mp_init(mu);
 3917                             		.loc 2 3213 14
 3918 0033 ED A1 01                		mov.L	4[r10], r1
 3919 0036 05 00 00 00             		bsr	_sp_init
 3920 003a E3 A1                   		mov.L	r1, [r10]
 3921                             	.L254:
3214:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 3922                             		.loc 2 3214 7
 3923 003c EC A5                   		mov.L	[r10], r5
 3924 003e 61 05                   		cmp	#0, r5
 3925 0040 3B D2 00                		bne	.L255
3215:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_calc_normalization(mu, modulus);
 3926                             		.loc 2 3215 14
 3927 0043 ED A2 05                		mov.L	20[r10], r2
 3928 0046 ED A1 01                		mov.L	4[r10], r1
 3929 0049 05 00 00 00             		bsr	_sp_mont_norm
 3930 004d E3 A1                   		mov.L	r1, [r10]
3216:../src/wolfcrypt/src/ecc.c **** 
3217:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY) {
 3931                             		.loc 2 3217 11
 3932 004f EC A5                   		mov.L	[r10], r5
 3933 0051 61 05                   		cmp	#0, r5
 3934 0053 3B B8 00                		bne	.L256
3218:../src/wolfcrypt/src/ecc.c ****            if (mp_cmp_d(mu, 1) == MP_EQ) {
 3935                             		.loc 2 3218 16
 3936 0056 66 12                   		mov.L	#1, r2
 3937 0058 ED A1 01                		mov.L	4[r10], r1
 3938 005b 05 00 00 00             		bsr	_sp_cmp_d
 3939 005f EF 15                   		mov.L	r1, r5
 3940                             		.loc 2 3218 15
 3941 0061 61 05                   		cmp	#0, r5
 3942 0063 21 50                   		bne	.L257
3219:../src/wolfcrypt/src/ecc.c ****                err = mp_copy(p->x, r->x);
 3943                             		.loc 2 3219 31
 3944 0065 ED A5 03                		mov.L	12[r10], r5
 3945                             		.loc 2 3219 37
 3946 0068 ED A4 04                		mov.L	16[r10], r4
 3947                             		.loc 2 3219 22
 3948 006b EF 42                   		mov.L	r4, r2
 3949 006d EF 51                   		mov.L	r5, r1
 3950 006f 05 00 00 00             		bsr	_sp_copy
 3951 0073 E3 A1                   		mov.L	r1, [r10]
3220:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
 3952                             		.loc 2 3220 19
 3953 0075 EC A5                   		mov.L	[r10], r5
 3954 0077 61 05                   		cmp	#0, r5
 3955 0079 21 1A                   		bne	.L258
3221:../src/wolfcrypt/src/ecc.c ****                    err = mp_copy(p->y, r->y);
 3956                             		.loc 2 3221 35
 3957 007b ED A5 03                		mov.L	12[r10], r5
 3958 007e 72 54 10 03             		add	#0x310, r5, r4
 3959                             		.loc 2 3221 41
 3960 0082 ED A5 04                		mov.L	16[r10], r5
 3961 0085 72 55 10 03             		add	#0x310, r5
 3962                             		.loc 2 3221 26
 3963 0089 EF 52                   		mov.L	r5, r2
 3964 008b EF 41                   		mov.L	r4, r1
 3965 008d 05 00 00 00             		bsr	_sp_copy
 3966 0091 E3 A1                   		mov.L	r1, [r10]
 3967                             	.L258:
3222:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
 3968                             		.loc 2 3222 19
 3969 0093 EC A5                   		mov.L	[r10], r5
 3970 0095 61 05                   		cmp	#0, r5
 3971 0097 21 74                   		bne	.L256
3223:../src/wolfcrypt/src/ecc.c ****                    err = mp_copy(p->z, r->z);
 3972                             		.loc 2 3223 35
 3973 0099 ED A5 03                		mov.L	12[r10], r5
 3974 009c 72 54 20 06             		add	#0x620, r5, r4
 3975                             		.loc 2 3223 41
 3976 00a0 ED A5 04                		mov.L	16[r10], r5
 3977 00a3 72 55 20 06             		add	#0x620, r5
 3978                             		.loc 2 3223 26
 3979 00a7 EF 52                   		mov.L	r5, r2
 3980 00a9 EF 41                   		mov.L	r4, r1
 3981 00ab 05 00 00 00             		bsr	_sp_copy
 3982 00af E3 A1                   		mov.L	r1, [r10]
 3983 00b1 2E 5A                   		bra	.L256
 3984                             	.L257:
3224:../src/wolfcrypt/src/ecc.c ****            }
3225:../src/wolfcrypt/src/ecc.c ****            else {
3226:../src/wolfcrypt/src/ecc.c ****                err = mp_mulmod(p->x, mu, modulus, r->x);
 3985                             		.loc 2 3226 33
 3986 00b3 ED A5 03                		mov.L	12[r10], r5
 3987                             		.loc 2 3226 52
 3988 00b6 ED A4 04                		mov.L	16[r10], r4
 3989                             		.loc 2 3226 22
 3990 00b9 ED A3 05                		mov.L	20[r10], r3
 3991 00bc ED A2 01                		mov.L	4[r10], r2
 3992 00bf EF 51                   		mov.L	r5, r1
 3993 00c1 05 00 00 00             		bsr	_sp_mulmod
 3994 00c5 E3 A1                   		mov.L	r1, [r10]
3227:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
 3995                             		.loc 2 3227 19
 3996 00c7 EC A5                   		mov.L	[r10], r5
 3997 00c9 61 05                   		cmp	#0, r5
 3998 00cb 21 1E                   		bne	.L260
3228:../src/wolfcrypt/src/ecc.c ****                    err = mp_mulmod(p->y, mu, modulus, r->y);
 3999                             		.loc 2 3228 37
 4000 00cd ED A5 03                		mov.L	12[r10], r5
 4001 00d0 72 51 10 03             		add	#0x310, r5, r1
 4002                             		.loc 2 3228 56
 4003 00d4 ED A5 04                		mov.L	16[r10], r5
 4004 00d7 72 55 10 03             		add	#0x310, r5
 4005                             		.loc 2 3228 26
 4006 00db EF 54                   		mov.L	r5, r4
 4007 00dd ED A3 05                		mov.L	20[r10], r3
 4008 00e0 ED A2 01                		mov.L	4[r10], r2
 4009 00e3 05 00 00 00             		bsr	_sp_mulmod
 4010 00e7 E3 A1                   		mov.L	r1, [r10]
 4011                             	.L260:
3229:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
 4012                             		.loc 2 3229 19
 4013 00e9 EC A5                   		mov.L	[r10], r5
 4014 00eb 61 05                   		cmp	#0, r5
 4015 00ed 21 1E                   		bne	.L256
3230:../src/wolfcrypt/src/ecc.c ****                    err = mp_mulmod(p->z, mu, modulus, r->z);
 4016                             		.loc 2 3230 37
 4017 00ef ED A5 03                		mov.L	12[r10], r5
 4018 00f2 72 51 20 06             		add	#0x620, r5, r1
 4019                             		.loc 2 3230 56
 4020 00f6 ED A5 04                		mov.L	16[r10], r5
 4021 00f9 72 55 20 06             		add	#0x620, r5
 4022                             		.loc 2 3230 26
 4023 00fd EF 54                   		mov.L	r5, r4
 4024 00ff ED A3 05                		mov.L	20[r10], r3
 4025 0102 ED A2 01                		mov.L	4[r10], r2
 4026 0105 05 00 00 00             		bsr	_sp_mulmod
 4027 0109 E3 A1                   		mov.L	r1, [r10]
 4028                             		.balign 8,3,1
 4029                             	.L256:
3231:../src/wolfcrypt/src/ecc.c ****            }
3232:../src/wolfcrypt/src/ecc.c ****        }
3233:../src/wolfcrypt/src/ecc.c **** 
3234:../src/wolfcrypt/src/ecc.c ****        mp_clear(mu);
 4030                             		.loc 2 3234 8
 4031 010b ED A1 01                		mov.L	4[r10], r1
 4032 010e 05 00 00 00             		bsr	_sp_clear
 4033                             	.L255:
3235:../src/wolfcrypt/src/ecc.c ****    }
3236:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
3237:../src/wolfcrypt/src/ecc.c ****    if (mu != NULL)
 4034                             		.loc 2 3237 7
 4035 0112 ED A5 01                		mov.L	4[r10], r5
 4036 0115 61 05                   		cmp	#0, r5
 4037 0117 20 15                   		beq	.L261
 4038                             	.LBB25:
3238:../src/wolfcrypt/src/ecc.c ****       XFREE(mu, heap, DYNAMIC_TYPE_ECC);
 4039                             		.loc 2 3238 7
 4040 0119 ED A5 01                		mov.L	4[r10], r5
 4041 011c E7 A5 02                		mov.L	r5, 8[r10]
 4042 011f ED A5 02                		mov.L	8[r10], r5
 4043 0122 61 05                   		cmp	#0, r5
 4044 0124 10                      		beq	.L261
 4045                             		.loc 2 3238 7 is_stmt 0 discriminator 1
 4046 0125 ED A1 02                		mov.L	8[r10], r1
 4047 0128 05 00 00 00             		bsr	_wolfSSL_Free
 4048                             	.L261:
 4049                             	.LBE25:
3239:../src/wolfcrypt/src/ecc.c **** #endif
3240:../src/wolfcrypt/src/ecc.c ****    return err;
 4050                             		.loc 2 3240 11 is_stmt 1
 4051 012c EC A5                   		mov.L	[r10], r5
3241:../src/wolfcrypt/src/ecc.c **** }
 4052                             		.loc 2 3241 1
 4053 012e EF 51                   		mov.L	r5, r1
 4054 0130 3F AA 08                		rtsd	#32, r10-r10
 4055                             	.LFE58:
 4057 0133 77 10 01 00 00          		.section	.text.wc_ecc_mulmod_ex,"ax",@progbits
 4058                             		.global	_wc_ecc_mulmod_ex
 4060                             	_wc_ecc_mulmod_ex:
 4061                             	.LFB59:
3242:../src/wolfcrypt/src/ecc.c **** 
3243:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
3244:../src/wolfcrypt/src/ecc.c **** static int ecc_key_tmp_init(ecc_key* key, void* heap)
3245:../src/wolfcrypt/src/ecc.c **** {
3246:../src/wolfcrypt/src/ecc.c ****    int err = MP_OKAY;
3247:../src/wolfcrypt/src/ecc.c **** 
3248:../src/wolfcrypt/src/ecc.c ****    XMEMSET(key, 0, sizeof(*key));
3249:../src/wolfcrypt/src/ecc.c **** 
3250:../src/wolfcrypt/src/ecc.c ****    key->t1 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
3251:../src/wolfcrypt/src/ecc.c ****    key->t2 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
3252:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
3253:../src/wolfcrypt/src/ecc.c ****    key->x = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
3254:../src/wolfcrypt/src/ecc.c ****    key->y = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
3255:../src/wolfcrypt/src/ecc.c ****    key->z = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
3256:../src/wolfcrypt/src/ecc.c **** #endif
3257:../src/wolfcrypt/src/ecc.c ****    if (key->t1 == NULL || key->t2 == NULL
3258:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
3259:../src/wolfcrypt/src/ecc.c ****       || key->x == NULL || key->y == NULL || key->z == NULL
3260:../src/wolfcrypt/src/ecc.c **** #endif
3261:../src/wolfcrypt/src/ecc.c ****    ) {
3262:../src/wolfcrypt/src/ecc.c ****        err = MEMORY_E;
3263:../src/wolfcrypt/src/ecc.c ****    }
3264:../src/wolfcrypt/src/ecc.c **** 
3265:../src/wolfcrypt/src/ecc.c ****    return err;
3266:../src/wolfcrypt/src/ecc.c **** }
3267:../src/wolfcrypt/src/ecc.c **** 
3268:../src/wolfcrypt/src/ecc.c **** static void ecc_key_tmp_final(ecc_key* key, void* heap)
3269:../src/wolfcrypt/src/ecc.c **** {
3270:../src/wolfcrypt/src/ecc.c ****     (void)heap;
3271:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
3272:../src/wolfcrypt/src/ecc.c ****    if (key->z != NULL)
3273:../src/wolfcrypt/src/ecc.c ****       XFREE(key->z, heap, DYNAMIC_TYPE_ECC);
3274:../src/wolfcrypt/src/ecc.c ****    if (key->y != NULL)
3275:../src/wolfcrypt/src/ecc.c ****       XFREE(key->y, heap, DYNAMIC_TYPE_ECC);
3276:../src/wolfcrypt/src/ecc.c ****    if (key->x != NULL)
3277:../src/wolfcrypt/src/ecc.c ****       XFREE(key->x, heap, DYNAMIC_TYPE_ECC);
3278:../src/wolfcrypt/src/ecc.c **** #endif
3279:../src/wolfcrypt/src/ecc.c ****    if (key->t2 != NULL)
3280:../src/wolfcrypt/src/ecc.c ****       XFREE(key->t2, heap, DYNAMIC_TYPE_ECC);
3281:../src/wolfcrypt/src/ecc.c ****    if (key->t1 != NULL)
3282:../src/wolfcrypt/src/ecc.c ****       XFREE(key->t1, heap, DYNAMIC_TYPE_ECC);
3283:../src/wolfcrypt/src/ecc.c **** }
3284:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK_CACHE */
3285:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH */
3286:../src/wolfcrypt/src/ecc.c **** 
3287:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH) || !defined(FP_ECC)
3288:../src/wolfcrypt/src/ecc.c **** /**
3289:../src/wolfcrypt/src/ecc.c ****    Perform a point multiplication
3290:../src/wolfcrypt/src/ecc.c ****    k    The scalar to multiply by
3291:../src/wolfcrypt/src/ecc.c ****    G    The base point
3292:../src/wolfcrypt/src/ecc.c ****    R    [out] Destination for kG
3293:../src/wolfcrypt/src/ecc.c ****    a    ECC curve parameter a
3294:../src/wolfcrypt/src/ecc.c ****    modulus  The modulus of the field the ECC curve is in
3295:../src/wolfcrypt/src/ecc.c ****    map      Boolean whether to map back to affine or not
3296:../src/wolfcrypt/src/ecc.c ****                 (1==map, 0 == leave in projective)
3297:../src/wolfcrypt/src/ecc.c ****    return MP_OKAY on success
3298:../src/wolfcrypt/src/ecc.c **** */
3299:../src/wolfcrypt/src/ecc.c **** #ifdef FP_ECC
3300:../src/wolfcrypt/src/ecc.c **** static int normal_ecc_mulmod(const mp_int* k, ecc_point *G, ecc_point *R,
3301:../src/wolfcrypt/src/ecc.c ****                              mp_int* a, mp_int* modulus, WC_RNG* rng, int map,
3302:../src/wolfcrypt/src/ecc.c ****                              void* heap)
3303:../src/wolfcrypt/src/ecc.c **** #else
3304:../src/wolfcrypt/src/ecc.c **** int wc_ecc_mulmod_ex(const mp_int* k, ecc_point *G, ecc_point *R, mp_int* a,
3305:../src/wolfcrypt/src/ecc.c ****                      mp_int* modulus, int map, void* heap)
3306:../src/wolfcrypt/src/ecc.c **** #endif
3307:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
3308:../src/wolfcrypt/src/ecc.c **** {
 4062                             		.loc 2 3308 1
 4063 0000 6E 6B                   		pushm	r6-r11
 4064                             	.LCFI46:
 4065 0002 71 0A C8                		add	#-56, r0, r10
 4066                             	.LCFI47:
 4067 0005 71 A0 F0                		add	#-16, r10, r0
 4068                             	.LCFI48:
 4069 0008 75 46 54                		mov.L	#0x54, r6
 4070 000b 4B A6                   		add	r10, r6
 4071 000d E7 A1 07                		mov.L	r1, 28[r10]
 4072 0010 E7 A2 08                		mov.L	r2, 32[r10]
 4073 0013 E7 A3 09                		mov.L	r3, 36[r10]
 4074 0016 E7 A4 0A                		mov.L	r4, 40[r10]
3309:../src/wolfcrypt/src/ecc.c ****    ecc_point     *tG, *M[M_POINTS];
3310:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_NO_MALLOC
3311:../src/wolfcrypt/src/ecc.c ****    ecc_point     lcl_tG, lcl_M[M_POINTS];
3312:../src/wolfcrypt/src/ecc.c **** #endif
3313:../src/wolfcrypt/src/ecc.c ****    int           i, err;
3314:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
3315:../src/wolfcrypt/src/ecc.c ****    ecc_key       *key = (ecc_key *)XMALLOC(sizeof(*key), heap, DYNAMIC_TYPE_ECC);
3316:../src/wolfcrypt/src/ecc.c **** #endif
3317:../src/wolfcrypt/src/ecc.c ****    mp_digit      mp;
3318:../src/wolfcrypt/src/ecc.c **** 
3319:../src/wolfcrypt/src/ecc.c ****    /* init variables */
3320:../src/wolfcrypt/src/ecc.c ****    tG = NULL;
 4075                             		.loc 2 3320 7
 4076 0019 F9 A6 02 00             		mov.L	#0, 8[r10]
3321:../src/wolfcrypt/src/ecc.c ****    XMEMSET(M, 0, sizeof(M));
 4077                             		.loc 2 3321 4
 4078 001d 71 A5 0C                		add	#12, r10, r5
 4079 0020 66 C3                   		mov.L	#12, r3
 4080 0022 66 02                   		mov.L	#0, r2
 4081 0024 EF 51                   		mov.L	r5, r1
 4082 0026 05 00 00 00             		bsr	_memset
3322:../src/wolfcrypt/src/ecc.c **** 
3323:../src/wolfcrypt/src/ecc.c ****    if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
 4083                             		.loc 2 3323 7
 4084 002a ED A5 07                		mov.L	28[r10], r5
 4085 002d 61 05                   		cmp	#0, r5
 4086 002f 20 14                   		beq	.L264
 4087                             		.loc 2 3323 18 discriminator 1
 4088 0031 ED A5 08                		mov.L	32[r10], r5
 4089 0034 61 05                   		cmp	#0, r5
 4090 0036 20 0D                   		beq	.L264
 4091                             		.loc 2 3323 31 discriminator 2
 4092 0038 ED A5 09                		mov.L	36[r10], r5
 4093 003b 61 05                   		cmp	#0, r5
 4094 003d 16                      		beq	.L264
 4095                             		.loc 2 3323 44 discriminator 3
 4096 003e EC 65                   		mov.L	[r6], r5
 4097 0040 61 05                   		cmp	#0, r5
 4098 0042 19                      		bne	.L265
 4099                             		.balign 8,3,4
 4100                             	.L264:
3324:../src/wolfcrypt/src/ecc.c ****        err = ECC_BAD_ARG_E;
 4101                             		.loc 2 3324 12
 4102 0043 F9 AA 01 56 FF          		mov.L	#-170, 4[r10]
3325:../src/wolfcrypt/src/ecc.c ****        goto exit;
 4103                             		.loc 2 3325 8
 4104 0048 38 E3 00                		bra	.L266
 4105                             	.L265:
3326:../src/wolfcrypt/src/ecc.c ****    }
3327:../src/wolfcrypt/src/ecc.c **** 
3328:../src/wolfcrypt/src/ecc.c ****    /* k can't have more bits than modulus count plus 1 */
3329:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(k) > mp_count_bits(modulus) + 1) {
 4106                             		.loc 2 3329 8
 4107 004b ED A1 07                		mov.L	28[r10], r1
 4108 004e 05 00 00 00             		bsr	_sp_count_bits
 4109 0052 EF 1B                   		mov.L	r1, r11
 4110                             		.loc 2 3329 27
 4111 0054 EC 61                   		mov.L	[r6], r1
 4112 0056 05 00 00 00             		bsr	_sp_count_bits
 4113 005a EF 15                   		mov.L	r1, r5
 4114                             		.loc 2 3329 50
 4115 005c 62 15                   		add	#1, r5
 4116                             		.loc 2 3329 7
 4117 005e 47 5B                   		cmp	r5, r11
 4118 0060 2B 0A                   		ble	.L267
3330:../src/wolfcrypt/src/ecc.c ****        err = ECC_OUT_OF_RANGE_E;
 4119                             		.loc 2 3330 12
 4120 0062 F9 AA 01 27 FF          		mov.L	#-217, 4[r10]
3331:../src/wolfcrypt/src/ecc.c ****        goto exit;
 4121                             		.loc 2 3331 8
 4122 0067 38 C4 00                		bra	.L266
 4123                             	.L267:
3332:../src/wolfcrypt/src/ecc.c ****    }
3333:../src/wolfcrypt/src/ecc.c **** 
3334:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
3335:../src/wolfcrypt/src/ecc.c ****    if (key == NULL) {
3336:../src/wolfcrypt/src/ecc.c ****        err = MP_MEM;
3337:../src/wolfcrypt/src/ecc.c ****        goto exit;
3338:../src/wolfcrypt/src/ecc.c ****    }
3339:../src/wolfcrypt/src/ecc.c ****    err = ecc_key_tmp_init(key, heap);
3340:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY)
3341:../src/wolfcrypt/src/ecc.c ****       goto exit;
3342:../src/wolfcrypt/src/ecc.c ****    R->key = key;
3343:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK_CACHE */
3344:../src/wolfcrypt/src/ecc.c **** 
3345:../src/wolfcrypt/src/ecc.c ****   /* alloc ram for window temps */
3346:../src/wolfcrypt/src/ecc.c ****   for (i = 0; i < M_POINTS; i++) {
 4124                             		.loc 2 3346 10
 4125 006a F8 A6 00                		mov.L	#0, [r10]
 4126                             		.loc 2 3346 3
 4127 006d 2E 24                   		bra	.L268
 4128                             	.L270:
3347:../src/wolfcrypt/src/ecc.c ****   #ifdef WOLFSSL_NO_MALLOC
3348:../src/wolfcrypt/src/ecc.c ****       M[i] = &lcl_M[i];
3349:../src/wolfcrypt/src/ecc.c ****   #endif
3350:../src/wolfcrypt/src/ecc.c ****       err = wc_ecc_new_point_ex(&M[i], heap);
 4129                             		.loc 2 3350 13
 4130 006f 71 A4 0C                		add	#12, r10, r4
 4131 0072 EC A5                   		mov.L	[r10], r5
 4132 0074 6C 25                   		shll	#2, r5
 4133 0076 4B 45                   		add	r4, r5
 4134 0078 A8 E2                   		mov.L	8[r6], r2
 4135 007a EF 51                   		mov.L	r5, r1
 4136 007c 05 00 00 00             		bsr	_wc_ecc_new_point_ex
 4137 0080 E7 A1 01                		mov.L	r1, 4[r10]
3351:../src/wolfcrypt/src/ecc.c ****       if (err != MP_OKAY) {
 4138                             		.loc 2 3351 10
 4139 0083 ED A5 01                		mov.L	4[r10], r5
 4140 0086 61 05                   		cmp	#0, r5
 4141 0088 3B 99 00                		bne	.L277
3346:../src/wolfcrypt/src/ecc.c ****   #ifdef WOLFSSL_NO_MALLOC
 4142                             		.loc 2 3346 30 discriminator 2
 4143 008b EC A5                   		mov.L	[r10], r5
 4144 008d 62 15                   		add	#1, r5
 4145 008f E3 A5                   		mov.L	r5, [r10]
 4146                             	.L268:
3346:../src/wolfcrypt/src/ecc.c ****   #ifdef WOLFSSL_NO_MALLOC
 4147                             		.loc 2 3346 3 discriminator 1
 4148 0091 EC A5                   		mov.L	[r10], r5
 4149 0093 61 25                   		cmp	#2, r5
 4150 0095 2B DA                   		ble	.L270
3352:../src/wolfcrypt/src/ecc.c ****          goto exit;
3353:../src/wolfcrypt/src/ecc.c ****       }
3354:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
3355:../src/wolfcrypt/src/ecc.c ****       M[i]->key = key;
3356:../src/wolfcrypt/src/ecc.c **** #endif
3357:../src/wolfcrypt/src/ecc.c ****   }
3358:../src/wolfcrypt/src/ecc.c **** 
3359:../src/wolfcrypt/src/ecc.c ****    /* make a copy of G in case R==G */
3360:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_NO_MALLOC
3361:../src/wolfcrypt/src/ecc.c ****    tG = &lcl_tG;
3362:../src/wolfcrypt/src/ecc.c **** #endif
3363:../src/wolfcrypt/src/ecc.c ****    err = wc_ecc_new_point_ex(&tG, heap);
 4151                             		.loc 2 3363 10
 4152 0097 71 A5 08                		add	#8, r10, r5
 4153 009a A8 E2                   		mov.L	8[r6], r2
 4154 009c EF 51                   		mov.L	r5, r1
 4155 009e 05 00 00 00             		bsr	_wc_ecc_new_point_ex
 4156 00a2 E7 A1 01                		mov.L	r1, 4[r10]
3364:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY) {
 4157                             		.loc 2 3364 7
 4158 00a5 ED A5 01                		mov.L	4[r10], r5
 4159 00a8 61 05                   		cmp	#0, r5
 4160 00aa 21 79                   		bne	.L278
3365:../src/wolfcrypt/src/ecc.c ****        goto exit;
3366:../src/wolfcrypt/src/ecc.c ****    }
3367:../src/wolfcrypt/src/ecc.c ****    if ((err = ecc_point_to_mont(G, tG, modulus, heap)) != MP_OKAY) {
 4161                             		.loc 2 3367 15
 4162 00ac ED A5 02                		mov.L	8[r10], r5
 4163 00af A8 E4                   		mov.L	8[r6], r4
 4164 00b1 EC 63                   		mov.L	[r6], r3
 4165 00b3 EF 52                   		mov.L	r5, r2
 4166 00b5 ED A1 08                		mov.L	32[r10], r1
 4167 00b8 05 00 00 00             		bsr	_ecc_point_to_mont
 4168 00bc E7 A1 01                		mov.L	r1, 4[r10]
 4169                             		.loc 2 3367 7
 4170 00bf ED A5 01                		mov.L	4[r10], r5
 4171 00c2 61 05                   		cmp	#0, r5
 4172 00c4 21 61                   		bne	.L279
3368:../src/wolfcrypt/src/ecc.c ****        goto exit;
3369:../src/wolfcrypt/src/ecc.c ****    }
3370:../src/wolfcrypt/src/ecc.c **** 
3371:../src/wolfcrypt/src/ecc.c ****    /* init montgomery reduction */
3372:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {
 4173                             		.loc 2 3372 15
 4174 00c6 71 A5 18                		add	#24, r10, r5
 4175 00c9 EF 52                   		mov.L	r5, r2
 4176 00cb EC 61                   		mov.L	[r6], r1
 4177 00cd 05 00 00 00             		bsr	_sp_mont_setup
 4178 00d1 E7 A1 01                		mov.L	r1, 4[r10]
 4179                             		.loc 2 3372 7
 4180 00d4 ED A5 01                		mov.L	4[r10], r5
 4181 00d7 61 05                   		cmp	#0, r5
 4182 00d9 21 4E                   		bne	.L280
3373:../src/wolfcrypt/src/ecc.c ****        goto exit;
3374:../src/wolfcrypt/src/ecc.c ****    }
3375:../src/wolfcrypt/src/ecc.c **** 
3376:../src/wolfcrypt/src/ecc.c **** #ifdef FP_ECC
3377:../src/wolfcrypt/src/ecc.c ****    err = ecc_mulmod(k, tG, R, M, a, modulus, mp, rng);
3378:../src/wolfcrypt/src/ecc.c **** #else
3379:../src/wolfcrypt/src/ecc.c ****    err = ecc_mulmod(k, tG, R, M, a, modulus, mp, NULL);
 4183                             		.loc 2 3379 10
 4184 00db ED A2 02                		mov.L	8[r10], r2
 4185 00de ED A4 06                		mov.L	24[r10], r4
 4186 00e1 71 A5 0C                		add	#12, r10, r5
 4187 00e4 3E 03 00                		mov.L	#0, 12[r0]
 4188 00e7 A0 84                   		mov.L	r4, 8[r0]
 4189 00e9 EC 64                   		mov.L	[r6], r4
 4190 00eb A0 0C                   		mov.L	r4, 4[r0]
 4191 00ed ED A4 0A                		mov.L	40[r10], r4
 4192 00f0 E3 04                   		mov.L	r4, [r0]
 4193 00f2 EF 54                   		mov.L	r5, r4
 4194 00f4 ED A3 09                		mov.L	36[r10], r3
 4195 00f7 ED A1 07                		mov.L	28[r10], r1
 4196 00fa 05 00 00 00             		bsr	_ecc_mulmod
 4197 00fe E7 A1 01                		mov.L	r1, 4[r10]
3380:../src/wolfcrypt/src/ecc.c **** #endif
3381:../src/wolfcrypt/src/ecc.c ****    /* map R back from projective space */
3382:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY && map)
 4198                             		.loc 2 3382 7
 4199 0101 ED A5 01                		mov.L	4[r10], r5
 4200 0104 61 05                   		cmp	#0, r5
 4201 0106 21 24                   		bne	.L281
 4202                             		.loc 2 3382 23 discriminator 1
 4203 0108 A8 6D                   		mov.L	4[r6], r5
 4204 010a 61 05                   		cmp	#0, r5
 4205 010c 20 1E                   		beq	.L281
3383:../src/wolfcrypt/src/ecc.c ****        err = ecc_map(R, modulus, mp);
 4206                             		.loc 2 3383 14
 4207 010e ED A5 06                		mov.L	24[r10], r5
 4208 0111 EF 53                   		mov.L	r5, r3
 4209 0113 EC 62                   		mov.L	[r6], r2
 4210 0115 ED A1 09                		mov.L	36[r10], r1
 4211 0118 05 00 00 00             		bsr	_ecc_map
 4212 011c E7 A1 01                		mov.L	r1, 4[r10]
 4213 011f 2E 0C                   		bra	.L266
 4214                             	.L277:
3352:../src/wolfcrypt/src/ecc.c ****       }
 4215                             		.loc 2 3352 10
 4216 0121 03                      		nop
 4217 0122 09                      		bra	.L266
 4218                             	.L278:
3365:../src/wolfcrypt/src/ecc.c ****    }
 4219                             		.loc 2 3365 8
 4220 0123 03                      		nop
 4221 0124 0F                      		bra	.L266
 4222                             	.L279:
3368:../src/wolfcrypt/src/ecc.c ****    }
 4223                             		.loc 2 3368 8
 4224 0125 03                      		nop
 4225 0126 0D                      		bra	.L266
 4226                             	.L280:
3373:../src/wolfcrypt/src/ecc.c ****    }
 4227                             		.loc 2 3373 8
 4228 0127 03                      		nop
 4229 0128 2E 03                   		bra	.L266
 4230                             	.L281:
3384:../src/wolfcrypt/src/ecc.c **** 
3385:../src/wolfcrypt/src/ecc.c **** exit:
 4231                             		.loc 2 3385 1
 4232 012a 03                      		nop
 4233                             		.balign 8,3,1
 4234                             	.L266:
3386:../src/wolfcrypt/src/ecc.c **** 
3387:../src/wolfcrypt/src/ecc.c ****    /* done */
3388:../src/wolfcrypt/src/ecc.c ****    wc_ecc_del_point_ex(tG, heap);
 4235                             		.loc 2 3388 4
 4236 012b ED A5 02                		mov.L	8[r10], r5
 4237 012e A8 E2                   		mov.L	8[r6], r2
 4238 0130 EF 51                   		mov.L	r5, r1
 4239 0132 05 00 00 00             		bsr	_wc_ecc_del_point_ex
3389:../src/wolfcrypt/src/ecc.c ****    for (i = 0; i < M_POINTS; i++) {
 4240                             		.loc 2 3389 11
 4241 0136 F8 A6 00                		mov.L	#0, [r10]
 4242                             		.loc 2 3389 4
 4243 0139 2E 18                   		bra	.L274
 4244                             	.L275:
3390:../src/wolfcrypt/src/ecc.c ****        wc_ecc_del_point_ex(M[i], heap);
 4245                             		.loc 2 3390 8 discriminator 3
 4246 013b EC A5                   		mov.L	[r10], r5
 4247 013d 6C 25                   		shll	#2, r5
 4248 013f 4B A5                   		add	r10, r5
 4249 0141 A8 DD                   		mov.L	12[r5], r5
 4250 0143 A8 E2                   		mov.L	8[r6], r2
 4251 0145 EF 51                   		mov.L	r5, r1
 4252 0147 05 00 00 00             		bsr	_wc_ecc_del_point_ex
3389:../src/wolfcrypt/src/ecc.c ****    for (i = 0; i < M_POINTS; i++) {
 4253                             		.loc 2 3389 31 discriminator 3
 4254 014b EC A5                   		mov.L	[r10], r5
 4255 014d 62 15                   		add	#1, r5
 4256 014f E3 A5                   		mov.L	r5, [r10]
 4257                             	.L274:
3389:../src/wolfcrypt/src/ecc.c ****    for (i = 0; i < M_POINTS; i++) {
 4258                             		.loc 2 3389 4 discriminator 1
 4259 0151 EC A5                   		mov.L	[r10], r5
 4260 0153 61 25                   		cmp	#2, r5
 4261 0155 2B E6                   		ble	.L275
3391:../src/wolfcrypt/src/ecc.c ****    }
3392:../src/wolfcrypt/src/ecc.c **** 
3393:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
3394:../src/wolfcrypt/src/ecc.c ****    if (key) {
3395:../src/wolfcrypt/src/ecc.c ****        if (R)
3396:../src/wolfcrypt/src/ecc.c ****            R->key = NULL;
3397:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY)
3398:../src/wolfcrypt/src/ecc.c ****            ecc_key_tmp_final(key, heap);
3399:../src/wolfcrypt/src/ecc.c ****        XFREE(key, heap, DYNAMIC_TYPE_ECC);
3400:../src/wolfcrypt/src/ecc.c ****    }
3401:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK_CACHE */
3402:../src/wolfcrypt/src/ecc.c **** 
3403:../src/wolfcrypt/src/ecc.c ****    return err;
 4262                             		.loc 2 3403 11
 4263 0157 ED A5 01                		mov.L	4[r10], r5
3404:../src/wolfcrypt/src/ecc.c **** }
 4264                             		.loc 2 3404 1
 4265 015a EF 51                   		mov.L	r5, r1
 4266 015c 3F 6B 18                		rtsd	#96, r6-r11
 4267                             	.LFE59:
 4269 015f 03                      		.section	.text.wc_ecc_mulmod_ex2,"ax",@progbits
 4270                             		.global	_wc_ecc_mulmod_ex2
 4272                             	_wc_ecc_mulmod_ex2:
 4273                             	.LFB60:
3405:../src/wolfcrypt/src/ecc.c **** #else
3406:../src/wolfcrypt/src/ecc.c **** {
3407:../src/wolfcrypt/src/ecc.c ****    if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
3408:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
3409:../src/wolfcrypt/src/ecc.c ****    }
3410:../src/wolfcrypt/src/ecc.c **** 
3411:../src/wolfcrypt/src/ecc.c ****    (void)a;
3412:../src/wolfcrypt/src/ecc.c **** 
3413:../src/wolfcrypt/src/ecc.c ****    /* k can't have more bits than modulus count plus 1 */
3414:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(k) > mp_count_bits(modulus) + 1) {
3415:../src/wolfcrypt/src/ecc.c ****        return ECC_OUT_OF_RANGE_E;
3416:../src/wolfcrypt/src/ecc.c ****    }
3417:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(G->x) > mp_count_bits(modulus) ||
3418:../src/wolfcrypt/src/ecc.c ****        mp_count_bits(G->y) > mp_count_bits(modulus) ||
3419:../src/wolfcrypt/src/ecc.c ****        mp_count_bits(G->z) > mp_count_bits(modulus)) {
3420:../src/wolfcrypt/src/ecc.c ****        return IS_POINT_E;
3421:../src/wolfcrypt/src/ecc.c ****    }
3422:../src/wolfcrypt/src/ecc.c **** 
3423:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
3424:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
3425:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(modulus) == 256) {
3426:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_mulmod_256(k, G, R, map, heap);
3427:../src/wolfcrypt/src/ecc.c ****    }
3428:../src/wolfcrypt/src/ecc.c **** #endif
3429:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
3430:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(modulus) == 384) {
3431:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_mulmod_384(k, G, R, map, heap);
3432:../src/wolfcrypt/src/ecc.c ****    }
3433:../src/wolfcrypt/src/ecc.c **** #endif
3434:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
3435:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(modulus) == 521) {
3436:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_mulmod_521(k, G, R, map, heap);
3437:../src/wolfcrypt/src/ecc.c ****    }
3438:../src/wolfcrypt/src/ecc.c **** #endif
3439:../src/wolfcrypt/src/ecc.c **** #else
3440:../src/wolfcrypt/src/ecc.c ****    (void)map;
3441:../src/wolfcrypt/src/ecc.c ****    (void)map;
3442:../src/wolfcrypt/src/ecc.c ****    (void)heap;
3443:../src/wolfcrypt/src/ecc.c **** #endif
3444:../src/wolfcrypt/src/ecc.c ****    return ECC_BAD_ARG_E;
3445:../src/wolfcrypt/src/ecc.c **** }
3446:../src/wolfcrypt/src/ecc.c **** #endif
3447:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH || !FP_ECC */
3448:../src/wolfcrypt/src/ecc.c **** 
3449:../src/wolfcrypt/src/ecc.c **** #ifndef FP_ECC
3450:../src/wolfcrypt/src/ecc.c **** /**
3451:../src/wolfcrypt/src/ecc.c ****    Perform a point multiplication
3452:../src/wolfcrypt/src/ecc.c ****    k    The scalar to multiply by
3453:../src/wolfcrypt/src/ecc.c ****    G    The base point
3454:../src/wolfcrypt/src/ecc.c ****    R    [out] Destination for kG
3455:../src/wolfcrypt/src/ecc.c ****    a    ECC curve parameter a
3456:../src/wolfcrypt/src/ecc.c ****    modulus  The modulus of the field the ECC curve is in
3457:../src/wolfcrypt/src/ecc.c ****    map      Boolean whether to map back to affine or not
3458:../src/wolfcrypt/src/ecc.c ****                 (1==map, 0 == leave in projective)
3459:../src/wolfcrypt/src/ecc.c ****    return MP_OKAY on success
3460:../src/wolfcrypt/src/ecc.c **** */
3461:../src/wolfcrypt/src/ecc.c **** int wc_ecc_mulmod_ex2(const mp_int* k, ecc_point *G, ecc_point *R, mp_int* a,
3462:../src/wolfcrypt/src/ecc.c ****                       mp_int* modulus, mp_int* order, WC_RNG* rng, int map,
3463:../src/wolfcrypt/src/ecc.c ****                       void* heap)
3464:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
3465:../src/wolfcrypt/src/ecc.c **** {
 4274                             		.loc 2 3465 1
 4275 0000 6E 6B                   		pushm	r6-r11
 4276                             	.LCFI49:
 4277 0002 72 0A AC FC             		add	#-852, r0, r10
 4278                             	.LCFI50:
 4279 0006 71 A0 F0                		add	#-16, r10, r0
 4280                             	.LCFI51:
 4281 0009 FB 6A 70 03             		mov.L	#0x370, r6
 4282 000d 4B A6                   		add	r10, r6
 4283 000f E7 A1 CC                		mov.L	r1, 816[r10]
 4284 0012 E7 A2 CD                		mov.L	r2, 820[r10]
 4285 0015 E7 A3 CE                		mov.L	r3, 824[r10]
 4286 0018 E7 A4 CF                		mov.L	r4, 828[r10]
3466:../src/wolfcrypt/src/ecc.c ****    ecc_point     *tG, *M[M_POINTS];
3467:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_NO_MALLOC
3468:../src/wolfcrypt/src/ecc.c ****    ecc_point     lcl_tG, lcl_M[M_POINTS];
3469:../src/wolfcrypt/src/ecc.c **** #endif
3470:../src/wolfcrypt/src/ecc.c ****    int           i, err;
3471:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
3472:../src/wolfcrypt/src/ecc.c ****    ecc_key       key;
3473:../src/wolfcrypt/src/ecc.c **** #endif
3474:../src/wolfcrypt/src/ecc.c ****    mp_digit      mp;
3475:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
3476:../src/wolfcrypt/src/ecc.c ****    mp_int t;
3477:../src/wolfcrypt/src/ecc.c **** #endif
3478:../src/wolfcrypt/src/ecc.c **** 
3479:../src/wolfcrypt/src/ecc.c ****    if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
 4287                             		.loc 2 3479 7
 4288 001b ED A5 CC                		mov.L	816[r10], r5
 4289 001e 61 05                   		cmp	#0, r5
 4290 0020 20 14                   		beq	.L283
 4291                             		.loc 2 3479 18 discriminator 1
 4292 0022 ED A5 CD                		mov.L	820[r10], r5
 4293 0025 61 05                   		cmp	#0, r5
 4294 0027 20 0D                   		beq	.L283
 4295                             		.loc 2 3479 31 discriminator 2
 4296 0029 ED A5 CE                		mov.L	824[r10], r5
 4297 002c 61 05                   		cmp	#0, r5
 4298 002e 16                      		beq	.L283
 4299                             		.loc 2 3479 44 discriminator 3
 4300 002f EC 65                   		mov.L	[r6], r5
 4301 0031 61 05                   		cmp	#0, r5
 4302 0033 18                      		bne	.L284
 4303                             		.balign 8,3,2
 4304                             	.L283:
3480:../src/wolfcrypt/src/ecc.c ****       return ECC_BAD_ARG_E;
 4305                             		.loc 2 3480 14
 4306 0034 FB 5A 56 FF             		mov.L	#-170, r5
 4307 0038 38 13 02                		bra	.L303
 4308                             	.L284:
3481:../src/wolfcrypt/src/ecc.c ****    }
3482:../src/wolfcrypt/src/ecc.c **** 
3483:../src/wolfcrypt/src/ecc.c ****    /* k can't have more bits than order */
3484:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(k) > mp_count_bits(order)) {
 4309                             		.loc 2 3484 8
 4310 003b ED A1 CC                		mov.L	816[r10], r1
 4311 003e 05 00 00 00             		bsr	_sp_count_bits
 4312 0042 EF 1B                   		mov.L	r1, r11
 4313                             		.loc 2 3484 27
 4314 0044 A8 69                   		mov.L	4[r6], r1
 4315 0046 05 00 00 00             		bsr	_sp_count_bits
 4316 004a EF 15                   		mov.L	r1, r5
 4317                             		.loc 2 3484 7
 4318 004c 47 5B                   		cmp	r5, r11
 4319 004e 2B 09                   		ble	.L286
3485:../src/wolfcrypt/src/ecc.c ****       return ECC_OUT_OF_RANGE_E;
 4320                             		.loc 2 3485 14
 4321 0050 FB 5A 27 FF             		mov.L	#-217, r5
 4322 0054 38 F7 01                		bra	.L303
 4323                             	.L286:
3486:../src/wolfcrypt/src/ecc.c ****    }
3487:../src/wolfcrypt/src/ecc.c **** 
3488:../src/wolfcrypt/src/ecc.c ****    /* init variables */
3489:../src/wolfcrypt/src/ecc.c ****    tG = NULL;
 4324                             		.loc 2 3489 7
 4325 0057 F9 A6 03 00             		mov.L	#0, 12[r10]
3490:../src/wolfcrypt/src/ecc.c ****    XMEMSET(M, 0, sizeof(M));
 4326                             		.loc 2 3490 4
 4327 005b 71 A5 10                		add	#16, r10, r5
 4328 005e 66 C3                   		mov.L	#12, r3
 4329 0060 66 02                   		mov.L	#0, r2
 4330 0062 EF 51                   		mov.L	r5, r1
 4331 0064 05 00 00 00             		bsr	_memset
3491:../src/wolfcrypt/src/ecc.c **** 
3492:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
3493:../src/wolfcrypt/src/ecc.c ****    err = ecc_key_tmp_init(&key, heap);
3494:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY)
3495:../src/wolfcrypt/src/ecc.c ****       goto exit;
3496:../src/wolfcrypt/src/ecc.c ****    R->key = &key;
3497:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK_CACHE */
3498:../src/wolfcrypt/src/ecc.c **** 
3499:../src/wolfcrypt/src/ecc.c ****    /* alloc ram for window temps */
3500:../src/wolfcrypt/src/ecc.c ****    for (i = 0; i < M_POINTS; i++) {
 4332                             		.loc 2 3500 11
 4333 0068 F8 A6 00                		mov.L	#0, [r10]
 4334                             		.loc 2 3500 4
 4335 006b 2E 24                   		bra	.L287
 4336                             	.L290:
3501:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_NO_MALLOC
3502:../src/wolfcrypt/src/ecc.c ****       M[i] = &lcl_M[i];
3503:../src/wolfcrypt/src/ecc.c ****    #endif
3504:../src/wolfcrypt/src/ecc.c ****       err = wc_ecc_new_point_ex(&M[i], heap);
 4337                             		.loc 2 3504 13
 4338 006d 71 A4 10                		add	#16, r10, r4
 4339 0070 EC A5                   		mov.L	[r10], r5
 4340 0072 6C 25                   		shll	#2, r5
 4341 0074 4B 45                   		add	r4, r5
 4342 0076 A9 62                   		mov.L	16[r6], r2
 4343 0078 EF 51                   		mov.L	r5, r1
 4344 007a 05 00 00 00             		bsr	_wc_ecc_new_point_ex
 4345 007e E7 A1 01                		mov.L	r1, 4[r10]
3505:../src/wolfcrypt/src/ecc.c ****       if (err != MP_OKAY) {
 4346                             		.loc 2 3505 10
 4347 0081 ED A5 01                		mov.L	4[r10], r5
 4348 0084 61 05                   		cmp	#0, r5
 4349 0086 3B 89 01                		bne	.L304
3500:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_NO_MALLOC
 4350                             		.loc 2 3500 31 discriminator 2
 4351 0089 EC A5                   		mov.L	[r10], r5
 4352 008b 62 15                   		add	#1, r5
 4353 008d E3 A5                   		mov.L	r5, [r10]
 4354                             	.L287:
3500:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_NO_MALLOC
 4355                             		.loc 2 3500 4 discriminator 1
 4356 008f EC A5                   		mov.L	[r10], r5
 4357 0091 61 25                   		cmp	#2, r5
 4358 0093 2B DA                   		ble	.L290
3506:../src/wolfcrypt/src/ecc.c ****          goto exit;
3507:../src/wolfcrypt/src/ecc.c ****       }
3508:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
3509:../src/wolfcrypt/src/ecc.c ****       M[i]->key = &key;
3510:../src/wolfcrypt/src/ecc.c **** #endif
3511:../src/wolfcrypt/src/ecc.c ****   }
3512:../src/wolfcrypt/src/ecc.c **** 
3513:../src/wolfcrypt/src/ecc.c ****    /* make a copy of G in case R==G */
3514:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_NO_MALLOC
3515:../src/wolfcrypt/src/ecc.c ****    tG = &lcl_tG;
3516:../src/wolfcrypt/src/ecc.c **** #endif
3517:../src/wolfcrypt/src/ecc.c ****    err = wc_ecc_new_point_ex(&tG, heap);
 4359                             		.loc 2 3517 10
 4360 0095 71 A5 0C                		add	#12, r10, r5
 4361 0098 A9 62                   		mov.L	16[r6], r2
 4362 009a EF 51                   		mov.L	r5, r1
 4363 009c 05 00 00 00             		bsr	_wc_ecc_new_point_ex
 4364 00a0 E7 A1 01                		mov.L	r1, 4[r10]
3518:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY) {
 4365                             		.loc 2 3518 7
 4366 00a3 ED A5 01                		mov.L	4[r10], r5
 4367 00a6 61 05                   		cmp	#0, r5
 4368 00a8 3B 6A 01                		bne	.L305
3519:../src/wolfcrypt/src/ecc.c ****        goto exit;
3520:../src/wolfcrypt/src/ecc.c ****    }
3521:../src/wolfcrypt/src/ecc.c ****    if ((err = ecc_point_to_mont(G, tG, modulus, heap)) != MP_OKAY) {
 4369                             		.loc 2 3521 15
 4370 00ab ED A5 03                		mov.L	12[r10], r5
 4371 00ae A9 64                   		mov.L	16[r6], r4
 4372 00b0 EC 63                   		mov.L	[r6], r3
 4373 00b2 EF 52                   		mov.L	r5, r2
 4374 00b4 ED A1 CD                		mov.L	820[r10], r1
 4375 00b7 05 00 00 00             		bsr	_ecc_point_to_mont
 4376 00bb E7 A1 01                		mov.L	r1, 4[r10]
 4377                             		.loc 2 3521 7
 4378 00be ED A5 01                		mov.L	4[r10], r5
 4379 00c1 61 05                   		cmp	#0, r5
 4380 00c3 3B 51 01                		bne	.L306
3522:../src/wolfcrypt/src/ecc.c ****        goto exit;
3523:../src/wolfcrypt/src/ecc.c ****    }
3524:../src/wolfcrypt/src/ecc.c **** 
3525:../src/wolfcrypt/src/ecc.c ****    /* init montgomery reduction */
3526:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {
 4381                             		.loc 2 3526 15
 4382 00c6 71 A5 1C                		add	#28, r10, r5
 4383 00c9 EF 52                   		mov.L	r5, r2
 4384 00cb EC 61                   		mov.L	[r6], r1
 4385 00cd 05 00 00 00             		bsr	_sp_mont_setup
 4386 00d1 E7 A1 01                		mov.L	r1, 4[r10]
 4387                             		.loc 2 3526 7
 4388 00d4 ED A5 01                		mov.L	4[r10], r5
 4389 00d7 61 05                   		cmp	#0, r5
 4390 00d9 3B 3D 01                		bne	.L307
3527:../src/wolfcrypt/src/ecc.c ****       goto exit;
3528:../src/wolfcrypt/src/ecc.c ****    }
3529:../src/wolfcrypt/src/ecc.c **** 
3530:../src/wolfcrypt/src/ecc.c ****    /* k can't have more bits than order */
3531:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(k) > mp_count_bits(order)) {
 4391                             		.loc 2 3531 8
 4392 00dc ED A1 CC                		mov.L	816[r10], r1
 4393 00df 05 00 00 00             		bsr	_sp_count_bits
 4394 00e3 EF 1B                   		mov.L	r1, r11
 4395                             		.loc 2 3531 27
 4396 00e5 A8 69                   		mov.L	4[r6], r1
 4397 00e7 05 00 00 00             		bsr	_sp_count_bits
 4398 00eb EF 15                   		mov.L	r1, r5
 4399                             		.loc 2 3531 7
 4400 00ed 47 5B                   		cmp	r5, r11
 4401 00ef 2B 0A                   		ble	.L294
3532:../src/wolfcrypt/src/ecc.c ****       err = ECC_OUT_OF_RANGE_E;
 4402                             		.loc 2 3532 11
 4403 00f1 F9 AA 01 27 FF          		mov.L	#-217, 4[r10]
3533:../src/wolfcrypt/src/ecc.c ****       goto exit;
 4404                             		.loc 2 3533 7
 4405 00f6 38 26 01                		bra	.L289
 4406                             	.L294:
3534:../src/wolfcrypt/src/ecc.c ****    }
3535:../src/wolfcrypt/src/ecc.c **** 
3536:../src/wolfcrypt/src/ecc.c **** 
3537:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
3538:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_init(&t)) != MP_OKAY)
 4407                             		.loc 2 3538 15
 4408 00f9 71 A5 20                		add	#32, r10, r5
 4409 00fc EF 51                   		mov.L	r5, r1
 4410 00fe 05 00 00 00             		bsr	_sp_init
 4411 0102 E7 A1 01                		mov.L	r1, 4[r10]
 4412                             		.loc 2 3538 7
 4413 0105 ED A5 01                		mov.L	4[r10], r5
 4414 0108 61 05                   		cmp	#0, r5
 4415 010a 3B 0E 01                		bne	.L308
3539:../src/wolfcrypt/src/ecc.c ****       goto exit;
3540:../src/wolfcrypt/src/ecc.c **** 
3541:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 4416                             		.loc 2 3541 7
 4417 010d ED A5 01                		mov.L	4[r10], r5
 4418 0110 61 05                   		cmp	#0, r5
 4419 0112 21 29                   		bne	.L296
3542:../src/wolfcrypt/src/ecc.c ****       err = ecc_mulmod(k, tG, R, M, a, modulus, mp, rng);
 4420                             		.loc 2 3542 13
 4421 0114 ED A2 03                		mov.L	12[r10], r2
 4422 0117 ED A4 07                		mov.L	28[r10], r4
 4423 011a 71 A5 10                		add	#16, r10, r5
 4424 011d A8 E3                   		mov.L	8[r6], r3
 4425 011f A0 8B                   		mov.L	r3, 12[r0]
 4426 0121 A0 84                   		mov.L	r4, 8[r0]
 4427 0123 EC 64                   		mov.L	[r6], r4
 4428 0125 A0 0C                   		mov.L	r4, 4[r0]
 4429 0127 ED A4 CF                		mov.L	828[r10], r4
 4430 012a E3 04                   		mov.L	r4, [r0]
 4431 012c EF 54                   		mov.L	r5, r4
 4432 012e ED A3 CE                		mov.L	824[r10], r3
 4433 0131 ED A1 CC                		mov.L	816[r10], r1
 4434 0134 05 00 00 00             		bsr	_ecc_mulmod
 4435 0138 E7 A1 01                		mov.L	r1, 4[r10]
 4436                             	.L296:
3543:../src/wolfcrypt/src/ecc.c **** 
3544:../src/wolfcrypt/src/ecc.c ****     /* Check for k == order - 1. Result will be 0 point which is not correct
3545:../src/wolfcrypt/src/ecc.c ****      * Calculates order / 2 and adds order / 2 + 1 and gets infinity.
3546:../src/wolfcrypt/src/ecc.c ****      * (with constant time implementation)
3547:../src/wolfcrypt/src/ecc.c ****      */
3548:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 4437                             		.loc 2 3548 7
 4438 013b ED A5 01                		mov.L	4[r10], r5
 4439 013e 61 05                   		cmp	#0, r5
 4440 0140 21 12                   		bne	.L297
3549:../src/wolfcrypt/src/ecc.c ****       err = mp_sub_d(order, 1, &t);
 4441                             		.loc 2 3549 13
 4442 0142 71 A5 20                		add	#32, r10, r5
 4443 0145 EF 53                   		mov.L	r5, r3
 4444 0147 66 12                   		mov.L	#1, r2
 4445 0149 A8 69                   		mov.L	4[r6], r1
 4446 014b 05 00 00 00             		bsr	_sp_sub_d
 4447 014f E7 A1 01                		mov.L	r1, 4[r10]
 4448                             	.L297:
3550:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 4449                             		.loc 2 3550 7
 4450 0152 ED A5 01                		mov.L	4[r10], r5
 4451 0155 61 05                   		cmp	#0, r5
 4452 0157 3B 8F 00                		bne	.L298
 4453                             	.LBB26:
3551:../src/wolfcrypt/src/ecc.c ****       int kIsMinusOne = (mp_cmp((mp_int*)k, &t) == MP_EQ);
 4454                             		.loc 2 3551 26
 4455 015a 71 A5 20                		add	#32, r10, r5
 4456 015d EF 52                   		mov.L	r5, r2
 4457 015f ED A1 CC                		mov.L	816[r10], r1
 4458 0162 05 00 00 00             		bsr	_sp_cmp
 4459 0166 EF 15                   		mov.L	r1, r5
 4460                             		.loc 2 3551 49
 4461 0168 61 05                   		cmp	#0, r5
 4462 016a FC DB 50                		sceq.L	r5
 4463                             		.loc 2 3551 11
 4464 016d 5B 55                   		movu.B	r5, r5
 4465 016f E7 A5 02                		mov.L	r5, 8[r10]
3552:../src/wolfcrypt/src/ecc.c ****       err = mp_cond_copy(tG->x, kIsMinusOne, R->x);
 4466                             		.loc 2 3552 28
 4467 0172 ED A5 03                		mov.L	12[r10], r5
 4468                             		.loc 2 3552 47
 4469 0175 ED A4 CE                		mov.L	824[r10], r4
 4470                             		.loc 2 3552 13
 4471 0178 EF 43                   		mov.L	r4, r3
 4472 017a ED A2 02                		mov.L	8[r10], r2
 4473 017d EF 51                   		mov.L	r5, r1
 4474 017f 05 00 00 00             		bsr	_mp_cond_copy
 4475 0183 E7 A1 01                		mov.L	r1, 4[r10]
3553:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
 4476                             		.loc 2 3553 10
 4477 0186 ED A5 01                		mov.L	4[r10], r5
 4478 0189 61 05                   		cmp	#0, r5
 4479 018b 21 19                   		bne	.L299
3554:../src/wolfcrypt/src/ecc.c ****           err = mp_sub(modulus, tG->y, &t);
 4480                             		.loc 2 3554 35
 4481 018d ED A5 03                		mov.L	12[r10], r5
 4482 0190 72 55 10 03             		add	#0x310, r5
 4483                             		.loc 2 3554 17
 4484 0194 71 A4 20                		add	#32, r10, r4
 4485 0197 EF 43                   		mov.L	r4, r3
 4486 0199 EF 52                   		mov.L	r5, r2
 4487 019b EC 61                   		mov.L	[r6], r1
 4488 019d 05 00 00 00             		bsr	_sp_sub
 4489 01a1 E7 A1 01                		mov.L	r1, 4[r10]
 4490                             	.L299:
3555:../src/wolfcrypt/src/ecc.c ****       }
3556:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
 4491                             		.loc 2 3556 10
 4492 01a4 ED A5 01                		mov.L	4[r10], r5
 4493 01a7 61 05                   		cmp	#0, r5
 4494 01a9 21 1A                   		bne	.L300
3557:../src/wolfcrypt/src/ecc.c ****           err = mp_cond_copy(&t, kIsMinusOne, R->y);
 4495                             		.loc 2 3557 48
 4496 01ab ED A5 CE                		mov.L	824[r10], r5
 4497 01ae 72 54 10 03             		add	#0x310, r5, r4
 4498                             		.loc 2 3557 17
 4499 01b2 71 A5 20                		add	#32, r10, r5
 4500 01b5 EF 43                   		mov.L	r4, r3
 4501 01b7 ED A2 02                		mov.L	8[r10], r2
 4502 01ba EF 51                   		mov.L	r5, r1
 4503 01bc 05 00 00 00             		bsr	_mp_cond_copy
 4504 01c0 E7 A1 01                		mov.L	r1, 4[r10]
 4505                             	.L300:
3558:../src/wolfcrypt/src/ecc.c ****       }
3559:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
 4506                             		.loc 2 3559 10
 4507 01c3 ED A5 01                		mov.L	4[r10], r5
 4508 01c6 61 05                   		cmp	#0, r5
 4509 01c8 21 1E                   		bne	.L298
3560:../src/wolfcrypt/src/ecc.c ****           err = mp_cond_copy(tG->z, kIsMinusOne, R->z);
 4510                             		.loc 2 3560 32
 4511 01ca ED A5 03                		mov.L	12[r10], r5
 4512 01cd 72 54 20 06             		add	#0x620, r5, r4
 4513                             		.loc 2 3560 51
 4514 01d1 ED A5 CE                		mov.L	824[r10], r5
 4515 01d4 72 55 20 06             		add	#0x620, r5
 4516                             		.loc 2 3560 17
 4517 01d8 EF 53                   		mov.L	r5, r3
 4518 01da ED A2 02                		mov.L	8[r10], r2
 4519 01dd EF 41                   		mov.L	r4, r1
 4520 01df 05 00 00 00             		bsr	_mp_cond_copy
 4521 01e3 E7 A1 01                		mov.L	r1, 4[r10]
 4522                             	.L298:
 4523                             	.LBE26:
3561:../src/wolfcrypt/src/ecc.c ****       }
3562:../src/wolfcrypt/src/ecc.c ****    }
3563:../src/wolfcrypt/src/ecc.c **** 
3564:../src/wolfcrypt/src/ecc.c ****    mp_free(&t);
 4524                             		.loc 2 3564 4
 4525 01e6 71 A5 20                		add	#32, r10, r5
 4526 01e9 EF 51                   		mov.L	r5, r1
 4527 01eb 05 00 00 00             		bsr	_sp_free
3565:../src/wolfcrypt/src/ecc.c **** #else
3566:../src/wolfcrypt/src/ecc.c ****    err = ecc_mulmod(k, tG, R, M, a, modulus, mp, rng);
3567:../src/wolfcrypt/src/ecc.c **** 
3568:../src/wolfcrypt/src/ecc.c ****    (void)order;
3569:../src/wolfcrypt/src/ecc.c **** #endif
3570:../src/wolfcrypt/src/ecc.c ****    /* map R back from projective space */
3571:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY && map)
 4528                             		.loc 2 3571 7
 4529 01ef ED A5 01                		mov.L	4[r10], r5
 4530 01f2 61 05                   		cmp	#0, r5
 4531 01f4 21 27                   		bne	.L309
 4532                             		.loc 2 3571 23 discriminator 1
 4533 01f6 A8 ED                   		mov.L	12[r6], r5
 4534 01f8 61 05                   		cmp	#0, r5
 4535 01fa 20 21                   		beq	.L309
3572:../src/wolfcrypt/src/ecc.c ****       err = ecc_map(R, modulus, mp);
 4536                             		.loc 2 3572 13
 4537 01fc ED A5 07                		mov.L	28[r10], r5
 4538 01ff EF 53                   		mov.L	r5, r3
 4539 0201 EC 62                   		mov.L	[r6], r2
 4540 0203 ED A1 CE                		mov.L	824[r10], r1
 4541 0206 05 00 00 00             		bsr	_ecc_map
 4542 020a E7 A1 01                		mov.L	r1, 4[r10]
 4543 020d 2E 0F                   		bra	.L289
 4544                             	.L304:
3506:../src/wolfcrypt/src/ecc.c ****       }
 4545                             		.loc 2 3506 10
 4546 020f 03                      		nop
 4547 0210 2E 0C                   		bra	.L289
 4548                             	.L305:
3519:../src/wolfcrypt/src/ecc.c ****    }
 4549                             		.loc 2 3519 8
 4550 0212 03                      		nop
 4551 0213 09                      		bra	.L289
 4552                             	.L306:
3522:../src/wolfcrypt/src/ecc.c ****    }
 4553                             		.loc 2 3522 8
 4554 0214 03                      		nop
 4555 0215 0F                      		bra	.L289
 4556                             	.L307:
3527:../src/wolfcrypt/src/ecc.c ****    }
 4557                             		.loc 2 3527 7
 4558 0216 03                      		nop
 4559 0217 0D                      		bra	.L289
 4560                             	.L308:
3539:../src/wolfcrypt/src/ecc.c **** 
 4561                             		.loc 2 3539 7
 4562 0218 03                      		nop
 4563 0219 2E 03                   		bra	.L289
 4564                             	.L309:
3573:../src/wolfcrypt/src/ecc.c **** 
3574:../src/wolfcrypt/src/ecc.c **** exit:
 4565                             		.loc 2 3574 1
 4566 021b 03                      		nop
 4567                             		.balign 8,3,1
 4568                             	.L289:
3575:../src/wolfcrypt/src/ecc.c **** 
3576:../src/wolfcrypt/src/ecc.c ****    /* done */
3577:../src/wolfcrypt/src/ecc.c ****    wc_ecc_del_point_ex(tG, heap);
 4569                             		.loc 2 3577 4
 4570 021c ED A5 03                		mov.L	12[r10], r5
 4571 021f A9 62                   		mov.L	16[r6], r2
 4572 0221 EF 51                   		mov.L	r5, r1
 4573 0223 05 00 00 00             		bsr	_wc_ecc_del_point_ex
3578:../src/wolfcrypt/src/ecc.c ****    for (i = 0; i < M_POINTS; i++) {
 4574                             		.loc 2 3578 11
 4575 0227 F8 A6 00                		mov.L	#0, [r10]
 4576                             		.loc 2 3578 4
 4577 022a 2E 18                   		bra	.L301
 4578                             	.L302:
3579:../src/wolfcrypt/src/ecc.c ****       wc_ecc_del_point_ex(M[i], heap);
 4579                             		.loc 2 3579 7 discriminator 3
 4580 022c EC A5                   		mov.L	[r10], r5
 4581 022e 6C 25                   		shll	#2, r5
 4582 0230 4B A5                   		add	r10, r5
 4583 0232 A9 55                   		mov.L	16[r5], r5
 4584 0234 A9 62                   		mov.L	16[r6], r2
 4585 0236 EF 51                   		mov.L	r5, r1
 4586 0238 05 00 00 00             		bsr	_wc_ecc_del_point_ex
3578:../src/wolfcrypt/src/ecc.c ****    for (i = 0; i < M_POINTS; i++) {
 4587                             		.loc 2 3578 31 discriminator 3
 4588 023c EC A5                   		mov.L	[r10], r5
 4589 023e 62 15                   		add	#1, r5
 4590 0240 E3 A5                   		mov.L	r5, [r10]
 4591                             	.L301:
3578:../src/wolfcrypt/src/ecc.c ****    for (i = 0; i < M_POINTS; i++) {
 4592                             		.loc 2 3578 4 discriminator 1
 4593 0242 EC A5                   		mov.L	[r10], r5
 4594 0244 61 25                   		cmp	#2, r5
 4595 0246 2B E6                   		ble	.L302
3580:../src/wolfcrypt/src/ecc.c ****    }
3581:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
3582:../src/wolfcrypt/src/ecc.c ****    R->key = NULL;
3583:../src/wolfcrypt/src/ecc.c ****    ecc_key_tmp_final(&key, heap);
3584:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK_CACHE */
3585:../src/wolfcrypt/src/ecc.c **** 
3586:../src/wolfcrypt/src/ecc.c ****    return err;
 4596                             		.loc 2 3586 11
 4597 0248 ED A5 01                		mov.L	4[r10], r5
 4598                             	.L303:
3587:../src/wolfcrypt/src/ecc.c **** }
 4599                             		.loc 2 3587 1 discriminator 1
 4600 024b EF 51                   		mov.L	r5, r1
 4601 024d 3F 6B DF                		rtsd	#892, r6-r11
 4602                             	.LFE60:
 4604                             		.section	.text.wc_ecc_mulmod,"ax",@progbits
 4605                             		.global	_wc_ecc_mulmod
 4607                             	_wc_ecc_mulmod:
 4608                             	.LFB61:
3588:../src/wolfcrypt/src/ecc.c **** #else
3589:../src/wolfcrypt/src/ecc.c **** {
3590:../src/wolfcrypt/src/ecc.c ****    if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
3591:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
3592:../src/wolfcrypt/src/ecc.c ****    }
3593:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(G->x) > mp_count_bits(modulus) ||
3594:../src/wolfcrypt/src/ecc.c ****        mp_count_bits(G->y) > mp_count_bits(modulus) ||
3595:../src/wolfcrypt/src/ecc.c ****        mp_count_bits(G->z) > mp_count_bits(modulus)) {
3596:../src/wolfcrypt/src/ecc.c ****        return IS_POINT_E;
3597:../src/wolfcrypt/src/ecc.c ****    }
3598:../src/wolfcrypt/src/ecc.c **** 
3599:../src/wolfcrypt/src/ecc.c ****    (void)a;
3600:../src/wolfcrypt/src/ecc.c ****    (void)order;
3601:../src/wolfcrypt/src/ecc.c ****    (void)rng;
3602:../src/wolfcrypt/src/ecc.c **** 
3603:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
3604:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
3605:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(modulus) == 256) {
3606:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_mulmod_256(k, G, R, map, heap);
3607:../src/wolfcrypt/src/ecc.c ****    }
3608:../src/wolfcrypt/src/ecc.c **** #endif
3609:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
3610:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(modulus) == 384) {
3611:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_mulmod_384(k, G, R, map, heap);
3612:../src/wolfcrypt/src/ecc.c ****    }
3613:../src/wolfcrypt/src/ecc.c **** #endif
3614:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
3615:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(modulus) == 521) {
3616:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_mulmod_521(k, G, R, map, heap);
3617:../src/wolfcrypt/src/ecc.c ****    }
3618:../src/wolfcrypt/src/ecc.c **** #endif
3619:../src/wolfcrypt/src/ecc.c **** #else
3620:../src/wolfcrypt/src/ecc.c ****    (void)map;
3621:../src/wolfcrypt/src/ecc.c ****    (void)heap;
3622:../src/wolfcrypt/src/ecc.c **** #endif
3623:../src/wolfcrypt/src/ecc.c ****    return ECC_BAD_ARG_E;
3624:../src/wolfcrypt/src/ecc.c **** }
3625:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH */
3626:../src/wolfcrypt/src/ecc.c **** #endif /* !FP_ECC */
3627:../src/wolfcrypt/src/ecc.c **** 
3628:../src/wolfcrypt/src/ecc.c **** #endif /* !FREESCALE_LTC_ECC && !WOLFSSL_STM32_PKA */
3629:../src/wolfcrypt/src/ecc.c **** 
3630:../src/wolfcrypt/src/ecc.c **** /** ECC Fixed Point mulmod global
3631:../src/wolfcrypt/src/ecc.c ****     k        The multiplicand
3632:../src/wolfcrypt/src/ecc.c ****     G        Base point to multiply
3633:../src/wolfcrypt/src/ecc.c ****     R        [out] Destination of product
3634:../src/wolfcrypt/src/ecc.c ****     a        ECC curve parameter a
3635:../src/wolfcrypt/src/ecc.c ****     modulus  The modulus for the curve
3636:../src/wolfcrypt/src/ecc.c ****     map      [boolean] If non-zero maps the point back to affine coordinates,
3637:../src/wolfcrypt/src/ecc.c ****              otherwise it's left in jacobian-montgomery form
3638:../src/wolfcrypt/src/ecc.c ****     return MP_OKAY if successful
3639:../src/wolfcrypt/src/ecc.c **** */
3640:../src/wolfcrypt/src/ecc.c **** int wc_ecc_mulmod(const mp_int* k, ecc_point *G, ecc_point *R, mp_int* a,
3641:../src/wolfcrypt/src/ecc.c ****                   mp_int* modulus, int map)
3642:../src/wolfcrypt/src/ecc.c **** {
 4609                             		.loc 2 3642 1
 4610 0000 7E AA                   		push.l	r10
 4611                             	.LCFI52:
 4612 0002 71 0A E8                		add	#-24, r0, r10
 4613                             	.LCFI53:
 4614 0005 71 A0 F4                		add	#-12, r10, r0
 4615                             	.LCFI54:
 4616 0008 75 45 20                		mov.L	#32, r5
 4617 000b 4B A5                   		add	r10, r5
 4618 000d E3 A1                   		mov.L	r1, [r10]
 4619 000f E7 A2 01                		mov.L	r2, 4[r10]
 4620 0012 E7 A3 02                		mov.L	r3, 8[r10]
 4621 0015 E7 A4 03                		mov.L	r4, 12[r10]
3643:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_mulmod_ex(k, G, R, a, modulus, map, NULL);
 4622                             		.loc 2 3643 12
 4623 0018 3E 02 00                		mov.L	#0, 8[r0]
 4624 001b A8 5C                   		mov.L	4[r5], r4
 4625 001d A0 0C                   		mov.L	r4, 4[r0]
 4626 001f EC 55                   		mov.L	[r5], r5
 4627 0021 E3 05                   		mov.L	r5, [r0]
 4628 0023 ED A4 03                		mov.L	12[r10], r4
 4629 0026 ED A3 02                		mov.L	8[r10], r3
 4630 0029 ED A2 01                		mov.L	4[r10], r2
 4631 002c EC A1                   		mov.L	[r10], r1
 4632 002e 05 00 00 00             		bsr	_wc_ecc_mulmod_ex
 4633 0032 EF 15                   		mov.L	r1, r5
3644:../src/wolfcrypt/src/ecc.c **** }
 4634                             		.loc 2 3644 1
 4635 0034 EF 51                   		mov.L	r5, r1
 4636 0036 3F AA 0A                		rtsd	#40, r10-r10
 4637                             	.LFE61:
 4639                             		.section	.text.wc_ecc_new_point_ex,"ax",@progbits
 4641                             	_wc_ecc_new_point_ex:
 4642                             	.LFB62:
3645:../src/wolfcrypt/src/ecc.c **** 
3646:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_ATECC508A */
3647:../src/wolfcrypt/src/ecc.c **** 
3648:../src/wolfcrypt/src/ecc.c **** /**
3649:../src/wolfcrypt/src/ecc.c ****  * Allocate a new ECC point (if one not provided)
3650:../src/wolfcrypt/src/ecc.c ****  * use a heap hint when creating new ecc_point
3651:../src/wolfcrypt/src/ecc.c ****  * return an allocated point on success or NULL on failure
3652:../src/wolfcrypt/src/ecc.c **** */
3653:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_new_point_ex(ecc_point** point, void* heap)
3654:../src/wolfcrypt/src/ecc.c **** {
 4643                             		.loc 2 3654 1
 4644 0000 7E AA                   		push.l	r10
 4645                             	.LCFI55:
 4646 0002 71 0A EC                		add	#-20, r0, r10
 4647                             	.LCFI56:
 4648 0005 71 A0 F8                		add	#-8, r10, r0
 4649                             	.LCFI57:
 4650 0008 E7 A1 03                		mov.L	r1, 12[r10]
 4651 000b E7 A2 04                		mov.L	r2, 16[r10]
3655:../src/wolfcrypt/src/ecc.c ****    int err = MP_OKAY;
 4652                             		.loc 2 3655 8
 4653 000e F9 A6 01 00             		mov.L	#0, 4[r10]
3656:../src/wolfcrypt/src/ecc.c ****    ecc_point* p;
3657:../src/wolfcrypt/src/ecc.c **** 
3658:../src/wolfcrypt/src/ecc.c ****    if (point == NULL) {
 4654                             		.loc 2 3658 7
 4655 0012 ED A5 03                		mov.L	12[r10], r5
 4656 0015 61 05                   		cmp	#0, r5
 4657 0017 1F                      		bne	.L313
3659:../src/wolfcrypt/src/ecc.c ****        return BAD_FUNC_ARG;
 4658                             		.loc 2 3659 15
 4659 0018 FB 5A 53 FF             		mov.L	#-173, r5
 4660 001c 2E 76                   		bra	.L314
 4661                             	.L313:
3660:../src/wolfcrypt/src/ecc.c ****    }
3661:../src/wolfcrypt/src/ecc.c **** 
3662:../src/wolfcrypt/src/ecc.c ****    p = *point;
 4662                             		.loc 2 3662 6
 4663 001e ED A5 03                		mov.L	12[r10], r5
 4664 0021 EC 55                   		mov.L	[r5], r5
 4665 0023 E3 A5                   		mov.L	r5, [r10]
3663:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_NO_MALLOC
3664:../src/wolfcrypt/src/ecc.c ****    if (p == NULL) {
 4666                             		.loc 2 3664 7
 4667 0025 EC A5                   		mov.L	[r10], r5
 4668 0027 61 05                   		cmp	#0, r5
 4669 0029 21 0C                   		bne	.L315
3665:../src/wolfcrypt/src/ecc.c ****       p = (ecc_point*)XMALLOC(sizeof(ecc_point), heap, DYNAMIC_TYPE_ECC);
 4670                             		.loc 2 3665 23
 4671 002b FB 1A 30 09             		mov.L	#0x930, r1
 4672 002f 05 00 00 00             		bsr	_wolfSSL_Malloc
 4673 0033 E3 A1                   		mov.L	r1, [r10]
 4674                             	.L315:
3666:../src/wolfcrypt/src/ecc.c ****    }
3667:../src/wolfcrypt/src/ecc.c **** #endif
3668:../src/wolfcrypt/src/ecc.c ****    if (p == NULL) {
 4675                             		.loc 2 3668 7
 4676 0035 EC A5                   		mov.L	[r10], r5
 4677 0037 61 05                   		cmp	#0, r5
 4678 0039 1E                      		bne	.L316
3669:../src/wolfcrypt/src/ecc.c ****       return MEMORY_E;
 4679                             		.loc 2 3669 14
 4680 003a FB 56 83                		mov.L	#-125, r5
 4681 003d 2E 55                   		bra	.L314
 4682                             	.L316:
3670:../src/wolfcrypt/src/ecc.c ****    }
3671:../src/wolfcrypt/src/ecc.c ****    XMEMSET(p, 0, sizeof(ecc_point));
 4683                             		.loc 2 3671 4
 4684 003f FB 3A 30 09             		mov.L	#0x930, r3
 4685 0043 66 02                   		mov.L	#0, r2
 4686 0045 EC A1                   		mov.L	[r10], r1
 4687 0047 05 00 00 00             		bsr	_memset
3672:../src/wolfcrypt/src/ecc.c **** 
3673:../src/wolfcrypt/src/ecc.c **** #ifndef ALT_ECC_SIZE
3674:../src/wolfcrypt/src/ecc.c ****    err = mp_init_multi(p->x, p->y, p->z, NULL, NULL, NULL);
 4688                             		.loc 2 3674 25
 4689 004b EC A1                   		mov.L	[r10], r1
 4690                             		.loc 2 3674 31
 4691 004d EC A5                   		mov.L	[r10], r5
 4692 004f 72 52 10 03             		add	#0x310, r5, r2
 4693                             		.loc 2 3674 37
 4694 0053 EC A5                   		mov.L	[r10], r5
 4695 0055 72 55 20 06             		add	#0x620, r5
 4696                             		.loc 2 3674 10
 4697 0059 3E 01 00                		mov.L	#0, 4[r0]
 4698 005c F8 06 00                		mov.L	#0, [r0]
 4699 005f 66 04                   		mov.L	#0, r4
 4700 0061 EF 53                   		mov.L	r5, r3
 4701 0063 05 00 00 00             		bsr	_sp_init_multi
 4702 0067 E7 A1 01                		mov.L	r1, 4[r10]
3675:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY) {
 4703                             		.loc 2 3675 7
 4704 006a ED A5 01                		mov.L	4[r10], r5
 4705 006d 61 05                   		cmp	#0, r5
 4706 006f 20 19                   		beq	.L317
 4707                             	.LBB27:
3676:../src/wolfcrypt/src/ecc.c ****    #ifndef WOLFSSL_NO_MALLOC
3677:../src/wolfcrypt/src/ecc.c ****       XFREE(p, heap, DYNAMIC_TYPE_ECC);
 4708                             		.loc 2 3677 7
 4709 0071 EC A5                   		mov.L	[r10], r5
 4710 0073 E7 A5 02                		mov.L	r5, 8[r10]
 4711 0076 ED A5 02                		mov.L	8[r10], r5
 4712 0079 61 05                   		cmp	#0, r5
 4713 007b 10                      		beq	.L318
 4714                             		.loc 2 3677 7 is_stmt 0 discriminator 1
 4715 007c ED A1 02                		mov.L	8[r10], r1
 4716 007f 05 00 00 00             		bsr	_wolfSSL_Free
 4717                             	.L318:
 4718                             	.LBE27:
3678:../src/wolfcrypt/src/ecc.c ****    #endif
3679:../src/wolfcrypt/src/ecc.c ****       return err;
 4719                             		.loc 2 3679 14 is_stmt 1
 4720 0083 ED A5 01                		mov.L	4[r10], r5
 4721 0086 2E 0C                   		bra	.L314
 4722                             	.L317:
3680:../src/wolfcrypt/src/ecc.c ****    }
3681:../src/wolfcrypt/src/ecc.c **** #else
3682:../src/wolfcrypt/src/ecc.c ****    p->x = (mp_int*)&p->xyz[0];
3683:../src/wolfcrypt/src/ecc.c ****    p->y = (mp_int*)&p->xyz[1];
3684:../src/wolfcrypt/src/ecc.c ****    p->z = (mp_int*)&p->xyz[2];
3685:../src/wolfcrypt/src/ecc.c ****    alt_fp_init(p->x);
3686:../src/wolfcrypt/src/ecc.c ****    alt_fp_init(p->y);
3687:../src/wolfcrypt/src/ecc.c ****    alt_fp_init(p->z);
3688:../src/wolfcrypt/src/ecc.c **** #endif
3689:../src/wolfcrypt/src/ecc.c **** 
3690:../src/wolfcrypt/src/ecc.c ****    *point = p;
 4723                             		.loc 2 3690 11
 4724 0088 ED A5 03                		mov.L	12[r10], r5
 4725 008b EC A4                   		mov.L	[r10], r4
 4726 008d E3 54                   		mov.L	r4, [r5]
3691:../src/wolfcrypt/src/ecc.c ****    (void)heap;
3692:../src/wolfcrypt/src/ecc.c ****    return err;
 4727                             		.loc 2 3692 11
 4728 008f ED A5 01                		mov.L	4[r10], r5
 4729                             		.balign 8,3,1
 4730                             	.L314:
3693:../src/wolfcrypt/src/ecc.c **** }
 4731                             		.loc 2 3693 1
 4732 0092 EF 51                   		mov.L	r5, r1
 4733 0094 3F AA 08                		rtsd	#32, r10-r10
 4734                             	.LFE62:
 4736 0097 03                      		.section	.text.wc_ecc_new_point_h,"ax",@progbits
 4737                             		.global	_wc_ecc_new_point_h
 4739                             	_wc_ecc_new_point_h:
 4740                             	.LFB63:
3694:../src/wolfcrypt/src/ecc.c **** ecc_point* wc_ecc_new_point_h(void* heap)
3695:../src/wolfcrypt/src/ecc.c **** {
 4741                             		.loc 2 3695 1
 4742 0000 7E AA                   		push.l	r10
 4743                             	.LCFI58:
 4744 0002 71 0A F8                		add	#-8, r0, r10
 4745                             	.LCFI59:
 4746 0005 EF A0                   		mov.L	r10, r0
 4747 0007 E7 A1 01                		mov.L	r1, 4[r10]
3696:../src/wolfcrypt/src/ecc.c ****     ecc_point* p = NULL;
 4748                             		.loc 2 3696 16
 4749 000a F8 A6 00                		mov.L	#0, [r10]
3697:../src/wolfcrypt/src/ecc.c ****     (void)wc_ecc_new_point_ex(&p, heap);
 4750                             		.loc 2 3697 11
 4751 000d ED A2 01                		mov.L	4[r10], r2
 4752 0010 EF A1                   		mov.L	r10, r1
 4753 0012 05 00 00 00             		bsr	_wc_ecc_new_point_ex
3698:../src/wolfcrypt/src/ecc.c ****     return p;
 4754                             		.loc 2 3698 12
 4755 0016 EC A5                   		mov.L	[r10], r5
3699:../src/wolfcrypt/src/ecc.c **** }
 4756                             		.loc 2 3699 1
 4757 0018 EF 51                   		mov.L	r5, r1
 4758 001a 3F AA 03                		rtsd	#12, r10-r10
 4759                             	.LFE63:
 4761                             		.section	.text.wc_ecc_new_point,"ax",@progbits
 4762                             		.global	_wc_ecc_new_point
 4764                             	_wc_ecc_new_point:
 4765                             	.LFB64:
3700:../src/wolfcrypt/src/ecc.c **** ecc_point* wc_ecc_new_point(void)
3701:../src/wolfcrypt/src/ecc.c **** {
 4766                             		.loc 2 3701 1
 4767 0000 7E AA                   		push.l	r10
 4768                             	.LCFI60:
 4769 0002 71 0A FC                		add	#-4, r0, r10
 4770                             	.LCFI61:
 4771 0005 EF A0                   		mov.L	r10, r0
3702:../src/wolfcrypt/src/ecc.c ****    ecc_point* p = NULL;
 4772                             		.loc 2 3702 15
 4773 0007 F8 A6 00                		mov.L	#0, [r10]
3703:../src/wolfcrypt/src/ecc.c ****    (void)wc_ecc_new_point_ex(&p, NULL);
 4774                             		.loc 2 3703 10
 4775 000a 66 02                   		mov.L	#0, r2
 4776 000c EF A1                   		mov.L	r10, r1
 4777 000e 05 00 00 00             		bsr	_wc_ecc_new_point_ex
3704:../src/wolfcrypt/src/ecc.c ****    return p;
 4778                             		.loc 2 3704 11
 4779 0012 EC A5                   		mov.L	[r10], r5
3705:../src/wolfcrypt/src/ecc.c **** }
 4780                             		.loc 2 3705 1
 4781 0014 EF 51                   		mov.L	r5, r1
 4782 0016 3F AA 02                		rtsd	#8, r10-r10
 4783                             	.LFE64:
 4785                             		.section	.text.wc_ecc_del_point_ex,"ax",@progbits
 4787                             	_wc_ecc_del_point_ex:
 4788                             	.LFB65:
3706:../src/wolfcrypt/src/ecc.c **** 
3707:../src/wolfcrypt/src/ecc.c **** /** Free an ECC point from memory
3708:../src/wolfcrypt/src/ecc.c ****   p   The point to free
3709:../src/wolfcrypt/src/ecc.c **** */
3710:../src/wolfcrypt/src/ecc.c **** static void wc_ecc_del_point_ex(ecc_point* p, void* heap)
3711:../src/wolfcrypt/src/ecc.c **** {
 4789                             		.loc 2 3711 1
 4790 0000 7E AA                   		push.l	r10
 4791                             	.LCFI62:
 4792 0002 71 0A F4                		add	#-12, r0, r10
 4793                             	.LCFI63:
 4794 0005 EF A0                   		mov.L	r10, r0
 4795 0007 E7 A1 01                		mov.L	r1, 4[r10]
 4796 000a E7 A2 02                		mov.L	r2, 8[r10]
3712:../src/wolfcrypt/src/ecc.c ****    if (p != NULL) {
 4797                             		.loc 2 3712 7
 4798 000d ED A5 01                		mov.L	4[r10], r5
 4799 0010 61 05                   		cmp	#0, r5
 4800 0012 20 35                   		beq	.L325
3713:../src/wolfcrypt/src/ecc.c ****       mp_clear(p->x);
 4801                             		.loc 2 3713 17
 4802 0014 ED A5 01                		mov.L	4[r10], r5
 4803                             		.loc 2 3713 7
 4804 0017 EF 51                   		mov.L	r5, r1
 4805 0019 05 00 00 00             		bsr	_sp_clear
3714:../src/wolfcrypt/src/ecc.c ****       mp_clear(p->y);
 4806                             		.loc 2 3714 17
 4807 001d ED A5 01                		mov.L	4[r10], r5
 4808 0020 72 55 10 03             		add	#0x310, r5
 4809                             		.loc 2 3714 7
 4810 0024 EF 51                   		mov.L	r5, r1
 4811 0026 05 00 00 00             		bsr	_sp_clear
3715:../src/wolfcrypt/src/ecc.c ****       mp_clear(p->z);
 4812                             		.loc 2 3715 17
 4813 002a ED A5 01                		mov.L	4[r10], r5
 4814 002d 72 55 20 06             		add	#0x620, r5
 4815                             		.loc 2 3715 7
 4816 0031 EF 51                   		mov.L	r5, r1
 4817 0033 05 00 00 00             		bsr	_sp_clear
 4818                             	.LBB28:
3716:../src/wolfcrypt/src/ecc.c ****    #ifndef WOLFSSL_NO_MALLOC
3717:../src/wolfcrypt/src/ecc.c ****       XFREE(p, heap, DYNAMIC_TYPE_ECC);
 4819                             		.loc 2 3717 7
 4820 0037 ED A5 01                		mov.L	4[r10], r5
 4821 003a E3 A5                   		mov.L	r5, [r10]
 4822 003c EC A5                   		mov.L	[r10], r5
 4823 003e 61 05                   		cmp	#0, r5
 4824 0040 17                      		beq	.L325
 4825                             		.loc 2 3717 7 is_stmt 0 discriminator 1
 4826 0041 EC A1                   		mov.L	[r10], r1
 4827 0043 05 00 00 00             		bsr	_wolfSSL_Free
 4828                             	.L325:
 4829                             	.LBE28:
3718:../src/wolfcrypt/src/ecc.c ****    #endif
3719:../src/wolfcrypt/src/ecc.c ****    }
3720:../src/wolfcrypt/src/ecc.c ****    (void)heap;
3721:../src/wolfcrypt/src/ecc.c **** }
 4830                             		.loc 2 3721 1 is_stmt 1
 4831 0047 03                      		nop
 4832 0048 3F AA 04                		rtsd	#16, r10-r10
 4833                             	.LFE65:
 4835                             		.section	.text.wc_ecc_del_point_h,"ax",@progbits
 4836                             		.global	_wc_ecc_del_point_h
 4838                             	_wc_ecc_del_point_h:
 4839                             	.LFB66:
3722:../src/wolfcrypt/src/ecc.c **** void wc_ecc_del_point_h(ecc_point* p, void* heap)
3723:../src/wolfcrypt/src/ecc.c **** {
 4840                             		.loc 2 3723 1
 4841 0000 7E AA                   		push.l	r10
 4842                             	.LCFI64:
 4843 0002 71 0A F8                		add	#-8, r0, r10
 4844                             	.LCFI65:
 4845 0005 EF A0                   		mov.L	r10, r0
 4846 0007 E3 A1                   		mov.L	r1, [r10]
 4847 0009 E7 A2 01                		mov.L	r2, 4[r10]
3724:../src/wolfcrypt/src/ecc.c ****    wc_ecc_del_point_ex(p, heap);
 4848                             		.loc 2 3724 4
 4849 000c ED A2 01                		mov.L	4[r10], r2
 4850 000f EC A1                   		mov.L	[r10], r1
 4851 0011 05 00 00 00             		bsr	_wc_ecc_del_point_ex
3725:../src/wolfcrypt/src/ecc.c **** }
 4852                             		.loc 2 3725 1
 4853 0015 03                      		nop
 4854 0016 3F AA 03                		rtsd	#12, r10-r10
 4855                             	.LFE66:
 4857                             		.section	.text.wc_ecc_del_point,"ax",@progbits
 4858                             		.global	_wc_ecc_del_point
 4860                             	_wc_ecc_del_point:
 4861                             	.LFB67:
3726:../src/wolfcrypt/src/ecc.c **** void wc_ecc_del_point(ecc_point* p)
3727:../src/wolfcrypt/src/ecc.c **** {
 4862                             		.loc 2 3727 1
 4863 0000 7E AA                   		push.l	r10
 4864                             	.LCFI66:
 4865 0002 71 0A FC                		add	#-4, r0, r10
 4866                             	.LCFI67:
 4867 0005 EF A0                   		mov.L	r10, r0
 4868 0007 E3 A1                   		mov.L	r1, [r10]
3728:../src/wolfcrypt/src/ecc.c ****     wc_ecc_del_point_ex(p, NULL);
 4869                             		.loc 2 3728 5
 4870 0009 66 02                   		mov.L	#0, r2
 4871 000b EC A1                   		mov.L	[r10], r1
 4872 000d 05 00 00 00             		bsr	_wc_ecc_del_point_ex
3729:../src/wolfcrypt/src/ecc.c **** }
 4873                             		.loc 2 3729 1
 4874 0011 03                      		nop
 4875 0012 3F AA 02                		rtsd	#8, r10-r10
 4876                             	.LFE67:
 4878                             		.section	.text.wc_ecc_forcezero_point,"ax",@progbits
 4879                             		.global	_wc_ecc_forcezero_point
 4881                             	_wc_ecc_forcezero_point:
 4882                             	.LFB68:
3730:../src/wolfcrypt/src/ecc.c **** 
3731:../src/wolfcrypt/src/ecc.c **** void wc_ecc_forcezero_point(ecc_point* p)
3732:../src/wolfcrypt/src/ecc.c **** {
 4883                             		.loc 2 3732 1
 4884 0000 7E AA                   		push.l	r10
 4885                             	.LCFI68:
 4886 0002 71 0A FC                		add	#-4, r0, r10
 4887                             	.LCFI69:
 4888 0005 EF A0                   		mov.L	r10, r0
 4889 0007 E3 A1                   		mov.L	r1, [r10]
3733:../src/wolfcrypt/src/ecc.c ****     if (p != NULL) {
 4890                             		.loc 2 3733 8
 4891 0009 EC A5                   		mov.L	[r10], r5
 4892 000b 61 05                   		cmp	#0, r5
 4893 000d 20 22                   		beq	.L330
3734:../src/wolfcrypt/src/ecc.c ****         mp_forcezero(p->x);
 4894                             		.loc 2 3734 23
 4895 000f EC A5                   		mov.L	[r10], r5
 4896                             		.loc 2 3734 9
 4897 0011 EF 51                   		mov.L	r5, r1
 4898 0013 05 00 00 00             		bsr	_sp_forcezero
3735:../src/wolfcrypt/src/ecc.c ****         mp_forcezero(p->y);
 4899                             		.loc 2 3735 23
 4900 0017 EC A5                   		mov.L	[r10], r5
 4901 0019 72 55 10 03             		add	#0x310, r5
 4902                             		.loc 2 3735 9
 4903 001d EF 51                   		mov.L	r5, r1
 4904 001f 05 00 00 00             		bsr	_sp_forcezero
3736:../src/wolfcrypt/src/ecc.c ****         mp_forcezero(p->z);
 4905                             		.loc 2 3736 23
 4906 0023 EC A5                   		mov.L	[r10], r5
 4907 0025 72 55 20 06             		add	#0x620, r5
 4908                             		.loc 2 3736 9
 4909 0029 EF 51                   		mov.L	r5, r1
 4910 002b 05 00 00 00             		bsr	_sp_forcezero
 4911                             	.L330:
3737:../src/wolfcrypt/src/ecc.c ****     }
3738:../src/wolfcrypt/src/ecc.c **** }
 4912                             		.loc 2 3738 1
 4913 002f 03                      		nop
 4914 0030 3F AA 02                		rtsd	#8, r10-r10
 4915                             	.LFE68:
 4917                             		.section	.text.wc_ecc_copy_point,"ax",@progbits
 4918                             		.global	_wc_ecc_copy_point
 4920                             	_wc_ecc_copy_point:
 4921                             	.LFB69:
3739:../src/wolfcrypt/src/ecc.c **** 
3740:../src/wolfcrypt/src/ecc.c **** 
3741:../src/wolfcrypt/src/ecc.c **** /** Copy the value of a point to an other one
3742:../src/wolfcrypt/src/ecc.c ****   p    The point to copy
3743:../src/wolfcrypt/src/ecc.c ****   r    The created point
3744:../src/wolfcrypt/src/ecc.c **** */
3745:../src/wolfcrypt/src/ecc.c **** int wc_ecc_copy_point(const ecc_point* p, ecc_point *r)
3746:../src/wolfcrypt/src/ecc.c **** {
 4922                             		.loc 2 3746 1
 4923 0000 7E AA                   		push.l	r10
 4924                             	.LCFI70:
 4925 0002 71 0A F4                		add	#-12, r0, r10
 4926                             	.LCFI71:
 4927 0005 EF A0                   		mov.L	r10, r0
 4928 0007 E7 A1 01                		mov.L	r1, 4[r10]
 4929 000a E7 A2 02                		mov.L	r2, 8[r10]
3747:../src/wolfcrypt/src/ecc.c ****     int ret;
3748:../src/wolfcrypt/src/ecc.c **** 
3749:../src/wolfcrypt/src/ecc.c ****     /* prevents null arguments */
3750:../src/wolfcrypt/src/ecc.c ****     if (p == NULL || r == NULL)
 4930                             		.loc 2 3750 8
 4931 000d ED A5 01                		mov.L	4[r10], r5
 4932 0010 61 05                   		cmp	#0, r5
 4933 0012 17                      		beq	.L332
 4934                             		.loc 2 3750 19 discriminator 1
 4935 0013 ED A5 02                		mov.L	8[r10], r5
 4936 0016 61 05                   		cmp	#0, r5
 4937 0018 1F                      		bne	.L333
 4938                             	.L332:
3751:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 4939                             		.loc 2 3751 16
 4940 0019 FB 5A 56 FF             		mov.L	#-170, r5
 4941 001d 2E 5E                   		bra	.L334
 4942                             	.L333:
3752:../src/wolfcrypt/src/ecc.c **** 
3753:../src/wolfcrypt/src/ecc.c ****     ret = mp_copy(p->x, r->x);
 4943                             		.loc 2 3753 20
 4944 001f ED A5 01                		mov.L	4[r10], r5
 4945                             		.loc 2 3753 26
 4946 0022 ED A4 02                		mov.L	8[r10], r4
 4947                             		.loc 2 3753 11
 4948 0025 EF 42                   		mov.L	r4, r2
 4949 0027 EF 51                   		mov.L	r5, r1
 4950 0029 05 00 00 00             		bsr	_sp_copy
 4951 002d E3 A1                   		mov.L	r1, [r10]
3754:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_OKAY)
 4952                             		.loc 2 3754 8
 4953 002f EC A5                   		mov.L	[r10], r5
 4954 0031 61 05                   		cmp	#0, r5
 4955 0033 15                      		beq	.L335
3755:../src/wolfcrypt/src/ecc.c ****         return ret;
 4956                             		.loc 2 3755 16
 4957 0034 EC A5                   		mov.L	[r10], r5
 4958 0036 2E 45                   		bra	.L334
 4959                             	.L335:
3756:../src/wolfcrypt/src/ecc.c ****     ret = mp_copy(p->y, r->y);
 4960                             		.loc 2 3756 20
 4961 0038 ED A5 01                		mov.L	4[r10], r5
 4962 003b 72 54 10 03             		add	#0x310, r5, r4
 4963                             		.loc 2 3756 26
 4964 003f ED A5 02                		mov.L	8[r10], r5
 4965 0042 72 55 10 03             		add	#0x310, r5
 4966                             		.loc 2 3756 11
 4967 0046 EF 52                   		mov.L	r5, r2
 4968 0048 EF 41                   		mov.L	r4, r1
 4969 004a 05 00 00 00             		bsr	_sp_copy
 4970 004e E3 A1                   		mov.L	r1, [r10]
3757:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_OKAY)
 4971                             		.loc 2 3757 8
 4972 0050 EC A5                   		mov.L	[r10], r5
 4973 0052 61 05                   		cmp	#0, r5
 4974 0054 15                      		beq	.L336
3758:../src/wolfcrypt/src/ecc.c ****         return ret;
 4975                             		.loc 2 3758 16
 4976 0055 EC A5                   		mov.L	[r10], r5
 4977 0057 2E 24                   		bra	.L334
 4978                             	.L336:
3759:../src/wolfcrypt/src/ecc.c ****     ret = mp_copy(p->z, r->z);
 4979                             		.loc 2 3759 20
 4980 0059 ED A5 01                		mov.L	4[r10], r5
 4981 005c 72 54 20 06             		add	#0x620, r5, r4
 4982                             		.loc 2 3759 26
 4983 0060 ED A5 02                		mov.L	8[r10], r5
 4984 0063 72 55 20 06             		add	#0x620, r5
 4985                             		.loc 2 3759 11
 4986 0067 EF 52                   		mov.L	r5, r2
 4987 0069 EF 41                   		mov.L	r4, r1
 4988 006b 05 00 00 00             		bsr	_sp_copy
 4989 006f E3 A1                   		mov.L	r1, [r10]
3760:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_OKAY)
 4990                             		.loc 2 3760 8
 4991 0071 EC A5                   		mov.L	[r10], r5
 4992 0073 61 05                   		cmp	#0, r5
 4993 0075 14                      		beq	.L337
3761:../src/wolfcrypt/src/ecc.c ****         return ret;
 4994                             		.loc 2 3761 16
 4995 0076 EC A5                   		mov.L	[r10], r5
 4996 0078 0B                      		bra	.L334
 4997                             	.L337:
3762:../src/wolfcrypt/src/ecc.c **** 
3763:../src/wolfcrypt/src/ecc.c ****     return MP_OKAY;
 4998                             		.loc 2 3763 12
 4999 0079 66 05                   		mov.L	#0, r5
 5000                             		.balign 8,3,1
 5001                             	.L334:
3764:../src/wolfcrypt/src/ecc.c **** }
 5002                             		.loc 2 3764 1
 5003 007b EF 51                   		mov.L	r5, r1
 5004 007d 3F AA 04                		rtsd	#16, r10-r10
 5005                             	.LFE69:
 5007                             		.section	.text.wc_ecc_cmp_point,"ax",@progbits
 5008                             		.global	_wc_ecc_cmp_point
 5010                             	_wc_ecc_cmp_point:
 5011                             	.LFB70:
3765:../src/wolfcrypt/src/ecc.c **** 
3766:../src/wolfcrypt/src/ecc.c **** /** Compare the value of a point with an other one
3767:../src/wolfcrypt/src/ecc.c ****  a    The point to compare
3768:../src/wolfcrypt/src/ecc.c ****  b    The other point to compare
3769:../src/wolfcrypt/src/ecc.c **** 
3770:../src/wolfcrypt/src/ecc.c ****  return MP_EQ if equal, MP_LT/MP_GT if not, < 0 in case of error
3771:../src/wolfcrypt/src/ecc.c ****  */
3772:../src/wolfcrypt/src/ecc.c **** int wc_ecc_cmp_point(ecc_point* a, ecc_point *b)
3773:../src/wolfcrypt/src/ecc.c **** {
 5012                             		.loc 2 3773 1
 5013 0000 7E AA                   		push.l	r10
 5014                             	.LCFI72:
 5015 0002 71 0A F4                		add	#-12, r0, r10
 5016                             	.LCFI73:
 5017 0005 EF A0                   		mov.L	r10, r0
 5018 0007 E7 A1 01                		mov.L	r1, 4[r10]
 5019 000a E7 A2 02                		mov.L	r2, 8[r10]
3774:../src/wolfcrypt/src/ecc.c ****     int ret;
3775:../src/wolfcrypt/src/ecc.c **** 
3776:../src/wolfcrypt/src/ecc.c ****     /* prevents null arguments */
3777:../src/wolfcrypt/src/ecc.c ****     if (a == NULL || b == NULL)
 5020                             		.loc 2 3777 8
 5021 000d ED A5 01                		mov.L	4[r10], r5
 5022 0010 61 05                   		cmp	#0, r5
 5023 0012 17                      		beq	.L339
 5024                             		.loc 2 3777 19 discriminator 1
 5025 0013 ED A5 02                		mov.L	8[r10], r5
 5026 0016 61 05                   		cmp	#0, r5
 5027 0018 1F                      		bne	.L340
 5028                             	.L339:
3778:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 5029                             		.loc 2 3778 16
 5030 0019 FB 5A 53 FF             		mov.L	#-173, r5
 5031 001d 2E 5E                   		bra	.L341
 5032                             	.L340:
3779:../src/wolfcrypt/src/ecc.c **** 
3780:../src/wolfcrypt/src/ecc.c ****     ret = mp_cmp(a->x, b->x);
 5033                             		.loc 2 3780 19
 5034 001f ED A5 01                		mov.L	4[r10], r5
 5035                             		.loc 2 3780 25
 5036 0022 ED A4 02                		mov.L	8[r10], r4
 5037                             		.loc 2 3780 11
 5038 0025 EF 42                   		mov.L	r4, r2
 5039 0027 EF 51                   		mov.L	r5, r1
 5040 0029 05 00 00 00             		bsr	_sp_cmp
 5041 002d E3 A1                   		mov.L	r1, [r10]
3781:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_EQ)
 5042                             		.loc 2 3781 8
 5043 002f EC A5                   		mov.L	[r10], r5
 5044 0031 61 05                   		cmp	#0, r5
 5045 0033 15                      		beq	.L342
3782:../src/wolfcrypt/src/ecc.c ****         return ret;
 5046                             		.loc 2 3782 16
 5047 0034 EC A5                   		mov.L	[r10], r5
 5048 0036 2E 45                   		bra	.L341
 5049                             	.L342:
3783:../src/wolfcrypt/src/ecc.c ****     ret = mp_cmp(a->y, b->y);
 5050                             		.loc 2 3783 19
 5051 0038 ED A5 01                		mov.L	4[r10], r5
 5052 003b 72 54 10 03             		add	#0x310, r5, r4
 5053                             		.loc 2 3783 25
 5054 003f ED A5 02                		mov.L	8[r10], r5
 5055 0042 72 55 10 03             		add	#0x310, r5
 5056                             		.loc 2 3783 11
 5057 0046 EF 52                   		mov.L	r5, r2
 5058 0048 EF 41                   		mov.L	r4, r1
 5059 004a 05 00 00 00             		bsr	_sp_cmp
 5060 004e E3 A1                   		mov.L	r1, [r10]
3784:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_EQ)
 5061                             		.loc 2 3784 8
 5062 0050 EC A5                   		mov.L	[r10], r5
 5063 0052 61 05                   		cmp	#0, r5
 5064 0054 15                      		beq	.L343
3785:../src/wolfcrypt/src/ecc.c ****         return ret;
 5065                             		.loc 2 3785 16
 5066 0055 EC A5                   		mov.L	[r10], r5
 5067 0057 2E 24                   		bra	.L341
 5068                             	.L343:
3786:../src/wolfcrypt/src/ecc.c ****     ret = mp_cmp(a->z, b->z);
 5069                             		.loc 2 3786 19
 5070 0059 ED A5 01                		mov.L	4[r10], r5
 5071 005c 72 54 20 06             		add	#0x620, r5, r4
 5072                             		.loc 2 3786 25
 5073 0060 ED A5 02                		mov.L	8[r10], r5
 5074 0063 72 55 20 06             		add	#0x620, r5
 5075                             		.loc 2 3786 11
 5076 0067 EF 52                   		mov.L	r5, r2
 5077 0069 EF 41                   		mov.L	r4, r1
 5078 006b 05 00 00 00             		bsr	_sp_cmp
 5079 006f E3 A1                   		mov.L	r1, [r10]
3787:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_EQ)
 5080                             		.loc 2 3787 8
 5081 0071 EC A5                   		mov.L	[r10], r5
 5082 0073 61 05                   		cmp	#0, r5
 5083 0075 14                      		beq	.L344
3788:../src/wolfcrypt/src/ecc.c ****         return ret;
 5084                             		.loc 2 3788 16
 5085 0076 EC A5                   		mov.L	[r10], r5
 5086 0078 0B                      		bra	.L341
 5087                             	.L344:
3789:../src/wolfcrypt/src/ecc.c **** 
3790:../src/wolfcrypt/src/ecc.c ****     return MP_EQ;
 5088                             		.loc 2 3790 12
 5089 0079 66 05                   		mov.L	#0, r5
 5090                             		.balign 8,3,1
 5091                             	.L341:
3791:../src/wolfcrypt/src/ecc.c **** }
 5092                             		.loc 2 3791 1
 5093 007b EF 51                   		mov.L	r5, r1
 5094 007d 3F AA 04                		rtsd	#16, r10-r10
 5095                             	.LFE70:
 5097                             		.section	.text.wc_ecc_is_valid_idx,"ax",@progbits
 5098                             		.global	_wc_ecc_is_valid_idx
 5100                             	_wc_ecc_is_valid_idx:
 5101                             	.LFB71:
3792:../src/wolfcrypt/src/ecc.c **** 
3793:../src/wolfcrypt/src/ecc.c **** 
3794:../src/wolfcrypt/src/ecc.c **** /** Returns whether an ECC idx is valid or not
3795:../src/wolfcrypt/src/ecc.c ****   n      The idx number to check
3796:../src/wolfcrypt/src/ecc.c ****   return 1 if valid, 0 if not
3797:../src/wolfcrypt/src/ecc.c **** */
3798:../src/wolfcrypt/src/ecc.c **** int wc_ecc_is_valid_idx(int n)
3799:../src/wolfcrypt/src/ecc.c **** {
 5102                             		.loc 2 3799 1
 5103 0000 7E AA                   		push.l	r10
 5104                             	.LCFI74:
 5105 0002 71 0A F8                		add	#-8, r0, r10
 5106                             	.LCFI75:
 5107 0005 EF A0                   		mov.L	r10, r0
 5108 0007 E7 A1 01                		mov.L	r1, 4[r10]
3800:../src/wolfcrypt/src/ecc.c ****    int x;
3801:../src/wolfcrypt/src/ecc.c **** 
3802:../src/wolfcrypt/src/ecc.c ****    if (n >= (int)ECC_SET_COUNT)
 5109                             		.loc 2 3802 7
 5110 000a ED A5 01                		mov.L	4[r10], r5
 5111 000d 61 55                   		cmp	#5, r5
 5112 000f 2B 06                   		ble	.L346
3803:../src/wolfcrypt/src/ecc.c ****        return 0;
 5113                             		.loc 2 3803 15
 5114 0011 66 05                   		mov.L	#0, r5
 5115 0013 2E 35                   		bra	.L347
 5116                             	.L346:
3804:../src/wolfcrypt/src/ecc.c **** 
3805:../src/wolfcrypt/src/ecc.c ****    for (x = 0; ecc_sets[x].size != 0; x++)
 5117                             		.loc 2 3805 11
 5118 0015 F8 A6 00                		mov.L	#0, [r10]
 5119                             		.loc 2 3805 4
 5120 0018 0F                      		bra	.L348
 5121                             	.L349:
 5122                             		.loc 2 3805 40 discriminator 3
 5123 0019 EC A5                   		mov.L	[r10], r5
 5124 001b 62 15                   		add	#1, r5
 5125 001d E3 A5                   		mov.L	r5, [r10]
 5126                             	.L348:
 5127                             		.loc 2 3805 27 discriminator 1
 5128 001f FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5129 0025 EC A5                   		mov.L	[r10], r5
 5130 0027 75 15 34                		mul	#52, r5
 5131 002a 4B 45                   		add	r4, r5
 5132 002c EC 55                   		mov.L	[r5], r5
 5133                             		.loc 2 3805 4 discriminator 1
 5134 002e 61 05                   		cmp	#0, r5
 5135 0030 21 E9                   		bne	.L349
3806:../src/wolfcrypt/src/ecc.c ****        ;
3807:../src/wolfcrypt/src/ecc.c ****    /* -1 is a valid index --- indicating that the domain params
3808:../src/wolfcrypt/src/ecc.c ****       were supplied by the user */
3809:../src/wolfcrypt/src/ecc.c ****    if ((n >= ECC_CUSTOM_IDX) && (n < x)) {
 5136                             		.loc 2 3809 7
 5137 0032 ED A5 01                		mov.L	4[r10], r5
 5138 0035 75 05 FF                		cmp	#-1, r5
 5139 0038 29 0E                   		blt	.L350
 5140                             		.loc 2 3809 30 discriminator 1
 5141 003a ED A4 01                		mov.L	4[r10], r4
 5142 003d EC A5                   		mov.L	[r10], r5
 5143 003f 47 54                   		cmp	r5, r4
 5144 0041 28 05                   		bge	.L350
3810:../src/wolfcrypt/src/ecc.c ****       return 1;
 5145                             		.loc 2 3810 14
 5146 0043 66 15                   		mov.L	#1, r5
 5147 0045 0B                      		bra	.L347
 5148                             	.L350:
3811:../src/wolfcrypt/src/ecc.c ****    }
3812:../src/wolfcrypt/src/ecc.c **** 
3813:../src/wolfcrypt/src/ecc.c ****    return 0;
 5149                             		.loc 2 3813 11
 5150 0046 66 05                   		mov.L	#0, r5
 5151                             	.L347:
3814:../src/wolfcrypt/src/ecc.c **** }
 5152                             		.loc 2 3814 1
 5153 0048 EF 51                   		mov.L	r5, r1
 5154 004a 3F AA 03                		rtsd	#12, r10-r10
 5155                             	.LFE71:
 5157                             		.section	.text.wc_ecc_get_curve_idx,"ax",@progbits
 5158                             		.global	_wc_ecc_get_curve_idx
 5160                             	_wc_ecc_get_curve_idx:
 5161                             	.LFB72:
3815:../src/wolfcrypt/src/ecc.c **** 
3816:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_curve_idx(int curve_id)
3817:../src/wolfcrypt/src/ecc.c **** {
 5162                             		.loc 2 3817 1
 5163 0000 7E AA                   		push.l	r10
 5164                             	.LCFI76:
 5165 0002 71 0A F8                		add	#-8, r0, r10
 5166                             	.LCFI77:
 5167 0005 EF A0                   		mov.L	r10, r0
 5168 0007 E7 A1 01                		mov.L	r1, 4[r10]
3818:../src/wolfcrypt/src/ecc.c ****     int curve_idx;
3819:../src/wolfcrypt/src/ecc.c ****     for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 5169                             		.loc 2 3819 20
 5170 000a F8 A6 00                		mov.L	#0, [r10]
 5171                             		.loc 2 3819 5
 5172 000d 2E 20                   		bra	.L352
 5173                             	.L355:
3820:../src/wolfcrypt/src/ecc.c ****         if (curve_id == ecc_sets[curve_idx].id)
 5174                             		.loc 2 3820 44
 5175 000f FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5176 0015 EC A5                   		mov.L	[r10], r5
 5177 0017 75 15 34                		mul	#52, r5
 5178 001a 4B 45                   		add	r4, r5
 5179 001c 62 45                   		add	#4, r5
 5180 001e EC 55                   		mov.L	[r5], r5
 5181                             		.loc 2 3820 12
 5182 0020 ED A4 01                		mov.L	4[r10], r4
 5183 0023 47 54                   		cmp	r5, r4
 5184 0025 20 1D                   		beq	.L358
3819:../src/wolfcrypt/src/ecc.c ****         if (curve_id == ecc_sets[curve_idx].id)
 5185                             		.loc 2 3819 65 discriminator 2
 5186 0027 EC A5                   		mov.L	[r10], r5
 5187 0029 62 15                   		add	#1, r5
 5188 002b E3 A5                   		mov.L	r5, [r10]
 5189                             	.L352:
3819:../src/wolfcrypt/src/ecc.c ****         if (curve_id == ecc_sets[curve_idx].id)
 5190                             		.loc 2 3819 44 discriminator 1
 5191 002d FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5192 0033 EC A5                   		mov.L	[r10], r5
 5193 0035 75 15 34                		mul	#52, r5
 5194 0038 4B 45                   		add	r4, r5
 5195 003a EC 55                   		mov.L	[r5], r5
3819:../src/wolfcrypt/src/ecc.c ****         if (curve_id == ecc_sets[curve_idx].id)
 5196                             		.loc 2 3819 5 discriminator 1
 5197 003c 61 05                   		cmp	#0, r5
 5198 003e 21 D1                   		bne	.L355
 5199 0040 2E 03                   		bra	.L354
 5200                             	.L358:
3821:../src/wolfcrypt/src/ecc.c ****             break;
 5201                             		.loc 2 3821 13
 5202 0042 03                      		nop
 5203                             	.L354:
3822:../src/wolfcrypt/src/ecc.c ****     }
3823:../src/wolfcrypt/src/ecc.c ****     if (ecc_sets[curve_idx].size == 0) {
 5204                             		.loc 2 3823 28
 5205 0043 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5206 0049 EC A5                   		mov.L	[r10], r5
 5207 004b 75 15 34                		mul	#52, r5
 5208 004e 4B 45                   		add	r4, r5
 5209 0050 EC 55                   		mov.L	[r5], r5
 5210                             		.loc 2 3823 8
 5211 0052 61 05                   		cmp	#0, r5
 5212 0054 1D                      		bne	.L356
3824:../src/wolfcrypt/src/ecc.c ****         return ECC_CURVE_INVALID;
 5213                             		.loc 2 3824 16
 5214 0055 FB 56 FF                		mov.L	#-1, r5
 5215 0058 0B                      		bra	.L357
 5216                             	.L356:
3825:../src/wolfcrypt/src/ecc.c ****     }
3826:../src/wolfcrypt/src/ecc.c ****     return curve_idx;
 5217                             		.loc 2 3826 12
 5218 0059 EC A5                   		mov.L	[r10], r5
 5219                             	.L357:
3827:../src/wolfcrypt/src/ecc.c **** }
 5220                             		.loc 2 3827 1
 5221 005b EF 51                   		mov.L	r5, r1
 5222 005d 3F AA 03                		rtsd	#12, r10-r10
 5223                             	.LFE72:
 5225                             		.section	.text.wc_ecc_get_curve_id,"ax",@progbits
 5226                             		.global	_wc_ecc_get_curve_id
 5228                             	_wc_ecc_get_curve_id:
 5229                             	.LFB73:
3828:../src/wolfcrypt/src/ecc.c **** 
3829:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_curve_id(int curve_idx)
3830:../src/wolfcrypt/src/ecc.c **** {
 5230                             		.loc 2 3830 1
 5231 0000 7E AA                   		push.l	r10
 5232                             	.LCFI78:
 5233 0002 71 0A FC                		add	#-4, r0, r10
 5234                             	.LCFI79:
 5235 0005 EF A0                   		mov.L	r10, r0
 5236 0007 E3 A1                   		mov.L	r1, [r10]
3831:../src/wolfcrypt/src/ecc.c ****     if (wc_ecc_is_valid_idx(curve_idx)) {
 5237                             		.loc 2 3831 9
 5238 0009 EC A1                   		mov.L	[r10], r1
 5239 000b 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 5240 000f EF 15                   		mov.L	r1, r5
 5241                             		.loc 2 3831 8
 5242 0011 61 05                   		cmp	#0, r5
 5243 0013 20 14                   		beq	.L360
3832:../src/wolfcrypt/src/ecc.c ****         return ecc_sets[curve_idx].id;
 5244                             		.loc 2 3832 35
 5245 0015 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5246 001b EC A5                   		mov.L	[r10], r5
 5247 001d 75 15 34                		mul	#52, r5
 5248 0020 4B 45                   		add	r4, r5
 5249 0022 62 45                   		add	#4, r5
 5250 0024 EC 55                   		mov.L	[r5], r5
 5251 0026 0C                      		bra	.L361
 5252                             	.L360:
3833:../src/wolfcrypt/src/ecc.c ****     }
3834:../src/wolfcrypt/src/ecc.c ****     return ECC_CURVE_INVALID;
 5253                             		.loc 2 3834 12
 5254 0027 FB 56 FF                		mov.L	#-1, r5
 5255                             	.L361:
3835:../src/wolfcrypt/src/ecc.c **** }
 5256                             		.loc 2 3835 1
 5257 002a EF 51                   		mov.L	r5, r1
 5258 002c 3F AA 02                		rtsd	#8, r10-r10
 5259                             	.LFE73:
 5261                             		.section	.text.wc_ecc_get_curve_size_from_id,"ax",@progbits
 5262                             		.global	_wc_ecc_get_curve_size_from_id
 5264                             	_wc_ecc_get_curve_size_from_id:
 5265                             	.LFB74:
3836:../src/wolfcrypt/src/ecc.c **** 
3837:../src/wolfcrypt/src/ecc.c **** /* Returns the curve size that corresponds to a given ecc_curve_id identifier
3838:../src/wolfcrypt/src/ecc.c ****  *
3839:../src/wolfcrypt/src/ecc.c ****  * id      curve id, from ecc_curve_id enum in ecc.h
3840:../src/wolfcrypt/src/ecc.c ****  * return  curve size, from ecc_sets[] on success, negative on error
3841:../src/wolfcrypt/src/ecc.c ****  */
3842:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_curve_size_from_id(int curve_id)
3843:../src/wolfcrypt/src/ecc.c **** {
 5266                             		.loc 2 3843 1
 5267 0000 7E AA                   		push.l	r10
 5268                             	.LCFI80:
 5269 0002 71 0A F8                		add	#-8, r0, r10
 5270                             	.LCFI81:
 5271 0005 EF A0                   		mov.L	r10, r0
 5272 0007 E7 A1 01                		mov.L	r1, 4[r10]
3844:../src/wolfcrypt/src/ecc.c ****     int curve_idx = wc_ecc_get_curve_idx(curve_id);
 5273                             		.loc 2 3844 21
 5274 000a ED A1 01                		mov.L	4[r10], r1
 5275 000d 05 00 00 00             		bsr	_wc_ecc_get_curve_idx
 5276 0011 E3 A1                   		mov.L	r1, [r10]
3845:../src/wolfcrypt/src/ecc.c ****     if (curve_idx == ECC_CURVE_INVALID)
 5277                             		.loc 2 3845 8
 5278 0013 EC A5                   		mov.L	[r10], r5
 5279 0015 75 05 FF                		cmp	#-1, r5
 5280 0018 1F                      		bne	.L363
3846:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 5281                             		.loc 2 3846 16
 5282 0019 FB 5A 56 FF             		mov.L	#-170, r5
 5283 001d 2E 11                   		bra	.L364
 5284                             	.L363:
3847:../src/wolfcrypt/src/ecc.c ****     return ecc_sets[curve_idx].size;
 5285                             		.loc 2 3847 31
 5286 001f FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5287 0025 EC A5                   		mov.L	[r10], r5
 5288 0027 75 15 34                		mul	#52, r5
 5289 002a 4B 45                   		add	r4, r5
 5290 002c EC 55                   		mov.L	[r5], r5
 5291                             	.L364:
3848:../src/wolfcrypt/src/ecc.c **** }
 5292                             		.loc 2 3848 1
 5293 002e EF 51                   		mov.L	r5, r1
 5294 0030 3F AA 03                		rtsd	#12, r10-r10
 5295                             	.LFE74:
 5297                             		.section C,"a",@progbits
 5298                             		.p2align 2
 5299                             	.LC37:
 5300 0a14 65 63 63 5F 73 65 74 20 		.string	"ecc_set curve name not found"
 5300      63 75 72 76 65 20 6E 61 
 5300      6D 65 20 6E 6F 74 20 66 
 5300      6F 75 6E 64 00 
 5301                             		.section	.text.wc_ecc_get_curve_idx_from_name,"ax",@progbits
 5302                             		.global	_wc_ecc_get_curve_idx_from_name
 5304                             	_wc_ecc_get_curve_idx_from_name:
 5305                             	.LFB75:
3849:../src/wolfcrypt/src/ecc.c **** 
3850:../src/wolfcrypt/src/ecc.c **** /* Returns the curve index that corresponds to a given curve name in
3851:../src/wolfcrypt/src/ecc.c ****  * ecc_sets[] of ecc.c
3852:../src/wolfcrypt/src/ecc.c ****  *
3853:../src/wolfcrypt/src/ecc.c ****  * name    curve name, from ecc_sets[].name in ecc.c
3854:../src/wolfcrypt/src/ecc.c ****  * return  curve index in ecc_sets[] on success, negative on error
3855:../src/wolfcrypt/src/ecc.c ****  */
3856:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_curve_idx_from_name(const char* curveName)
3857:../src/wolfcrypt/src/ecc.c **** {
 5306                             		.loc 2 3857 1
 5307 0000 7E AA                   		push.l	r10
 5308                             	.LCFI82:
 5309 0002 71 0A F8                		add	#-8, r0, r10
 5310                             	.LCFI83:
 5311 0005 EF A0                   		mov.L	r10, r0
 5312 0007 E7 A1 01                		mov.L	r1, 4[r10]
3858:../src/wolfcrypt/src/ecc.c ****     int curve_idx;
3859:../src/wolfcrypt/src/ecc.c **** 
3860:../src/wolfcrypt/src/ecc.c ****     if (curveName == NULL)
 5313                             		.loc 2 3860 8
 5314 000a ED A5 01                		mov.L	4[r10], r5
 5315 000d 61 05                   		cmp	#0, r5
 5316 000f 1F                      		bne	.L366
3861:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 5317                             		.loc 2 3861 16
 5318 0010 FB 5A 53 FF             		mov.L	#-173, r5
 5319 0014 2E 7B                   		bra	.L367
 5320                             	.L366:
3862:../src/wolfcrypt/src/ecc.c **** 
3863:../src/wolfcrypt/src/ecc.c ****     for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 5321                             		.loc 2 3863 20
 5322 0016 F8 A6 00                		mov.L	#0, [r10]
 5323                             		.loc 2 3863 5
 5324 0019 2E 3D                   		bra	.L368
 5325                             	.L371:
3864:../src/wolfcrypt/src/ecc.c ****         if (
3865:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
3866:../src/wolfcrypt/src/ecc.c ****             ecc_sets[curve_idx].name &&
 5326                             		.loc 2 3866 32
 5327 001b FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5328 0021 EC A5                   		mov.L	[r10], r5
 5329 0023 75 15 34                		mul	#52, r5
 5330 0026 4B 45                   		add	r4, r5
 5331 0028 62 85                   		add	#8, r5
 5332 002a EC 55                   		mov.L	[r5], r5
3864:../src/wolfcrypt/src/ecc.c ****         if (
 5333                             		.loc 2 3864 12
 5334 002c 61 05                   		cmp	#0, r5
 5335 002e 20 22                   		beq	.L369
3867:../src/wolfcrypt/src/ecc.c ****         #endif
3868:../src/wolfcrypt/src/ecc.c ****                 XSTRCASECMP(ecc_sets[curve_idx].name, curveName) == 0) {
 5336                             		.loc 2 3868 17
 5337 0030 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5338 0036 EC A5                   		mov.L	[r10], r5
 5339 0038 75 15 34                		mul	#52, r5
 5340 003b 4B 45                   		add	r4, r5
 5341 003d 62 85                   		add	#8, r5
 5342 003f EC 55                   		mov.L	[r5], r5
 5343 0041 ED A2 01                		mov.L	4[r10], r2
 5344 0044 EF 51                   		mov.L	r5, r1
 5345 0046 05 00 00 00             		bsr	_strcasecmp
 5346 004a EF 15                   		mov.L	r1, r5
3866:../src/wolfcrypt/src/ecc.c ****         #endif
 5347                             		.loc 2 3866 38
 5348 004c 61 05                   		cmp	#0, r5
 5349 004e 20 1D                   		beq	.L373
 5350                             	.L369:
3863:../src/wolfcrypt/src/ecc.c ****         if (
 5351                             		.loc 2 3863 65 discriminator 2
 5352 0050 EC A5                   		mov.L	[r10], r5
 5353 0052 62 15                   		add	#1, r5
 5354 0054 E3 A5                   		mov.L	r5, [r10]
 5355                             	.L368:
3863:../src/wolfcrypt/src/ecc.c ****         if (
 5356                             		.loc 2 3863 44 discriminator 1
 5357 0056 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5358 005c EC A5                   		mov.L	[r10], r5
 5359 005e 75 15 34                		mul	#52, r5
 5360 0061 4B 45                   		add	r4, r5
 5361 0063 EC 55                   		mov.L	[r5], r5
3863:../src/wolfcrypt/src/ecc.c ****         if (
 5362                             		.loc 2 3863 5 discriminator 1
 5363 0065 61 05                   		cmp	#0, r5
 5364 0067 21 B4                   		bne	.L371
 5365 0069 2E 03                   		bra	.L370
 5366                             	.L373:
3869:../src/wolfcrypt/src/ecc.c ****             break;
 5367                             		.loc 2 3869 13
 5368 006b 03                      		nop
 5369                             	.L370:
3870:../src/wolfcrypt/src/ecc.c ****         }
3871:../src/wolfcrypt/src/ecc.c ****     }
3872:../src/wolfcrypt/src/ecc.c ****     if (ecc_sets[curve_idx].size == 0) {
 5370                             		.loc 2 3872 28
 5371 006c FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5372 0072 EC A5                   		mov.L	[r10], r5
 5373 0074 75 15 34                		mul	#52, r5
 5374 0077 4B 45                   		add	r4, r5
 5375 0079 EC 55                   		mov.L	[r5], r5
 5376                             		.loc 2 3872 8
 5377 007b 61 05                   		cmp	#0, r5
 5378 007d 21 10                   		bne	.L372
3873:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("ecc_set curve name not found");
 5379                             		.loc 2 3873 9
 5380 007f FB 12 14 0A 00 00       		mov.L	#.LC37, r1
 5381 0085 05 00 00 00             		bsr	_WOLFSSL_MSG
3874:../src/wolfcrypt/src/ecc.c ****         return ECC_CURVE_INVALID;
 5382                             		.loc 2 3874 16
 5383 0089 FB 56 FF                		mov.L	#-1, r5
 5384 008c 0B                      		bra	.L367
 5385                             	.L372:
3875:../src/wolfcrypt/src/ecc.c ****     }
3876:../src/wolfcrypt/src/ecc.c ****     return curve_idx;
 5386                             		.loc 2 3876 12
 5387 008d EC A5                   		mov.L	[r10], r5
 5388                             	.L367:
3877:../src/wolfcrypt/src/ecc.c **** }
 5389                             		.loc 2 3877 1
 5390 008f EF 51                   		mov.L	r5, r1
 5391 0091 3F AA 03                		rtsd	#12, r10-r10
 5392                             	.LFE75:
 5394                             		.section	.text.wc_ecc_get_curve_size_from_name,"ax",@progbits
 5395                             		.global	_wc_ecc_get_curve_size_from_name
 5397                             	_wc_ecc_get_curve_size_from_name:
 5398                             	.LFB76:
3878:../src/wolfcrypt/src/ecc.c **** 
3879:../src/wolfcrypt/src/ecc.c **** /* Returns the curve size that corresponds to a given curve name,
3880:../src/wolfcrypt/src/ecc.c ****  * as listed in ecc_sets[] of ecc.c.
3881:../src/wolfcrypt/src/ecc.c ****  *
3882:../src/wolfcrypt/src/ecc.c ****  * name    curve name, from ecc_sets[].name in ecc.c
3883:../src/wolfcrypt/src/ecc.c ****  * return  curve size, from ecc_sets[] on success, negative on error
3884:../src/wolfcrypt/src/ecc.c ****  */
3885:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_curve_size_from_name(const char* curveName)
3886:../src/wolfcrypt/src/ecc.c **** {
 5399                             		.loc 2 3886 1
 5400 0000 7E AA                   		push.l	r10
 5401                             	.LCFI84:
 5402 0002 71 0A F8                		add	#-8, r0, r10
 5403                             	.LCFI85:
 5404 0005 EF A0                   		mov.L	r10, r0
 5405 0007 E7 A1 01                		mov.L	r1, 4[r10]
3887:../src/wolfcrypt/src/ecc.c ****     int curve_idx;
3888:../src/wolfcrypt/src/ecc.c **** 
3889:../src/wolfcrypt/src/ecc.c ****     if (curveName == NULL)
 5406                             		.loc 2 3889 8
 5407 000a ED A5 01                		mov.L	4[r10], r5
 5408 000d 61 05                   		cmp	#0, r5
 5409 000f 1F                      		bne	.L375
3890:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 5410                             		.loc 2 3890 16
 5411 0010 FB 5A 53 FF             		mov.L	#-173, r5
 5412 0014 2E 24                   		bra	.L376
 5413                             	.L375:
3891:../src/wolfcrypt/src/ecc.c **** 
3892:../src/wolfcrypt/src/ecc.c ****     curve_idx = wc_ecc_get_curve_idx_from_name(curveName);
 5414                             		.loc 2 3892 17
 5415 0016 ED A1 01                		mov.L	4[r10], r1
 5416 0019 05 00 00 00             		bsr	_wc_ecc_get_curve_idx_from_name
 5417 001d E3 A1                   		mov.L	r1, [r10]
3893:../src/wolfcrypt/src/ecc.c ****     if (curve_idx < 0)
 5418                             		.loc 2 3893 8
 5419 001f EC A5                   		mov.L	[r10], r5
 5420 0021 61 05                   		cmp	#0, r5
 5421 0023 28 06                   		bge	.L377
3894:../src/wolfcrypt/src/ecc.c ****         return curve_idx;
 5422                             		.loc 2 3894 16
 5423 0025 EC A5                   		mov.L	[r10], r5
 5424 0027 2E 11                   		bra	.L376
 5425                             	.L377:
3895:../src/wolfcrypt/src/ecc.c **** 
3896:../src/wolfcrypt/src/ecc.c ****     return ecc_sets[curve_idx].size;
 5426                             		.loc 2 3896 31
 5427 0029 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5428 002f EC A5                   		mov.L	[r10], r5
 5429 0031 75 15 34                		mul	#52, r5
 5430 0034 4B 45                   		add	r4, r5
 5431 0036 EC 55                   		mov.L	[r5], r5
 5432                             	.L376:
3897:../src/wolfcrypt/src/ecc.c **** }
 5433                             		.loc 2 3897 1
 5434 0038 EF 51                   		mov.L	r5, r1
 5435 003a 3F AA 03                		rtsd	#12, r10-r10
 5436                             	.LFE76:
 5438                             		.section	.text.wc_ecc_get_curve_id_from_name,"ax",@progbits
 5439                             		.global	_wc_ecc_get_curve_id_from_name
 5441                             	_wc_ecc_get_curve_id_from_name:
 5442                             	.LFB77:
3898:../src/wolfcrypt/src/ecc.c **** 
3899:../src/wolfcrypt/src/ecc.c **** /* Returns the curve id that corresponds to a given curve name,
3900:../src/wolfcrypt/src/ecc.c ****  * as listed in ecc_sets[] of ecc.c.
3901:../src/wolfcrypt/src/ecc.c ****  *
3902:../src/wolfcrypt/src/ecc.c ****  * name   curve name, from ecc_sets[].name in ecc.c
3903:../src/wolfcrypt/src/ecc.c ****  * return curve id, from ecc_sets[] on success, negative on error
3904:../src/wolfcrypt/src/ecc.c ****  */
3905:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_curve_id_from_name(const char* curveName)
3906:../src/wolfcrypt/src/ecc.c **** {
 5443                             		.loc 2 3906 1
 5444 0000 7E AA                   		push.l	r10
 5445                             	.LCFI86:
 5446 0002 71 0A F8                		add	#-8, r0, r10
 5447                             	.LCFI87:
 5448 0005 EF A0                   		mov.L	r10, r0
 5449 0007 E7 A1 01                		mov.L	r1, 4[r10]
3907:../src/wolfcrypt/src/ecc.c ****     int curve_idx;
3908:../src/wolfcrypt/src/ecc.c **** 
3909:../src/wolfcrypt/src/ecc.c ****     if (curveName == NULL)
 5450                             		.loc 2 3909 8
 5451 000a ED A5 01                		mov.L	4[r10], r5
 5452 000d 61 05                   		cmp	#0, r5
 5453 000f 1F                      		bne	.L379
3910:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 5454                             		.loc 2 3910 16
 5455 0010 FB 5A 53 FF             		mov.L	#-173, r5
 5456 0014 2E 26                   		bra	.L380
 5457                             	.L379:
3911:../src/wolfcrypt/src/ecc.c **** 
3912:../src/wolfcrypt/src/ecc.c ****     curve_idx = wc_ecc_get_curve_idx_from_name(curveName);
 5458                             		.loc 2 3912 17
 5459 0016 ED A1 01                		mov.L	4[r10], r1
 5460 0019 05 00 00 00             		bsr	_wc_ecc_get_curve_idx_from_name
 5461 001d E3 A1                   		mov.L	r1, [r10]
3913:../src/wolfcrypt/src/ecc.c ****     if (curve_idx < 0)
 5462                             		.loc 2 3913 8
 5463 001f EC A5                   		mov.L	[r10], r5
 5464 0021 61 05                   		cmp	#0, r5
 5465 0023 28 06                   		bge	.L381
3914:../src/wolfcrypt/src/ecc.c ****         return curve_idx;
 5466                             		.loc 2 3914 16
 5467 0025 EC A5                   		mov.L	[r10], r5
 5468 0027 2E 13                   		bra	.L380
 5469                             	.L381:
3915:../src/wolfcrypt/src/ecc.c **** 
3916:../src/wolfcrypt/src/ecc.c ****     return ecc_sets[curve_idx].id;
 5470                             		.loc 2 3916 31
 5471 0029 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5472 002f EC A5                   		mov.L	[r10], r5
 5473 0031 75 15 34                		mul	#52, r5
 5474 0034 4B 45                   		add	r4, r5
 5475 0036 62 45                   		add	#4, r5
 5476 0038 EC 55                   		mov.L	[r5], r5
 5477                             	.L380:
3917:../src/wolfcrypt/src/ecc.c **** }
 5478                             		.loc 2 3917 1
 5479 003a EF 51                   		mov.L	r5, r1
 5480 003c 3F AA 03                		rtsd	#12, r10-r10
 5481                             	.LFE77:
 5483                             		.section	.text.wc_ecc_cmp_param,"ax",@progbits
 5485                             	_wc_ecc_cmp_param:
 5486                             	.LFB78:
3918:../src/wolfcrypt/src/ecc.c **** 
3919:../src/wolfcrypt/src/ecc.c **** /* Compares a curve parameter (hex, from ecc_sets[]) to given input
3920:../src/wolfcrypt/src/ecc.c ****  * parameter for equality.
3921:../src/wolfcrypt/src/ecc.c ****  * encType is WC_TYPE_UNSIGNED_BIN or WC_TYPE_HEX_STR
3922:../src/wolfcrypt/src/ecc.c ****  * Returns MP_EQ on success, negative on error */
3923:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_cmp_param(const char* curveParam,
3924:../src/wolfcrypt/src/ecc.c ****                             const byte* param, word32 paramSz, int encType)
3925:../src/wolfcrypt/src/ecc.c **** {
 5487                             		.loc 2 3925 1
 5488 0000 7E AA                   		push.l	r10
 5489                             	.LCFI88:
 5490 0002 71 0A D0                		add	#-48, r0, r10
 5491                             	.LCFI89:
 5492 0005 71 A0 F8                		add	#-8, r10, r0
 5493                             	.LCFI90:
 5494 0008 E7 A1 08                		mov.L	r1, 32[r10]
 5495 000b E7 A2 09                		mov.L	r2, 36[r10]
 5496 000e E7 A3 0A                		mov.L	r3, 40[r10]
 5497 0011 E7 A4 0B                		mov.L	r4, 44[r10]
3926:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 5498                             		.loc 2 3926 9
 5499 0014 F8 A6 00                		mov.L	#0, [r10]
3927:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
3928:../src/wolfcrypt/src/ecc.c ****     mp_int* a = NULL;
 5500                             		.loc 2 3928 13
 5501 0017 F9 A6 01 00             		mov.L	#0, 4[r10]
3929:../src/wolfcrypt/src/ecc.c ****     mp_int* b = NULL;
 5502                             		.loc 2 3929 13
 5503 001b F9 A6 02 00             		mov.L	#0, 8[r10]
3930:../src/wolfcrypt/src/ecc.c **** #else
3931:../src/wolfcrypt/src/ecc.c ****     mp_int  a[1], b[1];
3932:../src/wolfcrypt/src/ecc.c **** #endif
3933:../src/wolfcrypt/src/ecc.c **** 
3934:../src/wolfcrypt/src/ecc.c ****     if (param == NULL || curveParam == NULL)
 5504                             		.loc 2 3934 8
 5505 001f ED A5 09                		mov.L	36[r10], r5
 5506 0022 61 05                   		cmp	#0, r5
 5507 0024 17                      		beq	.L383
 5508                             		.loc 2 3934 23 discriminator 1
 5509 0025 ED A5 08                		mov.L	32[r10], r5
 5510 0028 61 05                   		cmp	#0, r5
 5511 002a 18                      		bne	.L384
 5512                             	.L383:
3935:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 5513                             		.loc 2 3935 16
 5514 002b FB 5A 53 FF             		mov.L	#-173, r5
 5515 002f 38 21 01                		bra	.L385
 5516                             	.L384:
3936:../src/wolfcrypt/src/ecc.c **** 
3937:../src/wolfcrypt/src/ecc.c ****     if (encType == WC_TYPE_HEX_STR)
 5517                             		.loc 2 3937 8
 5518 0032 ED A5 0B                		mov.L	44[r10], r5
 5519 0035 61 15                   		cmp	#1, r5
 5520 0037 21 14                   		bne	.L386
3938:../src/wolfcrypt/src/ecc.c ****         return XSTRNCMP(curveParam, (char*) param, paramSz);
 5521                             		.loc 2 3938 16
 5522 0039 ED A3 0A                		mov.L	40[r10], r3
 5523 003c ED A2 09                		mov.L	36[r10], r2
 5524 003f ED A1 08                		mov.L	32[r10], r1
 5525 0042 05 00 00 00             		bsr	_strncmp
 5526 0046 EF 15                   		mov.L	r1, r5
 5527 0048 38 08 01                		bra	.L385
 5528                             	.L386:
3939:../src/wolfcrypt/src/ecc.c **** 
3940:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
3941:../src/wolfcrypt/src/ecc.c ****     a = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 5529                             		.loc 2 3941 18
 5530 004b FB 1A 10 03             		mov.L	#0x310, r1
 5531 004f 05 00 00 00             		bsr	_wolfSSL_Malloc
 5532 0053 E7 A1 01                		mov.L	r1, 4[r10]
3942:../src/wolfcrypt/src/ecc.c ****     if (a == NULL)
 5533                             		.loc 2 3942 8
 5534 0056 ED A5 01                		mov.L	4[r10], r5
 5535 0059 61 05                   		cmp	#0, r5
 5536 005b 1F                      		bne	.L387
3943:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 5537                             		.loc 2 3943 16
 5538 005c FB 56 83                		mov.L	#-125, r5
 5539 005f 38 F1 00                		bra	.L385
 5540                             	.L387:
3944:../src/wolfcrypt/src/ecc.c ****     b = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 5541                             		.loc 2 3944 18
 5542 0062 FB 1A 10 03             		mov.L	#0x310, r1
 5543 0066 05 00 00 00             		bsr	_wolfSSL_Malloc
 5544 006a E7 A1 02                		mov.L	r1, 8[r10]
3945:../src/wolfcrypt/src/ecc.c ****     if (b == NULL) {
 5545                             		.loc 2 3945 8
 5546 006d ED A5 02                		mov.L	8[r10], r5
 5547 0070 61 05                   		cmp	#0, r5
 5548 0072 21 1B                   		bne	.L388
 5549                             	.LBB29:
3946:../src/wolfcrypt/src/ecc.c ****         XFREE(a, NULL, DYNAMIC_TYPE_ECC);
 5550                             		.loc 2 3946 9
 5551 0074 ED A5 01                		mov.L	4[r10], r5
 5552 0077 E7 A5 03                		mov.L	r5, 12[r10]
 5553 007a ED A5 03                		mov.L	12[r10], r5
 5554 007d 61 05                   		cmp	#0, r5
 5555 007f 10                      		beq	.L389
 5556                             		.loc 2 3946 9 is_stmt 0 discriminator 1
 5557 0080 ED A1 03                		mov.L	12[r10], r1
 5558 0083 05 00 00 00             		bsr	_wolfSSL_Free
 5559                             	.L389:
 5560                             	.LBE29:
3947:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 5561                             		.loc 2 3947 16 is_stmt 1
 5562 0087 FB 56 83                		mov.L	#-125, r5
 5563 008a 38 C6 00                		bra	.L385
 5564                             	.L388:
3948:../src/wolfcrypt/src/ecc.c ****     }
3949:../src/wolfcrypt/src/ecc.c **** #endif
3950:../src/wolfcrypt/src/ecc.c **** 
3951:../src/wolfcrypt/src/ecc.c ****     if ((err = mp_init_multi(a, b, NULL, NULL, NULL, NULL)) != MP_OKAY) {
 5565                             		.loc 2 3951 16
 5566 008d 3E 01 00                		mov.L	#0, 4[r0]
 5567 0090 F8 06 00                		mov.L	#0, [r0]
 5568 0093 66 04                   		mov.L	#0, r4
 5569 0095 66 03                   		mov.L	#0, r3
 5570 0097 ED A2 02                		mov.L	8[r10], r2
 5571 009a ED A1 01                		mov.L	4[r10], r1
 5572 009d 05 00 00 00             		bsr	_sp_init_multi
 5573 00a1 E3 A1                   		mov.L	r1, [r10]
 5574                             		.loc 2 3951 8
 5575 00a3 EC A5                   		mov.L	[r10], r5
 5576 00a5 61 05                   		cmp	#0, r5
 5577 00a7 20 2C                   		beq	.L390
 5578                             	.LBB30:
3952:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
3953:../src/wolfcrypt/src/ecc.c ****         XFREE(a, NULL, DYNAMIC_TYPE_ECC);
 5579                             		.loc 2 3953 9
 5580 00a9 ED A5 01                		mov.L	4[r10], r5
 5581 00ac E7 A5 04                		mov.L	r5, 16[r10]
 5582 00af ED A5 04                		mov.L	16[r10], r5
 5583 00b2 61 05                   		cmp	#0, r5
 5584 00b4 10                      		beq	.L391
 5585                             		.loc 2 3953 9 is_stmt 0 discriminator 1
 5586 00b5 ED A1 04                		mov.L	16[r10], r1
 5587 00b8 05 00 00 00             		bsr	_wolfSSL_Free
 5588                             	.L391:
 5589                             	.LBE30:
 5590                             	.LBB31:
3954:../src/wolfcrypt/src/ecc.c ****         XFREE(b, NULL, DYNAMIC_TYPE_ECC);
 5591                             		.loc 2 3954 9 is_stmt 1
 5592 00bc ED A5 02                		mov.L	8[r10], r5
 5593 00bf E7 A5 05                		mov.L	r5, 20[r10]
 5594 00c2 ED A5 05                		mov.L	20[r10], r5
 5595 00c5 61 05                   		cmp	#0, r5
 5596 00c7 10                      		beq	.L392
 5597                             		.loc 2 3954 9 is_stmt 0 discriminator 1
 5598 00c8 ED A1 05                		mov.L	20[r10], r1
 5599 00cb 05 00 00 00             		bsr	_wolfSSL_Free
 5600                             	.L392:
 5601                             	.LBE31:
3955:../src/wolfcrypt/src/ecc.c ****     #endif
3956:../src/wolfcrypt/src/ecc.c ****         return err;
 5602                             		.loc 2 3956 16 is_stmt 1
 5603 00cf EC A5                   		mov.L	[r10], r5
 5604 00d1 2E 7F                   		bra	.L385
 5605                             	.L390:
3957:../src/wolfcrypt/src/ecc.c ****     }
3958:../src/wolfcrypt/src/ecc.c **** 
3959:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 5606                             		.loc 2 3959 8
 5607 00d3 EC A5                   		mov.L	[r10], r5
 5608 00d5 61 05                   		cmp	#0, r5
 5609 00d7 21 11                   		bne	.L393
3960:../src/wolfcrypt/src/ecc.c ****         err = mp_read_unsigned_bin(a, param, paramSz);
 5610                             		.loc 2 3960 15
 5611 00d9 ED A3 0A                		mov.L	40[r10], r3
 5612 00dc ED A2 09                		mov.L	36[r10], r2
 5613 00df ED A1 01                		mov.L	4[r10], r1
 5614 00e2 05 00 00 00             		bsr	_sp_read_unsigned_bin
 5615 00e6 E3 A1                   		mov.L	r1, [r10]
 5616                             	.L393:
3961:../src/wolfcrypt/src/ecc.c ****     }
3962:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 5617                             		.loc 2 3962 8
 5618 00e8 EC A5                   		mov.L	[r10], r5
 5619 00ea 61 05                   		cmp	#0, r5
 5620 00ec 21 11                   		bne	.L394
3963:../src/wolfcrypt/src/ecc.c ****         err = mp_read_radix(b, curveParam, MP_RADIX_HEX);
 5621                             		.loc 2 3963 15
 5622 00ee 75 43 10                		mov.L	#16, r3
 5623 00f1 ED A2 08                		mov.L	32[r10], r2
 5624 00f4 ED A1 02                		mov.L	8[r10], r1
 5625 00f7 05 00 00 00             		bsr	_sp_read_radix
 5626 00fb E3 A1                   		mov.L	r1, [r10]
 5627                             	.L394:
3964:../src/wolfcrypt/src/ecc.c **** 
3965:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 5628                             		.loc 2 3965 8
 5629 00fd EC A5                   		mov.L	[r10], r5
 5630 00ff 61 05                   		cmp	#0, r5
 5631 0101 21 18                   		bne	.L395
3966:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp(a, b) != MP_EQ) {
 5632                             		.loc 2 3966 13
 5633 0103 ED A2 02                		mov.L	8[r10], r2
 5634 0106 ED A1 01                		mov.L	4[r10], r1
 5635 0109 05 00 00 00             		bsr	_sp_cmp
 5636 010d EF 15                   		mov.L	r1, r5
 5637                             		.loc 2 3966 12
 5638 010f 61 05                   		cmp	#0, r5
 5639 0111 15                      		beq	.L396
3967:../src/wolfcrypt/src/ecc.c ****             err = -1;
 5640                             		.loc 2 3967 17
 5641 0112 F8 A6 FF                		mov.L	#-1, [r10]
 5642 0115 0C                      		bra	.L395
 5643                             	.L396:
3968:../src/wolfcrypt/src/ecc.c ****         } else {
3969:../src/wolfcrypt/src/ecc.c ****             err = MP_EQ;
 5644                             		.loc 2 3969 17
 5645 0116 F8 A6 00                		mov.L	#0, [r10]
 5646                             	.L395:
3970:../src/wolfcrypt/src/ecc.c ****         }
3971:../src/wolfcrypt/src/ecc.c ****     }
3972:../src/wolfcrypt/src/ecc.c **** 
3973:../src/wolfcrypt/src/ecc.c ****     mp_clear(a);
 5647                             		.loc 2 3973 5
 5648 0119 ED A1 01                		mov.L	4[r10], r1
 5649 011c 05 00 00 00             		bsr	_sp_clear
3974:../src/wolfcrypt/src/ecc.c ****     mp_clear(b);
 5650                             		.loc 2 3974 5
 5651 0120 ED A1 02                		mov.L	8[r10], r1
 5652 0123 05 00 00 00             		bsr	_sp_clear
 5653                             	.LBB32:
3975:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
3976:../src/wolfcrypt/src/ecc.c ****     XFREE(b, NULL, DYNAMIC_TYPE_ECC);
 5654                             		.loc 2 3976 5
 5655 0127 ED A5 02                		mov.L	8[r10], r5
 5656 012a E7 A5 06                		mov.L	r5, 24[r10]
 5657 012d ED A5 06                		mov.L	24[r10], r5
 5658 0130 61 05                   		cmp	#0, r5
 5659 0132 10                      		beq	.L397
 5660                             		.loc 2 3976 5 is_stmt 0 discriminator 1
 5661 0133 ED A1 06                		mov.L	24[r10], r1
 5662 0136 05 00 00 00             		bsr	_wolfSSL_Free
 5663                             	.L397:
 5664                             	.LBE32:
 5665                             	.LBB33:
3977:../src/wolfcrypt/src/ecc.c ****     XFREE(a, NULL, DYNAMIC_TYPE_ECC);
 5666                             		.loc 2 3977 5 is_stmt 1
 5667 013a ED A5 01                		mov.L	4[r10], r5
 5668 013d E7 A5 07                		mov.L	r5, 28[r10]
 5669 0140 ED A5 07                		mov.L	28[r10], r5
 5670 0143 61 05                   		cmp	#0, r5
 5671 0145 10                      		beq	.L398
 5672                             		.loc 2 3977 5 is_stmt 0 discriminator 1
 5673 0146 ED A1 07                		mov.L	28[r10], r1
 5674 0149 05 00 00 00             		bsr	_wolfSSL_Free
 5675                             	.L398:
 5676                             	.LBE33:
3978:../src/wolfcrypt/src/ecc.c **** #endif
3979:../src/wolfcrypt/src/ecc.c **** 
3980:../src/wolfcrypt/src/ecc.c ****     return err;
 5677                             		.loc 2 3980 12 is_stmt 1
 5678 014d EC A5                   		mov.L	[r10], r5
 5679 014f 03                      		.balign 8,3,1
 5680                             	.L385:
3981:../src/wolfcrypt/src/ecc.c **** }
 5681                             		.loc 2 3981 1
 5682 0150 EF 51                   		mov.L	r5, r1
 5683 0152 3F AA 0F                		rtsd	#60, r10-r10
 5684                             	.LFE78:
 5686 0155 FC 13 00                		.section	.text.wc_ecc_get_curve_id_from_params,"ax",@progbits
 5687                             		.global	_wc_ecc_get_curve_id_from_params
 5689                             	_wc_ecc_get_curve_id_from_params:
 5690                             	.LFB79:
3982:../src/wolfcrypt/src/ecc.c **** 
3983:../src/wolfcrypt/src/ecc.c **** /* Returns the curve id in ecc_sets[] that corresponds to a given set of
3984:../src/wolfcrypt/src/ecc.c ****  * curve parameters.
3985:../src/wolfcrypt/src/ecc.c ****  *
3986:../src/wolfcrypt/src/ecc.c ****  * fieldSize  the field size in bits
3987:../src/wolfcrypt/src/ecc.c ****  * prime      prime of the finite field
3988:../src/wolfcrypt/src/ecc.c ****  * primeSz    size of prime in octets
3989:../src/wolfcrypt/src/ecc.c ****  * Af         first coefficient a of the curve
3990:../src/wolfcrypt/src/ecc.c ****  * AfSz       size of Af in octets
3991:../src/wolfcrypt/src/ecc.c ****  * Bf         second coefficient b of the curve
3992:../src/wolfcrypt/src/ecc.c ****  * BfSz       size of Bf in octets
3993:../src/wolfcrypt/src/ecc.c ****  * order      curve order
3994:../src/wolfcrypt/src/ecc.c ****  * orderSz    size of curve in octets
3995:../src/wolfcrypt/src/ecc.c ****  * Gx         affine x coordinate of base point
3996:../src/wolfcrypt/src/ecc.c ****  * GxSz       size of Gx in octets
3997:../src/wolfcrypt/src/ecc.c ****  * Gy         affine y coordinate of base point
3998:../src/wolfcrypt/src/ecc.c ****  * GySz       size of Gy in octets
3999:../src/wolfcrypt/src/ecc.c ****  * cofactor   curve cofactor
4000:../src/wolfcrypt/src/ecc.c ****  *
4001:../src/wolfcrypt/src/ecc.c ****  * return curve id, from ecc_sets[] on success, negative on error
4002:../src/wolfcrypt/src/ecc.c ****  */
4003:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_curve_id_from_params(int fieldSize,
4004:../src/wolfcrypt/src/ecc.c ****         const byte* prime, word32 primeSz, const byte* Af, word32 AfSz,
4005:../src/wolfcrypt/src/ecc.c ****         const byte* Bf, word32 BfSz, const byte* order, word32 orderSz,
4006:../src/wolfcrypt/src/ecc.c ****         const byte* Gx, word32 GxSz, const byte* Gy, word32 GySz, int cofactor)
4007:../src/wolfcrypt/src/ecc.c **** {
 5691                             		.loc 2 4007 1
 5692 0000 7E AA                   		push.l	r10
 5693                             	.LCFI91:
 5694 0002 7E A6                   		push.l	r6
 5695                             	.LCFI92:
 5696 0004 71 0A C0                		add	#-64, r0, r10
 5697                             	.LCFI93:
 5698 0007 EF A0                   		mov.L	r10, r0
 5699 0009 75 46 4C                		mov.L	#0x4c, r6
 5700 000c 4B A6                   		add	r10, r6
 5701 000e E7 A1 02                		mov.L	r1, 8[r10]
 5702 0011 E7 A2 03                		mov.L	r2, 12[r10]
 5703 0014 E7 A3 04                		mov.L	r3, 16[r10]
 5704 0017 E7 A4 05                		mov.L	r4, 20[r10]
4008:../src/wolfcrypt/src/ecc.c ****     int idx;
4009:../src/wolfcrypt/src/ecc.c ****     int curveSz;
4010:../src/wolfcrypt/src/ecc.c **** 
4011:../src/wolfcrypt/src/ecc.c ****     if (prime == NULL || Af == NULL || Bf == NULL || order == NULL ||
 5705                             		.loc 2 4011 8
 5706 001a ED A5 03                		mov.L	12[r10], r5
 5707 001d 61 05                   		cmp	#0, r5
 5708 001f 20 21                   		beq	.L400
 5709                             		.loc 2 4011 23 discriminator 1
 5710 0021 ED A5 05                		mov.L	20[r10], r5
 5711 0024 61 05                   		cmp	#0, r5
 5712 0026 20 1A                   		beq	.L400
 5713                             		.loc 2 4011 37 discriminator 2
 5714 0028 A8 6D                   		mov.L	4[r6], r5
 5715 002a 61 05                   		cmp	#0, r5
 5716 002c 20 14                   		beq	.L400
 5717                             		.loc 2 4011 51 discriminator 3
 5718 002e A8 ED                   		mov.L	12[r6], r5
 5719 0030 61 05                   		cmp	#0, r5
 5720 0032 20 0E                   		beq	.L400
 5721                             		.loc 2 4011 68 discriminator 4
 5722 0034 A9 6D                   		mov.L	20[r6], r5
 5723 0036 61 05                   		cmp	#0, r5
 5724 0038 10                      		beq	.L400
4012:../src/wolfcrypt/src/ecc.c ****         Gx == NULL || Gy == NULL)
 5725                             		.loc 2 4012 20
 5726 0039 A9 ED                   		mov.L	28[r6], r5
 5727 003b 61 05                   		cmp	#0, r5
 5728 003d 1A                      		bne	.L401
 5729 003e EF 00                   		.balign 8,3,2
 5730                             	.L400:
4013:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 5731                             		.loc 2 4013 16
 5732 0040 FB 5A 53 FF             		mov.L	#-173, r5
 5733 0044 38 6A 01                		bra	.L402
 5734                             	.L401:
4014:../src/wolfcrypt/src/ecc.c **** 
4015:../src/wolfcrypt/src/ecc.c ****     curveSz = (fieldSize + 1) / 8;    /* round up */
 5735                             		.loc 2 4015 26
 5736 0047 ED A5 02                		mov.L	8[r10], r5
 5737 004a 62 15                   		add	#1, r5
 5738                             		.loc 2 4015 13
 5739 004c 61 05                   		cmp	#0, r5
 5740 004e 28 04                   		bge	.L403
 5741 0050 62 75                   		add	#7, r5
 5742                             	.L403:
 5743 0052 6A 35                   		shar	#3, r5
 5744 0054 E7 A5 01                		mov.L	r5, 4[r10]
4016:../src/wolfcrypt/src/ecc.c **** 
4017:../src/wolfcrypt/src/ecc.c ****     for (idx = 0; ecc_sets[idx].size != 0; idx++) {
 5745                             		.loc 2 4017 14
 5746 0057 F8 A6 00                		mov.L	#0, [r10]
 5747                             		.loc 2 4017 5
 5748 005a 38 15 01                		bra	.L404
 5749                             	.L407:
4018:../src/wolfcrypt/src/ecc.c ****         if (curveSz == ecc_sets[idx].size) {
 5750                             		.loc 2 4018 37
 5751 005d FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5752 0063 EC A5                   		mov.L	[r10], r5
 5753 0065 75 15 34                		mul	#52, r5
 5754 0068 4B 45                   		add	r4, r5
 5755 006a EC 55                   		mov.L	[r5], r5
 5756                             		.loc 2 4018 12
 5757 006c ED A4 01                		mov.L	4[r10], r4
 5758 006f 47 54                   		cmp	r5, r4
 5759 0071 3B F8 00                		bne	.L405
4019:../src/wolfcrypt/src/ecc.c ****             if ((wc_ecc_cmp_param(ecc_sets[idx].prime, prime,
 5760                             		.loc 2 4019 18
 5761 0074 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5762 007a EC A5                   		mov.L	[r10], r5
 5763 007c 75 15 34                		mul	#52, r5
 5764 007f 4B 45                   		add	r4, r5
 5765 0081 62 C5                   		add	#12, r5
 5766 0083 EC 55                   		mov.L	[r5], r5
 5767 0085 66 24                   		mov.L	#2, r4
 5768 0087 ED A3 04                		mov.L	16[r10], r3
 5769 008a ED A2 03                		mov.L	12[r10], r2
 5770 008d EF 51                   		mov.L	r5, r1
 5771 008f 05 00 00 00             		bsr	_wc_ecc_cmp_param
 5772 0093 EF 15                   		mov.L	r1, r5
 5773                             		.loc 2 4019 16
 5774 0095 61 05                   		cmp	#0, r5
 5775 0097 3B D2 00                		bne	.L405
4020:../src/wolfcrypt/src/ecc.c ****                             primeSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
4021:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Af, Af, AfSz,
 5776                             		.loc 2 4021 18
 5777 009a FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5778 00a0 EC A5                   		mov.L	[r10], r5
 5779 00a2 75 15 34                		mul	#52, r5
 5780 00a5 4B 45                   		add	r4, r5
 5781 00a7 71 55 10                		add	#16, r5
 5782 00aa EC 55                   		mov.L	[r5], r5
 5783 00ac 66 24                   		mov.L	#2, r4
 5784 00ae EC 63                   		mov.L	[r6], r3
 5785 00b0 ED A2 05                		mov.L	20[r10], r2
 5786 00b3 EF 51                   		mov.L	r5, r1
 5787 00b5 05 00 00 00             		bsr	_wc_ecc_cmp_param
 5788 00b9 EF 15                   		mov.L	r1, r5
4020:../src/wolfcrypt/src/ecc.c ****                             primeSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
 5789                             		.loc 2 4020 70
 5790 00bb 61 05                   		cmp	#0, r5
 5791 00bd 3B AC 00                		bne	.L405
4022:../src/wolfcrypt/src/ecc.c ****                                   WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
4023:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Bf, Bf, BfSz,
 5792                             		.loc 2 4023 18
 5793 00c0 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5794 00c6 EC A5                   		mov.L	[r10], r5
 5795 00c8 75 15 34                		mul	#52, r5
 5796 00cb 4B 45                   		add	r4, r5
 5797 00cd 71 55 14                		add	#20, r5
 5798 00d0 EC 55                   		mov.L	[r5], r5
 5799 00d2 66 24                   		mov.L	#2, r4
 5800 00d4 A8 E3                   		mov.L	8[r6], r3
 5801 00d6 A8 6A                   		mov.L	4[r6], r2
 5802 00d8 EF 51                   		mov.L	r5, r1
 5803 00da 05 00 00 00             		bsr	_wc_ecc_cmp_param
 5804 00de EF 15                   		mov.L	r1, r5
4022:../src/wolfcrypt/src/ecc.c ****                                   WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
 5805                             		.loc 2 4022 67
 5806 00e0 61 05                   		cmp	#0, r5
 5807 00e2 3B 87 00                		bne	.L405
4024:../src/wolfcrypt/src/ecc.c ****                                   WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
4025:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].order, order,
 5808                             		.loc 2 4025 18
 5809 00e5 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5810 00eb EC A5                   		mov.L	[r10], r5
 5811 00ed 75 15 34                		mul	#52, r5
 5812 00f0 4B 45                   		add	r4, r5
 5813 00f2 71 55 18                		add	#24, r5
 5814 00f5 EC 55                   		mov.L	[r5], r5
 5815 00f7 66 24                   		mov.L	#2, r4
 5816 00f9 A9 63                   		mov.L	16[r6], r3
 5817 00fb A8 EA                   		mov.L	12[r6], r2
 5818 00fd EF 51                   		mov.L	r5, r1
 5819 00ff 05 00 00 00             		bsr	_wc_ecc_cmp_param
 5820 0103 EF 15                   		mov.L	r1, r5
4024:../src/wolfcrypt/src/ecc.c ****                                   WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
 5821                             		.loc 2 4024 67
 5822 0105 61 05                   		cmp	#0, r5
 5823 0107 21 62                   		bne	.L405
4026:../src/wolfcrypt/src/ecc.c ****                                   orderSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
4027:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Gx, Gx, GxSz,
 5824                             		.loc 2 4027 18
 5825 0109 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5826 010f EC A5                   		mov.L	[r10], r5
 5827 0111 75 15 34                		mul	#52, r5
 5828 0114 4B 45                   		add	r4, r5
 5829 0116 71 55 1C                		add	#28, r5
 5830 0119 EC 55                   		mov.L	[r5], r5
 5831 011b 66 24                   		mov.L	#2, r4
 5832 011d A9 E3                   		mov.L	24[r6], r3
 5833 011f A9 6A                   		mov.L	20[r6], r2
 5834 0121 EF 51                   		mov.L	r5, r1
 5835 0123 05 00 00 00             		bsr	_wc_ecc_cmp_param
 5836 0127 EF 15                   		mov.L	r1, r5
4026:../src/wolfcrypt/src/ecc.c ****                                   orderSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
 5837                             		.loc 2 4026 76
 5838 0129 61 05                   		cmp	#0, r5
 5839 012b 21 3E                   		bne	.L405
4028:../src/wolfcrypt/src/ecc.c ****                                   WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
4029:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Gy, Gy, GySz,
 5840                             		.loc 2 4029 18
 5841 012d FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5842 0133 EC A5                   		mov.L	[r10], r5
 5843 0135 75 15 34                		mul	#52, r5
 5844 0138 4B 45                   		add	r4, r5
 5845 013a 71 55 20                		add	#32, r5
 5846 013d EC 55                   		mov.L	[r5], r5
 5847 013f 66 24                   		mov.L	#2, r4
 5848 0141 AA 63                   		mov.L	32[r6], r3
 5849 0143 A9 EA                   		mov.L	28[r6], r2
 5850 0145 EF 51                   		mov.L	r5, r1
 5851 0147 05 00 00 00             		bsr	_wc_ecc_cmp_param
 5852 014b EF 15                   		mov.L	r1, r5
4028:../src/wolfcrypt/src/ecc.c ****                                   WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
 5853                             		.loc 2 4028 67
 5854 014d 61 05                   		cmp	#0, r5
 5855 014f 21 1A                   		bne	.L405
4030:../src/wolfcrypt/src/ecc.c ****                                   WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
4031:../src/wolfcrypt/src/ecc.c ****                 (cofactor == ecc_sets[idx].cofactor)) {
 5856                             		.loc 2 4031 43
 5857 0151 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5858 0157 EC A5                   		mov.L	[r10], r5
 5859 0159 75 15 34                		mul	#52, r5
 5860 015c 4B 45                   		add	r4, r5
 5861 015e 71 55 30                		add	#48, r5
 5862 0161 EC 55                   		mov.L	[r5], r5
4030:../src/wolfcrypt/src/ecc.c ****                                   WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
 5863                             		.loc 2 4030 67
 5864 0163 AA 6C                   		mov.L	36[r6], r4
 5865 0165 47 54                   		cmp	r5, r4
 5866 0167 20 1E                   		beq	.L409
 5867                             		.balign 8,3,1
 5868                             	.L405:
4017:../src/wolfcrypt/src/ecc.c ****         if (curveSz == ecc_sets[idx].size) {
 5869                             		.loc 2 4017 47 discriminator 2
 5870 0169 EC A5                   		mov.L	[r10], r5
 5871 016b 62 15                   		add	#1, r5
 5872 016d E3 A5                   		mov.L	r5, [r10]
 5873                             	.L404:
4017:../src/wolfcrypt/src/ecc.c ****         if (curveSz == ecc_sets[idx].size) {
 5874                             		.loc 2 4017 32 discriminator 1
 5875 016f FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5876 0175 EC A5                   		mov.L	[r10], r5
 5877 0177 75 15 34                		mul	#52, r5
 5878 017a 4B 45                   		add	r4, r5
 5879 017c EC 55                   		mov.L	[r5], r5
4017:../src/wolfcrypt/src/ecc.c ****         if (curveSz == ecc_sets[idx].size) {
 5880                             		.loc 2 4017 5 discriminator 1
 5881 017e 61 05                   		cmp	#0, r5
 5882 0180 3B DD FE                		bne	.L407
 5883 0183 2E 03                   		bra	.L406
 5884                             	.L409:
4032:../src/wolfcrypt/src/ecc.c ****                     break;
 5885                             		.loc 2 4032 21
 5886 0185 03                      		nop
 5887                             	.L406:
4033:../src/wolfcrypt/src/ecc.c ****             }
4034:../src/wolfcrypt/src/ecc.c ****         }
4035:../src/wolfcrypt/src/ecc.c ****     }
4036:../src/wolfcrypt/src/ecc.c **** 
4037:../src/wolfcrypt/src/ecc.c ****     if (ecc_sets[idx].size == 0)
 5888                             		.loc 2 4037 22
 5889 0186 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5890 018c EC A5                   		mov.L	[r10], r5
 5891 018e 75 15 34                		mul	#52, r5
 5892 0191 4B 45                   		add	r4, r5
 5893 0193 EC 55                   		mov.L	[r5], r5
 5894                             		.loc 2 4037 8
 5895 0195 61 05                   		cmp	#0, r5
 5896 0197 1E                      		bne	.L408
4038:../src/wolfcrypt/src/ecc.c ****         return ECC_CURVE_INVALID;
 5897                             		.loc 2 4038 16
 5898 0198 FB 56 FF                		mov.L	#-1, r5
 5899 019b 2E 13                   		bra	.L402
 5900                             	.L408:
4039:../src/wolfcrypt/src/ecc.c **** 
4040:../src/wolfcrypt/src/ecc.c ****     return ecc_sets[idx].id;
 5901                             		.loc 2 4040 25
 5902 019d FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5903 01a3 EC A5                   		mov.L	[r10], r5
 5904 01a5 75 15 34                		mul	#52, r5
 5905 01a8 4B 45                   		add	r4, r5
 5906 01aa 62 45                   		add	#4, r5
 5907 01ac EC 55                   		mov.L	[r5], r5
 5908                             	.L402:
4041:../src/wolfcrypt/src/ecc.c **** }
 5909                             		.loc 2 4041 1
 5910 01ae EF 51                   		mov.L	r5, r1
 5911 01b0 71 00 40                		add	#0x40, r0
 5912 01b3 7E B6                   		pop	r6
 5913 01b5 7E BA                   		pop	r10
 5914 01b7 02                      		rts
 5915                             	.LFE79:
 5917                             		.section	.text.wc_ecc_get_curve_id_from_dp_params,"ax",@progbits
 5918                             		.global	_wc_ecc_get_curve_id_from_dp_params
 5920                             	_wc_ecc_get_curve_id_from_dp_params:
 5921                             	.LFB80:
4042:../src/wolfcrypt/src/ecc.c **** 
4043:../src/wolfcrypt/src/ecc.c **** /* Returns the curve id in ecc_sets[] that corresponds
4044:../src/wolfcrypt/src/ecc.c ****  * to a given domain parameters pointer.
4045:../src/wolfcrypt/src/ecc.c ****  *
4046:../src/wolfcrypt/src/ecc.c ****  * dp   domain parameters pointer
4047:../src/wolfcrypt/src/ecc.c ****  *
4048:../src/wolfcrypt/src/ecc.c ****  * return curve id, from ecc_sets[] on success, negative on error
4049:../src/wolfcrypt/src/ecc.c ****  */
4050:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_curve_id_from_dp_params(const ecc_set_type* dp)
4051:../src/wolfcrypt/src/ecc.c **** {
 5922                             		.loc 2 4051 1
 5923 0000 6E 6B                   		pushm	r6-r11
 5924                             	.LCFI94:
 5925 0002 71 0A F8                		add	#-8, r0, r10
 5926                             	.LCFI95:
 5927 0005 EF A0                   		mov.L	r10, r0
 5928 0007 E7 A1 01                		mov.L	r1, 4[r10]
4052:../src/wolfcrypt/src/ecc.c ****     int idx;
4053:../src/wolfcrypt/src/ecc.c **** 
4054:../src/wolfcrypt/src/ecc.c ****     if (dp == NULL
 5929                             		.loc 2 4054 8
 5930 000a ED A5 01                		mov.L	4[r10], r5
 5931 000d 61 05                   		cmp	#0, r5
 5932 000f 20 36                   		beq	.L411
4055:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_ECC_CURVE_STATIC
4056:../src/wolfcrypt/src/ecc.c ****          || dp->prime == NULL ||  dp->Af == NULL ||
 5933                             		.loc 2 4056 15
 5934 0011 ED A5 01                		mov.L	4[r10], r5
 5935 0014 A8 DD                   		mov.L	12[r5], r5
 5936                             		.loc 2 4056 10
 5937 0016 61 05                   		cmp	#0, r5
 5938 0018 20 2D                   		beq	.L411
 5939                             		.loc 2 4056 37 discriminator 1
 5940 001a ED A5 01                		mov.L	4[r10], r5
 5941 001d A9 55                   		mov.L	16[r5], r5
 5942                             		.loc 2 4056 31 discriminator 1
 5943 001f 61 05                   		cmp	#0, r5
 5944 0021 20 24                   		beq	.L411
4057:../src/wolfcrypt/src/ecc.c ****         dp->Bf == NULL || dp->order == NULL || dp->Gx == NULL || dp->Gy == NULL
 5945                             		.loc 2 4057 11 discriminator 2
 5946 0023 ED A5 01                		mov.L	4[r10], r5
 5947 0026 A9 5D                   		mov.L	20[r5], r5
4056:../src/wolfcrypt/src/ecc.c ****         dp->Bf == NULL || dp->order == NULL || dp->Gx == NULL || dp->Gy == NULL
 5948                             		.loc 2 4056 50 discriminator 2
 5949 0028 61 05                   		cmp	#0, r5
 5950 002a 20 1B                   		beq	.L411
 5951                             		.loc 2 4057 29
 5952 002c ED A5 01                		mov.L	4[r10], r5
 5953 002f A9 D5                   		mov.L	24[r5], r5
 5954                             		.loc 2 4057 24
 5955 0031 61 05                   		cmp	#0, r5
 5956 0033 20 12                   		beq	.L411
 5957                             		.loc 2 4057 50 discriminator 1
 5958 0035 ED A5 01                		mov.L	4[r10], r5
 5959 0038 A9 DD                   		mov.L	28[r5], r5
 5960                             		.loc 2 4057 45 discriminator 1
 5961 003a 61 05                   		cmp	#0, r5
 5962 003c 11                      		beq	.L411
 5963                             		.loc 2 4057 68 discriminator 2
 5964 003d ED A5 01                		mov.L	4[r10], r5
 5965 0040 AA 55                   		mov.L	32[r5], r5
 5966                             		.loc 2 4057 63 discriminator 2
 5967 0042 61 05                   		cmp	#0, r5
 5968 0044 18                      		bne	.L412
 5969                             		.balign 8,3,2
 5970                             	.L411:
4058:../src/wolfcrypt/src/ecc.c ****     #endif
4059:../src/wolfcrypt/src/ecc.c ****     ) {
4060:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 5971                             		.loc 2 4060 16
 5972 0045 FB 5A 53 FF             		mov.L	#-173, r5
 5973 0049 38 CF 01                		bra	.L413
 5974                             	.L412:
4061:../src/wolfcrypt/src/ecc.c ****     }
4062:../src/wolfcrypt/src/ecc.c **** 
4063:../src/wolfcrypt/src/ecc.c ****     for (idx = 0; ecc_sets[idx].size != 0; idx++) {
 5975                             		.loc 2 4063 14
 5976 004c F8 A6 00                		mov.L	#0, [r10]
 5977                             		.loc 2 4063 5
 5978 004f 38 8A 01                		bra	.L414
 5979                             	.L417:
4064:../src/wolfcrypt/src/ecc.c ****         if (dp->size == ecc_sets[idx].size) {
 5980                             		.loc 2 4064 15
 5981 0052 ED A5 01                		mov.L	4[r10], r5
 5982 0055 EC 54                   		mov.L	[r5], r4
 5983                             		.loc 2 4064 38
 5984 0057 FB 32 00 00 00 00       		mov.L	#_ecc_sets, r3
 5985 005d EC A5                   		mov.L	[r10], r5
 5986 005f 75 15 34                		mul	#52, r5
 5987 0062 4B 35                   		add	r3, r5
 5988 0064 EC 55                   		mov.L	[r5], r5
 5989                             		.loc 2 4064 12
 5990 0066 47 54                   		cmp	r5, r4
 5991 0068 3B 6B 01                		bne	.L415
4065:../src/wolfcrypt/src/ecc.c ****             if ((wc_ecc_cmp_param(ecc_sets[idx].prime, (const byte*)dp->prime,
 5992                             		.loc 2 4065 18
 5993 006b FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 5994 0071 EC A5                   		mov.L	[r10], r5
 5995 0073 75 15 34                		mul	#52, r5
 5996 0076 4B 45                   		add	r4, r5
 5997 0078 62 C5                   		add	#12, r5
 5998 007a EC 56                   		mov.L	[r5], r6
 5999                             		.loc 2 4065 71
 6000 007c ED A5 01                		mov.L	4[r10], r5
 6001 007f ED 5B 03                		mov.L	12[r5], r11
4066:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->prime), WC_TYPE_HEX_STR) == MP_EQ) &&
 6002                             		.loc 2 4066 29
 6003 0082 ED A5 01                		mov.L	4[r10], r5
 6004 0085 A8 DD                   		mov.L	12[r5], r5
 6005 0087 EF 51                   		mov.L	r5, r1
 6006 0089 05 00 00 00             		bsr	_strlen
 6007 008d EF 15                   		mov.L	r1, r5
4065:../src/wolfcrypt/src/ecc.c ****             if ((wc_ecc_cmp_param(ecc_sets[idx].prime, (const byte*)dp->prime,
 6008                             		.loc 2 4065 18
 6009 008f 66 14                   		mov.L	#1, r4
 6010 0091 EF 53                   		mov.L	r5, r3
 6011 0093 EF B2                   		mov.L	r11, r2
 6012 0095 EF 61                   		mov.L	r6, r1
 6013 0097 05 00 00 00             		bsr	_wc_ecc_cmp_param
 6014 009b EF 15                   		mov.L	r1, r5
4065:../src/wolfcrypt/src/ecc.c ****             if ((wc_ecc_cmp_param(ecc_sets[idx].prime, (const byte*)dp->prime,
 6015                             		.loc 2 4065 16
 6016 009d 61 05                   		cmp	#0, r5
 6017 009f 3B 34 01                		bne	.L415
4067:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Af, (const byte*)dp->Af,
 6018                             		.loc 2 4067 18
 6019 00a2 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6020 00a8 EC A5                   		mov.L	[r10], r5
 6021 00aa 75 15 34                		mul	#52, r5
 6022 00ad 4B 45                   		add	r4, r5
 6023 00af 71 55 10                		add	#16, r5
 6024 00b2 EC 56                   		mov.L	[r5], r6
 6025                             		.loc 2 4067 68
 6026 00b4 ED A5 01                		mov.L	4[r10], r5
 6027 00b7 ED 5B 04                		mov.L	16[r5], r11
4068:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->Af),WC_TYPE_HEX_STR) == MP_EQ) &&
 6028                             		.loc 2 4068 29
 6029 00ba ED A5 01                		mov.L	4[r10], r5
 6030 00bd A9 55                   		mov.L	16[r5], r5
 6031 00bf EF 51                   		mov.L	r5, r1
 6032 00c1 05 00 00 00             		bsr	_strlen
 6033 00c5 EF 15                   		mov.L	r1, r5
4067:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Af, (const byte*)dp->Af,
 6034                             		.loc 2 4067 18
 6035 00c7 66 14                   		mov.L	#1, r4
 6036 00c9 EF 53                   		mov.L	r5, r3
 6037 00cb EF B2                   		mov.L	r11, r2
 6038 00cd EF 61                   		mov.L	r6, r1
 6039 00cf 05 00 00 00             		bsr	_wc_ecc_cmp_param
 6040 00d3 EF 15                   		mov.L	r1, r5
4066:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->prime), WC_TYPE_HEX_STR) == MP_EQ) &&
 6041                             		.loc 2 4066 76
 6042 00d5 61 05                   		cmp	#0, r5
 6043 00d7 3B FC 00                		bne	.L415
4069:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Bf, (const byte*)dp->Bf,
 6044                             		.loc 2 4069 18
 6045 00da FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6046 00e0 EC A5                   		mov.L	[r10], r5
 6047 00e2 75 15 34                		mul	#52, r5
 6048 00e5 4B 45                   		add	r4, r5
 6049 00e7 71 55 14                		add	#20, r5
 6050 00ea EC 56                   		mov.L	[r5], r6
 6051                             		.loc 2 4069 68
 6052 00ec ED A5 01                		mov.L	4[r10], r5
 6053 00ef ED 5B 05                		mov.L	20[r5], r11
4070:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->Bf),WC_TYPE_HEX_STR) == MP_EQ) &&
 6054                             		.loc 2 4070 29
 6055 00f2 ED A5 01                		mov.L	4[r10], r5
 6056 00f5 A9 5D                   		mov.L	20[r5], r5
 6057 00f7 EF 51                   		mov.L	r5, r1
 6058 00f9 05 00 00 00             		bsr	_strlen
 6059 00fd EF 15                   		mov.L	r1, r5
4069:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Bf, (const byte*)dp->Bf,
 6060                             		.loc 2 4069 18
 6061 00ff 66 14                   		mov.L	#1, r4
 6062 0101 EF 53                   		mov.L	r5, r3
 6063 0103 EF B2                   		mov.L	r11, r2
 6064 0105 EF 61                   		mov.L	r6, r1
 6065 0107 05 00 00 00             		bsr	_wc_ecc_cmp_param
 6066 010b EF 15                   		mov.L	r1, r5
4068:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->Af),WC_TYPE_HEX_STR) == MP_EQ) &&
 6067                             		.loc 2 4068 72
 6068 010d 61 05                   		cmp	#0, r5
 6069 010f 3B C4 00                		bne	.L415
4071:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].order, (const byte*)dp->order,
 6070                             		.loc 2 4071 18
 6071 0112 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6072 0118 EC A5                   		mov.L	[r10], r5
 6073 011a 75 15 34                		mul	#52, r5
 6074 011d 4B 45                   		add	r4, r5
 6075 011f 71 55 18                		add	#24, r5
 6076 0122 EC 56                   		mov.L	[r5], r6
 6077                             		.loc 2 4071 71
 6078 0124 ED A5 01                		mov.L	4[r10], r5
 6079 0127 ED 5B 06                		mov.L	24[r5], r11
4072:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->order),WC_TYPE_HEX_STR) == MP_EQ) &&
 6080                             		.loc 2 4072 29
 6081 012a ED A5 01                		mov.L	4[r10], r5
 6082 012d A9 D5                   		mov.L	24[r5], r5
 6083 012f EF 51                   		mov.L	r5, r1
 6084 0131 05 00 00 00             		bsr	_strlen
 6085 0135 EF 15                   		mov.L	r1, r5
4071:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].order, (const byte*)dp->order,
 6086                             		.loc 2 4071 18
 6087 0137 66 14                   		mov.L	#1, r4
 6088 0139 EF 53                   		mov.L	r5, r3
 6089 013b EF B2                   		mov.L	r11, r2
 6090 013d EF 61                   		mov.L	r6, r1
 6091 013f 05 00 00 00             		bsr	_wc_ecc_cmp_param
 6092 0143 EF 15                   		mov.L	r1, r5
4070:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->Bf),WC_TYPE_HEX_STR) == MP_EQ) &&
 6093                             		.loc 2 4070 72
 6094 0145 61 05                   		cmp	#0, r5
 6095 0147 3B 8C 00                		bne	.L415
4073:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Gx, (const byte*)dp->Gx,
 6096                             		.loc 2 4073 18
 6097 014a FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6098 0150 EC A5                   		mov.L	[r10], r5
 6099 0152 75 15 34                		mul	#52, r5
 6100 0155 4B 45                   		add	r4, r5
 6101 0157 71 55 1C                		add	#28, r5
 6102 015a EC 56                   		mov.L	[r5], r6
 6103                             		.loc 2 4073 68
 6104 015c ED A5 01                		mov.L	4[r10], r5
 6105 015f ED 5B 07                		mov.L	28[r5], r11
4074:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->Gx),WC_TYPE_HEX_STR) == MP_EQ) &&
 6106                             		.loc 2 4074 29
 6107 0162 ED A5 01                		mov.L	4[r10], r5
 6108 0165 A9 DD                   		mov.L	28[r5], r5
 6109 0167 EF 51                   		mov.L	r5, r1
 6110 0169 05 00 00 00             		bsr	_strlen
 6111 016d EF 15                   		mov.L	r1, r5
4073:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Gx, (const byte*)dp->Gx,
 6112                             		.loc 2 4073 18
 6113 016f 66 14                   		mov.L	#1, r4
 6114 0171 EF 53                   		mov.L	r5, r3
 6115 0173 EF B2                   		mov.L	r11, r2
 6116 0175 EF 61                   		mov.L	r6, r1
 6117 0177 05 00 00 00             		bsr	_wc_ecc_cmp_param
 6118 017b EF 15                   		mov.L	r1, r5
4072:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->order),WC_TYPE_HEX_STR) == MP_EQ) &&
 6119                             		.loc 2 4072 75
 6120 017d 61 05                   		cmp	#0, r5
 6121 017f 21 54                   		bne	.L415
4075:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Gy, (const byte*)dp->Gy,
 6122                             		.loc 2 4075 18
 6123 0181 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6124 0187 EC A5                   		mov.L	[r10], r5
 6125 0189 75 15 34                		mul	#52, r5
 6126 018c 4B 45                   		add	r4, r5
 6127 018e 71 55 20                		add	#32, r5
 6128 0191 EC 56                   		mov.L	[r5], r6
 6129                             		.loc 2 4075 68
 6130 0193 ED A5 01                		mov.L	4[r10], r5
 6131 0196 ED 5B 08                		mov.L	32[r5], r11
4076:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->Gy),WC_TYPE_HEX_STR) == MP_EQ) &&
 6132                             		.loc 2 4076 29
 6133 0199 ED A5 01                		mov.L	4[r10], r5
 6134 019c AA 55                   		mov.L	32[r5], r5
 6135 019e EF 51                   		mov.L	r5, r1
 6136 01a0 05 00 00 00             		bsr	_strlen
 6137 01a4 EF 15                   		mov.L	r1, r5
4075:../src/wolfcrypt/src/ecc.c ****                 (wc_ecc_cmp_param(ecc_sets[idx].Gy, (const byte*)dp->Gy,
 6138                             		.loc 2 4075 18
 6139 01a6 66 14                   		mov.L	#1, r4
 6140 01a8 EF 53                   		mov.L	r5, r3
 6141 01aa EF B2                   		mov.L	r11, r2
 6142 01ac EF 61                   		mov.L	r6, r1
 6143 01ae 05 00 00 00             		bsr	_wc_ecc_cmp_param
 6144 01b2 EF 15                   		mov.L	r1, r5
4074:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->Gx),WC_TYPE_HEX_STR) == MP_EQ) &&
 6145                             		.loc 2 4074 72
 6146 01b4 61 05                   		cmp	#0, r5
 6147 01b6 21 1D                   		bne	.L415
4077:../src/wolfcrypt/src/ecc.c ****                 (dp->cofactor == ecc_sets[idx].cofactor)) {
 6148                             		.loc 2 4077 20
 6149 01b8 ED A5 01                		mov.L	4[r10], r5
 6150 01bb AB 54                   		mov.L	48[r5], r4
 6151                             		.loc 2 4077 47
 6152 01bd FB 32 00 00 00 00       		mov.L	#_ecc_sets, r3
 6153 01c3 EC A5                   		mov.L	[r10], r5
 6154 01c5 75 15 34                		mul	#52, r5
 6155 01c8 4B 35                   		add	r3, r5
 6156 01ca 71 55 30                		add	#48, r5
 6157 01cd EC 55                   		mov.L	[r5], r5
4076:../src/wolfcrypt/src/ecc.c ****                     (word32)XSTRLEN(dp->Gy),WC_TYPE_HEX_STR) == MP_EQ) &&
 6158                             		.loc 2 4076 72
 6159 01cf 47 54                   		cmp	r5, r4
 6160 01d1 20 1E                   		beq	.L419
 6161                             		.balign 8,3,1
 6162                             	.L415:
4063:../src/wolfcrypt/src/ecc.c ****         if (dp->size == ecc_sets[idx].size) {
 6163                             		.loc 2 4063 47 discriminator 2
 6164 01d3 EC A5                   		mov.L	[r10], r5
 6165 01d5 62 15                   		add	#1, r5
 6166 01d7 E3 A5                   		mov.L	r5, [r10]
 6167                             	.L414:
4063:../src/wolfcrypt/src/ecc.c ****         if (dp->size == ecc_sets[idx].size) {
 6168                             		.loc 2 4063 32 discriminator 1
 6169 01d9 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6170 01df EC A5                   		mov.L	[r10], r5
 6171 01e1 75 15 34                		mul	#52, r5
 6172 01e4 4B 45                   		add	r4, r5
 6173 01e6 EC 55                   		mov.L	[r5], r5
4063:../src/wolfcrypt/src/ecc.c ****         if (dp->size == ecc_sets[idx].size) {
 6174                             		.loc 2 4063 5 discriminator 1
 6175 01e8 61 05                   		cmp	#0, r5
 6176 01ea 3B 68 FE                		bne	.L417
 6177 01ed 2E 03                   		bra	.L416
 6178                             	.L419:
4078:../src/wolfcrypt/src/ecc.c ****                     break;
 6179                             		.loc 2 4078 21
 6180 01ef 03                      		nop
 6181                             	.L416:
4079:../src/wolfcrypt/src/ecc.c ****             }
4080:../src/wolfcrypt/src/ecc.c ****         }
4081:../src/wolfcrypt/src/ecc.c ****     }
4082:../src/wolfcrypt/src/ecc.c **** 
4083:../src/wolfcrypt/src/ecc.c ****     if (ecc_sets[idx].size == 0)
 6182                             		.loc 2 4083 22
 6183 01f0 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6184 01f6 EC A5                   		mov.L	[r10], r5
 6185 01f8 75 15 34                		mul	#52, r5
 6186 01fb 4B 45                   		add	r4, r5
 6187 01fd EC 55                   		mov.L	[r5], r5
 6188                             		.loc 2 4083 8
 6189 01ff 61 05                   		cmp	#0, r5
 6190 0201 1E                      		bne	.L418
4084:../src/wolfcrypt/src/ecc.c ****         return ECC_CURVE_INVALID;
 6191                             		.loc 2 4084 16
 6192 0202 FB 56 FF                		mov.L	#-1, r5
 6193 0205 2E 13                   		bra	.L413
 6194                             	.L418:
4085:../src/wolfcrypt/src/ecc.c **** 
4086:../src/wolfcrypt/src/ecc.c ****     return ecc_sets[idx].id;
 6195                             		.loc 2 4086 25
 6196 0207 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6197 020d EC A5                   		mov.L	[r10], r5
 6198 020f 75 15 34                		mul	#52, r5
 6199 0212 4B 45                   		add	r4, r5
 6200 0214 62 45                   		add	#4, r5
 6201 0216 EC 55                   		mov.L	[r5], r5
 6202                             	.L413:
4087:../src/wolfcrypt/src/ecc.c **** }
 6203                             		.loc 2 4087 1
 6204 0218 EF 51                   		mov.L	r5, r1
 6205 021a 3F 6B 08                		rtsd	#32, r6-r11
 6206                             	.LFE80:
 6208 021d FC 13 00                		.section	.text.wc_ecc_get_curve_id_from_oid,"ax",@progbits
 6209                             		.global	_wc_ecc_get_curve_id_from_oid
 6211                             	_wc_ecc_get_curve_id_from_oid:
 6212                             	.LFB81:
4088:../src/wolfcrypt/src/ecc.c **** 
4089:../src/wolfcrypt/src/ecc.c **** /* Returns the curve id that corresponds to a given OID,
4090:../src/wolfcrypt/src/ecc.c ****  * as listed in ecc_sets[] of ecc.c.
4091:../src/wolfcrypt/src/ecc.c ****  *
4092:../src/wolfcrypt/src/ecc.c ****  * oid   OID, from ecc_sets[].name in ecc.c
4093:../src/wolfcrypt/src/ecc.c ****  * len   OID len, from ecc_sets[].name in ecc.c
4094:../src/wolfcrypt/src/ecc.c ****  * return curve id, from ecc_sets[] on success, negative on error
4095:../src/wolfcrypt/src/ecc.c ****  */
4096:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_curve_id_from_oid(const byte* oid, word32 len)
4097:../src/wolfcrypt/src/ecc.c **** {
 6213                             		.loc 2 4097 1
 6214 0000 7E AA                   		push.l	r10
 6215                             	.LCFI96:
 6216 0002 71 0A F4                		add	#-12, r0, r10
 6217                             	.LCFI97:
 6218 0005 EF A0                   		mov.L	r10, r0
 6219 0007 E7 A1 01                		mov.L	r1, 4[r10]
 6220 000a E7 A2 02                		mov.L	r2, 8[r10]
4098:../src/wolfcrypt/src/ecc.c ****     int curve_idx;
4099:../src/wolfcrypt/src/ecc.c **** #if defined(HAVE_OID_DECODING) || defined(HAVE_OID_ENCODING)
4100:../src/wolfcrypt/src/ecc.c ****     int ret;
4101:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_OID_DECODING
4102:../src/wolfcrypt/src/ecc.c ****     word16 decOid[MAX_OID_SZ/sizeof(word16)];
4103:../src/wolfcrypt/src/ecc.c ****     #else
4104:../src/wolfcrypt/src/ecc.c ****     byte  decOid[MAX_OID_SZ];
4105:../src/wolfcrypt/src/ecc.c ****     #endif
4106:../src/wolfcrypt/src/ecc.c ****     word32 decOidSz;
4107:../src/wolfcrypt/src/ecc.c **** #endif
4108:../src/wolfcrypt/src/ecc.c **** 
4109:../src/wolfcrypt/src/ecc.c ****     if (oid == NULL)
 6221                             		.loc 2 4109 8
 6222 000d ED A5 01                		mov.L	4[r10], r5
 6223 0010 61 05                   		cmp	#0, r5
 6224 0012 18                      		bne	.L421
4110:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 6225                             		.loc 2 4110 16
 6226 0013 FB 5A 53 FF             		mov.L	#-173, r5
 6227 0017 38 AA 00                		bra	.L422
 6228                             	.L421:
4111:../src/wolfcrypt/src/ecc.c **** 
4112:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_OID_DECODING
4113:../src/wolfcrypt/src/ecc.c ****     decOidSz = (word32)sizeof(decOid);
4114:../src/wolfcrypt/src/ecc.c ****     ret = DecodeObjectId(oid, len, decOid, &decOidSz);
4115:../src/wolfcrypt/src/ecc.c ****     if (ret != 0) {
4116:../src/wolfcrypt/src/ecc.c ****         return ret;
4117:../src/wolfcrypt/src/ecc.c ****     }
4118:../src/wolfcrypt/src/ecc.c **** #endif
4119:../src/wolfcrypt/src/ecc.c **** 
4120:../src/wolfcrypt/src/ecc.c ****     for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 6229                             		.loc 2 4120 20
 6230 001a F8 A6 00                		mov.L	#0, [r10]
 6231                             		.loc 2 4120 5
 6232 001d 2E 5B                   		bra	.L423
 6233                             	.L426:
4121:../src/wolfcrypt/src/ecc.c ****     #if defined(HAVE_OID_ENCODING) && !defined(HAVE_OID_DECODING)
4122:../src/wolfcrypt/src/ecc.c ****         decOidSz = (word32)sizeof(decOid);
4123:../src/wolfcrypt/src/ecc.c ****         ret = EncodeObjectId(ecc_sets[curve_idx].oid, ecc_sets[curve_idx].oidSz,
4124:../src/wolfcrypt/src/ecc.c ****             decOid, &decOidSz);
4125:../src/wolfcrypt/src/ecc.c ****         if (ret != 0) {
4126:../src/wolfcrypt/src/ecc.c ****             continue;
4127:../src/wolfcrypt/src/ecc.c ****         }
4128:../src/wolfcrypt/src/ecc.c ****     #endif
4129:../src/wolfcrypt/src/ecc.c **** 
4130:../src/wolfcrypt/src/ecc.c ****         if (
4131:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
4132:../src/wolfcrypt/src/ecc.c ****             ecc_sets[curve_idx].oid &&
 6234                             		.loc 2 4132 32
 6235 001f FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6236 0025 EC A5                   		mov.L	[r10], r5
 6237 0027 75 15 34                		mul	#52, r5
 6238 002a 4B 45                   		add	r4, r5
 6239 002c 71 55 24                		add	#36, r5
 6240 002f EC 55                   		mov.L	[r5], r5
4130:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECC_CURVE_STATIC
 6241                             		.loc 2 4130 12
 6242 0031 61 05                   		cmp	#0, r5
 6243 0033 20 3F                   		beq	.L424
4133:../src/wolfcrypt/src/ecc.c ****         #endif
4134:../src/wolfcrypt/src/ecc.c ****         #if defined(HAVE_OID_ENCODING) && !defined(HAVE_OID_DECODING)
4135:../src/wolfcrypt/src/ecc.c ****             decOidSz == len &&
4136:../src/wolfcrypt/src/ecc.c ****                 XMEMCMP(decOid, oid, len) == 0
4137:../src/wolfcrypt/src/ecc.c ****         #elif defined(HAVE_OID_ENCODING) && defined(HAVE_OID_DECODING)
4138:../src/wolfcrypt/src/ecc.c ****             /* We double because decOidSz is a count of word16 elements. */
4139:../src/wolfcrypt/src/ecc.c ****             ecc_sets[curve_idx].oidSz == decOidSz &&
4140:../src/wolfcrypt/src/ecc.c ****                 XMEMCMP(ecc_sets[curve_idx].oid, decOid, decOidSz * 2) == 0
4141:../src/wolfcrypt/src/ecc.c ****         #else
4142:../src/wolfcrypt/src/ecc.c ****             ecc_sets[curve_idx].oidSz == len &&
 6244                             		.loc 2 4142 32
 6245 0035 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6246 003b EC A5                   		mov.L	[r10], r5
 6247 003d 75 15 34                		mul	#52, r5
 6248 0040 4B 45                   		add	r4, r5
 6249 0042 71 55 28                		add	#40, r5
 6250 0045 EC 55                   		mov.L	[r5], r5
4132:../src/wolfcrypt/src/ecc.c ****         #endif
 6251                             		.loc 2 4132 37
 6252 0047 ED A4 02                		mov.L	8[r10], r4
 6253 004a 47 54                   		cmp	r5, r4
 6254 004c 21 26                   		bne	.L424
4143:../src/wolfcrypt/src/ecc.c ****                 XMEMCMP(ecc_sets[curve_idx].oid, oid, len) == 0
 6255                             		.loc 2 4143 17
 6256 004e FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6257 0054 EC A5                   		mov.L	[r10], r5
 6258 0056 75 15 34                		mul	#52, r5
 6259 0059 4B 45                   		add	r4, r5
 6260 005b 71 55 24                		add	#36, r5
 6261 005e EC 55                   		mov.L	[r5], r5
 6262 0060 ED A3 02                		mov.L	8[r10], r3
 6263 0063 ED A2 01                		mov.L	4[r10], r2
 6264 0066 EF 51                   		mov.L	r5, r1
 6265 0068 05 00 00 00             		bsr	_memcmp
 6266 006c EF 15                   		mov.L	r1, r5
4142:../src/wolfcrypt/src/ecc.c ****                 XMEMCMP(ecc_sets[curve_idx].oid, oid, len) == 0
 6267                             		.loc 2 4142 46
 6268 006e 61 05                   		cmp	#0, r5
 6269 0070 20 1D                   		beq	.L428
 6270                             	.L424:
4120:../src/wolfcrypt/src/ecc.c ****     #if defined(HAVE_OID_ENCODING) && !defined(HAVE_OID_DECODING)
 6271                             		.loc 2 4120 65 discriminator 2
 6272 0072 EC A5                   		mov.L	[r10], r5
 6273 0074 62 15                   		add	#1, r5
 6274 0076 E3 A5                   		mov.L	r5, [r10]
 6275                             	.L423:
4120:../src/wolfcrypt/src/ecc.c ****     #if defined(HAVE_OID_ENCODING) && !defined(HAVE_OID_DECODING)
 6276                             		.loc 2 4120 44 discriminator 1
 6277 0078 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6278 007e EC A5                   		mov.L	[r10], r5
 6279 0080 75 15 34                		mul	#52, r5
 6280 0083 4B 45                   		add	r4, r5
 6281 0085 EC 55                   		mov.L	[r5], r5
4120:../src/wolfcrypt/src/ecc.c ****     #if defined(HAVE_OID_ENCODING) && !defined(HAVE_OID_DECODING)
 6282                             		.loc 2 4120 5 discriminator 1
 6283 0087 61 05                   		cmp	#0, r5
 6284 0089 21 96                   		bne	.L426
 6285 008b 2E 03                   		bra	.L425
 6286                             	.L428:
4144:../src/wolfcrypt/src/ecc.c ****         #endif
4145:../src/wolfcrypt/src/ecc.c ****         ) {
4146:../src/wolfcrypt/src/ecc.c ****             break;
 6287                             		.loc 2 4146 13
 6288 008d 03                      		nop
 6289                             	.L425:
4147:../src/wolfcrypt/src/ecc.c ****         }
4148:../src/wolfcrypt/src/ecc.c ****     }
4149:../src/wolfcrypt/src/ecc.c ****     if (ecc_sets[curve_idx].size == 0) {
 6290                             		.loc 2 4149 28
 6291 008e FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6292 0094 EC A5                   		mov.L	[r10], r5
 6293 0096 75 15 34                		mul	#52, r5
 6294 0099 4B 45                   		add	r4, r5
 6295 009b EC 55                   		mov.L	[r5], r5
 6296                             		.loc 2 4149 8
 6297 009d 61 05                   		cmp	#0, r5
 6298 009f 21 11                   		bne	.L427
4150:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("ecc_set curve name not found");
 6299                             		.loc 2 4150 9
 6300 00a1 FB 12 14 0A 00 00       		mov.L	#.LC37, r1
 6301 00a7 05 00 00 00             		bsr	_WOLFSSL_MSG
4151:../src/wolfcrypt/src/ecc.c ****         return ECC_CURVE_INVALID;
 6302                             		.loc 2 4151 16
 6303 00ab FB 56 FF                		mov.L	#-1, r5
 6304 00ae 2E 13                   		bra	.L422
 6305                             	.L427:
4152:../src/wolfcrypt/src/ecc.c ****     }
4153:../src/wolfcrypt/src/ecc.c **** 
4154:../src/wolfcrypt/src/ecc.c ****     return ecc_sets[curve_idx].id;
 6306                             		.loc 2 4154 31
 6307 00b0 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 6308 00b6 EC A5                   		mov.L	[r10], r5
 6309 00b8 75 15 34                		mul	#52, r5
 6310 00bb 4B 45                   		add	r4, r5
 6311 00bd 62 45                   		add	#4, r5
 6312 00bf EC 55                   		mov.L	[r5], r5
 6313                             	.L422:
4155:../src/wolfcrypt/src/ecc.c **** }
 6314                             		.loc 2 4155 1
 6315 00c1 EF 51                   		mov.L	r5, r1
 6316 00c3 3F AA 04                		rtsd	#16, r10-r10
 6317                             	.LFE81:
 6319                             		.section	.text.wc_ecc_get_curve_params,"ax",@progbits
 6320                             		.global	_wc_ecc_get_curve_params
 6322                             	_wc_ecc_get_curve_params:
 6323                             	.LFB82:
4156:../src/wolfcrypt/src/ecc.c **** 
4157:../src/wolfcrypt/src/ecc.c **** /* Get curve parameters using curve index */
4158:../src/wolfcrypt/src/ecc.c **** const ecc_set_type* wc_ecc_get_curve_params(int curve_idx)
4159:../src/wolfcrypt/src/ecc.c **** {
 6324                             		.loc 2 4159 1
 6325 0000 7E AA                   		push.l	r10
 6326                             	.LCFI98:
 6327 0002 71 0A F8                		add	#-8, r0, r10
 6328                             	.LCFI99:
 6329 0005 EF A0                   		mov.L	r10, r0
 6330 0007 E7 A1 01                		mov.L	r1, 4[r10]
4160:../src/wolfcrypt/src/ecc.c ****     const ecc_set_type* ecc_set = NULL;
 6331                             		.loc 2 4160 25
 6332 000a F8 A6 00                		mov.L	#0, [r10]
4161:../src/wolfcrypt/src/ecc.c **** 
4162:../src/wolfcrypt/src/ecc.c ****     if (curve_idx >= 0 && curve_idx < (int)ECC_SET_COUNT) {
 6333                             		.loc 2 4162 8
 6334 000d ED A5 01                		mov.L	4[r10], r5
 6335 0010 61 05                   		cmp	#0, r5
 6336 0012 29 17                   		blt	.L430
 6337                             		.loc 2 4162 24 discriminator 1
 6338 0014 ED A5 01                		mov.L	4[r10], r5
 6339 0017 61 55                   		cmp	#5, r5
 6340 0019 2A 10                   		bgt	.L430
4163:../src/wolfcrypt/src/ecc.c ****         ecc_set = &ecc_sets[curve_idx];
 6341                             		.loc 2 4163 17
 6342 001b ED A5 01                		mov.L	4[r10], r5
 6343 001e 75 15 34                		mul	#52, r5
 6344 0021 70 55 00 00 00 00       		add	#_ecc_sets, r5
 6345 0027 E3 A5                   		mov.L	r5, [r10]
 6346                             	.L430:
4164:../src/wolfcrypt/src/ecc.c ****     }
4165:../src/wolfcrypt/src/ecc.c ****     return ecc_set;
 6347                             		.loc 2 4165 12
 6348 0029 EC A5                   		mov.L	[r10], r5
4166:../src/wolfcrypt/src/ecc.c **** }
 6349                             		.loc 2 4166 1
 6350 002b EF 51                   		mov.L	r5, r1
 6351 002d 3F AA 03                		rtsd	#12, r10-r10
 6352                             	.LFE82:
 6354                             		.section	.text.wc_ecc_shared_secret,"ax",@progbits
 6355                             		.global	_wc_ecc_shared_secret
 6357                             	_wc_ecc_shared_secret:
 6358                             	.LFB83:
4167:../src/wolfcrypt/src/ecc.c **** 
4168:../src/wolfcrypt/src/ecc.c **** 
4169:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
4170:../src/wolfcrypt/src/ecc.c **** static WC_INLINE int wc_ecc_alloc_mpint(ecc_key* key, mp_int** mp)
4171:../src/wolfcrypt/src/ecc.c **** {
4172:../src/wolfcrypt/src/ecc.c ****    if (key == NULL || mp == NULL)
4173:../src/wolfcrypt/src/ecc.c ****       return BAD_FUNC_ARG;
4174:../src/wolfcrypt/src/ecc.c ****    if (*mp == NULL) {
4175:../src/wolfcrypt/src/ecc.c ****       *mp = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_BIGINT);
4176:../src/wolfcrypt/src/ecc.c ****       if (*mp == NULL) {
4177:../src/wolfcrypt/src/ecc.c ****          return MEMORY_E;
4178:../src/wolfcrypt/src/ecc.c ****       }
4179:../src/wolfcrypt/src/ecc.c ****       XMEMSET(*mp, 0, sizeof(mp_int));
4180:../src/wolfcrypt/src/ecc.c ****    }
4181:../src/wolfcrypt/src/ecc.c ****    return 0;
4182:../src/wolfcrypt/src/ecc.c **** }
4183:../src/wolfcrypt/src/ecc.c **** static WC_INLINE void wc_ecc_free_mpint(ecc_key* key, mp_int** mp)
4184:../src/wolfcrypt/src/ecc.c **** {
4185:../src/wolfcrypt/src/ecc.c ****    if (key && mp && *mp) {
4186:../src/wolfcrypt/src/ecc.c ****       mp_clear(*mp);
4187:../src/wolfcrypt/src/ecc.c ****       XFREE(*mp, key->heap, DYNAMIC_TYPE_BIGINT);
4188:../src/wolfcrypt/src/ecc.c ****       *mp = NULL;
4189:../src/wolfcrypt/src/ecc.c ****    }
4190:../src/wolfcrypt/src/ecc.c **** }
4191:../src/wolfcrypt/src/ecc.c **** 
4192:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_alloc_async(ecc_key* key)
4193:../src/wolfcrypt/src/ecc.c **** {
4194:../src/wolfcrypt/src/ecc.c ****     int err = wc_ecc_alloc_mpint(key, &key->r);
4195:../src/wolfcrypt/src/ecc.c ****     if (err == 0)
4196:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_alloc_mpint(key, &key->s);
4197:../src/wolfcrypt/src/ecc.c ****     return err;
4198:../src/wolfcrypt/src/ecc.c **** }
4199:../src/wolfcrypt/src/ecc.c **** 
4200:../src/wolfcrypt/src/ecc.c **** static void wc_ecc_free_async(ecc_key* key)
4201:../src/wolfcrypt/src/ecc.c **** {
4202:../src/wolfcrypt/src/ecc.c ****     wc_ecc_free_mpint(key, &key->r);
4203:../src/wolfcrypt/src/ecc.c ****     wc_ecc_free_mpint(key, &key->s);
4204:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_CAVIUM_V
4205:../src/wolfcrypt/src/ecc.c ****     wc_ecc_free_mpint(key, &key->e);
4206:../src/wolfcrypt/src/ecc.c ****     wc_ecc_free_mpint(key, &key->signK);
4207:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_CAVIUM_V */
4208:../src/wolfcrypt/src/ecc.c **** }
4209:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */
4210:../src/wolfcrypt/src/ecc.c **** 
4211:../src/wolfcrypt/src/ecc.c **** 
4212:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_DHE
4213:../src/wolfcrypt/src/ecc.c **** /**
4214:../src/wolfcrypt/src/ecc.c ****   Create an ECC shared secret between two keys
4215:../src/wolfcrypt/src/ecc.c ****   private_key      The private ECC key (heap hint based off of private key)
4216:../src/wolfcrypt/src/ecc.c ****   public_key       The public key
4217:../src/wolfcrypt/src/ecc.c ****   out              [out] Destination of the shared secret
4218:../src/wolfcrypt/src/ecc.c ****                          Conforms to EC-DH from ANSI X9.63
4219:../src/wolfcrypt/src/ecc.c ****   outlen           [in/out] The max size and resulting size of the shared secret
4220:../src/wolfcrypt/src/ecc.c ****   return           MP_OKAY if successful
4221:../src/wolfcrypt/src/ecc.c **** */
4222:../src/wolfcrypt/src/ecc.c **** int wc_ecc_shared_secret(ecc_key* private_key, ecc_key* public_key, byte* out,
4223:../src/wolfcrypt/src/ecc.c ****                       word32* outlen)
4224:../src/wolfcrypt/src/ecc.c **** {
 6359                             		.loc 2 4224 1
 6360 0000 7E AA                   		push.l	r10
 6361                             	.LCFI100:
 6362 0002 71 0A EC                		add	#-20, r0, r10
 6363                             	.LCFI101:
 6364 0005 EF A0                   		mov.L	r10, r0
 6365 0007 E7 A1 01                		mov.L	r1, 4[r10]
 6366 000a E7 A2 02                		mov.L	r2, 8[r10]
 6367 000d E7 A3 03                		mov.L	r3, 12[r10]
 6368 0010 E7 A4 04                		mov.L	r4, 16[r10]
4225:../src/wolfcrypt/src/ecc.c ****    int err;
4226:../src/wolfcrypt/src/ecc.c **** 
4227:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_ATECC508A) && \
4228:../src/wolfcrypt/src/ecc.c ****    !defined(WOLFSSL_ATECC608A)
4229:../src/wolfcrypt/src/ecc.c ****    CRYS_ECDH_TempData_t tempBuff;
4230:../src/wolfcrypt/src/ecc.c **** #endif
4231:../src/wolfcrypt/src/ecc.c **** 
4232:../src/wolfcrypt/src/ecc.c ****    (void)err;
4233:../src/wolfcrypt/src/ecc.c **** 
4234:../src/wolfcrypt/src/ecc.c ****    if (private_key == NULL || public_key == NULL || out == NULL ||
 6369                             		.loc 2 4234 7
 6370 0013 ED A5 01                		mov.L	4[r10], r5
 6371 0016 61 05                   		cmp	#0, r5
 6372 0018 20 15                   		beq	.L433
 6373                             		.loc 2 4234 28 discriminator 1
 6374 001a ED A5 02                		mov.L	8[r10], r5
 6375 001d 61 05                   		cmp	#0, r5
 6376 001f 20 0E                   		beq	.L433
 6377                             		.loc 2 4234 50 discriminator 2
 6378 0021 ED A5 03                		mov.L	12[r10], r5
 6379 0024 61 05                   		cmp	#0, r5
 6380 0026 17                      		beq	.L433
 6381                             		.loc 2 4234 65 discriminator 3
 6382 0027 ED A5 04                		mov.L	16[r10], r5
 6383 002a 61 05                   		cmp	#0, r5
 6384 002c 18                      		bne	.L434
 6385                             		.balign 8,3,2
 6386                             	.L433:
4235:../src/wolfcrypt/src/ecc.c ****                                                             outlen == NULL) {
4236:../src/wolfcrypt/src/ecc.c ****        return BAD_FUNC_ARG;
 6387                             		.loc 2 4236 15
 6388 002d FB 5A 53 FF             		mov.L	#-173, r5
 6389 0031 38 85 00                		bra	.L435
 6390                             	.L434:
4237:../src/wolfcrypt/src/ecc.c ****    }
4238:../src/wolfcrypt/src/ecc.c **** 
4239:../src/wolfcrypt/src/ecc.c **** #ifdef WOLF_CRYPTO_CB
4240:../src/wolfcrypt/src/ecc.c ****     if (private_key->devId != INVALID_DEVID) {
4241:../src/wolfcrypt/src/ecc.c ****         err = wc_CryptoCb_Ecdh(private_key, public_key, out, outlen);
4242:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLF_CRYPTO_CB_ONLY_ECC
4243:../src/wolfcrypt/src/ecc.c ****         if (err != CRYPTOCB_UNAVAILABLE)
4244:../src/wolfcrypt/src/ecc.c ****             return err;
4245:../src/wolfcrypt/src/ecc.c ****         /* fall-through when unavailable */
4246:../src/wolfcrypt/src/ecc.c ****     #endif
4247:../src/wolfcrypt/src/ecc.c ****     }
4248:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLF_CRYPTO_CB_ONLY_ECC
4249:../src/wolfcrypt/src/ecc.c ****     else {
4250:../src/wolfcrypt/src/ecc.c ****         err = NO_VALID_DEVID;
4251:../src/wolfcrypt/src/ecc.c ****     }
4252:../src/wolfcrypt/src/ecc.c ****     #endif
4253:../src/wolfcrypt/src/ecc.c **** #endif
4254:../src/wolfcrypt/src/ecc.c **** 
4255:../src/wolfcrypt/src/ecc.c **** #ifndef WOLF_CRYPTO_CB_ONLY_ECC
4256:../src/wolfcrypt/src/ecc.c ****    /* type valid? */
4257:../src/wolfcrypt/src/ecc.c ****    if (private_key->type != ECC_PRIVATEKEY &&
 6391                             		.loc 2 4257 19
 6392 0034 ED A5 01                		mov.L	4[r10], r5
 6393 0037 EC 55                   		mov.L	[r5], r5
 6394                             		.loc 2 4257 7
 6395 0039 61 25                   		cmp	#2, r5
 6396 003b 20 10                   		beq	.L436
4258:../src/wolfcrypt/src/ecc.c ****            private_key->type != ECC_PRIVATEKEY_ONLY) {
 6397                             		.loc 2 4258 23 discriminator 1
 6398 003d ED A5 01                		mov.L	4[r10], r5
 6399 0040 EC 55                   		mov.L	[r5], r5
4257:../src/wolfcrypt/src/ecc.c ****            private_key->type != ECC_PRIVATEKEY_ONLY) {
 6400                             		.loc 2 4257 44 discriminator 1
 6401 0042 61 35                   		cmp	#3, r5
 6402 0044 17                      		beq	.L436
4259:../src/wolfcrypt/src/ecc.c ****       return ECC_BAD_ARG_E;
 6403                             		.loc 2 4259 14
 6404 0045 FB 5A 56 FF             		mov.L	#-170, r5
 6405 0049 2E 6D                   		bra	.L435
 6406                             	.L436:
4260:../src/wolfcrypt/src/ecc.c ****    }
4261:../src/wolfcrypt/src/ecc.c **** 
4262:../src/wolfcrypt/src/ecc.c ****    /* Verify domain params supplied */
4263:../src/wolfcrypt/src/ecc.c ****    if (wc_ecc_is_valid_idx(private_key->idx) == 0 || private_key->dp == NULL ||
 6407                             		.loc 2 4263 8
 6408 004b ED A5 01                		mov.L	4[r10], r5
 6409 004e A8 5D                   		mov.L	4[r5], r5
 6410 0050 EF 51                   		mov.L	r5, r1
 6411 0052 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 6412 0056 EF 15                   		mov.L	r1, r5
 6413                             		.loc 2 4263 7
 6414 0058 61 05                   		cmp	#0, r5
 6415 005a 20 26                   		beq	.L437
 6416                             		.loc 2 4263 65 discriminator 1
 6417 005c ED A5 01                		mov.L	4[r10], r5
 6418 005f A9 55                   		mov.L	16[r5], r5
 6419                             		.loc 2 4263 51 discriminator 1
 6420 0061 61 05                   		cmp	#0, r5
 6421 0063 20 1D                   		beq	.L437
4264:../src/wolfcrypt/src/ecc.c ****        wc_ecc_is_valid_idx(public_key->idx)  == 0 || public_key->dp == NULL) {
 6422                             		.loc 2 4264 8 discriminator 2
 6423 0065 ED A5 02                		mov.L	8[r10], r5
 6424 0068 A8 5D                   		mov.L	4[r5], r5
 6425 006a EF 51                   		mov.L	r5, r1
 6426 006c 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 6427 0070 EF 15                   		mov.L	r1, r5
4263:../src/wolfcrypt/src/ecc.c ****        wc_ecc_is_valid_idx(public_key->idx)  == 0 || public_key->dp == NULL) {
 6428                             		.loc 2 4263 78 discriminator 2
 6429 0072 61 05                   		cmp	#0, r5
 6430 0074 20 0C                   		beq	.L437
 6431                             		.loc 2 4264 64
 6432 0076 ED A5 02                		mov.L	8[r10], r5
 6433 0079 A9 55                   		mov.L	16[r5], r5
 6434                             		.loc 2 4264 51
 6435 007b 61 05                   		cmp	#0, r5
 6436 007d 19                      		bne	.L438
 6437 007e EF 00                   		.balign 8,3,2
 6438                             	.L437:
4265:../src/wolfcrypt/src/ecc.c ****       return ECC_BAD_ARG_E;
 6439                             		.loc 2 4265 14
 6440 0080 FB 5A 56 FF             		mov.L	#-170, r5
 6441 0084 2E 32                   		bra	.L435
 6442                             	.L438:
4266:../src/wolfcrypt/src/ecc.c ****    }
4267:../src/wolfcrypt/src/ecc.c **** 
4268:../src/wolfcrypt/src/ecc.c ****    /* Verify curve id matches */
4269:../src/wolfcrypt/src/ecc.c ****    if (private_key->dp->id != public_key->dp->id) {
 6443                             		.loc 2 4269 19
 6444 0086 ED A5 01                		mov.L	4[r10], r5
 6445 0089 A9 55                   		mov.L	16[r5], r5
 6446                             		.loc 2 4269 23
 6447 008b A8 5C                   		mov.L	4[r5], r4
 6448                             		.loc 2 4269 41
 6449 008d ED A5 02                		mov.L	8[r10], r5
 6450 0090 A9 55                   		mov.L	16[r5], r5
 6451                             		.loc 2 4269 45
 6452 0092 A8 5D                   		mov.L	4[r5], r5
 6453                             		.loc 2 4269 7
 6454 0094 47 54                   		cmp	r5, r4
 6455 0096 17                      		beq	.L439
4270:../src/wolfcrypt/src/ecc.c ****       return ECC_BAD_ARG_E;
 6456                             		.loc 2 4270 14
 6457 0097 FB 5A 56 FF             		mov.L	#-170, r5
 6458 009b 2E 1B                   		bra	.L435
 6459                             	.L439:
4271:../src/wolfcrypt/src/ecc.c ****    }
4272:../src/wolfcrypt/src/ecc.c **** 
4273:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
4274:../src/wolfcrypt/src/ecc.c ****    /* For SECP256R1 use hardware */
4275:../src/wolfcrypt/src/ecc.c ****    if (private_key->dp->id == ECC_SECP256R1) {
4276:../src/wolfcrypt/src/ecc.c ****        err = atmel_ecc_create_pms(private_key->slot, public_key->pubkey_raw, out);
4277:../src/wolfcrypt/src/ecc.c ****        *outlen = private_key->dp->size;
4278:../src/wolfcrypt/src/ecc.c ****    }
4279:../src/wolfcrypt/src/ecc.c ****    else {
4280:../src/wolfcrypt/src/ecc.c ****       err = NOT_COMPILED_IN;
4281:../src/wolfcrypt/src/ecc.c ****    }
4282:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CRYPTOCELL)
4283:../src/wolfcrypt/src/ecc.c **** 
4284:../src/wolfcrypt/src/ecc.c ****     /* generate a secret*/
4285:../src/wolfcrypt/src/ecc.c ****     err = CRYS_ECDH_SVDP_DH(&public_key->ctx.pubKey,
4286:../src/wolfcrypt/src/ecc.c ****                             &private_key->ctx.privKey,
4287:../src/wolfcrypt/src/ecc.c ****                             out,
4288:../src/wolfcrypt/src/ecc.c ****                             (uint32_t*)outlen,
4289:../src/wolfcrypt/src/ecc.c ****                             &tempBuff);
4290:../src/wolfcrypt/src/ecc.c **** 
4291:../src/wolfcrypt/src/ecc.c ****     if (err != SA_SILIB_RET_OK){
4292:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("CRYS_ECDH_SVDP_DH for secret failed");
4293:../src/wolfcrypt/src/ecc.c ****         return err;
4294:../src/wolfcrypt/src/ecc.c ****     }
4295:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
4296:../src/wolfcrypt/src/ecc.c ****    err = silabs_ecc_shared_secret(private_key, public_key, out, outlen);
4297:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_KCAPI_ECC)
4298:../src/wolfcrypt/src/ecc.c ****    err = KcapiEcc_SharedSecret(private_key, public_key, out, outlen);
4299:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SE050)
4300:../src/wolfcrypt/src/ecc.c ****    err = se050_ecc_shared_secret(private_key, public_key, out, outlen);
4301:../src/wolfcrypt/src/ecc.c **** #else
4302:../src/wolfcrypt/src/ecc.c ****    err = wc_ecc_shared_secret_ex(private_key, &public_key->pubkey, out, outlen);
 6460                             		.loc 2 4302 10
 6461 009d ED A5 02                		mov.L	8[r10], r5
 6462 00a0 71 55 18                		add	#24, r5
 6463 00a3 ED A4 04                		mov.L	16[r10], r4
 6464 00a6 ED A3 03                		mov.L	12[r10], r3
 6465 00a9 EF 52                   		mov.L	r5, r2
 6466 00ab ED A1 01                		mov.L	4[r10], r1
 6467 00ae 05 00 00 00             		bsr	_wc_ecc_shared_secret_ex
 6468 00b2 E3 A1                   		mov.L	r1, [r10]
4303:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ATECC508A */
4304:../src/wolfcrypt/src/ecc.c **** #endif /* WOLF_CRYPTO_CB_ONLY_ECC */
4305:../src/wolfcrypt/src/ecc.c **** 
4306:../src/wolfcrypt/src/ecc.c ****    return err;
 6469                             		.loc 2 4306 11
 6470 00b4 EC A5                   		mov.L	[r10], r5
 6471                             		.balign 8,3,1
 6472                             	.L435:
4307:../src/wolfcrypt/src/ecc.c **** }
 6473                             		.loc 2 4307 1
 6474 00b6 EF 51                   		mov.L	r5, r1
 6475 00b8 3F AA 06                		rtsd	#24, r10-r10
 6476                             	.LFE83:
 6478 00bb 77 10 01 00 00          		.section	.text.wc_ecc_shared_secret_gen_sync,"ax",@progbits
 6480                             	_wc_ecc_shared_secret_gen_sync:
 6481                             	.LFB84:
4308:../src/wolfcrypt/src/ecc.c **** 
4309:../src/wolfcrypt/src/ecc.c **** 
4310:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
4311:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_KCAPI_ECC) && \
4312:../src/wolfcrypt/src/ecc.c ****     !defined(WOLF_CRYPTO_CB_ONLY_ECC)
4313:../src/wolfcrypt/src/ecc.c **** 
4314:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_shared_secret_gen_sync(ecc_key* private_key, ecc_point* point,
4315:../src/wolfcrypt/src/ecc.c ****                                byte* out, word32* outlen)
4316:../src/wolfcrypt/src/ecc.c **** {
 6482                             		.loc 2 4316 1
 6483 0000 7E AA                   		push.l	r10
 6484                             	.LCFI102:
 6485 0002 7E A6                   		push.l	r6
 6486                             	.LCFI103:
 6487 0004 71 0A A0                		add	#-96, r0, r10
 6488                             	.LCFI104:
 6489 0007 71 A0 EC                		add	#-20, r10, r0
 6490                             	.LCFI105:
 6491 000a E7 A1 14                		mov.L	r1, 80[r10]
 6492 000d E7 A2 15                		mov.L	r2, 84[r10]
 6493 0010 E7 A3 16                		mov.L	r3, 88[r10]
 6494 0013 E7 A4 17                		mov.L	r4, 92[r10]
4317:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 6495                             		.loc 2 4317 9
 6496 0016 F8 A6 00                		mov.L	#0, [r10]
4318:../src/wolfcrypt/src/ecc.c ****     mp_int* k = &private_key->k;
 6497                             		.loc 2 4318 13
 6498 0019 ED A5 14                		mov.L	80[r10], r5
 6499 001c 72 55 48 09             		add	#0x948, r5
 6500 0020 E7 A5 02                		mov.L	r5, 8[r10]
 6501                             	.LBB34:
4319:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_CDH
4320:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
4321:../src/wolfcrypt/src/ecc.c ****     mp_int *k_lcl = NULL;
4322:../src/wolfcrypt/src/ecc.c **** #else
4323:../src/wolfcrypt/src/ecc.c ****     mp_int k_lcl[1];
4324:../src/wolfcrypt/src/ecc.c **** #endif
4325:../src/wolfcrypt/src/ecc.c **** #endif
4326:../src/wolfcrypt/src/ecc.c **** 
4327:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_CDH
4328:../src/wolfcrypt/src/ecc.c ****     /* if cofactor flag has been set */
4329:../src/wolfcrypt/src/ecc.c ****     if (private_key->flags & WC_ECC_FLAG_COFACTOR) {
4330:../src/wolfcrypt/src/ecc.c ****         mp_digit cofactor = (mp_digit)private_key->dp->cofactor;
4331:../src/wolfcrypt/src/ecc.c ****         /* only perform cofactor calc if not equal to 1 */
4332:../src/wolfcrypt/src/ecc.c ****         if (cofactor != 1) {
4333:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
4334:../src/wolfcrypt/src/ecc.c ****             if ((k_lcl = (mp_int *)XMALLOC(sizeof(*k_lcl), private_key->heap, DYNAMIC_TYPE_ECC_BUFF
4335:../src/wolfcrypt/src/ecc.c ****                 return MEMORY_E;
4336:../src/wolfcrypt/src/ecc.c **** #endif
4337:../src/wolfcrypt/src/ecc.c ****             k = k_lcl;
4338:../src/wolfcrypt/src/ecc.c ****             if (mp_init(k) != MP_OKAY) {
4339:../src/wolfcrypt/src/ecc.c ****                 err = MEMORY_E;
4340:../src/wolfcrypt/src/ecc.c ****                 goto errout;
4341:../src/wolfcrypt/src/ecc.c ****             }
4342:../src/wolfcrypt/src/ecc.c ****             /* multiply cofactor times private key "k" */
4343:../src/wolfcrypt/src/ecc.c ****             err = mp_mul_d(&private_key->k, cofactor, k);
4344:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY)
4345:../src/wolfcrypt/src/ecc.c ****                 goto errout;
4346:../src/wolfcrypt/src/ecc.c ****         }
4347:../src/wolfcrypt/src/ecc.c ****     }
4348:../src/wolfcrypt/src/ecc.c **** #endif
4349:../src/wolfcrypt/src/ecc.c **** 
4350:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
4351:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
4352:../src/wolfcrypt/src/ecc.c ****     if (private_key->idx != ECC_CUSTOM_IDX &&
4353:../src/wolfcrypt/src/ecc.c ****                                ecc_sets[private_key->idx].id == ECC_SECP256R1) {
4354:../src/wolfcrypt/src/ecc.c ****         err = sp_ecc_secret_gen_256(k, point, out, outlen, private_key->heap);
4355:../src/wolfcrypt/src/ecc.c ****     }
4356:../src/wolfcrypt/src/ecc.c ****     else
4357:../src/wolfcrypt/src/ecc.c **** #endif
4358:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
4359:../src/wolfcrypt/src/ecc.c ****     if (private_key->idx != ECC_CUSTOM_IDX &&
4360:../src/wolfcrypt/src/ecc.c ****                                ecc_sets[private_key->idx].id == ECC_SECP384R1) {
4361:../src/wolfcrypt/src/ecc.c ****         err = sp_ecc_secret_gen_384(k, point, out, outlen, private_key->heap);
4362:../src/wolfcrypt/src/ecc.c ****     }
4363:../src/wolfcrypt/src/ecc.c ****     else
4364:../src/wolfcrypt/src/ecc.c **** #endif
4365:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
4366:../src/wolfcrypt/src/ecc.c ****     if (private_key->idx != ECC_CUSTOM_IDX &&
4367:../src/wolfcrypt/src/ecc.c ****                                ecc_sets[private_key->idx].id == ECC_SECP521R1) {
4368:../src/wolfcrypt/src/ecc.c ****         err = sp_ecc_secret_gen_521(k, point, out, outlen, private_key->heap);
4369:../src/wolfcrypt/src/ecc.c ****     }
4370:../src/wolfcrypt/src/ecc.c ****     else
4371:../src/wolfcrypt/src/ecc.c **** #endif
4372:../src/wolfcrypt/src/ecc.c **** #else
4373:../src/wolfcrypt/src/ecc.c ****     (void)point;
4374:../src/wolfcrypt/src/ecc.c ****     (void)out;
4375:../src/wolfcrypt/src/ecc.c ****     (void)outlen;
4376:../src/wolfcrypt/src/ecc.c ****     (void)k;
4377:../src/wolfcrypt/src/ecc.c **** #endif
4378:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_SP_MATH)
4379:../src/wolfcrypt/src/ecc.c ****     {
4380:../src/wolfcrypt/src/ecc.c ****         err = WC_KEY_SIZE_E;
4381:../src/wolfcrypt/src/ecc.c ****         goto errout;
4382:../src/wolfcrypt/src/ecc.c ****     }
4383:../src/wolfcrypt/src/ecc.c **** #else
4384:../src/wolfcrypt/src/ecc.c ****     {
4385:../src/wolfcrypt/src/ecc.c ****         ecc_point* result = NULL;
 6502                             		.loc 2 4385 20
 6503 0023 F9 A6 07 00             		mov.L	#0, 28[r10]
4386:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_NO_MALLOC
4387:../src/wolfcrypt/src/ecc.c ****         ecc_point  lcl_result;
4388:../src/wolfcrypt/src/ecc.c ****         #endif
4389:../src/wolfcrypt/src/ecc.c ****         word32 x = 0;
 6504                             		.loc 2 4389 16
 6505 0027 F9 A6 01 00             		mov.L	#0, 4[r10]
4390:../src/wolfcrypt/src/ecc.c ****         mp_digit mp = 0;
 6506                             		.loc 2 4390 18
 6507 002b F9 A6 08 00             		mov.L	#0, 32[r10]
4391:../src/wolfcrypt/src/ecc.c ****         DECLARE_CURVE_SPECS(3);
 6508                             		.loc 2 4391 9
 6509 002f F9 A6 03 00             		mov.L	#0, 12[r10]
 6510 0033 71 A5 28                		add	#40, r10, r5
 6511 0036 E7 A5 09                		mov.L	r5, 36[r10]
 6512 0039 ED A5 09                		mov.L	36[r10], r5
 6513 003c 75 43 28                		mov.L	#40, r3
 6514 003f 66 02                   		mov.L	#0, r2
 6515 0041 EF 51                   		mov.L	r5, r1
 6516 0043 05 00 00 00             		bsr	_memset
 6517 0047 ED A5 09                		mov.L	36[r10], r5
 6518 004a 3E 57 03                		mov.L	#3, 28[r5]
4392:../src/wolfcrypt/src/ecc.c **** 
4393:../src/wolfcrypt/src/ecc.c ****         /* load curve info */
4394:../src/wolfcrypt/src/ecc.c ****         ALLOC_CURVE_SPECS(3, err);
 6519                             		.loc 2 4394 9
 6520 004d FB 1A 30 09             		mov.L	#0x930, r1
 6521 0051 05 00 00 00             		bsr	_wolfSSL_Malloc
 6522 0055 E7 A1 03                		mov.L	r1, 12[r10]
 6523 0058 ED A5 03                		mov.L	12[r10], r5
 6524 005b 61 05                   		cmp	#0, r5
 6525 005d 1D                      		bne	.L441
 6526                             		.loc 2 4394 9 is_stmt 0 discriminator 1
 6527 005e F8 A6 83                		mov.L	#-125, [r10]
 6528 0061 09                      		bra	.L442
 6529                             	.L441:
 6530                             		.loc 2 4394 9 discriminator 2
 6531 0062 ED A5 09                		mov.L	36[r10], r5
 6532 0065 ED A4 03                		mov.L	12[r10], r4
 6533 0068 A1 D4                   		mov.L	r4, 24[r5]
 6534                             	.L442:
4395:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 6535                             		.loc 2 4395 12 is_stmt 1
 6536 006a EC A5                   		mov.L	[r10], r5
 6537 006c 61 05                   		cmp	#0, r5
 6538 006e 21 16                   		bne	.L443
4396:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_curve_load(private_key->dp, &curve,
 6539                             		.loc 2 4396 19
 6540 0070 ED A5 14                		mov.L	80[r10], r5
 6541 0073 A9 54                   		mov.L	16[r5], r4
 6542 0075 71 A5 24                		add	#36, r10, r5
 6543 0078 66 B3                   		mov	#11, r3
 6544 007a EF 52                   		mov.L	r5, r2
 6545 007c EF 41                   		mov.L	r4, r1
 6546 007e 05 00 00 00             		bsr	_wc_ecc_curve_load
 6547 0082 E3 A1                   		mov.L	r1, [r10]
 6548                             	.L443:
4397:../src/wolfcrypt/src/ecc.c ****                 (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF |
4398:../src/wolfcrypt/src/ecc.c ****                  ECC_CURVE_FIELD_ORDER));
4399:../src/wolfcrypt/src/ecc.c ****         }
4400:../src/wolfcrypt/src/ecc.c **** 
4401:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY) {
 6549                             		.loc 2 4401 12
 6550 0084 EC A5                   		mov.L	[r10], r5
 6551 0086 61 05                   		cmp	#0, r5
 6552 0088 20 1A                   		beq	.L444
 6553                             	.LBB35:
4402:../src/wolfcrypt/src/ecc.c ****             FREE_CURVE_SPECS();
 6554                             		.loc 2 4402 13
 6555 008a ED A5 03                		mov.L	12[r10], r5
 6556 008d E7 A5 04                		mov.L	r5, 16[r10]
 6557 0090 ED A5 04                		mov.L	16[r10], r5
 6558 0093 61 05                   		cmp	#0, r5
 6559 0095 3A 7D 01                		beq	.L459
 6560                             		.loc 2 4402 13 is_stmt 0 discriminator 1
 6561 0098 ED A1 04                		mov.L	16[r10], r1
 6562 009b 05 00 00 00             		bsr	_wolfSSL_Free
 6563                             	.LBE35:
4403:../src/wolfcrypt/src/ecc.c ****             goto errout;
 6564                             		.loc 2 4403 13 is_stmt 1 discriminator 1
 6565 009f 38 73 01                		bra	.L459
 6566                             	.L444:
4404:../src/wolfcrypt/src/ecc.c ****         }
4405:../src/wolfcrypt/src/ecc.c **** 
4406:../src/wolfcrypt/src/ecc.c ****         /* make new point */
4407:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_NO_MALLOC
4408:../src/wolfcrypt/src/ecc.c ****         result = &lcl_result;
4409:../src/wolfcrypt/src/ecc.c ****     #endif
4410:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_new_point_ex(&result, private_key->heap);
 6567                             		.loc 2 4410 15
 6568 00a2 ED A5 14                		mov.L	80[r10], r5
 6569 00a5 A9 5C                   		mov.L	20[r5], r4
 6570 00a7 71 A5 1C                		add	#28, r10, r5
 6571 00aa EF 42                   		mov.L	r4, r2
 6572 00ac EF 51                   		mov.L	r5, r1
 6573 00ae 05 00 00 00             		bsr	_wc_ecc_new_point_ex
 6574 00b2 E3 A1                   		mov.L	r1, [r10]
4411:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY) {
 6575                             		.loc 2 4411 12
 6576 00b4 EC A5                   		mov.L	[r10], r5
 6577 00b6 61 05                   		cmp	#0, r5
 6578 00b8 20 23                   		beq	.L447
4412:../src/wolfcrypt/src/ecc.c ****             wc_ecc_curve_free(curve);
 6579                             		.loc 2 4412 13
 6580 00ba ED A5 09                		mov.L	36[r10], r5
 6581 00bd EF 51                   		mov.L	r5, r1
 6582 00bf 05 00 00 00             		bsr	_wc_ecc_curve_free
 6583                             	.LBB36:
4413:../src/wolfcrypt/src/ecc.c ****             FREE_CURVE_SPECS();
 6584                             		.loc 2 4413 13
 6585 00c3 ED A5 03                		mov.L	12[r10], r5
 6586 00c6 E7 A5 05                		mov.L	r5, 20[r10]
 6587 00c9 ED A5 05                		mov.L	20[r10], r5
 6588 00cc 61 05                   		cmp	#0, r5
 6589 00ce 3A 47 01                		beq	.L460
 6590                             		.loc 2 4413 13 is_stmt 0 discriminator 1
 6591 00d1 ED A1 05                		mov.L	20[r10], r1
 6592 00d4 05 00 00 00             		bsr	_wolfSSL_Free
 6593                             	.LBE36:
4414:../src/wolfcrypt/src/ecc.c ****             goto errout;
 6594                             		.loc 2 4414 13 is_stmt 1 discriminator 1
 6595 00d8 38 3D 01                		bra	.L460
 6596                             	.L447:
4415:../src/wolfcrypt/src/ecc.c ****         }
4416:../src/wolfcrypt/src/ecc.c **** 
4417:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
4418:../src/wolfcrypt/src/ecc.c ****         if (private_key->rng == NULL) {
 6597                             		.loc 2 4418 24
 6598 00db ED A5 14                		mov.L	80[r10], r5
 6599 00de EE 55 16 03             		mov.L	3160[r5], r5
 6600                             		.loc 2 4418 12
 6601 00e2 61 05                   		cmp	#0, r5
 6602 00e4 1D                      		bne	.L449
4419:../src/wolfcrypt/src/ecc.c ****             err = MISSING_RNG_E;
 6603                             		.loc 2 4419 17
 6604 00e5 F8 AA 14 FF             		mov.L	#-236, [r10]
 6605                             	.L449:
4420:../src/wolfcrypt/src/ecc.c ****         }
4421:../src/wolfcrypt/src/ecc.c **** #endif
4422:../src/wolfcrypt/src/ecc.c **** 
4423:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 6606                             		.loc 2 4423 12
 6607 00e9 EC A5                   		mov.L	[r10], r5
 6608 00eb 61 05                   		cmp	#0, r5
 6609 00ed 21 37                   		bne	.L450
4424:../src/wolfcrypt/src/ecc.c ****             /* Map in a separate call as this should be constant time */
4425:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
4426:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_mulmod_ex2(k, point, result, curve->Af, curve->prime,
 6610                             		.loc 2 4426 19
 6611 00ef ED A3 07                		mov.L	28[r10], r3
 6612                             		.loc 2 4426 60
 6613 00f2 ED A5 09                		mov.L	36[r10], r5
 6614                             		.loc 2 4426 19
 6615 00f5 A8 D4                   		mov.L	8[r5], r4
 6616                             		.loc 2 4426 71
 6617 00f7 ED A5 09                		mov.L	36[r10], r5
 6618                             		.loc 2 4426 19
 6619 00fa A8 5A                   		mov.L	4[r5], r2
4427:../src/wolfcrypt/src/ecc.c ****                                               curve->order, private_key->rng, 0,
 6620                             		.loc 2 4427 52
 6621 00fc ED A5 09                		mov.L	36[r10], r5
4426:../src/wolfcrypt/src/ecc.c ****                                               curve->order, private_key->rng, 0,
 6622                             		.loc 2 4426 19
 6623 00ff A8 D9                   		mov.L	12[r5], r1
 6624 0101 ED A5 14                		mov.L	80[r10], r5
 6625 0104 EE 56 16 03             		mov.L	3160[r5], r6
 6626 0108 ED A5 14                		mov.L	80[r10], r5
 6627 010b A9 5D                   		mov.L	20[r5], r5
 6628 010d A1 05                   		mov.L	r5, 16[r0]
 6629 010f 3E 03 00                		mov.L	#0, 12[r0]
 6630 0112 A0 86                   		mov.L	r6, 8[r0]
 6631 0114 A0 09                   		mov.L	r1, 4[r0]
 6632 0116 E3 02                   		mov.L	r2, [r0]
 6633 0118 ED A2 15                		mov.L	84[r10], r2
 6634 011b ED A1 02                		mov.L	8[r10], r1
 6635 011e 05 00 00 00             		bsr	_wc_ecc_mulmod_ex2
 6636 0122 E3 A1                   		mov.L	r1, [r10]
 6637                             	.L450:
4428:../src/wolfcrypt/src/ecc.c ****                                               private_key->heap);
4429:../src/wolfcrypt/src/ecc.c **** #else
4430:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_mulmod_ex2(k, point, result, curve->Af, curve->prime,
4431:../src/wolfcrypt/src/ecc.c ****                                       curve->order, NULL, 0, private_key->heap);
4432:../src/wolfcrypt/src/ecc.c **** #endif
4433:../src/wolfcrypt/src/ecc.c ****         }
4434:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 6638                             		.loc 2 4434 12
 6639 0124 EC A5                   		mov.L	[r10], r5
 6640 0126 61 05                   		cmp	#0, r5
 6641 0128 21 14                   		bne	.L451
4435:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_CHECK_MEM_ZERO
4436:../src/wolfcrypt/src/ecc.c ****             mp_memzero_add("wc_ecc_shared_secret_gen_sync result->x",
4437:../src/wolfcrypt/src/ecc.c ****                 result->x);
4438:../src/wolfcrypt/src/ecc.c ****             mp_memzero_add("wc_ecc_shared_secret_gen_sync result->y",
4439:../src/wolfcrypt/src/ecc.c ****                 result->y);
4440:../src/wolfcrypt/src/ecc.c ****         #endif
4441:../src/wolfcrypt/src/ecc.c ****             err = mp_montgomery_setup(curve->prime, &mp);
 6642                             		.loc 2 4441 44
 6643 012a ED A5 09                		mov.L	36[r10], r5
 6644 012d A8 5C                   		mov.L	4[r5], r4
 6645                             		.loc 2 4441 19
 6646 012f 71 A5 20                		add	#32, r10, r5
 6647 0132 EF 52                   		mov.L	r5, r2
 6648 0134 EF 41                   		mov.L	r4, r1
 6649 0136 05 00 00 00             		bsr	_sp_mont_setup
 6650 013a E3 A1                   		mov.L	r1, [r10]
 6651                             	.L451:
4442:../src/wolfcrypt/src/ecc.c ****         }
4443:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 6652                             		.loc 2 4443 12
 6653 013c EC A5                   		mov.L	[r10], r5
 6654 013e 61 05                   		cmp	#0, r5
 6655 0140 21 17                   		bne	.L452
4444:../src/wolfcrypt/src/ecc.c ****             /* Use constant time map if compiled in */
4445:../src/wolfcrypt/src/ecc.c ****             err = ecc_map_ex(result, curve->prime, mp, 1);
 6656                             		.loc 2 4445 19
 6657 0142 ED A1 07                		mov.L	28[r10], r1
 6658                             		.loc 2 4445 43
 6659 0145 ED A5 09                		mov.L	36[r10], r5
 6660                             		.loc 2 4445 19
 6661 0148 A8 5D                   		mov.L	4[r5], r5
 6662 014a ED A3 08                		mov.L	32[r10], r3
 6663 014d 66 14                   		mov.L	#1, r4
 6664 014f EF 52                   		mov.L	r5, r2
 6665 0151 05 00 00 00             		bsr	_ecc_map_ex
 6666 0155 E3 A1                   		mov.L	r1, [r10]
 6667                             	.L452:
4446:../src/wolfcrypt/src/ecc.c ****         }
4447:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 6668                             		.loc 2 4447 12
 6669 0157 EC A5                   		mov.L	[r10], r5
 6670 0159 61 05                   		cmp	#0, r5
 6671 015b 21 34                   		bne	.L453
4448:../src/wolfcrypt/src/ecc.c ****             x = mp_unsigned_bin_size(curve->prime);
 6672                             		.loc 2 4448 43
 6673 015d ED A5 09                		mov.L	36[r10], r5
 6674 0160 A8 5D                   		mov.L	4[r5], r5
 6675                             		.loc 2 4448 17
 6676 0162 EF 51                   		mov.L	r5, r1
 6677 0164 05 00 00 00             		bsr	_sp_unsigned_bin_size
 6678 0168 EF 15                   		mov.L	r1, r5
 6679                             		.loc 2 4448 15
 6680 016a E7 A5 01                		mov.L	r5, 4[r10]
4449:../src/wolfcrypt/src/ecc.c ****             if (*outlen < x || (int)x < mp_unsigned_bin_size(result->x)) {
 6681                             		.loc 2 4449 17
 6682 016d ED A5 17                		mov.L	92[r10], r5
 6683 0170 EC 55                   		mov.L	[r5], r5
 6684                             		.loc 2 4449 16
 6685 0172 ED A4 01                		mov.L	4[r10], r4
 6686 0175 47 54                   		cmp	r5, r4
 6687 0177 24 14                   		bgtu	.L454
 6688                             		.loc 2 4449 68 discriminator 1
 6689 0179 ED A5 07                		mov.L	28[r10], r5
 6690                             		.loc 2 4449 41 discriminator 1
 6691 017c EF 51                   		mov.L	r5, r1
 6692 017e 05 00 00 00             		bsr	_sp_unsigned_bin_size
 6693 0182 EF 14                   		mov.L	r1, r4
 6694                             		.loc 2 4449 32 discriminator 1
 6695 0184 ED A5 01                		mov.L	4[r10], r5
 6696                             		.loc 2 4449 29 discriminator 1
 6697 0187 47 54                   		cmp	r5, r4
 6698 0189 2B 06                   		ble	.L453
 6699                             	.L454:
4450:../src/wolfcrypt/src/ecc.c ****                 err = BUFFER_E;
 6700                             		.loc 2 4450 21
 6701 018b F8 AA 7C FF             		mov.L	#-132, [r10]
 6702                             	.L453:
4451:../src/wolfcrypt/src/ecc.c ****             }
4452:../src/wolfcrypt/src/ecc.c ****         }
4453:../src/wolfcrypt/src/ecc.c **** 
4454:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 6703                             		.loc 2 4454 12
 6704 018f EC A5                   		mov.L	[r10], r5
 6705 0191 61 05                   		cmp	#0, r5
 6706 0193 21 33                   		bne	.L455
4455:../src/wolfcrypt/src/ecc.c ****             XMEMSET(out, 0, x);
 6707                             		.loc 2 4455 13
 6708 0195 ED A3 01                		mov.L	4[r10], r3
 6709 0198 66 02                   		mov.L	#0, r2
 6710 019a ED A1 16                		mov.L	88[r10], r1
 6711 019d 05 00 00 00             		bsr	_memset
4456:../src/wolfcrypt/src/ecc.c ****             err = mp_to_unsigned_bin(result->x,out +
 6712                             		.loc 2 4456 44
 6713 01a1 ED A5 07                		mov.L	28[r10], r5
 6714 01a4 EF 56                   		mov.L	r5, r6
4457:../src/wolfcrypt/src/ecc.c ****                                      (x - mp_unsigned_bin_size(result->x)));
 6715                             		.loc 2 4457 70
 6716 01a6 ED A5 07                		mov.L	28[r10], r5
 6717                             		.loc 2 4457 43
 6718 01a9 EF 51                   		mov.L	r5, r1
 6719 01ab 05 00 00 00             		bsr	_sp_unsigned_bin_size
 6720 01af EF 15                   		mov.L	r1, r5
 6721                             		.loc 2 4457 41
 6722 01b1 ED A4 01                		mov.L	4[r10], r4
 6723 01b4 FF 05 54                		sub	r5, r4, r5
4456:../src/wolfcrypt/src/ecc.c ****             err = mp_to_unsigned_bin(result->x,out +
 6724                             		.loc 2 4456 19
 6725 01b7 ED A4 16                		mov.L	88[r10], r4
 6726 01ba 4B 45                   		add	r4, r5
 6727 01bc EF 52                   		mov.L	r5, r2
 6728 01be EF 61                   		mov.L	r6, r1
 6729 01c0 05 00 00 00             		bsr	_sp_to_unsigned_bin
 6730 01c4 E3 A1                   		mov.L	r1, [r10]
 6731                             	.L455:
4458:../src/wolfcrypt/src/ecc.c ****         }
4459:../src/wolfcrypt/src/ecc.c ****         *outlen = x;
 6732                             		.loc 2 4459 17
 6733 01c6 ED A5 17                		mov.L	92[r10], r5
 6734 01c9 ED A4 01                		mov.L	4[r10], r4
 6735 01cc E3 54                   		mov.L	r4, [r5]
4460:../src/wolfcrypt/src/ecc.c **** 
4461:../src/wolfcrypt/src/ecc.c ****         mp_forcezero(result->x);
 6736                             		.loc 2 4461 28
 6737 01ce ED A5 07                		mov.L	28[r10], r5
 6738                             		.loc 2 4461 9
 6739 01d1 EF 51                   		mov.L	r5, r1
 6740 01d3 05 00 00 00             		bsr	_sp_forcezero
4462:../src/wolfcrypt/src/ecc.c ****         mp_forcezero(result->y);
 6741                             		.loc 2 4462 28
 6742 01d7 ED A5 07                		mov.L	28[r10], r5
 6743 01da 72 55 10 03             		add	#0x310, r5
 6744                             		.loc 2 4462 9
 6745 01de EF 51                   		mov.L	r5, r1
 6746 01e0 05 00 00 00             		bsr	_sp_forcezero
4463:../src/wolfcrypt/src/ecc.c ****         wc_ecc_del_point_ex(result, private_key->heap);
 6747                             		.loc 2 4463 9
 6748 01e4 ED A4 07                		mov.L	28[r10], r4
 6749 01e7 ED A5 14                		mov.L	80[r10], r5
 6750 01ea A9 5D                   		mov.L	20[r5], r5
 6751 01ec EF 52                   		mov.L	r5, r2
 6752 01ee EF 41                   		mov.L	r4, r1
 6753 01f0 05 00 00 00             		bsr	_wc_ecc_del_point_ex
4464:../src/wolfcrypt/src/ecc.c **** 
4465:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_free(curve);
 6754                             		.loc 2 4465 9
 6755 01f4 ED A5 09                		mov.L	36[r10], r5
 6756 01f7 EF 51                   		mov.L	r5, r1
 6757 01f9 05 00 00 00             		bsr	_wc_ecc_curve_free
 6758                             	.LBB37:
4466:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
 6759                             		.loc 2 4466 9
 6760 01fd ED A5 03                		mov.L	12[r10], r5
 6761 0200 E7 A5 06                		mov.L	r5, 24[r10]
 6762 0203 ED A5 06                		mov.L	24[r10], r5
 6763 0206 61 05                   		cmp	#0, r5
 6764 0208 20 0E                   		beq	.L457
 6765                             		.loc 2 4466 9 is_stmt 0 discriminator 1
 6766 020a ED A1 06                		mov.L	24[r10], r1
 6767 020d 05 00 00 00             		bsr	_wolfSSL_Free
 6768 0211 0D                      		bra	.L457
 6769                             	.L459:
 6770                             	.LBE37:
4403:../src/wolfcrypt/src/ecc.c ****         }
 6771                             		.loc 2 4403 13 is_stmt 1
 6772 0212 03                      		nop
 6773 0213 2E 03                   		bra	.L457
 6774                             	.L460:
4414:../src/wolfcrypt/src/ecc.c ****         }
 6775                             		.loc 2 4414 13
 6776 0215 03                      		nop
 6777                             		.balign 8,3,1
 6778                             	.L457:
 6779                             	.LBE34:
4467:../src/wolfcrypt/src/ecc.c ****     }
4468:../src/wolfcrypt/src/ecc.c **** #endif
4469:../src/wolfcrypt/src/ecc.c **** 
4470:../src/wolfcrypt/src/ecc.c ****   errout:
4471:../src/wolfcrypt/src/ecc.c **** 
4472:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_CDH
4473:../src/wolfcrypt/src/ecc.c ****     if (k == k_lcl)
4474:../src/wolfcrypt/src/ecc.c ****         mp_clear(k);
4475:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
4476:../src/wolfcrypt/src/ecc.c ****     if (k_lcl != NULL)
4477:../src/wolfcrypt/src/ecc.c ****         XFREE(k_lcl, private_key->heap, DYNAMIC_TYPE_ECC_BUFFER);
4478:../src/wolfcrypt/src/ecc.c **** #endif
4479:../src/wolfcrypt/src/ecc.c **** #endif
4480:../src/wolfcrypt/src/ecc.c **** 
4481:../src/wolfcrypt/src/ecc.c ****     return err;
 6780                             		.loc 2 4481 12
 6781 0216 EC A5                   		mov.L	[r10], r5
4482:../src/wolfcrypt/src/ecc.c **** }
 6782                             		.loc 2 4482 1
 6783 0218 EF 51                   		mov.L	r5, r1
 6784 021a 71 00 74                		add	#0x74, r0
 6785 021d 7E B6                   		pop	r6
 6786 021f 7E BA                   		pop	r10
 6787 0221 02                      		rts
 6788                             	.LFE84:
 6790 0222 74 10 01 00 00 00       		.section	.text.wc_ecc_shared_secret_gen,"ax",@progbits
 6791                             		.global	_wc_ecc_shared_secret_gen
 6793                             	_wc_ecc_shared_secret_gen:
 6794                             	.LFB85:
4483:../src/wolfcrypt/src/ecc.c **** 
4484:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
4485:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_shared_secret_gen_async(ecc_key* private_key,
4486:../src/wolfcrypt/src/ecc.c ****             ecc_point* point, byte* out, word32 *outlen)
4487:../src/wolfcrypt/src/ecc.c **** {
4488:../src/wolfcrypt/src/ecc.c ****     int err = 0;
4489:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(3);
4490:../src/wolfcrypt/src/ecc.c **** 
4491:../src/wolfcrypt/src/ecc.c ****     /* load curve info */
4492:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(3, err);
4493:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
4494:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_curve_load(private_key->dp, &curve,
4495:../src/wolfcrypt/src/ecc.c ****             (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF |
4496:../src/wolfcrypt/src/ecc.c ****              ECC_CURVE_FIELD_ORDER));
4497:../src/wolfcrypt/src/ecc.c ****     }
4498:../src/wolfcrypt/src/ecc.c **** 
4499:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY) {
4500:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
4501:../src/wolfcrypt/src/ecc.c ****         return err;
4502:../src/wolfcrypt/src/ecc.c ****     }
4503:../src/wolfcrypt/src/ecc.c **** 
4504:../src/wolfcrypt/src/ecc.c **** #if defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)
4505:../src/wolfcrypt/src/ecc.c ****     if (private_key->dp
4506:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_CUSTOM_CURVES
4507:../src/wolfcrypt/src/ecc.c ****         && private_key->dp->id != ECC_CURVE_CUSTOM
4508:../src/wolfcrypt/src/ecc.c ****     #endif
4509:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_CAVIUM_V
4510:../src/wolfcrypt/src/ecc.c ****         /* verify the curve is supported by hardware */
4511:../src/wolfcrypt/src/ecc.c ****         && NitroxEccIsCurveSupported(private_key)
4512:../src/wolfcrypt/src/ecc.c ****     #endif
4513:../src/wolfcrypt/src/ecc.c ****     ) {
4514:../src/wolfcrypt/src/ecc.c ****         word32 keySz = private_key->dp->size;
4515:../src/wolfcrypt/src/ecc.c **** 
4516:../src/wolfcrypt/src/ecc.c ****         /* sync public key x/y */
4517:../src/wolfcrypt/src/ecc.c ****         err = wc_mp_to_bigint_sz(&private_key->k, &private_key->k.raw, keySz);
4518:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
4519:../src/wolfcrypt/src/ecc.c ****             err = wc_mp_to_bigint_sz(point->x, &point->x->raw, keySz);
4520:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
4521:../src/wolfcrypt/src/ecc.c ****             err = wc_mp_to_bigint_sz(point->y, &point->y->raw, keySz);
4522:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_CAVIUM_V
4523:../src/wolfcrypt/src/ecc.c ****         /* allocate buffer for output */
4524:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
4525:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_alloc_mpint(private_key, &private_key->e);
4526:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
4527:../src/wolfcrypt/src/ecc.c ****             err = wc_bigint_alloc(&private_key->e->raw,
4528:../src/wolfcrypt/src/ecc.c ****                 NitroxEccGetSize(private_key)*2);
4529:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
4530:../src/wolfcrypt/src/ecc.c ****             err = NitroxEcdh(private_key,
4531:../src/wolfcrypt/src/ecc.c ****                 &private_key->k.raw, &point->x->raw, &point->y->raw,
4532:../src/wolfcrypt/src/ecc.c ****                 private_key->e->raw.buf, &private_key->e->raw.len,
4533:../src/wolfcrypt/src/ecc.c ****                 &curve->prime->raw);
4534:../src/wolfcrypt/src/ecc.c ****     #else
4535:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
4536:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_curve_load(private_key->dp, &curve, ECC_CURVE_FIELD_BF);
4537:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
4538:../src/wolfcrypt/src/ecc.c ****             err = IntelQaEcdh(&private_key->asyncDev,
4539:../src/wolfcrypt/src/ecc.c ****                 &private_key->k.raw, &point->x->raw, &point->y->raw,
4540:../src/wolfcrypt/src/ecc.c ****                 out, outlen,
4541:../src/wolfcrypt/src/ecc.c ****                 &curve->Af->raw, &curve->Bf->raw, &curve->prime->raw,
4542:../src/wolfcrypt/src/ecc.c ****                 private_key->dp->cofactor);
4543:../src/wolfcrypt/src/ecc.c ****     #endif
4544:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_free(curve);
4545:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
4546:../src/wolfcrypt/src/ecc.c ****         return err;
4547:../src/wolfcrypt/src/ecc.c ****     }
4548:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_ASYNC_CRYPT_TEST)
4549:../src/wolfcrypt/src/ecc.c ****     if (wc_AsyncTestInit(&private_key->asyncDev, ASYNC_TEST_ECC_SHARED_SEC)) {
4550:../src/wolfcrypt/src/ecc.c ****         WC_ASYNC_TEST* testDev = &private_key->asyncDev.test;
4551:../src/wolfcrypt/src/ecc.c ****         testDev->eccSharedSec.private_key = private_key;
4552:../src/wolfcrypt/src/ecc.c ****         testDev->eccSharedSec.public_point = point;
4553:../src/wolfcrypt/src/ecc.c ****         testDev->eccSharedSec.out = out;
4554:../src/wolfcrypt/src/ecc.c ****         testDev->eccSharedSec.outLen = outlen;
4555:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_free(curve);
4556:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
4557:../src/wolfcrypt/src/ecc.c ****         return WC_PENDING_E;
4558:../src/wolfcrypt/src/ecc.c ****     }
4559:../src/wolfcrypt/src/ecc.c **** #endif
4560:../src/wolfcrypt/src/ecc.c **** 
4561:../src/wolfcrypt/src/ecc.c ****     /* use sync in other cases */
4562:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_shared_secret_gen_sync(private_key, point, out, outlen);
4563:../src/wolfcrypt/src/ecc.c **** 
4564:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
4565:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
4566:../src/wolfcrypt/src/ecc.c **** 
4567:../src/wolfcrypt/src/ecc.c ****     return err;
4568:../src/wolfcrypt/src/ecc.c **** }
4569:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */
4570:../src/wolfcrypt/src/ecc.c **** 
4571:../src/wolfcrypt/src/ecc.c **** int wc_ecc_shared_secret_gen(ecc_key* private_key, ecc_point* point,
4572:../src/wolfcrypt/src/ecc.c ****                                                     byte* out, word32 *outlen)
4573:../src/wolfcrypt/src/ecc.c **** {
 6795                             		.loc 2 4573 1
 6796 0000 7E AA                   		push.l	r10
 6797                             	.LCFI106:
 6798 0002 71 0A EC                		add	#-20, r0, r10
 6799                             	.LCFI107:
 6800 0005 EF A0                   		mov.L	r10, r0
 6801 0007 E7 A1 01                		mov.L	r1, 4[r10]
 6802 000a E7 A2 02                		mov.L	r2, 8[r10]
 6803 000d E7 A3 03                		mov.L	r3, 12[r10]
 6804 0010 E7 A4 04                		mov.L	r4, 16[r10]
4574:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 6805                             		.loc 2 4574 9
 6806 0013 F8 A6 00                		mov.L	#0, [r10]
4575:../src/wolfcrypt/src/ecc.c **** 
4576:../src/wolfcrypt/src/ecc.c ****     if (private_key == NULL || point == NULL || out == NULL ||
 6807                             		.loc 2 4576 8
 6808 0016 ED A5 01                		mov.L	4[r10], r5
 6809 0019 61 05                   		cmp	#0, r5
 6810 001b 20 15                   		beq	.L462
 6811                             		.loc 2 4576 29 discriminator 1
 6812 001d ED A5 02                		mov.L	8[r10], r5
 6813 0020 61 05                   		cmp	#0, r5
 6814 0022 20 0E                   		beq	.L462
 6815                             		.loc 2 4576 46 discriminator 2
 6816 0024 ED A5 03                		mov.L	12[r10], r5
 6817 0027 61 05                   		cmp	#0, r5
 6818 0029 17                      		beq	.L462
 6819                             		.loc 2 4576 61 discriminator 3
 6820 002a ED A5 04                		mov.L	16[r10], r5
 6821 002d 61 05                   		cmp	#0, r5
 6822 002f 1F                      		bne	.L463
 6823                             		.balign 8,3,2
 6824                             	.L462:
4577:../src/wolfcrypt/src/ecc.c ****                                                             outlen == NULL) {
4578:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 6825                             		.loc 2 4578 16
 6826 0030 FB 5A 53 FF             		mov.L	#-173, r5
 6827 0034 2E 16                   		bra	.L464
 6828                             	.L463:
4579:../src/wolfcrypt/src/ecc.c ****     }
4580:../src/wolfcrypt/src/ecc.c **** 
4581:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
4582:../src/wolfcrypt/src/ecc.c ****     if (private_key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
4583:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_shared_secret_gen_async(private_key, point,
4584:../src/wolfcrypt/src/ecc.c ****             out, outlen);
4585:../src/wolfcrypt/src/ecc.c ****     }
4586:../src/wolfcrypt/src/ecc.c ****     else
4587:../src/wolfcrypt/src/ecc.c **** #endif
4588:../src/wolfcrypt/src/ecc.c ****     {
4589:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_shared_secret_gen_sync(private_key, point,
 6829                             		.loc 2 4589 15
 6830 0036 ED A4 04                		mov.L	16[r10], r4
 6831 0039 ED A3 03                		mov.L	12[r10], r3
 6832 003c ED A2 02                		mov.L	8[r10], r2
 6833 003f ED A1 01                		mov.L	4[r10], r1
 6834 0042 05 00 00 00             		bsr	_wc_ecc_shared_secret_gen_sync
 6835 0046 E3 A1                   		mov.L	r1, [r10]
4590:../src/wolfcrypt/src/ecc.c ****             out, outlen);
4591:../src/wolfcrypt/src/ecc.c ****     }
4592:../src/wolfcrypt/src/ecc.c **** 
4593:../src/wolfcrypt/src/ecc.c ****     return err;
 6836                             		.loc 2 4593 12
 6837 0048 EC A5                   		mov.L	[r10], r5
 6838                             	.L464:
4594:../src/wolfcrypt/src/ecc.c **** }
 6839                             		.loc 2 4594 1
 6840 004a EF 51                   		mov.L	r5, r1
 6841 004c 3F AA 06                		rtsd	#24, r10-r10
 6842                             	.LFE85:
 6844 004f 03                      		.section C,"a",@progbits
 6845 0a31 00 00 00                		.p2align 2
 6846                             	.LC38:
 6847 0a34 45 43 43 5F 42 41 44 5F 		.string	"ECC_BAD_ARG_E"
 6847      41 52 47 5F 45 00 
 6848                             	.LC39:
 6849 0a42 77 63 5F 65 63 63 5F 69 		.string	"wc_ecc_is_valid_idx failed"
 6849      73 5F 76 61 6C 69 64 5F 
 6849      69 64 78 20 66 61 69 6C 
 6849      65 64 00 
 6850                             		.section	.text.wc_ecc_shared_secret_ex,"ax",@progbits
 6851                             		.global	_wc_ecc_shared_secret_ex
 6853                             	_wc_ecc_shared_secret_ex:
 6854                             	.LFB86:
4595:../src/wolfcrypt/src/ecc.c **** 
4596:../src/wolfcrypt/src/ecc.c **** #ifndef WOLF_CRYPTO_CB_ONLY_ECC
4597:../src/wolfcrypt/src/ecc.c **** /**
4598:../src/wolfcrypt/src/ecc.c ****  Create an ECC shared secret between private key and public point
4599:../src/wolfcrypt/src/ecc.c ****  private_key      The private ECC key (heap hint based on private key)
4600:../src/wolfcrypt/src/ecc.c ****  point            The point to use (public key)
4601:../src/wolfcrypt/src/ecc.c ****  out              [out] Destination of the shared secret
4602:../src/wolfcrypt/src/ecc.c ****                         Conforms to EC-DH from ANSI X9.63
4603:../src/wolfcrypt/src/ecc.c ****  outlen           [in/out] The max size and resulting size of the shared secret
4604:../src/wolfcrypt/src/ecc.c ****  return           MP_OKAY if successful
4605:../src/wolfcrypt/src/ecc.c **** */
4606:../src/wolfcrypt/src/ecc.c **** int wc_ecc_shared_secret_ex(ecc_key* private_key, ecc_point* point,
4607:../src/wolfcrypt/src/ecc.c ****                             byte* out, word32 *outlen)
4608:../src/wolfcrypt/src/ecc.c **** {
 6855                             		.loc 2 4608 1
 6856 0000 7E AA                   		push.l	r10
 6857                             	.LCFI108:
 6858 0002 71 0A EC                		add	#-20, r0, r10
 6859                             	.LCFI109:
 6860 0005 EF A0                   		mov.L	r10, r0
 6861 0007 E7 A1 01                		mov.L	r1, 4[r10]
 6862 000a E7 A2 02                		mov.L	r2, 8[r10]
 6863 000d E7 A3 03                		mov.L	r3, 12[r10]
 6864 0010 E7 A4 04                		mov.L	r4, 16[r10]
4609:../src/wolfcrypt/src/ecc.c ****     int err;
4610:../src/wolfcrypt/src/ecc.c **** 
4611:../src/wolfcrypt/src/ecc.c ****     if (private_key == NULL || point == NULL || out == NULL ||
 6865                             		.loc 2 4611 8
 6866 0013 ED A5 01                		mov.L	4[r10], r5
 6867 0016 61 05                   		cmp	#0, r5
 6868 0018 20 15                   		beq	.L466
 6869                             		.loc 2 4611 29 discriminator 1
 6870 001a ED A5 02                		mov.L	8[r10], r5
 6871 001d 61 05                   		cmp	#0, r5
 6872 001f 20 0E                   		beq	.L466
 6873                             		.loc 2 4611 46 discriminator 2
 6874 0021 ED A5 03                		mov.L	12[r10], r5
 6875 0024 61 05                   		cmp	#0, r5
 6876 0026 17                      		beq	.L466
 6877                             		.loc 2 4611 61 discriminator 3
 6878 0027 ED A5 04                		mov.L	16[r10], r5
 6879 002a 61 05                   		cmp	#0, r5
 6880 002c 18                      		bne	.L467
 6881                             		.balign 8,3,2
 6882                             	.L466:
4612:../src/wolfcrypt/src/ecc.c ****                                                             outlen == NULL) {
4613:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 6883                             		.loc 2 4613 16
 6884 002d FB 5A 53 FF             		mov.L	#-173, r5
 6885 0031 38 B0 00                		bra	.L468
 6886                             	.L467:
4614:../src/wolfcrypt/src/ecc.c ****     }
4615:../src/wolfcrypt/src/ecc.c **** 
4616:../src/wolfcrypt/src/ecc.c ****     /* type valid? */
4617:../src/wolfcrypt/src/ecc.c ****     if (private_key->type != ECC_PRIVATEKEY &&
 6887                             		.loc 2 4617 20
 6888 0034 ED A5 01                		mov.L	4[r10], r5
 6889 0037 EC 55                   		mov.L	[r5], r5
 6890                             		.loc 2 4617 8
 6891 0039 61 25                   		cmp	#2, r5
 6892 003b 20 1C                   		beq	.L469
4618:../src/wolfcrypt/src/ecc.c ****             private_key->type != ECC_PRIVATEKEY_ONLY) {
 6893                             		.loc 2 4618 24 discriminator 1
 6894 003d ED A5 01                		mov.L	4[r10], r5
 6895 0040 EC 55                   		mov.L	[r5], r5
4617:../src/wolfcrypt/src/ecc.c ****             private_key->type != ECC_PRIVATEKEY_ONLY) {
 6896                             		.loc 2 4617 45 discriminator 1
 6897 0042 61 35                   		cmp	#3, r5
 6898 0044 20 13                   		beq	.L469
4619:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("ECC_BAD_ARG_E");
 6899                             		.loc 2 4619 9
 6900 0046 FB 12 34 0A 00 00       		mov.L	#.LC38, r1
 6901 004c 05 00 00 00             		bsr	_WOLFSSL_MSG
4620:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 6902                             		.loc 2 4620 16
 6903 0050 FB 5A 56 FF             		mov.L	#-170, r5
 6904 0054 38 8D 00                		bra	.L468
 6905                             	.L469:
4621:../src/wolfcrypt/src/ecc.c ****     }
4622:../src/wolfcrypt/src/ecc.c **** 
4623:../src/wolfcrypt/src/ecc.c ****     /* Verify domain params supplied */
4624:../src/wolfcrypt/src/ecc.c ****     if (wc_ecc_is_valid_idx(private_key->idx) == 0 || private_key->dp == NULL) {
 6906                             		.loc 2 4624 9
 6907 0057 ED A5 01                		mov.L	4[r10], r5
 6908 005a A8 5D                   		mov.L	4[r5], r5
 6909 005c EF 51                   		mov.L	r5, r1
 6910 005e 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 6911 0062 EF 15                   		mov.L	r1, r5
 6912                             		.loc 2 4624 8
 6913 0064 61 05                   		cmp	#0, r5
 6914 0066 12                      		beq	.L470
 6915                             		.loc 2 4624 66 discriminator 1
 6916 0067 ED A5 01                		mov.L	4[r10], r5
 6917 006a A9 55                   		mov.L	16[r5], r5
 6918                             		.loc 2 4624 52 discriminator 1
 6919 006c 61 05                   		cmp	#0, r5
 6920 006e 21 12                   		bne	.L471
 6921                             	.L470:
4625:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("wc_ecc_is_valid_idx failed");
 6922                             		.loc 2 4625 9
 6923 0070 FB 12 42 0A 00 00       		mov.L	#.LC39, r1
 6924 0076 05 00 00 00             		bsr	_WOLFSSL_MSG
4626:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 6925                             		.loc 2 4626 16
 6926 007a FB 5A 56 FF             		mov.L	#-170, r5
 6927 007e 2E 63                   		bra	.L468
 6928                             	.L471:
4627:../src/wolfcrypt/src/ecc.c ****     }
4628:../src/wolfcrypt/src/ecc.c **** 
4629:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
4630:../src/wolfcrypt/src/ecc.c **** 
4631:../src/wolfcrypt/src/ecc.c ****     switch (private_key->state) {
 6929                             		.loc 2 4631 24
 6930 0080 ED A5 01                		mov.L	4[r10], r5
 6931 0083 A8 D5                   		mov.L	8[r5], r5
 6932                             		.loc 2 4631 5
 6933 0085 61 05                   		cmp	#0, r5
 6934 0087 29 34                   		blt	.L472
 6935 0089 61 15                   		cmp	#1, r5
 6936 008b 2B 08                   		ble	.L473
 6937 008d 61 25                   		cmp	#2, r5
 6938 008f 20 22                   		beq	.L474
 6939 0091 2E 2A                   		bra	.L472
 6940                             	.L473:
4632:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_NONE:
4633:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_SHARED_SEC_GEN:
4634:../src/wolfcrypt/src/ecc.c ****             private_key->state = ECC_STATE_SHARED_SEC_GEN;
 6941                             		.loc 2 4634 32
 6942 0093 ED A5 01                		mov.L	4[r10], r5
 6943 0096 3E 52 01                		mov.L	#1, 8[r5]
4635:../src/wolfcrypt/src/ecc.c **** 
4636:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_shared_secret_gen(private_key, point, out, outlen);
 6944                             		.loc 2 4636 19
 6945 0099 ED A4 04                		mov.L	16[r10], r4
 6946 009c ED A3 03                		mov.L	12[r10], r3
 6947 009f ED A2 02                		mov.L	8[r10], r2
 6948 00a2 ED A1 01                		mov.L	4[r10], r1
 6949 00a5 05 00 00 00             		bsr	_wc_ecc_shared_secret_gen
 6950 00a9 E3 A1                   		mov.L	r1, [r10]
4637:../src/wolfcrypt/src/ecc.c ****             if (err < 0) {
 6951                             		.loc 2 4637 16
 6952 00ab EC A5                   		mov.L	[r10], r5
 6953 00ad 61 05                   		cmp	#0, r5
 6954 00af 29 12                   		blt	.L477
 6955                             	.L474:
4638:../src/wolfcrypt/src/ecc.c ****                 break;
4639:../src/wolfcrypt/src/ecc.c ****             }
4640:../src/wolfcrypt/src/ecc.c ****             FALL_THROUGH;
4641:../src/wolfcrypt/src/ecc.c **** 
4642:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_SHARED_SEC_RES:
4643:../src/wolfcrypt/src/ecc.c ****             private_key->state = ECC_STATE_SHARED_SEC_RES;
 6956                             		.loc 2 4643 32
 6957 00b1 ED A5 01                		mov.L	4[r10], r5
 6958 00b4 3E 52 02                		mov.L	#2, 8[r5]
4644:../src/wolfcrypt/src/ecc.c ****         #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
4645:../src/wolfcrypt/src/ecc.c ****             if (private_key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
4646:../src/wolfcrypt/src/ecc.c ****             #ifdef HAVE_CAVIUM_V
4647:../src/wolfcrypt/src/ecc.c ****                 /* verify the curve is supported by hardware */
4648:../src/wolfcrypt/src/ecc.c ****                 if (NitroxEccIsCurveSupported(private_key)) {
4649:../src/wolfcrypt/src/ecc.c ****                     /* copy output */
4650:../src/wolfcrypt/src/ecc.c ****                     *outlen = private_key->dp->size;
4651:../src/wolfcrypt/src/ecc.c ****                     XMEMCPY(out, private_key->e->raw.buf, *outlen);
4652:../src/wolfcrypt/src/ecc.c ****                 }
4653:../src/wolfcrypt/src/ecc.c ****             #endif /* HAVE_CAVIUM_V */
4654:../src/wolfcrypt/src/ecc.c ****             }
4655:../src/wolfcrypt/src/ecc.c ****         #endif /* WOLFSSL_ASYNC_CRYPT */
4656:../src/wolfcrypt/src/ecc.c ****             err = 0;
 6959                             		.loc 2 4656 17
 6960 00b7 F8 A6 00                		mov.L	#0, [r10]
4657:../src/wolfcrypt/src/ecc.c ****             break;
 6961                             		.loc 2 4657 13
 6962 00ba 08                      		bra	.L475
 6963                             	.L472:
4658:../src/wolfcrypt/src/ecc.c **** 
4659:../src/wolfcrypt/src/ecc.c ****         default:
4660:../src/wolfcrypt/src/ecc.c ****             err = BAD_STATE_E;
 6964                             		.loc 2 4660 17
 6965 00bb F8 AA 40 FF             		mov.L	#-192, [r10]
 6966 00bf 2E 03                   		bra	.L475
 6967                             	.L477:
4638:../src/wolfcrypt/src/ecc.c ****             }
 6968                             		.loc 2 4638 17
 6969 00c1 03                      		nop
 6970                             	.L475:
4661:../src/wolfcrypt/src/ecc.c ****     } /* switch */
4662:../src/wolfcrypt/src/ecc.c **** 
4663:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
4664:../src/wolfcrypt/src/ecc.c **** 
4665:../src/wolfcrypt/src/ecc.c ****     /* if async pending then return and skip done cleanup below */
4666:../src/wolfcrypt/src/ecc.c ****     if (err == WC_PENDING_E) {
 6971                             		.loc 2 4666 8
 6972 00c2 EC A5                   		mov.L	[r10], r5
 6973 00c4 75 05 94                		cmp	#-108, r5
 6974 00c7 21 12                   		bne	.L476
4667:../src/wolfcrypt/src/ecc.c ****         private_key->state++;
 6975                             		.loc 2 4667 20
 6976 00c9 ED A5 01                		mov.L	4[r10], r5
 6977 00cc A8 D5                   		mov.L	8[r5], r5
 6978                             		.loc 2 4667 27
 6979 00ce 71 54 01                		add	#1, r5, r4
 6980 00d1 ED A5 01                		mov.L	4[r10], r5
 6981 00d4 A0 D4                   		mov.L	r4, 8[r5]
4668:../src/wolfcrypt/src/ecc.c ****         return err;
 6982                             		.loc 2 4668 16
 6983 00d6 EC A5                   		mov.L	[r10], r5
 6984 00d8 09                      		bra	.L468
 6985                             	.L476:
4669:../src/wolfcrypt/src/ecc.c ****     }
4670:../src/wolfcrypt/src/ecc.c **** 
4671:../src/wolfcrypt/src/ecc.c ****     /* cleanup */
4672:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
4673:../src/wolfcrypt/src/ecc.c ****     wc_ecc_free_async(private_key);
4674:../src/wolfcrypt/src/ecc.c **** #endif
4675:../src/wolfcrypt/src/ecc.c ****     private_key->state = ECC_STATE_NONE;
 6986                             		.loc 2 4675 24
 6987 00d9 ED A5 01                		mov.L	4[r10], r5
 6988 00dc 3E 52 00                		mov.L	#0, 8[r5]
4676:../src/wolfcrypt/src/ecc.c **** 
4677:../src/wolfcrypt/src/ecc.c ****     return err;
 6989                             		.loc 2 4677 12
 6990 00df EC A5                   		mov.L	[r10], r5
 6991                             		.balign 8,3,1
 6992                             	.L468:
4678:../src/wolfcrypt/src/ecc.c **** }
 6993                             		.loc 2 4678 1
 6994 00e1 EF 51                   		mov.L	r5, r1
 6995 00e3 3F AA 06                		rtsd	#24, r10-r10
 6996                             	.LFE86:
 6998 00e6 EF 00                   		.section	.text.wc_ecc_point_is_at_infinity,"ax",@progbits
 6999                             		.global	_wc_ecc_point_is_at_infinity
 7001                             	_wc_ecc_point_is_at_infinity:
 7002                             	.LFB87:
4679:../src/wolfcrypt/src/ecc.c **** #endif /* WOLF_CRYPTO_CB_ONLY_ECC */
4680:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_KCAPI_ECC)
4681:../src/wolfcrypt/src/ecc.c **** int wc_ecc_shared_secret_ex(ecc_key* private_key, ecc_point* point,
4682:../src/wolfcrypt/src/ecc.c ****                             byte* out, word32 *outlen)
4683:../src/wolfcrypt/src/ecc.c **** {
4684:../src/wolfcrypt/src/ecc.c ****     int err;
4685:../src/wolfcrypt/src/ecc.c ****     ecc_key public_key;
4686:../src/wolfcrypt/src/ecc.c **** 
4687:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_init_ex(&public_key, private_key->heap, INVALID_DEVID);
4688:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
4689:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_set_curve(&public_key, private_key->dp->size,
4690:../src/wolfcrypt/src/ecc.c ****                                private_key->dp->id);
4691:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
4692:../src/wolfcrypt/src/ecc.c ****             err = mp_copy(point->x, public_key.pubkey.x);
4693:../src/wolfcrypt/src/ecc.c ****         }
4694:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
4695:../src/wolfcrypt/src/ecc.c ****             err = mp_copy(point->y, public_key.pubkey.y);
4696:../src/wolfcrypt/src/ecc.c ****         }
4697:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
4698:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_shared_secret(private_key, &public_key, out, outlen);
4699:../src/wolfcrypt/src/ecc.c ****         }
4700:../src/wolfcrypt/src/ecc.c **** 
4701:../src/wolfcrypt/src/ecc.c ****         wc_ecc_free(&public_key);
4702:../src/wolfcrypt/src/ecc.c ****     }
4703:../src/wolfcrypt/src/ecc.c **** 
4704:../src/wolfcrypt/src/ecc.c ****     return err;
4705:../src/wolfcrypt/src/ecc.c **** }
4706:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL && !WOLFSSL_KCAPI_ECC */
4707:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_DHE */
4708:../src/wolfcrypt/src/ecc.c **** 
4709:../src/wolfcrypt/src/ecc.c **** #ifdef USE_ECC_B_PARAM
4710:../src/wolfcrypt/src/ecc.c **** /* Checks if a point p lies on the curve with index curve_idx */
4711:../src/wolfcrypt/src/ecc.c **** int wc_ecc_point_is_on_curve(ecc_point *p, int curve_idx)
4712:../src/wolfcrypt/src/ecc.c **** {
4713:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
4714:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(3);
4715:../src/wolfcrypt/src/ecc.c **** 
4716:../src/wolfcrypt/src/ecc.c ****     if (p == NULL)
4717:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
4718:../src/wolfcrypt/src/ecc.c **** 
4719:../src/wolfcrypt/src/ecc.c ****     /* is the IDX valid ?  */
4720:../src/wolfcrypt/src/ecc.c ****     if (wc_ecc_is_valid_idx(curve_idx) == 0) {
4721:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
4722:../src/wolfcrypt/src/ecc.c ****     }
4723:../src/wolfcrypt/src/ecc.c **** 
4724:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
4725:../src/wolfcrypt/src/ecc.c **** 
4726:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(3, err);
4727:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
4728:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_curve_load(wc_ecc_get_curve_params(curve_idx), &curve,
4729:../src/wolfcrypt/src/ecc.c ****                                 ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF |
4730:../src/wolfcrypt/src/ecc.c ****                                 ECC_CURVE_FIELD_BF);
4731:../src/wolfcrypt/src/ecc.c ****     }
4732:../src/wolfcrypt/src/ecc.c **** 
4733:../src/wolfcrypt/src/ecc.c ****     /* x must be in the range [0, p-1] */
4734:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
4735:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp(p->x, curve->prime) != MP_LT)
4736:../src/wolfcrypt/src/ecc.c ****             err = ECC_OUT_OF_RANGE_E;
4737:../src/wolfcrypt/src/ecc.c ****     }
4738:../src/wolfcrypt/src/ecc.c ****     /* y must be in the range [0, p-1] */
4739:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
4740:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp(p->y, curve->prime) != MP_LT)
4741:../src/wolfcrypt/src/ecc.c ****             err = ECC_OUT_OF_RANGE_E;
4742:../src/wolfcrypt/src/ecc.c ****     }
4743:../src/wolfcrypt/src/ecc.c ****     /* z must be 1 */
4744:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
4745:../src/wolfcrypt/src/ecc.c ****         if (!mp_isone(p->z))
4746:../src/wolfcrypt/src/ecc.c ****             err = ECC_BAD_ARG_E;
4747:../src/wolfcrypt/src/ecc.c ****     }
4748:../src/wolfcrypt/src/ecc.c **** 
4749:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
4750:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_is_point(p, curve->Af, curve->Bf, curve->prime);
4751:../src/wolfcrypt/src/ecc.c ****     }
4752:../src/wolfcrypt/src/ecc.c **** 
4753:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
4754:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
4755:../src/wolfcrypt/src/ecc.c **** 
4756:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
4757:../src/wolfcrypt/src/ecc.c **** 
4758:../src/wolfcrypt/src/ecc.c ****     return err;
4759:../src/wolfcrypt/src/ecc.c **** }
4760:../src/wolfcrypt/src/ecc.c **** #endif /* USE_ECC_B_PARAM */
4761:../src/wolfcrypt/src/ecc.c **** 
4762:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
4763:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLF_CRYPTO_CB_ONLY_ECC)
4764:../src/wolfcrypt/src/ecc.c **** /* return 1 if point is at infinity, 0 if not, < 0 on error */
4765:../src/wolfcrypt/src/ecc.c **** int wc_ecc_point_is_at_infinity(ecc_point* p)
4766:../src/wolfcrypt/src/ecc.c **** {
 7003                             		.loc 2 4766 1
 7004 0000 7E AA                   		push.l	r10
 7005                             	.LCFI110:
 7006 0002 71 0A FC                		add	#-4, r0, r10
 7007                             	.LCFI111:
 7008 0005 EF A0                   		mov.L	r10, r0
 7009 0007 E3 A1                   		mov.L	r1, [r10]
4767:../src/wolfcrypt/src/ecc.c ****     if (p == NULL)
 7010                             		.loc 2 4767 8
 7011 0009 EC A5                   		mov.L	[r10], r5
 7012 000b 61 05                   		cmp	#0, r5
 7013 000d 1F                      		bne	.L479
4768:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 7014                             		.loc 2 4768 16
 7015 000e FB 5A 53 FF             		mov.L	#-173, r5
 7016 0012 2E 17                   		bra	.L480
 7017                             	.L479:
4769:../src/wolfcrypt/src/ecc.c ****     if (mp_iszero(p->x) && mp_iszero(p->y))
 7018                             		.loc 2 4769 9
 7019 0014 EC A5                   		mov.L	[r10], r5
 7020 0016 EC 55                   		mov.L	[r5], r5
 7021                             		.loc 2 4769 8
 7022 0018 61 05                   		cmp	#0, r5
 7023 001a 21 0D                   		bne	.L481
 7024                             		.loc 2 4769 28 discriminator 1
 7025 001c EC A5                   		mov.L	[r10], r5
 7026 001e ED 55 C4                		mov.L	784[r5], r5
 7027                             		.loc 2 4769 25 discriminator 1
 7028 0021 61 05                   		cmp	#0, r5
 7029 0023 1C                      		bne	.L481
4770:../src/wolfcrypt/src/ecc.c ****         return 1;
 7030                             		.loc 2 4770 16
 7031 0024 66 15                   		mov.L	#1, r5
 7032 0026 0B                      		bra	.L480
 7033                             	.L481:
4771:../src/wolfcrypt/src/ecc.c **** 
4772:../src/wolfcrypt/src/ecc.c ****     return 0;
 7034                             		.loc 2 4772 12
 7035 0027 66 05                   		mov.L	#0, r5
 7036                             	.L480:
4773:../src/wolfcrypt/src/ecc.c **** }
 7037                             		.loc 2 4773 1
 7038 0029 EF 51                   		mov.L	r5, r1
 7039 002b 3F AA 02                		rtsd	#8, r10-r10
 7040                             	.LFE87:
 7042                             		.section	.text.wc_ecc_gen_k,"ax",@progbits
 7043                             		.global	_wc_ecc_gen_k
 7045                             	_wc_ecc_gen_k:
 7046                             	.LFB88:
4774:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL */
4775:../src/wolfcrypt/src/ecc.c **** 
4776:../src/wolfcrypt/src/ecc.c **** /* generate random and ensure its greater than 0 and less than order */
4777:../src/wolfcrypt/src/ecc.c **** int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)
4778:../src/wolfcrypt/src/ecc.c **** {
 7047                             		.loc 2 4778 1
 7048 0000 7E AA                   		push.l	r10
 7049                             	.LCFI112:
 7050 0002 71 0A A0                		add	#-96, r0, r10
 7051                             	.LCFI113:
 7052 0005 EF A0                   		mov.L	r10, r0
 7053 0007 E7 A1 14                		mov.L	r1, 80[r10]
 7054 000a E7 A2 15                		mov.L	r2, 84[r10]
 7055 000d E7 A3 16                		mov.L	r3, 88[r10]
 7056 0010 E7 A4 17                		mov.L	r4, 92[r10]
4779:../src/wolfcrypt/src/ecc.c **** #ifndef WC_NO_RNG
4780:../src/wolfcrypt/src/ecc.c ****     int err;
4781:../src/wolfcrypt/src/ecc.c ****     byte buf[ECC_MAXSIZE_GEN];
4782:../src/wolfcrypt/src/ecc.c **** 
4783:../src/wolfcrypt/src/ecc.c ****     if (rng == NULL || size + 8 > ECC_MAXSIZE_GEN || k == NULL ||
 7057                             		.loc 2 4783 8
 7058 0013 ED A5 14                		mov.L	80[r10], r5
 7059 0016 61 05                   		cmp	#0, r5
 7060 0018 20 18                   		beq	.L483
 7061                             		.loc 2 4783 21 discriminator 1
 7062 001a ED A5 15                		mov.L	84[r10], r5
 7063 001d 75 55 42                		cmp	#0x42, r5
 7064 0020 2A 10                   		bgt	.L483
 7065                             		.loc 2 4783 51 discriminator 2
 7066 0022 ED A5 16                		mov.L	88[r10], r5
 7067 0025 61 05                   		cmp	#0, r5
 7068 0027 11                      		beq	.L483
 7069                             		.loc 2 4783 64 discriminator 3
 7070 0028 ED A5 17                		mov.L	92[r10], r5
 7071 002b 61 05                   		cmp	#0, r5
 7072 002d 19                      		bne	.L484
 7073 002e EF 00                   		.balign 8,3,2
 7074                             	.L483:
4784:../src/wolfcrypt/src/ecc.c ****                                                                 order == NULL) {
4785:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 7075                             		.loc 2 4785 16
 7076 0030 FB 5A 53 FF             		mov.L	#-173, r5
 7077 0034 2E 7B                   		bra	.L489
 7078                             	.L484:
4786:../src/wolfcrypt/src/ecc.c ****     }
4787:../src/wolfcrypt/src/ecc.c **** 
4788:../src/wolfcrypt/src/ecc.c ****     /* generate 8 extra bytes to mitigate bias from the modulo operation below */
4789:../src/wolfcrypt/src/ecc.c ****     /* see section A.1.2 in 'Suite B Implementor's Guide to FIPS 186-3 (ECDSA)' */
4790:../src/wolfcrypt/src/ecc.c ****     size += 8;
 7079                             		.loc 2 4790 10
 7080 0036 ED A5 15                		mov.L	84[r10], r5
 7081 0039 62 85                   		add	#8, r5
 7082 003b E7 A5 15                		mov.L	r5, 84[r10]
4791:../src/wolfcrypt/src/ecc.c **** 
4792:../src/wolfcrypt/src/ecc.c ****     /* make up random string */
4793:../src/wolfcrypt/src/ecc.c ****     err = wc_RNG_GenerateBlock(rng, buf, size);
 7083                             		.loc 2 4793 11
 7084 003e ED A4 15                		mov.L	84[r10], r4
 7085 0041 71 A5 04                		add	#4, r10, r5
 7086 0044 EF 43                   		mov.L	r4, r3
 7087 0046 EF 52                   		mov.L	r5, r2
 7088 0048 ED A1 14                		mov.L	80[r10], r1
 7089 004b 05 00 00 00             		bsr	_wc_RNG_GenerateBlock
 7090 004f E3 A1                   		mov.L	r1, [r10]
4794:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
4795:../src/wolfcrypt/src/ecc.c ****     wc_MemZero_Add("wc_ecc_gen_k buf", buf, size);
4796:../src/wolfcrypt/src/ecc.c **** #endif
4797:../src/wolfcrypt/src/ecc.c **** 
4798:../src/wolfcrypt/src/ecc.c ****     /* load random buffer data into k */
4799:../src/wolfcrypt/src/ecc.c ****     if (err == 0)
 7091                             		.loc 2 4799 8
 7092 0051 EC A5                   		mov.L	[r10], r5
 7093 0053 61 05                   		cmp	#0, r5
 7094 0055 21 15                   		bne	.L486
4800:../src/wolfcrypt/src/ecc.c ****         err = mp_read_unsigned_bin(k, buf, size);
 7095                             		.loc 2 4800 15
 7096 0057 ED A4 15                		mov.L	84[r10], r4
 7097 005a 71 A5 04                		add	#4, r10, r5
 7098 005d EF 43                   		mov.L	r4, r3
 7099 005f EF 52                   		mov.L	r5, r2
 7100 0061 ED A1 16                		mov.L	88[r10], r1
 7101 0064 05 00 00 00             		bsr	_sp_read_unsigned_bin
 7102 0068 E3 A1                   		mov.L	r1, [r10]
 7103                             	.L486:
4801:../src/wolfcrypt/src/ecc.c **** 
4802:../src/wolfcrypt/src/ecc.c ****     /* the key should be smaller than the order of base point */
4803:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 7104                             		.loc 2 4803 8
 7105 006a EC A5                   		mov.L	[r10], r5
 7106 006c 61 05                   		cmp	#0, r5
 7107 006e 21 22                   		bne	.L487
4804:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp(k, order) != MP_LT) {
 7108                             		.loc 2 4804 13
 7109 0070 ED A2 17                		mov.L	92[r10], r2
 7110 0073 ED A1 16                		mov.L	88[r10], r1
 7111 0076 05 00 00 00             		bsr	_sp_cmp
 7112 007a EF 15                   		mov.L	r1, r5
 7113                             		.loc 2 4804 12
 7114 007c 75 05 FF                		cmp	#-1, r5
 7115 007f 20 11                   		beq	.L487
4805:../src/wolfcrypt/src/ecc.c ****             err = mp_mod(k, order, k);
 7116                             		.loc 2 4805 19
 7117 0081 ED A3 16                		mov.L	88[r10], r3
 7118 0084 ED A2 17                		mov.L	92[r10], r2
 7119 0087 ED A1 16                		mov.L	88[r10], r1
 7120 008a 05 00 00 00             		bsr	_sp_mod
 7121 008e E3 A1                   		mov.L	r1, [r10]
 7122                             	.L487:
4806:../src/wolfcrypt/src/ecc.c ****         }
4807:../src/wolfcrypt/src/ecc.c ****     }
4808:../src/wolfcrypt/src/ecc.c **** 
4809:../src/wolfcrypt/src/ecc.c ****     /* quick sanity check to make sure we're not dealing with a 0 key */
4810:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 7123                             		.loc 2 4810 8
 7124 0090 EC A5                   		mov.L	[r10], r5
 7125 0092 61 05                   		cmp	#0, r5
 7126 0094 21 0D                   		bne	.L488
4811:../src/wolfcrypt/src/ecc.c ****         if (mp_iszero(k) == MP_YES)
 7127                             		.loc 2 4811 13
 7128 0096 ED A5 16                		mov.L	88[r10], r5
 7129 0099 EC 55                   		mov.L	[r5], r5
 7130                             		.loc 2 4811 12
 7131 009b 61 05                   		cmp	#0, r5
 7132 009d 1C                      		bne	.L488
4812:../src/wolfcrypt/src/ecc.c ****           err = MP_ZERO_E;
 7133                             		.loc 2 4812 15
 7134 009e F8 A6 87                		mov.L	#-121, [r10]
 7135                             	.L488:
4813:../src/wolfcrypt/src/ecc.c ****     }
4814:../src/wolfcrypt/src/ecc.c **** 
4815:../src/wolfcrypt/src/ecc.c ****     ForceZero(buf, ECC_MAXSIZE_GEN);
 7136                             		.loc 2 4815 5
 7137 00a1 71 A5 04                		add	#4, r10, r5
 7138 00a4 75 42 4A                		mov.L	#0x4a, r2
 7139 00a7 EF 51                   		mov.L	r5, r1
 7140 00a9 05 00 00 00             		bsr	_ForceZero
4816:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
4817:../src/wolfcrypt/src/ecc.c ****     wc_MemZero_Check(buf, ECC_MAXSIZE_GEN);
4818:../src/wolfcrypt/src/ecc.c **** #endif
4819:../src/wolfcrypt/src/ecc.c **** 
4820:../src/wolfcrypt/src/ecc.c ****     return err;
 7141                             		.loc 2 4820 12
 7142 00ad EC A5                   		mov.L	[r10], r5
 7143                             	.L489:
4821:../src/wolfcrypt/src/ecc.c **** #else
4822:../src/wolfcrypt/src/ecc.c ****     (void)rng;
4823:../src/wolfcrypt/src/ecc.c ****     (void)size;
4824:../src/wolfcrypt/src/ecc.c ****     (void)k;
4825:../src/wolfcrypt/src/ecc.c ****     (void)order;
4826:../src/wolfcrypt/src/ecc.c ****     return NOT_COMPILED_IN;
4827:../src/wolfcrypt/src/ecc.c **** #endif /* !WC_NO_RNG */
4828:../src/wolfcrypt/src/ecc.c **** }
 7144                             		.loc 2 4828 1 discriminator 1
 7145 00af EF 51                   		mov.L	r5, r1
 7146 00b1 3F AA 19                		rtsd	#100, r10-r10
 7147                             	.LFE88:
 7149 00b4 76 10 01 00             		.section	.text.wc_ecc_reset,"ax",@progbits
 7151                             	_wc_ecc_reset:
 7152                             	.LFB89:
4829:../src/wolfcrypt/src/ecc.c **** 
4830:../src/wolfcrypt/src/ecc.c **** static WC_INLINE void wc_ecc_reset(ecc_key* key)
4831:../src/wolfcrypt/src/ecc.c **** {
 7153                             		.loc 2 4831 1
 7154 0000 7E AA                   		push.l	r10
 7155                             	.LCFI114:
 7156 0002 71 0A FC                		add	#-4, r0, r10
 7157                             	.LCFI115:
 7158 0005 EF A0                   		mov.L	r10, r0
 7159 0007 E3 A1                   		mov.L	r1, [r10]
4832:../src/wolfcrypt/src/ecc.c ****     /* make sure required key variables are reset */
4833:../src/wolfcrypt/src/ecc.c ****     key->state = ECC_STATE_NONE;
 7160                             		.loc 2 4833 16
 7161 0009 EC A5                   		mov.L	[r10], r5
 7162 000b 3E 52 00                		mov.L	#0, 8[r5]
4834:../src/wolfcrypt/src/ecc.c **** }
 7163                             		.loc 2 4834 1
 7164 000e 03                      		nop
 7165 000f 3F AA 02                		rtsd	#8, r10-r10
 7166                             	.LFE89:
 7168                             		.section	.text.ecc_make_pub_ex,"ax",@progbits
 7170                             	_ecc_make_pub_ex:
 7171                             	.LFB90:
4835:../src/wolfcrypt/src/ecc.c **** 
4836:../src/wolfcrypt/src/ecc.c **** /* create the public ECC key from a private key
4837:../src/wolfcrypt/src/ecc.c ****  *
4838:../src/wolfcrypt/src/ecc.c ****  * key     an initialized private key to generate public part from
4839:../src/wolfcrypt/src/ecc.c ****  * curveIn [in]curve for key, can be NULL
4840:../src/wolfcrypt/src/ecc.c ****  * pubOut  [out]ecc_point holding the public key, if NULL then public key part
4841:../src/wolfcrypt/src/ecc.c ****  *         is cached in key instead.
4842:../src/wolfcrypt/src/ecc.c ****  *
4843:../src/wolfcrypt/src/ecc.c ****  * Note this function is local to the file because of the argument type
4844:../src/wolfcrypt/src/ecc.c ****  *      ecc_curve_spec. Having this argument allows for not having to load the
4845:../src/wolfcrypt/src/ecc.c ****  *      curve type multiple times when generating a key with wc_ecc_make_key().
4846:../src/wolfcrypt/src/ecc.c ****  * For async the results are placed directly into pubOut, so this function
4847:../src/wolfcrypt/src/ecc.c ****  *      does not need to be called again
4848:../src/wolfcrypt/src/ecc.c ****  *
4849:../src/wolfcrypt/src/ecc.c ****  * returns MP_OKAY on success
4850:../src/wolfcrypt/src/ecc.c ****  */
4851:../src/wolfcrypt/src/ecc.c **** static int ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curveIn,
4852:../src/wolfcrypt/src/ecc.c ****         ecc_point* pubOut, WC_RNG* rng)
4853:../src/wolfcrypt/src/ecc.c **** {
 7172                             		.loc 2 4853 1
 7173 0000 7E AA                   		push.l	r10
 7174                             	.LCFI116:
 7175 0002 7E A6                   		push.l	r6
 7176                             	.LCFI117:
 7177 0004 71 0A AC                		add	#-84, r0, r10
 7178                             	.LCFI118:
 7179 0007 71 A0 EC                		add	#-20, r10, r0
 7180                             	.LCFI119:
 7181 000a E7 A1 11                		mov.L	r1, 68[r10]
 7182 000d E7 A2 12                		mov.L	r2, 72[r10]
 7183 0010 E7 A3 13                		mov.L	r3, 76[r10]
 7184 0013 E7 A4 14                		mov.L	r4, 80[r10]
4854:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 7185                             		.loc 2 4854 9
 7186 0016 F8 A6 00                		mov.L	#0, [r10]
4855:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_MAKE_PUB
4856:../src/wolfcrypt/src/ecc.c ****     ecc_point* pub;
4857:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
 7187                             		.loc 2 4857 5
 7188 0019 F9 A6 02 00             		mov.L	#0, 8[r10]
 7189 001d 71 A5 10                		add	#16, r10, r5
 7190 0020 E7 A5 0E                		mov.L	r5, 56[r10]
 7191 0023 ED A5 0E                		mov.L	56[r10], r5
 7192 0026 75 43 28                		mov.L	#40, r3
 7193 0029 66 02                   		mov.L	#0, r2
 7194 002b EF 51                   		mov.L	r5, r1
 7195 002d 05 00 00 00             		bsr	_memset
 7196 0031 ED A5 0E                		mov.L	56[r10], r5
 7197 0034 3E 57 05                		mov.L	#5, 28[r5]
4858:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_MAKE_PUB */
4859:../src/wolfcrypt/src/ecc.c **** 
4860:../src/wolfcrypt/src/ecc.c ****     (void)rng;
4861:../src/wolfcrypt/src/ecc.c **** 
4862:../src/wolfcrypt/src/ecc.c ****     if (key == NULL) {
 7198                             		.loc 2 4862 8
 7199 0037 ED A5 11                		mov.L	68[r10], r5
 7200 003a 61 05                   		cmp	#0, r5
 7201 003c 18                      		bne	.L492
4863:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 7202                             		.loc 2 4863 16
 7203 003d FB 5A 53 FF             		mov.L	#-173, r5
 7204 0041 38 18 02                		bra	.L513
 7205                             	.L492:
4864:../src/wolfcrypt/src/ecc.c ****     }
4865:../src/wolfcrypt/src/ecc.c **** 
4866:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
4867:../src/wolfcrypt/src/ecc.c **** 
4868:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_MAKE_PUB
4869:../src/wolfcrypt/src/ecc.c ****     /* if ecc_point passed in then use it as output for public key point */
4870:../src/wolfcrypt/src/ecc.c ****     if (pubOut != NULL) {
 7206                             		.loc 2 4870 8
 7207 0044 ED A5 13                		mov.L	76[r10], r5
 7208 0047 61 05                   		cmp	#0, r5
 7209 0049 11                      		beq	.L494
4871:../src/wolfcrypt/src/ecc.c ****         pub = pubOut;
 7210                             		.loc 2 4871 13
 7211 004a ED A5 13                		mov.L	76[r10], r5
 7212 004d E7 A5 01                		mov.L	r5, 4[r10]
 7213 0050 2E 11                   		bra	.L495
 7214                             	.L494:
4872:../src/wolfcrypt/src/ecc.c ****     }
4873:../src/wolfcrypt/src/ecc.c ****     else {
4874:../src/wolfcrypt/src/ecc.c ****         /* caching public key making it a ECC_PRIVATEKEY instead of
4875:../src/wolfcrypt/src/ecc.c ****            ECC_PRIVATEKEY_ONLY */
4876:../src/wolfcrypt/src/ecc.c ****         pub = &key->pubkey;
 7215                             		.loc 2 4876 13
 7216 0052 ED A5 11                		mov.L	68[r10], r5
 7217 0055 71 55 18                		add	#24, r5
 7218 0058 E7 A5 01                		mov.L	r5, 4[r10]
4877:../src/wolfcrypt/src/ecc.c ****         key->type = ECC_PRIVATEKEY_ONLY;
 7219                             		.loc 2 4877 19
 7220 005b ED A5 11                		mov.L	68[r10], r5
 7221 005e F8 56 03                		mov.L	#3, [r5]
 7222                             	.L495:
4878:../src/wolfcrypt/src/ecc.c ****     }
4879:../src/wolfcrypt/src/ecc.c **** 
4880:../src/wolfcrypt/src/ecc.c ****     /* avoid loading the curve unless it is not passed in */
4881:../src/wolfcrypt/src/ecc.c ****     if (curveIn != NULL) {
 7223                             		.loc 2 4881 8
 7224 0061 ED A5 12                		mov.L	72[r10], r5
 7225 0064 61 05                   		cmp	#0, r5
 7226 0066 11                      		beq	.L496
4882:../src/wolfcrypt/src/ecc.c ****         curve = curveIn;
 7227                             		.loc 2 4882 15
 7228 0067 ED A5 12                		mov.L	72[r10], r5
 7229 006a E7 A5 0E                		mov.L	r5, 56[r10]
 7230 006d 2E 40                   		bra	.L497
 7231                             	.L496:
4883:../src/wolfcrypt/src/ecc.c ****     }
4884:../src/wolfcrypt/src/ecc.c ****     else {
4885:../src/wolfcrypt/src/ecc.c ****         /* load curve info */
4886:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 7232                             		.loc 2 4886 12
 7233 006f EC A5                   		mov.L	[r10], r5
 7234 0071 61 05                   		cmp	#0, r5
 7235 0073 21 1F                   		bne	.L498
4887:../src/wolfcrypt/src/ecc.c ****             ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 7236                             		.loc 2 4887 13
 7237 0075 FB 1A 50 0F             		mov.L	#0xf50, r1
 7238 0079 05 00 00 00             		bsr	_wolfSSL_Malloc
 7239 007d E7 A1 02                		mov.L	r1, 8[r10]
 7240 0080 ED A5 02                		mov.L	8[r10], r5
 7241 0083 61 05                   		cmp	#0, r5
 7242 0085 1D                      		bne	.L499
 7243                             		.loc 2 4887 13 is_stmt 0 discriminator 1
 7244 0086 F8 A6 83                		mov.L	#-125, [r10]
 7245 0089 09                      		bra	.L498
 7246                             	.L499:
 7247                             		.loc 2 4887 13 discriminator 2
 7248 008a ED A5 0E                		mov.L	56[r10], r5
 7249 008d ED A4 02                		mov.L	8[r10], r4
 7250 0090 A1 D4                   		mov.L	r4, 24[r5]
 7251                             	.L498:
4888:../src/wolfcrypt/src/ecc.c ****         }
4889:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 7252                             		.loc 2 4889 12 is_stmt 1
 7253 0092 EC A5                   		mov.L	[r10], r5
 7254 0094 61 05                   		cmp	#0, r5
 7255 0096 21 17                   		bne	.L497
4890:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 7256                             		.loc 2 4890 19
 7257 0098 ED A5 11                		mov.L	68[r10], r5
 7258 009b A9 54                   		mov.L	16[r5], r4
 7259 009d 71 A5 38                		add	#56, r10, r5
 7260 00a0 75 43 3B                		mov	#59, r3
 7261 00a3 EF 52                   		mov.L	r5, r2
 7262 00a5 EF 41                   		mov.L	r4, r1
 7263 00a7 05 00 00 00             		bsr	_wc_ecc_curve_load
 7264 00ab E3 A1                   		mov.L	r1, [r10]
 7265                             	.L497:
4891:../src/wolfcrypt/src/ecc.c ****         }
4892:../src/wolfcrypt/src/ecc.c ****     }
4893:../src/wolfcrypt/src/ecc.c **** 
4894:../src/wolfcrypt/src/ecc.c ****     if ((err == MP_OKAY) && (mp_iszero(&key->k) || mp_isneg(&key->k) ||
 7266                             		.loc 2 4894 8
 7267 00ad EC A5                   		mov.L	[r10], r5
 7268 00af 61 05                   		cmp	#0, r5
 7269 00b1 21 2B                   		bne	.L500
 7270                             		.loc 2 4894 30 discriminator 1
 7271 00b3 ED A5 11                		mov.L	68[r10], r5
 7272 00b6 EE 55 52 02             		mov.L	2376[r5], r5
 7273                             		.loc 2 4894 26 discriminator 1
 7274 00ba 61 05                   		cmp	#0, r5
 7275 00bc 20 1C                   		beq	.L501
4895:../src/wolfcrypt/src/ecc.c ****                                       (mp_cmp(&key->k, curve->order) != MP_LT)))
 7276                             		.loc 2 4895 47 discriminator 2
 7277 00be ED A5 11                		mov.L	68[r10], r5
 7278 00c1 72 54 48 09             		add	#0x948, r5, r4
 7279                             		.loc 2 4895 61 discriminator 2
 7280 00c5 ED A5 0E                		mov.L	56[r10], r5
 7281 00c8 A8 DD                   		mov.L	12[r5], r5
 7282                             		.loc 2 4895 40 discriminator 2
 7283 00ca EF 52                   		mov.L	r5, r2
 7284 00cc EF 41                   		mov.L	r4, r1
 7285 00ce 05 00 00 00             		bsr	_sp_cmp
 7286 00d2 EF 15                   		mov.L	r1, r5
4894:../src/wolfcrypt/src/ecc.c ****                                       (mp_cmp(&key->k, curve->order) != MP_LT)))
 7287                             		.loc 2 4894 70 discriminator 2
 7288 00d4 75 05 FF                		cmp	#-1, r5
 7289 00d7 15                      		beq	.L500
 7290                             	.L501:
4896:../src/wolfcrypt/src/ecc.c ****     {
4897:../src/wolfcrypt/src/ecc.c ****         err = ECC_PRIV_KEY_E;
 7291                             		.loc 2 4897 13
 7292 00d8 F8 AA 28 FF             		mov.L	#-216, [r10]
 7293                             	.L500:
4898:../src/wolfcrypt/src/ecc.c ****     }
4899:../src/wolfcrypt/src/ecc.c **** 
4900:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 7294                             		.loc 2 4900 8
 7295 00dc EC A5                   		mov.L	[r10], r5
 7296 00de 61 05                   		cmp	#0, r5
 7297 00e0 21 23                   		bne	.L502
4901:../src/wolfcrypt/src/ecc.c ****     #ifndef ALT_ECC_SIZE
4902:../src/wolfcrypt/src/ecc.c ****         err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);
 7298                             		.loc 2 4902 32
 7299 00e2 ED A1 01                		mov.L	4[r10], r1
 7300                             		.loc 2 4902 40
 7301 00e5 ED A5 01                		mov.L	4[r10], r5
 7302 00e8 72 52 10 03             		add	#0x310, r5, r2
 7303                             		.loc 2 4902 48
 7304 00ec ED A5 01                		mov.L	4[r10], r5
 7305 00ef 72 55 20 06             		add	#0x620, r5
 7306                             		.loc 2 4902 15
 7307 00f3 3E 01 00                		mov.L	#0, 4[r0]
 7308 00f6 F8 06 00                		mov.L	#0, [r0]
 7309 00f9 66 04                   		mov.L	#0, r4
 7310 00fb EF 53                   		mov.L	r5, r3
 7311 00fd 05 00 00 00             		bsr	_sp_init_multi
 7312 0101 E3 A1                   		mov.L	r1, [r10]
 7313                             	.L502:
4903:../src/wolfcrypt/src/ecc.c ****     #else
4904:../src/wolfcrypt/src/ecc.c ****         pub->x = (mp_int*)&pub->xyz[0];
4905:../src/wolfcrypt/src/ecc.c ****         pub->y = (mp_int*)&pub->xyz[1];
4906:../src/wolfcrypt/src/ecc.c ****         pub->z = (mp_int*)&pub->xyz[2];
4907:../src/wolfcrypt/src/ecc.c ****         alt_fp_init(pub->x);
4908:../src/wolfcrypt/src/ecc.c ****         alt_fp_init(pub->y);
4909:../src/wolfcrypt/src/ecc.c ****         alt_fp_init(pub->z);
4910:../src/wolfcrypt/src/ecc.c ****     #endif
4911:../src/wolfcrypt/src/ecc.c ****     }
4912:../src/wolfcrypt/src/ecc.c **** 
4913:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC) && \
4914:../src/wolfcrypt/src/ecc.c ****     defined(HAVE_INTEL_QA)
4915:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY && key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
4916:../src/wolfcrypt/src/ecc.c ****         word32 keySz = key->dp->size;
4917:../src/wolfcrypt/src/ecc.c ****         /* sync private key to raw */
4918:../src/wolfcrypt/src/ecc.c ****         err = wc_mp_to_bigint_sz(&key->k, &key->k.raw, keySz);
4919:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
4920:../src/wolfcrypt/src/ecc.c ****             err = IntelQaEccPointMul(&key->asyncDev,
4921:../src/wolfcrypt/src/ecc.c ****                 &key->k.raw, pub->x, pub->y, pub->z,
4922:../src/wolfcrypt/src/ecc.c ****                 &curve->Gx->raw, &curve->Gy->raw,
4923:../src/wolfcrypt/src/ecc.c ****                 &curve->Af->raw, &curve->Bf->raw, &curve->prime->raw,
4924:../src/wolfcrypt/src/ecc.c ****                 key->dp->cofactor);
4925:../src/wolfcrypt/src/ecc.c ****         }
4926:../src/wolfcrypt/src/ecc.c ****     }
4927:../src/wolfcrypt/src/ecc.c ****     else
4928:../src/wolfcrypt/src/ecc.c **** #endif
4929:../src/wolfcrypt/src/ecc.c ****     { /* BEGIN: Software Crypto */
4930:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
4931:../src/wolfcrypt/src/ecc.c ****     /* Single-Precision Math (optimized for specific curves) */
4932:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY) {
4933:../src/wolfcrypt/src/ecc.c ****     }
4934:../src/wolfcrypt/src/ecc.c ****     else
4935:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
4936:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {
4937:../src/wolfcrypt/src/ecc.c ****         err = sp_ecc_mulmod_base_256(&key->k, pub, 1, key->heap);
4938:../src/wolfcrypt/src/ecc.c ****     }
4939:../src/wolfcrypt/src/ecc.c ****     else
4940:../src/wolfcrypt/src/ecc.c **** #endif
4941:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
4942:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP384R1) {
4943:../src/wolfcrypt/src/ecc.c ****         err = sp_ecc_mulmod_base_384(&key->k, pub, 1, key->heap);
4944:../src/wolfcrypt/src/ecc.c ****     }
4945:../src/wolfcrypt/src/ecc.c ****     else
4946:../src/wolfcrypt/src/ecc.c **** #endif
4947:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
4948:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP521R1) {
4949:../src/wolfcrypt/src/ecc.c ****         err = sp_ecc_mulmod_base_521(&key->k, pub, 1, key->heap);
4950:../src/wolfcrypt/src/ecc.c ****     }
4951:../src/wolfcrypt/src/ecc.c ****     else
4952:../src/wolfcrypt/src/ecc.c **** #endif
4953:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_HAVE_SP_ECC */
4954:../src/wolfcrypt/src/ecc.c **** 
4955:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_SP_MATH)
4956:../src/wolfcrypt/src/ecc.c ****         err = WC_KEY_SIZE_E;
4957:../src/wolfcrypt/src/ecc.c **** #else
4958:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 7314                             		.loc 2 4958 8
 7315 0103 EC A5                   		mov.L	[r10], r5
 7316 0105 61 05                   		cmp	#0, r5
 7317 0107 3B EF 00                		bne	.L503
 7318                             	.LBB38:
4959:../src/wolfcrypt/src/ecc.c ****         /* Multi-Precision Math: compute public curve */
4960:../src/wolfcrypt/src/ecc.c ****         mp_digit mp = 0;
 7319                             		.loc 2 4960 18
 7320 010a F9 A6 0F 00             		mov.L	#0, 60[r10]
4961:../src/wolfcrypt/src/ecc.c ****         ecc_point* base = NULL;
 7321                             		.loc 2 4961 20
 7322 010e F9 A6 10 00             		mov.L	#0, 64[r10]
4962:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_NO_MALLOC
4963:../src/wolfcrypt/src/ecc.c ****         ecc_point  lcl_base;
4964:../src/wolfcrypt/src/ecc.c ****         base = &lcl_base;
4965:../src/wolfcrypt/src/ecc.c ****     #endif
4966:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_new_point_ex(&base, key->heap);
 7323                             		.loc 2 4966 15
 7324 0112 ED A5 11                		mov.L	68[r10], r5
 7325 0115 A9 5C                   		mov.L	20[r5], r4
 7326 0117 71 A5 40                		add	#0x40, r10, r5
 7327 011a EF 42                   		mov.L	r4, r2
 7328 011c EF 51                   		mov.L	r5, r1
 7329 011e 05 00 00 00             		bsr	_wc_ecc_new_point_ex
 7330 0122 E3 A1                   		mov.L	r1, [r10]
4967:../src/wolfcrypt/src/ecc.c **** 
4968:../src/wolfcrypt/src/ecc.c ****         /* read in the x/y for this key */
4969:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 7331                             		.loc 2 4969 12
 7332 0124 EC A5                   		mov.L	[r10], r5
 7333 0126 61 05                   		cmp	#0, r5
 7334 0128 21 14                   		bne	.L504
4970:../src/wolfcrypt/src/ecc.c ****             err = mp_copy(curve->Gx, base->x);
 7335                             		.loc 2 4970 32
 7336 012a ED A5 0E                		mov.L	56[r10], r5
 7337 012d A9 55                   		mov.L	16[r5], r5
 7338                             		.loc 2 4970 42
 7339 012f ED A4 10                		mov.L	64[r10], r4
 7340                             		.loc 2 4970 19
 7341 0132 EF 42                   		mov.L	r4, r2
 7342 0134 EF 51                   		mov.L	r5, r1
 7343 0136 05 00 00 00             		bsr	_sp_copy
 7344 013a E3 A1                   		mov.L	r1, [r10]
 7345                             	.L504:
4971:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 7346                             		.loc 2 4971 12
 7347 013c EC A5                   		mov.L	[r10], r5
 7348 013e 61 05                   		cmp	#0, r5
 7349 0140 21 18                   		bne	.L505
4972:../src/wolfcrypt/src/ecc.c ****             err = mp_copy(curve->Gy, base->y);
 7350                             		.loc 2 4972 32
 7351 0142 ED A5 0E                		mov.L	56[r10], r5
 7352 0145 A9 5C                   		mov.L	20[r5], r4
 7353                             		.loc 2 4972 42
 7354 0147 ED A5 10                		mov.L	64[r10], r5
 7355 014a 72 55 10 03             		add	#0x310, r5
 7356                             		.loc 2 4972 19
 7357 014e EF 52                   		mov.L	r5, r2
 7358 0150 EF 41                   		mov.L	r4, r1
 7359 0152 05 00 00 00             		bsr	_sp_copy
 7360 0156 E3 A1                   		mov.L	r1, [r10]
 7361                             	.L505:
4973:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 7362                             		.loc 2 4973 12
 7363 0158 EC A5                   		mov.L	[r10], r5
 7364 015a 61 05                   		cmp	#0, r5
 7365 015c 21 14                   		bne	.L506
4974:../src/wolfcrypt/src/ecc.c ****             err = mp_montgomery_setup(curve->prime, &mp);
 7366                             		.loc 2 4974 44
 7367 015e ED A5 0E                		mov.L	56[r10], r5
 7368 0161 A8 5C                   		mov.L	4[r5], r4
 7369                             		.loc 2 4974 19
 7370 0163 71 A5 3C                		add	#60, r10, r5
 7371 0166 EF 52                   		mov.L	r5, r2
 7372 0168 EF 41                   		mov.L	r4, r1
 7373 016a 05 00 00 00             		bsr	_sp_mont_setup
 7374 016e E3 A1                   		mov.L	r1, [r10]
 7375                             	.L506:
4975:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 7376                             		.loc 2 4975 12
 7377 0170 EC A5                   		mov.L	[r10], r5
 7378 0172 61 05                   		cmp	#0, r5
 7379 0174 21 13                   		bne	.L507
4976:../src/wolfcrypt/src/ecc.c ****             err = mp_set(base->z, 1);
 7380                             		.loc 2 4976 30
 7381 0176 ED A5 10                		mov.L	64[r10], r5
 7382 0179 72 55 20 06             		add	#0x620, r5
 7383                             		.loc 2 4976 19
 7384 017d 66 12                   		mov.L	#1, r2
 7385 017f EF 51                   		mov.L	r5, r1
 7386 0181 05 00 00 00             		bsr	_sp_set
 7387 0185 E3 A1                   		mov.L	r1, [r10]
 7388                             	.L507:
4977:../src/wolfcrypt/src/ecc.c **** 
4978:../src/wolfcrypt/src/ecc.c ****         /* make the public key */
4979:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 7389                             		.loc 2 4979 12
 7390 0187 EC A5                   		mov.L	[r10], r5
 7391 0189 61 05                   		cmp	#0, r5
 7392 018b 21 40                   		bne	.L508
4980:../src/wolfcrypt/src/ecc.c ****             /* Map in a separate call as this should be constant time */
4981:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_mulmod_ex2(&key->k, base, pub, curve->Af, curve->prime,
 7393                             		.loc 2 4981 37
 7394 018d ED A5 11                		mov.L	68[r10], r5
 7395 0190 72 51 48 09             		add	#0x948, r5, r1
 7396                             		.loc 2 4981 19
 7397 0194 ED A2 10                		mov.L	64[r10], r2
 7398                             		.loc 2 4981 62
 7399 0197 ED A5 0E                		mov.L	56[r10], r5
 7400                             		.loc 2 4981 19
 7401 019a A8 D4                   		mov.L	8[r5], r4
 7402                             		.loc 2 4981 73
 7403 019c ED A5 0E                		mov.L	56[r10], r5
 7404                             		.loc 2 4981 19
 7405 019f A8 5B                   		mov.L	4[r5], r3
4982:../src/wolfcrypt/src/ecc.c ****                                                curve->order, rng, 0, key->heap);
 7406                             		.loc 2 4982 53
 7407 01a1 ED A5 0E                		mov.L	56[r10], r5
4981:../src/wolfcrypt/src/ecc.c ****                                                curve->order, rng, 0, key->heap);
 7408                             		.loc 2 4981 19
 7409 01a4 A8 DE                   		mov.L	12[r5], r6
 7410 01a6 ED A5 11                		mov.L	68[r10], r5
 7411 01a9 A9 5D                   		mov.L	20[r5], r5
 7412 01ab A1 05                   		mov.L	r5, 16[r0]
 7413 01ad 3E 03 00                		mov.L	#0, 12[r0]
 7414 01b0 ED A5 14                		mov.L	80[r10], r5
 7415 01b3 A0 85                   		mov.L	r5, 8[r0]
 7416 01b5 A0 0E                   		mov.L	r6, 4[r0]
 7417 01b7 E3 03                   		mov.L	r3, [r0]
 7418 01b9 ED A3 01                		mov.L	4[r10], r3
 7419 01bc 05 00 00 00             		bsr	_wc_ecc_mulmod_ex2
 7420 01c0 E3 A1                   		mov.L	r1, [r10]
4983:../src/wolfcrypt/src/ecc.c ****             if (err == MP_MEM) {
 7421                             		.loc 2 4983 16
 7422 01c2 EC A5                   		mov.L	[r10], r5
 7423 01c4 75 05 FE                		cmp	#-2, r5
 7424 01c7 1C                      		bne	.L508
4984:../src/wolfcrypt/src/ecc.c ****                err = MEMORY_E;
 7425                             		.loc 2 4984 20
 7426 01c8 F8 A6 83                		mov.L	#-125, [r10]
 7427                             	.L508:
4985:../src/wolfcrypt/src/ecc.c ****             }
4986:../src/wolfcrypt/src/ecc.c ****         }
4987:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 7428                             		.loc 2 4987 12
 7429 01cb EC A5                   		mov.L	[r10], r5
 7430 01cd 61 05                   		cmp	#0, r5
 7431 01cf 21 17                   		bne	.L509
4988:../src/wolfcrypt/src/ecc.c ****             /* Use constant time map if compiled in */
4989:../src/wolfcrypt/src/ecc.c ****             err = ecc_map_ex(pub, curve->prime, mp, 1);
 7432                             		.loc 2 4989 40
 7433 01d1 ED A5 0E                		mov.L	56[r10], r5
 7434                             		.loc 2 4989 19
 7435 01d4 A8 5D                   		mov.L	4[r5], r5
 7436 01d6 ED A3 0F                		mov.L	60[r10], r3
 7437 01d9 66 14                   		mov.L	#1, r4
 7438 01db EF 52                   		mov.L	r5, r2
 7439 01dd ED A1 01                		mov.L	4[r10], r1
 7440 01e0 05 00 00 00             		bsr	_ecc_map_ex
 7441 01e4 E3 A1                   		mov.L	r1, [r10]
 7442                             	.L509:
4990:../src/wolfcrypt/src/ecc.c ****         }
4991:../src/wolfcrypt/src/ecc.c **** 
4992:../src/wolfcrypt/src/ecc.c ****         wc_ecc_del_point_ex(base, key->heap);
 7443                             		.loc 2 4992 9
 7444 01e6 ED A4 10                		mov.L	64[r10], r4
 7445 01e9 ED A5 11                		mov.L	68[r10], r5
 7446 01ec A9 5D                   		mov.L	20[r5], r5
 7447 01ee EF 52                   		mov.L	r5, r2
 7448 01f0 EF 41                   		mov.L	r4, r1
 7449 01f2 05 00 00 00             		bsr	_wc_ecc_del_point_ex
 7450                             	.L503:
 7451                             	.LBE38:
4993:../src/wolfcrypt/src/ecc.c ****     }
4994:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SP_MATH */
4995:../src/wolfcrypt/src/ecc.c ****     } /* END: Software Crypto */
4996:../src/wolfcrypt/src/ecc.c **** 
4997:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY
 7452                             		.loc 2 4997 8
 7453 01f6 EC A5                   		mov.L	[r10], r5
 7454 01f8 61 05                   		cmp	#0, r5
 7455 01fa 20 25                   		beq	.L510
4998:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_ASYNC_CRYPT
4999:../src/wolfcrypt/src/ecc.c ****         && err != WC_PENDING_E
5000:../src/wolfcrypt/src/ecc.c ****     #endif
5001:../src/wolfcrypt/src/ecc.c ****     ) {
5002:../src/wolfcrypt/src/ecc.c ****         /* clean up if failed */
5003:../src/wolfcrypt/src/ecc.c ****     #ifndef ALT_ECC_SIZE
5004:../src/wolfcrypt/src/ecc.c ****         mp_clear(pub->x);
 7456                             		.loc 2 5004 21
 7457 01fc ED A5 01                		mov.L	4[r10], r5
 7458                             		.loc 2 5004 9
 7459 01ff EF 51                   		mov.L	r5, r1
 7460 0201 05 00 00 00             		bsr	_sp_clear
5005:../src/wolfcrypt/src/ecc.c ****         mp_clear(pub->y);
 7461                             		.loc 2 5005 21
 7462 0205 ED A5 01                		mov.L	4[r10], r5
 7463 0208 72 55 10 03             		add	#0x310, r5
 7464                             		.loc 2 5005 9
 7465 020c EF 51                   		mov.L	r5, r1
 7466 020e 05 00 00 00             		bsr	_sp_clear
5006:../src/wolfcrypt/src/ecc.c ****         mp_clear(pub->z);
 7467                             		.loc 2 5006 21
 7468 0212 ED A5 01                		mov.L	4[r10], r5
 7469 0215 72 55 20 06             		add	#0x620, r5
 7470                             		.loc 2 5006 9
 7471 0219 EF 51                   		mov.L	r5, r1
 7472 021b 05 00 00 00             		bsr	_sp_clear
 7473                             	.L510:
5007:../src/wolfcrypt/src/ecc.c ****     #endif
5008:../src/wolfcrypt/src/ecc.c ****     }
5009:../src/wolfcrypt/src/ecc.c **** 
5010:../src/wolfcrypt/src/ecc.c ****     /* free up local curve */
5011:../src/wolfcrypt/src/ecc.c ****     if (curveIn == NULL) {
 7474                             		.loc 2 5011 8
 7475 021f ED A5 12                		mov.L	72[r10], r5
 7476 0222 61 05                   		cmp	#0, r5
 7477 0224 21 1E                   		bne	.L511
5012:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_free(curve);
 7478                             		.loc 2 5012 9
 7479 0226 ED A5 0E                		mov.L	56[r10], r5
 7480 0229 EF 51                   		mov.L	r5, r1
 7481 022b 05 00 00 00             		bsr	_wc_ecc_curve_free
 7482                             	.LBB39:
5013:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
 7483                             		.loc 2 5013 9
 7484 022f ED A5 02                		mov.L	8[r10], r5
 7485 0232 E7 A5 03                		mov.L	r5, 12[r10]
 7486 0235 ED A5 03                		mov.L	12[r10], r5
 7487 0238 61 05                   		cmp	#0, r5
 7488 023a 10                      		beq	.L511
 7489                             		.loc 2 5013 9 is_stmt 0 discriminator 1
 7490 023b ED A1 03                		mov.L	12[r10], r1
 7491 023e 05 00 00 00             		bsr	_wolfSSL_Free
 7492                             	.L511:
 7493                             	.LBE39:
5014:../src/wolfcrypt/src/ecc.c ****     }
5015:../src/wolfcrypt/src/ecc.c **** 
5016:../src/wolfcrypt/src/ecc.c **** #else
5017:../src/wolfcrypt/src/ecc.c ****     /* Using hardware crypto, that does not support ecc_make_pub_ex */
5018:../src/wolfcrypt/src/ecc.c ****     (void)curveIn;
5019:../src/wolfcrypt/src/ecc.c ****     err = NOT_COMPILED_IN;
5020:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_MAKE_PUB */
5021:../src/wolfcrypt/src/ecc.c **** 
5022:../src/wolfcrypt/src/ecc.c ****     /* change key state if public part is cached */
5023:../src/wolfcrypt/src/ecc.c ****     if (key->type == ECC_PRIVATEKEY_ONLY && pubOut == NULL) {
 7494                             		.loc 2 5023 12 is_stmt 1
 7495 0242 ED A5 11                		mov.L	68[r10], r5
 7496 0245 EC 55                   		mov.L	[r5], r5
 7497                             		.loc 2 5023 8
 7498 0247 61 35                   		cmp	#3, r5
 7499 0249 21 0E                   		bne	.L512
 7500                             		.loc 2 5023 42 discriminator 1
 7501 024b ED A5 13                		mov.L	76[r10], r5
 7502 024e 61 05                   		cmp	#0, r5
 7503 0250 1F                      		bne	.L512
5024:../src/wolfcrypt/src/ecc.c ****         key->type = ECC_PRIVATEKEY;
 7504                             		.loc 2 5024 19
 7505 0251 ED A5 11                		mov.L	68[r10], r5
 7506 0254 F8 56 02                		mov.L	#2, [r5]
 7507                             	.L512:
5025:../src/wolfcrypt/src/ecc.c ****     }
5026:../src/wolfcrypt/src/ecc.c **** 
5027:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
5028:../src/wolfcrypt/src/ecc.c **** 
5029:../src/wolfcrypt/src/ecc.c ****     return err;
 7508                             		.loc 2 5029 12
 7509 0257 EC A5                   		mov.L	[r10], r5
 7510                             	.L513:
5030:../src/wolfcrypt/src/ecc.c **** }
 7511                             		.loc 2 5030 1 discriminator 1
 7512 0259 EF 51                   		mov.L	r5, r1
 7513 025b 71 00 68                		add	#0x68, r0
 7514 025e 7E B6                   		pop	r6
 7515 0260 7E BA                   		pop	r10
 7516 0262 02                      		rts
 7517                             	.LFE90:
 7519                             		.section C,"a",@progbits
 7520 0a5d 00 00 00                		.p2align 2
 7521                             	.LC40:
 7522 0a60 77 63 5F 65 63 63 5F 6D 		.string	"wc_ecc_make_pub"
 7522      61 6B 65 5F 70 75 62 00 
 7523                             		.section	.text.wc_ecc_make_pub,"ax",@progbits
 7524                             		.global	_wc_ecc_make_pub
 7526                             	_wc_ecc_make_pub:
 7527                             	.LFB91:
5031:../src/wolfcrypt/src/ecc.c **** 
5032:../src/wolfcrypt/src/ecc.c **** 
5033:../src/wolfcrypt/src/ecc.c **** /* create the public ECC key from a private key
5034:../src/wolfcrypt/src/ecc.c ****  *
5035:../src/wolfcrypt/src/ecc.c ****  * key     an initialized private key to generate public part from
5036:../src/wolfcrypt/src/ecc.c ****  * pubOut  [out]ecc_point holding the public key, if NULL then public key part
5037:../src/wolfcrypt/src/ecc.c ****  *         is cached in key instead.
5038:../src/wolfcrypt/src/ecc.c ****  *
5039:../src/wolfcrypt/src/ecc.c ****  *
5040:../src/wolfcrypt/src/ecc.c ****  * returns MP_OKAY on success
5041:../src/wolfcrypt/src/ecc.c ****  */
5042:../src/wolfcrypt/src/ecc.c **** int wc_ecc_make_pub(ecc_key* key, ecc_point* pubOut)
5043:../src/wolfcrypt/src/ecc.c **** {
 7528                             		.loc 2 5043 1
 7529 0000 7E AA                   		push.l	r10
 7530                             	.LCFI120:
 7531 0002 71 0A F8                		add	#-8, r0, r10
 7532                             	.LCFI121:
 7533 0005 EF A0                   		mov.L	r10, r0
 7534 0007 E3 A1                   		mov.L	r1, [r10]
 7535 0009 E7 A2 01                		mov.L	r2, 4[r10]
5044:../src/wolfcrypt/src/ecc.c ****     WOLFSSL_ENTER("wc_ecc_make_pub");
 7536                             		.loc 2 5044 5
 7537 000c FB 12 60 0A 00 00       		mov.L	#.LC40, r1
 7538 0012 05 00 00 00             		bsr	_WOLFSSL_ENTER
5045:../src/wolfcrypt/src/ecc.c **** 
5046:../src/wolfcrypt/src/ecc.c ****     return ecc_make_pub_ex(key, NULL, pubOut, NULL);
 7539                             		.loc 2 5046 12
 7540 0016 66 04                   		mov.L	#0, r4
 7541 0018 ED A3 01                		mov.L	4[r10], r3
 7542 001b 66 02                   		mov.L	#0, r2
 7543 001d EC A1                   		mov.L	[r10], r1
 7544 001f 05 00 00 00             		bsr	_ecc_make_pub_ex
 7545 0023 EF 15                   		mov.L	r1, r5
5047:../src/wolfcrypt/src/ecc.c **** }
 7546                             		.loc 2 5047 1
 7547 0025 EF 51                   		mov.L	r5, r1
 7548 0027 3F AA 03                		rtsd	#12, r10-r10
 7549                             	.LFE91:
 7551                             		.section	.text.wc_ecc_make_pub_ex,"ax",@progbits
 7552                             		.global	_wc_ecc_make_pub_ex
 7554                             	_wc_ecc_make_pub_ex:
 7555                             	.LFB92:
5048:../src/wolfcrypt/src/ecc.c **** 
5049:../src/wolfcrypt/src/ecc.c **** /* create the public ECC key from a private key - mask timing use random z
5050:../src/wolfcrypt/src/ecc.c ****  *
5051:../src/wolfcrypt/src/ecc.c ****  * key     an initialized private key to generate public part from
5052:../src/wolfcrypt/src/ecc.c ****  * pubOut  [out]ecc_point holding the public key, if NULL then public key part
5053:../src/wolfcrypt/src/ecc.c ****  *         is cached in key instead.
5054:../src/wolfcrypt/src/ecc.c ****  *
5055:../src/wolfcrypt/src/ecc.c ****  *
5056:../src/wolfcrypt/src/ecc.c ****  * returns MP_OKAY on success
5057:../src/wolfcrypt/src/ecc.c ****  */
5058:../src/wolfcrypt/src/ecc.c **** int wc_ecc_make_pub_ex(ecc_key* key, ecc_point* pubOut, WC_RNG* rng)
5059:../src/wolfcrypt/src/ecc.c **** {
 7556                             		.loc 2 5059 1
 7557 0000 7E AA                   		push.l	r10
 7558                             	.LCFI122:
 7559 0002 71 0A F4                		add	#-12, r0, r10
 7560                             	.LCFI123:
 7561 0005 EF A0                   		mov.L	r10, r0
 7562 0007 E3 A1                   		mov.L	r1, [r10]
 7563 0009 E7 A2 01                		mov.L	r2, 4[r10]
 7564 000c E7 A3 02                		mov.L	r3, 8[r10]
5060:../src/wolfcrypt/src/ecc.c ****     WOLFSSL_ENTER("wc_ecc_make_pub");
 7565                             		.loc 2 5060 5
 7566 000f FB 12 60 0A 00 00       		mov.L	#.LC40, r1
 7567 0015 05 00 00 00             		bsr	_WOLFSSL_ENTER
5061:../src/wolfcrypt/src/ecc.c **** 
5062:../src/wolfcrypt/src/ecc.c ****     return ecc_make_pub_ex(key, NULL, pubOut, rng);
 7568                             		.loc 2 5062 12
 7569 0019 ED A4 02                		mov.L	8[r10], r4
 7570 001c ED A3 01                		mov.L	4[r10], r3
 7571 001f 66 02                   		mov.L	#0, r2
 7572 0021 EC A1                   		mov.L	[r10], r1
 7573 0023 05 00 00 00             		bsr	_ecc_make_pub_ex
 7574 0027 EF 15                   		mov.L	r1, r5
5063:../src/wolfcrypt/src/ecc.c **** }
 7575                             		.loc 2 5063 1
 7576 0029 EF 51                   		mov.L	r5, r1
 7577 002b 3F AA 04                		rtsd	#16, r10-r10
 7578                             	.LFE92:
 7580                             		.section	.text._ecc_make_key_ex,"ax",@progbits
 7582                             	__ecc_make_key_ex:
 7583                             	.LFB93:
5064:../src/wolfcrypt/src/ecc.c **** 
5065:../src/wolfcrypt/src/ecc.c **** 
5066:../src/wolfcrypt/src/ecc.c **** static int _ecc_make_key_ex(WC_RNG* rng, int keysize, ecc_key* key,
5067:../src/wolfcrypt/src/ecc.c ****         int curve_id, int flags)
5068:../src/wolfcrypt/src/ecc.c **** {
 7584                             		.loc 2 5068 1
 7585 0000 7E AA                   		push.l	r10
 7586                             	.LCFI124:
 7587 0002 7E A6                   		push.l	r6
 7588                             	.LCFI125:
 7589 0004 71 0A B4                		add	#-76, r0, r10
 7590                             	.LCFI126:
 7591 0007 EF A0                   		mov.L	r10, r0
 7592 0009 75 46 58                		mov.L	#0x58, r6
 7593 000c 4B A6                   		add	r10, r6
 7594 000e E7 A1 0E                		mov.L	r1, 56[r10]
 7595 0011 E7 A2 0F                		mov.L	r2, 60[r10]
 7596 0014 E7 A3 10                		mov.L	r3, 64[r10]
 7597 0017 E7 A4 11                		mov.L	r4, 68[r10]
5069:../src/wolfcrypt/src/ecc.c ****     int err = 0;
 7598                             		.loc 2 5069 9
 7599 001a F8 A6 00                		mov.L	#0, [r10]
5070:../src/wolfcrypt/src/ecc.c **** #if defined(HAVE_ECC_MAKE_PUB) && !defined(WOLFSSL_SP_MATH)
5071:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
 7600                             		.loc 2 5071 5
 7601 001d F9 A6 01 00             		mov.L	#0, 4[r10]
 7602 0021 71 A5 0C                		add	#12, r10, r5
 7603 0024 E7 A5 0D                		mov.L	r5, 52[r10]
 7604 0027 ED A5 0D                		mov.L	52[r10], r5
 7605 002a 75 43 28                		mov.L	#40, r3
 7606 002d 66 02                   		mov.L	#0, r2
 7607 002f EF 51                   		mov.L	r5, r1
 7608 0031 05 00 00 00             		bsr	_memset
 7609 0035 ED A5 0D                		mov.L	52[r10], r5
 7610 0038 3E 57 05                		mov.L	#5, 28[r5]
5072:../src/wolfcrypt/src/ecc.c **** #endif
5073:../src/wolfcrypt/src/ecc.c **** 
5074:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_ATECC508A) && \
5075:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_ATECC608A)
5076:../src/wolfcrypt/src/ecc.c ****     const CRYS_ECPKI_Domain_t*  pDomain;
5077:../src/wolfcrypt/src/ecc.c ****     CRYS_ECPKI_KG_TempData_t    tempBuff;
5078:../src/wolfcrypt/src/ecc.c ****     CRYS_ECPKI_KG_FipsContext_t fipsCtx;
5079:../src/wolfcrypt/src/ecc.c ****     byte ucompressed_key[ECC_MAX_CRYPTO_HW_SIZE*2 + 1];
5080:../src/wolfcrypt/src/ecc.c ****     word32 raw_size = 0;
5081:../src/wolfcrypt/src/ecc.c **** #endif
5082:../src/wolfcrypt/src/ecc.c ****     if (key == NULL || rng == NULL) {
 7611                             		.loc 2 5082 8
 7612 003b ED A5 10                		mov.L	64[r10], r5
 7613 003e 61 05                   		cmp	#0, r5
 7614 0040 17                      		beq	.L519
 7615                             		.loc 2 5082 21 discriminator 1
 7616 0041 ED A5 0E                		mov.L	56[r10], r5
 7617 0044 61 05                   		cmp	#0, r5
 7618 0046 18                      		bne	.L520
 7619                             	.L519:
5083:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 7620                             		.loc 2 5083 16
 7621 0047 FB 5A 53 FF             		mov.L	#-173, r5
 7622 004b 38 EC 00                		bra	.L531
 7623                             	.L520:
5084:../src/wolfcrypt/src/ecc.c ****     }
5085:../src/wolfcrypt/src/ecc.c **** 
5086:../src/wolfcrypt/src/ecc.c ****     /* make sure required variables are reset */
5087:../src/wolfcrypt/src/ecc.c ****     wc_ecc_reset(key);
 7624                             		.loc 2 5087 5
 7625 004e ED A1 10                		mov.L	64[r10], r1
 7626 0051 05 00 00 00             		bsr	_wc_ecc_reset
5088:../src/wolfcrypt/src/ecc.c **** 
5089:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_set_curve(key, keysize, curve_id);
 7627                             		.loc 2 5089 11
 7628 0055 ED A3 11                		mov.L	68[r10], r3
 7629 0058 ED A2 0F                		mov.L	60[r10], r2
 7630 005b ED A1 10                		mov.L	64[r10], r1
 7631 005e 05 00 00 00             		bsr	_wc_ecc_set_curve
 7632 0062 E3 A1                   		mov.L	r1, [r10]
5090:../src/wolfcrypt/src/ecc.c ****     if (err != 0) {
 7633                             		.loc 2 5090 8
 7634 0064 EC A5                   		mov.L	[r10], r5
 7635 0066 61 05                   		cmp	#0, r5
 7636 0068 16                      		beq	.L522
5091:../src/wolfcrypt/src/ecc.c ****         return err;
 7637                             		.loc 2 5091 16
 7638 0069 EC A5                   		mov.L	[r10], r5
 7639 006b 38 CC 00                		bra	.L531
 7640                             	.L522:
5092:../src/wolfcrypt/src/ecc.c ****     }
5093:../src/wolfcrypt/src/ecc.c **** 
5094:../src/wolfcrypt/src/ecc.c ****     key->flags = flags;
 7641                             		.loc 2 5094 16
 7642 006e EC 64                   		mov.L	[r6], r4
 7643 0070 ED A5 10                		mov.L	64[r10], r5
 7644 0073 A0 DC                   		mov.L	r4, 12[r5]
5095:../src/wolfcrypt/src/ecc.c **** 
5096:../src/wolfcrypt/src/ecc.c **** #ifdef WOLF_CRYPTO_CB
5097:../src/wolfcrypt/src/ecc.c ****     if (key->devId != INVALID_DEVID) {
5098:../src/wolfcrypt/src/ecc.c ****         err = wc_CryptoCb_MakeEccKey(rng, keysize, key, curve_id);
5099:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLF_CRYPTO_CB_ONLY_ECC
5100:../src/wolfcrypt/src/ecc.c ****         if (err != CRYPTOCB_UNAVAILABLE)
5101:../src/wolfcrypt/src/ecc.c ****             return err;
5102:../src/wolfcrypt/src/ecc.c ****         /* fall-through when unavailable */
5103:../src/wolfcrypt/src/ecc.c ****     #else
5104:../src/wolfcrypt/src/ecc.c ****         return err;
5105:../src/wolfcrypt/src/ecc.c ****     #endif
5106:../src/wolfcrypt/src/ecc.c ****     }
5107:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLF_CRYPTO_CB_ONLY_ECC
5108:../src/wolfcrypt/src/ecc.c ****     else {
5109:../src/wolfcrypt/src/ecc.c ****         return NO_VALID_DEVID;
5110:../src/wolfcrypt/src/ecc.c ****     }
5111:../src/wolfcrypt/src/ecc.c ****     #endif
5112:../src/wolfcrypt/src/ecc.c **** #endif
5113:../src/wolfcrypt/src/ecc.c **** 
5114:../src/wolfcrypt/src/ecc.c **** #ifndef WOLF_CRYPTO_CB_ONLY_ECC
5115:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
5116:../src/wolfcrypt/src/ecc.c ****     if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
5117:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_CAVIUM
5118:../src/wolfcrypt/src/ecc.c ****         /* TODO: Not implemented */
5119:../src/wolfcrypt/src/ecc.c ****     #elif defined(HAVE_INTEL_QA)
5120:../src/wolfcrypt/src/ecc.c ****         /* Implemented in ecc_make_pub_ex for the pub calc */
5121:../src/wolfcrypt/src/ecc.c ****     #else
5122:../src/wolfcrypt/src/ecc.c ****         if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_ECC_MAKE)) {
5123:../src/wolfcrypt/src/ecc.c ****             WC_ASYNC_TEST* testDev = &key->asyncDev.test;
5124:../src/wolfcrypt/src/ecc.c ****             testDev->eccMake.rng = rng;
5125:../src/wolfcrypt/src/ecc.c ****             testDev->eccMake.key = key;
5126:../src/wolfcrypt/src/ecc.c ****             testDev->eccMake.size = keysize;
5127:../src/wolfcrypt/src/ecc.c ****             testDev->eccMake.curve_id = curve_id;
5128:../src/wolfcrypt/src/ecc.c ****             return WC_PENDING_E;
5129:../src/wolfcrypt/src/ecc.c ****         }
5130:../src/wolfcrypt/src/ecc.c ****     #endif
5131:../src/wolfcrypt/src/ecc.c ****     }
5132:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */
5133:../src/wolfcrypt/src/ecc.c **** 
5134:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
5135:../src/wolfcrypt/src/ecc.c ****    if (key->dp->id == ECC_SECP256R1) {
5136:../src/wolfcrypt/src/ecc.c ****        key->type = ECC_PRIVATEKEY;
5137:../src/wolfcrypt/src/ecc.c ****        key->slot = atmel_ecc_alloc(ATMEL_SLOT_ECDHE);
5138:../src/wolfcrypt/src/ecc.c ****        err = atmel_ecc_create_key(key->slot, key->pubkey_raw);
5139:../src/wolfcrypt/src/ecc.c **** 
5140:../src/wolfcrypt/src/ecc.c ****        /* populate key->pubkey */
5141:../src/wolfcrypt/src/ecc.c ****        if (err == 0
5142:../src/wolfcrypt/src/ecc.c ****        #ifdef ALT_ECC_SIZE
5143:../src/wolfcrypt/src/ecc.c ****           && key->pubkey.x
5144:../src/wolfcrypt/src/ecc.c ****        #endif
5145:../src/wolfcrypt/src/ecc.c ****        ) {
5146:../src/wolfcrypt/src/ecc.c ****            err = mp_read_unsigned_bin(key->pubkey.x, key->pubkey_raw,
5147:../src/wolfcrypt/src/ecc.c ****                                       ECC_MAX_CRYPTO_HW_SIZE);
5148:../src/wolfcrypt/src/ecc.c ****        }
5149:../src/wolfcrypt/src/ecc.c ****        if (err == 0
5150:../src/wolfcrypt/src/ecc.c ****        #ifdef ALT_ECC_SIZE
5151:../src/wolfcrypt/src/ecc.c ****           && key->pubkey.y
5152:../src/wolfcrypt/src/ecc.c ****        #endif
5153:../src/wolfcrypt/src/ecc.c ****        ) {
5154:../src/wolfcrypt/src/ecc.c ****            err = mp_read_unsigned_bin(key->pubkey.y,
5155:../src/wolfcrypt/src/ecc.c ****                                       key->pubkey_raw + ECC_MAX_CRYPTO_HW_SIZE,
5156:../src/wolfcrypt/src/ecc.c ****                                       ECC_MAX_CRYPTO_HW_SIZE);
5157:../src/wolfcrypt/src/ecc.c ****        }
5158:../src/wolfcrypt/src/ecc.c ****    }
5159:../src/wolfcrypt/src/ecc.c ****    else {
5160:../src/wolfcrypt/src/ecc.c ****       err = NOT_COMPILED_IN;
5161:../src/wolfcrypt/src/ecc.c ****    }
5162:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SE050)
5163:../src/wolfcrypt/src/ecc.c ****     err = se050_ecc_create_key(key, key->dp->id, key->dp->size);
5164:../src/wolfcrypt/src/ecc.c ****     key->type = ECC_PRIVATEKEY;
5165:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CRYPTOCELL)
5166:../src/wolfcrypt/src/ecc.c **** 
5167:../src/wolfcrypt/src/ecc.c ****     pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(key->dp->id));
5168:../src/wolfcrypt/src/ecc.c ****     raw_size = (word32)(key->dp->size)*2 + 1;
5169:../src/wolfcrypt/src/ecc.c **** 
5170:../src/wolfcrypt/src/ecc.c ****     /* generate first key pair */
5171:../src/wolfcrypt/src/ecc.c ****     err = CRYS_ECPKI_GenKeyPair(&wc_rndState,
5172:../src/wolfcrypt/src/ecc.c ****                                 wc_rndGenVectFunc,
5173:../src/wolfcrypt/src/ecc.c ****                                 pDomain,
5174:../src/wolfcrypt/src/ecc.c ****                                 &key->ctx.privKey,
5175:../src/wolfcrypt/src/ecc.c ****                                 &key->ctx.pubKey,
5176:../src/wolfcrypt/src/ecc.c ****                                 &tempBuff,
5177:../src/wolfcrypt/src/ecc.c ****                                 &fipsCtx);
5178:../src/wolfcrypt/src/ecc.c **** 
5179:../src/wolfcrypt/src/ecc.c ****     if (err != SA_SILIB_RET_OK){
5180:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("CRYS_ECPKI_GenKeyPair for key pair failed");
5181:../src/wolfcrypt/src/ecc.c ****         return err;
5182:../src/wolfcrypt/src/ecc.c ****     }
5183:../src/wolfcrypt/src/ecc.c ****     key->type = ECC_PRIVATEKEY;
5184:../src/wolfcrypt/src/ecc.c **** 
5185:../src/wolfcrypt/src/ecc.c ****     err = CRYS_ECPKI_ExportPublKey(&key->ctx.pubKey,
5186:../src/wolfcrypt/src/ecc.c ****                                    CRYS_EC_PointUncompressed,
5187:../src/wolfcrypt/src/ecc.c ****                                    &ucompressed_key[0],
5188:../src/wolfcrypt/src/ecc.c ****                                    (uint32_t*)&raw_size);
5189:../src/wolfcrypt/src/ecc.c **** 
5190:../src/wolfcrypt/src/ecc.c ****     if (err == SA_SILIB_RET_OK && key->pubkey.x && key->pubkey.y) {
5191:../src/wolfcrypt/src/ecc.c ****         err = mp_read_unsigned_bin(key->pubkey.x,
5192:../src/wolfcrypt/src/ecc.c ****                                    &ucompressed_key[1], key->dp->size);
5193:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
5194:../src/wolfcrypt/src/ecc.c ****             err = mp_read_unsigned_bin(key->pubkey.y,
5195:../src/wolfcrypt/src/ecc.c ****                             &ucompressed_key[1+key->dp->size],key->dp->size);
5196:../src/wolfcrypt/src/ecc.c ****         }
5197:../src/wolfcrypt/src/ecc.c ****     }
5198:../src/wolfcrypt/src/ecc.c ****     raw_size = key->dp->size;
5199:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
5200:../src/wolfcrypt/src/ecc.c ****         err = CRYS_ECPKI_ExportPrivKey(&key->ctx.privKey,
5201:../src/wolfcrypt/src/ecc.c ****                                        ucompressed_key,
5202:../src/wolfcrypt/src/ecc.c ****                                        (uint32_t*)&raw_size);
5203:../src/wolfcrypt/src/ecc.c ****     }
5204:../src/wolfcrypt/src/ecc.c **** 
5205:../src/wolfcrypt/src/ecc.c ****     if (err == SA_SILIB_RET_OK) {
5206:../src/wolfcrypt/src/ecc.c ****         err = mp_read_unsigned_bin(&key->k, ucompressed_key, raw_size);
5207:../src/wolfcrypt/src/ecc.c ****     }
5208:../src/wolfcrypt/src/ecc.c **** 
5209:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
5210:../src/wolfcrypt/src/ecc.c ****     return silabs_ecc_make_key(key, keysize);
5211:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_KCAPI_ECC)
5212:../src/wolfcrypt/src/ecc.c **** 
5213:../src/wolfcrypt/src/ecc.c ****     err = KcapiEcc_MakeKey(key, keysize, curve_id);
5214:../src/wolfcrypt/src/ecc.c ****     (void)rng;
5215:../src/wolfcrypt/src/ecc.c **** 
5216:../src/wolfcrypt/src/ecc.c **** #else
5217:../src/wolfcrypt/src/ecc.c **** 
5218:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
5219:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
5220:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {
5221:../src/wolfcrypt/src/ecc.c ****         err = sp_ecc_make_key_256(rng, &key->k, &key->pubkey, key->heap);
5222:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
5223:../src/wolfcrypt/src/ecc.c ****             key->type = ECC_PRIVATEKEY;
5224:../src/wolfcrypt/src/ecc.c ****         }
5225:../src/wolfcrypt/src/ecc.c ****     }
5226:../src/wolfcrypt/src/ecc.c ****     else
5227:../src/wolfcrypt/src/ecc.c **** #endif
5228:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
5229:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP384R1) {
5230:../src/wolfcrypt/src/ecc.c ****         err = sp_ecc_make_key_384(rng, &key->k, &key->pubkey, key->heap);
5231:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
5232:../src/wolfcrypt/src/ecc.c ****             key->type = ECC_PRIVATEKEY;
5233:../src/wolfcrypt/src/ecc.c ****         }
5234:../src/wolfcrypt/src/ecc.c ****     }
5235:../src/wolfcrypt/src/ecc.c ****     else
5236:../src/wolfcrypt/src/ecc.c **** #endif
5237:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
5238:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP521R1) {
5239:../src/wolfcrypt/src/ecc.c ****         err = sp_ecc_make_key_521(rng, &key->k, &key->pubkey, key->heap);
5240:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
5241:../src/wolfcrypt/src/ecc.c ****             key->type = ECC_PRIVATEKEY;
5242:../src/wolfcrypt/src/ecc.c ****         }
5243:../src/wolfcrypt/src/ecc.c ****     }
5244:../src/wolfcrypt/src/ecc.c ****     else
5245:../src/wolfcrypt/src/ecc.c **** #endif
5246:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_HAVE_SP_ECC */
5247:../src/wolfcrypt/src/ecc.c **** 
5248:../src/wolfcrypt/src/ecc.c ****    { /* software key gen */
5249:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_SP_MATH)
5250:../src/wolfcrypt/src/ecc.c ****         err = WC_KEY_SIZE_E;
5251:../src/wolfcrypt/src/ecc.c **** #else
5252:../src/wolfcrypt/src/ecc.c **** 
5253:../src/wolfcrypt/src/ecc.c ****         /* setup the key variables */
5254:../src/wolfcrypt/src/ecc.c ****         err = mp_init(&key->k);
 7645                             		.loc 2 5254 23
 7646 0075 ED A5 10                		mov.L	64[r10], r5
 7647 0078 72 55 48 09             		add	#0x948, r5
 7648                             		.loc 2 5254 15
 7649 007c EF 51                   		mov.L	r5, r1
 7650 007e 05 00 00 00             		bsr	_sp_init
 7651 0082 E3 A1                   		mov.L	r1, [r10]
5255:../src/wolfcrypt/src/ecc.c **** 
5256:../src/wolfcrypt/src/ecc.c ****         /* load curve info */
5257:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 7652                             		.loc 2 5257 12
 7653 0084 EC A5                   		mov.L	[r10], r5
 7654 0086 61 05                   		cmp	#0, r5
 7655 0088 21 1F                   		bne	.L523
5258:../src/wolfcrypt/src/ecc.c ****             ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 7656                             		.loc 2 5258 13
 7657 008a FB 1A 50 0F             		mov.L	#0xf50, r1
 7658 008e 05 00 00 00             		bsr	_wolfSSL_Malloc
 7659 0092 E7 A1 01                		mov.L	r1, 4[r10]
 7660 0095 ED A5 01                		mov.L	4[r10], r5
 7661 0098 61 05                   		cmp	#0, r5
 7662 009a 1D                      		bne	.L524
 7663                             		.loc 2 5258 13 is_stmt 0 discriminator 1
 7664 009b F8 A6 83                		mov.L	#-125, [r10]
 7665 009e 09                      		bra	.L523
 7666                             	.L524:
 7667                             		.loc 2 5258 13 discriminator 2
 7668 009f ED A5 0D                		mov.L	52[r10], r5
 7669 00a2 ED A4 01                		mov.L	4[r10], r4
 7670 00a5 A1 D4                   		mov.L	r4, 24[r5]
 7671                             	.L523:
5259:../src/wolfcrypt/src/ecc.c ****         }
5260:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 7672                             		.loc 2 5260 12 is_stmt 1
 7673 00a7 EC A5                   		mov.L	[r10], r5
 7674 00a9 61 05                   		cmp	#0, r5
 7675 00ab 21 17                   		bne	.L525
5261:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 7676                             		.loc 2 5261 19
 7677 00ad ED A5 10                		mov.L	64[r10], r5
 7678 00b0 A9 54                   		mov.L	16[r5], r4
 7679 00b2 71 A5 34                		add	#52, r10, r5
 7680 00b5 75 43 3B                		mov	#59, r3
 7681 00b8 EF 52                   		mov.L	r5, r2
 7682 00ba EF 41                   		mov.L	r4, r1
 7683 00bc 05 00 00 00             		bsr	_wc_ecc_curve_load
 7684 00c0 E3 A1                   		mov.L	r1, [r10]
 7685                             	.L525:
5262:../src/wolfcrypt/src/ecc.c ****         }
5263:../src/wolfcrypt/src/ecc.c **** 
5264:../src/wolfcrypt/src/ecc.c ****         /* generate k */
5265:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 7686                             		.loc 2 5265 12
 7687 00c2 EC A5                   		mov.L	[r10], r5
 7688 00c4 61 05                   		cmp	#0, r5
 7689 00c6 21 20                   		bne	.L526
5266:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_gen_k(rng, key->dp->size, &key->k, curve->order);
 7690                             		.loc 2 5266 40
 7691 00c8 ED A5 10                		mov.L	64[r10], r5
 7692 00cb A9 55                   		mov.L	16[r5], r5
 7693                             		.loc 2 5266 19
 7694 00cd EC 52                   		mov.L	[r5], r2
 7695 00cf ED A5 10                		mov.L	64[r10], r5
 7696 00d2 72 53 48 09             		add	#0x948, r5, r3
 7697                             		.loc 2 5266 66
 7698 00d6 ED A5 0D                		mov.L	52[r10], r5
 7699                             		.loc 2 5266 19
 7700 00d9 A8 DD                   		mov.L	12[r5], r5
 7701 00db EF 54                   		mov.L	r5, r4
 7702 00dd ED A1 0E                		mov.L	56[r10], r1
 7703 00e0 05 00 00 00             		bsr	_wc_ecc_gen_k
 7704 00e4 E3 A1                   		mov.L	r1, [r10]
 7705                             	.L526:
5267:../src/wolfcrypt/src/ecc.c ****         }
5268:../src/wolfcrypt/src/ecc.c **** 
5269:../src/wolfcrypt/src/ecc.c ****         /* generate public key from k */
5270:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
 7706                             		.loc 2 5270 12
 7707 00e6 EC A5                   		mov.L	[r10], r5
 7708 00e8 61 05                   		cmp	#0, r5
 7709 00ea 21 15                   		bne	.L527
5271:../src/wolfcrypt/src/ecc.c ****             err = ecc_make_pub_ex(key, curve, NULL, rng);
 7710                             		.loc 2 5271 19
 7711 00ec ED A5 0D                		mov.L	52[r10], r5
 7712 00ef ED A4 0E                		mov.L	56[r10], r4
 7713 00f2 66 03                   		mov.L	#0, r3
 7714 00f4 EF 52                   		mov.L	r5, r2
 7715 00f6 ED A1 10                		mov.L	64[r10], r1
 7716 00f9 05 00 00 00             		bsr	_ecc_make_pub_ex
 7717 00fd E3 A1                   		mov.L	r1, [r10]
 7718                             	.L527:
5272:../src/wolfcrypt/src/ecc.c ****         }
5273:../src/wolfcrypt/src/ecc.c **** 
5274:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY
 7719                             		.loc 2 5274 12
 7720 00ff EC A5                   		mov.L	[r10], r5
 7721 0101 61 05                   		cmp	#0, r5
 7722 0103 19                      		bne	.L528
5275:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_ASYNC_CRYPT
5276:../src/wolfcrypt/src/ecc.c ****             || err == WC_PENDING_E
5277:../src/wolfcrypt/src/ecc.c ****         #endif
5278:../src/wolfcrypt/src/ecc.c ****         ) {
5279:../src/wolfcrypt/src/ecc.c ****             key->type = ECC_PRIVATEKEY;
 7723                             		.loc 2 5279 23
 7724 0104 ED A5 10                		mov.L	64[r10], r5
 7725 0107 F8 56 02                		mov.L	#2, [r5]
 7726 010a 2E 0F                   		bra	.L529
 7727                             	.L528:
5280:../src/wolfcrypt/src/ecc.c ****         }
5281:../src/wolfcrypt/src/ecc.c ****         else {
5282:../src/wolfcrypt/src/ecc.c ****             /* cleanup these on failure case only */
5283:../src/wolfcrypt/src/ecc.c ****             mp_forcezero(&key->k);
 7728                             		.loc 2 5283 26
 7729 010c ED A5 10                		mov.L	64[r10], r5
 7730 010f 72 55 48 09             		add	#0x948, r5
 7731                             		.loc 2 5283 13
 7732 0113 EF 51                   		mov.L	r5, r1
 7733 0115 05 00 00 00             		bsr	_sp_forcezero
 7734                             	.L529:
5284:../src/wolfcrypt/src/ecc.c ****         }
5285:../src/wolfcrypt/src/ecc.c **** 
5286:../src/wolfcrypt/src/ecc.c ****         /* cleanup allocations */
5287:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_free(curve);
 7735                             		.loc 2 5287 9
 7736 0119 ED A5 0D                		mov.L	52[r10], r5
 7737 011c EF 51                   		mov.L	r5, r1
 7738 011e 05 00 00 00             		bsr	_wc_ecc_curve_free
 7739                             	.LBB40:
5288:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
 7740                             		.loc 2 5288 9
 7741 0122 ED A5 01                		mov.L	4[r10], r5
 7742 0125 E7 A5 02                		mov.L	r5, 8[r10]
 7743 0128 ED A5 02                		mov.L	8[r10], r5
 7744 012b 61 05                   		cmp	#0, r5
 7745 012d 10                      		beq	.L530
 7746                             		.loc 2 5288 9 is_stmt 0 discriminator 1
 7747 012e ED A1 02                		mov.L	8[r10], r1
 7748 0131 05 00 00 00             		bsr	_wolfSSL_Free
 7749                             	.L530:
 7750                             	.LBE40:
5289:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SP_MATH */
5290:../src/wolfcrypt/src/ecc.c ****     }
5291:../src/wolfcrypt/src/ecc.c **** 
5292:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_WOLF_BIGINT
5293:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
5294:../src/wolfcrypt/src/ecc.c ****          err = wc_mp_to_bigint(&key->k, &key->k.raw);
5295:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
5296:../src/wolfcrypt/src/ecc.c ****          err = wc_mp_to_bigint(key->pubkey.x, &key->pubkey.x->raw);
5297:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
5298:../src/wolfcrypt/src/ecc.c ****          err = wc_mp_to_bigint(key->pubkey.y, &key->pubkey.y->raw);
5299:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
5300:../src/wolfcrypt/src/ecc.c ****          err = wc_mp_to_bigint(key->pubkey.z, &key->pubkey.z->raw);
5301:../src/wolfcrypt/src/ecc.c **** #endif
5302:../src/wolfcrypt/src/ecc.c **** 
5303:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_MAKE_PUB */
5304:../src/wolfcrypt/src/ecc.c **** 
5305:../src/wolfcrypt/src/ecc.c ****     return err;
 7751                             		.loc 2 5305 12 is_stmt 1
 7752 0135 EC A5                   		mov.L	[r10], r5
 7753                             	.L531:
5306:../src/wolfcrypt/src/ecc.c **** #endif /* WOLF_CRYPTO_CB_ONLY_ECC */
5307:../src/wolfcrypt/src/ecc.c **** }
 7754                             		.loc 2 5307 1 discriminator 1
 7755 0137 EF 51                   		mov.L	r5, r1
 7756 0139 71 00 4C                		add	#0x4c, r0
 7757 013c 7E B6                   		pop	r6
 7758 013e 7E BA                   		pop	r10
 7759 0140 02                      		rts
 7760                             	.LFE93:
 7762                             		.section	.text.wc_ecc_make_key_ex2,"ax",@progbits
 7763                             		.global	_wc_ecc_make_key_ex2
 7765                             	_wc_ecc_make_key_ex2:
 7766                             	.LFB94:
5308:../src/wolfcrypt/src/ecc.c **** 
5309:../src/wolfcrypt/src/ecc.c **** 
5310:../src/wolfcrypt/src/ecc.c **** int wc_ecc_make_key_ex2(WC_RNG* rng, int keysize, ecc_key* key, int curve_id,
5311:../src/wolfcrypt/src/ecc.c ****                         int flags)
5312:../src/wolfcrypt/src/ecc.c **** {
 7767                             		.loc 2 5312 1
 7768 0000 7E AA                   		push.l	r10
 7769                             	.LCFI127:
 7770 0002 71 0A E8                		add	#-24, r0, r10
 7771                             	.LCFI128:
 7772 0005 71 A0 FC                		add	#-4, r10, r0
 7773                             	.LCFI129:
 7774 0008 75 45 20                		mov.L	#32, r5
 7775 000b 4B A5                   		add	r10, r5
 7776 000d E7 A1 01                		mov.L	r1, 4[r10]
 7777 0010 E7 A2 02                		mov.L	r2, 8[r10]
 7778 0013 E7 A3 03                		mov.L	r3, 12[r10]
 7779 0016 E7 A4 04                		mov.L	r4, 16[r10]
5313:../src/wolfcrypt/src/ecc.c ****     int err;
5314:../src/wolfcrypt/src/ecc.c **** 
5315:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
5316:../src/wolfcrypt/src/ecc.c **** 
5317:../src/wolfcrypt/src/ecc.c ****     err = _ecc_make_key_ex(rng, keysize, key, curve_id, flags);
 7780                             		.loc 2 5317 11
 7781 0019 EC 55                   		mov.L	[r5], r5
 7782 001b E3 05                   		mov.L	r5, [r0]
 7783 001d ED A4 04                		mov.L	16[r10], r4
 7784 0020 ED A3 03                		mov.L	12[r10], r3
 7785 0023 ED A2 02                		mov.L	8[r10], r2
 7786 0026 ED A1 01                		mov.L	4[r10], r1
 7787 0029 05 00 00 00             		bsr	__ecc_make_key_ex
 7788 002d E3 A1                   		mov.L	r1, [r10]
5318:../src/wolfcrypt/src/ecc.c **** 
5319:../src/wolfcrypt/src/ecc.c **** #if (FIPS_VERSION_GE(5,0) || defined(WOLFSSL_VALIDATE_ECC_KEYGEN)) && \
5320:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_KCAPI_ECC)
5321:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
5322:../src/wolfcrypt/src/ecc.c ****         err = _ecc_validate_public_key(key, 0, 0);
5323:../src/wolfcrypt/src/ecc.c ****     }
5324:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
5325:../src/wolfcrypt/src/ecc.c ****         err = _ecc_pairwise_consistency_test(key, rng);
5326:../src/wolfcrypt/src/ecc.c ****     }
5327:../src/wolfcrypt/src/ecc.c **** #endif
5328:../src/wolfcrypt/src/ecc.c **** 
5329:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
5330:../src/wolfcrypt/src/ecc.c **** 
5331:../src/wolfcrypt/src/ecc.c ****     return err;
 7789                             		.loc 2 5331 12
 7790 002f EC A5                   		mov.L	[r10], r5
5332:../src/wolfcrypt/src/ecc.c **** }
 7791                             		.loc 2 5332 1
 7792 0031 EF 51                   		mov.L	r5, r1
 7793 0033 3F AA 08                		rtsd	#32, r10-r10
 7794                             	.LFE94:
 7796                             		.section	.text.wc_ecc_make_key_ex,"ax",@progbits
 7797                             		.global	_wc_ecc_make_key_ex
 7799                             	_wc_ecc_make_key_ex:
 7800                             	.LFB95:
5333:../src/wolfcrypt/src/ecc.c **** 
5334:../src/wolfcrypt/src/ecc.c **** WOLFSSL_ABI
5335:../src/wolfcrypt/src/ecc.c **** int wc_ecc_make_key_ex(WC_RNG* rng, int keysize, ecc_key* key, int curve_id)
5336:../src/wolfcrypt/src/ecc.c **** {
 7801                             		.loc 2 5336 1
 7802 0000 7E AA                   		push.l	r10
 7803                             	.LCFI130:
 7804 0002 71 0A F0                		add	#-16, r0, r10
 7805                             	.LCFI131:
 7806 0005 71 A0 FC                		add	#-4, r10, r0
 7807                             	.LCFI132:
 7808 0008 E3 A1                   		mov.L	r1, [r10]
 7809 000a E7 A2 01                		mov.L	r2, 4[r10]
 7810 000d E7 A3 02                		mov.L	r3, 8[r10]
 7811 0010 E7 A4 03                		mov.L	r4, 12[r10]
5337:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_make_key_ex2(rng, keysize, key, curve_id, WC_ECC_FLAG_NONE);
 7812                             		.loc 2 5337 12
 7813 0013 F8 06 00                		mov.L	#0, [r0]
 7814 0016 ED A4 03                		mov.L	12[r10], r4
 7815 0019 ED A3 02                		mov.L	8[r10], r3
 7816 001c ED A2 01                		mov.L	4[r10], r2
 7817 001f EC A1                   		mov.L	[r10], r1
 7818 0021 05 00 00 00             		bsr	_wc_ecc_make_key_ex2
 7819 0025 EF 15                   		mov.L	r1, r5
5338:../src/wolfcrypt/src/ecc.c **** }
 7820                             		.loc 2 5338 1
 7821 0027 EF 51                   		mov.L	r5, r1
 7822 0029 3F AA 06                		rtsd	#24, r10-r10
 7823                             	.LFE95:
 7825                             		.section	.text.wc_ecc_key_new,"ax",@progbits
 7826                             		.global	_wc_ecc_key_new
 7828                             	_wc_ecc_key_new:
 7829                             	.LFB96:
5339:../src/wolfcrypt/src/ecc.c **** 
5340:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_DUMP_OID
5341:../src/wolfcrypt/src/ecc.c **** /* Optional dump of encoded OID for adding new curves */
5342:../src/wolfcrypt/src/ecc.c **** static int mOidDumpDone;
5343:../src/wolfcrypt/src/ecc.c **** static void wc_ecc_dump_oids(void)
5344:../src/wolfcrypt/src/ecc.c **** {
5345:../src/wolfcrypt/src/ecc.c ****     int x;
5346:../src/wolfcrypt/src/ecc.c **** 
5347:../src/wolfcrypt/src/ecc.c ****     if (mOidDumpDone) {
5348:../src/wolfcrypt/src/ecc.c ****         return;
5349:../src/wolfcrypt/src/ecc.c ****     }
5350:../src/wolfcrypt/src/ecc.c **** 
5351:../src/wolfcrypt/src/ecc.c ****     /* find matching OID sum (based on encoded value) */
5352:../src/wolfcrypt/src/ecc.c ****     for (x = 0; ecc_sets[x].size != 0; x++) {
5353:../src/wolfcrypt/src/ecc.c ****         int i;
5354:../src/wolfcrypt/src/ecc.c ****         byte* oid;
5355:../src/wolfcrypt/src/ecc.c ****         word32 oidSz, sum = 0;
5356:../src/wolfcrypt/src/ecc.c **** 
5357:../src/wolfcrypt/src/ecc.c ****         printf("ECC %s (%d):\n", ecc_sets[x].name, x);
5358:../src/wolfcrypt/src/ecc.c **** 
5359:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_OID_ENCODING
5360:../src/wolfcrypt/src/ecc.c ****         byte oidEnc[ECC_MAX_OID_LEN];
5361:../src/wolfcrypt/src/ecc.c **** 
5362:../src/wolfcrypt/src/ecc.c ****         oid = oidEnc;
5363:../src/wolfcrypt/src/ecc.c ****         oidSz = ECC_MAX_OID_LEN;
5364:../src/wolfcrypt/src/ecc.c **** 
5365:../src/wolfcrypt/src/ecc.c ****         printf("OID: ");
5366:../src/wolfcrypt/src/ecc.c ****         for (i = 0; i < (int)ecc_sets[x].oidSz; i++) {
5367:../src/wolfcrypt/src/ecc.c ****             printf("%d.", ecc_sets[x].oid[i]);
5368:../src/wolfcrypt/src/ecc.c ****         }
5369:../src/wolfcrypt/src/ecc.c ****         printf("\n");
5370:../src/wolfcrypt/src/ecc.c **** 
5371:../src/wolfcrypt/src/ecc.c ****         EncodeObjectId(ecc_sets[x].oid, ecc_sets[x].oidSz, oidEnc, &oidSz);
5372:../src/wolfcrypt/src/ecc.c ****     #else
5373:../src/wolfcrypt/src/ecc.c ****         oid = (byte*)ecc_sets[x].oid;
5374:../src/wolfcrypt/src/ecc.c ****         oidSz = ecc_sets[x].oidSz;
5375:../src/wolfcrypt/src/ecc.c ****     #endif
5376:../src/wolfcrypt/src/ecc.c **** 
5377:../src/wolfcrypt/src/ecc.c ****         printf("OID Encoded: ");
5378:../src/wolfcrypt/src/ecc.c ****         for (i = 0; i < (int)oidSz; i++) {
5379:../src/wolfcrypt/src/ecc.c ****             printf("0x%02X,", oid[i]);
5380:../src/wolfcrypt/src/ecc.c ****         }
5381:../src/wolfcrypt/src/ecc.c ****         printf("\n");
5382:../src/wolfcrypt/src/ecc.c **** 
5383:../src/wolfcrypt/src/ecc.c ****         for (i = 0; i < (int)oidSz; i++) {
5384:../src/wolfcrypt/src/ecc.c ****             sum += oid[i];
5385:../src/wolfcrypt/src/ecc.c ****         }
5386:../src/wolfcrypt/src/ecc.c ****         printf("Sum: %u\n", sum);
5387:../src/wolfcrypt/src/ecc.c **** 
5388:../src/wolfcrypt/src/ecc.c ****         /* validate sum */
5389:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[x].oidSum != sum) {
5390:../src/wolfcrypt/src/ecc.c ****             fprintf(stderr, "  Sum %u Not Valid!\n", ecc_sets[x].oidSum);
5391:../src/wolfcrypt/src/ecc.c ****         }
5392:../src/wolfcrypt/src/ecc.c ****     }
5393:../src/wolfcrypt/src/ecc.c ****     mOidDumpDone = 1;
5394:../src/wolfcrypt/src/ecc.c **** }
5395:../src/wolfcrypt/src/ecc.c **** #endif /* ECC_DUMP_OID */
5396:../src/wolfcrypt/src/ecc.c **** 
5397:../src/wolfcrypt/src/ecc.c **** 
5398:../src/wolfcrypt/src/ecc.c **** WOLFSSL_ABI
5399:../src/wolfcrypt/src/ecc.c **** ecc_key* wc_ecc_key_new(void* heap)
5400:../src/wolfcrypt/src/ecc.c **** {
 7830                             		.loc 2 5400 1
 7831 0000 7E AA                   		push.l	r10
 7832                             	.LCFI133:
 7833 0002 71 0A F0                		add	#-16, r0, r10
 7834                             	.LCFI134:
 7835 0005 EF A0                   		mov.L	r10, r0
 7836 0007 E7 A1 03                		mov.L	r1, 12[r10]
5401:../src/wolfcrypt/src/ecc.c ****     int devId = INVALID_DEVID;
 7837                             		.loc 2 5401 9
 7838 000a F9 A6 01 FE             		mov.L	#-2, 4[r10]
5402:../src/wolfcrypt/src/ecc.c ****     ecc_key* key;
5403:../src/wolfcrypt/src/ecc.c **** 
5404:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_QNX_CAAM
5405:../src/wolfcrypt/src/ecc.c ****     devId = WOLFSSL_CAAM_DEVID;
5406:../src/wolfcrypt/src/ecc.c **** #endif
5407:../src/wolfcrypt/src/ecc.c ****     key = (ecc_key*)XMALLOC(sizeof(ecc_key), heap, DYNAMIC_TYPE_ECC);
 7839                             		.loc 2 5407 21
 7840 000e FB 1A 5C 0C             		mov.L	#0xc5c, r1
 7841 0012 05 00 00 00             		bsr	_wolfSSL_Malloc
 7842 0016 E3 A1                   		mov.L	r1, [r10]
5408:../src/wolfcrypt/src/ecc.c ****     if (key) {
 7843                             		.loc 2 5408 8
 7844 0018 EC A5                   		mov.L	[r10], r5
 7845 001a 61 05                   		cmp	#0, r5
 7846 001c 20 29                   		beq	.L537
5409:../src/wolfcrypt/src/ecc.c ****         if (wc_ecc_init_ex(key, heap, devId) != 0) {
 7847                             		.loc 2 5409 13
 7848 001e ED A3 01                		mov.L	4[r10], r3
 7849 0021 ED A2 03                		mov.L	12[r10], r2
 7850 0024 EC A1                   		mov.L	[r10], r1
 7851 0026 05 00 00 00             		bsr	_wc_ecc_init_ex
 7852 002a EF 15                   		mov.L	r1, r5
 7853                             		.loc 2 5409 12
 7854 002c 61 05                   		cmp	#0, r5
 7855 002e 20 17                   		beq	.L537
 7856                             	.LBB41:
5410:../src/wolfcrypt/src/ecc.c ****             XFREE(key, heap, DYNAMIC_TYPE_ECC);
 7857                             		.loc 2 5410 13
 7858 0030 EC A5                   		mov.L	[r10], r5
 7859 0032 E7 A5 02                		mov.L	r5, 8[r10]
 7860 0035 ED A5 02                		mov.L	8[r10], r5
 7861 0038 61 05                   		cmp	#0, r5
 7862 003a 10                      		beq	.L538
 7863                             		.loc 2 5410 13 is_stmt 0 discriminator 1
 7864 003b ED A1 02                		mov.L	8[r10], r1
 7865 003e 05 00 00 00             		bsr	_wolfSSL_Free
 7866                             	.L538:
 7867                             	.LBE41:
5411:../src/wolfcrypt/src/ecc.c ****             key = NULL;
 7868                             		.loc 2 5411 17 is_stmt 1
 7869 0042 F8 A6 00                		mov.L	#0, [r10]
 7870                             	.L537:
5412:../src/wolfcrypt/src/ecc.c ****         }
5413:../src/wolfcrypt/src/ecc.c ****     }
5414:../src/wolfcrypt/src/ecc.c **** 
5415:../src/wolfcrypt/src/ecc.c ****     return key;
 7871                             		.loc 2 5415 12
 7872 0045 EC A5                   		mov.L	[r10], r5
5416:../src/wolfcrypt/src/ecc.c **** }
 7873                             		.loc 2 5416 1
 7874 0047 EF 51                   		mov.L	r5, r1
 7875 0049 3F AA 05                		rtsd	#20, r10-r10
 7876                             	.LFE96:
 7878                             		.section	.text.wc_ecc_key_free,"ax",@progbits
 7879                             		.global	_wc_ecc_key_free
 7881                             	_wc_ecc_key_free:
 7882                             	.LFB97:
5417:../src/wolfcrypt/src/ecc.c **** 
5418:../src/wolfcrypt/src/ecc.c **** 
5419:../src/wolfcrypt/src/ecc.c **** WOLFSSL_ABI
5420:../src/wolfcrypt/src/ecc.c **** void wc_ecc_key_free(ecc_key* key)
5421:../src/wolfcrypt/src/ecc.c **** {
 7883                             		.loc 2 5421 1
 7884 0000 7E AA                   		push.l	r10
 7885                             	.LCFI135:
 7886 0002 71 0A F4                		add	#-12, r0, r10
 7887                             	.LCFI136:
 7888 0005 EF A0                   		mov.L	r10, r0
 7889 0007 E7 A1 02                		mov.L	r1, 8[r10]
5422:../src/wolfcrypt/src/ecc.c ****     if (key) {
 7890                             		.loc 2 5422 8
 7891 000a ED A5 02                		mov.L	8[r10], r5
 7892 000d 61 05                   		cmp	#0, r5
 7893 000f 20 2E                   		beq	.L542
 7894                             	.LBB42:
5423:../src/wolfcrypt/src/ecc.c ****         void* heap = key->heap;
 7895                             		.loc 2 5423 15
 7896 0011 ED A5 02                		mov.L	8[r10], r5
 7897 0014 A9 5D                   		mov.L	20[r5], r5
 7898 0016 E3 A5                   		mov.L	r5, [r10]
5424:../src/wolfcrypt/src/ecc.c **** 
5425:../src/wolfcrypt/src/ecc.c ****         wc_ecc_free(key);
 7899                             		.loc 2 5425 9
 7900 0018 ED A1 02                		mov.L	8[r10], r1
 7901 001b 05 00 00 00             		bsr	_wc_ecc_free
5426:../src/wolfcrypt/src/ecc.c ****         ForceZero(key, sizeof(ecc_key));
 7902                             		.loc 2 5426 9
 7903 001f FB 2A 5C 0C             		mov.L	#0xc5c, r2
 7904 0023 ED A1 02                		mov.L	8[r10], r1
 7905 0026 05 00 00 00             		bsr	_ForceZero
 7906                             	.LBB43:
5427:../src/wolfcrypt/src/ecc.c ****         XFREE(key, heap, DYNAMIC_TYPE_ECC);
 7907                             		.loc 2 5427 9
 7908 002a ED A5 02                		mov.L	8[r10], r5
 7909 002d E7 A5 01                		mov.L	r5, 4[r10]
 7910 0030 ED A5 01                		mov.L	4[r10], r5
 7911 0033 61 05                   		cmp	#0, r5
 7912 0035 10                      		beq	.L542
 7913                             		.loc 2 5427 9 is_stmt 0 discriminator 1
 7914 0036 ED A1 01                		mov.L	4[r10], r1
 7915 0039 05 00 00 00             		bsr	_wolfSSL_Free
 7916                             	.L542:
 7917                             	.LBE43:
 7918                             	.LBE42:
5428:../src/wolfcrypt/src/ecc.c ****         (void)heap;
5429:../src/wolfcrypt/src/ecc.c ****     }
5430:../src/wolfcrypt/src/ecc.c **** }
 7919                             		.loc 2 5430 1 is_stmt 1
 7920 003d 03                      		nop
 7921 003e 3F AA 04                		rtsd	#16, r10-r10
 7922                             	.LFE97:
 7924                             		.section	.text.wc_ecc_make_key,"ax",@progbits
 7925                             		.global	_wc_ecc_make_key
 7927                             	_wc_ecc_make_key:
 7928                             	.LFB98:
5431:../src/wolfcrypt/src/ecc.c **** 
5432:../src/wolfcrypt/src/ecc.c **** 
5433:../src/wolfcrypt/src/ecc.c **** /**
5434:../src/wolfcrypt/src/ecc.c ****  Make a new ECC key
5435:../src/wolfcrypt/src/ecc.c ****  rng          An active RNG state
5436:../src/wolfcrypt/src/ecc.c ****  keysize      The keysize for the new key (in octets from 20 to 65 bytes)
5437:../src/wolfcrypt/src/ecc.c ****  key          [out] Destination of the newly created key
5438:../src/wolfcrypt/src/ecc.c ****  return       MP_OKAY if successful,
5439:../src/wolfcrypt/src/ecc.c ****  upon error all allocated memory will be freed
5440:../src/wolfcrypt/src/ecc.c ****  */
5441:../src/wolfcrypt/src/ecc.c **** int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
5442:../src/wolfcrypt/src/ecc.c **** {
 7929                             		.loc 2 5442 1
 7930 0000 7E AA                   		push.l	r10
 7931                             	.LCFI137:
 7932 0002 71 0A F4                		add	#-12, r0, r10
 7933                             	.LCFI138:
 7934 0005 EF A0                   		mov.L	r10, r0
 7935 0007 E3 A1                   		mov.L	r1, [r10]
 7936 0009 E7 A2 01                		mov.L	r2, 4[r10]
 7937 000c E7 A3 02                		mov.L	r3, 8[r10]
5443:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
 7938                             		.loc 2 5443 12
 7939 000f 66 04                   		mov.L	#0, r4
 7940 0011 ED A3 02                		mov.L	8[r10], r3
 7941 0014 ED A2 01                		mov.L	4[r10], r2
 7942 0017 EC A1                   		mov.L	[r10], r1
 7943 0019 05 00 00 00             		bsr	_wc_ecc_make_key_ex
 7944 001d EF 15                   		mov.L	r1, r5
5444:../src/wolfcrypt/src/ecc.c **** }
 7945                             		.loc 2 5444 1
 7946 001f EF 51                   		mov.L	r5, r1
 7947 0021 3F AA 04                		rtsd	#16, r10-r10
 7948                             	.LFE98:
 7950                             		.section	.text.wc_ecc_init_ex,"ax",@progbits
 7951                             		.global	_wc_ecc_init_ex
 7953                             	_wc_ecc_init_ex:
 7954                             	.LFB99:
5445:../src/wolfcrypt/src/ecc.c **** 
5446:../src/wolfcrypt/src/ecc.c **** /* Setup dynamic pointers if using normal math for proper freeing */
5447:../src/wolfcrypt/src/ecc.c **** WOLFSSL_ABI
5448:../src/wolfcrypt/src/ecc.c **** int wc_ecc_init_ex(ecc_key* key, void* heap, int devId)
5449:../src/wolfcrypt/src/ecc.c **** {
 7955                             		.loc 2 5449 1
 7956 0000 7E AA                   		push.l	r10
 7957                             	.LCFI139:
 7958 0002 71 0A F0                		add	#-16, r0, r10
 7959                             	.LCFI140:
 7960 0005 71 A0 F8                		add	#-8, r10, r0
 7961                             	.LCFI141:
 7962 0008 E7 A1 01                		mov.L	r1, 4[r10]
 7963 000b E7 A2 02                		mov.L	r2, 8[r10]
 7964 000e E7 A3 03                		mov.L	r3, 12[r10]
5450:../src/wolfcrypt/src/ecc.c ****     int ret = 0;
 7965                             		.loc 2 5450 9
 7966 0011 F8 A6 00                		mov.L	#0, [r10]
5451:../src/wolfcrypt/src/ecc.c **** 
5452:../src/wolfcrypt/src/ecc.c ****     if (key == NULL) {
 7967                             		.loc 2 5452 8
 7968 0014 ED A5 01                		mov.L	4[r10], r5
 7969 0017 61 05                   		cmp	#0, r5
 7970 0019 1F                      		bne	.L546
5453:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 7971                             		.loc 2 5453 16
 7972 001a FB 5A 53 FF             		mov.L	#-173, r5
 7973 001e 2E 52                   		bra	.L547
 7974                             	.L546:
5454:../src/wolfcrypt/src/ecc.c ****     }
5455:../src/wolfcrypt/src/ecc.c **** 
5456:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_DUMP_OID
5457:../src/wolfcrypt/src/ecc.c ****     wc_ecc_dump_oids();
5458:../src/wolfcrypt/src/ecc.c **** #endif
5459:../src/wolfcrypt/src/ecc.c **** 
5460:../src/wolfcrypt/src/ecc.c ****     XMEMSET(key, 0, sizeof(ecc_key));
 7975                             		.loc 2 5460 5
 7976 0020 FB 3A 5C 0C             		mov.L	#0xc5c, r3
 7977 0024 66 02                   		mov.L	#0, r2
 7978 0026 ED A1 01                		mov.L	4[r10], r1
 7979 0029 05 00 00 00             		bsr	_memset
5461:../src/wolfcrypt/src/ecc.c ****     key->state = ECC_STATE_NONE;
 7980                             		.loc 2 5461 16
 7981 002d ED A5 01                		mov.L	4[r10], r5
 7982 0030 3E 52 00                		mov.L	#0, 8[r5]
5462:../src/wolfcrypt/src/ecc.c **** 
5463:../src/wolfcrypt/src/ecc.c **** #if defined(PLUTON_CRYPTO_ECC) || defined(WOLF_CRYPTO_CB)
5464:../src/wolfcrypt/src/ecc.c ****     key->devId = devId;
5465:../src/wolfcrypt/src/ecc.c **** #else
5466:../src/wolfcrypt/src/ecc.c ****     (void)devId;
5467:../src/wolfcrypt/src/ecc.c **** #endif
5468:../src/wolfcrypt/src/ecc.c **** 
5469:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
5470:../src/wolfcrypt/src/ecc.c ****     key->slot = ATECC_INVALID_SLOT;
5471:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_KCAPI_ECC)
5472:../src/wolfcrypt/src/ecc.c ****     key->handle = NULL;
5473:../src/wolfcrypt/src/ecc.c **** #else
5474:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
5475:../src/wolfcrypt/src/ecc.c ****     key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
5476:../src/wolfcrypt/src/ecc.c ****     key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
5477:../src/wolfcrypt/src/ecc.c ****     key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
5478:../src/wolfcrypt/src/ecc.c ****     alt_fp_init(key->pubkey.x);
5479:../src/wolfcrypt/src/ecc.c ****     alt_fp_init(key->pubkey.y);
5480:../src/wolfcrypt/src/ecc.c ****     alt_fp_init(key->pubkey.z);
5481:../src/wolfcrypt/src/ecc.c ****     ret = mp_init(&key->k);
5482:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_OKAY) {
5483:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
5484:../src/wolfcrypt/src/ecc.c ****     }
5485:../src/wolfcrypt/src/ecc.c **** #else
5486:../src/wolfcrypt/src/ecc.c ****     ret = mp_init_multi(&key->k, key->pubkey.x, key->pubkey.y, key->pubkey.z,
 7983                             		.loc 2 5486 25
 7984 0033 ED A5 01                		mov.L	4[r10], r5
 7985 0036 72 51 48 09             		add	#0x948, r5, r1
 7986                             		.loc 2 5486 45
 7987 003a ED A5 01                		mov.L	4[r10], r5
 7988 003d 71 52 18                		add	#24, r5, r2
 7989                             		.loc 2 5486 60
 7990 0040 ED A5 01                		mov.L	4[r10], r5
 7991 0043 72 53 28 03             		add	#0x328, r5, r3
 7992                             		.loc 2 5486 75
 7993 0047 ED A5 01                		mov.L	4[r10], r5
 7994 004a 72 55 38 06             		add	#0x638, r5
 7995                             		.loc 2 5486 11
 7996 004e 3E 01 00                		mov.L	#0, 4[r0]
 7997 0051 F8 06 00                		mov.L	#0, [r0]
 7998 0054 EF 54                   		mov.L	r5, r4
 7999 0056 05 00 00 00             		bsr	_sp_init_multi
 8000 005a E3 A1                   		mov.L	r1, [r10]
5487:../src/wolfcrypt/src/ecc.c ****                                                                     NULL, NULL);
5488:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_OKAY) {
 8001                             		.loc 2 5488 8
 8002 005c EC A5                   		mov.L	[r10], r5
 8003 005e 61 05                   		cmp	#0, r5
 8004 0060 16                      		beq	.L548
5489:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 8005                             		.loc 2 5489 16
 8006 0061 FB 56 83                		mov.L	#-125, r5
 8007 0064 2E 0C                   		bra	.L547
 8008                             	.L548:
5490:../src/wolfcrypt/src/ecc.c ****     }
5491:../src/wolfcrypt/src/ecc.c **** #endif /* ALT_ECC_SIZE */
5492:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ATECC508A */
5493:../src/wolfcrypt/src/ecc.c **** 
5494:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HEAP_TEST
5495:../src/wolfcrypt/src/ecc.c ****     key->heap = (void*)WOLFSSL_HEAP_TEST;
5496:../src/wolfcrypt/src/ecc.c **** #else
5497:../src/wolfcrypt/src/ecc.c ****     key->heap = heap;
 8009                             		.loc 2 5497 15
 8010 0066 ED A5 01                		mov.L	4[r10], r5
 8011 0069 ED A4 02                		mov.L	8[r10], r4
 8012 006c A1 5C                   		mov.L	r4, 20[r5]
5498:../src/wolfcrypt/src/ecc.c **** #endif
5499:../src/wolfcrypt/src/ecc.c **** 
5500:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
5501:../src/wolfcrypt/src/ecc.c ****     /* handle as async */
5502:../src/wolfcrypt/src/ecc.c ****     ret = wolfAsync_DevCtxInit(&key->asyncDev, WOLFSSL_ASYNC_MARKER_ECC,
5503:../src/wolfcrypt/src/ecc.c ****                                                             key->heap, devId);
5504:../src/wolfcrypt/src/ecc.c **** #endif
5505:../src/wolfcrypt/src/ecc.c **** 
5506:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_DSP)
5507:../src/wolfcrypt/src/ecc.c ****     key->handle = -1;
5508:../src/wolfcrypt/src/ecc.c **** #endif
5509:../src/wolfcrypt/src/ecc.c **** 
5510:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SE050
5511:../src/wolfcrypt/src/ecc.c ****     key->keyId = -1;
5512:../src/wolfcrypt/src/ecc.c **** #endif
5513:../src/wolfcrypt/src/ecc.c **** 
5514:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
5515:../src/wolfcrypt/src/ecc.c ****     mp_memzero_add("ECC k", &key->k);
5516:../src/wolfcrypt/src/ecc.c **** #endif
5517:../src/wolfcrypt/src/ecc.c **** 
5518:../src/wolfcrypt/src/ecc.c ****     return ret;
 8013                             		.loc 2 5518 12
 8014 006e EC A5                   		mov.L	[r10], r5
 8015                             	.L547:
5519:../src/wolfcrypt/src/ecc.c **** }
 8016                             		.loc 2 5519 1
 8017 0070 EF 51                   		mov.L	r5, r1
 8018 0072 3F AA 07                		rtsd	#28, r10-r10
 8019                             	.LFE99:
 8021                             		.section	.text.wc_ecc_init,"ax",@progbits
 8022                             		.global	_wc_ecc_init
 8024                             	_wc_ecc_init:
 8025                             	.LFB100:
5520:../src/wolfcrypt/src/ecc.c **** 
5521:../src/wolfcrypt/src/ecc.c **** int wc_ecc_init(ecc_key* key)
5522:../src/wolfcrypt/src/ecc.c **** {
 8026                             		.loc 2 5522 1
 8027 0000 7E AA                   		push.l	r10
 8028                             	.LCFI142:
 8029 0002 71 0A FC                		add	#-4, r0, r10
 8030                             	.LCFI143:
 8031 0005 EF A0                   		mov.L	r10, r0
 8032 0007 E3 A1                   		mov.L	r1, [r10]
5523:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_QNX_CAAM
5524:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_init_ex(key, NULL, WOLFSSL_CAAM_DEVID);
5525:../src/wolfcrypt/src/ecc.c **** #else
5526:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_init_ex(key, NULL, INVALID_DEVID);
 8033                             		.loc 2 5526 12
 8034 0009 FB 36 FE                		mov.L	#-2, r3
 8035 000c 66 02                   		mov.L	#0, r2
 8036 000e EC A1                   		mov.L	[r10], r1
 8037 0010 05 00 00 00             		bsr	_wc_ecc_init_ex
 8038 0014 EF 15                   		mov.L	r1, r5
5527:../src/wolfcrypt/src/ecc.c **** #endif
5528:../src/wolfcrypt/src/ecc.c **** }
 8039                             		.loc 2 5528 1
 8040 0016 EF 51                   		mov.L	r5, r1
 8041 0018 3F AA 02                		rtsd	#8, r10-r10
 8042                             	.LFE100:
 8044                             		.section	.text.wc_ecc_set_flags,"ax",@progbits
 8045                             		.global	_wc_ecc_set_flags
 8047                             	_wc_ecc_set_flags:
 8048                             	.LFB101:
5529:../src/wolfcrypt/src/ecc.c **** 
5530:../src/wolfcrypt/src/ecc.c **** #ifdef WOLF_PRIVATE_KEY_ID
5531:../src/wolfcrypt/src/ecc.c **** int wc_ecc_init_id(ecc_key* key, unsigned char* id, int len, void* heap,
5532:../src/wolfcrypt/src/ecc.c ****                    int devId)
5533:../src/wolfcrypt/src/ecc.c **** {
5534:../src/wolfcrypt/src/ecc.c ****     int ret = 0;
5535:../src/wolfcrypt/src/ecc.c **** 
5536:../src/wolfcrypt/src/ecc.c ****     if (key == NULL)
5537:../src/wolfcrypt/src/ecc.c ****         ret = BAD_FUNC_ARG;
5538:../src/wolfcrypt/src/ecc.c ****     if (ret == 0 && (len < 0 || len > ECC_MAX_ID_LEN))
5539:../src/wolfcrypt/src/ecc.c ****         ret = BUFFER_E;
5540:../src/wolfcrypt/src/ecc.c **** 
5541:../src/wolfcrypt/src/ecc.c ****     if (ret == 0)
5542:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_init_ex(key, heap, devId);
5543:../src/wolfcrypt/src/ecc.c ****     if (ret == 0 && id != NULL && len != 0) {
5544:../src/wolfcrypt/src/ecc.c ****         XMEMCPY(key->id, id, len);
5545:../src/wolfcrypt/src/ecc.c ****         key->idLen = len;
5546:../src/wolfcrypt/src/ecc.c ****     }
5547:../src/wolfcrypt/src/ecc.c **** 
5548:../src/wolfcrypt/src/ecc.c ****     return ret;
5549:../src/wolfcrypt/src/ecc.c **** }
5550:../src/wolfcrypt/src/ecc.c **** 
5551:../src/wolfcrypt/src/ecc.c **** int wc_ecc_init_label(ecc_key* key, const char* label, void* heap, int devId)
5552:../src/wolfcrypt/src/ecc.c **** {
5553:../src/wolfcrypt/src/ecc.c ****     int ret = 0;
5554:../src/wolfcrypt/src/ecc.c ****     int labelLen = 0;
5555:../src/wolfcrypt/src/ecc.c **** 
5556:../src/wolfcrypt/src/ecc.c ****     if (key == NULL || label == NULL)
5557:../src/wolfcrypt/src/ecc.c ****         ret = BAD_FUNC_ARG;
5558:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
5559:../src/wolfcrypt/src/ecc.c ****         labelLen = (int)XSTRLEN(label);
5560:../src/wolfcrypt/src/ecc.c ****         if (labelLen == 0 || labelLen > ECC_MAX_LABEL_LEN)
5561:../src/wolfcrypt/src/ecc.c ****             ret = BUFFER_E;
5562:../src/wolfcrypt/src/ecc.c ****     }
5563:../src/wolfcrypt/src/ecc.c **** 
5564:../src/wolfcrypt/src/ecc.c ****     if (ret == 0)
5565:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_init_ex(key, heap, devId);
5566:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
5567:../src/wolfcrypt/src/ecc.c ****         XMEMCPY(key->label, label, labelLen);
5568:../src/wolfcrypt/src/ecc.c ****         key->labelLen = labelLen;
5569:../src/wolfcrypt/src/ecc.c ****     }
5570:../src/wolfcrypt/src/ecc.c **** 
5571:../src/wolfcrypt/src/ecc.c ****     return ret;
5572:../src/wolfcrypt/src/ecc.c **** }
5573:../src/wolfcrypt/src/ecc.c **** #endif /* WOLF_PRIVATE_KEY_ID */
5574:../src/wolfcrypt/src/ecc.c **** 
5575:../src/wolfcrypt/src/ecc.c **** int wc_ecc_set_flags(ecc_key* key, word32 flags)
5576:../src/wolfcrypt/src/ecc.c **** {
 8049                             		.loc 2 5576 1
 8050 0000 7E AA                   		push.l	r10
 8051                             	.LCFI144:
 8052 0002 71 0A F8                		add	#-8, r0, r10
 8053                             	.LCFI145:
 8054 0005 EF A0                   		mov.L	r10, r0
 8055 0007 E3 A1                   		mov.L	r1, [r10]
 8056 0009 E7 A2 01                		mov.L	r2, 4[r10]
5577:../src/wolfcrypt/src/ecc.c ****     if (key == NULL) {
 8057                             		.loc 2 5577 8
 8058 000c EC A5                   		mov.L	[r10], r5
 8059 000e 61 05                   		cmp	#0, r5
 8060 0010 1F                      		bne	.L552
5578:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 8061                             		.loc 2 5578 16
 8062 0011 FB 5A 53 FF             		mov.L	#-173, r5
 8063 0015 2E 11                   		bra	.L553
 8064                             	.L552:
5579:../src/wolfcrypt/src/ecc.c ****     }
5580:../src/wolfcrypt/src/ecc.c ****     key->flags |= flags;
 8065                             		.loc 2 5580 16
 8066 0017 EC A5                   		mov.L	[r10], r5
 8067 0019 A8 DC                   		mov.L	12[r5], r4
 8068 001b ED A5 01                		mov.L	4[r10], r5
 8069 001e 57 54                   		or	r5, r4
 8070 0020 EC A5                   		mov.L	[r10], r5
 8071 0022 A0 DC                   		mov.L	r4, 12[r5]
5581:../src/wolfcrypt/src/ecc.c ****     return 0;
 8072                             		.loc 2 5581 12
 8073 0024 66 05                   		mov.L	#0, r5
 8074                             	.L553:
5582:../src/wolfcrypt/src/ecc.c **** }
 8075                             		.loc 2 5582 1
 8076 0026 EF 51                   		mov.L	r5, r1
 8077 0028 3F AA 03                		rtsd	#12, r10-r10
 8078                             	.LFE101:
 8080                             		.section	.text.wc_ecc_get_curve_order_bit_count,"ax",@progbits
 8082                             	_wc_ecc_get_curve_order_bit_count:
 8083                             	.LFB102:
5583:../src/wolfcrypt/src/ecc.c **** 
5584:../src/wolfcrypt/src/ecc.c **** 
5585:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_get_curve_order_bit_count(const ecc_set_type* dp)
5586:../src/wolfcrypt/src/ecc.c **** {
 8084                             		.loc 2 5586 1
 8085 0000 7E AA                   		push.l	r10
 8086                             	.LCFI146:
 8087 0002 71 0A BC                		add	#-68, r0, r10
 8088                             	.LCFI147:
 8089 0005 EF A0                   		mov.L	r10, r0
 8090 0007 E7 A1 10                		mov.L	r1, 64[r10]
5587:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 8091                             		.loc 2 5587 9
 8092 000a F8 A6 00                		mov.L	#0, [r10]
5588:../src/wolfcrypt/src/ecc.c ****     word32 orderBits;
5589:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(1);
 8093                             		.loc 2 5589 5
 8094 000d F9 A6 01 00             		mov.L	#0, 4[r10]
 8095 0011 71 A5 14                		add	#20, r10, r5
 8096 0014 E7 A5 0F                		mov.L	r5, 60[r10]
 8097 0017 ED A5 0F                		mov.L	60[r10], r5
 8098 001a 75 43 28                		mov.L	#40, r3
 8099 001d 66 02                   		mov.L	#0, r2
 8100 001f EF 51                   		mov.L	r5, r1
 8101 0021 05 00 00 00             		bsr	_memset
 8102 0025 ED A5 0F                		mov.L	60[r10], r5
 8103 0028 3E 57 01                		mov.L	#1, 28[r5]
5590:../src/wolfcrypt/src/ecc.c **** 
5591:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(1, err);
 8104                             		.loc 2 5591 5
 8105 002b FB 1A 10 03             		mov.L	#0x310, r1
 8106 002f 05 00 00 00             		bsr	_wolfSSL_Malloc
 8107 0033 E7 A1 01                		mov.L	r1, 4[r10]
 8108 0036 ED A5 01                		mov.L	4[r10], r5
 8109 0039 61 05                   		cmp	#0, r5
 8110 003b 1D                      		bne	.L555
 8111                             		.loc 2 5591 5 is_stmt 0 discriminator 1
 8112 003c F8 A6 83                		mov.L	#-125, [r10]
 8113 003f 09                      		bra	.L556
 8114                             	.L555:
 8115                             		.loc 2 5591 5 discriminator 2
 8116 0040 ED A5 0F                		mov.L	60[r10], r5
 8117 0043 ED A4 01                		mov.L	4[r10], r4
 8118 0046 A1 D4                   		mov.L	r4, 24[r5]
 8119                             	.L556:
5592:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 8120                             		.loc 2 5592 8 is_stmt 1
 8121 0048 EC A5                   		mov.L	[r10], r5
 8122 004a 61 05                   		cmp	#0, r5
 8123 004c 21 12                   		bne	.L557
5593:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_curve_load(dp, &curve, ECC_CURVE_FIELD_ORDER);
 8124                             		.loc 2 5593 15
 8125 004e 71 A5 3C                		add	#60, r10, r5
 8126 0051 66 83                   		mov	#8, r3
 8127 0053 EF 52                   		mov.L	r5, r2
 8128 0055 ED A1 10                		mov.L	64[r10], r1
 8129 0058 05 00 00 00             		bsr	_wc_ecc_curve_load
 8130 005c E3 A1                   		mov.L	r1, [r10]
 8131                             	.L557:
5594:../src/wolfcrypt/src/ecc.c ****     }
5595:../src/wolfcrypt/src/ecc.c **** 
5596:../src/wolfcrypt/src/ecc.c ****     if (err != 0) {
 8132                             		.loc 2 5596 8
 8133 005e EC A5                   		mov.L	[r10], r5
 8134 0060 61 05                   		cmp	#0, r5
 8135 0062 20 19                   		beq	.L558
 8136                             	.LBB44:
5597:../src/wolfcrypt/src/ecc.c ****        FREE_CURVE_SPECS();
 8137                             		.loc 2 5597 8
 8138 0064 ED A5 01                		mov.L	4[r10], r5
 8139 0067 E7 A5 02                		mov.L	r5, 8[r10]
 8140 006a ED A5 02                		mov.L	8[r10], r5
 8141 006d 61 05                   		cmp	#0, r5
 8142 006f 10                      		beq	.L559
 8143                             		.loc 2 5597 8 is_stmt 0 discriminator 1
 8144 0070 ED A1 02                		mov.L	8[r10], r1
 8145 0073 05 00 00 00             		bsr	_wolfSSL_Free
 8146                             	.L559:
 8147                             	.LBE44:
5598:../src/wolfcrypt/src/ecc.c ****        return err;
 8148                             		.loc 2 5598 15 is_stmt 1
 8149 0077 EC A5                   		mov.L	[r10], r5
 8150 0079 2E 31                   		bra	.L562
 8151                             	.L558:
5599:../src/wolfcrypt/src/ecc.c ****     }
5600:../src/wolfcrypt/src/ecc.c ****     orderBits = mp_count_bits(curve->order);
 8152                             		.loc 2 5600 36
 8153 007b ED A5 0F                		mov.L	60[r10], r5
 8154 007e A8 DD                   		mov.L	12[r5], r5
 8155                             		.loc 2 5600 17
 8156 0080 EF 51                   		mov.L	r5, r1
 8157 0082 05 00 00 00             		bsr	_sp_count_bits
 8158 0086 EF 15                   		mov.L	r1, r5
 8159                             		.loc 2 5600 15
 8160 0088 E7 A5 03                		mov.L	r5, 12[r10]
5601:../src/wolfcrypt/src/ecc.c **** 
5602:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
 8161                             		.loc 2 5602 5
 8162 008b ED A5 0F                		mov.L	60[r10], r5
 8163 008e EF 51                   		mov.L	r5, r1
 8164 0090 05 00 00 00             		bsr	_wc_ecc_curve_free
 8165                             	.LBB45:
5603:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
 8166                             		.loc 2 5603 5
 8167 0094 ED A5 01                		mov.L	4[r10], r5
 8168 0097 E7 A5 04                		mov.L	r5, 16[r10]
 8169 009a ED A5 04                		mov.L	16[r10], r5
 8170 009d 61 05                   		cmp	#0, r5
 8171 009f 10                      		beq	.L561
 8172                             		.loc 2 5603 5 is_stmt 0 discriminator 1
 8173 00a0 ED A1 04                		mov.L	16[r10], r1
 8174 00a3 05 00 00 00             		bsr	_wolfSSL_Free
 8175                             	.L561:
 8176                             	.LBE45:
5604:../src/wolfcrypt/src/ecc.c ****     return (int)orderBits;
 8177                             		.loc 2 5604 12 is_stmt 1
 8178 00a7 ED A5 03                		mov.L	12[r10], r5
 8179                             	.L562:
5605:../src/wolfcrypt/src/ecc.c **** }
 8180                             		.loc 2 5605 1 discriminator 1
 8181 00aa EF 51                   		mov.L	r5, r1
 8182 00ac 3F AA 12                		rtsd	#72, r10-r10
 8183                             	.LFE102:
 8185                             		.section C,"a",@progbits
 8186                             		.p2align 2
 8187                             	.LC41:
 8188 0a70 45 43 43 20 73 69 67 6E 		.string	"ECC sign RNG missing"
 8188      20 52 4E 47 20 6D 69 73 
 8188      73 69 6E 67 00 
 8189                             		.section	.text.wc_ecc_sign_hash,"ax",@progbits
 8190                             		.global	_wc_ecc_sign_hash
 8192                             	_wc_ecc_sign_hash:
 8193                             	.LFB103:
5606:../src/wolfcrypt/src/ecc.c **** 
5607:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_SIGN
5608:../src/wolfcrypt/src/ecc.c **** 
5609:../src/wolfcrypt/src/ecc.c **** #ifndef NO_ASN
5610:../src/wolfcrypt/src/ecc.c **** 
5611:../src/wolfcrypt/src/ecc.c **** 
5612:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A) ||  \
5613:../src/wolfcrypt/src/ecc.c ****     defined(PLUTON_CRYPTO_ECC) || defined(WOLFSSL_CRYPTOCELL) || \
5614:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_SILABS_SE_ACCEL) || defined(WOLFSSL_KCAPI_ECC) || \
5615:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_SE050)
5616:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_sign_hash_hw(const byte* in, word32 inlen,
5617:../src/wolfcrypt/src/ecc.c ****     mp_int* r, mp_int* s, byte* out, word32 *outlen, WC_RNG* rng,
5618:../src/wolfcrypt/src/ecc.c ****     ecc_key* key)
5619:../src/wolfcrypt/src/ecc.c **** {
5620:../src/wolfcrypt/src/ecc.c ****     int err;
5621:../src/wolfcrypt/src/ecc.c **** #ifdef PLUTON_CRYPTO_ECC
5622:../src/wolfcrypt/src/ecc.c ****     if (key->devId != INVALID_DEVID) /* use hardware */
5623:../src/wolfcrypt/src/ecc.c **** #endif
5624:../src/wolfcrypt/src/ecc.c ****     {
5625:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_ATECC508A) && \
5626:../src/wolfcrypt/src/ecc.c ****         !defined(WOLFSSL_ATECC608A)
5627:../src/wolfcrypt/src/ecc.c ****         CRYS_ECDSA_SignUserContext_t sigCtxTemp;
5628:../src/wolfcrypt/src/ecc.c ****         word32 raw_sig_size = *outlen;
5629:../src/wolfcrypt/src/ecc.c ****         word32 msgLenInBytes = inlen;
5630:../src/wolfcrypt/src/ecc.c ****         CRYS_ECPKI_HASH_OpMode_t hash_mode;
5631:../src/wolfcrypt/src/ecc.c ****     #endif
5632:../src/wolfcrypt/src/ecc.c ****         word32 keysize = (word32)key->dp->size;
5633:../src/wolfcrypt/src/ecc.c ****     #ifdef PLUTON_CRYPTO_ECC
5634:../src/wolfcrypt/src/ecc.c ****         word32 orderBits = wc_ecc_get_curve_order_bit_count(key->dp);
5635:../src/wolfcrypt/src/ecc.c ****     #endif
5636:../src/wolfcrypt/src/ecc.c **** 
5637:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_KCAPI_ECC
5638:../src/wolfcrypt/src/ecc.c ****         /* Check args */
5639:../src/wolfcrypt/src/ecc.c ****         if (keysize > ECC_MAX_CRYPTO_HW_SIZE || *outlen < keysize*2) {
5640:../src/wolfcrypt/src/ecc.c ****             return ECC_BAD_ARG_E;
5641:../src/wolfcrypt/src/ecc.c ****         }
5642:../src/wolfcrypt/src/ecc.c ****     #endif
5643:../src/wolfcrypt/src/ecc.c **** 
5644:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
5645:../src/wolfcrypt/src/ecc.c ****         /* Sign: Result is 32-bytes of R then 32-bytes of S */
5646:../src/wolfcrypt/src/ecc.c ****         err = atmel_ecc_sign(key->slot, in, out);
5647:../src/wolfcrypt/src/ecc.c ****         if (err != 0) {
5648:../src/wolfcrypt/src/ecc.c ****            return err;
5649:../src/wolfcrypt/src/ecc.c ****         }
5650:../src/wolfcrypt/src/ecc.c ****     #elif defined(PLUTON_CRYPTO_ECC)
5651:../src/wolfcrypt/src/ecc.c ****         {
5652:../src/wolfcrypt/src/ecc.c ****             /* if the input is larger than curve order, we must truncate */
5653:../src/wolfcrypt/src/ecc.c ****             if ((inlen * WOLFSSL_BIT_SIZE) > orderBits) {
5654:../src/wolfcrypt/src/ecc.c ****                inlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;
5655:../src/wolfcrypt/src/ecc.c ****             }
5656:../src/wolfcrypt/src/ecc.c **** 
5657:../src/wolfcrypt/src/ecc.c ****             /* perform ECC sign */
5658:../src/wolfcrypt/src/ecc.c ****             word32 raw_sig_size = *outlen;
5659:../src/wolfcrypt/src/ecc.c ****             err = Crypto_EccSign(in, inlen, out, &raw_sig_size);
5660:../src/wolfcrypt/src/ecc.c ****             if (err != CRYPTO_RES_SUCCESS || raw_sig_size != keysize*2){
5661:../src/wolfcrypt/src/ecc.c ****                return BAD_COND_E;
5662:../src/wolfcrypt/src/ecc.c ****             }
5663:../src/wolfcrypt/src/ecc.c ****         }
5664:../src/wolfcrypt/src/ecc.c ****     #elif defined(WOLFSSL_SILABS_SE_ACCEL)
5665:../src/wolfcrypt/src/ecc.c ****         err = silabs_ecc_sign_hash(in, inlen, out, outlen, key);
5666:../src/wolfcrypt/src/ecc.c ****         if (err != 0) {
5667:../src/wolfcrypt/src/ecc.c ****                return WC_HW_E;
5668:../src/wolfcrypt/src/ecc.c ****         }
5669:../src/wolfcrypt/src/ecc.c ****     #elif defined(WOLFSSL_CRYPTOCELL)
5670:../src/wolfcrypt/src/ecc.c ****         /* truncate if hash is longer than key size */
5671:../src/wolfcrypt/src/ecc.c ****         if (msgLenInBytes > keysize) {
5672:../src/wolfcrypt/src/ecc.c ****             msgLenInBytes = keysize;
5673:../src/wolfcrypt/src/ecc.c ****         }
5674:../src/wolfcrypt/src/ecc.c ****         hash_mode = cc310_hashModeECC(msgLenInBytes);
5675:../src/wolfcrypt/src/ecc.c ****         if (hash_mode == CRYS_ECPKI_HASH_OpModeLast) {
5676:../src/wolfcrypt/src/ecc.c ****             (void)cc310_hashModeECC(keysize);
5677:../src/wolfcrypt/src/ecc.c ****             /* Ignoring returned value */
5678:../src/wolfcrypt/src/ecc.c ****             hash_mode = CRYS_ECPKI_HASH_SHA256_mode;
5679:../src/wolfcrypt/src/ecc.c **** 
5680:../src/wolfcrypt/src/ecc.c ****         }
5681:../src/wolfcrypt/src/ecc.c **** 
5682:../src/wolfcrypt/src/ecc.c ****         /* create signature from an input buffer using a private key*/
5683:../src/wolfcrypt/src/ecc.c ****         err = CRYS_ECDSA_Sign(&wc_rndState,
5684:../src/wolfcrypt/src/ecc.c ****                                wc_rndGenVectFunc,
5685:../src/wolfcrypt/src/ecc.c ****                                &sigCtxTemp,
5686:../src/wolfcrypt/src/ecc.c ****                                &key->ctx.privKey,
5687:../src/wolfcrypt/src/ecc.c ****                                hash_mode,
5688:../src/wolfcrypt/src/ecc.c ****                                (byte*)in,
5689:../src/wolfcrypt/src/ecc.c ****                                msgLenInBytes,
5690:../src/wolfcrypt/src/ecc.c ****                                out,
5691:../src/wolfcrypt/src/ecc.c ****                                (uint32_t*)&raw_sig_size);
5692:../src/wolfcrypt/src/ecc.c **** 
5693:../src/wolfcrypt/src/ecc.c ****         if (err != SA_SILIB_RET_OK){
5694:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("CRYS_ECDSA_Sign failed");
5695:../src/wolfcrypt/src/ecc.c ****             return err;
5696:../src/wolfcrypt/src/ecc.c ****         }
5697:../src/wolfcrypt/src/ecc.c ****     #elif defined(WOLFSSL_KCAPI_ECC)
5698:../src/wolfcrypt/src/ecc.c ****         err = KcapiEcc_Sign(key, in, inlen, out, *outlen);
5699:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY) {
5700:../src/wolfcrypt/src/ecc.c ****             return err;
5701:../src/wolfcrypt/src/ecc.c ****         }
5702:../src/wolfcrypt/src/ecc.c ****         (void)rng;
5703:../src/wolfcrypt/src/ecc.c ****     #elif defined(WOLFSSL_SE050)
5704:../src/wolfcrypt/src/ecc.c ****         err = se050_ecc_sign_hash_ex(in, inlen, out, outlen, key);
5705:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY) {
5706:../src/wolfcrypt/src/ecc.c ****             return err;
5707:../src/wolfcrypt/src/ecc.c ****         }
5708:../src/wolfcrypt/src/ecc.c ****         (void)rng;
5709:../src/wolfcrypt/src/ecc.c ****     #endif
5710:../src/wolfcrypt/src/ecc.c **** 
5711:../src/wolfcrypt/src/ecc.c ****         /* Load R and S */
5712:../src/wolfcrypt/src/ecc.c ****         err = mp_read_unsigned_bin(r, &out[0], keysize);
5713:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY) {
5714:../src/wolfcrypt/src/ecc.c ****             return err;
5715:../src/wolfcrypt/src/ecc.c ****         }
5716:../src/wolfcrypt/src/ecc.c ****         err = mp_read_unsigned_bin(s, &out[keysize], keysize);
5717:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY) {
5718:../src/wolfcrypt/src/ecc.c ****             return err;
5719:../src/wolfcrypt/src/ecc.c ****         }
5720:../src/wolfcrypt/src/ecc.c **** 
5721:../src/wolfcrypt/src/ecc.c ****         /* Check for zeros */
5722:../src/wolfcrypt/src/ecc.c ****         if (mp_iszero(r) || mp_iszero(s)) {
5723:../src/wolfcrypt/src/ecc.c ****             return MP_ZERO_E;
5724:../src/wolfcrypt/src/ecc.c ****         }
5725:../src/wolfcrypt/src/ecc.c ****     }
5726:../src/wolfcrypt/src/ecc.c **** #ifdef PLUTON_CRYPTO_ECC
5727:../src/wolfcrypt/src/ecc.c ****     else {
5728:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);
5729:../src/wolfcrypt/src/ecc.c ****     }
5730:../src/wolfcrypt/src/ecc.c **** #endif
5731:../src/wolfcrypt/src/ecc.c ****     (void)rng;
5732:../src/wolfcrypt/src/ecc.c **** 
5733:../src/wolfcrypt/src/ecc.c ****     return err;
5734:../src/wolfcrypt/src/ecc.c **** }
5735:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ATECC508A || PLUTON_CRYPTO_ECC || WOLFSSL_CRYPTOCELL */
5736:../src/wolfcrypt/src/ecc.c **** 
5737:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
5738:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_sign_hash_async(const byte* in, word32 inlen, byte* out,
5739:../src/wolfcrypt/src/ecc.c ****     word32 *outlen, WC_RNG* rng, ecc_key* key)
5740:../src/wolfcrypt/src/ecc.c **** {
5741:../src/wolfcrypt/src/ecc.c ****     int err;
5742:../src/wolfcrypt/src/ecc.c ****     mp_int *r = NULL, *s = NULL;
5743:../src/wolfcrypt/src/ecc.c **** 
5744:../src/wolfcrypt/src/ecc.c ****     if (in == NULL || out == NULL || outlen == NULL || key == NULL ||
5745:../src/wolfcrypt/src/ecc.c ****                                                                 rng == NULL) {
5746:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
5747:../src/wolfcrypt/src/ecc.c ****     }
5748:../src/wolfcrypt/src/ecc.c **** 
5749:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_alloc_async(key);
5750:../src/wolfcrypt/src/ecc.c ****     if (err != 0) {
5751:../src/wolfcrypt/src/ecc.c ****         return err;
5752:../src/wolfcrypt/src/ecc.c ****     }
5753:../src/wolfcrypt/src/ecc.c ****     r = key->r;
5754:../src/wolfcrypt/src/ecc.c ****     s = key->s;
5755:../src/wolfcrypt/src/ecc.c **** 
5756:../src/wolfcrypt/src/ecc.c ****     switch (key->state) {
5757:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_NONE:
5758:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_SIGN_DO:
5759:../src/wolfcrypt/src/ecc.c ****             key->state = ECC_STATE_SIGN_DO;
5760:../src/wolfcrypt/src/ecc.c **** 
5761:../src/wolfcrypt/src/ecc.c ****             if ((err = mp_init_multi(r, s, NULL, NULL, NULL, NULL)) != MP_OKAY){
5762:../src/wolfcrypt/src/ecc.c ****                 break;
5763:../src/wolfcrypt/src/ecc.c ****             }
5764:../src/wolfcrypt/src/ecc.c **** 
5765:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);
5766:../src/wolfcrypt/src/ecc.c ****             if (err < 0) {
5767:../src/wolfcrypt/src/ecc.c ****                 break;
5768:../src/wolfcrypt/src/ecc.c ****             }
5769:../src/wolfcrypt/src/ecc.c **** 
5770:../src/wolfcrypt/src/ecc.c ****             FALL_THROUGH;
5771:../src/wolfcrypt/src/ecc.c **** 
5772:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_SIGN_ENCODE:
5773:../src/wolfcrypt/src/ecc.c ****             key->state = ECC_STATE_SIGN_ENCODE;
5774:../src/wolfcrypt/src/ecc.c **** 
5775:../src/wolfcrypt/src/ecc.c ****             if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
5776:../src/wolfcrypt/src/ecc.c ****                 #ifdef HAVE_CAVIUM_V
5777:../src/wolfcrypt/src/ecc.c ****                     /* Nitrox requires r and s in sep buffer, so split it */
5778:../src/wolfcrypt/src/ecc.c ****                     NitroxEccRsSplit(key, &r->raw, &s->raw);
5779:../src/wolfcrypt/src/ecc.c ****                 #endif
5780:../src/wolfcrypt/src/ecc.c ****                 #ifndef WOLFSSL_ASYNC_CRYPT_TEST
5781:../src/wolfcrypt/src/ecc.c ****                     /* only do this if not simulator, since it overwrites result */
5782:../src/wolfcrypt/src/ecc.c ****                     wc_bigint_to_mp(&r->raw, r);
5783:../src/wolfcrypt/src/ecc.c ****                     wc_bigint_to_mp(&s->raw, s);
5784:../src/wolfcrypt/src/ecc.c ****                 #endif
5785:../src/wolfcrypt/src/ecc.c ****             }
5786:../src/wolfcrypt/src/ecc.c **** 
5787:../src/wolfcrypt/src/ecc.c ****             /* encoded with DSA header */
5788:../src/wolfcrypt/src/ecc.c ****             err = StoreECC_DSA_Sig(out, outlen, r, s);
5789:../src/wolfcrypt/src/ecc.c **** 
5790:../src/wolfcrypt/src/ecc.c ****             /* done with R/S */
5791:../src/wolfcrypt/src/ecc.c ****             mp_clear(r);
5792:../src/wolfcrypt/src/ecc.c ****             mp_clear(s);
5793:../src/wolfcrypt/src/ecc.c ****             break;
5794:../src/wolfcrypt/src/ecc.c **** 
5795:../src/wolfcrypt/src/ecc.c ****         default:
5796:../src/wolfcrypt/src/ecc.c ****             err = BAD_STATE_E;
5797:../src/wolfcrypt/src/ecc.c ****             break;
5798:../src/wolfcrypt/src/ecc.c ****     }
5799:../src/wolfcrypt/src/ecc.c **** 
5800:../src/wolfcrypt/src/ecc.c ****     /* if async pending then return and skip done cleanup below */
5801:../src/wolfcrypt/src/ecc.c ****     if (err == WC_PENDING_E) {
5802:../src/wolfcrypt/src/ecc.c ****         key->state++;
5803:../src/wolfcrypt/src/ecc.c ****         return err;
5804:../src/wolfcrypt/src/ecc.c ****     }
5805:../src/wolfcrypt/src/ecc.c **** 
5806:../src/wolfcrypt/src/ecc.c ****     /* cleanup */
5807:../src/wolfcrypt/src/ecc.c ****     wc_ecc_free_async(key);
5808:../src/wolfcrypt/src/ecc.c ****     key->state = ECC_STATE_NONE;
5809:../src/wolfcrypt/src/ecc.c **** 
5810:../src/wolfcrypt/src/ecc.c ****     return err;
5811:../src/wolfcrypt/src/ecc.c **** }
5812:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */
5813:../src/wolfcrypt/src/ecc.c **** 
5814:../src/wolfcrypt/src/ecc.c **** /**
5815:../src/wolfcrypt/src/ecc.c ****  Sign a message digest
5816:../src/wolfcrypt/src/ecc.c ****  in        The message digest to sign
5817:../src/wolfcrypt/src/ecc.c ****  inlen     The length of the digest
5818:../src/wolfcrypt/src/ecc.c ****  out       [out] The destination for the signature
5819:../src/wolfcrypt/src/ecc.c ****  outlen    [in/out] The max size and resulting size of the signature
5820:../src/wolfcrypt/src/ecc.c ****  key       A private ECC key
5821:../src/wolfcrypt/src/ecc.c ****  return    MP_OKAY if successful
5822:../src/wolfcrypt/src/ecc.c ****  */
5823:../src/wolfcrypt/src/ecc.c **** WOLFSSL_ABI
5824:../src/wolfcrypt/src/ecc.c **** int wc_ecc_sign_hash(const byte* in, word32 inlen, byte* out, word32 *outlen,
5825:../src/wolfcrypt/src/ecc.c ****                      WC_RNG* rng, ecc_key* key)
5826:../src/wolfcrypt/src/ecc.c **** {
 8194                             		.loc 2 5826 1
 8195 0000 7E AA                   		push.l	r10
 8196                             	.LCFI148:
 8197 0002 7E A6                   		push.l	r6
 8198                             	.LCFI149:
 8199 0004 71 0A C0                		add	#-64, r0, r10
 8200                             	.LCFI150:
 8201 0007 71 A0 F8                		add	#-8, r10, r0
 8202                             	.LCFI151:
 8203 000a 75 46 4C                		mov.L	#0x4c, r6
 8204 000d 4B A6                   		add	r10, r6
 8205 000f E7 A1 0A                		mov.L	r1, 40[r10]
 8206 0012 E7 A2 0B                		mov.L	r2, 44[r10]
 8207 0015 E7 A3 0C                		mov.L	r3, 48[r10]
 8208 0018 E7 A4 0D                		mov.L	r4, 52[r10]
5827:../src/wolfcrypt/src/ecc.c ****     int err;
5828:../src/wolfcrypt/src/ecc.c **** 
5829:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(WC_ASYNC_ENABLE_ECC)
5830:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
5831:../src/wolfcrypt/src/ecc.c ****     mp_int *r = NULL, *s = NULL;
 8209                             		.loc 2 5831 13
 8210 001b F8 A6 00                		mov.L	#0, [r10]
 8211                             		.loc 2 5831 24
 8212 001e F9 A6 01 00             		mov.L	#0, 4[r10]
5832:../src/wolfcrypt/src/ecc.c **** #else
5833:../src/wolfcrypt/src/ecc.c ****     mp_int r[1], s[1];
5834:../src/wolfcrypt/src/ecc.c **** #endif
5835:../src/wolfcrypt/src/ecc.c **** #endif
5836:../src/wolfcrypt/src/ecc.c **** 
5837:../src/wolfcrypt/src/ecc.c ****     if (in == NULL || out == NULL || outlen == NULL || key == NULL) {
 8213                             		.loc 2 5837 8
 8214 0022 ED A5 0A                		mov.L	40[r10], r5
 8215 0025 61 05                   		cmp	#0, r5
 8216 0027 20 14                   		beq	.L564
 8217                             		.loc 2 5837 20 discriminator 1
 8218 0029 ED A5 0C                		mov.L	48[r10], r5
 8219 002c 61 05                   		cmp	#0, r5
 8220 002e 20 0D                   		beq	.L564
 8221                             		.loc 2 5837 35 discriminator 2
 8222 0030 ED A5 0D                		mov.L	52[r10], r5
 8223 0033 61 05                   		cmp	#0, r5
 8224 0035 16                      		beq	.L564
 8225                             		.loc 2 5837 53 discriminator 3
 8226 0036 A8 6D                   		mov.L	4[r6], r5
 8227 0038 61 05                   		cmp	#0, r5
 8228 003a 18                      		bne	.L565
 8229                             		.balign 8,3,2
 8230                             	.L564:
5838:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 8231                             		.loc 2 5838 16
 8232 003b FB 5A 56 FF             		mov.L	#-170, r5
 8233 003f 38 59 01                		bra	.L566
 8234                             	.L565:
5839:../src/wolfcrypt/src/ecc.c ****     }
5840:../src/wolfcrypt/src/ecc.c **** 
5841:../src/wolfcrypt/src/ecc.c **** #ifdef WOLF_CRYPTO_CB
5842:../src/wolfcrypt/src/ecc.c ****     if (key->devId != INVALID_DEVID) {
5843:../src/wolfcrypt/src/ecc.c ****         err = wc_CryptoCb_EccSign(in, inlen, out, outlen, rng, key);
5844:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLF_CRYPTO_CB_ONLY_ECC
5845:../src/wolfcrypt/src/ecc.c ****         if (err != CRYPTOCB_UNAVAILABLE)
5846:../src/wolfcrypt/src/ecc.c ****             return err;
5847:../src/wolfcrypt/src/ecc.c ****         /* fall-through when unavailable */
5848:../src/wolfcrypt/src/ecc.c ****     #endif
5849:../src/wolfcrypt/src/ecc.c ****     }
5850:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLF_CRYPTO_CB_ONLY_ECC
5851:../src/wolfcrypt/src/ecc.c ****     else {
5852:../src/wolfcrypt/src/ecc.c ****         err = NO_VALID_DEVID;
5853:../src/wolfcrypt/src/ecc.c ****     }
5854:../src/wolfcrypt/src/ecc.c ****     #endif
5855:../src/wolfcrypt/src/ecc.c **** #endif
5856:../src/wolfcrypt/src/ecc.c **** 
5857:../src/wolfcrypt/src/ecc.c **** #ifndef WOLF_CRYPTO_CB_ONLY_ECC
5858:../src/wolfcrypt/src/ecc.c ****     if (rng == NULL) {
 8235                             		.loc 2 5858 8
 8236 0042 EC 65                   		mov.L	[r6], r5
 8237 0044 61 05                   		cmp	#0, r5
 8238 0046 21 13                   		bne	.L567
5859:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("ECC sign RNG missing");
 8239                             		.loc 2 5859 9
 8240 0048 FB 12 70 0A 00 00       		mov.L	#.LC41, r1
 8241 004e 05 00 00 00             		bsr	_WOLFSSL_MSG
5860:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 8242                             		.loc 2 5860 16
 8243 0052 FB 5A 56 FF             		mov.L	#-170, r5
 8244 0056 38 42 01                		bra	.L566
 8245                             	.L567:
5861:../src/wolfcrypt/src/ecc.c ****     }
5862:../src/wolfcrypt/src/ecc.c **** 
5863:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
5864:../src/wolfcrypt/src/ecc.c ****     /* handle async cases */
5865:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_sign_hash_async(in, inlen, out, outlen, rng, key);
5866:../src/wolfcrypt/src/ecc.c **** #else
5867:../src/wolfcrypt/src/ecc.c **** 
5868:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
5869:../src/wolfcrypt/src/ecc.c ****     r = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 8246                             		.loc 2 5869 18
 8247 0059 FB 1A 10 03             		mov.L	#0x310, r1
 8248 005d 05 00 00 00             		bsr	_wolfSSL_Malloc
 8249 0061 E3 A1                   		mov.L	r1, [r10]
5870:../src/wolfcrypt/src/ecc.c ****     if (r == NULL)
 8250                             		.loc 2 5870 8
 8251 0063 EC A5                   		mov.L	[r10], r5
 8252 0065 61 05                   		cmp	#0, r5
 8253 0067 1F                      		bne	.L568
5871:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 8254                             		.loc 2 5871 16
 8255 0068 FB 56 83                		mov.L	#-125, r5
 8256 006b 38 2D 01                		bra	.L566
 8257                             	.L568:
5872:../src/wolfcrypt/src/ecc.c ****     s = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 8258                             		.loc 2 5872 18
 8259 006e FB 1A 10 03             		mov.L	#0x310, r1
 8260 0072 05 00 00 00             		bsr	_wolfSSL_Malloc
 8261 0076 E7 A1 01                		mov.L	r1, 4[r10]
5873:../src/wolfcrypt/src/ecc.c ****     if (s == NULL) {
 8262                             		.loc 2 5873 8
 8263 0079 ED A5 01                		mov.L	4[r10], r5
 8264 007c 61 05                   		cmp	#0, r5
 8265 007e 21 1A                   		bne	.L569
 8266                             	.LBB46:
5874:../src/wolfcrypt/src/ecc.c ****         XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 8267                             		.loc 2 5874 9
 8268 0080 EC A5                   		mov.L	[r10], r5
 8269 0082 E7 A5 02                		mov.L	r5, 8[r10]
 8270 0085 ED A5 02                		mov.L	8[r10], r5
 8271 0088 61 05                   		cmp	#0, r5
 8272 008a 10                      		beq	.L570
 8273                             		.loc 2 5874 9 is_stmt 0 discriminator 1
 8274 008b ED A1 02                		mov.L	8[r10], r1
 8275 008e 05 00 00 00             		bsr	_wolfSSL_Free
 8276                             	.L570:
 8277                             	.LBE46:
5875:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 8278                             		.loc 2 5875 16 is_stmt 1
 8279 0092 FB 56 83                		mov.L	#-125, r5
 8280 0095 38 03 01                		bra	.L566
 8281                             	.L569:
5876:../src/wolfcrypt/src/ecc.c ****     }
5877:../src/wolfcrypt/src/ecc.c **** #endif
5878:../src/wolfcrypt/src/ecc.c ****     XMEMSET(r, 0, sizeof(mp_int));
 8282                             		.loc 2 5878 5
 8283 0098 FB 3A 10 03             		mov.L	#0x310, r3
 8284 009c 66 02                   		mov.L	#0, r2
 8285 009e EC A1                   		mov.L	[r10], r1
 8286 00a0 05 00 00 00             		bsr	_memset
5879:../src/wolfcrypt/src/ecc.c ****     XMEMSET(s, 0, sizeof(mp_int));
 8287                             		.loc 2 5879 5
 8288 00a4 FB 3A 10 03             		mov.L	#0x310, r3
 8289 00a8 66 02                   		mov.L	#0, r2
 8290 00aa ED A1 01                		mov.L	4[r10], r1
 8291 00ad 05 00 00 00             		bsr	_memset
5880:../src/wolfcrypt/src/ecc.c **** 
5881:../src/wolfcrypt/src/ecc.c ****     if ((err = mp_init_multi(r, s, NULL, NULL, NULL, NULL)) != MP_OKAY){
 8292                             		.loc 2 5881 16
 8293 00b1 3E 01 00                		mov.L	#0, 4[r0]
 8294 00b4 F8 06 00                		mov.L	#0, [r0]
 8295 00b7 66 04                   		mov.L	#0, r4
 8296 00b9 66 03                   		mov.L	#0, r3
 8297 00bb ED A2 01                		mov.L	4[r10], r2
 8298 00be EC A1                   		mov.L	[r10], r1
 8299 00c0 05 00 00 00             		bsr	_sp_init_multi
 8300 00c4 E7 A1 03                		mov.L	r1, 12[r10]
 8301                             		.loc 2 5881 8
 8302 00c7 ED A5 03                		mov.L	12[r10], r5
 8303 00ca 61 05                   		cmp	#0, r5
 8304 00cc 20 2D                   		beq	.L571
 8305                             	.LBB47:
5882:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
5883:../src/wolfcrypt/src/ecc.c ****         XFREE(s, key->heap, DYNAMIC_TYPE_ECC);
 8306                             		.loc 2 5883 9
 8307 00ce ED A5 01                		mov.L	4[r10], r5
 8308 00d1 E7 A5 04                		mov.L	r5, 16[r10]
 8309 00d4 ED A5 04                		mov.L	16[r10], r5
 8310 00d7 61 05                   		cmp	#0, r5
 8311 00d9 10                      		beq	.L572
 8312                             		.loc 2 5883 9 is_stmt 0 discriminator 1
 8313 00da ED A1 04                		mov.L	16[r10], r1
 8314 00dd 05 00 00 00             		bsr	_wolfSSL_Free
 8315                             	.L572:
 8316                             	.LBE47:
 8317                             	.LBB48:
5884:../src/wolfcrypt/src/ecc.c ****         XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 8318                             		.loc 2 5884 9 is_stmt 1
 8319 00e1 EC A5                   		mov.L	[r10], r5
 8320 00e3 E7 A5 05                		mov.L	r5, 20[r10]
 8321 00e6 ED A5 05                		mov.L	20[r10], r5
 8322 00e9 61 05                   		cmp	#0, r5
 8323 00eb 10                      		beq	.L573
 8324                             		.loc 2 5884 9 is_stmt 0 discriminator 1
 8325 00ec ED A1 05                		mov.L	20[r10], r1
 8326 00ef 05 00 00 00             		bsr	_wolfSSL_Free
 8327                             	.L573:
 8328                             	.LBE48:
5885:../src/wolfcrypt/src/ecc.c ****     #endif
5886:../src/wolfcrypt/src/ecc.c ****         return err;
 8329                             		.loc 2 5886 16 is_stmt 1
 8330 00f3 ED A5 03                		mov.L	12[r10], r5
 8331 00f6 38 A2 00                		bra	.L566
 8332                             	.L571:
5887:../src/wolfcrypt/src/ecc.c ****     }
5888:../src/wolfcrypt/src/ecc.c **** 
5889:../src/wolfcrypt/src/ecc.c **** /* hardware crypto */
5890:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A) || \
5891:../src/wolfcrypt/src/ecc.c ****     defined(PLUTON_CRYPTO_ECC) || defined(WOLFSSL_CRYPTOCELL) || \
5892:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_SILABS_SE_ACCEL) || defined(WOLFSSL_KCAPI_ECC) || \
5893:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_SE050)
5894:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_sign_hash_hw(in, inlen, r, s, out, outlen, rng, key);
5895:../src/wolfcrypt/src/ecc.c **** #else
5896:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);
 8333                             		.loc 2 5896 11
 8334 00f9 ED A5 01                		mov.L	4[r10], r5
 8335 00fc A0 0D                   		mov.L	r5, 4[r0]
 8336 00fe EC A5                   		mov.L	[r10], r5
 8337 0100 E3 05                   		mov.L	r5, [r0]
 8338 0102 A8 6C                   		mov.L	4[r6], r4
 8339 0104 EC 63                   		mov.L	[r6], r3
 8340 0106 ED A2 0B                		mov.L	44[r10], r2
 8341 0109 ED A1 0A                		mov.L	40[r10], r1
 8342 010c 05 00 00 00             		bsr	_wc_ecc_sign_hash_ex
 8343 0110 E7 A1 03                		mov.L	r1, 12[r10]
5897:../src/wolfcrypt/src/ecc.c **** #endif
5898:../src/wolfcrypt/src/ecc.c ****     if (err < 0) {
 8344                             		.loc 2 5898 8
 8345 0113 ED A5 03                		mov.L	12[r10], r5
 8346 0116 61 05                   		cmp	#0, r5
 8347 0118 28 39                   		bge	.L574
5899:../src/wolfcrypt/src/ecc.c ****         mp_clear(r);
 8348                             		.loc 2 5899 9
 8349 011a EC A1                   		mov.L	[r10], r1
 8350 011c 05 00 00 00             		bsr	_sp_clear
5900:../src/wolfcrypt/src/ecc.c ****         mp_clear(s);
 8351                             		.loc 2 5900 9
 8352 0120 ED A1 01                		mov.L	4[r10], r1
 8353 0123 05 00 00 00             		bsr	_sp_clear
 8354                             	.LBB49:
5901:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
5902:../src/wolfcrypt/src/ecc.c ****         XFREE(s, key->heap, DYNAMIC_TYPE_ECC);
 8355                             		.loc 2 5902 9
 8356 0127 ED A5 01                		mov.L	4[r10], r5
 8357 012a E7 A5 06                		mov.L	r5, 24[r10]
 8358 012d ED A5 06                		mov.L	24[r10], r5
 8359 0130 61 05                   		cmp	#0, r5
 8360 0132 10                      		beq	.L575
 8361                             		.loc 2 5902 9 is_stmt 0 discriminator 1
 8362 0133 ED A1 06                		mov.L	24[r10], r1
 8363 0136 05 00 00 00             		bsr	_wolfSSL_Free
 8364                             	.L575:
 8365                             	.LBE49:
 8366                             	.LBB50:
5903:../src/wolfcrypt/src/ecc.c ****         XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 8367                             		.loc 2 5903 9 is_stmt 1
 8368 013a EC A5                   		mov.L	[r10], r5
 8369 013c E7 A5 07                		mov.L	r5, 28[r10]
 8370 013f ED A5 07                		mov.L	28[r10], r5
 8371 0142 61 05                   		cmp	#0, r5
 8372 0144 10                      		beq	.L576
 8373                             		.loc 2 5903 9 is_stmt 0 discriminator 1
 8374 0145 ED A1 07                		mov.L	28[r10], r1
 8375 0148 05 00 00 00             		bsr	_wolfSSL_Free
 8376                             	.L576:
 8377                             	.LBE50:
5904:../src/wolfcrypt/src/ecc.c ****     #endif
5905:../src/wolfcrypt/src/ecc.c ****         return err;
 8378                             		.loc 2 5905 16 is_stmt 1
 8379 014c ED A5 03                		mov.L	12[r10], r5
 8380 014f 2E 49                   		bra	.L566
 8381                             	.L574:
5906:../src/wolfcrypt/src/ecc.c ****     }
5907:../src/wolfcrypt/src/ecc.c **** 
5908:../src/wolfcrypt/src/ecc.c ****     /* encoded with DSA header */
5909:../src/wolfcrypt/src/ecc.c ****     err = StoreECC_DSA_Sig(out, outlen, r, s);
 8382                             		.loc 2 5909 11
 8383 0151 ED A4 01                		mov.L	4[r10], r4
 8384 0154 EC A3                   		mov.L	[r10], r3
 8385 0156 ED A2 0D                		mov.L	52[r10], r2
 8386 0159 ED A1 0C                		mov.L	48[r10], r1
 8387 015c 05 00 00 00             		bsr	_StoreECC_DSA_Sig
 8388 0160 E7 A1 03                		mov.L	r1, 12[r10]
5910:../src/wolfcrypt/src/ecc.c **** 
5911:../src/wolfcrypt/src/ecc.c ****     /* cleanup */
5912:../src/wolfcrypt/src/ecc.c ****     mp_clear(r);
 8389                             		.loc 2 5912 5
 8390 0163 EC A1                   		mov.L	[r10], r1
 8391 0165 05 00 00 00             		bsr	_sp_clear
5913:../src/wolfcrypt/src/ecc.c ****     mp_clear(s);
 8392                             		.loc 2 5913 5
 8393 0169 ED A1 01                		mov.L	4[r10], r1
 8394 016c 05 00 00 00             		bsr	_sp_clear
 8395                             	.LBB51:
5914:../src/wolfcrypt/src/ecc.c **** 
5915:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
5916:../src/wolfcrypt/src/ecc.c ****     XFREE(s, key->heap, DYNAMIC_TYPE_ECC);
 8396                             		.loc 2 5916 5
 8397 0170 ED A5 01                		mov.L	4[r10], r5
 8398 0173 E7 A5 08                		mov.L	r5, 32[r10]
 8399 0176 ED A5 08                		mov.L	32[r10], r5
 8400 0179 61 05                   		cmp	#0, r5
 8401 017b 10                      		beq	.L577
 8402                             		.loc 2 5916 5 is_stmt 0 discriminator 1
 8403 017c ED A1 08                		mov.L	32[r10], r1
 8404 017f 05 00 00 00             		bsr	_wolfSSL_Free
 8405                             	.L577:
 8406                             	.LBE51:
 8407                             	.LBB52:
5917:../src/wolfcrypt/src/ecc.c ****     XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 8408                             		.loc 2 5917 5 is_stmt 1
 8409 0183 EC A5                   		mov.L	[r10], r5
 8410 0185 E7 A5 09                		mov.L	r5, 36[r10]
 8411 0188 ED A5 09                		mov.L	36[r10], r5
 8412 018b 61 05                   		cmp	#0, r5
 8413 018d 10                      		beq	.L578
 8414                             		.loc 2 5917 5 is_stmt 0 discriminator 1
 8415 018e ED A1 09                		mov.L	36[r10], r1
 8416 0191 05 00 00 00             		bsr	_wolfSSL_Free
 8417                             	.L578:
 8418                             	.LBE52:
5918:../src/wolfcrypt/src/ecc.c **** #endif
5919:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ASYNC_CRYPT */
5920:../src/wolfcrypt/src/ecc.c **** #else
5921:../src/wolfcrypt/src/ecc.c ****     (void)rng;
5922:../src/wolfcrypt/src/ecc.c ****     (void)inlen;
5923:../src/wolfcrypt/src/ecc.c ****     (void)s;
5924:../src/wolfcrypt/src/ecc.c ****     (void)r;
5925:../src/wolfcrypt/src/ecc.c ****     (void)err;
5926:../src/wolfcrypt/src/ecc.c **** #endif /* WOLF_CRYPTO_CB_ONLY_ECC */
5927:../src/wolfcrypt/src/ecc.c **** 
5928:../src/wolfcrypt/src/ecc.c ****     return err;
 8419                             		.loc 2 5928 12 is_stmt 1
 8420 0195 ED A5 03                		mov.L	12[r10], r5
 8421                             		.balign 8,3,1
 8422                             	.L566:
5929:../src/wolfcrypt/src/ecc.c **** }
 8423                             		.loc 2 5929 1
 8424 0198 EF 51                   		mov.L	r5, r1
 8425 019a 71 00 48                		add	#0x48, r0
 8426 019d 7E B6                   		pop	r6
 8427 019f 7E BA                   		pop	r10
 8428 01a1 02                      		rts
 8429                             	.LFE103:
 8431 01a2 74 10 01 00 00 00       		.section	.text.ecc_sign_hash_sw,"ax",@progbits
 8433                             	_ecc_sign_hash_sw:
 8434                             	.LFB104:
5930:../src/wolfcrypt/src/ecc.c **** #endif /* !NO_ASN */
5931:../src/wolfcrypt/src/ecc.c **** 
5932:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECDSA_DETERMINISTIC_K) || \
5933:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT)
5934:../src/wolfcrypt/src/ecc.c **** /* returns MP_OKAY on success */
5935:../src/wolfcrypt/src/ecc.c **** static int deterministic_sign_helper(const byte* in, word32 inlen, ecc_key* key)
5936:../src/wolfcrypt/src/ecc.c **** {
5937:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
5938:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(1);
5939:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(1, err);
5940:../src/wolfcrypt/src/ecc.c **** 
5941:../src/wolfcrypt/src/ecc.c ****     /* get curve order */
5942:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
5943:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
5944:../src/wolfcrypt/src/ecc.c ****     }
5945:../src/wolfcrypt/src/ecc.c **** 
5946:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
5947:../src/wolfcrypt/src/ecc.c ****         /* if key->sign_k is NULL then create a buffer for the mp_int
5948:../src/wolfcrypt/src/ecc.c ****          * if not NULL then assume the user correctly set deterministic flag and
5949:../src/wolfcrypt/src/ecc.c ****          *    that the key->sign_k holds a previously malloc'd mp_int buffer */
5950:../src/wolfcrypt/src/ecc.c ****         if (key->sign_k == NULL) {
5951:../src/wolfcrypt/src/ecc.c ****             key->sign_k = (mp_int*)XMALLOC(sizeof(mp_int), key->heap,
5952:../src/wolfcrypt/src/ecc.c ****                                                             DYNAMIC_TYPE_ECC);
5953:../src/wolfcrypt/src/ecc.c ****         }
5954:../src/wolfcrypt/src/ecc.c **** 
5955:../src/wolfcrypt/src/ecc.c ****         if (key->sign_k != NULL) {
5956:../src/wolfcrypt/src/ecc.c ****             /* currently limiting to SHA256 for auto create */
5957:../src/wolfcrypt/src/ecc.c ****             if (mp_init(key->sign_k) != MP_OKAY ||
5958:../src/wolfcrypt/src/ecc.c ****                 wc_ecc_gen_deterministic_k(in, inlen,
5959:../src/wolfcrypt/src/ecc.c ****                         WC_HASH_TYPE_SHA256, &key->k, key->sign_k,
5960:../src/wolfcrypt/src/ecc.c ****                         curve->order, key->heap) != 0) {
5961:../src/wolfcrypt/src/ecc.c ****                 mp_free(key->sign_k);
5962:../src/wolfcrypt/src/ecc.c ****                 XFREE(key->sign_k, key->heap, DYNAMIC_TYPE_ECC);
5963:../src/wolfcrypt/src/ecc.c ****                 key->sign_k = NULL;
5964:../src/wolfcrypt/src/ecc.c ****                 err = ECC_PRIV_KEY_E;
5965:../src/wolfcrypt/src/ecc.c ****             }
5966:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_CHECK_MEM_ZERO
5967:../src/wolfcrypt/src/ecc.c ****             else {
5968:../src/wolfcrypt/src/ecc.c ****                 mp_memzero_add("deterministic_sign_helper sign_k", key->sign_k);
5969:../src/wolfcrypt/src/ecc.c ****             }
5970:../src/wolfcrypt/src/ecc.c ****         #endif
5971:../src/wolfcrypt/src/ecc.c ****         }
5972:../src/wolfcrypt/src/ecc.c ****         else {
5973:../src/wolfcrypt/src/ecc.c ****             err = MEMORY_E;
5974:../src/wolfcrypt/src/ecc.c ****         }
5975:../src/wolfcrypt/src/ecc.c ****     }
5976:../src/wolfcrypt/src/ecc.c **** 
5977:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
5978:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
5979:../src/wolfcrypt/src/ecc.c ****     return err;
5980:../src/wolfcrypt/src/ecc.c **** }
5981:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ECDSA_DETERMINISTIC_K ||
5982:../src/wolfcrypt/src/ecc.c ****           WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT */
5983:../src/wolfcrypt/src/ecc.c **** 
5984:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_STM32_PKA)
5985:../src/wolfcrypt/src/ecc.c **** int wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,
5986:../src/wolfcrypt/src/ecc.c ****                      ecc_key* key, mp_int *r, mp_int *s)
5987:../src/wolfcrypt/src/ecc.c **** {
5988:../src/wolfcrypt/src/ecc.c ****     return stm32_ecc_sign_hash_ex(in, inlen, rng, key, r, s);
5989:../src/wolfcrypt/src/ecc.c **** }
5990:../src/wolfcrypt/src/ecc.c **** #elif !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
5991:../src/wolfcrypt/src/ecc.c ****       !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_KCAPI_ECC)
5992:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_MATH
5993:../src/wolfcrypt/src/ecc.c **** static int ecc_sign_hash_sw(ecc_key* key, ecc_key* pubkey, WC_RNG* rng,
5994:../src/wolfcrypt/src/ecc.c ****                             ecc_curve_spec* curve, mp_int* e, mp_int* r,
5995:../src/wolfcrypt/src/ecc.c ****                             mp_int* s)
5996:../src/wolfcrypt/src/ecc.c **** {
 8435                             		.loc 2 5996 1
 8436 0000 7E AA                   		push.l	r10
 8437                             	.LCFI152:
 8438 0002 7E A6                   		push.l	r6
 8439                             	.LCFI153:
 8440 0004 71 0A C8                		add	#-56, r0, r10
 8441                             	.LCFI154:
 8442 0007 71 A0 FC                		add	#-4, r10, r0
 8443                             	.LCFI155:
 8444 000a 75 46 44                		mov.L	#0x44, r6
 8445 000d 4B A6                   		add	r10, r6
 8446 000f E7 A1 07                		mov.L	r1, 28[r10]
 8447 0012 E7 A2 08                		mov.L	r2, 32[r10]
 8448 0015 E7 A3 09                		mov.L	r3, 36[r10]
 8449 0018 E7 A4 0A                		mov.L	r4, 40[r10]
5997:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 8450                             		.loc 2 5997 9
 8451 001b F8 A6 00                		mov.L	#0, [r10]
5998:../src/wolfcrypt/src/ecc.c ****     int loop_check = 0;
 8452                             		.loc 2 5998 9
 8453 001e F9 A6 01 00             		mov.L	#0, 4[r10]
5999:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
6000:../src/wolfcrypt/src/ecc.c ****     mp_int* b = NULL;
 8454                             		.loc 2 6000 13
 8455 0022 F9 A6 02 00             		mov.L	#0, 8[r10]
6001:../src/wolfcrypt/src/ecc.c **** #else
6002:../src/wolfcrypt/src/ecc.c ****     mp_int  b[1];
6003:../src/wolfcrypt/src/ecc.c **** #endif
6004:../src/wolfcrypt/src/ecc.c **** 
6005:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
6006:../src/wolfcrypt/src/ecc.c ****     b = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 8456                             		.loc 2 6006 18
 8457 0026 FB 1A 10 03             		mov.L	#0x310, r1
 8458 002a 05 00 00 00             		bsr	_wolfSSL_Malloc
 8459 002e E7 A1 02                		mov.L	r1, 8[r10]
6007:../src/wolfcrypt/src/ecc.c ****     if (b == NULL)
 8460                             		.loc 2 6007 8
 8461 0031 ED A5 02                		mov.L	8[r10], r5
 8462 0034 61 05                   		cmp	#0, r5
 8463 0036 1C                      		bne	.L580
6008:../src/wolfcrypt/src/ecc.c ****         err = MEMORY_E;
 8464                             		.loc 2 6008 13
 8465 0037 F8 A6 83                		mov.L	#-125, [r10]
 8466                             	.L580:
6009:../src/wolfcrypt/src/ecc.c **** #endif
6010:../src/wolfcrypt/src/ecc.c **** 
6011:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 8467                             		.loc 2 6011 8
 8468 003a EC A5                   		mov.L	[r10], r5
 8469 003c 61 05                   		cmp	#0, r5
 8470 003e 1A                      		bne	.L581
6012:../src/wolfcrypt/src/ecc.c ****         err = mp_init(b);
 8471                             		.loc 2 6012 15
 8472 003f ED A1 02                		mov.L	8[r10], r1
 8473 0042 05 00 00 00             		bsr	_sp_init
 8474 0046 E3 A1                   		mov.L	r1, [r10]
 8475                             	.L581:
6013:../src/wolfcrypt/src/ecc.c ****     }
6014:../src/wolfcrypt/src/ecc.c **** 
6015:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CUSTOM_CURVES
6016:../src/wolfcrypt/src/ecc.c ****     /* if custom curve, apply params to pubkey */
6017:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY && key->idx == ECC_CUSTOM_IDX) {
6018:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_set_custom_curve(pubkey, key->dp);
6019:../src/wolfcrypt/src/ecc.c ****     }
6020:../src/wolfcrypt/src/ecc.c **** #endif
6021:../src/wolfcrypt/src/ecc.c **** 
6022:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 8476                             		.loc 2 6022 8
 8477 0048 EC A5                   		mov.L	[r10], r5
 8478 004a 61 05                   		cmp	#0, r5
 8479 004c 3B BF 01                		bne	.L586
 8480                             	.L585:
6023:../src/wolfcrypt/src/ecc.c ****         /* Generate blinding value - non-zero value. */
6024:../src/wolfcrypt/src/ecc.c ****         do {
6025:../src/wolfcrypt/src/ecc.c ****             if (++loop_check > 64) {
 8481                             		.loc 2 6025 16
 8482 004f ED A5 01                		mov.L	4[r10], r5
 8483 0052 62 15                   		add	#1, r5
 8484 0054 E7 A5 01                		mov.L	r5, 4[r10]
 8485 0057 ED A5 01                		mov.L	4[r10], r5
 8486 005a 75 55 40                		cmp	#0x40, r5
 8487 005d 2B 08                   		ble	.L583
6026:../src/wolfcrypt/src/ecc.c ****                  err = RNG_FAILURE_E;
 8488                             		.loc 2 6026 22
 8489 005f F8 AA 39 FF             		mov.L	#-199, [r10]
6027:../src/wolfcrypt/src/ecc.c ****                  break;
 8490                             		.loc 2 6027 18
 8491 0063 2E 23                   		bra	.L584
 8492                             	.L583:
6028:../src/wolfcrypt/src/ecc.c ****             }
6029:../src/wolfcrypt/src/ecc.c **** 
6030:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_gen_k(rng, key->dp->size, b, curve->order);
 8493                             		.loc 2 6030 40
 8494 0065 ED A5 07                		mov.L	28[r10], r5
 8495 0068 A9 55                   		mov.L	16[r5], r5
 8496                             		.loc 2 6030 19
 8497 006a EC 52                   		mov.L	[r5], r2
 8498 006c ED A5 0A                		mov.L	40[r10], r5
 8499 006f A8 DD                   		mov.L	12[r5], r5
 8500 0071 EF 54                   		mov.L	r5, r4
 8501 0073 ED A3 02                		mov.L	8[r10], r3
 8502 0076 ED A1 09                		mov.L	36[r10], r1
 8503 0079 05 00 00 00             		bsr	_wc_ecc_gen_k
 8504 007d E3 A1                   		mov.L	r1, [r10]
6031:../src/wolfcrypt/src/ecc.c ****         }
6032:../src/wolfcrypt/src/ecc.c ****         while (err == MP_ZERO_E);
 8505                             		.loc 2 6032 9
 8506 007f EC A5                   		mov.L	[r10], r5
 8507 0081 75 05 87                		cmp	#-121, r5
 8508 0084 20 CB                   		beq	.L585
 8509                             	.L584:
6033:../src/wolfcrypt/src/ecc.c ****         loop_check = 0;
 8510                             		.loc 2 6033 20
 8511 0086 F9 A6 01 00             		mov.L	#0, 4[r10]
6034:../src/wolfcrypt/src/ecc.c ****     }
6035:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
6036:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
6037:../src/wolfcrypt/src/ecc.c ****         mp_memzero_add("ecc_sign_hash_sw b", b);
6038:../src/wolfcrypt/src/ecc.c ****     }
6039:../src/wolfcrypt/src/ecc.c **** #endif
6040:../src/wolfcrypt/src/ecc.c **** 
6041:../src/wolfcrypt/src/ecc.c ****     for (; err == MP_OKAY;) {
 8512                             		.loc 2 6041 5
 8513 008a 38 81 01                		bra	.L586
 8514                             	.L599:
6042:../src/wolfcrypt/src/ecc.c ****         if (++loop_check > 64) {
 8515                             		.loc 2 6042 12
 8516 008d ED A5 01                		mov.L	4[r10], r5
 8517 0090 62 15                   		add	#1, r5
 8518 0092 E7 A5 01                		mov.L	r5, 4[r10]
 8519 0095 ED A5 01                		mov.L	4[r10], r5
 8520 0098 75 55 40                		cmp	#0x40, r5
 8521 009b 2B 09                   		ble	.L587
6043:../src/wolfcrypt/src/ecc.c ****              err = RNG_FAILURE_E;
 8522                             		.loc 2 6043 18
 8523 009d F8 AA 39 FF             		mov.L	#-199, [r10]
6044:../src/wolfcrypt/src/ecc.c ****              break;
 8524                             		.loc 2 6044 14
 8525 00a1 38 8C 01                		bra	.L588
 8526                             	.L587:
6045:../src/wolfcrypt/src/ecc.c ****         }
6046:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECDSA_SET_K) || defined(WOLFSSL_ECDSA_SET_K_ONE_LOOP) || \
6047:../src/wolfcrypt/src/ecc.c ****            defined(WOLFSSL_ECDSA_DETERMINISTIC_K) || \
6048:../src/wolfcrypt/src/ecc.c ****            defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT)
6049:../src/wolfcrypt/src/ecc.c ****         if (key->sign_k != NULL) {
6050:../src/wolfcrypt/src/ecc.c ****             if (loop_check > 1) {
6051:../src/wolfcrypt/src/ecc.c ****                err = RNG_FAILURE_E;
6052:../src/wolfcrypt/src/ecc.c ****                break;
6053:../src/wolfcrypt/src/ecc.c ****             }
6054:../src/wolfcrypt/src/ecc.c **** 
6055:../src/wolfcrypt/src/ecc.c ****             /* use provided sign_k */
6056:../src/wolfcrypt/src/ecc.c ****             err = mp_copy(key->sign_k, &pubkey->k);
6057:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY) break;
6058:../src/wolfcrypt/src/ecc.c **** 
6059:../src/wolfcrypt/src/ecc.c ****             /* free sign_k, so only used once */
6060:../src/wolfcrypt/src/ecc.c ****             mp_forcezero(key->sign_k);
6061:../src/wolfcrypt/src/ecc.c ****             mp_free(key->sign_k);
6062:../src/wolfcrypt/src/ecc.c ****             XFREE(key->sign_k, key->heap, DYNAMIC_TYPE_ECC);
6063:../src/wolfcrypt/src/ecc.c ****             key->sign_k = NULL;
6064:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_ECDSA_SET_K_ONE_LOOP
6065:../src/wolfcrypt/src/ecc.c ****             loop_check = 64;
6066:../src/wolfcrypt/src/ecc.c ****     #endif
6067:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_ECDSA_DETERMINISTIC_K) || \
6068:../src/wolfcrypt/src/ecc.c ****         defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT)
6069:../src/wolfcrypt/src/ecc.c ****             if (key->deterministic == 1) {
6070:../src/wolfcrypt/src/ecc.c ****                 /* sign_k generated earlier in function for SP calls.
6071:../src/wolfcrypt/src/ecc.c ****                  * Only go through the loop once and fail if error */
6072:../src/wolfcrypt/src/ecc.c ****                 loop_check = 64;
6073:../src/wolfcrypt/src/ecc.c ****             }
6074:../src/wolfcrypt/src/ecc.c ****     #endif
6075:../src/wolfcrypt/src/ecc.c **** 
6076:../src/wolfcrypt/src/ecc.c ****             /* compute public key based on provided "k" */
6077:../src/wolfcrypt/src/ecc.c ****             err = ecc_make_pub_ex(pubkey, curve, NULL, rng);
6078:../src/wolfcrypt/src/ecc.c ****         }
6079:../src/wolfcrypt/src/ecc.c ****         else
6080:../src/wolfcrypt/src/ecc.c **** #endif
6081:../src/wolfcrypt/src/ecc.c ****         {
6082:../src/wolfcrypt/src/ecc.c ****             err = _ecc_make_key_ex(rng, key->dp->size, pubkey, key->dp->id,
 8527                             		.loc 2 6082 44
 8528 00a4 ED A5 07                		mov.L	28[r10], r5
 8529 00a7 A9 55                   		mov.L	16[r5], r5
 8530                             		.loc 2 6082 19
 8531 00a9 EC 52                   		mov.L	[r5], r2
 8532                             		.loc 2 6082 67
 8533 00ab ED A5 07                		mov.L	28[r10], r5
 8534 00ae A9 55                   		mov.L	16[r5], r5
 8535                             		.loc 2 6082 19
 8536 00b0 A8 5D                   		mov.L	4[r5], r5
 8537 00b2 F8 06 00                		mov.L	#0, [r0]
 8538 00b5 EF 54                   		mov.L	r5, r4
 8539 00b7 ED A3 08                		mov.L	32[r10], r3
 8540 00ba ED A1 09                		mov.L	36[r10], r1
 8541 00bd 05 00 00 00             		bsr	__ecc_make_key_ex
 8542 00c1 E3 A1                   		mov.L	r1, [r10]
6083:../src/wolfcrypt/src/ecc.c ****                     WC_ECC_FLAG_NONE);
6084:../src/wolfcrypt/src/ecc.c ****         }
6085:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_CHECK_MEM_ZERO
6086:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
6087:../src/wolfcrypt/src/ecc.c ****             mp_memzero_add("ecc_sign_hash_sw k", &pubkey->k);
6088:../src/wolfcrypt/src/ecc.c ****         }
6089:../src/wolfcrypt/src/ecc.c ****     #endif
6090:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_ASYNC_CRYPT
6091:../src/wolfcrypt/src/ecc.c ****         /* for async do blocking wait here */
6092:../src/wolfcrypt/src/ecc.c ****         err = wc_AsyncWait(err, &pubkey->asyncDev, WC_ASYNC_FLAG_NONE);
6093:../src/wolfcrypt/src/ecc.c ****     #endif
6094:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY) break;
 8543                             		.loc 2 6094 12
 8544 00c3 EC A5                   		mov.L	[r10], r5
 8545 00c5 61 05                   		cmp	#0, r5
 8546 00c7 3B 4D 01                		bne	.L602
6095:../src/wolfcrypt/src/ecc.c **** 
6096:../src/wolfcrypt/src/ecc.c ****         /* find r = x1 mod n */
6097:../src/wolfcrypt/src/ecc.c ****         err = mp_mod(pubkey->pubkey.x, curve->order, r);
 8547                             		.loc 2 6097 36
 8548 00ca ED A5 08                		mov.L	32[r10], r5
 8549 00cd 71 54 18                		add	#24, r5, r4
 8550                             		.loc 2 6097 45
 8551 00d0 ED A5 0A                		mov.L	40[r10], r5
 8552 00d3 A8 DD                   		mov.L	12[r5], r5
 8553                             		.loc 2 6097 15
 8554 00d5 A8 6B                   		mov.L	4[r6], r3
 8555 00d7 EF 52                   		mov.L	r5, r2
 8556 00d9 EF 41                   		mov.L	r4, r1
 8557 00db 05 00 00 00             		bsr	_sp_mod
 8558 00df E3 A1                   		mov.L	r1, [r10]
6098:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY) break;
 8559                             		.loc 2 6098 12
 8560 00e1 EC A5                   		mov.L	[r10], r5
 8561 00e3 61 05                   		cmp	#0, r5
 8562 00e5 3B 32 01                		bne	.L603
6099:../src/wolfcrypt/src/ecc.c **** 
6100:../src/wolfcrypt/src/ecc.c ****         if (mp_iszero(r) == MP_NO) {
 8563                             		.loc 2 6100 13
 8564 00e8 A8 6D                   		mov.L	4[r6], r5
 8565 00ea EC 55                   		mov.L	[r5], r5
 8566                             		.loc 2 6100 12
 8567 00ec 61 05                   		cmp	#0, r5
 8568 00ee 3A EA 00                		beq	.L591
 8569                             	.LBB53:
6101:../src/wolfcrypt/src/ecc.c ****             mp_int* ep = &pubkey->k;
 8570                             		.loc 2 6101 21
 8571 00f1 ED A5 08                		mov.L	32[r10], r5
 8572 00f4 72 55 48 09             		add	#0x948, r5
 8573 00f8 E7 A5 03                		mov.L	r5, 12[r10]
6102:../src/wolfcrypt/src/ecc.c ****             mp_int* kp = &pubkey->k;
 8574                             		.loc 2 6102 21
 8575 00fb ED A5 08                		mov.L	32[r10], r5
 8576 00fe 72 55 48 09             		add	#0x948, r5
 8577 0102 E7 A5 04                		mov.L	r5, 16[r10]
6103:../src/wolfcrypt/src/ecc.c ****             mp_int* x  = &key->k;
 8578                             		.loc 2 6103 21
 8579 0105 ED A5 07                		mov.L	28[r10], r5
 8580 0108 72 55 48 09             		add	#0x948, r5
 8581 010c E7 A5 05                		mov.L	r5, 20[r10]
6104:../src/wolfcrypt/src/ecc.c **** 
6105:../src/wolfcrypt/src/ecc.c ****             /* find s = (e + xr)/k
6106:../src/wolfcrypt/src/ecc.c ****                       = b.(e/k.b + x.r/k.b) */
6107:../src/wolfcrypt/src/ecc.c **** 
6108:../src/wolfcrypt/src/ecc.c ****             /* k' = k.b */
6109:../src/wolfcrypt/src/ecc.c ****             err = mp_mulmod(&pubkey->k, b, curve->order, kp);
 8582                             		.loc 2 6109 29
 8583 010f ED A5 08                		mov.L	32[r10], r5
 8584 0112 72 51 48 09             		add	#0x948, r5, r1
 8585                             		.loc 2 6109 49
 8586 0116 ED A5 0A                		mov.L	40[r10], r5
 8587 0119 A8 DD                   		mov.L	12[r5], r5
 8588                             		.loc 2 6109 19
 8589 011b ED A4 04                		mov.L	16[r10], r4
 8590 011e EF 53                   		mov.L	r5, r3
 8591 0120 ED A2 02                		mov.L	8[r10], r2
 8592 0123 05 00 00 00             		bsr	_sp_mulmod
 8593 0127 E3 A1                   		mov.L	r1, [r10]
6110:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY) break;
 8594                             		.loc 2 6110 16
 8595 0129 EC A5                   		mov.L	[r10], r5
 8596 012b 61 05                   		cmp	#0, r5
 8597 012d 3B ED 00                		bne	.L604
6111:../src/wolfcrypt/src/ecc.c **** 
6112:../src/wolfcrypt/src/ecc.c ****             /* k' = 1/k.b
6113:../src/wolfcrypt/src/ecc.c ****                   = 1/k' */
6114:../src/wolfcrypt/src/ecc.c ****             err = mp_invmod(kp, curve->order, kp);
 8598                             		.loc 2 6114 38
 8599 0130 ED A5 0A                		mov.L	40[r10], r5
 8600 0133 A8 DD                   		mov.L	12[r5], r5
 8601                             		.loc 2 6114 19
 8602 0135 ED A3 04                		mov.L	16[r10], r3
 8603 0138 EF 52                   		mov.L	r5, r2
 8604 013a ED A1 04                		mov.L	16[r10], r1
 8605 013d 05 00 00 00             		bsr	_sp_invmod
 8606 0141 E3 A1                   		mov.L	r1, [r10]
6115:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY) break;
 8607                             		.loc 2 6115 16
 8608 0143 EC A5                   		mov.L	[r10], r5
 8609 0145 61 05                   		cmp	#0, r5
 8610 0147 3B D6 00                		bne	.L605
6116:../src/wolfcrypt/src/ecc.c **** 
6117:../src/wolfcrypt/src/ecc.c ****             /* s = x.r */
6118:../src/wolfcrypt/src/ecc.c ****             err = mp_mulmod(x, r, curve->order, s);
 8611                             		.loc 2 6118 40
 8612 014a ED A5 0A                		mov.L	40[r10], r5
 8613 014d A8 DD                   		mov.L	12[r5], r5
 8614                             		.loc 2 6118 19
 8615 014f A8 E4                   		mov.L	8[r6], r4
 8616 0151 EF 53                   		mov.L	r5, r3
 8617 0153 A8 6A                   		mov.L	4[r6], r2
 8618 0155 ED A1 05                		mov.L	20[r10], r1
 8619 0158 05 00 00 00             		bsr	_sp_mulmod
 8620 015c E3 A1                   		mov.L	r1, [r10]
6119:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY) break;
 8621                             		.loc 2 6119 16
 8622 015e EC A5                   		mov.L	[r10], r5
 8623 0160 61 05                   		cmp	#0, r5
 8624 0162 3B BE 00                		bne	.L606
6120:../src/wolfcrypt/src/ecc.c **** 
6121:../src/wolfcrypt/src/ecc.c ****             /* s = x.r/k.b
6122:../src/wolfcrypt/src/ecc.c ****                  = k'.s */
6123:../src/wolfcrypt/src/ecc.c ****             err = mp_mulmod(kp, s, curve->order, s);
 8625                             		.loc 2 6123 41
 8626 0165 ED A5 0A                		mov.L	40[r10], r5
 8627 0168 A8 DD                   		mov.L	12[r5], r5
 8628                             		.loc 2 6123 19
 8629 016a A8 E4                   		mov.L	8[r6], r4
 8630 016c EF 53                   		mov.L	r5, r3
 8631 016e A8 E2                   		mov.L	8[r6], r2
 8632 0170 ED A1 04                		mov.L	16[r10], r1
 8633 0173 05 00 00 00             		bsr	_sp_mulmod
 8634 0177 E3 A1                   		mov.L	r1, [r10]
6124:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY) break;
 8635                             		.loc 2 6124 16
 8636 0179 EC A5                   		mov.L	[r10], r5
 8637 017b 61 05                   		cmp	#0, r5
 8638 017d 3B A6 00                		bne	.L607
6125:../src/wolfcrypt/src/ecc.c **** 
6126:../src/wolfcrypt/src/ecc.c ****             /* e' = e/k.b
6127:../src/wolfcrypt/src/ecc.c ****                   = e.k' */
6128:../src/wolfcrypt/src/ecc.c ****             err = mp_mulmod(kp, e, curve->order, ep);
 8639                             		.loc 2 6128 41
 8640 0180 ED A5 0A                		mov.L	40[r10], r5
 8641 0183 A8 DD                   		mov.L	12[r5], r5
 8642                             		.loc 2 6128 19
 8643 0185 ED A4 03                		mov.L	12[r10], r4
 8644 0188 EF 53                   		mov.L	r5, r3
 8645 018a EC 62                   		mov.L	[r6], r2
 8646 018c ED A1 04                		mov.L	16[r10], r1
 8647 018f 05 00 00 00             		bsr	_sp_mulmod
 8648 0193 E3 A1                   		mov.L	r1, [r10]
6129:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY) break;
 8649                             		.loc 2 6129 16
 8650 0195 EC A5                   		mov.L	[r10], r5
 8651 0197 61 05                   		cmp	#0, r5
 8652 0199 3B 8C 00                		bne	.L608
6130:../src/wolfcrypt/src/ecc.c **** 
6131:../src/wolfcrypt/src/ecc.c ****             /* s = e/k.b + x.r/k.b = (e + x.r)/k.b
6132:../src/wolfcrypt/src/ecc.c ****                  = e' + s */
6133:../src/wolfcrypt/src/ecc.c ****             err = mp_addmod_ct(ep, s, curve->order, s);
 8653                             		.loc 2 6133 44
 8654 019c ED A5 0A                		mov.L	40[r10], r5
 8655 019f A8 DD                   		mov.L	12[r5], r5
 8656                             		.loc 2 6133 19
 8657 01a1 A8 E4                   		mov.L	8[r6], r4
 8658 01a3 EF 53                   		mov.L	r5, r3
 8659 01a5 A8 E2                   		mov.L	8[r6], r2
 8660 01a7 ED A1 03                		mov.L	12[r10], r1
 8661 01aa 05 00 00 00             		bsr	_sp_addmod_ct
 8662 01ae E3 A1                   		mov.L	r1, [r10]
6134:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY) break;
 8663                             		.loc 2 6134 16
 8664 01b0 EC A5                   		mov.L	[r10], r5
 8665 01b2 61 05                   		cmp	#0, r5
 8666 01b4 21 73                   		bne	.L609
6135:../src/wolfcrypt/src/ecc.c **** 
6136:../src/wolfcrypt/src/ecc.c ****             /* s = b.(e + x.r)/k.b = (e + x.r)/k
6137:../src/wolfcrypt/src/ecc.c ****                  = b.s */
6138:../src/wolfcrypt/src/ecc.c ****             err = mp_mulmod(s, b, curve->order, s);
 8667                             		.loc 2 6138 40
 8668 01b6 ED A5 0A                		mov.L	40[r10], r5
 8669 01b9 A8 DD                   		mov.L	12[r5], r5
 8670                             		.loc 2 6138 19
 8671 01bb A8 E4                   		mov.L	8[r6], r4
 8672 01bd EF 53                   		mov.L	r5, r3
 8673 01bf ED A2 02                		mov.L	8[r10], r2
 8674 01c2 A8 E1                   		mov.L	8[r6], r1
 8675 01c4 05 00 00 00             		bsr	_sp_mulmod
 8676 01c8 E3 A1                   		mov.L	r1, [r10]
6139:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY) break;
 8677                             		.loc 2 6139 16
 8678 01ca EC A5                   		mov.L	[r10], r5
 8679 01cc 61 05                   		cmp	#0, r5
 8680 01ce 21 5B                   		bne	.L610
6140:../src/wolfcrypt/src/ecc.c **** 
6141:../src/wolfcrypt/src/ecc.c ****             if (mp_iszero(s) == MP_NO) {
 8681                             		.loc 2 6141 17
 8682 01d0 A8 E5                   		mov.L	8[r6], r5
 8683 01d2 EC 55                   		mov.L	[r5], r5
 8684                             		.loc 2 6141 16
 8685 01d4 61 05                   		cmp	#0, r5
 8686 01d6 21 56                   		bne	.L611
 8687                             	.L591:
 8688                             	.LBE53:
6142:../src/wolfcrypt/src/ecc.c ****                 /* sign successful */
6143:../src/wolfcrypt/src/ecc.c ****                 break;
6144:../src/wolfcrypt/src/ecc.c ****             }
6145:../src/wolfcrypt/src/ecc.c ****          }
6146:../src/wolfcrypt/src/ecc.c ****      #ifndef ALT_ECC_SIZE
6147:../src/wolfcrypt/src/ecc.c ****          mp_clear(pubkey->pubkey.x);
 8689                             		.loc 2 6147 33
 8690 01d8 ED A5 08                		mov.L	32[r10], r5
 8691 01db 71 55 18                		add	#24, r5
 8692                             		.loc 2 6147 10
 8693 01de EF 51                   		mov.L	r5, r1
 8694 01e0 05 00 00 00             		bsr	_sp_clear
6148:../src/wolfcrypt/src/ecc.c ****          mp_clear(pubkey->pubkey.y);
 8695                             		.loc 2 6148 33
 8696 01e4 ED A5 08                		mov.L	32[r10], r5
 8697 01e7 72 55 28 03             		add	#0x328, r5
 8698                             		.loc 2 6148 10
 8699 01eb EF 51                   		mov.L	r5, r1
 8700 01ed 05 00 00 00             		bsr	_sp_clear
6149:../src/wolfcrypt/src/ecc.c ****          mp_clear(pubkey->pubkey.z);
 8701                             		.loc 2 6149 33
 8702 01f1 ED A5 08                		mov.L	32[r10], r5
 8703 01f4 72 55 38 06             		add	#0x638, r5
 8704                             		.loc 2 6149 10
 8705 01f8 EF 51                   		mov.L	r5, r1
 8706 01fa 05 00 00 00             		bsr	_sp_clear
6150:../src/wolfcrypt/src/ecc.c ****      #endif
6151:../src/wolfcrypt/src/ecc.c ****          mp_forcezero(&pubkey->k);
 8707                             		.loc 2 6151 23
 8708 01fe ED A5 08                		mov.L	32[r10], r5
 8709 0201 72 55 48 09             		add	#0x948, r5
 8710                             		.loc 2 6151 10
 8711 0205 EF 51                   		mov.L	r5, r1
 8712 0207 05 00 00 00             		bsr	_sp_forcezero
 8713                             	.L586:
6041:../src/wolfcrypt/src/ecc.c ****         if (++loop_check > 64) {
 8714                             		.loc 2 6041 5
 8715 020b EC A5                   		mov.L	[r10], r5
 8716 020d 61 05                   		cmp	#0, r5
 8717 020f 3A 7E FE                		beq	.L599
 8718 0212 2E 1B                   		bra	.L588
 8719                             	.L602:
6094:../src/wolfcrypt/src/ecc.c **** 
 8720                             		.loc 2 6094 9
 8721 0214 03                      		nop
 8722 0215 2E 18                   		bra	.L588
 8723                             	.L603:
6098:../src/wolfcrypt/src/ecc.c **** 
 8724                             		.loc 2 6098 9
 8725 0217 03                      		nop
 8726 0218 2E 15                   		bra	.L588
 8727                             	.L604:
 8728                             	.LBB54:
6110:../src/wolfcrypt/src/ecc.c **** 
 8729                             		.loc 2 6110 13
 8730 021a 03                      		nop
 8731 021b 2E 12                   		bra	.L588
 8732                             	.L605:
6115:../src/wolfcrypt/src/ecc.c **** 
 8733                             		.loc 2 6115 13
 8734 021d 03                      		nop
 8735 021e 2E 0F                   		bra	.L588
 8736                             	.L606:
6119:../src/wolfcrypt/src/ecc.c **** 
 8737                             		.loc 2 6119 13
 8738 0220 03                      		nop
 8739 0221 2E 0C                   		bra	.L588
 8740                             	.L607:
6124:../src/wolfcrypt/src/ecc.c **** 
 8741                             		.loc 2 6124 13
 8742 0223 03                      		nop
 8743 0224 09                      		bra	.L588
 8744                             	.L608:
6129:../src/wolfcrypt/src/ecc.c **** 
 8745                             		.loc 2 6129 13
 8746 0225 03                      		nop
 8747 0226 0F                      		bra	.L588
 8748                             	.L609:
6134:../src/wolfcrypt/src/ecc.c **** 
 8749                             		.loc 2 6134 13
 8750 0227 03                      		nop
 8751 0228 0D                      		bra	.L588
 8752                             	.L610:
6139:../src/wolfcrypt/src/ecc.c **** 
 8753                             		.loc 2 6139 13
 8754 0229 03                      		nop
 8755 022a 2E 03                   		bra	.L588
 8756                             	.L611:
6143:../src/wolfcrypt/src/ecc.c ****             }
 8757                             		.loc 2 6143 17
 8758 022c 03                      		nop
 8759                             		.balign 8,3,1
 8760                             	.L588:
 8761                             	.LBE54:
6152:../src/wolfcrypt/src/ecc.c ****     }
6153:../src/wolfcrypt/src/ecc.c ****     mp_forcezero(b);
 8762                             		.loc 2 6153 5
 8763 022d ED A1 02                		mov.L	8[r10], r1
 8764 0230 05 00 00 00             		bsr	_sp_forcezero
 8765                             	.LBB55:
6154:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
6155:../src/wolfcrypt/src/ecc.c ****     XFREE(b, key->heap, DYNAMIC_TYPE_ECC);
 8766                             		.loc 2 6155 5
 8767 0234 ED A5 02                		mov.L	8[r10], r5
 8768 0237 E7 A5 06                		mov.L	r5, 24[r10]
 8769 023a ED A5 06                		mov.L	24[r10], r5
 8770 023d 61 05                   		cmp	#0, r5
 8771 023f 10                      		beq	.L600
 8772                             		.loc 2 6155 5 is_stmt 0 discriminator 1
 8773 0240 ED A1 06                		mov.L	24[r10], r1
 8774 0243 05 00 00 00             		bsr	_wolfSSL_Free
 8775                             	.L600:
 8776                             	.LBE55:
6156:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
6157:../src/wolfcrypt/src/ecc.c ****     mp_memzero_check(b);
6158:../src/wolfcrypt/src/ecc.c **** #endif
6159:../src/wolfcrypt/src/ecc.c **** 
6160:../src/wolfcrypt/src/ecc.c ****     return err;
 8777                             		.loc 2 6160 12 is_stmt 1
 8778 0247 EC A5                   		mov.L	[r10], r5
6161:../src/wolfcrypt/src/ecc.c **** }
 8779                             		.loc 2 6161 1
 8780 0249 EF 51                   		mov.L	r5, r1
 8781 024b 71 00 3C                		add	#60, r0
 8782 024e 7E B6                   		pop	r6
 8783 0250 7E BA                   		pop	r10
 8784 0252 02                      		rts
 8785                             	.LFE104:
 8787 0253 77 10 01 00 00          		.section	.text.wc_ecc_sign_hash_ex,"ax",@progbits
 8788                             		.global	_wc_ecc_sign_hash_ex
 8790                             	_wc_ecc_sign_hash_ex:
 8791                             	.LFB105:
6162:../src/wolfcrypt/src/ecc.c **** #endif
6163:../src/wolfcrypt/src/ecc.c **** 
6164:../src/wolfcrypt/src/ecc.c **** /**
6165:../src/wolfcrypt/src/ecc.c ****   Sign a message digest
6166:../src/wolfcrypt/src/ecc.c ****   in        The message digest to sign
6167:../src/wolfcrypt/src/ecc.c ****   inlen     The length of the digest
6168:../src/wolfcrypt/src/ecc.c ****   key       A private ECC key
6169:../src/wolfcrypt/src/ecc.c ****   r         [out] The destination for r component of the signature
6170:../src/wolfcrypt/src/ecc.c ****   s         [out] The destination for s component of the signature
6171:../src/wolfcrypt/src/ecc.c ****   return    MP_OKAY if successful
6172:../src/wolfcrypt/src/ecc.c **** */
6173:../src/wolfcrypt/src/ecc.c **** int wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,
6174:../src/wolfcrypt/src/ecc.c ****                      ecc_key* key, mp_int *r, mp_int *s)
6175:../src/wolfcrypt/src/ecc.c **** {
 8792                             		.loc 2 6175 1
 8793 0000 7E AA                   		push.l	r10
 8794                             	.LCFI156:
 8795 0002 7E A6                   		push.l	r6
 8796                             	.LCFI157:
 8797 0004 71 0A 98                		add	#-104, r0, r10
 8798                             	.LCFI158:
 8799 0007 71 A0 F4                		add	#-12, r10, r0
 8800                             	.LCFI159:
 8801 000a 75 46 74                		mov.L	#0x74, r6
 8802 000d 4B A6                   		add	r10, r6
 8803 000f E7 A1 14                		mov.L	r1, 80[r10]
 8804 0012 E7 A2 15                		mov.L	r2, 84[r10]
 8805 0015 E7 A3 16                		mov.L	r3, 88[r10]
 8806 0018 E7 A4 17                		mov.L	r4, 92[r10]
6176:../src/wolfcrypt/src/ecc.c ****    int    err = 0;
 8807                             		.loc 2 6176 11
 8808 001b F8 A6 00                		mov.L	#0, [r10]
6177:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
6178:../src/wolfcrypt/src/ecc.c ****    mp_int* e;
6179:../src/wolfcrypt/src/ecc.c **** #if (!defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)) && \
6180:../src/wolfcrypt/src/ecc.c ****                                                    !defined(WOLFSSL_SMALL_STACK)
6181:../src/wolfcrypt/src/ecc.c ****    mp_int  e_lcl;
6182:../src/wolfcrypt/src/ecc.c **** #endif
6183:../src/wolfcrypt/src/ecc.c **** 
6184:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECDSA_SET_K) || defined(WOLFSSL_ECDSA_SET_K_ONE_LOOP) || \
6185:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_ECDSA_DETERMINISTIC_K) || \
6186:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT) || \
6187:../src/wolfcrypt/src/ecc.c ****     (defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC) && \
6188:../src/wolfcrypt/src/ecc.c ****     (defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)))
6189:../src/wolfcrypt/src/ecc.c ****    DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
6190:../src/wolfcrypt/src/ecc.c **** #else
6191:../src/wolfcrypt/src/ecc.c ****    DECLARE_CURVE_SPECS(1);
 8809                             		.loc 2 6191 4
 8810 001e F9 A6 01 00             		mov.L	#0, 4[r10]
 8811 0022 71 A5 24                		add	#36, r10, r5
 8812 0025 E7 A5 13                		mov.L	r5, 76[r10]
 8813 0028 ED A5 13                		mov.L	76[r10], r5
 8814 002b 75 43 28                		mov.L	#40, r3
 8815 002e 66 02                   		mov.L	#0, r2
 8816 0030 EF 51                   		mov.L	r5, r1
 8817 0032 05 00 00 00             		bsr	_memset
 8818 0036 ED A5 13                		mov.L	76[r10], r5
 8819 0039 3E 57 01                		mov.L	#1, 28[r5]
6192:../src/wolfcrypt/src/ecc.c **** #endif
6193:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH */
6194:../src/wolfcrypt/src/ecc.c **** 
6195:../src/wolfcrypt/src/ecc.c ****    if (in == NULL || r == NULL || s == NULL || key == NULL || rng == NULL) {
 8820                             		.loc 2 6195 7
 8821 003c ED A5 14                		mov.L	80[r10], r5
 8822 003f 61 05                   		cmp	#0, r5
 8823 0041 20 1A                   		beq	.L613
 8824                             		.loc 2 6195 19 discriminator 1
 8825 0043 EC 65                   		mov.L	[r6], r5
 8826 0045 61 05                   		cmp	#0, r5
 8827 0047 20 14                   		beq	.L613
 8828                             		.loc 2 6195 32 discriminator 2
 8829 0049 A8 6D                   		mov.L	4[r6], r5
 8830 004b 61 05                   		cmp	#0, r5
 8831 004d 20 0E                   		beq	.L613
 8832                             		.loc 2 6195 45 discriminator 3
 8833 004f ED A5 17                		mov.L	92[r10], r5
 8834 0052 61 05                   		cmp	#0, r5
 8835 0054 17                      		beq	.L613
 8836                             		.loc 2 6195 60 discriminator 4
 8837 0055 ED A5 16                		mov.L	88[r10], r5
 8838 0058 61 05                   		cmp	#0, r5
 8839 005a 18                      		bne	.L614
 8840                             		.balign 8,3,2
 8841                             	.L613:
6196:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
 8842                             		.loc 2 6196 15
 8843 005b FB 5A 56 FF             		mov.L	#-170, r5
 8844 005f 38 BE 01                		bra	.L631
 8845                             	.L614:
6197:../src/wolfcrypt/src/ecc.c ****    }
6198:../src/wolfcrypt/src/ecc.c **** 
6199:../src/wolfcrypt/src/ecc.c ****    /* is this a private key? */
6200:../src/wolfcrypt/src/ecc.c ****    if (key->type != ECC_PRIVATEKEY && key->type != ECC_PRIVATEKEY_ONLY) {
 8846                             		.loc 2 6200 11
 8847 0062 ED A5 17                		mov.L	92[r10], r5
 8848 0065 EC 55                   		mov.L	[r5], r5
 8849                             		.loc 2 6200 7
 8850 0067 61 25                   		cmp	#2, r5
 8851 0069 20 11                   		beq	.L616
 8852                             		.loc 2 6200 42 discriminator 1
 8853 006b ED A5 17                		mov.L	92[r10], r5
 8854 006e EC 55                   		mov.L	[r5], r5
 8855                             		.loc 2 6200 36 discriminator 1
 8856 0070 61 35                   		cmp	#3, r5
 8857 0072 10                      		beq	.L616
6201:../src/wolfcrypt/src/ecc.c ****       return ECC_BAD_ARG_E;
 8858                             		.loc 2 6201 14
 8859 0073 FB 5A 56 FF             		mov.L	#-170, r5
 8860 0077 38 A6 01                		bra	.L631
 8861                             	.L616:
6202:../src/wolfcrypt/src/ecc.c ****    }
6203:../src/wolfcrypt/src/ecc.c **** 
6204:../src/wolfcrypt/src/ecc.c ****    /* is the IDX valid ?  */
6205:../src/wolfcrypt/src/ecc.c ****    if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {
 8862                             		.loc 2 6205 8
 8863 007a ED A5 17                		mov.L	92[r10], r5
 8864 007d A8 5D                   		mov.L	4[r5], r5
 8865 007f EF 51                   		mov.L	r5, r1
 8866 0081 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 8867 0085 EF 15                   		mov.L	r1, r5
 8868                             		.loc 2 6205 7
 8869 0087 61 05                   		cmp	#0, r5
 8870 0089 11                      		beq	.L617
 8871                             		.loc 2 6205 49 discriminator 1
 8872 008a ED A5 17                		mov.L	92[r10], r5
 8873 008d A9 55                   		mov.L	16[r5], r5
 8874                             		.loc 2 6205 43 discriminator 1
 8875 008f 61 05                   		cmp	#0, r5
 8876 0091 18                      		bne	.L618
 8877                             	.L617:
6206:../src/wolfcrypt/src/ecc.c ****       return ECC_BAD_ARG_E;
 8878                             		.loc 2 6206 14
 8879 0092 FB 5A 56 FF             		mov.L	#-170, r5
 8880 0096 38 87 01                		bra	.L631
 8881                             	.L618:
6207:../src/wolfcrypt/src/ecc.c ****    }
6208:../src/wolfcrypt/src/ecc.c **** 
6209:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_SP_MATH)
6210:../src/wolfcrypt/src/ecc.c ****     if (key->idx == ECC_CUSTOM_IDX || (1
6211:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_SP_NO_256
6212:../src/wolfcrypt/src/ecc.c ****          && ecc_sets[key->idx].id != ECC_SECP256R1
6213:../src/wolfcrypt/src/ecc.c ****     #endif
6214:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_384
6215:../src/wolfcrypt/src/ecc.c ****          && ecc_sets[key->idx].id != ECC_SECP384R1
6216:../src/wolfcrypt/src/ecc.c ****     #endif
6217:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_521
6218:../src/wolfcrypt/src/ecc.c ****          && ecc_sets[key->idx].id != ECC_SECP521R1
6219:../src/wolfcrypt/src/ecc.c ****     #endif
6220:../src/wolfcrypt/src/ecc.c ****         )) {
6221:../src/wolfcrypt/src/ecc.c ****         return WC_KEY_SIZE_E;
6222:../src/wolfcrypt/src/ecc.c ****     }
6223:../src/wolfcrypt/src/ecc.c **** #endif
6224:../src/wolfcrypt/src/ecc.c **** 
6225:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECDSA_DETERMINISTIC_K) || \
6226:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT)
6227:../src/wolfcrypt/src/ecc.c ****     /* generate deterministic 'k' value to be used either with SP or normal */
6228:../src/wolfcrypt/src/ecc.c ****     if (key->deterministic == 1) {
6229:../src/wolfcrypt/src/ecc.c ****         if (deterministic_sign_helper(in, inlen, key)) {
6230:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("Error generating deterministic k to sign");
6231:../src/wolfcrypt/src/ecc.c ****             return ECC_PRIV_KEY_E;
6232:../src/wolfcrypt/src/ecc.c ****         }
6233:../src/wolfcrypt/src/ecc.c ****     }
6234:../src/wolfcrypt/src/ecc.c **** #endif
6235:../src/wolfcrypt/src/ecc.c **** 
6236:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_HAVE_SP_ECC)
6237:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX
6238:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
6239:../src/wolfcrypt/src/ecc.c ****         && key->asyncDev.marker != WOLFSSL_ASYNC_MARKER_ECC
6240:../src/wolfcrypt/src/ecc.c ****     #endif
6241:../src/wolfcrypt/src/ecc.c ****     ) {
6242:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_ECDSA_SET_K) || defined(WOLFSSL_ECDSA_SET_K_ONE_LOOP) \
6243:../src/wolfcrypt/src/ecc.c ****         || defined(WOLFSSL_ECDSA_DETERMINISTIC_K) || \
6244:../src/wolfcrypt/src/ecc.c ****            defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT)
6245:../src/wolfcrypt/src/ecc.c ****         mp_int* sign_k = key->sign_k;
6246:../src/wolfcrypt/src/ecc.c ****     #else
6247:../src/wolfcrypt/src/ecc.c ****         mp_int* sign_k = NULL;
6248:../src/wolfcrypt/src/ecc.c ****     #endif
6249:../src/wolfcrypt/src/ecc.c ****     #if defined(WC_ECC_NONBLOCK) && defined(WC_ECC_NONBLOCK_ONLY)
6250:../src/wolfcrypt/src/ecc.c ****         /* perform blocking call to non-blocking function */
6251:../src/wolfcrypt/src/ecc.c ****         ecc_nb_ctx_t nb_ctx;
6252:../src/wolfcrypt/src/ecc.c ****         XMEMSET(&nb_ctx, 0, sizeof(nb_ctx));
6253:../src/wolfcrypt/src/ecc.c ****     #endif
6254:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_SP_NO_256
6255:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[key->idx].id == ECC_SECP256R1) {
6256:../src/wolfcrypt/src/ecc.c ****         #ifdef WC_ECC_NONBLOCK
6257:../src/wolfcrypt/src/ecc.c ****             if (key->nb_ctx) {
6258:../src/wolfcrypt/src/ecc.c ****                 return sp_ecc_sign_256_nb(&key->nb_ctx->sp_ctx, in, inlen, rng,
6259:../src/wolfcrypt/src/ecc.c ****                     &key->k, r, s, sign_k, key->heap);
6260:../src/wolfcrypt/src/ecc.c ****             }
6261:../src/wolfcrypt/src/ecc.c ****             #ifdef WC_ECC_NONBLOCK_ONLY
6262:../src/wolfcrypt/src/ecc.c ****             do { /* perform blocking call to non-blocking function */
6263:../src/wolfcrypt/src/ecc.c ****                 err = sp_ecc_sign_256_nb(&nb_ctx.sp_ctx, in, inlen, rng,
6264:../src/wolfcrypt/src/ecc.c ****                     &key->k, r, s, sign_k, key->heap);
6265:../src/wolfcrypt/src/ecc.c ****             } while (err == FP_WOULDBLOCK);
6266:../src/wolfcrypt/src/ecc.c ****             return err;
6267:../src/wolfcrypt/src/ecc.c ****             #endif
6268:../src/wolfcrypt/src/ecc.c ****         #endif /* WC_ECC_NONBLOCK */
6269:../src/wolfcrypt/src/ecc.c ****         #if !defined(WC_ECC_NONBLOCK) || (defined(WC_ECC_NONBLOCK) && !defined(WC_ECC_NONBLOCK_ONLY
6270:../src/wolfcrypt/src/ecc.c ****             {
6271:../src/wolfcrypt/src/ecc.c ****                 int ret;
6272:../src/wolfcrypt/src/ecc.c ****                 SAVE_VECTOR_REGISTERS(return _svr_ret;);
6273:../src/wolfcrypt/src/ecc.c ****                 ret = sp_ecc_sign_256(in, inlen, rng, &key->k, r, s, sign_k,
6274:../src/wolfcrypt/src/ecc.c ****                                       key->heap);
6275:../src/wolfcrypt/src/ecc.c ****                 RESTORE_VECTOR_REGISTERS();
6276:../src/wolfcrypt/src/ecc.c ****                 return ret;
6277:../src/wolfcrypt/src/ecc.c ****             }
6278:../src/wolfcrypt/src/ecc.c ****         #endif
6279:../src/wolfcrypt/src/ecc.c ****         }
6280:../src/wolfcrypt/src/ecc.c ****     #endif
6281:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_384
6282:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[key->idx].id == ECC_SECP384R1) {
6283:../src/wolfcrypt/src/ecc.c ****         #ifdef WC_ECC_NONBLOCK
6284:../src/wolfcrypt/src/ecc.c ****             if (key->nb_ctx) {
6285:../src/wolfcrypt/src/ecc.c ****                 return sp_ecc_sign_384_nb(&key->nb_ctx->sp_ctx, in, inlen, rng,
6286:../src/wolfcrypt/src/ecc.c ****                     &key->k, r, s, sign_k, key->heap);
6287:../src/wolfcrypt/src/ecc.c ****             }
6288:../src/wolfcrypt/src/ecc.c ****             #ifdef WC_ECC_NONBLOCK_ONLY
6289:../src/wolfcrypt/src/ecc.c ****             do { /* perform blocking call to non-blocking function */
6290:../src/wolfcrypt/src/ecc.c ****                 err = sp_ecc_sign_384_nb(&nb_ctx.sp_ctx, in, inlen, rng,
6291:../src/wolfcrypt/src/ecc.c ****                     &key->k, r, s, sign_k, key->heap);
6292:../src/wolfcrypt/src/ecc.c ****             } while (err == FP_WOULDBLOCK);
6293:../src/wolfcrypt/src/ecc.c ****             return err;
6294:../src/wolfcrypt/src/ecc.c ****             #endif
6295:../src/wolfcrypt/src/ecc.c ****         #endif /* WC_ECC_NONBLOCK */
6296:../src/wolfcrypt/src/ecc.c ****         #if !defined(WC_ECC_NONBLOCK) || (defined(WC_ECC_NONBLOCK) && !defined(WC_ECC_NONBLOCK_ONLY
6297:../src/wolfcrypt/src/ecc.c ****             {
6298:../src/wolfcrypt/src/ecc.c ****                 int ret;
6299:../src/wolfcrypt/src/ecc.c ****                 SAVE_VECTOR_REGISTERS(return _svr_ret;);
6300:../src/wolfcrypt/src/ecc.c ****                 ret = sp_ecc_sign_384(in, inlen, rng, &key->k, r, s, sign_k,
6301:../src/wolfcrypt/src/ecc.c ****                                       key->heap);
6302:../src/wolfcrypt/src/ecc.c ****                 RESTORE_VECTOR_REGISTERS();
6303:../src/wolfcrypt/src/ecc.c ****                 return ret;
6304:../src/wolfcrypt/src/ecc.c ****             }
6305:../src/wolfcrypt/src/ecc.c ****         #endif
6306:../src/wolfcrypt/src/ecc.c ****         }
6307:../src/wolfcrypt/src/ecc.c ****     #endif
6308:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_521
6309:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[key->idx].id == ECC_SECP521R1) {
6310:../src/wolfcrypt/src/ecc.c ****         #ifdef WC_ECC_NONBLOCK
6311:../src/wolfcrypt/src/ecc.c ****             if (key->nb_ctx) {
6312:../src/wolfcrypt/src/ecc.c ****                 return sp_ecc_sign_521_nb(&key->nb_ctx->sp_ctx, in, inlen, rng,
6313:../src/wolfcrypt/src/ecc.c ****                     &key->k, r, s, sign_k, key->heap);
6314:../src/wolfcrypt/src/ecc.c ****             }
6315:../src/wolfcrypt/src/ecc.c ****             #ifdef WC_ECC_NONBLOCK_ONLY
6316:../src/wolfcrypt/src/ecc.c ****             do { /* perform blocking call to non-blocking function */
6317:../src/wolfcrypt/src/ecc.c ****                 err = sp_ecc_sign_521_nb(&nb_ctx.sp_ctx, in, inlen, rng,
6318:../src/wolfcrypt/src/ecc.c ****                     &key->k, r, s, sign_k, key->heap);
6319:../src/wolfcrypt/src/ecc.c ****             } while (err == FP_WOULDBLOCK);
6320:../src/wolfcrypt/src/ecc.c ****             return err;
6321:../src/wolfcrypt/src/ecc.c ****             #endif
6322:../src/wolfcrypt/src/ecc.c ****         #endif /* WC_ECC_NONBLOCK */
6323:../src/wolfcrypt/src/ecc.c ****         #if !defined(WC_ECC_NONBLOCK) || (defined(WC_ECC_NONBLOCK) && !defined(WC_ECC_NONBLOCK_ONLY
6324:../src/wolfcrypt/src/ecc.c ****             {
6325:../src/wolfcrypt/src/ecc.c ****                 int ret;
6326:../src/wolfcrypt/src/ecc.c ****                 SAVE_VECTOR_REGISTERS(return _svr_ret;);
6327:../src/wolfcrypt/src/ecc.c ****                 ret = sp_ecc_sign_521(in, inlen, rng, &key->k, r, s, sign_k,
6328:../src/wolfcrypt/src/ecc.c ****                                       key->heap);
6329:../src/wolfcrypt/src/ecc.c ****                 RESTORE_VECTOR_REGISTERS();
6330:../src/wolfcrypt/src/ecc.c ****                 return ret;
6331:../src/wolfcrypt/src/ecc.c ****             }
6332:../src/wolfcrypt/src/ecc.c ****         #endif
6333:../src/wolfcrypt/src/ecc.c ****         }
6334:../src/wolfcrypt/src/ecc.c ****     #endif
6335:../src/wolfcrypt/src/ecc.c ****         (void)sign_k;
6336:../src/wolfcrypt/src/ecc.c ****     }
6337:../src/wolfcrypt/src/ecc.c **** #else
6338:../src/wolfcrypt/src/ecc.c ****    (void)inlen;
6339:../src/wolfcrypt/src/ecc.c **** #endif
6340:../src/wolfcrypt/src/ecc.c **** 
6341:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC) && \
6342:../src/wolfcrypt/src/ecc.c ****        defined(WOLFSSL_ASYNC_CRYPT_TEST)
6343:../src/wolfcrypt/src/ecc.c ****     if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
6344:../src/wolfcrypt/src/ecc.c ****         if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_ECC_SIGN)) {
6345:../src/wolfcrypt/src/ecc.c ****             WC_ASYNC_TEST* testDev = &key->asyncDev.test;
6346:../src/wolfcrypt/src/ecc.c ****             testDev->eccSign.in = in;
6347:../src/wolfcrypt/src/ecc.c ****             testDev->eccSign.inSz = inlen;
6348:../src/wolfcrypt/src/ecc.c ****             testDev->eccSign.rng = rng;
6349:../src/wolfcrypt/src/ecc.c ****             testDev->eccSign.key = key;
6350:../src/wolfcrypt/src/ecc.c ****             testDev->eccSign.r = r;
6351:../src/wolfcrypt/src/ecc.c ****             testDev->eccSign.s = s;
6352:../src/wolfcrypt/src/ecc.c ****             return WC_PENDING_E;
6353:../src/wolfcrypt/src/ecc.c ****         }
6354:../src/wolfcrypt/src/ecc.c ****     }
6355:../src/wolfcrypt/src/ecc.c **** #endif
6356:../src/wolfcrypt/src/ecc.c **** 
6357:../src/wolfcrypt/src/ecc.c **** 
6358:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
6359:../src/wolfcrypt/src/ecc.c **** 
6360:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(HAVE_CAVIUM_V)
6361:../src/wolfcrypt/src/ecc.c ****    err = wc_ecc_alloc_mpint(key, &key->e);
6362:../src/wolfcrypt/src/ecc.c ****    if (err != 0) {
6363:../src/wolfcrypt/src/ecc.c ****       return err;
6364:../src/wolfcrypt/src/ecc.c ****    }
6365:../src/wolfcrypt/src/ecc.c ****    e = key->e;
6366:../src/wolfcrypt/src/ecc.c **** #elif !defined(WOLFSSL_SMALL_STACK)
6367:../src/wolfcrypt/src/ecc.c ****    e = &e_lcl;
6368:../src/wolfcrypt/src/ecc.c **** #else
6369:../src/wolfcrypt/src/ecc.c ****    e = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 8882                             		.loc 2 6369 17
 8883 0099 FB 1A 10 03             		mov.L	#0x310, r1
 8884 009d 05 00 00 00             		bsr	_wolfSSL_Malloc
 8885 00a1 E7 A1 02                		mov.L	r1, 8[r10]
6370:../src/wolfcrypt/src/ecc.c ****    if (e == NULL) {
 8886                             		.loc 2 6370 7
 8887 00a4 ED A5 02                		mov.L	8[r10], r5
 8888 00a7 61 05                   		cmp	#0, r5
 8889 00a9 1F                      		bne	.L619
6371:../src/wolfcrypt/src/ecc.c ****       return MEMORY_E;
 8890                             		.loc 2 6371 14
 8891 00aa FB 56 83                		mov.L	#-125, r5
 8892 00ad 38 70 01                		bra	.L631
 8893                             	.L619:
6372:../src/wolfcrypt/src/ecc.c ****    }
6373:../src/wolfcrypt/src/ecc.c **** #endif
6374:../src/wolfcrypt/src/ecc.c **** 
6375:../src/wolfcrypt/src/ecc.c ****    /* get the hash and load it as a bignum into 'e' */
6376:../src/wolfcrypt/src/ecc.c ****    /* init the bignums */
6377:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_init(e)) != MP_OKAY) {
 8894                             		.loc 2 6377 15
 8895 00b0 ED A1 02                		mov.L	8[r10], r1
 8896 00b3 05 00 00 00             		bsr	_sp_init
 8897 00b7 E3 A1                   		mov.L	r1, [r10]
 8898                             		.loc 2 6377 7
 8899 00b9 EC A5                   		mov.L	[r10], r5
 8900 00bb 61 05                   		cmp	#0, r5
 8901 00bd 20 1A                   		beq	.L620
 8902                             	.LBB56:
6378:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_SMALL_STACK
6379:../src/wolfcrypt/src/ecc.c ****       XFREE(e, key->heap, DYNAMIC_TYPE_ECC);
 8903                             		.loc 2 6379 7
 8904 00bf ED A5 02                		mov.L	8[r10], r5
 8905 00c2 E7 A5 03                		mov.L	r5, 12[r10]
 8906 00c5 ED A5 03                		mov.L	12[r10], r5
 8907 00c8 61 05                   		cmp	#0, r5
 8908 00ca 10                      		beq	.L621
 8909                             		.loc 2 6379 7 is_stmt 0 discriminator 1
 8910 00cb ED A1 03                		mov.L	12[r10], r1
 8911 00ce 05 00 00 00             		bsr	_wolfSSL_Free
 8912                             	.L621:
 8913                             	.LBE56:
6380:../src/wolfcrypt/src/ecc.c ****    #endif
6381:../src/wolfcrypt/src/ecc.c ****       return err;
 8914                             		.loc 2 6381 14 is_stmt 1
 8915 00d2 EC A5                   		mov.L	[r10], r5
 8916 00d4 38 49 01                		bra	.L631
 8917                             	.L620:
6382:../src/wolfcrypt/src/ecc.c ****    }
6383:../src/wolfcrypt/src/ecc.c **** 
6384:../src/wolfcrypt/src/ecc.c ****    /* load curve info */
6385:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECDSA_SET_K) || defined(WOLFSSL_ECDSA_SET_K_ONE_LOOP) || \
6386:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_ECDSA_DETERMINISTIC_K) || \
6387:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT)
6388:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
6389:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
6390:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
6391:../src/wolfcrypt/src/ecc.c **** #else
6392:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC) && \
6393:../src/wolfcrypt/src/ecc.c ****       (defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA))
6394:../src/wolfcrypt/src/ecc.c ****     if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
6395:../src/wolfcrypt/src/ecc.c ****         ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
6396:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
6397:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
6398:../src/wolfcrypt/src/ecc.c ****     }
6399:../src/wolfcrypt/src/ecc.c ****     else
6400:../src/wolfcrypt/src/ecc.c ****     #endif
6401:../src/wolfcrypt/src/ecc.c ****     {
6402:../src/wolfcrypt/src/ecc.c ****         ALLOC_CURVE_SPECS(1, err);
 8918                             		.loc 2 6402 9
 8919 00d7 FB 1A 10 03             		mov.L	#0x310, r1
 8920 00db 05 00 00 00             		bsr	_wolfSSL_Malloc
 8921 00df E7 A1 01                		mov.L	r1, 4[r10]
 8922 00e2 ED A5 01                		mov.L	4[r10], r5
 8923 00e5 61 05                   		cmp	#0, r5
 8924 00e7 1D                      		bne	.L622
 8925                             		.loc 2 6402 9 is_stmt 0 discriminator 1
 8926 00e8 F8 A6 83                		mov.L	#-125, [r10]
 8927 00eb 09                      		bra	.L623
 8928                             	.L622:
 8929                             		.loc 2 6402 9 discriminator 2
 8930 00ec ED A5 13                		mov.L	76[r10], r5
 8931 00ef ED A4 01                		mov.L	4[r10], r4
 8932 00f2 A1 D4                   		mov.L	r4, 24[r5]
 8933                             	.L623:
6403:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 8934                             		.loc 2 6403 12 is_stmt 1
 8935 00f4 EC A5                   		mov.L	[r10], r5
 8936 00f6 61 05                   		cmp	#0, r5
 8937 00f8 21 16                   		bne	.L624
6404:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
 8938                             		.loc 2 6404 19
 8939 00fa ED A5 17                		mov.L	92[r10], r5
 8940 00fd A9 54                   		mov.L	16[r5], r4
 8941 00ff 71 A5 4C                		add	#0x4c, r10, r5
 8942 0102 66 83                   		mov	#8, r3
 8943 0104 EF 52                   		mov.L	r5, r2
 8944 0106 EF 41                   		mov.L	r4, r1
 8945 0108 05 00 00 00             		bsr	_wc_ecc_curve_load
 8946 010c E3 A1                   		mov.L	r1, [r10]
 8947                             	.L624:
6405:../src/wolfcrypt/src/ecc.c ****     }
6406:../src/wolfcrypt/src/ecc.c **** #endif
6407:../src/wolfcrypt/src/ecc.c **** 
6408:../src/wolfcrypt/src/ecc.c ****    /* load digest into e */
6409:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 8948                             		.loc 2 6409 7
 8949 010e EC A5                   		mov.L	[r10], r5
 8950 0110 61 05                   		cmp	#0, r5
 8951 0112 21 5F                   		bne	.L625
 8952                             	.LBB57:
6410:../src/wolfcrypt/src/ecc.c ****        /* we may need to truncate if hash is longer than key size */
6411:../src/wolfcrypt/src/ecc.c ****        word32 orderBits = mp_count_bits(curve->order);
 8953                             		.loc 2 6411 46
 8954 0114 ED A5 13                		mov.L	76[r10], r5
 8955 0117 A8 DD                   		mov.L	12[r5], r5
 8956                             		.loc 2 6411 27
 8957 0119 EF 51                   		mov.L	r5, r1
 8958 011b 05 00 00 00             		bsr	_sp_count_bits
 8959 011f EF 15                   		mov.L	r1, r5
 8960                             		.loc 2 6411 15
 8961 0121 E7 A5 04                		mov.L	r5, 16[r10]
6412:../src/wolfcrypt/src/ecc.c **** 
6413:../src/wolfcrypt/src/ecc.c ****        /* truncate down to byte size, may be all that's needed */
6414:../src/wolfcrypt/src/ecc.c ****        if ((WOLFSSL_BIT_SIZE * inlen) > orderBits)
 8962                             		.loc 2 6414 30
 8963 0124 ED A5 15                		mov.L	84[r10], r5
 8964 0127 6C 35                   		shll	#3, r5
 8965                             		.loc 2 6414 11
 8966 0129 ED A4 04                		mov.L	16[r10], r4
 8967 012c 47 54                   		cmp	r5, r4
 8968 012e 22 0C                   		bgeu	.L626
6415:../src/wolfcrypt/src/ecc.c ****            inlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;
 8969                             		.loc 2 6415 50
 8970 0130 ED A5 04                		mov.L	16[r10], r5
 8971 0133 62 75                   		add	#7, r5
 8972                             		.loc 2 6415 18
 8973 0135 68 35                   		shlr	#3, r5
 8974 0137 E7 A5 15                		mov.L	r5, 84[r10]
 8975                             	.L626:
6416:../src/wolfcrypt/src/ecc.c ****        err = mp_read_unsigned_bin(e, in, inlen);
 8976                             		.loc 2 6416 14
 8977 013a ED A3 15                		mov.L	84[r10], r3
 8978 013d ED A2 14                		mov.L	80[r10], r2
 8979 0140 ED A1 02                		mov.L	8[r10], r1
 8980 0143 05 00 00 00             		bsr	_sp_read_unsigned_bin
 8981 0147 E3 A1                   		mov.L	r1, [r10]
6417:../src/wolfcrypt/src/ecc.c **** 
6418:../src/wolfcrypt/src/ecc.c ****        /* may still need bit truncation too */
6419:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * inlen) > orderBits)
 8982                             		.loc 2 6419 11
 8983 0149 EC A5                   		mov.L	[r10], r5
 8984 014b 61 05                   		cmp	#0, r5
 8985 014d 21 24                   		bne	.L625
 8986                             		.loc 2 6419 48 discriminator 1
 8987 014f ED A5 15                		mov.L	84[r10], r5
 8988 0152 6C 35                   		shll	#3, r5
 8989                             		.loc 2 6419 27 discriminator 1
 8990 0154 ED A4 04                		mov.L	16[r10], r4
 8991 0157 47 54                   		cmp	r5, r4
 8992 0159 22 18                   		bgeu	.L625
6420:../src/wolfcrypt/src/ecc.c ****            mp_rshb(e, WOLFSSL_BIT_SIZE - (orderBits & 0x7));
 8993                             		.loc 2 6420 12
 8994 015b ED A5 04                		mov.L	16[r10], r5
 8995 015e 64 75                   		and	#7, r5
 8996 0160 66 84                   		mov.L	#8, r4
 8997 0162 FF 05 54                		sub	r5, r4, r5
 8998 0165 ED A3 02                		mov.L	8[r10], r3
 8999 0168 EF 52                   		mov.L	r5, r2
 9000 016a ED A1 02                		mov.L	8[r10], r1
 9001 016d 05 00 00 00             		bsr	_sp_rshb
 9002                             		.balign 8,3,1
 9003                             	.L625:
 9004                             	.LBE57:
6421:../src/wolfcrypt/src/ecc.c ****    }
6422:../src/wolfcrypt/src/ecc.c **** 
6423:../src/wolfcrypt/src/ecc.c ****    /* make up a key and export the public copy */
6424:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 9005                             		.loc 2 6424 7
 9006 0171 EC A5                   		mov.L	[r10], r5
 9007 0173 61 05                   		cmp	#0, r5
 9008 0175 21 70                   		bne	.L627
 9009                             	.LBB58:
6425:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_SMALL_STACK
6426:../src/wolfcrypt/src/ecc.c ****        ecc_key* pubkey;
6427:../src/wolfcrypt/src/ecc.c ****    #else
6428:../src/wolfcrypt/src/ecc.c ****        ecc_key  pubkey[1];
6429:../src/wolfcrypt/src/ecc.c ****    #endif
6430:../src/wolfcrypt/src/ecc.c **** 
6431:../src/wolfcrypt/src/ecc.c ****    #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
6432:../src/wolfcrypt/src/ecc.c ****         if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
6433:../src/wolfcrypt/src/ecc.c ****         #if defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)
6434:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_CAVIUM_V
6435:../src/wolfcrypt/src/ecc.c ****             if (NitroxEccIsCurveSupported(key))
6436:../src/wolfcrypt/src/ecc.c ****         #endif
6437:../src/wolfcrypt/src/ecc.c ****             {
6438:../src/wolfcrypt/src/ecc.c ****                word32 keySz = key->dp->size;
6439:../src/wolfcrypt/src/ecc.c ****                mp_int* k;
6440:../src/wolfcrypt/src/ecc.c ****             #ifdef HAVE_CAVIUM_V
6441:../src/wolfcrypt/src/ecc.c ****                err = wc_ecc_alloc_mpint(key, &key->signK);
6442:../src/wolfcrypt/src/ecc.c ****                if (err != 0)
6443:../src/wolfcrypt/src/ecc.c ****                   return err;
6444:../src/wolfcrypt/src/ecc.c ****                k = key->signK;
6445:../src/wolfcrypt/src/ecc.c ****             #else
6446:../src/wolfcrypt/src/ecc.c ****                mp_int k_lcl;
6447:../src/wolfcrypt/src/ecc.c ****                k = &k_lcl;
6448:../src/wolfcrypt/src/ecc.c ****             #endif
6449:../src/wolfcrypt/src/ecc.c **** 
6450:../src/wolfcrypt/src/ecc.c ****                err = mp_init(k);
6451:../src/wolfcrypt/src/ecc.c **** 
6452:../src/wolfcrypt/src/ecc.c ****                 /* make sure r and s are allocated */
6453:../src/wolfcrypt/src/ecc.c ****            #ifdef HAVE_CAVIUM_V
6454:../src/wolfcrypt/src/ecc.c ****                /* Nitrox V needs single buffer for R and S */
6455:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6456:../src/wolfcrypt/src/ecc.c ****                    err = wc_bigint_alloc(&key->r->raw, NitroxEccGetSize(key)*2);
6457:../src/wolfcrypt/src/ecc.c ****                /* Nitrox V only needs Prime and Order */
6458:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6459:../src/wolfcrypt/src/ecc.c ****                    err = wc_ecc_curve_load(key->dp, &curve,
6460:../src/wolfcrypt/src/ecc.c ****                         (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_ORDER));
6461:../src/wolfcrypt/src/ecc.c ****            #else
6462:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6463:../src/wolfcrypt/src/ecc.c ****                    err = wc_bigint_alloc(&key->r->raw, key->dp->size);
6464:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6465:../src/wolfcrypt/src/ecc.c ****                    err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
6466:../src/wolfcrypt/src/ecc.c ****            #endif
6467:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6468:../src/wolfcrypt/src/ecc.c ****                    err = wc_bigint_alloc(&key->s->raw, key->dp->size);
6469:../src/wolfcrypt/src/ecc.c **** 
6470:../src/wolfcrypt/src/ecc.c ****                /* load e and k */
6471:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6472:../src/wolfcrypt/src/ecc.c ****                    err = wc_mp_to_bigint_sz(e, &e->raw, keySz);
6473:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6474:../src/wolfcrypt/src/ecc.c ****                    err = wc_mp_to_bigint_sz(&key->k, &key->k.raw, keySz);
6475:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6476:../src/wolfcrypt/src/ecc.c ****                    err = wc_ecc_gen_k(rng, key->dp->size, k, curve->order);
6477:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6478:../src/wolfcrypt/src/ecc.c ****                    err = wc_mp_to_bigint_sz(k, &k->raw, keySz);
6479:../src/wolfcrypt/src/ecc.c **** 
6480:../src/wolfcrypt/src/ecc.c ****            #ifdef HAVE_CAVIUM_V
6481:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6482:../src/wolfcrypt/src/ecc.c ****                    err = NitroxEcdsaSign(key, &e->raw, &key->k.raw, &k->raw,
6483:../src/wolfcrypt/src/ecc.c ****                     &r->raw, &s->raw, &curve->prime->raw, &curve->order->raw);
6484:../src/wolfcrypt/src/ecc.c ****            #else
6485:../src/wolfcrypt/src/ecc.c ****                if (err == MP_OKAY)
6486:../src/wolfcrypt/src/ecc.c ****                    err = IntelQaEcdsaSign(&key->asyncDev, &e->raw, &key->k.raw,
6487:../src/wolfcrypt/src/ecc.c ****                       &k->raw, &r->raw, &s->raw, &curve->Af->raw, &curve->Bf->raw,
6488:../src/wolfcrypt/src/ecc.c ****                       &curve->prime->raw, &curve->order->raw, &curve->Gx->raw,
6489:../src/wolfcrypt/src/ecc.c ****                       &curve->Gy->raw);
6490:../src/wolfcrypt/src/ecc.c ****            #endif
6491:../src/wolfcrypt/src/ecc.c **** 
6492:../src/wolfcrypt/src/ecc.c ****            #ifndef HAVE_CAVIUM_V
6493:../src/wolfcrypt/src/ecc.c ****                mp_clear(e);
6494:../src/wolfcrypt/src/ecc.c ****                mp_clear(k);
6495:../src/wolfcrypt/src/ecc.c ****            #endif
6496:../src/wolfcrypt/src/ecc.c ****                wc_ecc_curve_free(curve);
6497:../src/wolfcrypt/src/ecc.c ****                FREE_CURVE_SPECS();
6498:../src/wolfcrypt/src/ecc.c **** 
6499:../src/wolfcrypt/src/ecc.c ****                return err;
6500:../src/wolfcrypt/src/ecc.c ****            }
6501:../src/wolfcrypt/src/ecc.c ****        #endif /* HAVE_CAVIUM_V || HAVE_INTEL_QA */
6502:../src/wolfcrypt/src/ecc.c ****        }
6503:../src/wolfcrypt/src/ecc.c ****    #endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */
6504:../src/wolfcrypt/src/ecc.c **** 
6505:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_SMALL_STACK
6506:../src/wolfcrypt/src/ecc.c ****        pubkey = (ecc_key*)XMALLOC(sizeof(ecc_key), key->heap, DYNAMIC_TYPE_ECC);
 9010                             		.loc 2 6506 27
 9011 0177 FB 1A 5C 0C             		mov.L	#0xc5c, r1
 9012 017b 05 00 00 00             		bsr	_wolfSSL_Malloc
 9013 017f E7 A1 05                		mov.L	r1, 20[r10]
6507:../src/wolfcrypt/src/ecc.c ****        if (pubkey == NULL)
 9014                             		.loc 2 6507 11
 9015 0182 ED A5 05                		mov.L	20[r10], r5
 9016 0185 61 05                   		cmp	#0, r5
 9017 0187 1C                      		bne	.L628
6508:../src/wolfcrypt/src/ecc.c ****            err = MEMORY_E;
 9018                             		.loc 2 6508 16
 9019 0188 F8 A6 83                		mov.L	#-125, [r10]
 9020                             	.L628:
6509:../src/wolfcrypt/src/ecc.c ****    #endif
6510:../src/wolfcrypt/src/ecc.c **** 
6511:../src/wolfcrypt/src/ecc.c ****        /* don't use async for key, since we don't support async return here */
6512:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY) {
 9021                             		.loc 2 6512 11
 9022 018b EC A5                   		mov.L	[r10], r5
 9023 018d 61 05                   		cmp	#0, r5
 9024 018f 21 56                   		bne	.L627
6513:../src/wolfcrypt/src/ecc.c ****            err = wc_ecc_init_ex(pubkey, key->heap, INVALID_DEVID);
 9025                             		.loc 2 6513 18
 9026 0191 ED A5 17                		mov.L	92[r10], r5
 9027 0194 A9 5D                   		mov.L	20[r5], r5
 9028 0196 FB 36 FE                		mov.L	#-2, r3
 9029 0199 EF 52                   		mov.L	r5, r2
 9030 019b ED A1 05                		mov.L	20[r10], r1
 9031 019e 05 00 00 00             		bsr	_wc_ecc_init_ex
 9032 01a2 E3 A1                   		mov.L	r1, [r10]
6514:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY) {
 9033                             		.loc 2 6514 15
 9034 01a4 EC A5                   		mov.L	[r10], r5
 9035 01a6 61 05                   		cmp	#0, r5
 9036 01a8 21 3D                   		bne	.L627
6515:../src/wolfcrypt/src/ecc.c ****               err = ecc_sign_hash_sw(key, pubkey, rng, curve, e, r, s);
 9037                             		.loc 2 6515 21
 9038 01aa ED A5 13                		mov.L	76[r10], r5
 9039 01ad A8 6C                   		mov.L	4[r6], r4
 9040 01af A0 84                   		mov.L	r4, 8[r0]
 9041 01b1 EC 64                   		mov.L	[r6], r4
 9042 01b3 A0 0C                   		mov.L	r4, 4[r0]
 9043 01b5 ED A4 02                		mov.L	8[r10], r4
 9044 01b8 E3 04                   		mov.L	r4, [r0]
 9045 01ba EF 54                   		mov.L	r5, r4
 9046 01bc ED A3 16                		mov.L	88[r10], r3
 9047 01bf ED A2 05                		mov.L	20[r10], r2
 9048 01c2 ED A1 17                		mov.L	92[r10], r1
 9049 01c5 05 00 00 00             		bsr	_ecc_sign_hash_sw
 9050 01c9 E3 A1                   		mov.L	r1, [r10]
6516:../src/wolfcrypt/src/ecc.c ****               wc_ecc_free(pubkey);
 9051                             		.loc 2 6516 15
 9052 01cb ED A1 05                		mov.L	20[r10], r1
 9053 01ce 05 00 00 00             		bsr	_wc_ecc_free
 9054                             	.LBB59:
6517:../src/wolfcrypt/src/ecc.c ****            #ifdef WOLFSSL_SMALL_STACK
6518:../src/wolfcrypt/src/ecc.c ****               XFREE(pubkey, key->heap, DYNAMIC_TYPE_ECC);
 9055                             		.loc 2 6518 15
 9056 01d2 ED A5 05                		mov.L	20[r10], r5
 9057 01d5 E7 A5 06                		mov.L	r5, 24[r10]
 9058 01d8 ED A5 06                		mov.L	24[r10], r5
 9059 01db 61 05                   		cmp	#0, r5
 9060 01dd 10                      		beq	.L627
 9061                             		.loc 2 6518 15 is_stmt 0 discriminator 1
 9062 01de ED A1 06                		mov.L	24[r10], r1
 9063 01e1 05 00 00 00             		bsr	_wolfSSL_Free
 9064                             		.balign 8,3,1
 9065                             	.L627:
 9066                             	.LBE59:
 9067                             	.LBE58:
6519:../src/wolfcrypt/src/ecc.c ****            #endif
6520:../src/wolfcrypt/src/ecc.c ****            }
6521:../src/wolfcrypt/src/ecc.c ****        }
6522:../src/wolfcrypt/src/ecc.c ****    }
6523:../src/wolfcrypt/src/ecc.c **** 
6524:../src/wolfcrypt/src/ecc.c ****    mp_clear(e);
 9068                             		.loc 2 6524 4 is_stmt 1
 9069 01e5 ED A1 02                		mov.L	8[r10], r1
 9070 01e8 05 00 00 00             		bsr	_sp_clear
6525:../src/wolfcrypt/src/ecc.c ****    wc_ecc_curve_free(curve);
 9071                             		.loc 2 6525 4
 9072 01ec ED A5 13                		mov.L	76[r10], r5
 9073 01ef EF 51                   		mov.L	r5, r1
 9074 01f1 05 00 00 00             		bsr	_wc_ecc_curve_free
 9075                             	.LBB60:
6526:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
6527:../src/wolfcrypt/src/ecc.c ****    XFREE(e, key->heap, DYNAMIC_TYPE_ECC);
 9076                             		.loc 2 6527 4
 9077 01f5 ED A5 02                		mov.L	8[r10], r5
 9078 01f8 E7 A5 07                		mov.L	r5, 28[r10]
 9079 01fb ED A5 07                		mov.L	28[r10], r5
 9080 01fe 61 05                   		cmp	#0, r5
 9081 0200 10                      		beq	.L629
 9082                             		.loc 2 6527 4 is_stmt 0 discriminator 1
 9083 0201 ED A1 07                		mov.L	28[r10], r1
 9084 0204 05 00 00 00             		bsr	_wolfSSL_Free
 9085                             	.L629:
 9086                             	.LBE60:
 9087                             	.LBB61:
6528:../src/wolfcrypt/src/ecc.c **** #endif
6529:../src/wolfcrypt/src/ecc.c ****    FREE_CURVE_SPECS();
 9088                             		.loc 2 6529 4 is_stmt 1
 9089 0208 ED A5 01                		mov.L	4[r10], r5
 9090 020b E7 A5 08                		mov.L	r5, 32[r10]
 9091 020e ED A5 08                		mov.L	32[r10], r5
 9092 0211 61 05                   		cmp	#0, r5
 9093 0213 10                      		beq	.L630
 9094                             		.loc 2 6529 4 is_stmt 0 discriminator 1
 9095 0214 ED A1 08                		mov.L	32[r10], r1
 9096 0217 05 00 00 00             		bsr	_wolfSSL_Free
 9097                             	.L630:
 9098                             	.LBE61:
6530:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH */
6531:../src/wolfcrypt/src/ecc.c **** 
6532:../src/wolfcrypt/src/ecc.c ****    return err;
 9099                             		.loc 2 6532 11 is_stmt 1
 9100 021b EC A5                   		mov.L	[r10], r5
 9101                             		.balign 8,3,1
 9102                             	.L631:
6533:../src/wolfcrypt/src/ecc.c **** }
 9103                             		.loc 2 6533 1 discriminator 1
 9104 021d EF 51                   		mov.L	r5, r1
 9105 021f 71 00 74                		add	#0x74, r0
 9106 0222 7E B6                   		pop	r6
 9107 0224 7E BA                   		pop	r10
 9108 0226 02                      		rts
 9109                             	.LFE105:
 9111 0227 03                      		.section	.text.wc_ecc_free,"ax",@progbits
 9112                             		.global	_wc_ecc_free
 9114                             	_wc_ecc_free:
 9115                             	.LFB106:
6534:../src/wolfcrypt/src/ecc.c **** 
6535:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECDSA_DETERMINISTIC_K) || \
6536:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT)
6537:../src/wolfcrypt/src/ecc.c **** /* helper function to do HMAC operations
6538:../src/wolfcrypt/src/ecc.c ****  * returns 0 on success and updates "out" buffer
6539:../src/wolfcrypt/src/ecc.c ****  */
6540:../src/wolfcrypt/src/ecc.c **** static int _HMAC_K(byte* K, word32 KSz, byte* V, word32 VSz,
6541:../src/wolfcrypt/src/ecc.c ****         const byte* h1, word32 h1Sz, byte* x, word32 xSz, byte* oct,
6542:../src/wolfcrypt/src/ecc.c ****         byte* out, enum wc_HashType hashType, void* heap)
6543:../src/wolfcrypt/src/ecc.c **** {
6544:../src/wolfcrypt/src/ecc.c ****     Hmac hmac;
6545:../src/wolfcrypt/src/ecc.c ****     int  ret, init;
6546:../src/wolfcrypt/src/ecc.c **** 
6547:../src/wolfcrypt/src/ecc.c ****     ret = init = wc_HmacInit(&hmac, heap, 0);
6548:../src/wolfcrypt/src/ecc.c ****     if (ret == 0)
6549:../src/wolfcrypt/src/ecc.c ****         ret = wc_HmacSetKey(&hmac, hashType, K, KSz);
6550:../src/wolfcrypt/src/ecc.c **** 
6551:../src/wolfcrypt/src/ecc.c ****     if (ret == 0)
6552:../src/wolfcrypt/src/ecc.c ****         ret = wc_HmacUpdate(&hmac, V, VSz);
6553:../src/wolfcrypt/src/ecc.c **** 
6554:../src/wolfcrypt/src/ecc.c ****     if (ret == 0 && oct != NULL)
6555:../src/wolfcrypt/src/ecc.c ****         ret = wc_HmacUpdate(&hmac, oct, 1);
6556:../src/wolfcrypt/src/ecc.c **** 
6557:../src/wolfcrypt/src/ecc.c ****     if (ret == 0)
6558:../src/wolfcrypt/src/ecc.c ****         ret = wc_HmacUpdate(&hmac, x, xSz);
6559:../src/wolfcrypt/src/ecc.c **** 
6560:../src/wolfcrypt/src/ecc.c ****     if (ret == 0)
6561:../src/wolfcrypt/src/ecc.c ****         ret = wc_HmacUpdate(&hmac, h1, h1Sz);
6562:../src/wolfcrypt/src/ecc.c **** 
6563:../src/wolfcrypt/src/ecc.c ****     if (ret == 0)
6564:../src/wolfcrypt/src/ecc.c ****         ret = wc_HmacFinal(&hmac, out);
6565:../src/wolfcrypt/src/ecc.c **** 
6566:../src/wolfcrypt/src/ecc.c ****     if (init == 0)
6567:../src/wolfcrypt/src/ecc.c ****         wc_HmacFree(&hmac);
6568:../src/wolfcrypt/src/ecc.c **** 
6569:../src/wolfcrypt/src/ecc.c ****     return ret;
6570:../src/wolfcrypt/src/ecc.c **** }
6571:../src/wolfcrypt/src/ecc.c **** 
6572:../src/wolfcrypt/src/ecc.c **** 
6573:../src/wolfcrypt/src/ecc.c **** /* Generates a deterministic key based of the message using RFC6979
6574:../src/wolfcrypt/src/ecc.c ****  * @param  [in]   hash     Hash value to sign
6575:../src/wolfcrypt/src/ecc.c ****  * @param  [in]   hashSz   Size of 'hash' buffer passed in
6576:../src/wolfcrypt/src/ecc.c ****  * @param  [in]   hashType Type of hash to use with deterministic k gen, i.e.
6577:../src/wolfcrypt/src/ecc.c ****  *                WC_HASH_TYPE_SHA256
6578:../src/wolfcrypt/src/ecc.c ****  * @param  [in]   priv     Current ECC private key set
6579:../src/wolfcrypt/src/ecc.c ****  * @param  [out]  k        An initialized mp_int to set the k value generated in
6580:../src/wolfcrypt/src/ecc.c ****  * @param  [in]   order    ECC order parameter to use with generation
6581:../src/wolfcrypt/src/ecc.c ****  * @return  0 on success.
6582:../src/wolfcrypt/src/ecc.c ****  */
6583:../src/wolfcrypt/src/ecc.c **** int wc_ecc_gen_deterministic_k(const byte* hash, word32 hashSz,
6584:../src/wolfcrypt/src/ecc.c ****         enum wc_HashType hashType, mp_int* priv, mp_int* k, mp_int* order,
6585:../src/wolfcrypt/src/ecc.c ****         void* heap)
6586:../src/wolfcrypt/src/ecc.c **** {
6587:../src/wolfcrypt/src/ecc.c ****     int ret = 0, qbits = 0;
6588:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SMALL_STACK
6589:../src/wolfcrypt/src/ecc.c ****     byte h1[MAX_ECC_BYTES];
6590:../src/wolfcrypt/src/ecc.c ****     byte V[WC_MAX_DIGEST_SIZE];
6591:../src/wolfcrypt/src/ecc.c ****     byte K[WC_MAX_DIGEST_SIZE];
6592:../src/wolfcrypt/src/ecc.c ****     byte x[MAX_ECC_BYTES];
6593:../src/wolfcrypt/src/ecc.c ****     mp_int z1[1];
6594:../src/wolfcrypt/src/ecc.c **** #else
6595:../src/wolfcrypt/src/ecc.c ****     byte *h1 = NULL;
6596:../src/wolfcrypt/src/ecc.c ****     byte *V  = NULL;
6597:../src/wolfcrypt/src/ecc.c ****     byte *K  = NULL;
6598:../src/wolfcrypt/src/ecc.c ****     byte *x  = NULL;
6599:../src/wolfcrypt/src/ecc.c ****     mp_int *z1 = NULL;
6600:../src/wolfcrypt/src/ecc.c **** #endif
6601:../src/wolfcrypt/src/ecc.c ****     word32 xSz, VSz, KSz, h1len, qLen;
6602:../src/wolfcrypt/src/ecc.c ****     byte intOct;
6603:../src/wolfcrypt/src/ecc.c **** 
6604:../src/wolfcrypt/src/ecc.c ****     if (hash == NULL || k == NULL || order == NULL) {
6605:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
6606:../src/wolfcrypt/src/ecc.c ****     }
6607:../src/wolfcrypt/src/ecc.c **** 
6608:../src/wolfcrypt/src/ecc.c ****     if (hashSz > WC_MAX_DIGEST_SIZE) {
6609:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("hash size was too large!");
6610:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
6611:../src/wolfcrypt/src/ecc.c ****     }
6612:../src/wolfcrypt/src/ecc.c **** 
6613:../src/wolfcrypt/src/ecc.c ****     if (hashSz != WC_SHA256_DIGEST_SIZE) {
6614:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("Currently only SHA256 digest is supported");
6615:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
6616:../src/wolfcrypt/src/ecc.c ****     }
6617:../src/wolfcrypt/src/ecc.c **** 
6618:../src/wolfcrypt/src/ecc.c ****     if (mp_unsigned_bin_size(priv) > MAX_ECC_BYTES) {
6619:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("private key larger than max expected!");
6620:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
6621:../src/wolfcrypt/src/ecc.c ****     }
6622:../src/wolfcrypt/src/ecc.c **** 
6623:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
6624:../src/wolfcrypt/src/ecc.c ****     h1 = (byte*)XMALLOC(MAX_ECC_BYTES, heap, DYNAMIC_TYPE_DIGEST);
6625:../src/wolfcrypt/src/ecc.c ****     if (h1 == NULL) {
6626:../src/wolfcrypt/src/ecc.c ****         ret = MEMORY_E;
6627:../src/wolfcrypt/src/ecc.c ****     }
6628:../src/wolfcrypt/src/ecc.c **** 
6629:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6630:../src/wolfcrypt/src/ecc.c ****         V = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
6631:../src/wolfcrypt/src/ecc.c ****         if (V == NULL)
6632:../src/wolfcrypt/src/ecc.c ****             ret = MEMORY_E;
6633:../src/wolfcrypt/src/ecc.c ****     }
6634:../src/wolfcrypt/src/ecc.c **** 
6635:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6636:../src/wolfcrypt/src/ecc.c ****         K = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
6637:../src/wolfcrypt/src/ecc.c ****         if (K == NULL)
6638:../src/wolfcrypt/src/ecc.c ****             ret = MEMORY_E;
6639:../src/wolfcrypt/src/ecc.c ****     }
6640:../src/wolfcrypt/src/ecc.c **** 
6641:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6642:../src/wolfcrypt/src/ecc.c ****         x = (byte*)XMALLOC(MAX_ECC_BYTES, heap, DYNAMIC_TYPE_PRIVATE_KEY);
6643:../src/wolfcrypt/src/ecc.c ****         if (x == NULL)
6644:../src/wolfcrypt/src/ecc.c ****             ret = MEMORY_E;
6645:../src/wolfcrypt/src/ecc.c ****     }
6646:../src/wolfcrypt/src/ecc.c **** 
6647:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6648:../src/wolfcrypt/src/ecc.c ****         z1 = (mp_int *)XMALLOC(sizeof(*z1), heap, DYNAMIC_TYPE_ECC_BUFFER);
6649:../src/wolfcrypt/src/ecc.c ****         if (z1 == NULL)
6650:../src/wolfcrypt/src/ecc.c ****             ret = MEMORY_E;
6651:../src/wolfcrypt/src/ecc.c ****     }
6652:../src/wolfcrypt/src/ecc.c **** 
6653:../src/wolfcrypt/src/ecc.c ****     /* bail out if any error has been hit at this point */
6654:../src/wolfcrypt/src/ecc.c ****     if (ret != 0) {
6655:../src/wolfcrypt/src/ecc.c ****         if (x != NULL)
6656:../src/wolfcrypt/src/ecc.c ****             XFREE(x, heap, DYNAMIC_TYPE_PRIVATE_KEY);
6657:../src/wolfcrypt/src/ecc.c ****         if (K != NULL)
6658:../src/wolfcrypt/src/ecc.c ****             XFREE(K, heap, DYNAMIC_TYPE_ECC_BUFFER);
6659:../src/wolfcrypt/src/ecc.c ****         if (V != NULL)
6660:../src/wolfcrypt/src/ecc.c ****             XFREE(V, heap, DYNAMIC_TYPE_ECC_BUFFER);
6661:../src/wolfcrypt/src/ecc.c ****         if (h1 != NULL)
6662:../src/wolfcrypt/src/ecc.c ****             XFREE(h1, heap, DYNAMIC_TYPE_DIGEST);
6663:../src/wolfcrypt/src/ecc.c ****         return ret;
6664:../src/wolfcrypt/src/ecc.c ****     }
6665:../src/wolfcrypt/src/ecc.c **** #endif
6666:../src/wolfcrypt/src/ecc.c **** 
6667:../src/wolfcrypt/src/ecc.c ****     VSz = KSz = hashSz;
6668:../src/wolfcrypt/src/ecc.c ****     qLen = xSz = h1len = mp_unsigned_bin_size(order);
6669:../src/wolfcrypt/src/ecc.c **** 
6670:../src/wolfcrypt/src/ecc.c ****     /* 3.2 b. Set V = 0x01 0x01 ... */
6671:../src/wolfcrypt/src/ecc.c ****     XMEMSET(V, 0x01, VSz);
6672:../src/wolfcrypt/src/ecc.c **** 
6673:../src/wolfcrypt/src/ecc.c ****     /* 3.2 c. Set K = 0x00 0x00 ... */
6674:../src/wolfcrypt/src/ecc.c ****     XMEMSET(K, 0x00, KSz);
6675:../src/wolfcrypt/src/ecc.c **** 
6676:../src/wolfcrypt/src/ecc.c ****     mp_init(z1); /* always init z1 and free z1 */
6677:../src/wolfcrypt/src/ecc.c ****     ret = mp_to_unsigned_bin_len(priv, x, qLen);
6678:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6679:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_CHECK_MEM_ZERO
6680:../src/wolfcrypt/src/ecc.c ****         wc_MemZero_Add("wc_ecc_gen_deterministic_k x", x, qLen);
6681:../src/wolfcrypt/src/ecc.c ****     #endif
6682:../src/wolfcrypt/src/ecc.c ****         qbits = mp_count_bits(order);
6683:../src/wolfcrypt/src/ecc.c ****         ret = mp_read_unsigned_bin(z1, hash, hashSz);
6684:../src/wolfcrypt/src/ecc.c ****     }
6685:../src/wolfcrypt/src/ecc.c **** 
6686:../src/wolfcrypt/src/ecc.c ****     /* bits2octets on h1 */
6687:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6688:../src/wolfcrypt/src/ecc.c ****         XMEMSET(h1, 0, MAX_ECC_BYTES);
6689:../src/wolfcrypt/src/ecc.c **** 
6690:../src/wolfcrypt/src/ecc.c ****     #if !defined(WOLFSSL_ECDSA_DETERMINISTIC_K_VARIANT)
6691:../src/wolfcrypt/src/ecc.c ****         /* mod reduce by order using conditional subtract
6692:../src/wolfcrypt/src/ecc.c ****          * RFC6979 lists a variant that uses the hash directly instead of
6693:../src/wolfcrypt/src/ecc.c ****          * doing bits2octets(H(m)), when variant macro is used avoid this
6694:../src/wolfcrypt/src/ecc.c ****          * bits2octets operation */
6695:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp(z1, order) == MP_GT) {
6696:../src/wolfcrypt/src/ecc.c ****             int z1Sz;
6697:../src/wolfcrypt/src/ecc.c **** 
6698:../src/wolfcrypt/src/ecc.c ****             mp_sub(z1, order, z1);
6699:../src/wolfcrypt/src/ecc.c ****             z1Sz = mp_unsigned_bin_size(z1);
6700:../src/wolfcrypt/src/ecc.c ****             if (z1Sz < 0 || z1Sz > MAX_ECC_BYTES) {
6701:../src/wolfcrypt/src/ecc.c ****                 ret = BUFFER_E;
6702:../src/wolfcrypt/src/ecc.c ****             }
6703:../src/wolfcrypt/src/ecc.c ****             else {
6704:../src/wolfcrypt/src/ecc.c ****                 ret = mp_to_unsigned_bin_len(z1, h1, h1len);
6705:../src/wolfcrypt/src/ecc.c ****             }
6706:../src/wolfcrypt/src/ecc.c ****         }
6707:../src/wolfcrypt/src/ecc.c ****         else
6708:../src/wolfcrypt/src/ecc.c ****     #endif
6709:../src/wolfcrypt/src/ecc.c ****         {
6710:../src/wolfcrypt/src/ecc.c ****             /* use original hash and keep leading 0's */
6711:../src/wolfcrypt/src/ecc.c ****             mp_to_unsigned_bin_len(z1, h1, h1len);
6712:../src/wolfcrypt/src/ecc.c ****         }
6713:../src/wolfcrypt/src/ecc.c ****     }
6714:../src/wolfcrypt/src/ecc.c ****     mp_free(z1);
6715:../src/wolfcrypt/src/ecc.c **** 
6716:../src/wolfcrypt/src/ecc.c ****     /* 3.2 step d. K = HMAC_K(V || 0x00 || int2octests(x) || bits2octests(h1) */
6717:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6718:../src/wolfcrypt/src/ecc.c ****         intOct = 0x00;
6719:../src/wolfcrypt/src/ecc.c ****         ret = _HMAC_K(K, KSz, V, VSz, h1, h1len, x, xSz, &intOct, K,
6720:../src/wolfcrypt/src/ecc.c ****                 hashType, heap);
6721:../src/wolfcrypt/src/ecc.c ****     }
6722:../src/wolfcrypt/src/ecc.c **** 
6723:../src/wolfcrypt/src/ecc.c ****     /* 3.2 step e. V = HMAC_K(V) */
6724:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6725:../src/wolfcrypt/src/ecc.c ****         ret = _HMAC_K(K, KSz, V, VSz, NULL, 0, NULL, 0, NULL, V, hashType,
6726:../src/wolfcrypt/src/ecc.c ****                 heap);
6727:../src/wolfcrypt/src/ecc.c ****     }
6728:../src/wolfcrypt/src/ecc.c **** 
6729:../src/wolfcrypt/src/ecc.c **** 
6730:../src/wolfcrypt/src/ecc.c ****     /* 3.2 step f. K = HMAC_K(V || 0x01 || int2octests(x) || bits2octests(h1) */
6731:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6732:../src/wolfcrypt/src/ecc.c ****         intOct = 0x01;
6733:../src/wolfcrypt/src/ecc.c ****         ret = _HMAC_K(K, KSz, V, VSz, h1, h1len, x, xSz, &intOct, K, hashType,
6734:../src/wolfcrypt/src/ecc.c ****                 heap);
6735:../src/wolfcrypt/src/ecc.c ****     }
6736:../src/wolfcrypt/src/ecc.c **** 
6737:../src/wolfcrypt/src/ecc.c ****     /* 3.2 step g. V = HMAC_K(V) */
6738:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6739:../src/wolfcrypt/src/ecc.c ****         ret = _HMAC_K(K, KSz, V, VSz, NULL, 0, NULL, 0, NULL, V, hashType,
6740:../src/wolfcrypt/src/ecc.c ****                 heap);
6741:../src/wolfcrypt/src/ecc.c ****     }
6742:../src/wolfcrypt/src/ecc.c **** 
6743:../src/wolfcrypt/src/ecc.c ****     /* 3.2 step h. loop through the next steps until a valid value is found */
6744:../src/wolfcrypt/src/ecc.c ****     if (ret == 0 ) {
6745:../src/wolfcrypt/src/ecc.c ****         int err;
6746:../src/wolfcrypt/src/ecc.c **** 
6747:../src/wolfcrypt/src/ecc.c ****         intOct = 0x00;
6748:../src/wolfcrypt/src/ecc.c ****         do {
6749:../src/wolfcrypt/src/ecc.c ****             xSz = 0; /* used as tLen */
6750:../src/wolfcrypt/src/ecc.c ****             err = 0; /* start as good until generated k is tested */
6751:../src/wolfcrypt/src/ecc.c **** 
6752:../src/wolfcrypt/src/ecc.c ****             /* 3.2 step h.2 when tlen < qlen do V = HMAC_K(V); T = T || V */
6753:../src/wolfcrypt/src/ecc.c ****             while (xSz < qLen) {
6754:../src/wolfcrypt/src/ecc.c ****                 ret = _HMAC_K(K, KSz, V, VSz, NULL, 0, NULL, 0, NULL, V,
6755:../src/wolfcrypt/src/ecc.c ****                         hashType, heap);
6756:../src/wolfcrypt/src/ecc.c ****                 if (ret == 0) {
6757:../src/wolfcrypt/src/ecc.c ****                     int sz;
6758:../src/wolfcrypt/src/ecc.c **** 
6759:../src/wolfcrypt/src/ecc.c ****                     sz = MIN(qLen - xSz, VSz);
6760:../src/wolfcrypt/src/ecc.c ****                     XMEMCPY(x + xSz, V, sz);
6761:../src/wolfcrypt/src/ecc.c ****                     xSz += sz;
6762:../src/wolfcrypt/src/ecc.c ****                 }
6763:../src/wolfcrypt/src/ecc.c ****                 else {
6764:../src/wolfcrypt/src/ecc.c ****                     break; /* error case */
6765:../src/wolfcrypt/src/ecc.c ****                 }
6766:../src/wolfcrypt/src/ecc.c ****             }
6767:../src/wolfcrypt/src/ecc.c **** 
6768:../src/wolfcrypt/src/ecc.c ****             if (ret == 0) {
6769:../src/wolfcrypt/src/ecc.c ****                 mp_clear(k); /* 3.2 step h.1 clear T */
6770:../src/wolfcrypt/src/ecc.c ****                 ret = mp_read_unsigned_bin(k, x, xSz);
6771:../src/wolfcrypt/src/ecc.c ****             }
6772:../src/wolfcrypt/src/ecc.c **** 
6773:../src/wolfcrypt/src/ecc.c ****             if ((ret == 0) && ((int)(xSz * WOLFSSL_BIT_SIZE) != qbits)) {
6774:../src/wolfcrypt/src/ecc.c ****                 /* handle odd case where shift of 'k' is needed with RFC 6979
6775:../src/wolfcrypt/src/ecc.c ****                  *  k = bits2int(T) in section 3.2 h.3 */
6776:../src/wolfcrypt/src/ecc.c ****                 mp_rshb(k, (xSz * WOLFSSL_BIT_SIZE) - qbits);
6777:../src/wolfcrypt/src/ecc.c ****             }
6778:../src/wolfcrypt/src/ecc.c **** 
6779:../src/wolfcrypt/src/ecc.c ****             /* 3.2 step h.3 the key should be smaller than the order of base
6780:../src/wolfcrypt/src/ecc.c ****              * point */
6781:../src/wolfcrypt/src/ecc.c ****             if (ret == 0) {
6782:../src/wolfcrypt/src/ecc.c ****                 if (mp_cmp(k, order) != MP_LT) {
6783:../src/wolfcrypt/src/ecc.c ****                     err = MP_VAL;
6784:../src/wolfcrypt/src/ecc.c ****                 } else if (mp_iszero(k) == MP_YES) {
6785:../src/wolfcrypt/src/ecc.c ****                     /* no 0 key's */
6786:../src/wolfcrypt/src/ecc.c ****                     err = MP_ZERO_E;
6787:../src/wolfcrypt/src/ecc.c ****                 }
6788:../src/wolfcrypt/src/ecc.c ****             }
6789:../src/wolfcrypt/src/ecc.c **** 
6790:../src/wolfcrypt/src/ecc.c ****             /* 3.2 step h.3 if there was a problem with 'k' generated then try
6791:../src/wolfcrypt/src/ecc.c ****              * again K = HMAC_K(V || 0x00) and V = HMAC_K(V) */
6792:../src/wolfcrypt/src/ecc.c ****             if (ret == 0 && err != 0) {
6793:../src/wolfcrypt/src/ecc.c ****                 ret = _HMAC_K(K, KSz, V, VSz, NULL, 0, NULL, 0, &intOct, K,
6794:../src/wolfcrypt/src/ecc.c ****                     hashType, heap);
6795:../src/wolfcrypt/src/ecc.c ****                 if (ret == 0) {
6796:../src/wolfcrypt/src/ecc.c ****                     ret = _HMAC_K(K, KSz, V, VSz, NULL, 0, NULL, 0, NULL, V,
6797:../src/wolfcrypt/src/ecc.c ****                     hashType, heap);
6798:../src/wolfcrypt/src/ecc.c ****                 }
6799:../src/wolfcrypt/src/ecc.c ****             }
6800:../src/wolfcrypt/src/ecc.c ****         } while (ret == 0 && err != 0);
6801:../src/wolfcrypt/src/ecc.c ****     }
6802:../src/wolfcrypt/src/ecc.c **** 
6803:../src/wolfcrypt/src/ecc.c ****     ForceZero(x, MAX_ECC_BYTES);
6804:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
6805:../src/wolfcrypt/src/ecc.c ****     if (z1 != NULL)
6806:../src/wolfcrypt/src/ecc.c ****         XFREE(z1, heap, DYNAMIC_TYPE_ECC_BUFFER);
6807:../src/wolfcrypt/src/ecc.c ****     if (x != NULL)
6808:../src/wolfcrypt/src/ecc.c ****         XFREE(x, heap, DYNAMIC_TYPE_PRIVATE_KEY);
6809:../src/wolfcrypt/src/ecc.c ****     if (K != NULL)
6810:../src/wolfcrypt/src/ecc.c ****         XFREE(K, heap, DYNAMIC_TYPE_ECC_BUFFER);
6811:../src/wolfcrypt/src/ecc.c ****     if (V != NULL)
6812:../src/wolfcrypt/src/ecc.c ****         XFREE(V, heap, DYNAMIC_TYPE_ECC_BUFFER);
6813:../src/wolfcrypt/src/ecc.c ****     if (h1 != NULL)
6814:../src/wolfcrypt/src/ecc.c ****         XFREE(h1, heap, DYNAMIC_TYPE_DIGEST);
6815:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
6816:../src/wolfcrypt/src/ecc.c ****     wc_MemZero_Check(x, MAX_ECC_BYTES);
6817:../src/wolfcrypt/src/ecc.c **** #endif
6818:../src/wolfcrypt/src/ecc.c **** 
6819:../src/wolfcrypt/src/ecc.c ****     return ret;
6820:../src/wolfcrypt/src/ecc.c **** }
6821:../src/wolfcrypt/src/ecc.c **** 
6822:../src/wolfcrypt/src/ecc.c **** 
6823:../src/wolfcrypt/src/ecc.c **** /* Sets the deterministic flag for 'k' generation with sign.
6824:../src/wolfcrypt/src/ecc.c ****  * returns 0 on success
6825:../src/wolfcrypt/src/ecc.c ****  */
6826:../src/wolfcrypt/src/ecc.c **** int wc_ecc_set_deterministic(ecc_key* key, byte flag)
6827:../src/wolfcrypt/src/ecc.c **** {
6828:../src/wolfcrypt/src/ecc.c ****     if (key == NULL) {
6829:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
6830:../src/wolfcrypt/src/ecc.c ****     }
6831:../src/wolfcrypt/src/ecc.c **** 
6832:../src/wolfcrypt/src/ecc.c ****     key->deterministic = flag;
6833:../src/wolfcrypt/src/ecc.c ****     return 0;
6834:../src/wolfcrypt/src/ecc.c **** }
6835:../src/wolfcrypt/src/ecc.c **** #endif /* end sign_ex and deterministic sign */
6836:../src/wolfcrypt/src/ecc.c **** 
6837:../src/wolfcrypt/src/ecc.c **** 
6838:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECDSA_SET_K) || defined(WOLFSSL_ECDSA_SET_K_ONE_LOOP)
6839:../src/wolfcrypt/src/ecc.c **** int wc_ecc_sign_set_k(const byte* k, word32 klen, ecc_key* key)
6840:../src/wolfcrypt/src/ecc.c **** {
6841:../src/wolfcrypt/src/ecc.c ****     int ret = MP_OKAY;
6842:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(1);
6843:../src/wolfcrypt/src/ecc.c **** 
6844:../src/wolfcrypt/src/ecc.c ****     if (k == NULL || klen == 0 || key == NULL) {
6845:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
6846:../src/wolfcrypt/src/ecc.c ****     }
6847:../src/wolfcrypt/src/ecc.c **** 
6848:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(1, ret);
6849:../src/wolfcrypt/src/ecc.c ****     if (ret == MP_OKAY) {
6850:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
6851:../src/wolfcrypt/src/ecc.c ****     }
6852:../src/wolfcrypt/src/ecc.c **** 
6853:../src/wolfcrypt/src/ecc.c ****     if (ret != 0) {
6854:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
6855:../src/wolfcrypt/src/ecc.c ****         return ret;
6856:../src/wolfcrypt/src/ecc.c ****     }
6857:../src/wolfcrypt/src/ecc.c **** 
6858:../src/wolfcrypt/src/ecc.c ****     if (key->sign_k == NULL) {
6859:../src/wolfcrypt/src/ecc.c ****         key->sign_k = (mp_int*)XMALLOC(sizeof(mp_int), key->heap,
6860:../src/wolfcrypt/src/ecc.c ****                                                             DYNAMIC_TYPE_ECC);
6861:../src/wolfcrypt/src/ecc.c ****         if (key->sign_k) {
6862:../src/wolfcrypt/src/ecc.c ****             ret = mp_init(key->sign_k);
6863:../src/wolfcrypt/src/ecc.c ****         }
6864:../src/wolfcrypt/src/ecc.c ****         else {
6865:../src/wolfcrypt/src/ecc.c ****             ret = MEMORY_E;
6866:../src/wolfcrypt/src/ecc.c ****         }
6867:../src/wolfcrypt/src/ecc.c ****     }
6868:../src/wolfcrypt/src/ecc.c **** 
6869:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
6870:../src/wolfcrypt/src/ecc.c ****         ret = mp_read_unsigned_bin(key->sign_k, k, klen);
6871:../src/wolfcrypt/src/ecc.c ****     }
6872:../src/wolfcrypt/src/ecc.c ****     if (ret == 0 && mp_cmp(key->sign_k, curve->order) != MP_LT) {
6873:../src/wolfcrypt/src/ecc.c ****         ret = MP_VAL;
6874:../src/wolfcrypt/src/ecc.c ****     }
6875:../src/wolfcrypt/src/ecc.c **** 
6876:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
6877:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
6878:../src/wolfcrypt/src/ecc.c ****     return ret;
6879:../src/wolfcrypt/src/ecc.c **** }
6880:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ECDSA_SET_K || WOLFSSL_ECDSA_SET_K_ONE_LOOP */
6881:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ATECC508A && WOLFSSL_CRYPTOCELL */
6882:../src/wolfcrypt/src/ecc.c **** 
6883:../src/wolfcrypt/src/ecc.c **** #endif /* !HAVE_ECC_SIGN */
6884:../src/wolfcrypt/src/ecc.c **** 
6885:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CUSTOM_CURVES
6886:../src/wolfcrypt/src/ecc.c **** void wc_ecc_free_curve(const ecc_set_type* curve, void* heap)
6887:../src/wolfcrypt/src/ecc.c **** {
6888:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_ECC_CURVE_STATIC
6889:../src/wolfcrypt/src/ecc.c ****     if (curve->prime != NULL)
6890:../src/wolfcrypt/src/ecc.c ****         XFREE((void*)curve->prime, heap, DYNAMIC_TYPE_ECC_BUFFER);
6891:../src/wolfcrypt/src/ecc.c ****     if (curve->Af != NULL)
6892:../src/wolfcrypt/src/ecc.c ****         XFREE((void*)curve->Af, heap, DYNAMIC_TYPE_ECC_BUFFER);
6893:../src/wolfcrypt/src/ecc.c ****     if (curve->Bf != NULL)
6894:../src/wolfcrypt/src/ecc.c ****         XFREE((void*)curve->Bf, heap, DYNAMIC_TYPE_ECC_BUFFER);
6895:../src/wolfcrypt/src/ecc.c ****     if (curve->order != NULL)
6896:../src/wolfcrypt/src/ecc.c ****         XFREE((void*)curve->order, heap, DYNAMIC_TYPE_ECC_BUFFER);
6897:../src/wolfcrypt/src/ecc.c ****     if (curve->Gx != NULL)
6898:../src/wolfcrypt/src/ecc.c ****         XFREE((void*)curve->Gx, heap, DYNAMIC_TYPE_ECC_BUFFER);
6899:../src/wolfcrypt/src/ecc.c ****     if (curve->Gy != NULL)
6900:../src/wolfcrypt/src/ecc.c ****         XFREE((void*)curve->Gy, heap, DYNAMIC_TYPE_ECC_BUFFER);
6901:../src/wolfcrypt/src/ecc.c **** #endif
6902:../src/wolfcrypt/src/ecc.c **** 
6903:../src/wolfcrypt/src/ecc.c ****     XFREE((void*)curve, heap, DYNAMIC_TYPE_ECC_BUFFER);
6904:../src/wolfcrypt/src/ecc.c **** 
6905:../src/wolfcrypt/src/ecc.c ****     (void)heap;
6906:../src/wolfcrypt/src/ecc.c **** }
6907:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_CUSTOM_CURVES */
6908:../src/wolfcrypt/src/ecc.c **** 
6909:../src/wolfcrypt/src/ecc.c **** /**
6910:../src/wolfcrypt/src/ecc.c ****   Free an ECC key from memory
6911:../src/wolfcrypt/src/ecc.c ****   key   The key you wish to free
6912:../src/wolfcrypt/src/ecc.c **** */
6913:../src/wolfcrypt/src/ecc.c **** WOLFSSL_ABI
6914:../src/wolfcrypt/src/ecc.c **** int wc_ecc_free(ecc_key* key)
6915:../src/wolfcrypt/src/ecc.c **** {
 9116                             		.loc 2 6915 1
 9117 0000 7E AA                   		push.l	r10
 9118                             	.LCFI160:
 9119 0002 71 0A FC                		add	#-4, r0, r10
 9120                             	.LCFI161:
 9121 0005 EF A0                   		mov.L	r10, r0
 9122 0007 E3 A1                   		mov.L	r1, [r10]
6916:../src/wolfcrypt/src/ecc.c ****     if (key == NULL) {
 9123                             		.loc 2 6916 8
 9124 0009 EC A5                   		mov.L	[r10], r5
 9125 000b 61 05                   		cmp	#0, r5
 9126 000d 1D                      		bne	.L633
6917:../src/wolfcrypt/src/ecc.c ****         return 0;
 9127                             		.loc 2 6917 16
 9128 000e 66 05                   		mov.L	#0, r5
 9129 0010 2E 33                   		bra	.L634
 9130                             	.L633:
6918:../src/wolfcrypt/src/ecc.c ****     }
6919:../src/wolfcrypt/src/ecc.c **** 
6920:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECDSA_SET_K) || defined(WOLFSSL_ECDSA_SET_K_ONE_LOOP)
6921:../src/wolfcrypt/src/ecc.c ****     if (key->sign_k != NULL) {
6922:../src/wolfcrypt/src/ecc.c ****         mp_forcezero(key->sign_k);
6923:../src/wolfcrypt/src/ecc.c ****         mp_free(key->sign_k);
6924:../src/wolfcrypt/src/ecc.c ****         XFREE(key->sign_k, key->heap, DYNAMIC_TYPE_ECC);
6925:../src/wolfcrypt/src/ecc.c ****     }
6926:../src/wolfcrypt/src/ecc.c **** #endif
6927:../src/wolfcrypt/src/ecc.c **** 
6928:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
6929:../src/wolfcrypt/src/ecc.c ****     #ifdef WC_ASYNC_ENABLE_ECC
6930:../src/wolfcrypt/src/ecc.c ****     wolfAsync_DevCtxFree(&key->asyncDev, WOLFSSL_ASYNC_MARKER_ECC);
6931:../src/wolfcrypt/src/ecc.c ****     #endif
6932:../src/wolfcrypt/src/ecc.c ****     wc_ecc_free_async(key);
6933:../src/wolfcrypt/src/ecc.c **** #endif
6934:../src/wolfcrypt/src/ecc.c **** 
6935:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_QNX_CAAM
6936:../src/wolfcrypt/src/ecc.c ****     /* free secure memory */
6937:../src/wolfcrypt/src/ecc.c ****     if ((key->blackKey != CAAM_BLACK_KEY_CCM &&
6938:../src/wolfcrypt/src/ecc.c ****          key->blackKey != CAAM_BLACK_KEY_ECB) && key->blackKey > 0) {
6939:../src/wolfcrypt/src/ecc.c ****        caamFreePart(key->partNum);
6940:../src/wolfcrypt/src/ecc.c ****     }
6941:../src/wolfcrypt/src/ecc.c **** #endif
6942:../src/wolfcrypt/src/ecc.c **** 
6943:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SE050
6944:../src/wolfcrypt/src/ecc.c ****     se050_ecc_free_key(key);
6945:../src/wolfcrypt/src/ecc.c **** #endif
6946:../src/wolfcrypt/src/ecc.c **** 
6947:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
6948:../src/wolfcrypt/src/ecc.c ****     atmel_ecc_free(key->slot);
6949:../src/wolfcrypt/src/ecc.c ****     key->slot = ATECC_INVALID_SLOT;
6950:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ATECC508A */
6951:../src/wolfcrypt/src/ecc.c **** 
6952:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_KCAPI_ECC
6953:../src/wolfcrypt/src/ecc.c ****     KcapiEcc_Free(key);
6954:../src/wolfcrypt/src/ecc.c **** #endif
6955:../src/wolfcrypt/src/ecc.c **** 
6956:../src/wolfcrypt/src/ecc.c ****     mp_clear(key->pubkey.x);
 9131                             		.loc 2 6956 25
 9132 0012 EC A5                   		mov.L	[r10], r5
 9133 0014 71 55 18                		add	#24, r5
 9134                             		.loc 2 6956 5
 9135 0017 EF 51                   		mov.L	r5, r1
 9136 0019 05 00 00 00             		bsr	_sp_clear
6957:../src/wolfcrypt/src/ecc.c ****     mp_clear(key->pubkey.y);
 9137                             		.loc 2 6957 25
 9138 001d EC A5                   		mov.L	[r10], r5
 9139 001f 72 55 28 03             		add	#0x328, r5
 9140                             		.loc 2 6957 5
 9141 0023 EF 51                   		mov.L	r5, r1
 9142 0025 05 00 00 00             		bsr	_sp_clear
6958:../src/wolfcrypt/src/ecc.c ****     mp_clear(key->pubkey.z);
 9143                             		.loc 2 6958 25
 9144 0029 EC A5                   		mov.L	[r10], r5
 9145 002b 72 55 38 06             		add	#0x638, r5
 9146                             		.loc 2 6958 5
 9147 002f EF 51                   		mov.L	r5, r1
 9148 0031 05 00 00 00             		bsr	_sp_clear
6959:../src/wolfcrypt/src/ecc.c **** 
6960:../src/wolfcrypt/src/ecc.c ****     mp_forcezero(&key->k);
 9149                             		.loc 2 6960 18
 9150 0035 EC A5                   		mov.L	[r10], r5
 9151 0037 72 55 48 09             		add	#0x948, r5
 9152                             		.loc 2 6960 5
 9153 003b EF 51                   		mov.L	r5, r1
 9154 003d 05 00 00 00             		bsr	_sp_forcezero
6961:../src/wolfcrypt/src/ecc.c **** 
6962:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CUSTOM_CURVES
6963:../src/wolfcrypt/src/ecc.c ****     if (key->deallocSet && key->dp != NULL)
6964:../src/wolfcrypt/src/ecc.c ****         wc_ecc_free_curve(key->dp, key->heap);
6965:../src/wolfcrypt/src/ecc.c **** #endif
6966:../src/wolfcrypt/src/ecc.c **** 
6967:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
6968:../src/wolfcrypt/src/ecc.c ****     wc_MemZero_Check(key, sizeof(ecc_key));
6969:../src/wolfcrypt/src/ecc.c **** #endif
6970:../src/wolfcrypt/src/ecc.c **** 
6971:../src/wolfcrypt/src/ecc.c ****     return 0;
 9155                             		.loc 2 6971 12
 9156 0041 66 05                   		mov.L	#0, r5
 9157                             	.L634:
6972:../src/wolfcrypt/src/ecc.c **** }
 9158                             		.loc 2 6972 1
 9159 0043 EF 51                   		mov.L	r5, r1
 9160 0045 3F AA 02                		rtsd	#8, r10-r10
 9161                             	.LFE106:
 9163                             		.section	.text.ecc_projective_add_point_safe,"ax",@progbits
 9164                             		.global	_ecc_projective_add_point_safe
 9166                             	_ecc_projective_add_point_safe:
 9167                             	.LFB107:
6973:../src/wolfcrypt/src/ecc.c **** 
6974:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
6975:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_SP_MATH) && \
6976:../src/wolfcrypt/src/ecc.c ****     !defined(WOLF_CRYPTO_CB_ONLY_ECC)
6977:../src/wolfcrypt/src/ecc.c **** /* Handles add failure cases:
6978:../src/wolfcrypt/src/ecc.c ****  *
6979:../src/wolfcrypt/src/ecc.c ****  * Before add:
6980:../src/wolfcrypt/src/ecc.c ****  *   Case 1: A is infinity
6981:../src/wolfcrypt/src/ecc.c ****  *        -> Copy B into result.
6982:../src/wolfcrypt/src/ecc.c ****  *   Case 2: B is infinity
6983:../src/wolfcrypt/src/ecc.c ****  *        -> Copy A into result.
6984:../src/wolfcrypt/src/ecc.c ****  *   Case 3: x and z are the same in A and B (same x value in affine)
6985:../src/wolfcrypt/src/ecc.c ****  *     Case 3a: y values the same - same point
6986:../src/wolfcrypt/src/ecc.c ****  *           -> Double instead of add.
6987:../src/wolfcrypt/src/ecc.c ****  *     Case 3b: y values different - negative of the other when points on curve
6988:../src/wolfcrypt/src/ecc.c ****  *           -> Need to set result to infinity.
6989:../src/wolfcrypt/src/ecc.c ****  *
6990:../src/wolfcrypt/src/ecc.c ****  * After add:
6991:../src/wolfcrypt/src/ecc.c ****  *   Case 1: A and B are the same point (maybe different z)
6992:../src/wolfcrypt/src/ecc.c ****  *           (Result was: x == y == z == 0)
6993:../src/wolfcrypt/src/ecc.c ****  *        -> Need to double instead.
6994:../src/wolfcrypt/src/ecc.c ****  *
6995:../src/wolfcrypt/src/ecc.c ****  *   Case 2: A + B = <infinity> = 0.
6996:../src/wolfcrypt/src/ecc.c ****  *           (Result was: z == 0, x and/or y not 0)
6997:../src/wolfcrypt/src/ecc.c ****  *        -> Need to set result to infinity.
6998:../src/wolfcrypt/src/ecc.c ****  */
6999:../src/wolfcrypt/src/ecc.c **** int ecc_projective_add_point_safe(ecc_point* A, ecc_point* B, ecc_point* R,
7000:../src/wolfcrypt/src/ecc.c ****     mp_int* a, mp_int* modulus, mp_digit mp, int* infinity)
7001:../src/wolfcrypt/src/ecc.c **** {
 9168                             		.loc 2 7001 1
 9169 0000 7E AA                   		push.l	r10
 9170                             	.LCFI162:
 9171 0002 7E A6                   		push.l	r6
 9172                             	.LCFI163:
 9173 0004 71 0A E0                		add	#-32, r0, r10
 9174                             	.LCFI164:
 9175 0007 71 A0 F8                		add	#-8, r10, r0
 9176                             	.LCFI165:
 9177 000a 75 46 2C                		mov.L	#44, r6
 9178 000d 4B A6                   		add	r10, r6
 9179 000f E7 A1 01                		mov.L	r1, 4[r10]
 9180 0012 E7 A2 02                		mov.L	r2, 8[r10]
 9181 0015 E7 A3 03                		mov.L	r3, 12[r10]
 9182 0018 E7 A4 04                		mov.L	r4, 16[r10]
7002:../src/wolfcrypt/src/ecc.c ****     int err;
7003:../src/wolfcrypt/src/ecc.c **** 
7004:../src/wolfcrypt/src/ecc.c ****     if (mp_iszero(A->x) && mp_iszero(A->y)) {
 9183                             		.loc 2 7004 9
 9184 001b ED A5 01                		mov.L	4[r10], r5
 9185 001e EC 55                   		mov.L	[r5], r5
 9186                             		.loc 2 7004 8
 9187 0020 61 05                   		cmp	#0, r5
 9188 0022 21 1B                   		bne	.L636
 9189                             		.loc 2 7004 28 discriminator 1
 9190 0024 ED A5 01                		mov.L	4[r10], r5
 9191 0027 ED 55 C4                		mov.L	784[r5], r5
 9192                             		.loc 2 7004 25 discriminator 1
 9193 002a 61 05                   		cmp	#0, r5
 9194 002c 21 11                   		bne	.L636
7005:../src/wolfcrypt/src/ecc.c ****         /* A is infinity. */
7006:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_copy_point(B, R);
 9195                             		.loc 2 7006 15
 9196 002e ED A2 03                		mov.L	12[r10], r2
 9197 0031 ED A1 02                		mov.L	8[r10], r1
 9198 0034 05 00 00 00             		bsr	_wc_ecc_copy_point
 9199 0038 E3 A1                   		mov.L	r1, [r10]
 9200                             		.loc 2 7006 13
 9201 003a 38 D0 01                		bra	.L637
 9202                             	.L636:
7007:../src/wolfcrypt/src/ecc.c ****     }
7008:../src/wolfcrypt/src/ecc.c ****     else if (mp_iszero(B->x) && mp_iszero(B->y)) {
 9203                             		.loc 2 7008 14
 9204 003d ED A5 02                		mov.L	8[r10], r5
 9205 0040 EC 55                   		mov.L	[r5], r5
 9206                             		.loc 2 7008 13
 9207 0042 61 05                   		cmp	#0, r5
 9208 0044 21 1B                   		bne	.L638
 9209                             		.loc 2 7008 33 discriminator 1
 9210 0046 ED A5 02                		mov.L	8[r10], r5
 9211 0049 ED 55 C4                		mov.L	784[r5], r5
 9212                             		.loc 2 7008 30 discriminator 1
 9213 004c 61 05                   		cmp	#0, r5
 9214 004e 21 11                   		bne	.L638
7009:../src/wolfcrypt/src/ecc.c ****         /* B is infinity. */
7010:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_copy_point(A, R);
 9215                             		.loc 2 7010 15
 9216 0050 ED A2 03                		mov.L	12[r10], r2
 9217 0053 ED A1 01                		mov.L	4[r10], r1
 9218 0056 05 00 00 00             		bsr	_wc_ecc_copy_point
 9219 005a E3 A1                   		mov.L	r1, [r10]
 9220                             		.loc 2 7010 13
 9221 005c 38 AE 01                		bra	.L637
 9222                             	.L638:
7011:../src/wolfcrypt/src/ecc.c ****     }
7012:../src/wolfcrypt/src/ecc.c ****     else if ((mp_cmp(A->x, B->x) == MP_EQ) && (mp_cmp(A->z, B->z) == MP_EQ)) {
 9223                             		.loc 2 7012 23
 9224 005f ED A5 01                		mov.L	4[r10], r5
 9225                             		.loc 2 7012 29
 9226 0062 ED A4 02                		mov.L	8[r10], r4
 9227                             		.loc 2 7012 15
 9228 0065 EF 42                   		mov.L	r4, r2
 9229 0067 EF 51                   		mov.L	r5, r1
 9230 0069 05 00 00 00             		bsr	_sp_cmp
 9231 006d EF 15                   		mov.L	r1, r5
 9232                             		.loc 2 7012 13
 9233 006f 61 05                   		cmp	#0, r5
 9234 0071 3B A5 00                		bne	.L639
 9235                             		.loc 2 7012 56 discriminator 1
 9236 0074 ED A5 01                		mov.L	4[r10], r5
 9237 0077 72 54 20 06             		add	#0x620, r5, r4
 9238                             		.loc 2 7012 62 discriminator 1
 9239 007b ED A5 02                		mov.L	8[r10], r5
 9240 007e 72 55 20 06             		add	#0x620, r5
 9241                             		.loc 2 7012 48 discriminator 1
 9242 0082 EF 52                   		mov.L	r5, r2
 9243 0084 EF 41                   		mov.L	r4, r1
 9244 0086 05 00 00 00             		bsr	_sp_cmp
 9245 008a EF 15                   		mov.L	r1, r5
 9246                             		.loc 2 7012 44 discriminator 1
 9247 008c 61 05                   		cmp	#0, r5
 9248 008e 3B 88 00                		bne	.L639
7013:../src/wolfcrypt/src/ecc.c ****         /* x ordinattes the same. */
7014:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp(A->y, B->y) == MP_EQ) {
 9249                             		.loc 2 7014 21
 9250 0091 ED A5 01                		mov.L	4[r10], r5
 9251 0094 72 54 10 03             		add	#0x310, r5, r4
 9252                             		.loc 2 7014 27
 9253 0098 ED A5 02                		mov.L	8[r10], r5
 9254 009b 72 55 10 03             		add	#0x310, r5
 9255                             		.loc 2 7014 13
 9256 009f EF 52                   		mov.L	r5, r2
 9257 00a1 EF 41                   		mov.L	r4, r1
 9258 00a3 05 00 00 00             		bsr	_sp_cmp
 9259 00a7 EF 15                   		mov.L	r1, r5
 9260                             		.loc 2 7014 12
 9261 00a9 61 05                   		cmp	#0, r5
 9262 00ab 21 1A                   		bne	.L640
7015:../src/wolfcrypt/src/ecc.c ****             /* A = B */
7016:../src/wolfcrypt/src/ecc.c ****             err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
 9263                             		.loc 2 7016 19
 9264 00ad A8 6D                   		mov.L	4[r6], r5
 9265 00af E3 05                   		mov.L	r5, [r0]
 9266 00b1 EC 64                   		mov.L	[r6], r4
 9267 00b3 ED A3 04                		mov.L	16[r10], r3
 9268 00b6 ED A2 03                		mov.L	12[r10], r2
 9269 00b9 ED A1 02                		mov.L	8[r10], r1
 9270 00bc 05 00 00 00             		bsr	__ecc_projective_dbl_point
 9271 00c0 E3 A1                   		mov.L	r1, [r10]
7014:../src/wolfcrypt/src/ecc.c ****             /* A = B */
 9272                             		.loc 2 7014 12
 9273 00c2 38 44 01                		bra	.L652
 9274                             	.L640:
7017:../src/wolfcrypt/src/ecc.c ****         }
7018:../src/wolfcrypt/src/ecc.c ****         else {
7019:../src/wolfcrypt/src/ecc.c ****             /* A = -B */
7020:../src/wolfcrypt/src/ecc.c ****             err = mp_set(R->x, 0);
 9275                             		.loc 2 7020 27
 9276 00c5 ED A5 03                		mov.L	12[r10], r5
 9277                             		.loc 2 7020 19
 9278 00c8 66 02                   		mov.L	#0, r2
 9279 00ca EF 51                   		mov.L	r5, r1
 9280 00cc 05 00 00 00             		bsr	_sp_set
 9281 00d0 E3 A1                   		mov.L	r1, [r10]
7021:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
 9282                             		.loc 2 7021 16
 9283 00d2 EC A5                   		mov.L	[r10], r5
 9284 00d4 61 05                   		cmp	#0, r5
 9285 00d6 21 13                   		bne	.L642
7022:../src/wolfcrypt/src/ecc.c ****                 err = mp_set(R->y, 0);
 9286                             		.loc 2 7022 31
 9287 00d8 ED A5 03                		mov.L	12[r10], r5
 9288 00db 72 55 10 03             		add	#0x310, r5
 9289                             		.loc 2 7022 23
 9290 00df 66 02                   		mov.L	#0, r2
 9291 00e1 EF 51                   		mov.L	r5, r1
 9292 00e3 05 00 00 00             		bsr	_sp_set
 9293 00e7 E3 A1                   		mov.L	r1, [r10]
 9294                             	.L642:
7023:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
 9295                             		.loc 2 7023 16
 9296 00e9 EC A5                   		mov.L	[r10], r5
 9297 00eb 61 05                   		cmp	#0, r5
 9298 00ed 21 13                   		bne	.L643
7024:../src/wolfcrypt/src/ecc.c ****                 err = mp_set(R->z, 1);
 9299                             		.loc 2 7024 31
 9300 00ef ED A5 03                		mov.L	12[r10], r5
 9301 00f2 72 55 20 06             		add	#0x620, r5
 9302                             		.loc 2 7024 23
 9303 00f6 66 12                   		mov.L	#1, r2
 9304 00f8 EF 51                   		mov.L	r5, r1
 9305 00fa 05 00 00 00             		bsr	_sp_set
 9306 00fe E3 A1                   		mov.L	r1, [r10]
 9307                             	.L643:
7025:../src/wolfcrypt/src/ecc.c ****             if ((err == MP_OKAY) && (infinity != NULL))
 9308                             		.loc 2 7025 16
 9309 0100 EC A5                   		mov.L	[r10], r5
 9310 0102 61 05                   		cmp	#0, r5
 9311 0104 3B 02 01                		bne	.L652
 9312                             		.loc 2 7025 34 discriminator 1
 9313 0107 A8 E5                   		mov.L	8[r6], r5
 9314 0109 61 05                   		cmp	#0, r5
 9315 010b 3A FB 00                		beq	.L652
7026:../src/wolfcrypt/src/ecc.c ****                 *infinity = 1;
 9316                             		.loc 2 7026 27
 9317 010e A8 E5                   		mov.L	8[r6], r5
 9318 0110 F8 56 01                		mov.L	#1, [r5]
7014:../src/wolfcrypt/src/ecc.c ****             /* A = B */
 9319                             		.loc 2 7014 12
 9320 0113 38 F3 00                		bra	.L652
 9321                             	.L639:
7027:../src/wolfcrypt/src/ecc.c ****         }
7028:../src/wolfcrypt/src/ecc.c ****     }
7029:../src/wolfcrypt/src/ecc.c ****     else {
7030:../src/wolfcrypt/src/ecc.c ****         err = _ecc_projective_add_point(A, B, R, a, modulus, mp);
 9322                             		.loc 2 7030 15
 9323 0116 A8 6D                   		mov.L	4[r6], r5
 9324 0118 A0 0D                   		mov.L	r5, 4[r0]
 9325 011a EC 65                   		mov.L	[r6], r5
 9326 011c E3 05                   		mov.L	r5, [r0]
 9327 011e ED A4 04                		mov.L	16[r10], r4
 9328 0121 ED A3 03                		mov.L	12[r10], r3
 9329 0124 ED A2 02                		mov.L	8[r10], r2
 9330 0127 ED A1 01                		mov.L	4[r10], r1
 9331 012a 05 00 00 00             		bsr	__ecc_projective_add_point
 9332 012e E3 A1                   		mov.L	r1, [r10]
7031:../src/wolfcrypt/src/ecc.c ****         if ((err == MP_OKAY) && mp_iszero(R->z)) {
 9333                             		.loc 2 7031 12
 9334 0130 EC A5                   		mov.L	[r10], r5
 9335 0132 61 05                   		cmp	#0, r5
 9336 0134 3B D6 00                		bne	.L637
 9337                             		.loc 2 7031 33 discriminator 1
 9338 0137 ED A5 03                		mov.L	12[r10], r5
 9339 013a EE 55 88 01             		mov.L	1568[r5], r5
 9340                             		.loc 2 7031 30 discriminator 1
 9341 013e 61 05                   		cmp	#0, r5
 9342 0140 3B CA 00                		bne	.L637
7032:../src/wolfcrypt/src/ecc.c ****             /* When all zero then should have done a double */
7033:../src/wolfcrypt/src/ecc.c ****             if (mp_iszero(R->x) && mp_iszero(R->y)) {
 9343                             		.loc 2 7033 17
 9344 0143 ED A5 03                		mov.L	12[r10], r5
 9345 0146 EC 55                   		mov.L	[r5], r5
 9346                             		.loc 2 7033 16
 9347 0148 61 05                   		cmp	#0, r5
 9348 014a 21 6F                   		bne	.L644
 9349                             		.loc 2 7033 36 discriminator 1
 9350 014c ED A5 03                		mov.L	12[r10], r5
 9351 014f ED 55 C4                		mov.L	784[r5], r5
 9352                             		.loc 2 7033 33 discriminator 1
 9353 0152 61 05                   		cmp	#0, r5
 9354 0154 21 65                   		bne	.L644
7034:../src/wolfcrypt/src/ecc.c ****                 if (mp_iszero(B->z)) {
 9355                             		.loc 2 7034 21
 9356 0156 ED A5 02                		mov.L	8[r10], r5
 9357 0159 EE 55 88 01             		mov.L	1568[r5], r5
 9358                             		.loc 2 7034 20
 9359 015d 61 05                   		cmp	#0, r5
 9360 015f 21 43                   		bne	.L645
7035:../src/wolfcrypt/src/ecc.c ****                     err = wc_ecc_copy_point(B, R);
 9361                             		.loc 2 7035 27
 9362 0161 ED A2 03                		mov.L	12[r10], r2
 9363 0164 ED A1 02                		mov.L	8[r10], r1
 9364 0167 05 00 00 00             		bsr	_wc_ecc_copy_point
 9365 016b E3 A1                   		mov.L	r1, [r10]
7036:../src/wolfcrypt/src/ecc.c ****                     if (err == MP_OKAY) {
 9366                             		.loc 2 7036 24
 9367 016d EC A5                   		mov.L	[r10], r5
 9368 016f 61 05                   		cmp	#0, r5
 9369 0171 21 13                   		bne	.L646
7037:../src/wolfcrypt/src/ecc.c ****                         err = mp_montgomery_calc_normalization(R->z, modulus);
 9370                             		.loc 2 7037 65
 9371 0173 ED A5 03                		mov.L	12[r10], r5
 9372 0176 72 55 20 06             		add	#0x620, r5
 9373                             		.loc 2 7037 31
 9374 017a EC 62                   		mov.L	[r6], r2
 9375 017c EF 51                   		mov.L	r5, r1
 9376 017e 05 00 00 00             		bsr	_sp_mont_norm
 9377 0182 E3 A1                   		mov.L	r1, [r10]
 9378                             	.L646:
7038:../src/wolfcrypt/src/ecc.c ****                     }
7039:../src/wolfcrypt/src/ecc.c ****                     if (err == MP_OKAY) {
 9379                             		.loc 2 7039 24
 9380 0184 EC A5                   		mov.L	[r10], r5
 9381 0186 61 05                   		cmp	#0, r5
 9382 0188 3B 81 00                		bne	.L653
7040:../src/wolfcrypt/src/ecc.c ****                         err = _ecc_projective_dbl_point(R, R, a, modulus, mp);
 9383                             		.loc 2 7040 31
 9384 018b A8 6D                   		mov.L	4[r6], r5
 9385 018d E3 05                   		mov.L	r5, [r0]
 9386 018f EC 64                   		mov.L	[r6], r4
 9387 0191 ED A3 04                		mov.L	16[r10], r3
 9388 0194 ED A2 03                		mov.L	12[r10], r2
 9389 0197 ED A1 03                		mov.L	12[r10], r1
 9390 019a 05 00 00 00             		bsr	__ecc_projective_dbl_point
 9391 019e E3 A1                   		mov.L	r1, [r10]
7034:../src/wolfcrypt/src/ecc.c ****                     err = wc_ecc_copy_point(B, R);
 9392                             		.loc 2 7034 20
 9393 01a0 2E 69                   		bra	.L653
 9394                             	.L645:
7041:../src/wolfcrypt/src/ecc.c ****                     }
7042:../src/wolfcrypt/src/ecc.c ****                 }
7043:../src/wolfcrypt/src/ecc.c ****                 else {
7044:../src/wolfcrypt/src/ecc.c ****                     err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
 9395                             		.loc 2 7044 27
 9396 01a2 A8 6D                   		mov.L	4[r6], r5
 9397 01a4 E3 05                   		mov.L	r5, [r0]
 9398 01a6 EC 64                   		mov.L	[r6], r4
 9399 01a8 ED A3 04                		mov.L	16[r10], r3
 9400 01ab ED A2 03                		mov.L	12[r10], r2
 9401 01ae ED A1 02                		mov.L	8[r10], r1
 9402 01b1 05 00 00 00             		bsr	__ecc_projective_dbl_point
 9403 01b5 E3 A1                   		mov.L	r1, [r10]
7034:../src/wolfcrypt/src/ecc.c ****                     err = wc_ecc_copy_point(B, R);
 9404                             		.loc 2 7034 20
 9405 01b7 2E 52                   		bra	.L653
 9406                             	.L644:
7045:../src/wolfcrypt/src/ecc.c ****                 }
7046:../src/wolfcrypt/src/ecc.c ****             }
7047:../src/wolfcrypt/src/ecc.c ****             /* When only Z zero then result is infinity */
7048:../src/wolfcrypt/src/ecc.c ****             else {
7049:../src/wolfcrypt/src/ecc.c ****                 err = mp_set(R->x, 0);
 9407                             		.loc 2 7049 31
 9408 01b9 ED A5 03                		mov.L	12[r10], r5
 9409                             		.loc 2 7049 23
 9410 01bc 66 02                   		mov.L	#0, r2
 9411 01be EF 51                   		mov.L	r5, r1
 9412 01c0 05 00 00 00             		bsr	_sp_set
 9413 01c4 E3 A1                   		mov.L	r1, [r10]
7050:../src/wolfcrypt/src/ecc.c ****                 if (err == MP_OKAY)
 9414                             		.loc 2 7050 20
 9415 01c6 EC A5                   		mov.L	[r10], r5
 9416 01c8 61 05                   		cmp	#0, r5
 9417 01ca 21 13                   		bne	.L649
7051:../src/wolfcrypt/src/ecc.c ****                     err = mp_set(R->y, 0);
 9418                             		.loc 2 7051 35
 9419 01cc ED A5 03                		mov.L	12[r10], r5
 9420 01cf 72 55 10 03             		add	#0x310, r5
 9421                             		.loc 2 7051 27
 9422 01d3 66 02                   		mov.L	#0, r2
 9423 01d5 EF 51                   		mov.L	r5, r1
 9424 01d7 05 00 00 00             		bsr	_sp_set
 9425 01db E3 A1                   		mov.L	r1, [r10]
 9426                             	.L649:
7052:../src/wolfcrypt/src/ecc.c ****                 if (err == MP_OKAY)
 9427                             		.loc 2 7052 20
 9428 01dd EC A5                   		mov.L	[r10], r5
 9429 01df 61 05                   		cmp	#0, r5
 9430 01e1 21 13                   		bne	.L650
7053:../src/wolfcrypt/src/ecc.c ****                     err = mp_set(R->z, 1);
 9431                             		.loc 2 7053 35
 9432 01e3 ED A5 03                		mov.L	12[r10], r5
 9433 01e6 72 55 20 06             		add	#0x620, r5
 9434                             		.loc 2 7053 27
 9435 01ea 66 12                   		mov.L	#1, r2
 9436 01ec EF 51                   		mov.L	r5, r1
 9437 01ee 05 00 00 00             		bsr	_sp_set
 9438 01f2 E3 A1                   		mov.L	r1, [r10]
 9439                             	.L650:
7054:../src/wolfcrypt/src/ecc.c ****                 if ((err == MP_OKAY) && (infinity != NULL))
 9440                             		.loc 2 7054 20
 9441 01f4 EC A5                   		mov.L	[r10], r5
 9442 01f6 61 05                   		cmp	#0, r5
 9443 01f8 21 12                   		bne	.L637
 9444                             		.loc 2 7054 38 discriminator 1
 9445 01fa A8 E5                   		mov.L	8[r6], r5
 9446 01fc 61 05                   		cmp	#0, r5
 9447 01fe 20 0C                   		beq	.L637
7055:../src/wolfcrypt/src/ecc.c ****                     *infinity = 1;
 9448                             		.loc 2 7055 31
 9449 0200 A8 E5                   		mov.L	8[r6], r5
 9450 0202 F8 56 01                		mov.L	#1, [r5]
 9451 0205 0D                      		bra	.L637
 9452                             	.L652:
7014:../src/wolfcrypt/src/ecc.c ****             /* A = B */
 9453                             		.loc 2 7014 12
 9454 0206 03                      		nop
 9455 0207 2E 03                   		bra	.L637
 9456                             	.L653:
7034:../src/wolfcrypt/src/ecc.c ****                     err = wc_ecc_copy_point(B, R);
 9457                             		.loc 2 7034 20
 9458 0209 03                      		nop
 9459                             		.balign 8,3,1
 9460                             	.L637:
7056:../src/wolfcrypt/src/ecc.c ****             }
7057:../src/wolfcrypt/src/ecc.c ****         }
7058:../src/wolfcrypt/src/ecc.c ****     }
7059:../src/wolfcrypt/src/ecc.c **** 
7060:../src/wolfcrypt/src/ecc.c ****     return err;
 9461                             		.loc 2 7060 12
 9462 020a EC A5                   		mov.L	[r10], r5
7061:../src/wolfcrypt/src/ecc.c **** }
 9463                             		.loc 2 7061 1
 9464 020c EF 51                   		mov.L	r5, r1
 9465 020e 71 00 28                		add	#40, r0
 9466 0211 7E B6                   		pop	r6
 9467 0213 7E BA                   		pop	r10
 9468 0215 02                      		rts
 9469                             	.LFE107:
 9471 0216 EF 00                   		.section	.text.ecc_projective_dbl_point_safe,"ax",@progbits
 9472                             		.global	_ecc_projective_dbl_point_safe
 9474                             	_ecc_projective_dbl_point_safe:
 9475                             	.LFB108:
7062:../src/wolfcrypt/src/ecc.c **** 
7063:../src/wolfcrypt/src/ecc.c **** /* Handles when P is the infinity point.
7064:../src/wolfcrypt/src/ecc.c ****  *
7065:../src/wolfcrypt/src/ecc.c ****  * Double infinity -> infinity.
7066:../src/wolfcrypt/src/ecc.c ****  * Otherwise do normal double - which can't lead to infinity as odd order.
7067:../src/wolfcrypt/src/ecc.c ****  */
7068:../src/wolfcrypt/src/ecc.c **** int ecc_projective_dbl_point_safe(ecc_point *P, ecc_point *R, mp_int* a,
7069:../src/wolfcrypt/src/ecc.c ****                                   mp_int* modulus, mp_digit mp)
7070:../src/wolfcrypt/src/ecc.c **** {
 9476                             		.loc 2 7070 1
 9477 0000 7E AA                   		push.l	r10
 9478                             	.LCFI166:
 9479 0002 71 0A E8                		add	#-24, r0, r10
 9480                             	.LCFI167:
 9481 0005 71 A0 FC                		add	#-4, r10, r0
 9482                             	.LCFI168:
 9483 0008 75 45 20                		mov.L	#32, r5
 9484 000b 4B A5                   		add	r10, r5
 9485 000d E7 A1 01                		mov.L	r1, 4[r10]
 9486 0010 E7 A2 02                		mov.L	r2, 8[r10]
 9487 0013 E7 A3 03                		mov.L	r3, 12[r10]
 9488 0016 E7 A4 04                		mov.L	r4, 16[r10]
7071:../src/wolfcrypt/src/ecc.c ****     int err;
7072:../src/wolfcrypt/src/ecc.c **** 
7073:../src/wolfcrypt/src/ecc.c ****     if (mp_iszero(P->x) && mp_iszero(P->y)) {
 9489                             		.loc 2 7073 9
 9490 0019 ED A4 01                		mov.L	4[r10], r4
 9491 001c EC 44                   		mov.L	[r4], r4
 9492                             		.loc 2 7073 8
 9493 001e 61 04                   		cmp	#0, r4
 9494 0020 21 1A                   		bne	.L655
 9495                             		.loc 2 7073 28 discriminator 1
 9496 0022 ED A4 01                		mov.L	4[r10], r4
 9497 0025 ED 44 C4                		mov.L	784[r4], r4
 9498                             		.loc 2 7073 25 discriminator 1
 9499 0028 61 04                   		cmp	#0, r4
 9500 002a 21 10                   		bne	.L655
7074:../src/wolfcrypt/src/ecc.c ****         /* P is infinity. */
7075:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_copy_point(P, R);
 9501                             		.loc 2 7075 15
 9502 002c ED A2 02                		mov.L	8[r10], r2
 9503 002f ED A1 01                		mov.L	4[r10], r1
 9504 0032 05 00 00 00             		bsr	_wc_ecc_copy_point
 9505 0036 E3 A1                   		mov.L	r1, [r10]
 9506                             		.loc 2 7075 13
 9507 0038 2E 18                   		bra	.L656
 9508                             	.L655:
7076:../src/wolfcrypt/src/ecc.c ****     }
7077:../src/wolfcrypt/src/ecc.c ****     else {
7078:../src/wolfcrypt/src/ecc.c ****         err = _ecc_projective_dbl_point(P, R, a, modulus, mp);
 9509                             		.loc 2 7078 15
 9510 003a EC 55                   		mov.L	[r5], r5
 9511 003c E3 05                   		mov.L	r5, [r0]
 9512 003e ED A4 04                		mov.L	16[r10], r4
 9513 0041 ED A3 03                		mov.L	12[r10], r3
 9514 0044 ED A2 02                		mov.L	8[r10], r2
 9515 0047 ED A1 01                		mov.L	4[r10], r1
 9516 004a 05 00 00 00             		bsr	__ecc_projective_dbl_point
 9517 004e E3 A1                   		mov.L	r1, [r10]
 9518                             	.L656:
7079:../src/wolfcrypt/src/ecc.c ****     }
7080:../src/wolfcrypt/src/ecc.c **** 
7081:../src/wolfcrypt/src/ecc.c ****     return err;
 9519                             		.loc 2 7081 12
 9520 0050 EC A5                   		mov.L	[r10], r5
7082:../src/wolfcrypt/src/ecc.c **** }
 9521                             		.loc 2 7082 1
 9522 0052 EF 51                   		mov.L	r5, r1
 9523 0054 3F AA 08                		rtsd	#32, r10-r10
 9524                             	.LFE108:
 9526                             		.section	.text.wc_ecc_verify_hash,"ax",@progbits
 9527                             		.global	_wc_ecc_verify_hash
 9529                             	_wc_ecc_verify_hash:
 9530                             	.LFB109:
7083:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_ATECC508A && !WOLFSSL_ATECC608A
7084:../src/wolfcrypt/src/ecc.c ****           && !WOLFSSL_CRYPTOCELL && !WOLFSSL_SP_MATH */
7085:../src/wolfcrypt/src/ecc.c **** 
7086:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH) && !defined(WOLFSSL_ATECC508A) && \
7087:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_ATECC608A) && !defined(WOLFSSL_CRYPTOCELL) && \
7088:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_KCAPI_ECC) && !defined(WOLF_CRYPTO_CB_ONLY_ECC)
7089:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_SHAMIR
7090:../src/wolfcrypt/src/ecc.c **** 
7091:../src/wolfcrypt/src/ecc.c **** /** Computes kA*A + kB*B = C using Shamir's Trick
7092:../src/wolfcrypt/src/ecc.c ****   A        First point to multiply
7093:../src/wolfcrypt/src/ecc.c ****   kA       What to multiple A by
7094:../src/wolfcrypt/src/ecc.c ****   B        Second point to multiply
7095:../src/wolfcrypt/src/ecc.c ****   kB       What to multiple B by
7096:../src/wolfcrypt/src/ecc.c ****   C        [out] Destination point (can overlap with A or B)
7097:../src/wolfcrypt/src/ecc.c ****   a        ECC curve parameter a
7098:../src/wolfcrypt/src/ecc.c ****   modulus  Modulus for curve
7099:../src/wolfcrypt/src/ecc.c ****   return MP_OKAY on success
7100:../src/wolfcrypt/src/ecc.c **** */
7101:../src/wolfcrypt/src/ecc.c **** #ifdef FP_ECC
7102:../src/wolfcrypt/src/ecc.c **** static int normal_ecc_mul2add(ecc_point* A, mp_int* kA,
7103:../src/wolfcrypt/src/ecc.c ****                              ecc_point* B, mp_int* kB,
7104:../src/wolfcrypt/src/ecc.c ****                              ecc_point* C, mp_int* a, mp_int* modulus,
7105:../src/wolfcrypt/src/ecc.c ****                              void* heap)
7106:../src/wolfcrypt/src/ecc.c **** #else
7107:../src/wolfcrypt/src/ecc.c **** int ecc_mul2add(ecc_point* A, mp_int* kA,
7108:../src/wolfcrypt/src/ecc.c ****                     ecc_point* B, mp_int* kB,
7109:../src/wolfcrypt/src/ecc.c ****                     ecc_point* C, mp_int* a, mp_int* modulus,
7110:../src/wolfcrypt/src/ecc.c ****                     void* heap)
7111:../src/wolfcrypt/src/ecc.c **** #endif
7112:../src/wolfcrypt/src/ecc.c **** {
7113:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
7114:../src/wolfcrypt/src/ecc.c ****   ecc_key        key;
7115:../src/wolfcrypt/src/ecc.c **** #endif
7116:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
7117:../src/wolfcrypt/src/ecc.c ****   ecc_point**    precomp = NULL;
7118:../src/wolfcrypt/src/ecc.c **** #else
7119:../src/wolfcrypt/src/ecc.c ****   ecc_point*     precomp[SHAMIR_PRECOMP_SZ];
7120:../src/wolfcrypt/src/ecc.c ****   #ifdef WOLFSSL_NO_MALLOC
7121:../src/wolfcrypt/src/ecc.c ****   ecc_point      lcl_precomp[SHAMIR_PRECOMP_SZ];
7122:../src/wolfcrypt/src/ecc.c ****   #endif
7123:../src/wolfcrypt/src/ecc.c **** #endif
7124:../src/wolfcrypt/src/ecc.c ****   unsigned       bitbufA, bitbufB, lenA, lenB, len, nA, nB, nibble;
7125:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_NO_MALLOC
7126:../src/wolfcrypt/src/ecc.c ****   unsigned char tA[ECC_BUFSIZE];
7127:../src/wolfcrypt/src/ecc.c ****   unsigned char tB[ECC_BUFSIZE];
7128:../src/wolfcrypt/src/ecc.c **** #else
7129:../src/wolfcrypt/src/ecc.c ****   unsigned char* tA = NULL;
7130:../src/wolfcrypt/src/ecc.c ****   unsigned char* tB = NULL;
7131:../src/wolfcrypt/src/ecc.c **** #endif
7132:../src/wolfcrypt/src/ecc.c ****   int            err = MP_OKAY, first, x, y;
7133:../src/wolfcrypt/src/ecc.c ****   mp_digit       mp = 0;
7134:../src/wolfcrypt/src/ecc.c **** 
7135:../src/wolfcrypt/src/ecc.c ****   /* argchks */
7136:../src/wolfcrypt/src/ecc.c ****   if (A == NULL || kA == NULL || B == NULL || kB == NULL || C == NULL ||
7137:../src/wolfcrypt/src/ecc.c ****                                                          modulus == NULL) {
7138:../src/wolfcrypt/src/ecc.c ****      return ECC_BAD_ARG_E;
7139:../src/wolfcrypt/src/ecc.c ****   }
7140:../src/wolfcrypt/src/ecc.c **** 
7141:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_NO_MALLOC
7142:../src/wolfcrypt/src/ecc.c ****   /* allocate memory */
7143:../src/wolfcrypt/src/ecc.c ****   tA = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
7144:../src/wolfcrypt/src/ecc.c ****   if (tA == NULL) {
7145:../src/wolfcrypt/src/ecc.c ****      return GEN_MEM_ERR;
7146:../src/wolfcrypt/src/ecc.c ****   }
7147:../src/wolfcrypt/src/ecc.c ****   tB = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
7148:../src/wolfcrypt/src/ecc.c ****   if (tB == NULL) {
7149:../src/wolfcrypt/src/ecc.c ****      XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
7150:../src/wolfcrypt/src/ecc.c ****      return GEN_MEM_ERR;
7151:../src/wolfcrypt/src/ecc.c ****   }
7152:../src/wolfcrypt/src/ecc.c **** #endif
7153:../src/wolfcrypt/src/ecc.c **** 
7154:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
7155:../src/wolfcrypt/src/ecc.c ****   precomp = (ecc_point**)XMALLOC(sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ, heap,
7156:../src/wolfcrypt/src/ecc.c ****                                                        DYNAMIC_TYPE_ECC_BUFFER);
7157:../src/wolfcrypt/src/ecc.c ****   if (precomp == NULL) {
7158:../src/wolfcrypt/src/ecc.c ****      XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
7159:../src/wolfcrypt/src/ecc.c ****      XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
7160:../src/wolfcrypt/src/ecc.c ****      return GEN_MEM_ERR;
7161:../src/wolfcrypt/src/ecc.c ****   }
7162:../src/wolfcrypt/src/ecc.c **** #endif
7163:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
7164:../src/wolfcrypt/src/ecc.c ****   key.t1 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
7165:../src/wolfcrypt/src/ecc.c ****   key.t2 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
7166:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
7167:../src/wolfcrypt/src/ecc.c ****   key.x = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
7168:../src/wolfcrypt/src/ecc.c ****   key.y = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
7169:../src/wolfcrypt/src/ecc.c ****   key.z = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
7170:../src/wolfcrypt/src/ecc.c **** #endif
7171:../src/wolfcrypt/src/ecc.c **** 
7172:../src/wolfcrypt/src/ecc.c ****   if (key.t1 == NULL || key.t2 == NULL
7173:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
7174:../src/wolfcrypt/src/ecc.c ****      || key.x == NULL || key.y == NULL || key.z == NULL
7175:../src/wolfcrypt/src/ecc.c **** #endif
7176:../src/wolfcrypt/src/ecc.c ****   ) {
7177:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
7178:../src/wolfcrypt/src/ecc.c ****       XFREE(key.z, heap, DYNAMIC_TYPE_ECC);
7179:../src/wolfcrypt/src/ecc.c ****       XFREE(key.y, heap, DYNAMIC_TYPE_ECC);
7180:../src/wolfcrypt/src/ecc.c ****       XFREE(key.x, heap, DYNAMIC_TYPE_ECC);
7181:../src/wolfcrypt/src/ecc.c **** #endif
7182:../src/wolfcrypt/src/ecc.c ****       XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);
7183:../src/wolfcrypt/src/ecc.c ****       XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);
7184:../src/wolfcrypt/src/ecc.c ****       XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);
7185:../src/wolfcrypt/src/ecc.c ****       XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
7186:../src/wolfcrypt/src/ecc.c ****       XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
7187:../src/wolfcrypt/src/ecc.c ****       return MEMORY_E;
7188:../src/wolfcrypt/src/ecc.c ****   }
7189:../src/wolfcrypt/src/ecc.c ****   C->key = &key;
7190:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SMALL_STACK_CACHE */
7191:../src/wolfcrypt/src/ecc.c **** 
7192:../src/wolfcrypt/src/ecc.c ****   /* init variables */
7193:../src/wolfcrypt/src/ecc.c ****   XMEMSET(tA, 0, ECC_BUFSIZE);
7194:../src/wolfcrypt/src/ecc.c ****   XMEMSET(tB, 0, ECC_BUFSIZE);
7195:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SMALL_STACK
7196:../src/wolfcrypt/src/ecc.c ****   XMEMSET(precomp, 0, sizeof(precomp));
7197:../src/wolfcrypt/src/ecc.c **** #else
7198:../src/wolfcrypt/src/ecc.c ****   XMEMSET(precomp, 0, sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ);
7199:../src/wolfcrypt/src/ecc.c **** #endif
7200:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
7201:../src/wolfcrypt/src/ecc.c ****   wc_MemZero_Add("ecc_mul2add tA", tA, ECC_BUFSIZE);
7202:../src/wolfcrypt/src/ecc.c ****   wc_MemZero_Add("ecc_mul2add tB", tB, ECC_BUFSIZE);
7203:../src/wolfcrypt/src/ecc.c **** #endif
7204:../src/wolfcrypt/src/ecc.c **** 
7205:../src/wolfcrypt/src/ecc.c ****   /* get sizes */
7206:../src/wolfcrypt/src/ecc.c ****   lenA = mp_unsigned_bin_size(kA);
7207:../src/wolfcrypt/src/ecc.c ****   lenB = mp_unsigned_bin_size(kB);
7208:../src/wolfcrypt/src/ecc.c ****   len  = MAX(lenA, lenB);
7209:../src/wolfcrypt/src/ecc.c **** 
7210:../src/wolfcrypt/src/ecc.c ****   /* sanity check */
7211:../src/wolfcrypt/src/ecc.c ****   if ((lenA > ECC_BUFSIZE) || (lenB > ECC_BUFSIZE)) {
7212:../src/wolfcrypt/src/ecc.c ****     err = BAD_FUNC_ARG;
7213:../src/wolfcrypt/src/ecc.c ****   }
7214:../src/wolfcrypt/src/ecc.c **** 
7215:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY) {
7216:../src/wolfcrypt/src/ecc.c ****     /* extract and justify kA */
7217:../src/wolfcrypt/src/ecc.c ****     err = mp_to_unsigned_bin(kA, (len - lenA) + tA);
7218:../src/wolfcrypt/src/ecc.c **** 
7219:../src/wolfcrypt/src/ecc.c ****     /* extract and justify kB */
7220:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
7221:../src/wolfcrypt/src/ecc.c ****         err = mp_to_unsigned_bin(kB, (len - lenB) + tB);
7222:../src/wolfcrypt/src/ecc.c **** 
7223:../src/wolfcrypt/src/ecc.c ****     /* allocate the table */
7224:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
7225:../src/wolfcrypt/src/ecc.c ****         for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
7226:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_NO_MALLOC
7227:../src/wolfcrypt/src/ecc.c ****             precomp[x] = &lcl_precomp[x];
7228:../src/wolfcrypt/src/ecc.c ****         #endif
7229:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_new_point_ex(&precomp[x], heap);
7230:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY)
7231:../src/wolfcrypt/src/ecc.c ****                 break;
7232:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_SMALL_STACK_CACHE
7233:../src/wolfcrypt/src/ecc.c ****             precomp[x]->key = &key;
7234:../src/wolfcrypt/src/ecc.c ****         #endif
7235:../src/wolfcrypt/src/ecc.c ****         }
7236:../src/wolfcrypt/src/ecc.c ****     }
7237:../src/wolfcrypt/src/ecc.c ****   }
7238:../src/wolfcrypt/src/ecc.c **** 
7239:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY)
7240:../src/wolfcrypt/src/ecc.c ****     /* init montgomery reduction */
7241:../src/wolfcrypt/src/ecc.c ****     err = mp_montgomery_setup(modulus, &mp);
7242:../src/wolfcrypt/src/ecc.c **** 
7243:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY) {
7244:../src/wolfcrypt/src/ecc.c ****   #ifdef WOLFSSL_SMALL_STACK
7245:../src/wolfcrypt/src/ecc.c ****     mp_int* mu;
7246:../src/wolfcrypt/src/ecc.c ****   #else
7247:../src/wolfcrypt/src/ecc.c ****     mp_int  mu[1];
7248:../src/wolfcrypt/src/ecc.c ****   #endif
7249:../src/wolfcrypt/src/ecc.c ****   #ifdef WOLFSSL_SMALL_STACK
7250:../src/wolfcrypt/src/ecc.c ****     mu = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
7251:../src/wolfcrypt/src/ecc.c ****     if (mu == NULL)
7252:../src/wolfcrypt/src/ecc.c ****         err = MEMORY_E;
7253:../src/wolfcrypt/src/ecc.c ****   #endif
7254:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
7255:../src/wolfcrypt/src/ecc.c ****         err = mp_init(mu);
7256:../src/wolfcrypt/src/ecc.c ****     }
7257:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
7258:../src/wolfcrypt/src/ecc.c ****       err = mp_montgomery_calc_normalization(mu, modulus);
7259:../src/wolfcrypt/src/ecc.c **** 
7260:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
7261:../src/wolfcrypt/src/ecc.c ****         /* copy ones ... */
7262:../src/wolfcrypt/src/ecc.c ****         err = mp_mulmod(A->x, mu, modulus, precomp[1]->x);
7263:../src/wolfcrypt/src/ecc.c **** 
7264:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
7265:../src/wolfcrypt/src/ecc.c ****         err = mp_mulmod(A->y, mu, modulus, precomp[1]->y);
7266:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
7267:../src/wolfcrypt/src/ecc.c ****         err = mp_mulmod(A->z, mu, modulus, precomp[1]->z);
7268:../src/wolfcrypt/src/ecc.c **** 
7269:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
7270:../src/wolfcrypt/src/ecc.c ****         err = mp_mulmod(B->x, mu, modulus, precomp[1<<2]->x);
7271:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
7272:../src/wolfcrypt/src/ecc.c ****         err = mp_mulmod(B->y, mu, modulus, precomp[1<<2]->y);
7273:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
7274:../src/wolfcrypt/src/ecc.c ****         err = mp_mulmod(B->z, mu, modulus, precomp[1<<2]->z);
7275:../src/wolfcrypt/src/ecc.c **** 
7276:../src/wolfcrypt/src/ecc.c ****       /* done with mu */
7277:../src/wolfcrypt/src/ecc.c ****       mp_clear(mu);
7278:../src/wolfcrypt/src/ecc.c ****     }
7279:../src/wolfcrypt/src/ecc.c ****   #ifdef WOLFSSL_SMALL_STACK
7280:../src/wolfcrypt/src/ecc.c ****     if (mu != NULL) {
7281:../src/wolfcrypt/src/ecc.c ****       XFREE(mu, heap, DYNAMIC_TYPE_ECC);
7282:../src/wolfcrypt/src/ecc.c ****     }
7283:../src/wolfcrypt/src/ecc.c ****   #endif
7284:../src/wolfcrypt/src/ecc.c ****   }
7285:../src/wolfcrypt/src/ecc.c **** 
7286:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY) {
7287:../src/wolfcrypt/src/ecc.c ****     /* precomp [i,0](A + B) table */
7288:../src/wolfcrypt/src/ecc.c ****     err = ecc_projective_dbl_point_safe(precomp[1], precomp[2], a, modulus, mp);
7289:../src/wolfcrypt/src/ecc.c ****   }
7290:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY) {
7291:../src/wolfcrypt/src/ecc.c ****     err = ecc_projective_add_point_safe(precomp[1], precomp[2], precomp[3],
7292:../src/wolfcrypt/src/ecc.c ****                                                           a, modulus, mp, NULL);
7293:../src/wolfcrypt/src/ecc.c ****   }
7294:../src/wolfcrypt/src/ecc.c **** 
7295:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY) {
7296:../src/wolfcrypt/src/ecc.c ****     /* precomp [0,i](A + B) table */
7297:../src/wolfcrypt/src/ecc.c ****     err = ecc_projective_dbl_point_safe(precomp[4], precomp[8], a, modulus, mp);
7298:../src/wolfcrypt/src/ecc.c ****   }
7299:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY) {
7300:../src/wolfcrypt/src/ecc.c ****     err = ecc_projective_add_point_safe(precomp[4], precomp[8], precomp[12], a,
7301:../src/wolfcrypt/src/ecc.c ****                                                              modulus, mp, NULL);
7302:../src/wolfcrypt/src/ecc.c ****   }
7303:../src/wolfcrypt/src/ecc.c **** 
7304:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY) {
7305:../src/wolfcrypt/src/ecc.c ****     /* precomp [i,j](A + B) table (i != 0, j != 0) */
7306:../src/wolfcrypt/src/ecc.c ****     for (x = 1; x < 4; x++) {
7307:../src/wolfcrypt/src/ecc.c ****       for (y = 1; y < 4; y++) {
7308:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
7309:../src/wolfcrypt/src/ecc.c ****           err = ecc_projective_add_point_safe(precomp[x], precomp[(y<<2)],
7310:../src/wolfcrypt/src/ecc.c ****                                                   precomp[x+(y<<2)], a, modulus,
7311:../src/wolfcrypt/src/ecc.c ****                                                   mp, NULL);
7312:../src/wolfcrypt/src/ecc.c ****         }
7313:../src/wolfcrypt/src/ecc.c ****       }
7314:../src/wolfcrypt/src/ecc.c ****     }
7315:../src/wolfcrypt/src/ecc.c ****   }
7316:../src/wolfcrypt/src/ecc.c **** 
7317:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY) {
7318:../src/wolfcrypt/src/ecc.c ****     nibble  = 3;
7319:../src/wolfcrypt/src/ecc.c ****     first   = 1;
7320:../src/wolfcrypt/src/ecc.c ****     bitbufA = tA[0];
7321:../src/wolfcrypt/src/ecc.c ****     bitbufB = tB[0];
7322:../src/wolfcrypt/src/ecc.c **** 
7323:../src/wolfcrypt/src/ecc.c ****     /* for every byte of the multiplicands */
7324:../src/wolfcrypt/src/ecc.c ****     for (x = 0; x < (int)len || nibble != 3; ) {
7325:../src/wolfcrypt/src/ecc.c ****         /* grab a nibble */
7326:../src/wolfcrypt/src/ecc.c ****         if (++nibble == 4) {
7327:../src/wolfcrypt/src/ecc.c ****             if (x == (int)len) break;
7328:../src/wolfcrypt/src/ecc.c ****             bitbufA = tA[x];
7329:../src/wolfcrypt/src/ecc.c ****             bitbufB = tB[x];
7330:../src/wolfcrypt/src/ecc.c ****             nibble  = 0;
7331:../src/wolfcrypt/src/ecc.c ****             x++;
7332:../src/wolfcrypt/src/ecc.c ****         }
7333:../src/wolfcrypt/src/ecc.c **** 
7334:../src/wolfcrypt/src/ecc.c ****         /* extract two bits from both, shift/update */
7335:../src/wolfcrypt/src/ecc.c ****         nA = (bitbufA >> 6) & 0x03;
7336:../src/wolfcrypt/src/ecc.c ****         nB = (bitbufB >> 6) & 0x03;
7337:../src/wolfcrypt/src/ecc.c ****         bitbufA = (bitbufA << 2) & 0xFF;
7338:../src/wolfcrypt/src/ecc.c ****         bitbufB = (bitbufB << 2) & 0xFF;
7339:../src/wolfcrypt/src/ecc.c **** 
7340:../src/wolfcrypt/src/ecc.c ****         /* if both zero, if first, continue */
7341:../src/wolfcrypt/src/ecc.c ****         if ((nA == 0) && (nB == 0) && (first == 1)) {
7342:../src/wolfcrypt/src/ecc.c ****             continue;
7343:../src/wolfcrypt/src/ecc.c ****         }
7344:../src/wolfcrypt/src/ecc.c **** 
7345:../src/wolfcrypt/src/ecc.c ****         /* double twice, only if this isn't the first */
7346:../src/wolfcrypt/src/ecc.c ****         if (first == 0) {
7347:../src/wolfcrypt/src/ecc.c ****             /* double twice */
7348:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
7349:../src/wolfcrypt/src/ecc.c ****                 err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
7350:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
7351:../src/wolfcrypt/src/ecc.c ****                 err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
7352:../src/wolfcrypt/src/ecc.c ****             else
7353:../src/wolfcrypt/src/ecc.c ****                 break;
7354:../src/wolfcrypt/src/ecc.c ****         }
7355:../src/wolfcrypt/src/ecc.c **** 
7356:../src/wolfcrypt/src/ecc.c ****         /* if not both zero */
7357:../src/wolfcrypt/src/ecc.c ****         if ((nA != 0) || (nB != 0)) {
7358:../src/wolfcrypt/src/ecc.c ****             int i = nA + (nB<<2);
7359:../src/wolfcrypt/src/ecc.c ****             if (first == 1) {
7360:../src/wolfcrypt/src/ecc.c ****                 /* if first, copy from table */
7361:../src/wolfcrypt/src/ecc.c ****                 first = 0;
7362:../src/wolfcrypt/src/ecc.c ****                 if (err == MP_OKAY)
7363:../src/wolfcrypt/src/ecc.c ****                     err = mp_copy(precomp[i]->x, C->x);
7364:../src/wolfcrypt/src/ecc.c **** 
7365:../src/wolfcrypt/src/ecc.c ****                 if (err == MP_OKAY)
7366:../src/wolfcrypt/src/ecc.c ****                     err = mp_copy(precomp[i]->y, C->y);
7367:../src/wolfcrypt/src/ecc.c **** 
7368:../src/wolfcrypt/src/ecc.c ****                 if (err == MP_OKAY)
7369:../src/wolfcrypt/src/ecc.c ****                     err = mp_copy(precomp[i]->z, C->z);
7370:../src/wolfcrypt/src/ecc.c ****                 else
7371:../src/wolfcrypt/src/ecc.c ****                     break;
7372:../src/wolfcrypt/src/ecc.c ****             } else {
7373:../src/wolfcrypt/src/ecc.c ****                 /* if not first, add from table */
7374:../src/wolfcrypt/src/ecc.c ****                 if (err == MP_OKAY)
7375:../src/wolfcrypt/src/ecc.c ****                     err = ecc_projective_add_point_safe(C, precomp[i],
7376:../src/wolfcrypt/src/ecc.c ****                                                         C, a, modulus, mp,
7377:../src/wolfcrypt/src/ecc.c ****                                                         &first);
7378:../src/wolfcrypt/src/ecc.c ****                 if (err != MP_OKAY)
7379:../src/wolfcrypt/src/ecc.c ****                     break;
7380:../src/wolfcrypt/src/ecc.c ****             }
7381:../src/wolfcrypt/src/ecc.c ****         }
7382:../src/wolfcrypt/src/ecc.c ****     }
7383:../src/wolfcrypt/src/ecc.c ****   }
7384:../src/wolfcrypt/src/ecc.c **** 
7385:../src/wolfcrypt/src/ecc.c ****   /* reduce to affine */
7386:../src/wolfcrypt/src/ecc.c ****   if (err == MP_OKAY)
7387:../src/wolfcrypt/src/ecc.c ****     err = ecc_map(C, modulus, mp);
7388:../src/wolfcrypt/src/ecc.c **** 
7389:../src/wolfcrypt/src/ecc.c ****   /* clean up */
7390:../src/wolfcrypt/src/ecc.c ****   for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
7391:../src/wolfcrypt/src/ecc.c ****      wc_ecc_del_point_ex(precomp[x], heap);
7392:../src/wolfcrypt/src/ecc.c ****   }
7393:../src/wolfcrypt/src/ecc.c **** 
7394:../src/wolfcrypt/src/ecc.c ****   ForceZero(tA, ECC_BUFSIZE);
7395:../src/wolfcrypt/src/ecc.c ****   ForceZero(tB, ECC_BUFSIZE);
7396:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK_CACHE
7397:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
7398:../src/wolfcrypt/src/ecc.c ****   XFREE(key.z, heap, DYNAMIC_TYPE_ECC);
7399:../src/wolfcrypt/src/ecc.c ****   XFREE(key.y, heap, DYNAMIC_TYPE_ECC);
7400:../src/wolfcrypt/src/ecc.c ****   XFREE(key.x, heap, DYNAMIC_TYPE_ECC);
7401:../src/wolfcrypt/src/ecc.c **** #endif
7402:../src/wolfcrypt/src/ecc.c ****   XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);
7403:../src/wolfcrypt/src/ecc.c ****   XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);
7404:../src/wolfcrypt/src/ecc.c ****   C->key = NULL;
7405:../src/wolfcrypt/src/ecc.c **** #endif
7406:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
7407:../src/wolfcrypt/src/ecc.c ****   XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);
7408:../src/wolfcrypt/src/ecc.c **** #endif
7409:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_NO_MALLOC
7410:../src/wolfcrypt/src/ecc.c ****   XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
7411:../src/wolfcrypt/src/ecc.c ****   XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
7412:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
7413:../src/wolfcrypt/src/ecc.c ****   wc_MemZero_Check(tB, ECC_BUFSIZE);
7414:../src/wolfcrypt/src/ecc.c ****   wc_MemZero_Check(tA, ECC_BUFSIZE);
7415:../src/wolfcrypt/src/ecc.c **** #endif
7416:../src/wolfcrypt/src/ecc.c ****   return err;
7417:../src/wolfcrypt/src/ecc.c **** }
7418:../src/wolfcrypt/src/ecc.c **** 
7419:../src/wolfcrypt/src/ecc.c **** #endif /* ECC_SHAMIR */
7420:../src/wolfcrypt/src/ecc.c **** #endif /* (!WOLFSSL_SP_MATH && !WOLFSSL_ATECC508A && !WOLFSSL_ATECC608A &&
7421:../src/wolfcrypt/src/ecc.c ****         * !WOLFSSL_CRYPTOCEL */
7422:../src/wolfcrypt/src/ecc.c **** 
7423:../src/wolfcrypt/src/ecc.c **** 
7424:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_VERIFY
7425:../src/wolfcrypt/src/ecc.c **** #ifndef NO_ASN
7426:../src/wolfcrypt/src/ecc.c **** /* verify
7427:../src/wolfcrypt/src/ecc.c ****  *
7428:../src/wolfcrypt/src/ecc.c ****  * w  = s^-1 mod n
7429:../src/wolfcrypt/src/ecc.c ****  * u1 = xw
7430:../src/wolfcrypt/src/ecc.c ****  * u2 = rw
7431:../src/wolfcrypt/src/ecc.c ****  * X = u1*G + u2*Q
7432:../src/wolfcrypt/src/ecc.c ****  * v = X_x1 mod n
7433:../src/wolfcrypt/src/ecc.c ****  * accept if v == r
7434:../src/wolfcrypt/src/ecc.c ****  */
7435:../src/wolfcrypt/src/ecc.c **** 
7436:../src/wolfcrypt/src/ecc.c **** /**
7437:../src/wolfcrypt/src/ecc.c ****  Verify an ECC signature
7438:../src/wolfcrypt/src/ecc.c ****  sig         The signature to verify
7439:../src/wolfcrypt/src/ecc.c ****  siglen      The length of the signature (octets)
7440:../src/wolfcrypt/src/ecc.c ****  hash        The hash (message digest) that was signed
7441:../src/wolfcrypt/src/ecc.c ****  hashlen     The length of the hash (octets)
7442:../src/wolfcrypt/src/ecc.c ****  res         Result of signature, 1==valid, 0==invalid
7443:../src/wolfcrypt/src/ecc.c ****  key         The corresponding public ECC key
7444:../src/wolfcrypt/src/ecc.c ****  return      MP_OKAY if successful (even if the signature is not valid)
7445:../src/wolfcrypt/src/ecc.c ****  */
7446:../src/wolfcrypt/src/ecc.c **** int wc_ecc_verify_hash(const byte* sig, word32 siglen, const byte* hash,
7447:../src/wolfcrypt/src/ecc.c ****                        word32 hashlen, int* res, ecc_key* key)
7448:../src/wolfcrypt/src/ecc.c **** {
 9531                             		.loc 2 7448 1
 9532 0000 7E AA                   		push.l	r10
 9533                             	.LCFI169:
 9534 0002 7E A6                   		push.l	r6
 9535                             	.LCFI170:
 9536 0004 71 0A C8                		add	#-56, r0, r10
 9537                             	.LCFI171:
 9538 0007 71 A0 F8                		add	#-8, r10, r0
 9539                             	.LCFI172:
 9540 000a 75 46 44                		mov.L	#0x44, r6
 9541 000d 4B A6                   		add	r10, r6
 9542 000f E7 A1 08                		mov.L	r1, 32[r10]
 9543 0012 E7 A2 09                		mov.L	r2, 36[r10]
 9544 0015 E7 A3 0A                		mov.L	r3, 40[r10]
 9545 0018 E7 A4 0B                		mov.L	r4, 44[r10]
7449:../src/wolfcrypt/src/ecc.c ****     int err;
7450:../src/wolfcrypt/src/ecc.c **** 
7451:../src/wolfcrypt/src/ecc.c ****     mp_int *r = NULL, *s = NULL;
 9546                             		.loc 2 7451 13
 9547 001b F9 A6 01 00             		mov.L	#0, 4[r10]
 9548                             		.loc 2 7451 24
 9549 001f F9 A6 02 00             		mov.L	#0, 8[r10]
7452:../src/wolfcrypt/src/ecc.c **** #if (!defined(WOLFSSL_ASYNC_CRYPT) || !defined(WC_ASYNC_ENABLE_ECC)) && \
7453:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_SMALL_STACK)
7454:../src/wolfcrypt/src/ecc.c ****     mp_int r_lcl, s_lcl;
7455:../src/wolfcrypt/src/ecc.c **** #endif
7456:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_ASYNC_CRYPT
7457:../src/wolfcrypt/src/ecc.c ****     int isPrivateKeyOnly = 0;
7458:../src/wolfcrypt/src/ecc.c **** #endif
7459:../src/wolfcrypt/src/ecc.c **** 
7460:../src/wolfcrypt/src/ecc.c ****     if (sig == NULL || hash == NULL || res == NULL || key == NULL) {
 9550                             		.loc 2 7460 8
 9551 0023 ED A5 08                		mov.L	32[r10], r5
 9552 0026 61 05                   		cmp	#0, r5
 9553 0028 20 13                   		beq	.L659
 9554                             		.loc 2 7460 21 discriminator 1
 9555 002a ED A5 0A                		mov.L	40[r10], r5
 9556 002d 61 05                   		cmp	#0, r5
 9557 002f 20 0C                   		beq	.L659
 9558                             		.loc 2 7460 37 discriminator 2
 9559 0031 EC 65                   		mov.L	[r6], r5
 9560 0033 61 05                   		cmp	#0, r5
 9561 0035 16                      		beq	.L659
 9562                             		.loc 2 7460 52 discriminator 3
 9563 0036 A8 6D                   		mov.L	4[r6], r5
 9564 0038 61 05                   		cmp	#0, r5
 9565 003a 18                      		bne	.L660
 9566                             		.balign 8,3,2
 9567                             	.L659:
7461:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 9568                             		.loc 2 7461 16
 9569 003b FB 5A 56 FF             		mov.L	#-170, r5
 9570 003f 38 49 01                		bra	.L661
 9571                             	.L660:
7462:../src/wolfcrypt/src/ecc.c ****     }
7463:../src/wolfcrypt/src/ecc.c **** 
7464:../src/wolfcrypt/src/ecc.c **** #ifdef WOLF_CRYPTO_CB
7465:../src/wolfcrypt/src/ecc.c ****     if (key->devId != INVALID_DEVID) {
7466:../src/wolfcrypt/src/ecc.c ****         err = wc_CryptoCb_EccVerify(sig, siglen, hash, hashlen, res, key);
7467:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLF_CRYPTO_CB_ONLY_ECC
7468:../src/wolfcrypt/src/ecc.c ****         if (err != CRYPTOCB_UNAVAILABLE)
7469:../src/wolfcrypt/src/ecc.c ****             return err;
7470:../src/wolfcrypt/src/ecc.c ****         /* fall-through when unavailable */
7471:../src/wolfcrypt/src/ecc.c ****     #endif
7472:../src/wolfcrypt/src/ecc.c ****     }
7473:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLF_CRYPTO_CB_ONLY_ECC
7474:../src/wolfcrypt/src/ecc.c ****     else {
7475:../src/wolfcrypt/src/ecc.c ****         err = NO_VALID_DEVID;
7476:../src/wolfcrypt/src/ecc.c ****     }
7477:../src/wolfcrypt/src/ecc.c ****     #endif
7478:../src/wolfcrypt/src/ecc.c **** #endif
7479:../src/wolfcrypt/src/ecc.c **** 
7480:../src/wolfcrypt/src/ecc.c **** #ifndef WOLF_CRYPTO_CB_ONLY_ECC
7481:../src/wolfcrypt/src/ecc.c **** 
7482:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
7483:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_alloc_async(key);
7484:../src/wolfcrypt/src/ecc.c ****     if (err != 0)
7485:../src/wolfcrypt/src/ecc.c ****         return err;
7486:../src/wolfcrypt/src/ecc.c ****     r = key->r;
7487:../src/wolfcrypt/src/ecc.c ****     s = key->s;
7488:../src/wolfcrypt/src/ecc.c **** #else
7489:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_SMALL_STACK
7490:../src/wolfcrypt/src/ecc.c ****     r = &r_lcl;
7491:../src/wolfcrypt/src/ecc.c ****     s = &s_lcl;
7492:../src/wolfcrypt/src/ecc.c ****     #else
7493:../src/wolfcrypt/src/ecc.c ****     r = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 9572                             		.loc 2 7493 18
 9573 0042 FB 1A 10 03             		mov.L	#0x310, r1
 9574 0046 05 00 00 00             		bsr	_wolfSSL_Malloc
 9575 004a E7 A1 01                		mov.L	r1, 4[r10]
7494:../src/wolfcrypt/src/ecc.c ****     if (r == NULL)
 9576                             		.loc 2 7494 8
 9577 004d ED A5 01                		mov.L	4[r10], r5
 9578 0050 61 05                   		cmp	#0, r5
 9579 0052 1F                      		bne	.L662
7495:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 9580                             		.loc 2 7495 16
 9581 0053 FB 56 83                		mov.L	#-125, r5
 9582 0056 38 32 01                		bra	.L661
 9583                             	.L662:
7496:../src/wolfcrypt/src/ecc.c ****     s = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 9584                             		.loc 2 7496 18
 9585 0059 FB 1A 10 03             		mov.L	#0x310, r1
 9586 005d 05 00 00 00             		bsr	_wolfSSL_Malloc
 9587 0061 E7 A1 02                		mov.L	r1, 8[r10]
7497:../src/wolfcrypt/src/ecc.c ****     if (s == NULL) {
 9588                             		.loc 2 7497 8
 9589 0064 ED A5 02                		mov.L	8[r10], r5
 9590 0067 61 05                   		cmp	#0, r5
 9591 0069 21 1B                   		bne	.L663
 9592                             	.LBB62:
7498:../src/wolfcrypt/src/ecc.c ****         XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 9593                             		.loc 2 7498 9
 9594 006b ED A5 01                		mov.L	4[r10], r5
 9595 006e E7 A5 03                		mov.L	r5, 12[r10]
 9596 0071 ED A5 03                		mov.L	12[r10], r5
 9597 0074 61 05                   		cmp	#0, r5
 9598 0076 10                      		beq	.L664
 9599                             		.loc 2 7498 9 is_stmt 0 discriminator 1
 9600 0077 ED A1 03                		mov.L	12[r10], r1
 9601 007a 05 00 00 00             		bsr	_wolfSSL_Free
 9602                             	.L664:
 9603                             	.LBE62:
7499:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 9604                             		.loc 2 7499 16 is_stmt 1
 9605 007e FB 56 83                		mov.L	#-125, r5
 9606 0081 38 07 01                		bra	.L661
 9607                             	.L663:
7500:../src/wolfcrypt/src/ecc.c ****     }
7501:../src/wolfcrypt/src/ecc.c ****     #endif
7502:../src/wolfcrypt/src/ecc.c ****     XMEMSET(r, 0, sizeof(mp_int));
 9608                             		.loc 2 7502 5
 9609 0084 FB 3A 10 03             		mov.L	#0x310, r3
 9610 0088 66 02                   		mov.L	#0, r2
 9611 008a ED A1 01                		mov.L	4[r10], r1
 9612 008d 05 00 00 00             		bsr	_memset
7503:../src/wolfcrypt/src/ecc.c ****     XMEMSET(s, 0, sizeof(mp_int));
 9613                             		.loc 2 7503 5
 9614 0091 FB 3A 10 03             		mov.L	#0x310, r3
 9615 0095 66 02                   		mov.L	#0, r2
 9616 0097 ED A1 02                		mov.L	8[r10], r1
 9617 009a 05 00 00 00             		bsr	_memset
7504:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ASYNC_CRYPT */
7505:../src/wolfcrypt/src/ecc.c **** 
7506:../src/wolfcrypt/src/ecc.c ****     switch (key->state) {
 9618                             		.loc 2 7506 16
 9619 009e A8 6D                   		mov.L	4[r6], r5
 9620 00a0 A8 D5                   		mov.L	8[r5], r5
 9621                             		.loc 2 7506 5
 9622 00a2 61 55                   		cmp	#5, r5
 9623 00a4 20 19                   		beq	.L665
 9624 00a6 61 55                   		cmp	#5, r5
 9625 00a8 2A 09                   		bgt	.L666
 9626 00aa 61 05                   		cmp	#0, r5
 9627 00ac 20 11                   		beq	.L665
 9628 00ae 38 9B 00                		bra	.L667
 9629                             	.L666:
 9630 00b1 61 65                   		cmp	#6, r5
 9631 00b3 20 2C                   		beq	.L668
 9632 00b5 61 75                   		cmp	#7, r5
 9633 00b7 3A 89 00                		beq	.L669
 9634 00ba 38 8F 00                		bra	.L667
 9635                             	.L665:
7507:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_NONE:
7508:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_VERIFY_DECODE:
7509:../src/wolfcrypt/src/ecc.c ****             key->state = ECC_STATE_VERIFY_DECODE;
 9636                             		.loc 2 7509 24
 9637 00bd A8 6D                   		mov.L	4[r6], r5
 9638 00bf 3E 52 05                		mov.L	#5, 8[r5]
7510:../src/wolfcrypt/src/ecc.c **** 
7511:../src/wolfcrypt/src/ecc.c ****             /* default to invalid signature */
7512:../src/wolfcrypt/src/ecc.c ****             *res = 0;
 9639                             		.loc 2 7512 18
 9640 00c2 EC 65                   		mov.L	[r6], r5
 9641 00c4 F8 56 00                		mov.L	#0, [r5]
7513:../src/wolfcrypt/src/ecc.c **** 
7514:../src/wolfcrypt/src/ecc.c ****             /* Note, DecodeECC_DSA_Sig() calls mp_init() on r and s.
7515:../src/wolfcrypt/src/ecc.c ****              * If either of those don't allocate correctly, none of
7516:../src/wolfcrypt/src/ecc.c ****              * the rest of this function will execute, and everything
7517:../src/wolfcrypt/src/ecc.c ****              * gets cleaned up at the end. */
7518:../src/wolfcrypt/src/ecc.c ****             /* decode DSA header */
7519:../src/wolfcrypt/src/ecc.c ****             err = DecodeECC_DSA_Sig(sig, siglen, r, s);
 9642                             		.loc 2 7519 19
 9643 00c7 ED A4 02                		mov.L	8[r10], r4
 9644 00ca ED A3 01                		mov.L	4[r10], r3
 9645 00cd ED A2 09                		mov.L	36[r10], r2
 9646 00d0 ED A1 08                		mov.L	32[r10], r1
 9647 00d3 05 00 00 00             		bsr	_DecodeECC_DSA_Sig
 9648 00d7 E3 A1                   		mov.L	r1, [r10]
7520:../src/wolfcrypt/src/ecc.c ****             if (err < 0) {
 9649                             		.loc 2 7520 16
 9650 00d9 EC A5                   		mov.L	[r10], r5
 9651 00db 61 05                   		cmp	#0, r5
 9652 00dd 29 71                   		blt	.L675
 9653                             	.L668:
7521:../src/wolfcrypt/src/ecc.c ****                 break;
7522:../src/wolfcrypt/src/ecc.c ****             }
7523:../src/wolfcrypt/src/ecc.c ****             FALL_THROUGH;
7524:../src/wolfcrypt/src/ecc.c **** 
7525:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_VERIFY_DO:
7526:../src/wolfcrypt/src/ecc.c ****             key->state = ECC_STATE_VERIFY_DO;
 9654                             		.loc 2 7526 24
 9655 00df A8 6D                   		mov.L	4[r6], r5
 9656 00e1 3E 52 06                		mov.L	#6, 8[r5]
7527:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_ASYNC_CRYPT
7528:../src/wolfcrypt/src/ecc.c ****             if (key->type == ECC_PRIVATEKEY_ONLY) {
7529:../src/wolfcrypt/src/ecc.c ****                 isPrivateKeyOnly = 1;
7530:../src/wolfcrypt/src/ecc.c ****             }
7531:../src/wolfcrypt/src/ecc.c ****         #endif
7532:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
 9657                             		.loc 2 7532 19
 9658 00e4 A8 6D                   		mov.L	4[r6], r5
 9659 00e6 A0 0D                   		mov.L	r5, 4[r0]
 9660 00e8 EC 65                   		mov.L	[r6], r5
 9661 00ea E3 05                   		mov.L	r5, [r0]
 9662 00ec ED A4 0B                		mov.L	44[r10], r4
 9663 00ef ED A3 0A                		mov.L	40[r10], r3
 9664 00f2 ED A2 02                		mov.L	8[r10], r2
 9665 00f5 ED A1 01                		mov.L	4[r10], r1
 9666 00f8 05 00 00 00             		bsr	_wc_ecc_verify_hash_ex
 9667 00fc E3 A1                   		mov.L	r1, [r10]
7533:../src/wolfcrypt/src/ecc.c **** 
7534:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ASYNC_CRYPT
7535:../src/wolfcrypt/src/ecc.c ****             /* done with R/S */
7536:../src/wolfcrypt/src/ecc.c ****             mp_clear(r);
 9668                             		.loc 2 7536 13
 9669 00fe ED A1 01                		mov.L	4[r10], r1
 9670 0101 05 00 00 00             		bsr	_sp_clear
7537:../src/wolfcrypt/src/ecc.c ****             mp_clear(s);
 9671                             		.loc 2 7537 13
 9672 0105 ED A1 02                		mov.L	8[r10], r1
 9673 0108 05 00 00 00             		bsr	_sp_clear
 9674                             	.LBB63:
7538:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_SMALL_STACK
7539:../src/wolfcrypt/src/ecc.c ****             XFREE(s, key->heap, DYNAMIC_TYPE_ECC);
 9675                             		.loc 2 7539 13
 9676 010c ED A5 02                		mov.L	8[r10], r5
 9677 010f E7 A5 04                		mov.L	r5, 16[r10]
 9678 0112 ED A5 04                		mov.L	16[r10], r5
 9679 0115 61 05                   		cmp	#0, r5
 9680 0117 10                      		beq	.L671
 9681                             		.loc 2 7539 13 is_stmt 0 discriminator 1
 9682 0118 ED A1 04                		mov.L	16[r10], r1
 9683 011b 05 00 00 00             		bsr	_wolfSSL_Free
 9684                             	.L671:
 9685                             	.LBE63:
 9686                             	.LBB64:
7540:../src/wolfcrypt/src/ecc.c ****             XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 9687                             		.loc 2 7540 13 is_stmt 1
 9688 011f ED A5 01                		mov.L	4[r10], r5
 9689 0122 E7 A5 05                		mov.L	r5, 20[r10]
 9690 0125 ED A5 05                		mov.L	20[r10], r5
 9691 0128 61 05                   		cmp	#0, r5
 9692 012a 10                      		beq	.L672
 9693                             		.loc 2 7540 13 is_stmt 0 discriminator 1
 9694 012b ED A1 05                		mov.L	20[r10], r1
 9695 012e 05 00 00 00             		bsr	_wolfSSL_Free
 9696                             	.L672:
 9697                             	.LBE64:
7541:../src/wolfcrypt/src/ecc.c ****             r = NULL;
 9698                             		.loc 2 7541 15 is_stmt 1
 9699 0132 F9 A6 01 00             		mov.L	#0, 4[r10]
7542:../src/wolfcrypt/src/ecc.c ****             s = NULL;
 9700                             		.loc 2 7542 15
 9701 0136 F9 A6 02 00             		mov.L	#0, 8[r10]
7543:../src/wolfcrypt/src/ecc.c ****         #endif
7544:../src/wolfcrypt/src/ecc.c ****         #endif
7545:../src/wolfcrypt/src/ecc.c **** 
7546:../src/wolfcrypt/src/ecc.c ****             if (err < 0) {
 9702                             		.loc 2 7546 16
 9703 013a EC A5                   		mov.L	[r10], r5
 9704 013c 61 05                   		cmp	#0, r5
 9705 013e 29 13                   		blt	.L676
 9706                             	.L669:
7547:../src/wolfcrypt/src/ecc.c ****                 break;
7548:../src/wolfcrypt/src/ecc.c ****             }
7549:../src/wolfcrypt/src/ecc.c ****             FALL_THROUGH;
7550:../src/wolfcrypt/src/ecc.c **** 
7551:../src/wolfcrypt/src/ecc.c ****         case ECC_STATE_VERIFY_RES:
7552:../src/wolfcrypt/src/ecc.c ****             key->state = ECC_STATE_VERIFY_RES;
 9707                             		.loc 2 7552 24
 9708 0140 A8 6D                   		mov.L	4[r6], r5
 9709 0142 3E 52 07                		mov.L	#7, 8[r5]
7553:../src/wolfcrypt/src/ecc.c ****             err = 0;
 9710                             		.loc 2 7553 17
 9711 0145 F8 A6 00                		mov.L	#0, [r10]
7554:../src/wolfcrypt/src/ecc.c ****             break;
 9712                             		.loc 2 7554 13
 9713 0148 0A                      		bra	.L670
 9714                             	.L667:
7555:../src/wolfcrypt/src/ecc.c **** 
7556:../src/wolfcrypt/src/ecc.c ****         default:
7557:../src/wolfcrypt/src/ecc.c ****             err = BAD_STATE_E;
 9715                             		.loc 2 7557 17
 9716 0149 F8 AA 40 FF             		mov.L	#-192, [r10]
 9717 014d 0D                      		bra	.L670
 9718                             	.L675:
7521:../src/wolfcrypt/src/ecc.c ****             }
 9719                             		.loc 2 7521 17
 9720 014e 03                      		nop
 9721 014f 2E 03                   		bra	.L670
 9722                             	.L676:
7547:../src/wolfcrypt/src/ecc.c ****             }
 9723                             		.loc 2 7547 17
 9724 0151 03                      		nop
 9725                             		.balign 8,3,1
 9726                             	.L670:
 9727                             	.LBB65:
7558:../src/wolfcrypt/src/ecc.c ****     }
7559:../src/wolfcrypt/src/ecc.c **** 
7560:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_ASYNC_CRYPT
7561:../src/wolfcrypt/src/ecc.c ****     /* if async pending then return and skip done cleanup below */
7562:../src/wolfcrypt/src/ecc.c ****     if (err == WC_PENDING_E) {
7563:../src/wolfcrypt/src/ecc.c ****         if (!isPrivateKeyOnly) /* do not advance state if doing make pub key */
7564:../src/wolfcrypt/src/ecc.c ****             key->state++;
7565:../src/wolfcrypt/src/ecc.c ****         return err;
7566:../src/wolfcrypt/src/ecc.c ****     }
7567:../src/wolfcrypt/src/ecc.c **** #endif
7568:../src/wolfcrypt/src/ecc.c **** 
7569:../src/wolfcrypt/src/ecc.c ****     /* cleanup */
7570:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
7571:../src/wolfcrypt/src/ecc.c ****     wc_ecc_free_async(key);
7572:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SMALL_STACK)
7573:../src/wolfcrypt/src/ecc.c ****     XFREE(s, key->heap, DYNAMIC_TYPE_ECC);
 9728                             		.loc 2 7573 5
 9729 0152 ED A5 02                		mov.L	8[r10], r5
 9730 0155 E7 A5 06                		mov.L	r5, 24[r10]
 9731 0158 ED A5 06                		mov.L	24[r10], r5
 9732 015b 61 05                   		cmp	#0, r5
 9733 015d 10                      		beq	.L673
 9734                             		.loc 2 7573 5 is_stmt 0 discriminator 1
 9735 015e ED A1 06                		mov.L	24[r10], r1
 9736 0161 05 00 00 00             		bsr	_wolfSSL_Free
 9737                             	.L673:
 9738                             	.LBE65:
 9739                             	.LBB66:
7574:../src/wolfcrypt/src/ecc.c ****     XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 9740                             		.loc 2 7574 5 is_stmt 1
 9741 0165 ED A5 01                		mov.L	4[r10], r5
 9742 0168 E7 A5 07                		mov.L	r5, 28[r10]
 9743 016b ED A5 07                		mov.L	28[r10], r5
 9744 016e 61 05                   		cmp	#0, r5
 9745 0170 10                      		beq	.L674
 9746                             		.loc 2 7574 5 is_stmt 0 discriminator 1
 9747 0171 ED A1 07                		mov.L	28[r10], r1
 9748 0174 05 00 00 00             		bsr	_wolfSSL_Free
 9749                             	.L674:
 9750                             	.LBE66:
7575:../src/wolfcrypt/src/ecc.c ****     r = NULL;
 9751                             		.loc 2 7575 7 is_stmt 1
 9752 0178 F9 A6 01 00             		mov.L	#0, 4[r10]
7576:../src/wolfcrypt/src/ecc.c ****     s = NULL;
 9753                             		.loc 2 7576 7
 9754 017c F9 A6 02 00             		mov.L	#0, 8[r10]
7577:../src/wolfcrypt/src/ecc.c **** #endif
7578:../src/wolfcrypt/src/ecc.c **** 
7579:../src/wolfcrypt/src/ecc.c ****     /* make sure required variables are reset */
7580:../src/wolfcrypt/src/ecc.c ****     wc_ecc_reset(key);
 9755                             		.loc 2 7580 5
 9756 0180 A8 69                   		mov.L	4[r6], r1
 9757 0182 05 00 00 00             		bsr	_wc_ecc_reset
7581:../src/wolfcrypt/src/ecc.c **** #else
7582:../src/wolfcrypt/src/ecc.c ****     (void)siglen;
7583:../src/wolfcrypt/src/ecc.c ****     (void)hashlen;
7584:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_SMALL_STACK
7585:../src/wolfcrypt/src/ecc.c ****     (void)s_lcl;
7586:../src/wolfcrypt/src/ecc.c ****     (void)r_lcl;
7587:../src/wolfcrypt/src/ecc.c ****     #endif
7588:../src/wolfcrypt/src/ecc.c ****     (void)s;
7589:../src/wolfcrypt/src/ecc.c ****     (void)r;
7590:../src/wolfcrypt/src/ecc.c ****     (void)err;
7591:../src/wolfcrypt/src/ecc.c **** #endif /* WOLF_CRYPTO_CB_ONLY_ECC */
7592:../src/wolfcrypt/src/ecc.c **** 
7593:../src/wolfcrypt/src/ecc.c ****     return err;
 9758                             		.loc 2 7593 12
 9759 0186 EC A5                   		mov.L	[r10], r5
 9760                             		.balign 8,3,1
 9761                             	.L661:
7594:../src/wolfcrypt/src/ecc.c **** }
 9762                             		.loc 2 7594 1
 9763 0188 EF 51                   		mov.L	r5, r1
 9764 018a 71 00 40                		add	#0x40, r0
 9765 018d 7E B6                   		pop	r6
 9766 018f 7E BA                   		pop	r10
 9767 0191 02                      		rts
 9768                             	.LFE109:
 9770 0192 74 10 01 00 00 00       		.section	.text.wc_ecc_check_r_s_range,"ax",@progbits
 9772                             	_wc_ecc_check_r_s_range:
 9773                             	.LFB110:
7595:../src/wolfcrypt/src/ecc.c **** #endif /* !NO_ASN */
7596:../src/wolfcrypt/src/ecc.c **** 
7597:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_STM32_PKA) && !defined(WOLFSSL_PSOC6_CRYPTO) && \
7598:../src/wolfcrypt/src/ecc.c ****     !defined(WOLF_CRYPTO_CB_ONLY_ECC)
7599:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_check_r_s_range(ecc_key* key, mp_int* r, mp_int* s)
7600:../src/wolfcrypt/src/ecc.c **** {
 9774                             		.loc 2 7600 1
 9775 0000 7E AA                   		push.l	r10
 9776                             	.LCFI173:
 9777 0002 71 0A B8                		add	#-72, r0, r10
 9778                             	.LCFI174:
 9779 0005 EF A0                   		mov.L	r10, r0
 9780 0007 E7 A1 0F                		mov.L	r1, 60[r10]
 9781 000a E7 A2 10                		mov.L	r2, 64[r10]
 9782 000d E7 A3 11                		mov.L	r3, 68[r10]
7601:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 9783                             		.loc 2 7601 9
 9784 0010 F8 A6 00                		mov.L	#0, [r10]
7602:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(1);
 9785                             		.loc 2 7602 5
 9786 0013 F9 A6 01 00             		mov.L	#0, 4[r10]
 9787 0017 71 A5 10                		add	#16, r10, r5
 9788 001a E7 A5 0E                		mov.L	r5, 56[r10]
 9789 001d ED A5 0E                		mov.L	56[r10], r5
 9790 0020 75 43 28                		mov.L	#40, r3
 9791 0023 66 02                   		mov.L	#0, r2
 9792 0025 EF 51                   		mov.L	r5, r1
 9793 0027 05 00 00 00             		bsr	_memset
 9794 002b ED A5 0E                		mov.L	56[r10], r5
 9795 002e 3E 57 01                		mov.L	#1, 28[r5]
7603:../src/wolfcrypt/src/ecc.c **** 
7604:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(1, err);
 9796                             		.loc 2 7604 5
 9797 0031 FB 1A 10 03             		mov.L	#0x310, r1
 9798 0035 05 00 00 00             		bsr	_wolfSSL_Malloc
 9799 0039 E7 A1 01                		mov.L	r1, 4[r10]
 9800 003c ED A5 01                		mov.L	4[r10], r5
 9801 003f 61 05                   		cmp	#0, r5
 9802 0041 1D                      		bne	.L678
 9803                             		.loc 2 7604 5 is_stmt 0 discriminator 1
 9804 0042 F8 A6 83                		mov.L	#-125, [r10]
 9805 0045 09                      		bra	.L679
 9806                             	.L678:
 9807                             		.loc 2 7604 5 discriminator 2
 9808 0046 ED A5 0E                		mov.L	56[r10], r5
 9809 0049 ED A4 01                		mov.L	4[r10], r4
 9810 004c A1 D4                   		mov.L	r4, 24[r5]
 9811                             	.L679:
7605:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 9812                             		.loc 2 7605 8 is_stmt 1
 9813 004e EC A5                   		mov.L	[r10], r5
 9814 0050 61 05                   		cmp	#0, r5
 9815 0052 21 16                   		bne	.L680
7606:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
 9816                             		.loc 2 7606 15
 9817 0054 ED A5 0F                		mov.L	60[r10], r5
 9818 0057 A9 54                   		mov.L	16[r5], r4
 9819 0059 71 A5 38                		add	#56, r10, r5
 9820 005c 66 83                   		mov	#8, r3
 9821 005e EF 52                   		mov.L	r5, r2
 9822 0060 EF 41                   		mov.L	r4, r1
 9823 0062 05 00 00 00             		bsr	_wc_ecc_curve_load
 9824 0066 E3 A1                   		mov.L	r1, [r10]
 9825                             	.L680:
7607:../src/wolfcrypt/src/ecc.c ****     }
7608:../src/wolfcrypt/src/ecc.c ****     if (err != 0) {
 9826                             		.loc 2 7608 8
 9827 0068 EC A5                   		mov.L	[r10], r5
 9828 006a 61 05                   		cmp	#0, r5
 9829 006c 20 19                   		beq	.L681
 9830                             	.LBB67:
7609:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
 9831                             		.loc 2 7609 9
 9832 006e ED A5 01                		mov.L	4[r10], r5
 9833 0071 E7 A5 02                		mov.L	r5, 8[r10]
 9834 0074 ED A5 02                		mov.L	8[r10], r5
 9835 0077 61 05                   		cmp	#0, r5
 9836 0079 10                      		beq	.L682
 9837                             		.loc 2 7609 9 is_stmt 0 discriminator 1
 9838 007a ED A1 02                		mov.L	8[r10], r1
 9839 007d 05 00 00 00             		bsr	_wolfSSL_Free
 9840                             	.L682:
 9841                             	.LBE67:
7610:../src/wolfcrypt/src/ecc.c ****         return err;
 9842                             		.loc 2 7610 16 is_stmt 1
 9843 0081 EC A5                   		mov.L	[r10], r5
 9844 0083 2E 6D                   		bra	.L689
 9845                             	.L681:
7611:../src/wolfcrypt/src/ecc.c ****     }
7612:../src/wolfcrypt/src/ecc.c **** 
7613:../src/wolfcrypt/src/ecc.c ****     if (mp_iszero(r) || mp_iszero(s)) {
 9846                             		.loc 2 7613 9
 9847 0085 ED A5 10                		mov.L	64[r10], r5
 9848 0088 EC 55                   		mov.L	[r5], r5
 9849                             		.loc 2 7613 8
 9850 008a 61 05                   		cmp	#0, r5
 9851 008c 11                      		beq	.L684
 9852                             		.loc 2 7613 25 discriminator 1
 9853 008d ED A5 11                		mov.L	68[r10], r5
 9854 0090 EC 55                   		mov.L	[r5], r5
 9855                             		.loc 2 7613 22 discriminator 1
 9856 0092 61 05                   		cmp	#0, r5
 9857 0094 1C                      		bne	.L685
 9858                             	.L684:
7614:../src/wolfcrypt/src/ecc.c ****         err = MP_ZERO_E;
 9859                             		.loc 2 7614 13
 9860 0095 F8 A6 87                		mov.L	#-121, [r10]
 9861                             	.L685:
7615:../src/wolfcrypt/src/ecc.c ****     }
7616:../src/wolfcrypt/src/ecc.c ****     if ((err == 0) && (mp_cmp(r, curve->order) != MP_LT)) {
 9862                             		.loc 2 7616 8
 9863 0098 EC A5                   		mov.L	[r10], r5
 9864 009a 61 05                   		cmp	#0, r5
 9865 009c 21 19                   		bne	.L686
 9866                             		.loc 2 7616 39 discriminator 1
 9867 009e ED A5 0E                		mov.L	56[r10], r5
 9868 00a1 A8 DD                   		mov.L	12[r5], r5
 9869                             		.loc 2 7616 24 discriminator 1
 9870 00a3 EF 52                   		mov.L	r5, r2
 9871 00a5 ED A1 10                		mov.L	64[r10], r1
 9872 00a8 05 00 00 00             		bsr	_sp_cmp
 9873 00ac EF 15                   		mov.L	r1, r5
 9874                             		.loc 2 7616 20 discriminator 1
 9875 00ae 75 05 FF                		cmp	#-1, r5
 9876 00b1 14                      		beq	.L686
7617:../src/wolfcrypt/src/ecc.c ****         err = MP_VAL;
 9877                             		.loc 2 7617 13
 9878 00b2 F8 A6 FD                		mov.L	#-3, [r10]
 9879                             	.L686:
7618:../src/wolfcrypt/src/ecc.c ****     }
7619:../src/wolfcrypt/src/ecc.c ****     if ((err == 0) && (mp_cmp(s, curve->order) != MP_LT)) {
 9880                             		.loc 2 7619 8
 9881 00b5 EC A5                   		mov.L	[r10], r5
 9882 00b7 61 05                   		cmp	#0, r5
 9883 00b9 21 19                   		bne	.L687
 9884                             		.loc 2 7619 39 discriminator 1
 9885 00bb ED A5 0E                		mov.L	56[r10], r5
 9886 00be A8 DD                   		mov.L	12[r5], r5
 9887                             		.loc 2 7619 24 discriminator 1
 9888 00c0 EF 52                   		mov.L	r5, r2
 9889 00c2 ED A1 11                		mov.L	68[r10], r1
 9890 00c5 05 00 00 00             		bsr	_sp_cmp
 9891 00c9 EF 15                   		mov.L	r1, r5
 9892                             		.loc 2 7619 20 discriminator 1
 9893 00cb 75 05 FF                		cmp	#-1, r5
 9894 00ce 14                      		beq	.L687
7620:../src/wolfcrypt/src/ecc.c ****         err = MP_VAL;
 9895                             		.loc 2 7620 13
 9896 00cf F8 A6 FD                		mov.L	#-3, [r10]
 9897                             	.L687:
7621:../src/wolfcrypt/src/ecc.c ****     }
7622:../src/wolfcrypt/src/ecc.c **** 
7623:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
 9898                             		.loc 2 7623 5
 9899 00d2 ED A5 0E                		mov.L	56[r10], r5
 9900 00d5 EF 51                   		mov.L	r5, r1
 9901 00d7 05 00 00 00             		bsr	_wc_ecc_curve_free
 9902                             	.LBB68:
7624:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
 9903                             		.loc 2 7624 5
 9904 00db ED A5 01                		mov.L	4[r10], r5
 9905 00de E7 A5 03                		mov.L	r5, 12[r10]
 9906 00e1 ED A5 03                		mov.L	12[r10], r5
 9907 00e4 61 05                   		cmp	#0, r5
 9908 00e6 10                      		beq	.L688
 9909                             		.loc 2 7624 5 is_stmt 0 discriminator 1
 9910 00e7 ED A1 03                		mov.L	12[r10], r1
 9911 00ea 05 00 00 00             		bsr	_wolfSSL_Free
 9912                             	.L688:
 9913                             	.LBE68:
7625:../src/wolfcrypt/src/ecc.c ****     return err;
 9914                             		.loc 2 7625 12 is_stmt 1
 9915 00ee EC A5                   		mov.L	[r10], r5
 9916                             	.L689:
7626:../src/wolfcrypt/src/ecc.c **** }
 9917                             		.loc 2 7626 1 discriminator 1
 9918 00f0 EF 51                   		mov.L	r5, r1
 9919 00f2 3F AA 13                		rtsd	#76, r10-r10
 9920                             	.LFE110:
 9922                             		.section C,"a",@progbits
 9923 0a85 00 00 00                		.p2align 2
 9924                             	.LC42:
 9925 0a88 56 65 72 69 66 79 20 63 		.string	"Verify called with private key, generating public part"
 9925      61 6C 6C 65 64 20 77 69 
 9925      74 68 20 70 72 69 76 61 
 9925      74 65 20 6B 65 79 2C 20 
 9925      67 65 6E 65 72 61 74 69 
 9926                             	.LC43:
 9927 0abf 55 6E 61 62 6C 65 20 74 		.string	"Unable to extract public key"
 9927      6F 20 65 78 74 72 61 63 
 9927      74 20 70 75 62 6C 69 63 
 9927      20 6B 65 79 00 
 9928                             		.section	.text.wc_ecc_verify_hash_ex,"ax",@progbits
 9929                             		.global	_wc_ecc_verify_hash_ex
 9931                             	_wc_ecc_verify_hash_ex:
 9932                             	.LFB111:
7627:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_STM32_PKA && !WOLFSSL_PSOC6_CRYPTO */
7628:../src/wolfcrypt/src/ecc.c **** 
7629:../src/wolfcrypt/src/ecc.c **** 
7630:../src/wolfcrypt/src/ecc.c **** /**
7631:../src/wolfcrypt/src/ecc.c ****    Verify an ECC signature
7632:../src/wolfcrypt/src/ecc.c ****    r           The signature R component to verify
7633:../src/wolfcrypt/src/ecc.c ****    s           The signature S component to verify
7634:../src/wolfcrypt/src/ecc.c ****    hash        The hash (message digest) that was signed
7635:../src/wolfcrypt/src/ecc.c ****    hashlen     The length of the hash (octets)
7636:../src/wolfcrypt/src/ecc.c ****    res         Result of signature, 1==valid, 0==invalid
7637:../src/wolfcrypt/src/ecc.c ****    key         The corresponding public ECC key
7638:../src/wolfcrypt/src/ecc.c ****    return      MP_OKAY if successful (even if the signature is not valid)
7639:../src/wolfcrypt/src/ecc.c **** */
7640:../src/wolfcrypt/src/ecc.c **** #ifndef WOLF_CRYPTO_CB_ONLY_ECC
7641:../src/wolfcrypt/src/ecc.c **** int wc_ecc_verify_hash_ex(mp_int *r, mp_int *s, const byte* hash,
7642:../src/wolfcrypt/src/ecc.c ****                     word32 hashlen, int* res, ecc_key* key)
7643:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_STM32_PKA)
7644:../src/wolfcrypt/src/ecc.c **** {
7645:../src/wolfcrypt/src/ecc.c ****     return stm32_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
7646:../src/wolfcrypt/src/ecc.c **** }
7647:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_PSOC6_CRYPTO)
7648:../src/wolfcrypt/src/ecc.c **** {
7649:../src/wolfcrypt/src/ecc.c ****     return psoc6_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
7650:../src/wolfcrypt/src/ecc.c **** }
7651:../src/wolfcrypt/src/ecc.c **** #else
7652:../src/wolfcrypt/src/ecc.c **** {
 9933                             		.loc 2 7652 1
 9934 0000 6E 6B                   		pushm	r6-r11
 9935                             	.LCFI175:
 9936 0002 72 0A 64 FF             		add	#-156, r0, r10
 9937                             	.LCFI176:
 9938 0006 71 A0 F4                		add	#-12, r10, r0
 9939                             	.LCFI177:
 9940 0009 75 46 B8                		mov.L	#0xb8, r6
 9941 000c 4B A6                   		add	r10, r6
 9942 000e E7 A1 21                		mov.L	r1, 132[r10]
 9943 0011 E7 A2 22                		mov.L	r2, 136[r10]
 9944 0014 E7 A3 23                		mov.L	r3, 140[r10]
 9945 0017 E7 A4 24                		mov.L	r4, 144[r10]
7653:../src/wolfcrypt/src/ecc.c ****    int           err;
7654:../src/wolfcrypt/src/ecc.c ****    word32        keySz = 0;
 9946                             		.loc 2 7654 18
 9947 001a F9 A6 06 00             		mov.L	#0, 24[r10]
7655:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
7656:../src/wolfcrypt/src/ecc.c ****    byte sigRS[ATECC_KEY_SIZE*2];
7657:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CRYPTOCELL)
7658:../src/wolfcrypt/src/ecc.c ****    byte sigRS[ECC_MAX_CRYPTO_HW_SIZE*2];
7659:../src/wolfcrypt/src/ecc.c ****    CRYS_ECDSA_VerifyUserContext_t sigCtxTemp;
7660:../src/wolfcrypt/src/ecc.c ****    word32 msgLenInBytes = hashlen;
7661:../src/wolfcrypt/src/ecc.c ****    CRYS_ECPKI_HASH_OpMode_t hash_mode;
7662:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
7663:../src/wolfcrypt/src/ecc.c ****    byte sigRS[ECC_MAX_CRYPTO_HW_SIZE * 2];
7664:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_KCAPI_ECC)
7665:../src/wolfcrypt/src/ecc.c ****    byte sigRS[MAX_ECC_BYTES*2];
7666:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SE050)
7667:../src/wolfcrypt/src/ecc.c ****    byte sigRS[ECC_MAX_CRYPTO_HW_SIZE * 2];
7668:../src/wolfcrypt/src/ecc.c **** #elif !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)
7669:../src/wolfcrypt/src/ecc.c ****    int          did_init = 0;
 9948                             		.loc 2 7669 17
 9949 001e F9 A6 01 00             		mov.L	#0, 4[r10]
7670:../src/wolfcrypt/src/ecc.c ****    ecc_point    *mG = NULL, *mQ = NULL;
 9950                             		.loc 2 7670 18
 9951 0022 F9 A6 13 00             		mov.L	#0, 76[r10]
 9952                             		.loc 2 7670 30
 9953 0026 F9 A6 14 00             		mov.L	#0, 80[r10]
7671:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_NO_MALLOC
7672:../src/wolfcrypt/src/ecc.c ****    ecc_point    lcl_mG, lcl_mQ;
7673:../src/wolfcrypt/src/ecc.c ****    #endif
7674:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_SMALL_STACK
7675:../src/wolfcrypt/src/ecc.c ****    mp_int*       v = NULL;
 9954                             		.loc 2 7675 18
 9955 002a F9 A6 02 00             		mov.L	#0, 8[r10]
7676:../src/wolfcrypt/src/ecc.c ****    mp_int*       w = NULL;
 9956                             		.loc 2 7676 18
 9957 002e F9 A6 03 00             		mov.L	#0, 12[r10]
7677:../src/wolfcrypt/src/ecc.c ****    mp_int*       u1 = NULL;
 9958                             		.loc 2 7677 18
 9959 0032 F9 A6 04 00             		mov.L	#0, 16[r10]
7678:../src/wolfcrypt/src/ecc.c ****    mp_int*       u2 = NULL;
 9960                             		.loc 2 7678 18
 9961 0036 F9 A6 05 00             		mov.L	#0, 20[r10]
7679:../src/wolfcrypt/src/ecc.c ****       #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
7680:../src/wolfcrypt/src/ecc.c ****    mp_int*       e_lcl = NULL;
 9962                             		.loc 2 7680 18
 9963 003a F9 A6 07 00             		mov.L	#0, 28[r10]
7681:../src/wolfcrypt/src/ecc.c ****       #endif
7682:../src/wolfcrypt/src/ecc.c ****    #else /* WOLFSSL_SMALL_STACK */
7683:../src/wolfcrypt/src/ecc.c ****    mp_int        v[1];
7684:../src/wolfcrypt/src/ecc.c ****    mp_int        w[1];
7685:../src/wolfcrypt/src/ecc.c ****    mp_int        u1[1];
7686:../src/wolfcrypt/src/ecc.c ****    mp_int        u2[1];
7687:../src/wolfcrypt/src/ecc.c ****       #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
7688:../src/wolfcrypt/src/ecc.c ****    mp_int        e_lcl[1];
7689:../src/wolfcrypt/src/ecc.c ****       #endif
7690:../src/wolfcrypt/src/ecc.c ****    #endif /* WOLFSSL_SMALL_STACK */
7691:../src/wolfcrypt/src/ecc.c ****    mp_int*       e;
7692:../src/wolfcrypt/src/ecc.c ****    DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
 9964                             		.loc 2 7692 4
 9965 003e F9 A6 08 00             		mov.L	#0, 32[r10]
 9966 0042 71 A5 54                		add	#0x54, r10, r5
 9967 0045 E7 A5 1F                		mov.L	r5, 124[r10]
 9968 0048 ED A5 1F                		mov.L	124[r10], r5
 9969 004b 75 43 28                		mov.L	#40, r3
 9970 004e 66 02                   		mov.L	#0, r2
 9971 0050 EF 51                   		mov.L	r5, r1
 9972 0052 05 00 00 00             		bsr	_memset
 9973 0056 ED A5 1F                		mov.L	124[r10], r5
 9974 0059 3E 57 05                		mov.L	#5, 28[r5]
7693:../src/wolfcrypt/src/ecc.c **** #endif
7694:../src/wolfcrypt/src/ecc.c **** 
7695:../src/wolfcrypt/src/ecc.c ****    if (r == NULL || s == NULL || hash == NULL || res == NULL || key == NULL)
 9975                             		.loc 2 7695 7
 9976 005c ED A5 21                		mov.L	132[r10], r5
 9977 005f 61 05                   		cmp	#0, r5
 9978 0061 20 1A                   		beq	.L691
 9979                             		.loc 2 7695 18 discriminator 1
 9980 0063 ED A5 22                		mov.L	136[r10], r5
 9981 0066 61 05                   		cmp	#0, r5
 9982 0068 20 13                   		beq	.L691
 9983                             		.loc 2 7695 31 discriminator 2
 9984 006a ED A5 23                		mov.L	140[r10], r5
 9985 006d 61 05                   		cmp	#0, r5
 9986 006f 20 0C                   		beq	.L691
 9987                             		.loc 2 7695 47 discriminator 3
 9988 0071 EC 65                   		mov.L	[r6], r5
 9989 0073 61 05                   		cmp	#0, r5
 9990 0075 16                      		beq	.L691
 9991                             		.loc 2 7695 62 discriminator 4
 9992 0076 A8 6D                   		mov.L	4[r6], r5
 9993 0078 61 05                   		cmp	#0, r5
 9994 007a 18                      		bne	.L692
 9995                             		.balign 8,3,2
 9996                             	.L691:
7696:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
 9997                             		.loc 2 7696 15
 9998 007b FB 5A 56 FF             		mov.L	#-170, r5
 9999 007f 38 1D 05                		bra	.L740
 10000                             	.L692:
7697:../src/wolfcrypt/src/ecc.c **** 
7698:../src/wolfcrypt/src/ecc.c ****    /* default to invalid signature */
7699:../src/wolfcrypt/src/ecc.c ****    *res = 0;
 10001                             		.loc 2 7699 9
 10002 0082 EC 65                   		mov.L	[r6], r5
 10003 0084 F8 56 00                		mov.L	#0, [r5]
7700:../src/wolfcrypt/src/ecc.c **** 
7701:../src/wolfcrypt/src/ecc.c ****    /* is the IDX valid ?  */
7702:../src/wolfcrypt/src/ecc.c ****    if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {
 10004                             		.loc 2 7702 8
 10005 0087 A8 6D                   		mov.L	4[r6], r5
 10006 0089 A8 5D                   		mov.L	4[r5], r5
 10007 008b EF 51                   		mov.L	r5, r1
 10008 008d 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 10009 0091 EF 15                   		mov.L	r1, r5
 10010                             		.loc 2 7702 7
 10011 0093 61 05                   		cmp	#0, r5
 10012 0095 10                      		beq	.L694
 10013                             		.loc 2 7702 49 discriminator 1
 10014 0096 A8 6D                   		mov.L	4[r6], r5
 10015 0098 A9 55                   		mov.L	16[r5], r5
 10016                             		.loc 2 7702 43 discriminator 1
 10017 009a 61 05                   		cmp	#0, r5
 10018 009c 18                      		bne	.L695
 10019                             	.L694:
7703:../src/wolfcrypt/src/ecc.c ****       return ECC_BAD_ARG_E;
 10020                             		.loc 2 7703 14
 10021 009d FB 5A 56 FF             		mov.L	#-170, r5
 10022 00a1 38 FB 04                		bra	.L740
 10023                             	.L695:
7704:../src/wolfcrypt/src/ecc.c ****    }
7705:../src/wolfcrypt/src/ecc.c **** 
7706:../src/wolfcrypt/src/ecc.c ****    err = wc_ecc_check_r_s_range(key, r, s);
 10024                             		.loc 2 7706 10
 10025 00a4 ED A3 22                		mov.L	136[r10], r3
 10026 00a7 ED A2 21                		mov.L	132[r10], r2
 10027 00aa A8 69                   		mov.L	4[r6], r1
 10028 00ac 05 00 00 00             		bsr	_wc_ecc_check_r_s_range
 10029 00b0 E3 A1                   		mov.L	r1, [r10]
7707:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY) {
 10030                             		.loc 2 7707 7
 10031 00b2 EC A5                   		mov.L	[r10], r5
 10032 00b4 61 05                   		cmp	#0, r5
 10033 00b6 16                      		beq	.L696
7708:../src/wolfcrypt/src/ecc.c ****       return err;
 10034                             		.loc 2 7708 14
 10035 00b7 EC A5                   		mov.L	[r10], r5
 10036 00b9 38 E3 04                		bra	.L740
 10037                             	.L696:
7709:../src/wolfcrypt/src/ecc.c ****    }
7710:../src/wolfcrypt/src/ecc.c **** 
7711:../src/wolfcrypt/src/ecc.c ****    keySz = key->dp->size;
 10038                             		.loc 2 7711 15
 10039 00bc A8 6D                   		mov.L	4[r6], r5
 10040 00be A9 55                   		mov.L	16[r5], r5
 10041                             		.loc 2 7711 19
 10042 00c0 EC 55                   		mov.L	[r5], r5
 10043                             		.loc 2 7711 10
 10044 00c2 E7 A5 06                		mov.L	r5, 24[r10]
7712:../src/wolfcrypt/src/ecc.c **** 
7713:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC) && \
7714:../src/wolfcrypt/src/ecc.c ****        defined(WOLFSSL_ASYNC_CRYPT_TEST)
7715:../src/wolfcrypt/src/ecc.c ****     if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
7716:../src/wolfcrypt/src/ecc.c ****         if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_ECC_VERIFY)) {
7717:../src/wolfcrypt/src/ecc.c ****             WC_ASYNC_TEST* testDev = &key->asyncDev.test;
7718:../src/wolfcrypt/src/ecc.c ****             testDev->eccVerify.r = r;
7719:../src/wolfcrypt/src/ecc.c ****             testDev->eccVerify.s = s;
7720:../src/wolfcrypt/src/ecc.c ****             testDev->eccVerify.hash = hash;
7721:../src/wolfcrypt/src/ecc.c ****             testDev->eccVerify.hashlen = hashlen;
7722:../src/wolfcrypt/src/ecc.c ****             testDev->eccVerify.stat = res;
7723:../src/wolfcrypt/src/ecc.c ****             testDev->eccVerify.key = key;
7724:../src/wolfcrypt/src/ecc.c ****             return WC_PENDING_E;
7725:../src/wolfcrypt/src/ecc.c ****         }
7726:../src/wolfcrypt/src/ecc.c ****     }
7727:../src/wolfcrypt/src/ecc.c **** #endif
7728:../src/wolfcrypt/src/ecc.c **** 
7729:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A) || \
7730:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_CRYPTOCELL) || defined(WOLFSSL_SILABS_SE_ACCEL) || \
7731:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_KCAPI_ECC) || defined(WOLFSSL_SE050)
7732:../src/wolfcrypt/src/ecc.c **** 
7733:../src/wolfcrypt/src/ecc.c ****     /* Extract R and S with front zero padding (if required) */
7734:../src/wolfcrypt/src/ecc.c ****     XMEMSET(sigRS, 0, keySz * 2);
7735:../src/wolfcrypt/src/ecc.c ****     err = mp_to_unsigned_bin(r, sigRS +
7736:../src/wolfcrypt/src/ecc.c ****                                 (keySz - mp_unsigned_bin_size(r)));
7737:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY) {
7738:../src/wolfcrypt/src/ecc.c ****         return err;
7739:../src/wolfcrypt/src/ecc.c ****     }
7740:../src/wolfcrypt/src/ecc.c ****     err = mp_to_unsigned_bin(s, sigRS + keySz +
7741:../src/wolfcrypt/src/ecc.c ****                                 (keySz - mp_unsigned_bin_size(s)));
7742:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY) {
7743:../src/wolfcrypt/src/ecc.c ****         return err;
7744:../src/wolfcrypt/src/ecc.c ****     }
7745:../src/wolfcrypt/src/ecc.c **** 
7746:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
7747:../src/wolfcrypt/src/ecc.c ****     err = atmel_ecc_verify(hash, sigRS, key->pubkey_raw, res);
7748:../src/wolfcrypt/src/ecc.c ****     if (err != 0) {
7749:../src/wolfcrypt/src/ecc.c ****        return err;
7750:../src/wolfcrypt/src/ecc.c ****     }
7751:../src/wolfcrypt/src/ecc.c ****     (void)hashlen;
7752:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CRYPTOCELL)
7753:../src/wolfcrypt/src/ecc.c **** 
7754:../src/wolfcrypt/src/ecc.c ****    /* truncate if hash is longer than key size */
7755:../src/wolfcrypt/src/ecc.c ****    if (msgLenInBytes > keySz) {
7756:../src/wolfcrypt/src/ecc.c ****        msgLenInBytes = keySz;
7757:../src/wolfcrypt/src/ecc.c ****    }
7758:../src/wolfcrypt/src/ecc.c ****    hash_mode = cc310_hashModeECC(msgLenInBytes);
7759:../src/wolfcrypt/src/ecc.c ****    if (hash_mode == CRYS_ECPKI_HASH_OpModeLast) {
7760:../src/wolfcrypt/src/ecc.c ****        /* hash_mode = */ cc310_hashModeECC(keySz);
7761:../src/wolfcrypt/src/ecc.c ****        hash_mode = CRYS_ECPKI_HASH_SHA256_mode;
7762:../src/wolfcrypt/src/ecc.c ****    }
7763:../src/wolfcrypt/src/ecc.c **** 
7764:../src/wolfcrypt/src/ecc.c ****    /* verify the signature using the public key */
7765:../src/wolfcrypt/src/ecc.c ****    err = CRYS_ECDSA_Verify(&sigCtxTemp,
7766:../src/wolfcrypt/src/ecc.c ****                            &key->ctx.pubKey,
7767:../src/wolfcrypt/src/ecc.c ****                            hash_mode,
7768:../src/wolfcrypt/src/ecc.c ****                            &sigRS[0],
7769:../src/wolfcrypt/src/ecc.c ****                            keySz*2,
7770:../src/wolfcrypt/src/ecc.c ****                            (byte*)hash,
7771:../src/wolfcrypt/src/ecc.c ****                            msgLenInBytes);
7772:../src/wolfcrypt/src/ecc.c **** 
7773:../src/wolfcrypt/src/ecc.c ****    if (err != SA_SILIB_RET_OK) {
7774:../src/wolfcrypt/src/ecc.c ****        WOLFSSL_MSG("CRYS_ECDSA_Verify failed");
7775:../src/wolfcrypt/src/ecc.c ****        return err;
7776:../src/wolfcrypt/src/ecc.c ****    }
7777:../src/wolfcrypt/src/ecc.c ****    /* valid signature if we get to this point */
7778:../src/wolfcrypt/src/ecc.c ****    *res = 1;
7779:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
7780:../src/wolfcrypt/src/ecc.c ****    err = silabs_ecc_verify_hash(&sigRS[0], keySz * 2,
7781:../src/wolfcrypt/src/ecc.c ****                                 hash, hashlen,
7782:../src/wolfcrypt/src/ecc.c ****                                 res, key);
7783:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_KCAPI_ECC)
7784:../src/wolfcrypt/src/ecc.c ****     err = KcapiEcc_Verify(key, hash, hashlen, sigRS, keySz * 2);
7785:../src/wolfcrypt/src/ecc.c ****     if (err == 0) {
7786:../src/wolfcrypt/src/ecc.c ****         *res = 1;
7787:../src/wolfcrypt/src/ecc.c ****     }
7788:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SE050)
7789:../src/wolfcrypt/src/ecc.c ****     err = se050_ecc_verify_hash_ex(hash, hashlen, sigRS, keySz * 2, key, res);
7790:../src/wolfcrypt/src/ecc.c **** #endif
7791:../src/wolfcrypt/src/ecc.c **** 
7792:../src/wolfcrypt/src/ecc.c **** #else
7793:../src/wolfcrypt/src/ecc.c ****   /* checking if private key with no public part */
7794:../src/wolfcrypt/src/ecc.c ****   if (key->type == ECC_PRIVATEKEY_ONLY) {
 10045                             		.loc 2 7794 10
 10046 00c5 A8 6D                   		mov.L	4[r6], r5
 10047 00c7 EC 55                   		mov.L	[r5], r5
 10048                             		.loc 2 7794 6
 10049 00c9 61 35                   		cmp	#3, r5
 10050 00cb 21 2F                   		bne	.L697
7795:../src/wolfcrypt/src/ecc.c ****       WOLFSSL_MSG("Verify called with private key, generating public part");
 10051                             		.loc 2 7795 7
 10052 00cd FB 12 88 0A 00 00       		mov.L	#.LC42, r1
 10053 00d3 05 00 00 00             		bsr	_WOLFSSL_MSG
7796:../src/wolfcrypt/src/ecc.c ****       err = ecc_make_pub_ex(key, NULL, NULL, NULL);
 10054                             		.loc 2 7796 13
 10055 00d7 66 04                   		mov.L	#0, r4
 10056 00d9 66 03                   		mov.L	#0, r3
 10057 00db 66 02                   		mov.L	#0, r2
 10058 00dd A8 69                   		mov.L	4[r6], r1
 10059 00df 05 00 00 00             		bsr	_ecc_make_pub_ex
 10060 00e3 E3 A1                   		mov.L	r1, [r10]
7797:../src/wolfcrypt/src/ecc.c ****       if (err != MP_OKAY) {
 10061                             		.loc 2 7797 10
 10062 00e5 EC A5                   		mov.L	[r10], r5
 10063 00e7 61 05                   		cmp	#0, r5
 10064 00e9 20 11                   		beq	.L697
7798:../src/wolfcrypt/src/ecc.c ****            WOLFSSL_MSG("Unable to extract public key");
 10065                             		.loc 2 7798 12
 10066 00eb FB 12 BF 0A 00 00       		mov.L	#.LC43, r1
 10067 00f1 05 00 00 00             		bsr	_WOLFSSL_MSG
7799:../src/wolfcrypt/src/ecc.c ****            return err;
 10068                             		.loc 2 7799 19
 10069 00f5 EC A5                   		mov.L	[r10], r5
 10070 00f7 38 A5 04                		bra	.L740
 10071                             	.L697:
7800:../src/wolfcrypt/src/ecc.c ****       }
7801:../src/wolfcrypt/src/ecc.c ****   }
7802:../src/wolfcrypt/src/ecc.c **** 
7803:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_DSP) && !defined(FREESCALE_LTC_ECC)
7804:../src/wolfcrypt/src/ecc.c ****   if (key->handle != -1) {
7805:../src/wolfcrypt/src/ecc.c ****       return sp_dsp_ecc_verify_256(key->handle, hash, hashlen, key->pubkey.x,
7806:../src/wolfcrypt/src/ecc.c ****         key->pubkey.y, key->pubkey.z, r, s, res, key->heap);
7807:../src/wolfcrypt/src/ecc.c ****   }
7808:../src/wolfcrypt/src/ecc.c ****   if (wolfSSL_GetHandleCbSet() == 1) {
7809:../src/wolfcrypt/src/ecc.c ****       return sp_dsp_ecc_verify_256(0, hash, hashlen, key->pubkey.x,
7810:../src/wolfcrypt/src/ecc.c ****         key->pubkey.y, key->pubkey.z, r, s, res, key->heap);
7811:../src/wolfcrypt/src/ecc.c ****   }
7812:../src/wolfcrypt/src/ecc.c **** #endif
7813:../src/wolfcrypt/src/ecc.c **** 
7814:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_SP_MATH) && !defined(FREESCALE_LTC_ECC)
7815:../src/wolfcrypt/src/ecc.c ****     if (key->idx == ECC_CUSTOM_IDX || (1
7816:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_SP_NO_256
7817:../src/wolfcrypt/src/ecc.c ****          && ecc_sets[key->idx].id != ECC_SECP256R1
7818:../src/wolfcrypt/src/ecc.c ****     #endif
7819:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_384
7820:../src/wolfcrypt/src/ecc.c ****          && ecc_sets[key->idx].id != ECC_SECP384R1
7821:../src/wolfcrypt/src/ecc.c ****     #endif
7822:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_521
7823:../src/wolfcrypt/src/ecc.c ****          && ecc_sets[key->idx].id != ECC_SECP521R1
7824:../src/wolfcrypt/src/ecc.c ****     #endif
7825:../src/wolfcrypt/src/ecc.c ****         )) {
7826:../src/wolfcrypt/src/ecc.c ****         return WC_KEY_SIZE_E;
7827:../src/wolfcrypt/src/ecc.c ****     }
7828:../src/wolfcrypt/src/ecc.c **** #endif
7829:../src/wolfcrypt/src/ecc.c **** 
7830:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_HAVE_SP_ECC)
7831:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX
7832:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
7833:../src/wolfcrypt/src/ecc.c ****         && key->asyncDev.marker != WOLFSSL_ASYNC_MARKER_ECC
7834:../src/wolfcrypt/src/ecc.c ****     #endif
7835:../src/wolfcrypt/src/ecc.c ****     ) {
7836:../src/wolfcrypt/src/ecc.c ****     #if defined(WC_ECC_NONBLOCK) && defined(WC_ECC_NONBLOCK_ONLY)
7837:../src/wolfcrypt/src/ecc.c ****         /* perform blocking call to non-blocking function */
7838:../src/wolfcrypt/src/ecc.c ****         ecc_nb_ctx_t nb_ctx;
7839:../src/wolfcrypt/src/ecc.c ****         XMEMSET(&nb_ctx, 0, sizeof(nb_ctx));
7840:../src/wolfcrypt/src/ecc.c ****         err = NOT_COMPILED_IN; /* set default error */
7841:../src/wolfcrypt/src/ecc.c ****     #endif
7842:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_SP_NO_256
7843:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[key->idx].id == ECC_SECP256R1) {
7844:../src/wolfcrypt/src/ecc.c ****         #ifdef WC_ECC_NONBLOCK
7845:../src/wolfcrypt/src/ecc.c ****             if (key->nb_ctx) {
7846:../src/wolfcrypt/src/ecc.c ****                 return sp_ecc_verify_256_nb(&key->nb_ctx->sp_ctx, hash, hashlen,
7847:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.x, key->pubkey.y, key->pubkey.z, r, s, res,
7848:../src/wolfcrypt/src/ecc.c ****                     key->heap);
7849:../src/wolfcrypt/src/ecc.c ****             }
7850:../src/wolfcrypt/src/ecc.c ****             #ifdef WC_ECC_NONBLOCK_ONLY
7851:../src/wolfcrypt/src/ecc.c ****             do { /* perform blocking call to non-blocking function */
7852:../src/wolfcrypt/src/ecc.c ****                 err = sp_ecc_verify_256_nb(&nb_ctx.sp_ctx, hash, hashlen,
7853:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.x, key->pubkey.y, key->pubkey.z, r, s, res,
7854:../src/wolfcrypt/src/ecc.c ****                     key->heap);
7855:../src/wolfcrypt/src/ecc.c ****             } while (err == FP_WOULDBLOCK);
7856:../src/wolfcrypt/src/ecc.c ****             return err;
7857:../src/wolfcrypt/src/ecc.c ****             #endif
7858:../src/wolfcrypt/src/ecc.c ****         #endif /* WC_ECC_NONBLOCK */
7859:../src/wolfcrypt/src/ecc.c ****         #if !defined(WC_ECC_NONBLOCK) || (defined(WC_ECC_NONBLOCK) && !defined(WC_ECC_NONBLOCK_ONLY
7860:../src/wolfcrypt/src/ecc.c ****             {
7861:../src/wolfcrypt/src/ecc.c ****                 int ret;
7862:../src/wolfcrypt/src/ecc.c ****                 SAVE_VECTOR_REGISTERS(return _svr_ret;);
7863:../src/wolfcrypt/src/ecc.c ****                 ret = sp_ecc_verify_256(hash, hashlen, key->pubkey.x,
7864:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.y, key->pubkey.z, r, s, res, key->heap);
7865:../src/wolfcrypt/src/ecc.c ****                 RESTORE_VECTOR_REGISTERS();
7866:../src/wolfcrypt/src/ecc.c ****                 return ret;
7867:../src/wolfcrypt/src/ecc.c ****             }
7868:../src/wolfcrypt/src/ecc.c ****         #endif
7869:../src/wolfcrypt/src/ecc.c ****         }
7870:../src/wolfcrypt/src/ecc.c ****     #endif
7871:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_384
7872:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[key->idx].id == ECC_SECP384R1) {
7873:../src/wolfcrypt/src/ecc.c ****         #ifdef WC_ECC_NONBLOCK
7874:../src/wolfcrypt/src/ecc.c ****             if (key->nb_ctx) {
7875:../src/wolfcrypt/src/ecc.c ****                 return sp_ecc_verify_384_nb(&key->nb_ctx->sp_ctx, hash, hashlen,
7876:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.x,  key->pubkey.y, key->pubkey.z, r, s, res,
7877:../src/wolfcrypt/src/ecc.c ****                     key->heap);
7878:../src/wolfcrypt/src/ecc.c ****             }
7879:../src/wolfcrypt/src/ecc.c ****             #ifdef WC_ECC_NONBLOCK_ONLY
7880:../src/wolfcrypt/src/ecc.c ****             do { /* perform blocking call to non-blocking function */
7881:../src/wolfcrypt/src/ecc.c ****                 err = sp_ecc_verify_384_nb(&nb_ctx.sp_ctx, hash, hashlen,
7882:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.x, key->pubkey.y, key->pubkey.z, r, s, res,
7883:../src/wolfcrypt/src/ecc.c ****                     key->heap);
7884:../src/wolfcrypt/src/ecc.c ****             } while (err == FP_WOULDBLOCK);
7885:../src/wolfcrypt/src/ecc.c ****             return err;
7886:../src/wolfcrypt/src/ecc.c ****             #endif
7887:../src/wolfcrypt/src/ecc.c ****         #endif /* WC_ECC_NONBLOCK */
7888:../src/wolfcrypt/src/ecc.c ****         #if !defined(WC_ECC_NONBLOCK) || (defined(WC_ECC_NONBLOCK) && !defined(WC_ECC_NONBLOCK_ONLY
7889:../src/wolfcrypt/src/ecc.c ****             {
7890:../src/wolfcrypt/src/ecc.c ****                 int ret;
7891:../src/wolfcrypt/src/ecc.c ****                 SAVE_VECTOR_REGISTERS(return _svr_ret;);
7892:../src/wolfcrypt/src/ecc.c ****                 ret = sp_ecc_verify_384(hash, hashlen, key->pubkey.x,
7893:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.y, key->pubkey.z, r, s, res, key->heap);
7894:../src/wolfcrypt/src/ecc.c ****                 RESTORE_VECTOR_REGISTERS();
7895:../src/wolfcrypt/src/ecc.c ****                 return ret;
7896:../src/wolfcrypt/src/ecc.c ****             }
7897:../src/wolfcrypt/src/ecc.c ****         #endif
7898:../src/wolfcrypt/src/ecc.c ****         }
7899:../src/wolfcrypt/src/ecc.c ****     #endif
7900:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_521
7901:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[key->idx].id == ECC_SECP521R1) {
7902:../src/wolfcrypt/src/ecc.c ****         #ifdef WC_ECC_NONBLOCK
7903:../src/wolfcrypt/src/ecc.c ****             if (key->nb_ctx) {
7904:../src/wolfcrypt/src/ecc.c ****                 return sp_ecc_verify_521_nb(&key->nb_ctx->sp_ctx, hash, hashlen,
7905:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.x,  key->pubkey.y, key->pubkey.z, r, s, res,
7906:../src/wolfcrypt/src/ecc.c ****                     key->heap);
7907:../src/wolfcrypt/src/ecc.c ****             }
7908:../src/wolfcrypt/src/ecc.c ****             #ifdef WC_ECC_NONBLOCK_ONLY
7909:../src/wolfcrypt/src/ecc.c ****             do { /* perform blocking call to non-blocking function */
7910:../src/wolfcrypt/src/ecc.c ****                 err = sp_ecc_verify_521_nb(&nb_ctx.sp_ctx, hash, hashlen,
7911:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.x, key->pubkey.y, key->pubkey.z, r, s, res,
7912:../src/wolfcrypt/src/ecc.c ****                     key->heap);
7913:../src/wolfcrypt/src/ecc.c ****             } while (err == FP_WOULDBLOCK);
7914:../src/wolfcrypt/src/ecc.c ****             return err;
7915:../src/wolfcrypt/src/ecc.c ****             #endif
7916:../src/wolfcrypt/src/ecc.c ****         #endif /* WC_ECC_NONBLOCK */
7917:../src/wolfcrypt/src/ecc.c ****         #if !defined(WC_ECC_NONBLOCK) || (defined(WC_ECC_NONBLOCK) && !defined(WC_ECC_NONBLOCK_ONLY
7918:../src/wolfcrypt/src/ecc.c ****             {
7919:../src/wolfcrypt/src/ecc.c ****                 int ret;
7920:../src/wolfcrypt/src/ecc.c ****                 SAVE_VECTOR_REGISTERS(return _svr_ret;);
7921:../src/wolfcrypt/src/ecc.c ****                 ret = sp_ecc_verify_521(hash, hashlen, key->pubkey.x,
7922:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.y, key->pubkey.z, r, s, res, key->heap);
7923:../src/wolfcrypt/src/ecc.c ****                 RESTORE_VECTOR_REGISTERS();
7924:../src/wolfcrypt/src/ecc.c ****                 return ret;
7925:../src/wolfcrypt/src/ecc.c ****             }
7926:../src/wolfcrypt/src/ecc.c ****         #endif
7927:../src/wolfcrypt/src/ecc.c ****         }
7928:../src/wolfcrypt/src/ecc.c ****     #endif
7929:../src/wolfcrypt/src/ecc.c ****     }
7930:../src/wolfcrypt/src/ecc.c **** #endif
7931:../src/wolfcrypt/src/ecc.c **** 
7932:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)
7933:../src/wolfcrypt/src/ecc.c ****    ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 10072                             		.loc 2 7933 4
 10073 00fa FB 1A 50 0F             		mov.L	#0xf50, r1
 10074 00fe 05 00 00 00             		bsr	_wolfSSL_Malloc
 10075 0102 E7 A1 08                		mov.L	r1, 32[r10]
 10076 0105 ED A5 08                		mov.L	32[r10], r5
 10077 0108 61 05                   		cmp	#0, r5
 10078 010a 1D                      		bne	.L698
 10079                             		.loc 2 7933 4 is_stmt 0 discriminator 1
 10080 010b F8 A6 83                		mov.L	#-125, [r10]
 10081 010e 09                      		bra	.L699
 10082                             	.L698:
 10083                             		.loc 2 7933 4 discriminator 2
 10084 010f ED A5 1F                		mov.L	124[r10], r5
 10085 0112 ED A4 08                		mov.L	32[r10], r4
 10086 0115 A1 D4                   		mov.L	r4, 24[r5]
 10087                             	.L699:
7934:../src/wolfcrypt/src/ecc.c ****    if (err != 0) {
 10088                             		.loc 2 7934 7 is_stmt 1
 10089 0117 EC A5                   		mov.L	[r10], r5
 10090 0119 61 05                   		cmp	#0, r5
 10091 011b 16                      		beq	.L700
7935:../src/wolfcrypt/src/ecc.c ****       return err;
 10092                             		.loc 2 7935 14
 10093 011c EC A5                   		mov.L	[r10], r5
 10094 011e 38 7E 04                		bra	.L740
 10095                             	.L700:
7936:../src/wolfcrypt/src/ecc.c ****    }
7937:../src/wolfcrypt/src/ecc.c **** 
7938:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(HAVE_CAVIUM_V)
7939:../src/wolfcrypt/src/ecc.c ****    err = wc_ecc_alloc_mpint(key, &key->e);
7940:../src/wolfcrypt/src/ecc.c ****    if (err != 0) {
7941:../src/wolfcrypt/src/ecc.c ****       FREE_CURVE_SPECS();
7942:../src/wolfcrypt/src/ecc.c ****       return err;
7943:../src/wolfcrypt/src/ecc.c ****    }
7944:../src/wolfcrypt/src/ecc.c ****    e = key->e;
7945:../src/wolfcrypt/src/ecc.c **** #else
7946:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
7947:../src/wolfcrypt/src/ecc.c ****    e_lcl = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 10096                             		.loc 2 7947 21
 10097 0121 FB 1A 10 03             		mov.L	#0x310, r1
 10098 0125 05 00 00 00             		bsr	_wolfSSL_Malloc
 10099 0129 E7 A1 07                		mov.L	r1, 28[r10]
7948:../src/wolfcrypt/src/ecc.c ****    if (e_lcl == NULL) {
 10100                             		.loc 2 7948 7
 10101 012c ED A5 07                		mov.L	28[r10], r5
 10102 012f 61 05                   		cmp	#0, r5
 10103 0131 21 1B                   		bne	.L701
 10104                             	.LBB69:
7949:../src/wolfcrypt/src/ecc.c ****        FREE_CURVE_SPECS();
 10105                             		.loc 2 7949 8
 10106 0133 ED A5 08                		mov.L	32[r10], r5
 10107 0136 E7 A5 09                		mov.L	r5, 36[r10]
 10108 0139 ED A5 09                		mov.L	36[r10], r5
 10109 013c 61 05                   		cmp	#0, r5
 10110 013e 10                      		beq	.L702
 10111                             		.loc 2 7949 8 is_stmt 0 discriminator 1
 10112 013f ED A1 09                		mov.L	36[r10], r1
 10113 0142 05 00 00 00             		bsr	_wolfSSL_Free
 10114                             	.L702:
 10115                             	.LBE69:
7950:../src/wolfcrypt/src/ecc.c ****        return MEMORY_E;
 10116                             		.loc 2 7950 15 is_stmt 1
 10117 0146 FB 56 83                		mov.L	#-125, r5
 10118 0149 38 53 04                		bra	.L740
 10119                             	.L701:
7951:../src/wolfcrypt/src/ecc.c ****    }
7952:../src/wolfcrypt/src/ecc.c **** #endif
7953:../src/wolfcrypt/src/ecc.c ****    e = e_lcl;
 10120                             		.loc 2 7953 6
 10121 014c ED A5 07                		mov.L	28[r10], r5
 10122 014f E7 A5 0A                		mov.L	r5, 40[r10]
7954:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ASYNC_CRYPT && HAVE_CAVIUM_V */
7955:../src/wolfcrypt/src/ecc.c **** 
7956:../src/wolfcrypt/src/ecc.c ****    err = mp_init(e);
 10123                             		.loc 2 7956 10
 10124 0152 ED A1 0A                		mov.L	40[r10], r1
 10125 0155 05 00 00 00             		bsr	_sp_init
 10126 0159 E3 A1                   		mov.L	r1, [r10]
7957:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY) {
 10127                             		.loc 2 7957 7
 10128 015b EC A5                   		mov.L	[r10], r5
 10129 015d 61 05                   		cmp	#0, r5
 10130 015f 20 1B                   		beq	.L703
 10131                             	.LBB70:
7958:../src/wolfcrypt/src/ecc.c ****       FREE_CURVE_SPECS();
 10132                             		.loc 2 7958 7
 10133 0161 ED A5 08                		mov.L	32[r10], r5
 10134 0164 E7 A5 0B                		mov.L	r5, 44[r10]
 10135 0167 ED A5 0B                		mov.L	44[r10], r5
 10136 016a 61 05                   		cmp	#0, r5
 10137 016c 10                      		beq	.L704
 10138                             		.loc 2 7958 7 is_stmt 0 discriminator 1
 10139 016d ED A1 0B                		mov.L	44[r10], r1
 10140 0170 05 00 00 00             		bsr	_wolfSSL_Free
 10141                             	.L704:
 10142                             	.LBE70:
7959:../src/wolfcrypt/src/ecc.c ****       return MEMORY_E;
 10143                             		.loc 2 7959 14 is_stmt 1
 10144 0174 FB 56 83                		mov.L	#-125, r5
 10145 0177 38 25 04                		bra	.L740
 10146                             	.L703:
7960:../src/wolfcrypt/src/ecc.c ****    }
7961:../src/wolfcrypt/src/ecc.c **** 
7962:../src/wolfcrypt/src/ecc.c ****    /* read in the specs for this curve */
7963:../src/wolfcrypt/src/ecc.c ****    err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 10147                             		.loc 2 7963 10
 10148 017a A8 6D                   		mov.L	4[r6], r5
 10149 017c A9 54                   		mov.L	16[r5], r4
 10150 017e 71 A5 7C                		add	#0x7c, r10, r5
 10151 0181 75 43 3B                		mov	#59, r3
 10152 0184 EF 52                   		mov.L	r5, r2
 10153 0186 EF 41                   		mov.L	r4, r1
 10154 0188 05 00 00 00             		bsr	_wc_ecc_curve_load
 10155 018c E3 A1                   		mov.L	r1, [r10]
7964:../src/wolfcrypt/src/ecc.c **** 
7965:../src/wolfcrypt/src/ecc.c ****    /* read hash */
7966:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 10156                             		.loc 2 7966 7
 10157 018e EC A5                   		mov.L	[r10], r5
 10158 0190 61 05                   		cmp	#0, r5
 10159 0192 21 5F                   		bne	.L705
 10160                             	.LBB71:
7967:../src/wolfcrypt/src/ecc.c ****        /* we may need to truncate if hash is longer than key size */
7968:../src/wolfcrypt/src/ecc.c ****        unsigned int orderBits = mp_count_bits(curve->order);
 10161                             		.loc 2 7968 52
 10162 0194 ED A5 1F                		mov.L	124[r10], r5
 10163 0197 A8 DD                   		mov.L	12[r5], r5
 10164                             		.loc 2 7968 33
 10165 0199 EF 51                   		mov.L	r5, r1
 10166 019b 05 00 00 00             		bsr	_sp_count_bits
 10167 019f EF 15                   		mov.L	r1, r5
 10168                             		.loc 2 7968 21
 10169 01a1 E7 A5 0C                		mov.L	r5, 48[r10]
7969:../src/wolfcrypt/src/ecc.c **** 
7970:../src/wolfcrypt/src/ecc.c ****        /* truncate down to byte size, may be all that's needed */
7971:../src/wolfcrypt/src/ecc.c ****        if ( (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 10170                             		.loc 2 7971 31
 10171 01a4 ED A5 24                		mov.L	144[r10], r5
 10172 01a7 6C 35                   		shll	#3, r5
 10173                             		.loc 2 7971 11
 10174 01a9 ED A4 0C                		mov.L	48[r10], r4
 10175 01ac 47 54                   		cmp	r5, r4
 10176 01ae 22 0C                   		bgeu	.L706
7972:../src/wolfcrypt/src/ecc.c ****            hashlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;
 10177                             		.loc 2 7972 52
 10178 01b0 ED A5 0C                		mov.L	48[r10], r5
 10179 01b3 62 75                   		add	#7, r5
 10180                             		.loc 2 7972 20
 10181 01b5 68 35                   		shlr	#3, r5
 10182 01b7 E7 A5 24                		mov.L	r5, 144[r10]
 10183                             	.L706:
7973:../src/wolfcrypt/src/ecc.c ****        err = mp_read_unsigned_bin(e, hash, hashlen);
 10184                             		.loc 2 7973 14
 10185 01ba ED A3 24                		mov.L	144[r10], r3
 10186 01bd ED A2 23                		mov.L	140[r10], r2
 10187 01c0 ED A1 0A                		mov.L	40[r10], r1
 10188 01c3 05 00 00 00             		bsr	_sp_read_unsigned_bin
 10189 01c7 E3 A1                   		mov.L	r1, [r10]
7974:../src/wolfcrypt/src/ecc.c **** 
7975:../src/wolfcrypt/src/ecc.c ****        /* may still need bit truncation too */
7976:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 10190                             		.loc 2 7976 11
 10191 01c9 EC A5                   		mov.L	[r10], r5
 10192 01cb 61 05                   		cmp	#0, r5
 10193 01cd 21 24                   		bne	.L705
 10194                             		.loc 2 7976 48 discriminator 1
 10195 01cf ED A5 24                		mov.L	144[r10], r5
 10196 01d2 6C 35                   		shll	#3, r5
 10197                             		.loc 2 7976 27 discriminator 1
 10198 01d4 ED A4 0C                		mov.L	48[r10], r4
 10199 01d7 47 54                   		cmp	r5, r4
 10200 01d9 22 18                   		bgeu	.L705
7977:../src/wolfcrypt/src/ecc.c ****            mp_rshb(e, WOLFSSL_BIT_SIZE - (orderBits & 0x7));
 10201                             		.loc 2 7977 12
 10202 01db ED A5 0C                		mov.L	48[r10], r5
 10203 01de 64 75                   		and	#7, r5
 10204 01e0 66 84                   		mov.L	#8, r4
 10205 01e2 FF 05 54                		sub	r5, r4, r5
 10206 01e5 ED A3 0A                		mov.L	40[r10], r3
 10207 01e8 EF 52                   		mov.L	r5, r2
 10208 01ea ED A1 0A                		mov.L	40[r10], r1
 10209 01ed 05 00 00 00             		bsr	_sp_rshb
 10210                             		.balign 8,3,1
 10211                             	.L705:
 10212                             	.LBE71:
7978:../src/wolfcrypt/src/ecc.c ****    }
7979:../src/wolfcrypt/src/ecc.c **** 
7980:../src/wolfcrypt/src/ecc.c ****    /* check for async hardware acceleration */
7981:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
7982:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY && key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {
7983:../src/wolfcrypt/src/ecc.c ****    #if defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)
7984:../src/wolfcrypt/src/ecc.c ****    #ifdef HAVE_CAVIUM_V
7985:../src/wolfcrypt/src/ecc.c ****       if (NitroxEccIsCurveSupported(key))
7986:../src/wolfcrypt/src/ecc.c ****    #endif
7987:../src/wolfcrypt/src/ecc.c ****       {
7988:../src/wolfcrypt/src/ecc.c ****           err = wc_mp_to_bigint_sz(e, &e->raw, keySz);
7989:../src/wolfcrypt/src/ecc.c ****           if (err == MP_OKAY)
7990:../src/wolfcrypt/src/ecc.c ****               err = wc_mp_to_bigint_sz(key->pubkey.x, &key->pubkey.x->raw, keySz);
7991:../src/wolfcrypt/src/ecc.c ****           if (err == MP_OKAY)
7992:../src/wolfcrypt/src/ecc.c ****               err = wc_mp_to_bigint_sz(key->pubkey.y, &key->pubkey.y->raw, keySz);
7993:../src/wolfcrypt/src/ecc.c ****           if (err == MP_OKAY)
7994:../src/wolfcrypt/src/ecc.c ****           #ifdef HAVE_CAVIUM_V
7995:../src/wolfcrypt/src/ecc.c ****               err = NitroxEcdsaVerify(key, &e->raw, &key->pubkey.x->raw,
7996:../src/wolfcrypt/src/ecc.c ****                     &key->pubkey.y->raw, &r->raw, &s->raw,
7997:../src/wolfcrypt/src/ecc.c ****                     &curve->prime->raw, &curve->order->raw, res);
7998:../src/wolfcrypt/src/ecc.c ****           #else
7999:../src/wolfcrypt/src/ecc.c ****               err = IntelQaEcdsaVerify(&key->asyncDev, &e->raw, &key->pubkey.x->raw,
8000:../src/wolfcrypt/src/ecc.c ****                     &key->pubkey.y->raw, &r->raw, &s->raw, &curve->Af->raw,
8001:../src/wolfcrypt/src/ecc.c ****                     &curve->Bf->raw, &curve->prime->raw, &curve->order->raw,
8002:../src/wolfcrypt/src/ecc.c ****                     &curve->Gx->raw, &curve->Gy->raw, res);
8003:../src/wolfcrypt/src/ecc.c ****           #endif
8004:../src/wolfcrypt/src/ecc.c **** 
8005:../src/wolfcrypt/src/ecc.c ****       #ifndef HAVE_CAVIUM_V
8006:../src/wolfcrypt/src/ecc.c ****           mp_clear(e);
8007:../src/wolfcrypt/src/ecc.c ****       #endif
8008:../src/wolfcrypt/src/ecc.c ****           wc_ecc_curve_free(curve);
8009:../src/wolfcrypt/src/ecc.c ****           FREE_CURVE_SPECS();
8010:../src/wolfcrypt/src/ecc.c **** 
8011:../src/wolfcrypt/src/ecc.c ****           return err;
8012:../src/wolfcrypt/src/ecc.c ****       }
8013:../src/wolfcrypt/src/ecc.c ****    #endif /* HAVE_CAVIUM_V || HAVE_INTEL_QA */
8014:../src/wolfcrypt/src/ecc.c ****    }
8015:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */
8016:../src/wolfcrypt/src/ecc.c **** 
8017:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8018:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 10213                             		.loc 2 8018 7
 10214 01f1 EC A5                   		mov.L	[r10], r5
 10215 01f3 61 05                   		cmp	#0, r5
 10216 01f5 21 16                   		bne	.L707
8019:../src/wolfcrypt/src/ecc.c ****        v = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 10217                             		.loc 2 8019 21
 10218 01f7 FB 1A 10 03             		mov.L	#0x310, r1
 10219 01fb 05 00 00 00             		bsr	_wolfSSL_Malloc
 10220 01ff E7 A1 02                		mov.L	r1, 8[r10]
8020:../src/wolfcrypt/src/ecc.c ****        if (v == NULL)
 10221                             		.loc 2 8020 11
 10222 0202 ED A5 02                		mov.L	8[r10], r5
 10223 0205 61 05                   		cmp	#0, r5
 10224 0207 1C                      		bne	.L707
8021:../src/wolfcrypt/src/ecc.c ****            err = MEMORY_E;
 10225                             		.loc 2 8021 16
 10226 0208 F8 A6 83                		mov.L	#-125, [r10]
 10227                             	.L707:
8022:../src/wolfcrypt/src/ecc.c ****    }
8023:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 10228                             		.loc 2 8023 7
 10229 020b EC A5                   		mov.L	[r10], r5
 10230 020d 61 05                   		cmp	#0, r5
 10231 020f 21 16                   		bne	.L708
8024:../src/wolfcrypt/src/ecc.c ****        w = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 10232                             		.loc 2 8024 21
 10233 0211 FB 1A 10 03             		mov.L	#0x310, r1
 10234 0215 05 00 00 00             		bsr	_wolfSSL_Malloc
 10235 0219 E7 A1 03                		mov.L	r1, 12[r10]
8025:../src/wolfcrypt/src/ecc.c ****        if (w == NULL)
 10236                             		.loc 2 8025 11
 10237 021c ED A5 03                		mov.L	12[r10], r5
 10238 021f 61 05                   		cmp	#0, r5
 10239 0221 1C                      		bne	.L708
8026:../src/wolfcrypt/src/ecc.c ****            err = MEMORY_E;
 10240                             		.loc 2 8026 16
 10241 0222 F8 A6 83                		mov.L	#-125, [r10]
 10242                             	.L708:
8027:../src/wolfcrypt/src/ecc.c ****    }
8028:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 10243                             		.loc 2 8028 7
 10244 0225 EC A5                   		mov.L	[r10], r5
 10245 0227 61 05                   		cmp	#0, r5
 10246 0229 21 16                   		bne	.L709
8029:../src/wolfcrypt/src/ecc.c ****        u1 = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 10247                             		.loc 2 8029 22
 10248 022b FB 1A 10 03             		mov.L	#0x310, r1
 10249 022f 05 00 00 00             		bsr	_wolfSSL_Malloc
 10250 0233 E7 A1 04                		mov.L	r1, 16[r10]
8030:../src/wolfcrypt/src/ecc.c ****        if (u1 == NULL)
 10251                             		.loc 2 8030 11
 10252 0236 ED A5 04                		mov.L	16[r10], r5
 10253 0239 61 05                   		cmp	#0, r5
 10254 023b 1C                      		bne	.L709
8031:../src/wolfcrypt/src/ecc.c ****            err = MEMORY_E;
 10255                             		.loc 2 8031 16
 10256 023c F8 A6 83                		mov.L	#-125, [r10]
 10257                             	.L709:
8032:../src/wolfcrypt/src/ecc.c ****    }
8033:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 10258                             		.loc 2 8033 7
 10259 023f EC A5                   		mov.L	[r10], r5
 10260 0241 61 05                   		cmp	#0, r5
 10261 0243 21 16                   		bne	.L710
8034:../src/wolfcrypt/src/ecc.c ****        u2 = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 10262                             		.loc 2 8034 22
 10263 0245 FB 1A 10 03             		mov.L	#0x310, r1
 10264 0249 05 00 00 00             		bsr	_wolfSSL_Malloc
 10265 024d E7 A1 05                		mov.L	r1, 20[r10]
8035:../src/wolfcrypt/src/ecc.c ****        if (u2 == NULL)
 10266                             		.loc 2 8035 11
 10267 0250 ED A5 05                		mov.L	20[r10], r5
 10268 0253 61 05                   		cmp	#0, r5
 10269 0255 1C                      		bne	.L710
8036:../src/wolfcrypt/src/ecc.c ****            err = MEMORY_E;
 10270                             		.loc 2 8036 16
 10271 0256 F8 A6 83                		mov.L	#-125, [r10]
 10272                             	.L710:
8037:../src/wolfcrypt/src/ecc.c ****    }
8038:../src/wolfcrypt/src/ecc.c **** #endif
8039:../src/wolfcrypt/src/ecc.c **** 
8040:../src/wolfcrypt/src/ecc.c ****    /* allocate ints */
8041:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 10273                             		.loc 2 8041 7
 10274 0259 EC A5                   		mov.L	[r10], r5
 10275 025b 61 05                   		cmp	#0, r5
 10276 025d 21 27                   		bne	.L711
8042:../src/wolfcrypt/src/ecc.c ****        if ((err = mp_init_multi(v, w, u1, u2, NULL, NULL)) != MP_OKAY) {
 10277                             		.loc 2 8042 19
 10278 025f 3E 01 00                		mov.L	#0, 4[r0]
 10279 0262 F8 06 00                		mov.L	#0, [r0]
 10280 0265 ED A4 05                		mov.L	20[r10], r4
 10281 0268 ED A3 04                		mov.L	16[r10], r3
 10282 026b ED A2 03                		mov.L	12[r10], r2
 10283 026e ED A1 02                		mov.L	8[r10], r1
 10284 0271 05 00 00 00             		bsr	_sp_init_multi
 10285 0275 E3 A1                   		mov.L	r1, [r10]
 10286                             		.loc 2 8042 11
 10287 0277 EC A5                   		mov.L	[r10], r5
 10288 0279 61 05                   		cmp	#0, r5
 10289 027b 15                      		beq	.L712
8043:../src/wolfcrypt/src/ecc.c ****           err = MEMORY_E;
 10290                             		.loc 2 8043 15
 10291 027c F8 A6 83                		mov.L	#-125, [r10]
 10292 027f 0D                      		bra	.L711
 10293                             	.L712:
8044:../src/wolfcrypt/src/ecc.c ****        } else {
8045:../src/wolfcrypt/src/ecc.c ****            did_init = 1;
 10294                             		.loc 2 8045 21
 10295 0280 F9 A6 01 01             		mov.L	#1, 4[r10]
 10296                             	.L711:
8046:../src/wolfcrypt/src/ecc.c ****        }
8047:../src/wolfcrypt/src/ecc.c ****    }
8048:../src/wolfcrypt/src/ecc.c **** 
8049:../src/wolfcrypt/src/ecc.c ****    /* allocate points */
8050:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 10297                             		.loc 2 8050 7
 10298 0284 EC A5                   		mov.L	[r10], r5
 10299 0286 61 05                   		cmp	#0, r5
 10300 0288 21 13                   		bne	.L713
8051:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_NO_MALLOC
8052:../src/wolfcrypt/src/ecc.c ****        mG = &lcl_mG;
8053:../src/wolfcrypt/src/ecc.c ****    #endif
8054:../src/wolfcrypt/src/ecc.c ****        err = wc_ecc_new_point_ex(&mG, key->heap);
 10301                             		.loc 2 8054 14
 10302 028a A8 6D                   		mov.L	4[r6], r5
 10303 028c A9 5C                   		mov.L	20[r5], r4
 10304 028e 71 A5 4C                		add	#0x4c, r10, r5
 10305 0291 EF 42                   		mov.L	r4, r2
 10306 0293 EF 51                   		mov.L	r5, r1
 10307 0295 05 00 00 00             		bsr	_wc_ecc_new_point_ex
 10308 0299 E3 A1                   		mov.L	r1, [r10]
 10309                             	.L713:
8055:../src/wolfcrypt/src/ecc.c ****    }
8056:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 10310                             		.loc 2 8056 7
 10311 029b EC A5                   		mov.L	[r10], r5
 10312 029d 61 05                   		cmp	#0, r5
 10313 029f 21 13                   		bne	.L714
8057:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_NO_MALLOC
8058:../src/wolfcrypt/src/ecc.c ****        mQ = &lcl_mQ;
8059:../src/wolfcrypt/src/ecc.c ****    #endif
8060:../src/wolfcrypt/src/ecc.c ****        err = wc_ecc_new_point_ex(&mQ, key->heap);
 10314                             		.loc 2 8060 14
 10315 02a1 A8 6D                   		mov.L	4[r6], r5
 10316 02a3 A9 5C                   		mov.L	20[r5], r4
 10317 02a5 71 A5 50                		add	#0x50, r10, r5
 10318 02a8 EF 42                   		mov.L	r4, r2
 10319 02aa EF 51                   		mov.L	r5, r1
 10320 02ac 05 00 00 00             		bsr	_wc_ecc_new_point_ex
 10321 02b0 E3 A1                   		mov.L	r1, [r10]
 10322                             	.L714:
8061:../src/wolfcrypt/src/ecc.c ****    }
8062:../src/wolfcrypt/src/ecc.c **** 
8063:../src/wolfcrypt/src/ecc.c ****    /*  w  = s^-1 mod n */
8064:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10323                             		.loc 2 8064 7
 10324 02b2 EC A5                   		mov.L	[r10], r5
 10325 02b4 61 05                   		cmp	#0, r5
 10326 02b6 21 15                   		bne	.L715
8065:../src/wolfcrypt/src/ecc.c ****        err = mp_invmod(s, curve->order, w);
 10327                             		.loc 2 8065 32
 10328 02b8 ED A5 1F                		mov.L	124[r10], r5
 10329 02bb A8 DD                   		mov.L	12[r5], r5
 10330                             		.loc 2 8065 14
 10331 02bd ED A3 03                		mov.L	12[r10], r3
 10332 02c0 EF 52                   		mov.L	r5, r2
 10333 02c2 ED A1 22                		mov.L	136[r10], r1
 10334 02c5 05 00 00 00             		bsr	_sp_invmod
 10335 02c9 E3 A1                   		mov.L	r1, [r10]
 10336                             	.L715:
8066:../src/wolfcrypt/src/ecc.c **** 
8067:../src/wolfcrypt/src/ecc.c ****    /* u1 = ew */
8068:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10337                             		.loc 2 8068 7
 10338 02cb EC A5                   		mov.L	[r10], r5
 10339 02cd 61 05                   		cmp	#0, r5
 10340 02cf 21 18                   		bne	.L716
8069:../src/wolfcrypt/src/ecc.c ****        err = mp_mulmod(e, w, curve->order, u1);
 10341                             		.loc 2 8069 35
 10342 02d1 ED A5 1F                		mov.L	124[r10], r5
 10343 02d4 A8 DD                   		mov.L	12[r5], r5
 10344                             		.loc 2 8069 14
 10345 02d6 ED A4 04                		mov.L	16[r10], r4
 10346 02d9 EF 53                   		mov.L	r5, r3
 10347 02db ED A2 03                		mov.L	12[r10], r2
 10348 02de ED A1 0A                		mov.L	40[r10], r1
 10349 02e1 05 00 00 00             		bsr	_sp_mulmod
 10350 02e5 E3 A1                   		mov.L	r1, [r10]
 10351                             	.L716:
8070:../src/wolfcrypt/src/ecc.c **** 
8071:../src/wolfcrypt/src/ecc.c ****    /* u2 = rw */
8072:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10352                             		.loc 2 8072 7
 10353 02e7 EC A5                   		mov.L	[r10], r5
 10354 02e9 61 05                   		cmp	#0, r5
 10355 02eb 21 18                   		bne	.L717
8073:../src/wolfcrypt/src/ecc.c ****        err = mp_mulmod(r, w, curve->order, u2);
 10356                             		.loc 2 8073 35
 10357 02ed ED A5 1F                		mov.L	124[r10], r5
 10358 02f0 A8 DD                   		mov.L	12[r5], r5
 10359                             		.loc 2 8073 14
 10360 02f2 ED A4 05                		mov.L	20[r10], r4
 10361 02f5 EF 53                   		mov.L	r5, r3
 10362 02f7 ED A2 03                		mov.L	12[r10], r2
 10363 02fa ED A1 21                		mov.L	132[r10], r1
 10364 02fd 05 00 00 00             		bsr	_sp_mulmod
 10365 0301 E3 A1                   		mov.L	r1, [r10]
 10366                             	.L717:
8074:../src/wolfcrypt/src/ecc.c **** 
8075:../src/wolfcrypt/src/ecc.c ****    /* find mG and mQ */
8076:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10367                             		.loc 2 8076 7
 10368 0303 EC A5                   		mov.L	[r10], r5
 10369 0305 61 05                   		cmp	#0, r5
 10370 0307 21 14                   		bne	.L718
8077:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(curve->Gx, mG->x);
 10371                             		.loc 2 8077 27
 10372 0309 ED A5 1F                		mov.L	124[r10], r5
 10373 030c A9 55                   		mov.L	16[r5], r5
 10374                             		.loc 2 8077 35
 10375 030e ED A4 13                		mov.L	76[r10], r4
 10376                             		.loc 2 8077 14
 10377 0311 EF 42                   		mov.L	r4, r2
 10378 0313 EF 51                   		mov.L	r5, r1
 10379 0315 05 00 00 00             		bsr	_sp_copy
 10380 0319 E3 A1                   		mov.L	r1, [r10]
 10381                             	.L718:
8078:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10382                             		.loc 2 8078 7
 10383 031b EC A5                   		mov.L	[r10], r5
 10384 031d 61 05                   		cmp	#0, r5
 10385 031f 21 18                   		bne	.L719
8079:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(curve->Gy, mG->y);
 10386                             		.loc 2 8079 27
 10387 0321 ED A5 1F                		mov.L	124[r10], r5
 10388 0324 A9 5C                   		mov.L	20[r5], r4
 10389                             		.loc 2 8079 35
 10390 0326 ED A5 13                		mov.L	76[r10], r5
 10391 0329 72 55 10 03             		add	#0x310, r5
 10392                             		.loc 2 8079 14
 10393 032d EF 52                   		mov.L	r5, r2
 10394 032f EF 41                   		mov.L	r4, r1
 10395 0331 05 00 00 00             		bsr	_sp_copy
 10396 0335 E3 A1                   		mov.L	r1, [r10]
 10397                             	.L719:
8080:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10398                             		.loc 2 8080 7
 10399 0337 EC A5                   		mov.L	[r10], r5
 10400 0339 61 05                   		cmp	#0, r5
 10401 033b 21 13                   		bne	.L720
8081:../src/wolfcrypt/src/ecc.c ****        err = mp_set(mG->z, 1);
 10402                             		.loc 2 8081 23
 10403 033d ED A5 13                		mov.L	76[r10], r5
 10404 0340 72 55 20 06             		add	#0x620, r5
 10405                             		.loc 2 8081 14
 10406 0344 66 12                   		mov.L	#1, r2
 10407 0346 EF 51                   		mov.L	r5, r1
 10408 0348 05 00 00 00             		bsr	_sp_set
 10409 034c E3 A1                   		mov.L	r1, [r10]
 10410                             	.L720:
8082:../src/wolfcrypt/src/ecc.c **** 
8083:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10411                             		.loc 2 8083 7
 10412 034e EC A5                   		mov.L	[r10], r5
 10413 0350 61 05                   		cmp	#0, r5
 10414 0352 21 14                   		bne	.L721
8084:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(key->pubkey.x, mQ->x);
 10415                             		.loc 2 8084 33
 10416 0354 A8 6D                   		mov.L	4[r6], r5
 10417 0356 71 55 18                		add	#24, r5
 10418                             		.loc 2 8084 39
 10419 0359 ED A4 14                		mov.L	80[r10], r4
 10420                             		.loc 2 8084 14
 10421 035c EF 42                   		mov.L	r4, r2
 10422 035e EF 51                   		mov.L	r5, r1
 10423 0360 05 00 00 00             		bsr	_sp_copy
 10424 0364 E3 A1                   		mov.L	r1, [r10]
 10425                             	.L721:
8085:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10426                             		.loc 2 8085 7
 10427 0366 EC A5                   		mov.L	[r10], r5
 10428 0368 61 05                   		cmp	#0, r5
 10429 036a 21 19                   		bne	.L722
8086:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(key->pubkey.y, mQ->y);
 10430                             		.loc 2 8086 33
 10431 036c A8 6D                   		mov.L	4[r6], r5
 10432 036e 72 54 28 03             		add	#0x328, r5, r4
 10433                             		.loc 2 8086 39
 10434 0372 ED A5 14                		mov.L	80[r10], r5
 10435 0375 72 55 10 03             		add	#0x310, r5
 10436                             		.loc 2 8086 14
 10437 0379 EF 52                   		mov.L	r5, r2
 10438 037b EF 41                   		mov.L	r4, r1
 10439 037d 05 00 00 00             		bsr	_sp_copy
 10440 0381 E3 A1                   		mov.L	r1, [r10]
 10441                             	.L722:
8087:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10442                             		.loc 2 8087 7
 10443 0383 EC A5                   		mov.L	[r10], r5
 10444 0385 61 05                   		cmp	#0, r5
 10445 0387 21 19                   		bne	.L723
8088:../src/wolfcrypt/src/ecc.c ****        err = mp_copy(key->pubkey.z, mQ->z);
 10446                             		.loc 2 8088 33
 10447 0389 A8 6D                   		mov.L	4[r6], r5
 10448 038b 72 54 38 06             		add	#0x638, r5, r4
 10449                             		.loc 2 8088 39
 10450 038f ED A5 14                		mov.L	80[r10], r5
 10451 0392 72 55 20 06             		add	#0x620, r5
 10452                             		.loc 2 8088 14
 10453 0396 EF 52                   		mov.L	r5, r2
 10454 0398 EF 41                   		mov.L	r4, r1
 10455 039a 05 00 00 00             		bsr	_sp_copy
 10456 039e E3 A1                   		mov.L	r1, [r10]
 10457                             	.L723:
8089:../src/wolfcrypt/src/ecc.c **** 
8090:../src/wolfcrypt/src/ecc.c **** #if defined(FREESCALE_LTC_ECC)
8091:../src/wolfcrypt/src/ecc.c ****    /* use PKHA to compute u1*mG + u2*mQ */
8092:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
8093:../src/wolfcrypt/src/ecc.c ****        err = wc_ecc_mulmod_ex(u1, mG, mG, curve->Af, curve->prime, 0, key->heap);
8094:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
8095:../src/wolfcrypt/src/ecc.c ****        err = wc_ecc_mulmod_ex(u2, mQ, mQ, curve->Af, curve->prime, 0, key->heap);
8096:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
8097:../src/wolfcrypt/src/ecc.c ****        err = wc_ecc_point_add(mG, mQ, mG, curve->prime);
8098:../src/wolfcrypt/src/ecc.c **** #else
8099:../src/wolfcrypt/src/ecc.c **** #ifndef ECC_SHAMIR
8100:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 10458                             		.loc 2 8100 8
 10459 03a0 EC A5                   		mov.L	[r10], r5
 10460 03a2 61 05                   		cmp	#0, r5
 10461 03a4 3B FC 00                		bne	.L724
 10462                             	.LBB72:
8101:../src/wolfcrypt/src/ecc.c ****     {
8102:../src/wolfcrypt/src/ecc.c ****         mp_digit mp = 0;
 10463                             		.loc 2 8102 18
 10464 03a7 F9 A6 20 00             		mov.L	#0, 128[r10]
8103:../src/wolfcrypt/src/ecc.c **** 
8104:../src/wolfcrypt/src/ecc.c ****         if (!mp_iszero(u1)) {
 10465                             		.loc 2 8104 14
 10466 03ab ED A5 04                		mov.L	16[r10], r5
 10467 03ae EC 55                   		mov.L	[r5], r5
 10468                             		.loc 2 8104 12
 10469 03b0 61 05                   		cmp	#0, r5
 10470 03b2 3A 96 00                		beq	.L725
8105:../src/wolfcrypt/src/ecc.c ****             /* compute u1*mG + u2*mQ = mG */
8106:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_mulmod_ex(u1, mG, mG, curve->Af, curve->prime, 0,
 10471                             		.loc 2 8106 19
 10472 03b5 ED A2 13                		mov.L	76[r10], r2
 10473 03b8 ED A3 13                		mov.L	76[r10], r3
 10474                             		.loc 2 8106 53
 10475 03bb ED A5 1F                		mov.L	124[r10], r5
 10476                             		.loc 2 8106 19
 10477 03be A8 D4                   		mov.L	8[r5], r4
 10478                             		.loc 2 8106 64
 10479 03c0 ED A5 1F                		mov.L	124[r10], r5
 10480                             		.loc 2 8106 19
 10481 03c3 A8 59                   		mov.L	4[r5], r1
 10482 03c5 A8 6D                   		mov.L	4[r6], r5
 10483 03c7 A9 5D                   		mov.L	20[r5], r5
 10484 03c9 A0 85                   		mov.L	r5, 8[r0]
 10485 03cb 3E 01 00                		mov.L	#0, 4[r0]
 10486 03ce E3 01                   		mov.L	r1, [r0]
 10487 03d0 ED A1 04                		mov.L	16[r10], r1
 10488 03d3 05 00 00 00             		bsr	_wc_ecc_mulmod_ex
 10489 03d7 E3 A1                   		mov.L	r1, [r10]
8107:../src/wolfcrypt/src/ecc.c ****                                                                      key->heap);
8108:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY) {
 10490                             		.loc 2 8108 16
 10491 03d9 EC A5                   		mov.L	[r10], r5
 10492 03db 61 05                   		cmp	#0, r5
 10493 03dd 21 26                   		bne	.L726
8109:../src/wolfcrypt/src/ecc.c ****                 err = wc_ecc_mulmod_ex(u2, mQ, mQ, curve->Af, curve->prime, 0,
 10494                             		.loc 2 8109 23
 10495 03df ED A2 14                		mov.L	80[r10], r2
 10496 03e2 ED A3 14                		mov.L	80[r10], r3
 10497                             		.loc 2 8109 57
 10498 03e5 ED A5 1F                		mov.L	124[r10], r5
 10499                             		.loc 2 8109 23
 10500 03e8 A8 D4                   		mov.L	8[r5], r4
 10501                             		.loc 2 8109 68
 10502 03ea ED A5 1F                		mov.L	124[r10], r5
 10503                             		.loc 2 8109 23
 10504 03ed A8 59                   		mov.L	4[r5], r1
 10505 03ef A8 6D                   		mov.L	4[r6], r5
 10506 03f1 A9 5D                   		mov.L	20[r5], r5
 10507 03f3 A0 85                   		mov.L	r5, 8[r0]
 10508 03f5 3E 01 00                		mov.L	#0, 4[r0]
 10509 03f8 E3 01                   		mov.L	r1, [r0]
 10510 03fa ED A1 05                		mov.L	20[r10], r1
 10511 03fd 05 00 00 00             		bsr	_wc_ecc_mulmod_ex
 10512 0401 E3 A1                   		mov.L	r1, [r10]
 10513                             	.L726:
8110:../src/wolfcrypt/src/ecc.c ****                                                                      key->heap);
8111:../src/wolfcrypt/src/ecc.c ****             }
8112:../src/wolfcrypt/src/ecc.c **** 
8113:../src/wolfcrypt/src/ecc.c ****             /* find the montgomery mp */
8114:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
 10514                             		.loc 2 8114 16
 10515 0403 EC A5                   		mov.L	[r10], r5
 10516 0405 61 05                   		cmp	#0, r5
 10517 0407 21 15                   		bne	.L727
8115:../src/wolfcrypt/src/ecc.c ****                 err = mp_montgomery_setup(curve->prime, &mp);
 10518                             		.loc 2 8115 48
 10519 0409 ED A5 1F                		mov.L	124[r10], r5
 10520 040c A8 5C                   		mov.L	4[r5], r4
 10521                             		.loc 2 8115 23
 10522 040e 72 A5 80 00             		add	#0x80, r10, r5
 10523 0412 EF 52                   		mov.L	r5, r2
 10524 0414 EF 41                   		mov.L	r4, r1
 10525 0416 05 00 00 00             		bsr	_sp_mont_setup
 10526 041a E3 A1                   		mov.L	r1, [r10]
 10527                             	.L727:
8116:../src/wolfcrypt/src/ecc.c **** 
8117:../src/wolfcrypt/src/ecc.c ****             /* add them */
8118:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
 10528                             		.loc 2 8118 16
 10529 041c EC A5                   		mov.L	[r10], r5
 10530 041e 61 05                   		cmp	#0, r5
 10531 0420 21 65                   		bne	.L729
8119:../src/wolfcrypt/src/ecc.c ****                 err = ecc_projective_add_point_safe(mQ, mG, mG, curve->Af,
 10532                             		.loc 2 8119 23
 10533 0422 ED A1 14                		mov.L	80[r10], r1
 10534 0425 ED A2 13                		mov.L	76[r10], r2
 10535 0428 ED A3 13                		mov.L	76[r10], r3
 10536                             		.loc 2 8119 70
 10537 042b ED A5 1F                		mov.L	124[r10], r5
 10538                             		.loc 2 8119 23
 10539 042e A8 D4                   		mov.L	8[r5], r4
8120:../src/wolfcrypt/src/ecc.c ****                                                         curve->prime, mp, NULL);
 10540                             		.loc 2 8120 62
 10541 0430 ED A5 1F                		mov.L	124[r10], r5
8119:../src/wolfcrypt/src/ecc.c ****                 err = ecc_projective_add_point_safe(mQ, mG, mG, curve->Af,
 10542                             		.loc 2 8119 23
 10543 0433 A8 5D                   		mov.L	4[r5], r5
 10544 0435 ED AB 20                		mov.L	128[r10], r11
 10545 0438 3E 02 00                		mov.L	#0, 8[r0]
 10546 043b E7 0B 01                		mov.L	r11, 4[r0]
 10547 043e E3 05                   		mov.L	r5, [r0]
 10548 0440 05 00 00 00             		bsr	_ecc_projective_add_point_safe
 10549 0444 E3 A1                   		mov.L	r1, [r10]
 10550 0446 2E 3F                   		bra	.L729
 10551                             	.L725:
8121:../src/wolfcrypt/src/ecc.c ****         }
8122:../src/wolfcrypt/src/ecc.c ****         else {
8123:../src/wolfcrypt/src/ecc.c ****             /* compute 0*mG + u2*mQ = mG */
8124:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_mulmod_ex(u2, mQ, mG, curve->Af, curve->prime, 0,
 10552                             		.loc 2 8124 19
 10553 0448 ED A2 14                		mov.L	80[r10], r2
 10554 044b ED A3 13                		mov.L	76[r10], r3
 10555                             		.loc 2 8124 53
 10556 044e ED A5 1F                		mov.L	124[r10], r5
 10557                             		.loc 2 8124 19
 10558 0451 A8 D4                   		mov.L	8[r5], r4
 10559                             		.loc 2 8124 64
 10560 0453 ED A5 1F                		mov.L	124[r10], r5
 10561                             		.loc 2 8124 19
 10562 0456 A8 59                   		mov.L	4[r5], r1
 10563 0458 A8 6D                   		mov.L	4[r6], r5
 10564 045a A9 5D                   		mov.L	20[r5], r5
 10565 045c A0 85                   		mov.L	r5, 8[r0]
 10566 045e 3E 01 00                		mov.L	#0, 4[r0]
 10567 0461 E3 01                   		mov.L	r1, [r0]
 10568 0463 ED A1 05                		mov.L	20[r10], r1
 10569 0466 05 00 00 00             		bsr	_wc_ecc_mulmod_ex
 10570 046a E3 A1                   		mov.L	r1, [r10]
8125:../src/wolfcrypt/src/ecc.c ****                                                                      key->heap);
8126:../src/wolfcrypt/src/ecc.c ****             /* find the montgomery mp */
8127:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
 10571                             		.loc 2 8127 16
 10572 046c EC A5                   		mov.L	[r10], r5
 10573 046e 61 05                   		cmp	#0, r5
 10574 0470 21 15                   		bne	.L729
8128:../src/wolfcrypt/src/ecc.c ****                 err = mp_montgomery_setup(curve->prime, &mp);
 10575                             		.loc 2 8128 48
 10576 0472 ED A5 1F                		mov.L	124[r10], r5
 10577 0475 A8 5C                   		mov.L	4[r5], r4
 10578                             		.loc 2 8128 23
 10579 0477 72 A5 80 00             		add	#0x80, r10, r5
 10580 047b EF 52                   		mov.L	r5, r2
 10581 047d EF 41                   		mov.L	r4, r1
 10582 047f 05 00 00 00             		bsr	_sp_mont_setup
 10583 0483 E3 A1                   		mov.L	r1, [r10]
 10584                             		.balign 8,3,1
 10585                             	.L729:
8129:../src/wolfcrypt/src/ecc.c ****         }
8130:../src/wolfcrypt/src/ecc.c **** 
8131:../src/wolfcrypt/src/ecc.c ****         /* reduce */
8132:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 10586                             		.loc 2 8132 12
 10587 0485 EC A5                   		mov.L	[r10], r5
 10588 0487 61 05                   		cmp	#0, r5
 10589 0489 21 17                   		bne	.L724
8133:../src/wolfcrypt/src/ecc.c ****             err = ecc_map(mG, curve->prime, mp);
 10590                             		.loc 2 8133 19
 10591 048b ED A4 13                		mov.L	76[r10], r4
 10592                             		.loc 2 8133 36
 10593 048e ED A5 1F                		mov.L	124[r10], r5
 10594                             		.loc 2 8133 19
 10595 0491 A8 5D                   		mov.L	4[r5], r5
 10596 0493 ED A3 20                		mov.L	128[r10], r3
 10597 0496 EF 52                   		mov.L	r5, r2
 10598 0498 EF 41                   		mov.L	r4, r1
 10599 049a 05 00 00 00             		bsr	_ecc_map
 10600 049e E3 A1                   		mov.L	r1, [r10]
 10601                             	.L724:
 10602                             	.LBE72:
8134:../src/wolfcrypt/src/ecc.c ****     }
8135:../src/wolfcrypt/src/ecc.c **** #else
8136:../src/wolfcrypt/src/ecc.c ****     /* use Shamir's trick to compute u1*mG + u2*mQ using half the doubles */
8137:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
8138:../src/wolfcrypt/src/ecc.c ****         err = ecc_mul2add(mG, u1, mQ, u2, mG, curve->Af, curve->prime,
8139:../src/wolfcrypt/src/ecc.c ****                                                                      key->heap);
8140:../src/wolfcrypt/src/ecc.c ****     }
8141:../src/wolfcrypt/src/ecc.c **** #endif /* ECC_SHAMIR */
8142:../src/wolfcrypt/src/ecc.c **** #endif /* FREESCALE_LTC_ECC */
8143:../src/wolfcrypt/src/ecc.c ****    /* v = X_x1 mod n */
8144:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 10603                             		.loc 2 8144 7
 10604 04a0 EC A5                   		mov.L	[r10], r5
 10605 04a2 61 05                   		cmp	#0, r5
 10606 04a4 21 19                   		bne	.L731
8145:../src/wolfcrypt/src/ecc.c ****        err = mp_mod(mG->x, curve->order, v);
 10607                             		.loc 2 8145 23
 10608 04a6 ED A5 13                		mov.L	76[r10], r5
 10609 04a9 EF 54                   		mov.L	r5, r4
 10610                             		.loc 2 8145 33
 10611 04ab ED A5 1F                		mov.L	124[r10], r5
 10612 04ae A8 DD                   		mov.L	12[r5], r5
 10613                             		.loc 2 8145 14
 10614 04b0 ED A3 02                		mov.L	8[r10], r3
 10615 04b3 EF 52                   		mov.L	r5, r2
 10616 04b5 EF 41                   		mov.L	r4, r1
 10617 04b7 05 00 00 00             		bsr	_sp_mod
 10618 04bb E3 A1                   		mov.L	r1, [r10]
 10619                             	.L731:
8146:../src/wolfcrypt/src/ecc.c **** 
8147:../src/wolfcrypt/src/ecc.c ****    /* does v == r */
8148:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 10620                             		.loc 2 8148 7
 10621 04bd EC A5                   		mov.L	[r10], r5
 10622 04bf 61 05                   		cmp	#0, r5
 10623 04c1 21 16                   		bne	.L732
8149:../src/wolfcrypt/src/ecc.c ****        if (mp_cmp(v, r) == MP_EQ)
 10624                             		.loc 2 8149 12
 10625 04c3 ED A2 21                		mov.L	132[r10], r2
 10626 04c6 ED A1 02                		mov.L	8[r10], r1
 10627 04c9 05 00 00 00             		bsr	_sp_cmp
 10628 04cd EF 15                   		mov.L	r1, r5
 10629                             		.loc 2 8149 11
 10630 04cf 61 05                   		cmp	#0, r5
 10631 04d1 1E                      		bne	.L732
8150:../src/wolfcrypt/src/ecc.c ****            *res = 1;
 10632                             		.loc 2 8150 17
 10633 04d2 EC 65                   		mov.L	[r6], r5
 10634 04d4 F8 56 01                		mov.L	#1, [r5]
 10635                             	.L732:
8151:../src/wolfcrypt/src/ecc.c ****    }
8152:../src/wolfcrypt/src/ecc.c **** 
8153:../src/wolfcrypt/src/ecc.c ****    /* cleanup */
8154:../src/wolfcrypt/src/ecc.c ****    wc_ecc_del_point_ex(mG, key->heap);
 10636                             		.loc 2 8154 4
 10637 04d7 ED A4 13                		mov.L	76[r10], r4
 10638 04da A8 6D                   		mov.L	4[r6], r5
 10639 04dc A9 5D                   		mov.L	20[r5], r5
 10640 04de EF 52                   		mov.L	r5, r2
 10641 04e0 EF 41                   		mov.L	r4, r1
 10642 04e2 05 00 00 00             		bsr	_wc_ecc_del_point_ex
8155:../src/wolfcrypt/src/ecc.c ****    wc_ecc_del_point_ex(mQ, key->heap);
 10643                             		.loc 2 8155 4
 10644 04e6 ED A4 14                		mov.L	80[r10], r4
 10645 04e9 A8 6D                   		mov.L	4[r6], r5
 10646 04eb A9 5D                   		mov.L	20[r5], r5
 10647 04ed EF 52                   		mov.L	r5, r2
 10648 04ef EF 41                   		mov.L	r4, r1
 10649 04f1 05 00 00 00             		bsr	_wc_ecc_del_point_ex
8156:../src/wolfcrypt/src/ecc.c **** 
8157:../src/wolfcrypt/src/ecc.c ****    mp_clear(e);
 10650                             		.loc 2 8157 4
 10651 04f5 ED A1 0A                		mov.L	40[r10], r1
 10652 04f8 05 00 00 00             		bsr	_sp_clear
8158:../src/wolfcrypt/src/ecc.c ****    if (did_init) {
 10653                             		.loc 2 8158 7
 10654 04fc ED A5 01                		mov.L	4[r10], r5
 10655 04ff 61 05                   		cmp	#0, r5
 10656 0501 20 1E                   		beq	.L733
8159:../src/wolfcrypt/src/ecc.c ****        mp_clear(v);
 10657                             		.loc 2 8159 8
 10658 0503 ED A1 02                		mov.L	8[r10], r1
 10659 0506 05 00 00 00             		bsr	_sp_clear
8160:../src/wolfcrypt/src/ecc.c ****        mp_clear(w);
 10660                             		.loc 2 8160 8
 10661 050a ED A1 03                		mov.L	12[r10], r1
 10662 050d 05 00 00 00             		bsr	_sp_clear
8161:../src/wolfcrypt/src/ecc.c ****        mp_clear(u1);
 10663                             		.loc 2 8161 8
 10664 0511 ED A1 04                		mov.L	16[r10], r1
 10665 0514 05 00 00 00             		bsr	_sp_clear
8162:../src/wolfcrypt/src/ecc.c ****        mp_clear(u2);
 10666                             		.loc 2 8162 8
 10667 0518 ED A1 05                		mov.L	20[r10], r1
 10668 051b 05 00 00 00             		bsr	_sp_clear
 10669                             	.L733:
 10670                             	.LBB73:
8163:../src/wolfcrypt/src/ecc.c ****    }
8164:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8165:../src/wolfcrypt/src/ecc.c ****    XFREE(u2, key->heap, DYNAMIC_TYPE_ECC);
 10671                             		.loc 2 8165 4
 10672 051f ED A5 05                		mov.L	20[r10], r5
 10673 0522 E7 A5 0D                		mov.L	r5, 52[r10]
 10674 0525 ED A5 0D                		mov.L	52[r10], r5
 10675 0528 61 05                   		cmp	#0, r5
 10676 052a 10                      		beq	.L734
 10677                             		.loc 2 8165 4 is_stmt 0 discriminator 1
 10678 052b ED A1 0D                		mov.L	52[r10], r1
 10679 052e 05 00 00 00             		bsr	_wolfSSL_Free
 10680                             	.L734:
 10681                             	.LBE73:
 10682                             	.LBB74:
8166:../src/wolfcrypt/src/ecc.c ****    XFREE(u1, key->heap, DYNAMIC_TYPE_ECC);
 10683                             		.loc 2 8166 4 is_stmt 1
 10684 0532 ED A5 04                		mov.L	16[r10], r5
 10685 0535 E7 A5 0E                		mov.L	r5, 56[r10]
 10686 0538 ED A5 0E                		mov.L	56[r10], r5
 10687 053b 61 05                   		cmp	#0, r5
 10688 053d 10                      		beq	.L735
 10689                             		.loc 2 8166 4 is_stmt 0 discriminator 1
 10690 053e ED A1 0E                		mov.L	56[r10], r1
 10691 0541 05 00 00 00             		bsr	_wolfSSL_Free
 10692                             	.L735:
 10693                             	.LBE74:
 10694                             	.LBB75:
8167:../src/wolfcrypt/src/ecc.c ****    XFREE(w, key->heap, DYNAMIC_TYPE_ECC);
 10695                             		.loc 2 8167 4 is_stmt 1
 10696 0545 ED A5 03                		mov.L	12[r10], r5
 10697 0548 E7 A5 0F                		mov.L	r5, 60[r10]
 10698 054b ED A5 0F                		mov.L	60[r10], r5
 10699 054e 61 05                   		cmp	#0, r5
 10700 0550 10                      		beq	.L736
 10701                             		.loc 2 8167 4 is_stmt 0 discriminator 1
 10702 0551 ED A1 0F                		mov.L	60[r10], r1
 10703 0554 05 00 00 00             		bsr	_wolfSSL_Free
 10704                             	.L736:
 10705                             	.LBE75:
 10706                             	.LBB76:
8168:../src/wolfcrypt/src/ecc.c ****    XFREE(v, key->heap, DYNAMIC_TYPE_ECC);
 10707                             		.loc 2 8168 4 is_stmt 1
 10708 0558 ED A5 02                		mov.L	8[r10], r5
 10709 055b E7 A5 10                		mov.L	r5, 64[r10]
 10710 055e ED A5 10                		mov.L	64[r10], r5
 10711 0561 61 05                   		cmp	#0, r5
 10712 0563 10                      		beq	.L737
 10713                             		.loc 2 8168 4 is_stmt 0 discriminator 1
 10714 0564 ED A1 10                		mov.L	64[r10], r1
 10715 0567 05 00 00 00             		bsr	_wolfSSL_Free
 10716                             	.L737:
 10717                             	.LBE76:
 10718                             	.LBB77:
8169:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
8170:../src/wolfcrypt/src/ecc.c ****    XFREE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
 10719                             		.loc 2 8170 4 is_stmt 1
 10720 056b ED A5 07                		mov.L	28[r10], r5
 10721 056e E7 A5 11                		mov.L	r5, 68[r10]
 10722 0571 ED A5 11                		mov.L	68[r10], r5
 10723 0574 61 05                   		cmp	#0, r5
 10724 0576 10                      		beq	.L738
 10725                             		.loc 2 8170 4 is_stmt 0 discriminator 1
 10726 0577 ED A1 11                		mov.L	68[r10], r1
 10727 057a 05 00 00 00             		bsr	_wolfSSL_Free
 10728                             	.L738:
 10729                             	.LBE77:
8171:../src/wolfcrypt/src/ecc.c **** #endif
8172:../src/wolfcrypt/src/ecc.c **** #endif
8173:../src/wolfcrypt/src/ecc.c **** 
8174:../src/wolfcrypt/src/ecc.c ****    wc_ecc_curve_free(curve);
 10730                             		.loc 2 8174 4 is_stmt 1
 10731 057e ED A5 1F                		mov.L	124[r10], r5
 10732 0581 EF 51                   		mov.L	r5, r1
 10733 0583 05 00 00 00             		bsr	_wc_ecc_curve_free
 10734                             	.LBB78:
8175:../src/wolfcrypt/src/ecc.c ****    FREE_CURVE_SPECS();
 10735                             		.loc 2 8175 4
 10736 0587 ED A5 08                		mov.L	32[r10], r5
 10737 058a E7 A5 12                		mov.L	r5, 72[r10]
 10738 058d ED A5 12                		mov.L	72[r10], r5
 10739 0590 61 05                   		cmp	#0, r5
 10740 0592 10                      		beq	.L739
 10741                             		.loc 2 8175 4 is_stmt 0 discriminator 1
 10742 0593 ED A1 12                		mov.L	72[r10], r1
 10743 0596 05 00 00 00             		bsr	_wolfSSL_Free
 10744                             	.L739:
 10745                             	.LBE78:
8176:../src/wolfcrypt/src/ecc.c **** 
8177:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH || FREESCALE_LTC_ECC */
8178:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ATECC508A */
8179:../src/wolfcrypt/src/ecc.c **** 
8180:../src/wolfcrypt/src/ecc.c ****    (void)keySz;
8181:../src/wolfcrypt/src/ecc.c ****    (void)hashlen;
8182:../src/wolfcrypt/src/ecc.c **** 
8183:../src/wolfcrypt/src/ecc.c ****    return err;
 10746                             		.loc 2 8183 11 is_stmt 1
 10747 059a EC A5                   		mov.L	[r10], r5
 10748                             		.balign 8,3,1
 10749                             	.L740:
8184:../src/wolfcrypt/src/ecc.c **** }
 10750                             		.loc 2 8184 1 discriminator 1
 10751 059c EF 51                   		mov.L	r5, r1
 10752 059e 3F 6B 30                		rtsd	#192, r6-r11
 10753                             	.LFE111:
 10755 05a1 FD 70 40 00 00 00 80    		.section	.text.wc_ecc_import_point_der_ex,"ax",@progbits
 10756                             		.global	_wc_ecc_import_point_der_ex
 10758                             	_wc_ecc_import_point_der_ex:
 10759                             	.LFB112:
8185:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_STM32_PKA */
8186:../src/wolfcrypt/src/ecc.c **** #endif /* WOLF_CRYPTO_CB_ONLY_ECC */
8187:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_VERIFY */
8188:../src/wolfcrypt/src/ecc.c **** 
8189:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_KEY_IMPORT
8190:../src/wolfcrypt/src/ecc.c **** /* import point from der
8191:../src/wolfcrypt/src/ecc.c ****  * if shortKeySize != 0 then keysize is always (inLen-1)>>1 */
8192:../src/wolfcrypt/src/ecc.c **** int wc_ecc_import_point_der_ex(const byte* in, word32 inLen,
8193:../src/wolfcrypt/src/ecc.c ****                                const int curve_idx, ecc_point* point,
8194:../src/wolfcrypt/src/ecc.c ****                                int shortKeySize)
8195:../src/wolfcrypt/src/ecc.c **** {
 10760                             		.loc 2 8195 1
 10761 0000 7E AA                   		push.l	r10
 10762                             	.LCFI178:
 10763 0002 71 0A E0                		add	#-32, r0, r10
 10764                             	.LCFI179:
 10765 0005 71 A0 F8                		add	#-8, r10, r0
 10766                             	.LCFI180:
 10767 0008 E7 A1 03                		mov.L	r1, 12[r10]
 10768 000b E7 A2 04                		mov.L	r2, 16[r10]
 10769 000e E7 A3 05                		mov.L	r3, 20[r10]
 10770 0011 E7 A4 06                		mov.L	r4, 24[r10]
8196:../src/wolfcrypt/src/ecc.c ****     int err = 0;
 10771                             		.loc 2 8196 9
 10772 0014 F8 A6 00                		mov.L	#0, [r10]
8197:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
8198:../src/wolfcrypt/src/ecc.c ****     int compressed = 0;
8199:../src/wolfcrypt/src/ecc.c **** #endif
8200:../src/wolfcrypt/src/ecc.c ****     int keysize;
8201:../src/wolfcrypt/src/ecc.c ****     byte pointType;
8202:../src/wolfcrypt/src/ecc.c **** 
8203:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_COMP_KEY
8204:../src/wolfcrypt/src/ecc.c ****     (void)shortKeySize;
8205:../src/wolfcrypt/src/ecc.c **** #endif
8206:../src/wolfcrypt/src/ecc.c **** 
8207:../src/wolfcrypt/src/ecc.c ****     if (in == NULL || point == NULL || (curve_idx < 0) ||
 10773                             		.loc 2 8207 8
 10774 0017 ED A5 03                		mov.L	12[r10], r5
 10775 001a 61 05                   		cmp	#0, r5
 10776 001c 20 1C                   		beq	.L742
 10777                             		.loc 2 8207 20 discriminator 1
 10778 001e ED A5 06                		mov.L	24[r10], r5
 10779 0021 61 05                   		cmp	#0, r5
 10780 0023 20 15                   		beq	.L742
 10781                             		.loc 2 8207 37 discriminator 2
 10782 0025 ED A5 05                		mov.L	20[r10], r5
 10783 0028 61 05                   		cmp	#0, r5
 10784 002a 29 0E                   		blt	.L742
8208:../src/wolfcrypt/src/ecc.c ****         (wc_ecc_is_valid_idx(curve_idx) == 0))
 10785                             		.loc 2 8208 10 discriminator 3
 10786 002c ED A1 05                		mov.L	20[r10], r1
 10787 002f 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 10788 0033 EF 15                   		mov.L	r1, r5
8207:../src/wolfcrypt/src/ecc.c ****         (wc_ecc_is_valid_idx(curve_idx) == 0))
 10789                             		.loc 2 8207 56 discriminator 3
 10790 0035 61 05                   		cmp	#0, r5
 10791 0037 18                      		bne	.L743
 10792                             		.balign 8,3,2
 10793                             	.L742:
8209:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 10794                             		.loc 2 8209 16
 10795 0038 FB 5A 56 FF             		mov.L	#-170, r5
 10796 003c 38 29 01                		bra	.L744
 10797                             	.L743:
8210:../src/wolfcrypt/src/ecc.c **** 
8211:../src/wolfcrypt/src/ecc.c ****     /* must be odd */
8212:../src/wolfcrypt/src/ecc.c ****     if ((inLen & 1) == 0) {
 10798                             		.loc 2 8212 16
 10799 003f ED A5 04                		mov.L	16[r10], r5
 10800 0042 64 15                   		and	#1, r5
 10801                             		.loc 2 8212 8
 10802 0044 61 05                   		cmp	#0, r5
 10803 0046 18                      		bne	.L745
8213:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 10804                             		.loc 2 8213 16
 10805 0047 FB 5A 56 FF             		mov.L	#-170, r5
 10806 004b 38 1A 01                		bra	.L744
 10807                             	.L745:
8214:../src/wolfcrypt/src/ecc.c ****     }
8215:../src/wolfcrypt/src/ecc.c **** 
8216:../src/wolfcrypt/src/ecc.c ****     /* clear if previously allocated */
8217:../src/wolfcrypt/src/ecc.c ****     mp_clear(point->x);
 10808                             		.loc 2 8217 19
 10809 004e ED A5 06                		mov.L	24[r10], r5
 10810                             		.loc 2 8217 5
 10811 0051 EF 51                   		mov.L	r5, r1
 10812 0053 05 00 00 00             		bsr	_sp_clear
8218:../src/wolfcrypt/src/ecc.c ****     mp_clear(point->y);
 10813                             		.loc 2 8218 19
 10814 0057 ED A5 06                		mov.L	24[r10], r5
 10815 005a 72 55 10 03             		add	#0x310, r5
 10816                             		.loc 2 8218 5
 10817 005e EF 51                   		mov.L	r5, r1
 10818 0060 05 00 00 00             		bsr	_sp_clear
8219:../src/wolfcrypt/src/ecc.c ****     mp_clear(point->z);
 10819                             		.loc 2 8219 19
 10820 0064 ED A5 06                		mov.L	24[r10], r5
 10821 0067 72 55 20 06             		add	#0x620, r5
 10822                             		.loc 2 8219 5
 10823 006b EF 51                   		mov.L	r5, r1
 10824 006d 05 00 00 00             		bsr	_sp_clear
8220:../src/wolfcrypt/src/ecc.c **** 
8221:../src/wolfcrypt/src/ecc.c ****     /* init point */
8222:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
8223:../src/wolfcrypt/src/ecc.c ****     point->x = (mp_int*)&point->xyz[0];
8224:../src/wolfcrypt/src/ecc.c ****     point->y = (mp_int*)&point->xyz[1];
8225:../src/wolfcrypt/src/ecc.c ****     point->z = (mp_int*)&point->xyz[2];
8226:../src/wolfcrypt/src/ecc.c ****     alt_fp_init(point->x);
8227:../src/wolfcrypt/src/ecc.c ****     alt_fp_init(point->y);
8228:../src/wolfcrypt/src/ecc.c ****     alt_fp_init(point->z);
8229:../src/wolfcrypt/src/ecc.c **** #else
8230:../src/wolfcrypt/src/ecc.c ****     err = mp_init_multi(point->x, point->y, point->z, NULL, NULL, NULL);
 10825                             		.loc 2 8230 30
 10826 0071 ED A1 06                		mov.L	24[r10], r1
 10827                             		.loc 2 8230 40
 10828 0074 ED A5 06                		mov.L	24[r10], r5
 10829 0077 72 52 10 03             		add	#0x310, r5, r2
 10830                             		.loc 2 8230 50
 10831 007b ED A5 06                		mov.L	24[r10], r5
 10832 007e 72 55 20 06             		add	#0x620, r5
 10833                             		.loc 2 8230 11
 10834 0082 3E 01 00                		mov.L	#0, 4[r0]
 10835 0085 F8 06 00                		mov.L	#0, [r0]
 10836 0088 66 04                   		mov.L	#0, r4
 10837 008a EF 53                   		mov.L	r5, r3
 10838 008c 05 00 00 00             		bsr	_sp_init_multi
 10839 0090 E3 A1                   		mov.L	r1, [r10]
8231:../src/wolfcrypt/src/ecc.c **** #endif
8232:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY)
 10840                             		.loc 2 8232 8
 10841 0092 EC A5                   		mov.L	[r10], r5
 10842 0094 61 05                   		cmp	#0, r5
 10843 0096 17                      		beq	.L746
8233:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 10844                             		.loc 2 8233 16
 10845 0097 FB 56 83                		mov.L	#-125, r5
 10846 009a 38 CB 00                		bra	.L744
 10847                             	.L746:
8234:../src/wolfcrypt/src/ecc.c **** 
8235:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
8236:../src/wolfcrypt/src/ecc.c **** 
8237:../src/wolfcrypt/src/ecc.c ****     /* check for point type (4, 2, or 3) */
8238:../src/wolfcrypt/src/ecc.c ****     pointType = in[0];
 10848                             		.loc 2 8238 15
 10849 009d ED A5 03                		mov.L	12[r10], r5
 10850 00a0 CC 55                   		mov.B	[r5], r5
 10851 00a2 C7 A5 04                		mov.B	r5, 4[r10]
8239:../src/wolfcrypt/src/ecc.c ****     if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&
 10852                             		.loc 2 8239 8
 10853 00a5 59 A5 04                		movu.B	4[r10], r5
 10854 00a8 61 45                   		cmp	#4, r5
 10855 00aa 20 16                   		beq	.L747
 10856                             		.loc 2 8239 39 discriminator 1
 10857 00ac 59 A5 04                		movu.B	4[r10], r5
 10858 00af 61 25                   		cmp	#2, r5
 10859 00b1 20 0F                   		beq	.L747
 10860                             		.loc 2 8239 75 discriminator 2
 10861 00b3 59 A5 04                		movu.B	4[r10], r5
 10862 00b6 61 35                   		cmp	#3, r5
 10863 00b8 10                      		beq	.L747
8240:../src/wolfcrypt/src/ecc.c ****                                          pointType != ECC_POINT_COMP_ODD) {
8241:../src/wolfcrypt/src/ecc.c ****         err = ASN_PARSE_E;
 10864                             		.loc 2 8241 13
 10865 00b9 F8 AA 74 FF             		mov.L	#-140, [r10]
 10866 00bd FC 13 00                		.balign 8,3,3
 10867                             	.L747:
8242:../src/wolfcrypt/src/ecc.c ****     }
8243:../src/wolfcrypt/src/ecc.c **** 
8244:../src/wolfcrypt/src/ecc.c ****     if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {
 10868                             		.loc 2 8244 8
 10869 00c0 59 A5 04                		movu.B	4[r10], r5
 10870 00c3 61 25                   		cmp	#2, r5
 10871 00c5 17                      		beq	.L748
 10872                             		.loc 2 8244 42 discriminator 1
 10873 00c6 59 A5 04                		movu.B	4[r10], r5
 10874 00c9 61 35                   		cmp	#3, r5
 10875 00cb 1D                      		bne	.L749
 10876                             	.L748:
8245:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
8246:../src/wolfcrypt/src/ecc.c ****         compressed = 1;
8247:../src/wolfcrypt/src/ecc.c **** #else
8248:../src/wolfcrypt/src/ecc.c ****         err = NOT_COMPILED_IN;
 10877                             		.loc 2 8248 13
 10878 00cc F8 AA 52 FF             		mov.L	#-174, [r10]
 10879                             	.L749:
8249:../src/wolfcrypt/src/ecc.c **** #endif
8250:../src/wolfcrypt/src/ecc.c ****     }
8251:../src/wolfcrypt/src/ecc.c **** 
8252:../src/wolfcrypt/src/ecc.c ****     /* adjust to skip first byte */
8253:../src/wolfcrypt/src/ecc.c ****     inLen -= 1;
 10880                             		.loc 2 8253 11
 10881 00d0 ED A5 04                		mov.L	16[r10], r5
 10882 00d3 60 15                   		sub	#1, r5
 10883 00d5 E7 A5 04                		mov.L	r5, 16[r10]
8254:../src/wolfcrypt/src/ecc.c ****     in += 1;
 10884                             		.loc 2 8254 8
 10885 00d8 ED A5 03                		mov.L	12[r10], r5
 10886 00db 62 15                   		add	#1, r5
 10887 00dd E7 A5 03                		mov.L	r5, 12[r10]
8255:../src/wolfcrypt/src/ecc.c **** 
8256:../src/wolfcrypt/src/ecc.c ****     /* calculate key size based on inLen / 2 if uncompressed or shortKeySize
8257:../src/wolfcrypt/src/ecc.c ****      * is true */
8258:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
8259:../src/wolfcrypt/src/ecc.c ****     keysize = compressed && !shortKeySize ? inLen : inLen>>1;
8260:../src/wolfcrypt/src/ecc.c **** #else
8261:../src/wolfcrypt/src/ecc.c ****     keysize = inLen>>1;
 10888                             		.loc 2 8261 20
 10889 00e0 ED A5 04                		mov.L	16[r10], r5
 10890 00e3 68 15                   		shlr	#1, r5
 10891                             		.loc 2 8261 13
 10892 00e5 E7 A5 02                		mov.L	r5, 8[r10]
8262:../src/wolfcrypt/src/ecc.c **** #endif
8263:../src/wolfcrypt/src/ecc.c **** 
8264:../src/wolfcrypt/src/ecc.c ****     /* read data */
8265:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 10893                             		.loc 2 8265 8
 10894 00e8 EC A5                   		mov.L	[r10], r5
 10895 00ea 61 05                   		cmp	#0, r5
 10896 00ec 21 15                   		bne	.L750
8266:../src/wolfcrypt/src/ecc.c ****         err = mp_read_unsigned_bin(point->x, in, keysize);
 10897                             		.loc 2 8266 41
 10898 00ee ED A5 06                		mov.L	24[r10], r5
 10899                             		.loc 2 8266 15
 10900 00f1 ED A4 02                		mov.L	8[r10], r4
 10901 00f4 EF 43                   		mov.L	r4, r3
 10902 00f6 ED A2 03                		mov.L	12[r10], r2
 10903 00f9 EF 51                   		mov.L	r5, r1
 10904 00fb 05 00 00 00             		bsr	_sp_read_unsigned_bin
 10905 00ff E3 A1                   		mov.L	r1, [r10]
 10906                             	.L750:
8267:../src/wolfcrypt/src/ecc.c **** 
8268:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
8269:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY && compressed == 1) {   /* build y */
8270:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_HAVE_SP_ECC)
8271:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_SP_NO_256
8272:../src/wolfcrypt/src/ecc.c ****         if (curve_idx != ECC_CUSTOM_IDX &&
8273:../src/wolfcrypt/src/ecc.c ****                                       ecc_sets[curve_idx].id == ECC_SECP256R1) {
8274:../src/wolfcrypt/src/ecc.c ****             sp_ecc_uncompress_256(point->x, pointType, point->y);
8275:../src/wolfcrypt/src/ecc.c ****         }
8276:../src/wolfcrypt/src/ecc.c ****         else
8277:../src/wolfcrypt/src/ecc.c ****         #endif
8278:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_SP_384
8279:../src/wolfcrypt/src/ecc.c ****         if (curve_idx != ECC_CUSTOM_IDX &&
8280:../src/wolfcrypt/src/ecc.c ****                                       ecc_sets[curve_idx].id == ECC_SECP384R1) {
8281:../src/wolfcrypt/src/ecc.c ****             sp_ecc_uncompress_384(point->x, pointType, point->y);
8282:../src/wolfcrypt/src/ecc.c ****         }
8283:../src/wolfcrypt/src/ecc.c ****         else
8284:../src/wolfcrypt/src/ecc.c ****         #endif
8285:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_SP_521
8286:../src/wolfcrypt/src/ecc.c ****         if (curve_idx != ECC_CUSTOM_IDX &&
8287:../src/wolfcrypt/src/ecc.c ****                                       ecc_sets[curve_idx].id == ECC_SECP521R1) {
8288:../src/wolfcrypt/src/ecc.c ****             sp_ecc_uncompress_521(point->x, pointType, point->y);
8289:../src/wolfcrypt/src/ecc.c ****         }
8290:../src/wolfcrypt/src/ecc.c ****         else
8291:../src/wolfcrypt/src/ecc.c ****         #endif
8292:../src/wolfcrypt/src/ecc.c ****     #endif
8293:../src/wolfcrypt/src/ecc.c ****     #if !defined(WOLFSSL_SP_MATH)
8294:../src/wolfcrypt/src/ecc.c ****         {
8295:../src/wolfcrypt/src/ecc.c ****             int did_init = 0;
8296:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_SMALL_STACK
8297:../src/wolfcrypt/src/ecc.c ****             mp_int* t1 = NULL;
8298:../src/wolfcrypt/src/ecc.c ****             mp_int* t2 = NULL;
8299:../src/wolfcrypt/src/ecc.c ****         #else
8300:../src/wolfcrypt/src/ecc.c ****             mp_int t1[1], t2[1];
8301:../src/wolfcrypt/src/ecc.c ****         #endif
8302:../src/wolfcrypt/src/ecc.c ****             DECLARE_CURVE_SPECS(3);
8303:../src/wolfcrypt/src/ecc.c **** 
8304:../src/wolfcrypt/src/ecc.c ****             ALLOC_CURVE_SPECS(3, err);
8305:../src/wolfcrypt/src/ecc.c **** 
8306:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_SMALL_STACK
8307:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY) {
8308:../src/wolfcrypt/src/ecc.c ****                 t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL,
8309:../src/wolfcrypt/src/ecc.c ****                                       DYNAMIC_TYPE_BIGINT);
8310:../src/wolfcrypt/src/ecc.c ****                 if (t1 == NULL) {
8311:../src/wolfcrypt/src/ecc.c ****                     err = MEMORY_E;
8312:../src/wolfcrypt/src/ecc.c ****                 }
8313:../src/wolfcrypt/src/ecc.c ****             }
8314:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY) {
8315:../src/wolfcrypt/src/ecc.c ****                 t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL,
8316:../src/wolfcrypt/src/ecc.c ****                                       DYNAMIC_TYPE_BIGINT);
8317:../src/wolfcrypt/src/ecc.c ****                 if (t2 == NULL) {
8318:../src/wolfcrypt/src/ecc.c ****                     err = MEMORY_E;
8319:../src/wolfcrypt/src/ecc.c ****                 }
8320:../src/wolfcrypt/src/ecc.c ****             }
8321:../src/wolfcrypt/src/ecc.c ****         #endif
8322:../src/wolfcrypt/src/ecc.c **** 
8323:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY) {
8324:../src/wolfcrypt/src/ecc.c ****                 if (mp_init_multi(t1, t2, NULL, NULL, NULL, NULL) != MP_OKAY)
8325:../src/wolfcrypt/src/ecc.c ****                     err = MEMORY_E;
8326:../src/wolfcrypt/src/ecc.c ****                 else
8327:../src/wolfcrypt/src/ecc.c ****                     did_init = 1;
8328:../src/wolfcrypt/src/ecc.c ****             }
8329:../src/wolfcrypt/src/ecc.c **** 
8330:../src/wolfcrypt/src/ecc.c ****             /* load curve info */
8331:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
8332:../src/wolfcrypt/src/ecc.c ****                 err = wc_ecc_curve_load(&ecc_sets[curve_idx], &curve,
8333:../src/wolfcrypt/src/ecc.c ****                     (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF |
8334:../src/wolfcrypt/src/ecc.c ****                         ECC_CURVE_FIELD_BF));
8335:../src/wolfcrypt/src/ecc.c **** 
8336:../src/wolfcrypt/src/ecc.c ****         #if defined(WOLFSSL_CUSTOM_CURVES) && \
8337:../src/wolfcrypt/src/ecc.c ****             defined(WOLFSSL_VALIDATE_ECC_IMPORT)
8338:../src/wolfcrypt/src/ecc.c ****             /* validate prime is prime for custom curves */
8339:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY && curve_idx == ECC_CUSTOM_IDX) {
8340:../src/wolfcrypt/src/ecc.c ****                 int isPrime = MP_NO;
8341:../src/wolfcrypt/src/ecc.c ****                 err = mp_prime_is_prime(curve->prime, 8, &isPrime);
8342:../src/wolfcrypt/src/ecc.c ****                 if (err == MP_OKAY && isPrime == MP_NO)
8343:../src/wolfcrypt/src/ecc.c ****                     err = MP_VAL;
8344:../src/wolfcrypt/src/ecc.c ****             }
8345:../src/wolfcrypt/src/ecc.c ****         #endif
8346:../src/wolfcrypt/src/ecc.c **** 
8347:../src/wolfcrypt/src/ecc.c ****             /* compute x^3 */
8348:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
8349:../src/wolfcrypt/src/ecc.c ****                 err = mp_sqr(point->x, t1);
8350:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
8351:../src/wolfcrypt/src/ecc.c ****                 err = mp_mulmod(t1, point->x, curve->prime, t1);
8352:../src/wolfcrypt/src/ecc.c **** 
8353:../src/wolfcrypt/src/ecc.c ****             /* compute x^3 + a*x */
8354:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
8355:../src/wolfcrypt/src/ecc.c ****                 err = mp_mulmod(curve->Af, point->x, curve->prime, t2);
8356:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
8357:../src/wolfcrypt/src/ecc.c ****                 err = mp_add(t1, t2, t1);
8358:../src/wolfcrypt/src/ecc.c **** 
8359:../src/wolfcrypt/src/ecc.c ****             /* compute x^3 + a*x + b */
8360:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
8361:../src/wolfcrypt/src/ecc.c ****                 err = mp_add(t1, curve->Bf, t1);
8362:../src/wolfcrypt/src/ecc.c **** 
8363:../src/wolfcrypt/src/ecc.c ****             /* compute sqrt(x^3 + a*x + b) */
8364:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
8365:../src/wolfcrypt/src/ecc.c ****                 err = mp_sqrtmod_prime(t1, curve->prime, t2);
8366:../src/wolfcrypt/src/ecc.c **** 
8367:../src/wolfcrypt/src/ecc.c ****             /* adjust y */
8368:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY) {
8369:../src/wolfcrypt/src/ecc.c ****                 if ((mp_isodd(t2) == MP_YES &&
8370:../src/wolfcrypt/src/ecc.c ****                                             pointType == ECC_POINT_COMP_ODD) ||
8371:../src/wolfcrypt/src/ecc.c ****                     (mp_isodd(t2) == MP_NO &&
8372:../src/wolfcrypt/src/ecc.c ****                                             pointType == ECC_POINT_COMP_EVEN)) {
8373:../src/wolfcrypt/src/ecc.c ****                     err = mp_mod(t2, curve->prime, point->y);
8374:../src/wolfcrypt/src/ecc.c ****                 }
8375:../src/wolfcrypt/src/ecc.c ****                 else {
8376:../src/wolfcrypt/src/ecc.c ****                     err = mp_submod(curve->prime, t2, curve->prime, point->y);
8377:../src/wolfcrypt/src/ecc.c ****                 }
8378:../src/wolfcrypt/src/ecc.c ****             }
8379:../src/wolfcrypt/src/ecc.c **** 
8380:../src/wolfcrypt/src/ecc.c ****             if (did_init) {
8381:../src/wolfcrypt/src/ecc.c ****                 mp_clear(t2);
8382:../src/wolfcrypt/src/ecc.c ****                 mp_clear(t1);
8383:../src/wolfcrypt/src/ecc.c ****             }
8384:../src/wolfcrypt/src/ecc.c **** 
8385:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_SMALL_STACK
8386:../src/wolfcrypt/src/ecc.c ****             if (t1 != NULL) {
8387:../src/wolfcrypt/src/ecc.c ****                 XFREE(t1, NULL, DYNAMIC_TYPE_BIGINT);
8388:../src/wolfcrypt/src/ecc.c ****             }
8389:../src/wolfcrypt/src/ecc.c ****             if (t2 != NULL) {
8390:../src/wolfcrypt/src/ecc.c ****                 XFREE(t2, NULL, DYNAMIC_TYPE_BIGINT);
8391:../src/wolfcrypt/src/ecc.c ****             }
8392:../src/wolfcrypt/src/ecc.c ****         #endif
8393:../src/wolfcrypt/src/ecc.c **** 
8394:../src/wolfcrypt/src/ecc.c ****             wc_ecc_curve_free(curve);
8395:../src/wolfcrypt/src/ecc.c ****             FREE_CURVE_SPECS();
8396:../src/wolfcrypt/src/ecc.c ****         }
8397:../src/wolfcrypt/src/ecc.c ****     #else
8398:../src/wolfcrypt/src/ecc.c ****         {
8399:../src/wolfcrypt/src/ecc.c ****             err = WC_KEY_SIZE_E;
8400:../src/wolfcrypt/src/ecc.c ****         }
8401:../src/wolfcrypt/src/ecc.c ****     #endif
8402:../src/wolfcrypt/src/ecc.c ****     }
8403:../src/wolfcrypt/src/ecc.c **** #endif
8404:../src/wolfcrypt/src/ecc.c **** 
8405:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 10907                             		.loc 2 8405 8
 10908 0101 EC A5                   		mov.L	[r10], r5
 10909 0103 61 05                   		cmp	#0, r5
 10910 0105 21 1E                   		bne	.L751
8406:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
8407:../src/wolfcrypt/src/ecc.c ****         if (compressed == 0)
8408:../src/wolfcrypt/src/ecc.c **** #endif
8409:../src/wolfcrypt/src/ecc.c ****             err = mp_read_unsigned_bin(point->y, in + keysize, keysize);
 10911                             		.loc 2 8409 45
 10912 0107 ED A5 06                		mov.L	24[r10], r5
 10913 010a 72 51 10 03             		add	#0x310, r5, r1
 10914                             		.loc 2 8409 19
 10915 010e ED A5 02                		mov.L	8[r10], r5
 10916 0111 ED A4 03                		mov.L	12[r10], r4
 10917 0114 4B 45                   		add	r4, r5
 10918 0116 ED A4 02                		mov.L	8[r10], r4
 10919 0119 EF 43                   		mov.L	r4, r3
 10920 011b EF 52                   		mov.L	r5, r2
 10921 011d 05 00 00 00             		bsr	_sp_read_unsigned_bin
 10922 0121 E3 A1                   		mov.L	r1, [r10]
 10923                             	.L751:
8410:../src/wolfcrypt/src/ecc.c ****      }
8411:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 10924                             		.loc 2 8411 8
 10925 0123 EC A5                   		mov.L	[r10], r5
 10926 0125 61 05                   		cmp	#0, r5
 10927 0127 21 13                   		bne	.L752
8412:../src/wolfcrypt/src/ecc.c ****         err = mp_set(point->z, 1);
 10928                             		.loc 2 8412 27
 10929 0129 ED A5 06                		mov.L	24[r10], r5
 10930 012c 72 55 20 06             		add	#0x620, r5
 10931                             		.loc 2 8412 15
 10932 0130 66 12                   		mov.L	#1, r2
 10933 0132 EF 51                   		mov.L	r5, r1
 10934 0134 05 00 00 00             		bsr	_sp_set
 10935 0138 E3 A1                   		mov.L	r1, [r10]
 10936                             	.L752:
8413:../src/wolfcrypt/src/ecc.c **** 
8414:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY) {
 10937                             		.loc 2 8414 8
 10938 013a EC A5                   		mov.L	[r10], r5
 10939 013c 61 05                   		cmp	#0, r5
 10940 013e 20 25                   		beq	.L753
8415:../src/wolfcrypt/src/ecc.c ****         mp_clear(point->x);
 10941                             		.loc 2 8415 23
 10942 0140 ED A5 06                		mov.L	24[r10], r5
 10943                             		.loc 2 8415 9
 10944 0143 EF 51                   		mov.L	r5, r1
 10945 0145 05 00 00 00             		bsr	_sp_clear
8416:../src/wolfcrypt/src/ecc.c ****         mp_clear(point->y);
 10946                             		.loc 2 8416 23
 10947 0149 ED A5 06                		mov.L	24[r10], r5
 10948 014c 72 55 10 03             		add	#0x310, r5
 10949                             		.loc 2 8416 9
 10950 0150 EF 51                   		mov.L	r5, r1
 10951 0152 05 00 00 00             		bsr	_sp_clear
8417:../src/wolfcrypt/src/ecc.c ****         mp_clear(point->z);
 10952                             		.loc 2 8417 23
 10953 0156 ED A5 06                		mov.L	24[r10], r5
 10954 0159 72 55 20 06             		add	#0x620, r5
 10955                             		.loc 2 8417 9
 10956 015d EF 51                   		mov.L	r5, r1
 10957 015f 05 00 00 00             		bsr	_sp_clear
 10958                             	.L753:
8418:../src/wolfcrypt/src/ecc.c ****     }
8419:../src/wolfcrypt/src/ecc.c **** 
8420:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
8421:../src/wolfcrypt/src/ecc.c **** 
8422:../src/wolfcrypt/src/ecc.c ****     return err;
 10959                             		.loc 2 8422 12
 10960 0163 EC A5                   		mov.L	[r10], r5
 10961                             		.balign 8,3,1
 10962                             	.L744:
8423:../src/wolfcrypt/src/ecc.c **** }
 10963                             		.loc 2 8423 1
 10964 0165 EF 51                   		mov.L	r5, r1
 10965 0167 3F AA 0B                		rtsd	#44, r10-r10
 10966                             	.LFE112:
 10968 016a 74 10 01 00 00 00       		.section	.text.wc_ecc_import_point_der,"ax",@progbits
 10969                             		.global	_wc_ecc_import_point_der
 10971                             	_wc_ecc_import_point_der:
 10972                             	.LFB113:
8424:../src/wolfcrypt/src/ecc.c **** 
8425:../src/wolfcrypt/src/ecc.c **** /* function for backwards compatiblity with previous implementations */
8426:../src/wolfcrypt/src/ecc.c **** int wc_ecc_import_point_der(const byte* in, word32 inLen, const int curve_idx,
8427:../src/wolfcrypt/src/ecc.c ****                             ecc_point* point)
8428:../src/wolfcrypt/src/ecc.c **** {
 10973                             		.loc 2 8428 1
 10974 0000 7E AA                   		push.l	r10
 10975                             	.LCFI181:
 10976 0002 71 0A F0                		add	#-16, r0, r10
 10977                             	.LCFI182:
 10978 0005 71 A0 FC                		add	#-4, r10, r0
 10979                             	.LCFI183:
 10980 0008 E3 A1                   		mov.L	r1, [r10]
 10981 000a E7 A2 01                		mov.L	r2, 4[r10]
 10982 000d E7 A3 02                		mov.L	r3, 8[r10]
 10983 0010 E7 A4 03                		mov.L	r4, 12[r10]
8429:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_import_point_der_ex(in, inLen, curve_idx, point, 1);
 10984                             		.loc 2 8429 12
 10985 0013 F8 06 01                		mov.L	#1, [r0]
 10986 0016 ED A4 03                		mov.L	12[r10], r4
 10987 0019 ED A3 02                		mov.L	8[r10], r3
 10988 001c ED A2 01                		mov.L	4[r10], r2
 10989 001f EC A1                   		mov.L	[r10], r1
 10990 0021 05 00 00 00             		bsr	_wc_ecc_import_point_der_ex
 10991 0025 EF 15                   		mov.L	r1, r5
8430:../src/wolfcrypt/src/ecc.c **** }
 10992                             		.loc 2 8430 1
 10993 0027 EF 51                   		mov.L	r5, r1
 10994 0029 3F AA 06                		rtsd	#24, r10-r10
 10995                             	.LFE113:
 10997                             		.section	.text.wc_ecc_export_point_der_ex,"ax",@progbits
 10998                             		.global	_wc_ecc_export_point_der_ex
 11000                             	_wc_ecc_export_point_der_ex:
 11001                             	.LFB114:
8431:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_KEY_IMPORT */
8432:../src/wolfcrypt/src/ecc.c **** 
8433:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_KEY_EXPORT
8434:../src/wolfcrypt/src/ecc.c **** /* export point to der */
8435:../src/wolfcrypt/src/ecc.c **** 
8436:../src/wolfcrypt/src/ecc.c **** int wc_ecc_export_point_der_ex(const int curve_idx, ecc_point* point, byte* out,
8437:../src/wolfcrypt/src/ecc.c ****                                word32* outLen, int compressed)
8438:../src/wolfcrypt/src/ecc.c **** {
 11002                             		.loc 2 8438 1
 11003 0000 7E AA                   		push.l	r10
 11004                             	.LCFI184:
 11005 0002 71 0A EC                		add	#-20, r0, r10
 11006                             	.LCFI185:
 11007 0005 EF A0                   		mov.L	r10, r0
 11008 0007 75 45 1C                		mov.L	#28, r5
 11009 000a 4B A5                   		add	r10, r5
 11010 000c E3 A1                   		mov.L	r1, [r10]
 11011 000e E7 A2 01                		mov.L	r2, 4[r10]
 11012 0011 E7 A3 02                		mov.L	r3, 8[r10]
 11013 0014 E7 A4 03                		mov.L	r4, 12[r10]
8439:../src/wolfcrypt/src/ecc.c ****     if (compressed == 0)
 11014                             		.loc 2 8439 8
 11015 0017 EC 55                   		mov.L	[r5], r5
 11016 0019 61 05                   		cmp	#0, r5
 11017 001b 21 14                   		bne	.L757
8440:../src/wolfcrypt/src/ecc.c ****         return wc_ecc_export_point_der(curve_idx, point, out, outLen);
 11018                             		.loc 2 8440 16
 11019 001d ED A4 03                		mov.L	12[r10], r4
 11020 0020 ED A3 02                		mov.L	8[r10], r3
 11021 0023 ED A2 01                		mov.L	4[r10], r2
 11022 0026 EC A1                   		mov.L	[r10], r1
 11023 0028 05 00 00 00             		bsr	_wc_ecc_export_point_der
 11024 002c EF 15                   		mov.L	r1, r5
 11025 002e 0D                      		bra	.L758
 11026                             	.L757:
8441:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
8442:../src/wolfcrypt/src/ecc.c ****     else
8443:../src/wolfcrypt/src/ecc.c ****         return wc_ecc_export_point_der_compressed(curve_idx, point, out, outLen);
8444:../src/wolfcrypt/src/ecc.c **** #else
8445:../src/wolfcrypt/src/ecc.c ****     return NOT_COMPILED_IN;
 11027                             		.loc 2 8445 12
 11028 002f FB 5A 52 FF             		mov.L	#-174, r5
 11029                             	.L758:
8446:../src/wolfcrypt/src/ecc.c **** #endif
8447:../src/wolfcrypt/src/ecc.c **** }
 11030                             		.loc 2 8447 1
 11031 0033 EF 51                   		mov.L	r5, r1
 11032 0035 3F AA 06                		rtsd	#24, r10-r10
 11033                             	.LFE114:
 11035                             		.section	.text.wc_ecc_export_point_der,"ax",@progbits
 11036                             		.global	_wc_ecc_export_point_der
 11038                             	_wc_ecc_export_point_der:
 11039                             	.LFB115:
8448:../src/wolfcrypt/src/ecc.c **** 
8449:../src/wolfcrypt/src/ecc.c **** int wc_ecc_export_point_der(const int curve_idx, ecc_point* point, byte* out,
8450:../src/wolfcrypt/src/ecc.c ****                             word32* outLen)
8451:../src/wolfcrypt/src/ecc.c **** {
 11040                             		.loc 2 8451 1
 11041 0000 7E AA                   		push.l	r10
 11042                             	.LCFI186:
 11043 0002 7E A6                   		push.l	r6
 11044                             	.LCFI187:
 11045 0004 71 0A E0                		add	#-32, r0, r10
 11046                             	.LCFI188:
 11047 0007 EF A0                   		mov.L	r10, r0
 11048 0009 E7 A1 04                		mov.L	r1, 16[r10]
 11049 000c E7 A2 05                		mov.L	r2, 20[r10]
 11050 000f E7 A3 06                		mov.L	r3, 24[r10]
 11051 0012 E7 A4 07                		mov.L	r4, 28[r10]
8452:../src/wolfcrypt/src/ecc.c ****     int    ret = MP_OKAY;
 11052                             		.loc 2 8452 12
 11053 0015 F8 A6 00                		mov.L	#0, [r10]
8453:../src/wolfcrypt/src/ecc.c ****     word32 numlen;
8454:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8455:../src/wolfcrypt/src/ecc.c ****     byte*  buf;
8456:../src/wolfcrypt/src/ecc.c **** #else
8457:../src/wolfcrypt/src/ecc.c ****     byte   buf[ECC_BUFSIZE];
8458:../src/wolfcrypt/src/ecc.c **** #endif
8459:../src/wolfcrypt/src/ecc.c **** 
8460:../src/wolfcrypt/src/ecc.c ****     if ((curve_idx < 0) || (wc_ecc_is_valid_idx(curve_idx) == 0))
 11054                             		.loc 2 8460 8
 11055 0018 ED A5 04                		mov.L	16[r10], r5
 11056 001b 61 05                   		cmp	#0, r5
 11057 001d 29 0E                   		blt	.L760
 11058                             		.loc 2 8460 29 discriminator 1
 11059 001f ED A1 04                		mov.L	16[r10], r1
 11060 0022 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 11061 0026 EF 15                   		mov.L	r1, r5
 11062                             		.loc 2 8460 25 discriminator 1
 11063 0028 61 05                   		cmp	#0, r5
 11064 002a 18                      		bne	.L761
 11065                             	.L760:
8461:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 11066                             		.loc 2 8461 16
 11067 002b FB 5A 56 FF             		mov.L	#-170, r5
 11068 002f 38 8B 01                		bra	.L762
 11069                             	.L761:
8462:../src/wolfcrypt/src/ecc.c **** 
8463:../src/wolfcrypt/src/ecc.c ****     numlen = ecc_sets[curve_idx].size;
 11070                             		.loc 2 8463 33
 11071 0032 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 11072 0038 ED A5 04                		mov.L	16[r10], r5
 11073 003b 75 15 34                		mul	#52, r5
 11074 003e 4B 45                   		add	r4, r5
 11075 0040 EC 55                   		mov.L	[r5], r5
 11076                             		.loc 2 8463 12
 11077 0042 E7 A5 01                		mov.L	r5, 4[r10]
8464:../src/wolfcrypt/src/ecc.c **** 
8465:../src/wolfcrypt/src/ecc.c ****     /* return length needed only */
8466:../src/wolfcrypt/src/ecc.c ****     if (point != NULL && out == NULL && outLen != NULL) {
 11078                             		.loc 2 8466 8
 11079 0045 ED A5 05                		mov.L	20[r10], r5
 11080 0048 61 05                   		cmp	#0, r5
 11081 004a 20 24                   		beq	.L763
 11082                             		.loc 2 8466 23 discriminator 1
 11083 004c ED A5 06                		mov.L	24[r10], r5
 11084 004f 61 05                   		cmp	#0, r5
 11085 0051 21 1D                   		bne	.L763
 11086                             		.loc 2 8466 38 discriminator 2
 11087 0053 ED A5 07                		mov.L	28[r10], r5
 11088 0056 61 05                   		cmp	#0, r5
 11089 0058 20 16                   		beq	.L763
8467:../src/wolfcrypt/src/ecc.c ****         *outLen = 1 + 2*numlen;
 11090                             		.loc 2 8467 24
 11091 005a ED A5 01                		mov.L	4[r10], r5
 11092 005d 4B 55                   		add	r5, r5
 11093                             		.loc 2 8467 21
 11094 005f 71 54 01                		add	#1, r5, r4
 11095                             		.loc 2 8467 17
 11096 0062 ED A5 07                		mov.L	28[r10], r5
 11097 0065 E3 54                   		mov.L	r4, [r5]
8468:../src/wolfcrypt/src/ecc.c ****         return LENGTH_ONLY_E;
 11098                             		.loc 2 8468 16
 11099 0067 FB 5A 36 FF             		mov.L	#-202, r5
 11100 006b 38 4F 01                		bra	.L762
 11101                             	.L763:
8469:../src/wolfcrypt/src/ecc.c ****     }
8470:../src/wolfcrypt/src/ecc.c **** 
8471:../src/wolfcrypt/src/ecc.c ****     if (point == NULL || out == NULL || outLen == NULL)
 11102                             		.loc 2 8471 8
 11103 006e ED A5 05                		mov.L	20[r10], r5
 11104 0071 61 05                   		cmp	#0, r5
 11105 0073 20 0E                   		beq	.L764
 11106                             		.loc 2 8471 23 discriminator 1
 11107 0075 ED A5 06                		mov.L	24[r10], r5
 11108 0078 61 05                   		cmp	#0, r5
 11109 007a 17                      		beq	.L764
 11110                             		.loc 2 8471 38 discriminator 2
 11111 007b ED A5 07                		mov.L	28[r10], r5
 11112 007e 61 05                   		cmp	#0, r5
 11113 0080 18                      		bne	.L765
 11114                             	.L764:
8472:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 11115                             		.loc 2 8472 16
 11116 0081 FB 5A 56 FF             		mov.L	#-170, r5
 11117 0085 38 35 01                		bra	.L762
 11118                             	.L765:
8473:../src/wolfcrypt/src/ecc.c **** 
8474:../src/wolfcrypt/src/ecc.c ****     if (*outLen < (1 + 2*numlen)) {
 11119                             		.loc 2 8474 9
 11120 0088 ED A5 07                		mov.L	28[r10], r5
 11121 008b EC 54                   		mov.L	[r5], r4
 11122                             		.loc 2 8474 25
 11123 008d ED A5 01                		mov.L	4[r10], r5
 11124 0090 4B 55                   		add	r5, r5
 11125                             		.loc 2 8474 22
 11126 0092 62 15                   		add	#1, r5
 11127                             		.loc 2 8474 8
 11128 0094 47 54                   		cmp	r5, r4
 11129 0096 22 16                   		bgeu	.L766
8475:../src/wolfcrypt/src/ecc.c ****         *outLen = 1 + 2*numlen;
 11130                             		.loc 2 8475 24
 11131 0098 ED A5 01                		mov.L	4[r10], r5
 11132 009b 4B 55                   		add	r5, r5
 11133                             		.loc 2 8475 21
 11134 009d 71 54 01                		add	#1, r5, r4
 11135                             		.loc 2 8475 17
 11136 00a0 ED A5 07                		mov.L	28[r10], r5
 11137 00a3 E3 54                   		mov.L	r4, [r5]
8476:../src/wolfcrypt/src/ecc.c ****         return BUFFER_E;
 11138                             		.loc 2 8476 16
 11139 00a5 FB 5A 7C FF             		mov.L	#-132, r5
 11140 00a9 38 11 01                		bra	.L762
 11141                             	.L766:
8477:../src/wolfcrypt/src/ecc.c ****     }
8478:../src/wolfcrypt/src/ecc.c **** 
8479:../src/wolfcrypt/src/ecc.c ****     /* Sanity check the ordinates' sizes. */
8480:../src/wolfcrypt/src/ecc.c ****     if (((word32)mp_unsigned_bin_size(point->x) > numlen) ||
 11142                             		.loc 2 8480 44
 11143 00ac ED A5 05                		mov.L	20[r10], r5
 11144                             		.loc 2 8480 18
 11145 00af EF 51                   		mov.L	r5, r1
 11146 00b1 05 00 00 00             		bsr	_sp_unsigned_bin_size
 11147 00b5 EF 15                   		mov.L	r1, r5
 11148                             		.loc 2 8480 8
 11149 00b7 ED A4 01                		mov.L	4[r10], r4
 11150 00ba 47 54                   		cmp	r5, r4
 11151 00bc 23 18                   		bltu	.L767
8481:../src/wolfcrypt/src/ecc.c ****         ((word32)mp_unsigned_bin_size(point->y) > numlen)) {
 11152                             		.loc 2 8481 44 discriminator 1
 11153 00be ED A5 05                		mov.L	20[r10], r5
 11154 00c1 72 55 10 03             		add	#0x310, r5
 11155                             		.loc 2 8481 18 discriminator 1
 11156 00c5 EF 51                   		mov.L	r5, r1
 11157 00c7 05 00 00 00             		bsr	_sp_unsigned_bin_size
 11158 00cb EF 15                   		mov.L	r1, r5
8480:../src/wolfcrypt/src/ecc.c ****         ((word32)mp_unsigned_bin_size(point->y) > numlen)) {
 11159                             		.loc 2 8480 59 discriminator 1
 11160 00cd ED A4 01                		mov.L	4[r10], r4
 11161 00d0 47 54                   		cmp	r5, r4
 11162 00d2 22 09                   		bgeu	.L768
 11163                             	.L767:
8482:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 11164                             		.loc 2 8482 16
 11165 00d4 FB 5A 56 FF             		mov.L	#-170, r5
 11166 00d8 38 E2 00                		bra	.L762
 11167                             	.L768:
8483:../src/wolfcrypt/src/ecc.c ****     }
8484:../src/wolfcrypt/src/ecc.c **** 
8485:../src/wolfcrypt/src/ecc.c ****     /* store byte point type */
8486:../src/wolfcrypt/src/ecc.c ****     out[0] = ECC_POINT_UNCOMP;
 11168                             		.loc 2 8486 12
 11169 00db ED A5 06                		mov.L	24[r10], r5
 11170 00de F8 54 04                		mov.B	#4, [r5]
8487:../src/wolfcrypt/src/ecc.c **** 
8488:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8489:../src/wolfcrypt/src/ecc.c ****     buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);
 11171                             		.loc 2 8489 18
 11172 00e1 FB 1A 01 01             		mov.L	#0x101, r1
 11173 00e5 05 00 00 00             		bsr	_wolfSSL_Malloc
 11174 00e9 E7 A1 02                		mov.L	r1, 8[r10]
8490:../src/wolfcrypt/src/ecc.c ****     if (buf == NULL)
 11175                             		.loc 2 8490 8
 11176 00ec ED A5 02                		mov.L	8[r10], r5
 11177 00ef 61 05                   		cmp	#0, r5
 11178 00f1 1F                      		bne	.L769
8491:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 11179                             		.loc 2 8491 16
 11180 00f2 FB 56 83                		mov.L	#-125, r5
 11181 00f5 38 C5 00                		bra	.L762
 11182                             	.L769:
8492:../src/wolfcrypt/src/ecc.c **** #endif
8493:../src/wolfcrypt/src/ecc.c **** 
8494:../src/wolfcrypt/src/ecc.c ****     /* pad and store x */
8495:../src/wolfcrypt/src/ecc.c ****     XMEMSET(buf, 0, ECC_BUFSIZE);
 11183                             		.loc 2 8495 5
 11184 00f8 FB 3A 01 01             		mov.L	#0x101, r3
 11185 00fc 66 02                   		mov.L	#0, r2
 11186 00fe ED A1 02                		mov.L	8[r10], r1
 11187 0101 05 00 00 00             		bsr	_memset
8496:../src/wolfcrypt/src/ecc.c ****     ret = mp_to_unsigned_bin(point->x, buf +
 11188                             		.loc 2 8496 35
 11189 0105 ED A6 05                		mov.L	20[r10], r6
8497:../src/wolfcrypt/src/ecc.c ****                                  (numlen - mp_unsigned_bin_size(point->x)));
 11190                             		.loc 2 8497 70
 11191 0108 ED A5 05                		mov.L	20[r10], r5
 11192                             		.loc 2 8497 44
 11193 010b EF 51                   		mov.L	r5, r1
 11194 010d 05 00 00 00             		bsr	_sp_unsigned_bin_size
 11195 0111 EF 15                   		mov.L	r1, r5
 11196                             		.loc 2 8497 42
 11197 0113 ED A4 01                		mov.L	4[r10], r4
 11198 0116 FF 05 54                		sub	r5, r4, r5
8496:../src/wolfcrypt/src/ecc.c ****     ret = mp_to_unsigned_bin(point->x, buf +
 11199                             		.loc 2 8496 11
 11200 0119 ED A4 02                		mov.L	8[r10], r4
 11201 011c 4B 45                   		add	r4, r5
 11202 011e EF 52                   		mov.L	r5, r2
 11203 0120 EF 61                   		mov.L	r6, r1
 11204 0122 05 00 00 00             		bsr	_sp_to_unsigned_bin
 11205 0126 E3 A1                   		mov.L	r1, [r10]
8498:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_OKAY)
 11206                             		.loc 2 8498 8
 11207 0128 EC A5                   		mov.L	[r10], r5
 11208 012a 61 05                   		cmp	#0, r5
 11209 012c 21 75                   		bne	.L774
8499:../src/wolfcrypt/src/ecc.c ****         goto done;
8500:../src/wolfcrypt/src/ecc.c ****     XMEMCPY(out+1, buf, numlen);
 11210                             		.loc 2 8500 5
 11211 012e ED A5 06                		mov.L	24[r10], r5
 11212 0131 62 15                   		add	#1, r5
 11213 0133 ED A3 01                		mov.L	4[r10], r3
 11214 0136 ED A2 02                		mov.L	8[r10], r2
 11215 0139 EF 51                   		mov.L	r5, r1
 11216 013b 05 00 00 00             		bsr	_memcpy
8501:../src/wolfcrypt/src/ecc.c **** 
8502:../src/wolfcrypt/src/ecc.c ****     /* pad and store y */
8503:../src/wolfcrypt/src/ecc.c ****     XMEMSET(buf, 0, ECC_BUFSIZE);
 11217                             		.loc 2 8503 5
 11218 013f FB 3A 01 01             		mov.L	#0x101, r3
 11219 0143 66 02                   		mov.L	#0, r2
 11220 0145 ED A1 02                		mov.L	8[r10], r1
 11221 0148 05 00 00 00             		bsr	_memset
8504:../src/wolfcrypt/src/ecc.c ****     ret = mp_to_unsigned_bin(point->y, buf +
 11222                             		.loc 2 8504 35
 11223 014c ED A5 05                		mov.L	20[r10], r5
 11224 014f 72 56 10 03             		add	#0x310, r5, r6
8505:../src/wolfcrypt/src/ecc.c ****                                  (numlen - mp_unsigned_bin_size(point->y)));
 11225                             		.loc 2 8505 70
 11226 0153 ED A5 05                		mov.L	20[r10], r5
 11227 0156 72 55 10 03             		add	#0x310, r5
 11228                             		.loc 2 8505 44
 11229 015a EF 51                   		mov.L	r5, r1
 11230 015c 05 00 00 00             		bsr	_sp_unsigned_bin_size
 11231 0160 EF 15                   		mov.L	r1, r5
 11232                             		.loc 2 8505 42
 11233 0162 ED A4 01                		mov.L	4[r10], r4
 11234 0165 FF 05 54                		sub	r5, r4, r5
8504:../src/wolfcrypt/src/ecc.c ****     ret = mp_to_unsigned_bin(point->y, buf +
 11235                             		.loc 2 8504 11
 11236 0168 ED A4 02                		mov.L	8[r10], r4
 11237 016b 4B 45                   		add	r4, r5
 11238 016d EF 52                   		mov.L	r5, r2
 11239 016f EF 61                   		mov.L	r6, r1
 11240 0171 05 00 00 00             		bsr	_sp_to_unsigned_bin
 11241 0175 E3 A1                   		mov.L	r1, [r10]
8506:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_OKAY)
 11242                             		.loc 2 8506 8
 11243 0177 EC A5                   		mov.L	[r10], r5
 11244 0179 61 05                   		cmp	#0, r5
 11245 017b 21 29                   		bne	.L775
8507:../src/wolfcrypt/src/ecc.c ****         goto done;
8508:../src/wolfcrypt/src/ecc.c ****     XMEMCPY(out+1+numlen, buf, numlen);
 11246                             		.loc 2 8508 5
 11247 017d ED A5 01                		mov.L	4[r10], r5
 11248 0180 62 15                   		add	#1, r5
 11249 0182 ED A4 06                		mov.L	24[r10], r4
 11250 0185 4B 45                   		add	r4, r5
 11251 0187 ED A3 01                		mov.L	4[r10], r3
 11252 018a ED A2 02                		mov.L	8[r10], r2
 11253 018d EF 51                   		mov.L	r5, r1
 11254 018f 05 00 00 00             		bsr	_memcpy
8509:../src/wolfcrypt/src/ecc.c **** 
8510:../src/wolfcrypt/src/ecc.c ****     *outLen = 1 + 2*numlen;
 11255                             		.loc 2 8510 20
 11256 0193 ED A5 01                		mov.L	4[r10], r5
 11257 0196 4B 55                   		add	r5, r5
 11258                             		.loc 2 8510 17
 11259 0198 71 54 01                		add	#1, r5, r4
 11260                             		.loc 2 8510 13
 11261 019b ED A5 07                		mov.L	28[r10], r5
 11262 019e E3 54                   		mov.L	r4, [r5]
 11263 01a0 0D                      		bra	.L771
 11264                             	.L774:
8499:../src/wolfcrypt/src/ecc.c ****     XMEMCPY(out+1, buf, numlen);
 11265                             		.loc 2 8499 9
 11266 01a1 03                      		nop
 11267 01a2 2E 03                   		bra	.L771
 11268                             	.L775:
8507:../src/wolfcrypt/src/ecc.c ****         goto done;
 11269                             		.loc 2 8507 9
 11270 01a4 03                      		nop
 11271                             	.L771:
 11272                             	.LBB79:
8511:../src/wolfcrypt/src/ecc.c **** 
8512:../src/wolfcrypt/src/ecc.c **** done:
8513:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8514:../src/wolfcrypt/src/ecc.c ****     XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);
 11273                             		.loc 2 8514 5
 11274 01a5 ED A5 02                		mov.L	8[r10], r5
 11275 01a8 E7 A5 03                		mov.L	r5, 12[r10]
 11276 01ab ED A5 03                		mov.L	12[r10], r5
 11277 01ae 61 05                   		cmp	#0, r5
 11278 01b0 10                      		beq	.L773
 11279                             		.loc 2 8514 5 is_stmt 0 discriminator 1
 11280 01b1 ED A1 03                		mov.L	12[r10], r1
 11281 01b4 05 00 00 00             		bsr	_wolfSSL_Free
 11282                             	.L773:
 11283                             	.LBE79:
8515:../src/wolfcrypt/src/ecc.c **** #endif
8516:../src/wolfcrypt/src/ecc.c **** 
8517:../src/wolfcrypt/src/ecc.c ****     return ret;
 11284                             		.loc 2 8517 12 is_stmt 1
 11285 01b8 EC A5                   		mov.L	[r10], r5
 11286                             		.balign 8,3,1
 11287                             	.L762:
8518:../src/wolfcrypt/src/ecc.c **** }
 11288                             		.loc 2 8518 1
 11289 01ba EF 51                   		mov.L	r5, r1
 11290 01bc 71 00 20                		add	#32, r0
 11291 01bf 7E B6                   		pop	r6
 11292 01c1 7E BA                   		pop	r10
 11293 01c3 02                      		rts
 11294                             	.LFE115:
 11296 01c4 76 10 01 00             		.section C,"a",@progbits
 11297                             		.p2align 2
 11298                             	.LC44:
 11299 0adc 50 75 62 6C 69 63 20 6B 		.string	"Public key x/y invalid!"
 11299      65 79 20 78 2F 79 20 69 
 11299      6E 76 61 6C 69 64 21 00 
 11300                             		.section	.text.wc_ecc_export_x963,"ax",@progbits
 11301                             		.global	_wc_ecc_export_x963
 11303                             	_wc_ecc_export_x963:
 11304                             	.LFB116:
8519:../src/wolfcrypt/src/ecc.c **** 
8520:../src/wolfcrypt/src/ecc.c **** 
8521:../src/wolfcrypt/src/ecc.c **** /* export point to der */
8522:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
8523:../src/wolfcrypt/src/ecc.c **** int wc_ecc_export_point_der_compressed(const int curve_idx, ecc_point* point,
8524:../src/wolfcrypt/src/ecc.c ****                                        byte* out, word32* outLen)
8525:../src/wolfcrypt/src/ecc.c **** {
8526:../src/wolfcrypt/src/ecc.c ****     int    ret = MP_OKAY;
8527:../src/wolfcrypt/src/ecc.c ****     word32 numlen;
8528:../src/wolfcrypt/src/ecc.c ****     word32 output_len;
8529:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8530:../src/wolfcrypt/src/ecc.c ****     byte*  buf;
8531:../src/wolfcrypt/src/ecc.c **** #else
8532:../src/wolfcrypt/src/ecc.c ****     byte   buf[ECC_BUFSIZE];
8533:../src/wolfcrypt/src/ecc.c **** #endif
8534:../src/wolfcrypt/src/ecc.c **** 
8535:../src/wolfcrypt/src/ecc.c ****     if ((curve_idx < 0) || (wc_ecc_is_valid_idx(curve_idx) == 0))
8536:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
8537:../src/wolfcrypt/src/ecc.c **** 
8538:../src/wolfcrypt/src/ecc.c ****     numlen = ecc_sets[curve_idx].size;
8539:../src/wolfcrypt/src/ecc.c ****     output_len = 1 + numlen; /* y point type + x */
8540:../src/wolfcrypt/src/ecc.c **** 
8541:../src/wolfcrypt/src/ecc.c ****     /* return length needed only */
8542:../src/wolfcrypt/src/ecc.c ****     if (point != NULL && out == NULL && outLen != NULL) {
8543:../src/wolfcrypt/src/ecc.c ****         *outLen = output_len;
8544:../src/wolfcrypt/src/ecc.c ****         return LENGTH_ONLY_E;
8545:../src/wolfcrypt/src/ecc.c ****     }
8546:../src/wolfcrypt/src/ecc.c **** 
8547:../src/wolfcrypt/src/ecc.c ****     if (point == NULL || out == NULL || outLen == NULL)
8548:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
8549:../src/wolfcrypt/src/ecc.c **** 
8550:../src/wolfcrypt/src/ecc.c **** 
8551:../src/wolfcrypt/src/ecc.c ****     if (*outLen < output_len) {
8552:../src/wolfcrypt/src/ecc.c ****         *outLen = output_len;
8553:../src/wolfcrypt/src/ecc.c ****         return BUFFER_E;
8554:../src/wolfcrypt/src/ecc.c ****     }
8555:../src/wolfcrypt/src/ecc.c **** 
8556:../src/wolfcrypt/src/ecc.c ****     /* Sanity check the ordinate's size. */
8557:../src/wolfcrypt/src/ecc.c ****     if ((word32)mp_unsigned_bin_size(point->x) > numlen) {
8558:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
8559:../src/wolfcrypt/src/ecc.c ****     }
8560:../src/wolfcrypt/src/ecc.c **** 
8561:../src/wolfcrypt/src/ecc.c ****     /* store byte point type */
8562:../src/wolfcrypt/src/ecc.c ****     out[0] = mp_isodd(point->y) == MP_YES ? ECC_POINT_COMP_ODD :
8563:../src/wolfcrypt/src/ecc.c ****                                             ECC_POINT_COMP_EVEN;
8564:../src/wolfcrypt/src/ecc.c **** 
8565:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8566:../src/wolfcrypt/src/ecc.c ****     buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);
8567:../src/wolfcrypt/src/ecc.c ****     if (buf == NULL)
8568:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
8569:../src/wolfcrypt/src/ecc.c **** #endif
8570:../src/wolfcrypt/src/ecc.c **** 
8571:../src/wolfcrypt/src/ecc.c ****     /* pad and store x */
8572:../src/wolfcrypt/src/ecc.c ****     XMEMSET(buf, 0, ECC_BUFSIZE);
8573:../src/wolfcrypt/src/ecc.c ****     ret = mp_to_unsigned_bin(point->x, buf +
8574:../src/wolfcrypt/src/ecc.c ****                                  (numlen - mp_unsigned_bin_size(point->x)));
8575:../src/wolfcrypt/src/ecc.c ****     if (ret != MP_OKAY)
8576:../src/wolfcrypt/src/ecc.c ****         goto done;
8577:../src/wolfcrypt/src/ecc.c ****     XMEMCPY(out+1, buf, numlen);
8578:../src/wolfcrypt/src/ecc.c **** 
8579:../src/wolfcrypt/src/ecc.c ****     *outLen = output_len;
8580:../src/wolfcrypt/src/ecc.c **** 
8581:../src/wolfcrypt/src/ecc.c **** done:
8582:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8583:../src/wolfcrypt/src/ecc.c ****     XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);
8584:../src/wolfcrypt/src/ecc.c **** #endif
8585:../src/wolfcrypt/src/ecc.c **** 
8586:../src/wolfcrypt/src/ecc.c ****     return ret;
8587:../src/wolfcrypt/src/ecc.c **** }
8588:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_COMP_KEY */
8589:../src/wolfcrypt/src/ecc.c **** 
8590:../src/wolfcrypt/src/ecc.c **** /* export public ECC key in ANSI X9.63 format */
8591:../src/wolfcrypt/src/ecc.c **** int wc_ecc_export_x963(ecc_key* key, byte* out, word32* outLen)
8592:../src/wolfcrypt/src/ecc.c **** {
 11305                             		.loc 2 8592 1
 11306 0000 7E AA                   		push.l	r10
 11307                             	.LCFI189:
 11308 0002 71 0A DC                		add	#-36, r0, r10
 11309                             	.LCFI190:
 11310 0005 EF A0                   		mov.L	r10, r0
 11311 0007 E7 A1 06                		mov.L	r1, 24[r10]
 11312 000a E7 A2 07                		mov.L	r2, 28[r10]
 11313 000d E7 A3 08                		mov.L	r3, 32[r10]
8593:../src/wolfcrypt/src/ecc.c ****    int    ret = MP_OKAY;
 11314                             		.loc 2 8593 11
 11315 0010 F8 A6 00                		mov.L	#0, [r10]
8594:../src/wolfcrypt/src/ecc.c ****    word32 numlen;
8595:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8596:../src/wolfcrypt/src/ecc.c ****    byte*  buf;
8597:../src/wolfcrypt/src/ecc.c **** #else
8598:../src/wolfcrypt/src/ecc.c ****    byte   buf[ECC_BUFSIZE];
8599:../src/wolfcrypt/src/ecc.c **** #endif
8600:../src/wolfcrypt/src/ecc.c ****    word32 pubxlen, pubylen;
8601:../src/wolfcrypt/src/ecc.c **** 
8602:../src/wolfcrypt/src/ecc.c ****    /* return length needed only */
8603:../src/wolfcrypt/src/ecc.c ****    if (key != NULL && out == NULL && outLen != NULL) {
 11316                             		.loc 2 8603 7
 11317 0013 ED A5 06                		mov.L	24[r10], r5
 11318 0016 61 05                   		cmp	#0, r5
 11319 0018 20 3A                   		beq	.L777
 11320                             		.loc 2 8603 20 discriminator 1
 11321 001a ED A5 07                		mov.L	28[r10], r5
 11322 001d 61 05                   		cmp	#0, r5
 11323 001f 21 33                   		bne	.L777
 11324                             		.loc 2 8603 35 discriminator 2
 11325 0021 ED A5 08                		mov.L	32[r10], r5
 11326 0024 61 05                   		cmp	#0, r5
 11327 0026 20 2C                   		beq	.L777
8604:../src/wolfcrypt/src/ecc.c ****       /* if key hasn't been setup assume max bytes for size estimation */
8605:../src/wolfcrypt/src/ecc.c ****       numlen = key->dp ? key->dp->size : MAX_ECC_BYTES;
 11328                             		.loc 2 8605 19
 11329 0028 ED A5 06                		mov.L	24[r10], r5
 11330 002b A9 55                   		mov.L	16[r5], r5
 11331                             		.loc 2 8605 40
 11332 002d 61 05                   		cmp	#0, r5
 11333 002f 11                      		beq	.L778
 11334                             		.loc 2 8605 29 discriminator 1
 11335 0030 ED A5 06                		mov.L	24[r10], r5
 11336 0033 A9 55                   		mov.L	16[r5], r5
 11337                             		.loc 2 8605 33 discriminator 1
 11338 0035 EC 55                   		mov.L	[r5], r5
 11339 0037 0C                      		bra	.L779
 11340                             	.L778:
 11341                             		.loc 2 8605 40 discriminator 2
 11342 0038 75 45 42                		mov.L	#0x42, r5
 11343                             	.L779:
 11344                             		.loc 2 8605 14 discriminator 4
 11345 003b E7 A5 01                		mov.L	r5, 4[r10]
8606:../src/wolfcrypt/src/ecc.c ****       *outLen = 1 + 2*numlen;
 11346                             		.loc 2 8606 22 discriminator 4
 11347 003e ED A5 01                		mov.L	4[r10], r5
 11348 0041 4B 55                   		add	r5, r5
 11349                             		.loc 2 8606 19 discriminator 4
 11350 0043 71 54 01                		add	#1, r5, r4
 11351                             		.loc 2 8606 15 discriminator 4
 11352 0046 ED A5 08                		mov.L	32[r10], r5
 11353 0049 E3 54                   		mov.L	r4, [r5]
8607:../src/wolfcrypt/src/ecc.c ****       return LENGTH_ONLY_E;
 11354                             		.loc 2 8607 14 discriminator 4
 11355 004b FB 5A 36 FF             		mov.L	#-202, r5
 11356 004f 38 99 01                		bra	.L780
 11357                             	.L777:
8608:../src/wolfcrypt/src/ecc.c ****    }
8609:../src/wolfcrypt/src/ecc.c **** 
8610:../src/wolfcrypt/src/ecc.c ****    if (key == NULL || out == NULL || outLen == NULL)
 11358                             		.loc 2 8610 7
 11359 0052 ED A5 06                		mov.L	24[r10], r5
 11360 0055 61 05                   		cmp	#0, r5
 11361 0057 20 0E                   		beq	.L781
 11362                             		.loc 2 8610 20 discriminator 1
 11363 0059 ED A5 07                		mov.L	28[r10], r5
 11364 005c 61 05                   		cmp	#0, r5
 11365 005e 17                      		beq	.L781
 11366                             		.loc 2 8610 35 discriminator 2
 11367 005f ED A5 08                		mov.L	32[r10], r5
 11368 0062 61 05                   		cmp	#0, r5
 11369 0064 18                      		bne	.L782
 11370                             	.L781:
8611:../src/wolfcrypt/src/ecc.c ****       return ECC_BAD_ARG_E;
 11371                             		.loc 2 8611 14
 11372 0065 FB 5A 56 FF             		mov.L	#-170, r5
 11373 0069 38 7F 01                		bra	.L780
 11374                             	.L782:
8612:../src/wolfcrypt/src/ecc.c **** 
8613:../src/wolfcrypt/src/ecc.c ****    if (key->type == ECC_PRIVATEKEY_ONLY)
 11375                             		.loc 2 8613 11
 11376 006c ED A5 06                		mov.L	24[r10], r5
 11377 006f EC 55                   		mov.L	[r5], r5
 11378                             		.loc 2 8613 7
 11379 0071 61 35                   		cmp	#3, r5
 11380 0073 18                      		bne	.L783
8614:../src/wolfcrypt/src/ecc.c ****        return ECC_PRIVATEONLY_E;
 11381                             		.loc 2 8614 15
 11382 0074 FB 5A 0A FF             		mov.L	#-246, r5
 11383 0078 38 70 01                		bra	.L780
 11384                             	.L783:
8615:../src/wolfcrypt/src/ecc.c **** 
8616:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_QNX_CAAM
8617:../src/wolfcrypt/src/ecc.c ****     /* check if public key in secure memory */
8618:../src/wolfcrypt/src/ecc.c ****     if (key->securePubKey > 0) {
8619:../src/wolfcrypt/src/ecc.c ****         int keySz = wc_ecc_size(key);
8620:../src/wolfcrypt/src/ecc.c **** 
8621:../src/wolfcrypt/src/ecc.c ****         /* store byte point type */
8622:../src/wolfcrypt/src/ecc.c ****         out[0] = ECC_POINT_UNCOMP;
8623:../src/wolfcrypt/src/ecc.c **** 
8624:../src/wolfcrypt/src/ecc.c ****         if (caamReadPartition((CAAM_ADDRESS)key->securePubKey, out+1, keySz*2) != 0)
8625:../src/wolfcrypt/src/ecc.c ****             return WC_HW_E;
8626:../src/wolfcrypt/src/ecc.c **** 
8627:../src/wolfcrypt/src/ecc.c ****         *outLen = 1 + 2*keySz;
8628:../src/wolfcrypt/src/ecc.c ****         return MP_OKAY;
8629:../src/wolfcrypt/src/ecc.c ****     }
8630:../src/wolfcrypt/src/ecc.c **** #endif
8631:../src/wolfcrypt/src/ecc.c **** 
8632:../src/wolfcrypt/src/ecc.c ****    if (key->type == 0 || wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL){
 11385                             		.loc 2 8632 11
 11386 007b ED A5 06                		mov.L	24[r10], r5
 11387 007e EC 55                   		mov.L	[r5], r5
 11388                             		.loc 2 8632 7
 11389 0080 61 05                   		cmp	#0, r5
 11390 0082 20 1A                   		beq	.L784
 11391                             		.loc 2 8632 26 discriminator 1
 11392 0084 ED A5 06                		mov.L	24[r10], r5
 11393 0087 A8 5D                   		mov.L	4[r5], r5
 11394 0089 EF 51                   		mov.L	r5, r1
 11395 008b 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 11396 008f EF 15                   		mov.L	r1, r5
 11397                             		.loc 2 8632 23 discriminator 1
 11398 0091 61 05                   		cmp	#0, r5
 11399 0093 11                      		beq	.L784
 11400                             		.loc 2 8632 67 discriminator 2
 11401 0094 ED A5 06                		mov.L	24[r10], r5
 11402 0097 A9 55                   		mov.L	16[r5], r5
 11403                             		.loc 2 8632 61 discriminator 2
 11404 0099 61 05                   		cmp	#0, r5
 11405 009b 18                      		bne	.L785
 11406                             	.L784:
8633:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
 11407                             		.loc 2 8633 15
 11408 009c FB 5A 56 FF             		mov.L	#-170, r5
 11409 00a0 38 48 01                		bra	.L780
 11410                             	.L785:
8634:../src/wolfcrypt/src/ecc.c ****    }
8635:../src/wolfcrypt/src/ecc.c **** 
8636:../src/wolfcrypt/src/ecc.c ****    numlen = key->dp->size;
 11411                             		.loc 2 8636 16
 11412 00a3 ED A5 06                		mov.L	24[r10], r5
 11413 00a6 A9 55                   		mov.L	16[r5], r5
 11414                             		.loc 2 8636 20
 11415 00a8 EC 55                   		mov.L	[r5], r5
 11416                             		.loc 2 8636 11
 11417 00aa E7 A5 01                		mov.L	r5, 4[r10]
8637:../src/wolfcrypt/src/ecc.c **** 
8638:../src/wolfcrypt/src/ecc.c ****     /* verify room in out buffer */
8639:../src/wolfcrypt/src/ecc.c ****    if (*outLen < (1 + 2*numlen)) {
 11418                             		.loc 2 8639 8
 11419 00ad ED A5 08                		mov.L	32[r10], r5
 11420 00b0 EC 54                   		mov.L	[r5], r4
 11421                             		.loc 2 8639 24
 11422 00b2 ED A5 01                		mov.L	4[r10], r5
 11423 00b5 4B 55                   		add	r5, r5
 11424                             		.loc 2 8639 21
 11425 00b7 62 15                   		add	#1, r5
 11426                             		.loc 2 8639 7
 11427 00b9 47 54                   		cmp	r5, r4
 11428 00bb 22 16                   		bgeu	.L786
8640:../src/wolfcrypt/src/ecc.c ****       *outLen = 1 + 2*numlen;
 11429                             		.loc 2 8640 22
 11430 00bd ED A5 01                		mov.L	4[r10], r5
 11431 00c0 4B 55                   		add	r5, r5
 11432                             		.loc 2 8640 19
 11433 00c2 71 54 01                		add	#1, r5, r4
 11434                             		.loc 2 8640 15
 11435 00c5 ED A5 08                		mov.L	32[r10], r5
 11436 00c8 E3 54                   		mov.L	r4, [r5]
8641:../src/wolfcrypt/src/ecc.c ****       return BUFFER_E;
 11437                             		.loc 2 8641 14
 11438 00ca FB 5A 7C FF             		mov.L	#-132, r5
 11439 00ce 38 1A 01                		bra	.L780
 11440                             	.L786:
8642:../src/wolfcrypt/src/ecc.c ****    }
8643:../src/wolfcrypt/src/ecc.c **** 
8644:../src/wolfcrypt/src/ecc.c ****    /* verify public key length is less than key size */
8645:../src/wolfcrypt/src/ecc.c ****    pubxlen = mp_unsigned_bin_size(key->pubkey.x);
 11441                             		.loc 2 8645 46
 11442 00d1 ED A5 06                		mov.L	24[r10], r5
 11443 00d4 71 55 18                		add	#24, r5
 11444                             		.loc 2 8645 14
 11445 00d7 EF 51                   		mov.L	r5, r1
 11446 00d9 05 00 00 00             		bsr	_sp_unsigned_bin_size
 11447 00dd EF 15                   		mov.L	r1, r5
 11448                             		.loc 2 8645 12
 11449 00df E7 A5 02                		mov.L	r5, 8[r10]
8646:../src/wolfcrypt/src/ecc.c ****    pubylen = mp_unsigned_bin_size(key->pubkey.y);
 11450                             		.loc 2 8646 46
 11451 00e2 ED A5 06                		mov.L	24[r10], r5
 11452 00e5 72 55 28 03             		add	#0x328, r5
 11453                             		.loc 2 8646 14
 11454 00e9 EF 51                   		mov.L	r5, r1
 11455 00eb 05 00 00 00             		bsr	_sp_unsigned_bin_size
 11456 00ef EF 15                   		mov.L	r1, r5
 11457                             		.loc 2 8646 12
 11458 00f1 E7 A5 03                		mov.L	r5, 12[r10]
8647:../src/wolfcrypt/src/ecc.c ****    if ((pubxlen > numlen) || (pubylen > numlen)) {
 11459                             		.loc 2 8647 7
 11460 00f4 ED A4 02                		mov.L	8[r10], r4
 11461 00f7 ED A5 01                		mov.L	4[r10], r5
 11462 00fa 47 54                   		cmp	r5, r4
 11463 00fc 24 0C                   		bgtu	.L787
 11464                             		.loc 2 8647 27 discriminator 1
 11465 00fe ED A4 03                		mov.L	12[r10], r4
 11466 0101 ED A5 01                		mov.L	4[r10], r5
 11467 0104 47 54                   		cmp	r5, r4
 11468 0106 25 13                   		bleu	.L788
 11469                             	.L787:
8648:../src/wolfcrypt/src/ecc.c ****       WOLFSSL_MSG("Public key x/y invalid!");
 11470                             		.loc 2 8648 7
 11471 0108 FB 12 DC 0A 00 00       		mov.L	#.LC44, r1
 11472 010e 05 00 00 00             		bsr	_WOLFSSL_MSG
8649:../src/wolfcrypt/src/ecc.c ****       return BUFFER_E;
 11473                             		.loc 2 8649 14
 11474 0112 FB 5A 7C FF             		mov.L	#-132, r5
 11475 0116 38 D2 00                		bra	.L780
 11476                             	.L788:
8650:../src/wolfcrypt/src/ecc.c ****    }
8651:../src/wolfcrypt/src/ecc.c **** 
8652:../src/wolfcrypt/src/ecc.c ****    /* store byte point type */
8653:../src/wolfcrypt/src/ecc.c ****    out[0] = ECC_POINT_UNCOMP;
 11477                             		.loc 2 8653 11
 11478 0119 ED A5 07                		mov.L	28[r10], r5
 11479 011c F8 54 04                		mov.B	#4, [r5]
8654:../src/wolfcrypt/src/ecc.c **** 
8655:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8656:../src/wolfcrypt/src/ecc.c ****    buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);
 11480                             		.loc 2 8656 17
 11481 011f FB 1A 01 01             		mov.L	#0x101, r1
 11482 0123 05 00 00 00             		bsr	_wolfSSL_Malloc
 11483 0127 E7 A1 04                		mov.L	r1, 16[r10]
8657:../src/wolfcrypt/src/ecc.c ****    if (buf == NULL)
 11484                             		.loc 2 8657 7
 11485 012a ED A5 04                		mov.L	16[r10], r5
 11486 012d 61 05                   		cmp	#0, r5
 11487 012f 1F                      		bne	.L789
8658:../src/wolfcrypt/src/ecc.c ****       return MEMORY_E;
 11488                             		.loc 2 8658 14
 11489 0130 FB 56 83                		mov.L	#-125, r5
 11490 0133 38 B5 00                		bra	.L780
 11491                             	.L789:
8659:../src/wolfcrypt/src/ecc.c **** #endif
8660:../src/wolfcrypt/src/ecc.c **** 
8661:../src/wolfcrypt/src/ecc.c ****    /* pad and store x */
8662:../src/wolfcrypt/src/ecc.c ****    XMEMSET(buf, 0, ECC_BUFSIZE);
 11492                             		.loc 2 8662 4
 11493 0136 FB 3A 01 01             		mov.L	#0x101, r3
 11494 013a 66 02                   		mov.L	#0, r2
 11495 013c ED A1 04                		mov.L	16[r10], r1
 11496 013f 05 00 00 00             		bsr	_memset
8663:../src/wolfcrypt/src/ecc.c ****    ret = mp_to_unsigned_bin(key->pubkey.x, buf + (numlen - pubxlen));
 11497                             		.loc 2 8663 40
 11498 0143 ED A5 06                		mov.L	24[r10], r5
 11499 0146 71 53 18                		add	#24, r5, r3
 11500                             		.loc 2 8663 58
 11501 0149 ED A4 01                		mov.L	4[r10], r4
 11502 014c ED A5 02                		mov.L	8[r10], r5
 11503 014f FF 05 54                		sub	r5, r4, r5
 11504                             		.loc 2 8663 10
 11505 0152 ED A4 04                		mov.L	16[r10], r4
 11506 0155 4B 45                   		add	r4, r5
 11507 0157 EF 52                   		mov.L	r5, r2
 11508 0159 EF 31                   		mov.L	r3, r1
 11509 015b 05 00 00 00             		bsr	_sp_to_unsigned_bin
 11510 015f E3 A1                   		mov.L	r1, [r10]
8664:../src/wolfcrypt/src/ecc.c ****    if (ret != MP_OKAY)
 11511                             		.loc 2 8664 7
 11512 0161 EC A5                   		mov.L	[r10], r5
 11513 0163 61 05                   		cmp	#0, r5
 11514 0165 21 69                   		bne	.L794
8665:../src/wolfcrypt/src/ecc.c ****       goto done;
8666:../src/wolfcrypt/src/ecc.c ****    XMEMCPY(out+1, buf, numlen);
 11515                             		.loc 2 8666 4
 11516 0167 ED A5 07                		mov.L	28[r10], r5
 11517 016a 62 15                   		add	#1, r5
 11518 016c ED A3 01                		mov.L	4[r10], r3
 11519 016f ED A2 04                		mov.L	16[r10], r2
 11520 0172 EF 51                   		mov.L	r5, r1
 11521 0174 05 00 00 00             		bsr	_memcpy
8667:../src/wolfcrypt/src/ecc.c **** 
8668:../src/wolfcrypt/src/ecc.c ****    /* pad and store y */
8669:../src/wolfcrypt/src/ecc.c ****    XMEMSET(buf, 0, ECC_BUFSIZE);
 11522                             		.loc 2 8669 4
 11523 0178 FB 3A 01 01             		mov.L	#0x101, r3
 11524 017c 66 02                   		mov.L	#0, r2
 11525 017e ED A1 04                		mov.L	16[r10], r1
 11526 0181 05 00 00 00             		bsr	_memset
8670:../src/wolfcrypt/src/ecc.c ****    ret = mp_to_unsigned_bin(key->pubkey.y, buf + (numlen - pubylen));
 11527                             		.loc 2 8670 40
 11528 0185 ED A5 06                		mov.L	24[r10], r5
 11529 0188 72 53 28 03             		add	#0x328, r5, r3
 11530                             		.loc 2 8670 58
 11531 018c ED A4 01                		mov.L	4[r10], r4
 11532 018f ED A5 03                		mov.L	12[r10], r5
 11533 0192 FF 05 54                		sub	r5, r4, r5
 11534                             		.loc 2 8670 10
 11535 0195 ED A4 04                		mov.L	16[r10], r4
 11536 0198 4B 45                   		add	r4, r5
 11537 019a EF 52                   		mov.L	r5, r2
 11538 019c EF 31                   		mov.L	r3, r1
 11539 019e 05 00 00 00             		bsr	_sp_to_unsigned_bin
 11540 01a2 E3 A1                   		mov.L	r1, [r10]
8671:../src/wolfcrypt/src/ecc.c ****    if (ret != MP_OKAY)
 11541                             		.loc 2 8671 7
 11542 01a4 EC A5                   		mov.L	[r10], r5
 11543 01a6 61 05                   		cmp	#0, r5
 11544 01a8 21 29                   		bne	.L795
8672:../src/wolfcrypt/src/ecc.c ****       goto done;
8673:../src/wolfcrypt/src/ecc.c ****    XMEMCPY(out+1+numlen, buf, numlen);
 11545                             		.loc 2 8673 4
 11546 01aa ED A5 01                		mov.L	4[r10], r5
 11547 01ad 62 15                   		add	#1, r5
 11548 01af ED A4 07                		mov.L	28[r10], r4
 11549 01b2 4B 45                   		add	r4, r5
 11550 01b4 ED A3 01                		mov.L	4[r10], r3
 11551 01b7 ED A2 04                		mov.L	16[r10], r2
 11552 01ba EF 51                   		mov.L	r5, r1
 11553 01bc 05 00 00 00             		bsr	_memcpy
8674:../src/wolfcrypt/src/ecc.c **** 
8675:../src/wolfcrypt/src/ecc.c ****    *outLen = 1 + 2*numlen;
 11554                             		.loc 2 8675 19
 11555 01c0 ED A5 01                		mov.L	4[r10], r5
 11556 01c3 4B 55                   		add	r5, r5
 11557                             		.loc 2 8675 16
 11558 01c5 71 54 01                		add	#1, r5, r4
 11559                             		.loc 2 8675 12
 11560 01c8 ED A5 08                		mov.L	32[r10], r5
 11561 01cb E3 54                   		mov.L	r4, [r5]
 11562 01cd 0D                      		bra	.L791
 11563                             	.L794:
8665:../src/wolfcrypt/src/ecc.c ****    XMEMCPY(out+1, buf, numlen);
 11564                             		.loc 2 8665 7
 11565 01ce 03                      		nop
 11566 01cf 2E 03                   		bra	.L791
 11567                             	.L795:
8672:../src/wolfcrypt/src/ecc.c ****       goto done;
 11568                             		.loc 2 8672 7
 11569 01d1 03                      		nop
 11570                             	.L791:
 11571                             	.LBB80:
8676:../src/wolfcrypt/src/ecc.c **** 
8677:../src/wolfcrypt/src/ecc.c **** done:
8678:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8679:../src/wolfcrypt/src/ecc.c ****    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);
 11572                             		.loc 2 8679 4
 11573 01d2 ED A5 04                		mov.L	16[r10], r5
 11574 01d5 E7 A5 05                		mov.L	r5, 20[r10]
 11575 01d8 ED A5 05                		mov.L	20[r10], r5
 11576 01db 61 05                   		cmp	#0, r5
 11577 01dd 10                      		beq	.L793
 11578                             		.loc 2 8679 4 is_stmt 0 discriminator 1
 11579 01de ED A1 05                		mov.L	20[r10], r1
 11580 01e1 05 00 00 00             		bsr	_wolfSSL_Free
 11581                             	.L793:
 11582                             	.LBE80:
8680:../src/wolfcrypt/src/ecc.c **** #endif
8681:../src/wolfcrypt/src/ecc.c **** 
8682:../src/wolfcrypt/src/ecc.c ****    return ret;
 11583                             		.loc 2 8682 11 is_stmt 1
 11584 01e5 EC A5                   		mov.L	[r10], r5
 11585 01e7 03                      		.balign 8,3,1
 11586                             	.L780:
8683:../src/wolfcrypt/src/ecc.c **** }
 11587                             		.loc 2 8683 1
 11588 01e8 EF 51                   		mov.L	r5, r1
 11589 01ea 3F AA 0A                		rtsd	#40, r10-r10
 11590                             	.LFE116:
 11592 01ed FC 13 00                		.section	.text.wc_ecc_export_x963_ex,"ax",@progbits
 11593                             		.global	_wc_ecc_export_x963_ex
 11595                             	_wc_ecc_export_x963_ex:
 11596                             	.LFB117:
8684:../src/wolfcrypt/src/ecc.c **** 
8685:../src/wolfcrypt/src/ecc.c **** 
8686:../src/wolfcrypt/src/ecc.c **** /* export public ECC key in ANSI X9.63 format, extended with
8687:../src/wolfcrypt/src/ecc.c ****  * compression option */
8688:../src/wolfcrypt/src/ecc.c **** int wc_ecc_export_x963_ex(ecc_key* key, byte* out, word32* outLen,
8689:../src/wolfcrypt/src/ecc.c ****                           int compressed)
8690:../src/wolfcrypt/src/ecc.c **** {
 11597                             		.loc 2 8690 1
 11598 0000 7E AA                   		push.l	r10
 11599                             	.LCFI191:
 11600 0002 71 0A F0                		add	#-16, r0, r10
 11601                             	.LCFI192:
 11602 0005 EF A0                   		mov.L	r10, r0
 11603 0007 E3 A1                   		mov.L	r1, [r10]
 11604 0009 E7 A2 01                		mov.L	r2, 4[r10]
 11605 000c E7 A3 02                		mov.L	r3, 8[r10]
 11606 000f E7 A4 03                		mov.L	r4, 12[r10]
8691:../src/wolfcrypt/src/ecc.c ****     if (compressed == 0)
 11607                             		.loc 2 8691 8
 11608 0012 ED A5 03                		mov.L	12[r10], r5
 11609 0015 61 05                   		cmp	#0, r5
 11610 0017 21 11                   		bne	.L797
8692:../src/wolfcrypt/src/ecc.c ****         return wc_ecc_export_x963(key, out, outLen);
 11611                             		.loc 2 8692 16
 11612 0019 ED A3 02                		mov.L	8[r10], r3
 11613 001c ED A2 01                		mov.L	4[r10], r2
 11614 001f EC A1                   		mov.L	[r10], r1
 11615 0021 05 00 00 00             		bsr	_wc_ecc_export_x963
 11616 0025 EF 15                   		mov.L	r1, r5
 11617 0027 0D                      		bra	.L798
 11618                             	.L797:
8693:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
8694:../src/wolfcrypt/src/ecc.c ****     else
8695:../src/wolfcrypt/src/ecc.c ****         return wc_ecc_export_x963_compressed(key, out, outLen);
8696:../src/wolfcrypt/src/ecc.c **** #else
8697:../src/wolfcrypt/src/ecc.c ****     return NOT_COMPILED_IN;
 11619                             		.loc 2 8697 12
 11620 0028 FB 5A 52 FF             		mov.L	#-174, r5
 11621                             	.L798:
8698:../src/wolfcrypt/src/ecc.c **** #endif
8699:../src/wolfcrypt/src/ecc.c **** }
 11622                             		.loc 2 8699 1
 11623 002c EF 51                   		mov.L	r5, r1
 11624 002e 3F AA 05                		rtsd	#20, r10-r10
 11625                             	.LFE117:
 11627                             		.section	.text.wc_ecc_is_point,"ax",@progbits
 11628                             		.global	_wc_ecc_is_point
 11630                             	_wc_ecc_is_point:
 11631                             	.LFB118:
8700:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_KEY_EXPORT */
8701:../src/wolfcrypt/src/ecc.c **** 
8702:../src/wolfcrypt/src/ecc.c **** 
8703:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
8704:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_SE050) && \
8705:../src/wolfcrypt/src/ecc.c ****     !defined(WOLF_CRYPTO_CB_ONLY_ECC)
8706:../src/wolfcrypt/src/ecc.c **** 
8707:../src/wolfcrypt/src/ecc.c **** /* is ecc point on curve described by dp ? */
8708:../src/wolfcrypt/src/ecc.c **** int wc_ecc_is_point(ecc_point* ecp, mp_int* a, mp_int* b, mp_int* prime)
8709:../src/wolfcrypt/src/ecc.c **** {
 11632                             		.loc 2 8709 1
 11633 0000 7E AA                   		push.l	r10
 11634                             	.LCFI193:
 11635 0002 71 0A D0                		add	#-48, r0, r10
 11636                             	.LCFI194:
 11637 0005 71 A0 F8                		add	#-8, r10, r0
 11638                             	.LCFI195:
 11639 0008 E7 A1 08                		mov.L	r1, 32[r10]
 11640 000b E7 A2 09                		mov.L	r2, 36[r10]
 11641 000e E7 A3 0A                		mov.L	r3, 40[r10]
 11642 0011 E7 A4 0B                		mov.L	r4, 44[r10]
8710:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
8711:../src/wolfcrypt/src/ecc.c ****    int err;
8712:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8713:../src/wolfcrypt/src/ecc.c ****    mp_int* t1;
8714:../src/wolfcrypt/src/ecc.c ****    mp_int* t2;
8715:../src/wolfcrypt/src/ecc.c **** #else
8716:../src/wolfcrypt/src/ecc.c ****    mp_int  t1[1], t2[1];
8717:../src/wolfcrypt/src/ecc.c **** #endif
8718:../src/wolfcrypt/src/ecc.c **** 
8719:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8720:../src/wolfcrypt/src/ecc.c ****    t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 11643                             		.loc 2 8720 18
 11644 0014 FB 1A 10 03             		mov.L	#0x310, r1
 11645 0018 05 00 00 00             		bsr	_wolfSSL_Malloc
 11646 001c E7 A1 01                		mov.L	r1, 4[r10]
8721:../src/wolfcrypt/src/ecc.c ****    if (t1 == NULL)
 11647                             		.loc 2 8721 7
 11648 001f ED A5 01                		mov.L	4[r10], r5
 11649 0022 61 05                   		cmp	#0, r5
 11650 0024 1F                      		bne	.L800
8722:../src/wolfcrypt/src/ecc.c ****        return MEMORY_E;
 11651                             		.loc 2 8722 15
 11652 0025 FB 56 83                		mov.L	#-125, r5
 11653 0028 38 BB 01                		bra	.L801
 11654                             	.L800:
8723:../src/wolfcrypt/src/ecc.c ****    t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 11655                             		.loc 2 8723 18
 11656 002b FB 1A 10 03             		mov.L	#0x310, r1
 11657 002f 05 00 00 00             		bsr	_wolfSSL_Malloc
 11658 0033 E7 A1 02                		mov.L	r1, 8[r10]
8724:../src/wolfcrypt/src/ecc.c ****    if (t2 == NULL) {
 11659                             		.loc 2 8724 7
 11660 0036 ED A5 02                		mov.L	8[r10], r5
 11661 0039 61 05                   		cmp	#0, r5
 11662 003b 21 1B                   		bne	.L802
 11663                             	.LBB81:
8725:../src/wolfcrypt/src/ecc.c ****        XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 11664                             		.loc 2 8725 8
 11665 003d ED A5 01                		mov.L	4[r10], r5
 11666 0040 E7 A5 03                		mov.L	r5, 12[r10]
 11667 0043 ED A5 03                		mov.L	12[r10], r5
 11668 0046 61 05                   		cmp	#0, r5
 11669 0048 10                      		beq	.L803
 11670                             		.loc 2 8725 8 is_stmt 0 discriminator 1
 11671 0049 ED A1 03                		mov.L	12[r10], r1
 11672 004c 05 00 00 00             		bsr	_wolfSSL_Free
 11673                             	.L803:
 11674                             	.LBE81:
8726:../src/wolfcrypt/src/ecc.c ****        return MEMORY_E;
 11675                             		.loc 2 8726 15 is_stmt 1
 11676 0050 FB 56 83                		mov.L	#-125, r5
 11677 0053 38 90 01                		bra	.L801
 11678                             	.L802:
8727:../src/wolfcrypt/src/ecc.c ****    }
8728:../src/wolfcrypt/src/ecc.c **** #endif
8729:../src/wolfcrypt/src/ecc.c **** 
8730:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {
 11679                             		.loc 2 8730 15
 11680 0056 3E 01 00                		mov.L	#0, 4[r0]
 11681 0059 F8 06 00                		mov.L	#0, [r0]
 11682 005c 66 04                   		mov.L	#0, r4
 11683 005e 66 03                   		mov.L	#0, r3
 11684 0060 ED A2 02                		mov.L	8[r10], r2
 11685 0063 ED A1 01                		mov.L	4[r10], r1
 11686 0066 05 00 00 00             		bsr	_sp_init_multi
 11687 006a E3 A1                   		mov.L	r1, [r10]
 11688                             		.loc 2 8730 7
 11689 006c EC A5                   		mov.L	[r10], r5
 11690 006e 61 05                   		cmp	#0, r5
 11691 0070 20 2D                   		beq	.L804
 11692                             	.LBB82:
8731:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_SMALL_STACK
8732:../src/wolfcrypt/src/ecc.c ****       XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 11693                             		.loc 2 8732 7
 11694 0072 ED A5 02                		mov.L	8[r10], r5
 11695 0075 E7 A5 04                		mov.L	r5, 16[r10]
 11696 0078 ED A5 04                		mov.L	16[r10], r5
 11697 007b 61 05                   		cmp	#0, r5
 11698 007d 10                      		beq	.L805
 11699                             		.loc 2 8732 7 is_stmt 0 discriminator 1
 11700 007e ED A1 04                		mov.L	16[r10], r1
 11701 0081 05 00 00 00             		bsr	_wolfSSL_Free
 11702                             	.L805:
 11703                             	.LBE82:
 11704                             	.LBB83:
8733:../src/wolfcrypt/src/ecc.c ****       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 11705                             		.loc 2 8733 7 is_stmt 1
 11706 0085 ED A5 01                		mov.L	4[r10], r5
 11707 0088 E7 A5 05                		mov.L	r5, 20[r10]
 11708 008b ED A5 05                		mov.L	20[r10], r5
 11709 008e 61 05                   		cmp	#0, r5
 11710 0090 10                      		beq	.L806
 11711                             		.loc 2 8733 7 is_stmt 0 discriminator 1
 11712 0091 ED A1 05                		mov.L	20[r10], r1
 11713 0094 05 00 00 00             		bsr	_wolfSSL_Free
 11714                             	.L806:
 11715                             	.LBE83:
8734:../src/wolfcrypt/src/ecc.c ****    #endif
8735:../src/wolfcrypt/src/ecc.c ****       return err;
 11716                             		.loc 2 8735 14 is_stmt 1
 11717 0098 EC A5                   		mov.L	[r10], r5
 11718 009a 38 49 01                		bra	.L801
 11719                             	.L804:
8736:../src/wolfcrypt/src/ecc.c ****    }
8737:../src/wolfcrypt/src/ecc.c **** 
8738:../src/wolfcrypt/src/ecc.c ****    SAVE_VECTOR_REGISTERS(err = _svr_ret;);
8739:../src/wolfcrypt/src/ecc.c **** 
8740:../src/wolfcrypt/src/ecc.c ****    /* compute y^2 */
8741:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 11720                             		.loc 2 8741 7
 11721 009d EC A5                   		mov.L	[r10], r5
 11722 009f 61 05                   		cmp	#0, r5
 11723 00a1 21 14                   		bne	.L807
8742:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(ecp->y, t1);
 11724                             		.loc 2 8742 24
 11725 00a3 ED A5 08                		mov.L	32[r10], r5
 11726 00a6 72 55 10 03             		add	#0x310, r5
 11727                             		.loc 2 8742 14
 11728 00aa ED A2 01                		mov.L	4[r10], r2
 11729 00ad EF 51                   		mov.L	r5, r1
 11730 00af 05 00 00 00             		bsr	_sp_sqr
 11731 00b3 E3 A1                   		mov.L	r1, [r10]
 11732                             	.L807:
8743:../src/wolfcrypt/src/ecc.c **** 
8744:../src/wolfcrypt/src/ecc.c ****    /* compute x^3 */
8745:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 11733                             		.loc 2 8745 7
 11734 00b5 EC A5                   		mov.L	[r10], r5
 11735 00b7 61 05                   		cmp	#0, r5
 11736 00b9 21 10                   		bne	.L808
8746:../src/wolfcrypt/src/ecc.c ****        err = mp_sqr(ecp->x, t2);
 11737                             		.loc 2 8746 24
 11738 00bb ED A5 08                		mov.L	32[r10], r5
 11739                             		.loc 2 8746 14
 11740 00be ED A2 02                		mov.L	8[r10], r2
 11741 00c1 EF 51                   		mov.L	r5, r1
 11742 00c3 05 00 00 00             		bsr	_sp_sqr
 11743 00c7 E3 A1                   		mov.L	r1, [r10]
 11744                             	.L808:
8747:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 11745                             		.loc 2 8747 7
 11746 00c9 EC A5                   		mov.L	[r10], r5
 11747 00cb 61 05                   		cmp	#0, r5
 11748 00cd 21 11                   		bne	.L809
8748:../src/wolfcrypt/src/ecc.c ****        err = mp_mod(t2, prime, t2);
 11749                             		.loc 2 8748 14
 11750 00cf ED A3 02                		mov.L	8[r10], r3
 11751 00d2 ED A2 0B                		mov.L	44[r10], r2
 11752 00d5 ED A1 02                		mov.L	8[r10], r1
 11753 00d8 05 00 00 00             		bsr	_sp_mod
 11754 00dc E3 A1                   		mov.L	r1, [r10]
 11755                             	.L809:
8749:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 11756                             		.loc 2 8749 7
 11757 00de EC A5                   		mov.L	[r10], r5
 11758 00e0 61 05                   		cmp	#0, r5
 11759 00e2 21 13                   		bne	.L810
8750:../src/wolfcrypt/src/ecc.c ****        err = mp_mul(ecp->x, t2, t2);
 11760                             		.loc 2 8750 24
 11761 00e4 ED A5 08                		mov.L	32[r10], r5
 11762                             		.loc 2 8750 14
 11763 00e7 ED A3 02                		mov.L	8[r10], r3
 11764 00ea ED A2 02                		mov.L	8[r10], r2
 11765 00ed EF 51                   		mov.L	r5, r1
 11766 00ef 05 00 00 00             		bsr	_sp_mul
 11767 00f3 E3 A1                   		mov.L	r1, [r10]
 11768                             	.L810:
8751:../src/wolfcrypt/src/ecc.c **** 
8752:../src/wolfcrypt/src/ecc.c ****    /* compute y^2 - x^3 */
8753:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY)
 11769                             		.loc 2 8753 7
 11770 00f5 EC A5                   		mov.L	[r10], r5
 11771 00f7 61 05                   		cmp	#0, r5
 11772 00f9 21 14                   		bne	.L811
8754:../src/wolfcrypt/src/ecc.c ****        err = mp_submod(t1, t2, prime, t1);
 11773                             		.loc 2 8754 14
 11774 00fb ED A4 01                		mov.L	4[r10], r4
 11775 00fe ED A3 0B                		mov.L	44[r10], r3
 11776 0101 ED A2 02                		mov.L	8[r10], r2
 11777 0104 ED A1 01                		mov.L	4[r10], r1
 11778 0107 05 00 00 00             		bsr	_sp_submod
 11779 010b E3 A1                   		mov.L	r1, [r10]
 11780                             	.L811:
8755:../src/wolfcrypt/src/ecc.c **** 
8756:../src/wolfcrypt/src/ecc.c ****    /* Determine if curve "a" should be used in calc */
8757:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CUSTOM_CURVES
8758:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
8759:../src/wolfcrypt/src/ecc.c ****       /* Use a and prime to determine if a == 3 */
8760:../src/wolfcrypt/src/ecc.c ****       err = mp_set(t2, 0);
8761:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
8762:../src/wolfcrypt/src/ecc.c ****           err = mp_submod(prime, a, prime, t2);
8763:../src/wolfcrypt/src/ecc.c ****    }
8764:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY && mp_cmp_d(t2, 3) != MP_EQ) {
8765:../src/wolfcrypt/src/ecc.c ****       /* compute y^2 - x^3 + a*x */
8766:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
8767:../src/wolfcrypt/src/ecc.c ****           err = mp_mulmod(t2, ecp->x, prime, t2);
8768:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
8769:../src/wolfcrypt/src/ecc.c ****           err = mp_addmod(t1, t2, prime, t1);
8770:../src/wolfcrypt/src/ecc.c ****    }
8771:../src/wolfcrypt/src/ecc.c ****    else
8772:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_CUSTOM_CURVES */
8773:../src/wolfcrypt/src/ecc.c ****    {
8774:../src/wolfcrypt/src/ecc.c ****       /* assumes "a" == 3 */
8775:../src/wolfcrypt/src/ecc.c ****       (void)a;
8776:../src/wolfcrypt/src/ecc.c **** 
8777:../src/wolfcrypt/src/ecc.c ****       /* compute y^2 - x^3 + 3x */
8778:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 11781                             		.loc 2 8778 10
 11782 010d EC A5                   		mov.L	[r10], r5
 11783 010f 61 05                   		cmp	#0, r5
 11784 0111 21 13                   		bne	.L812
8779:../src/wolfcrypt/src/ecc.c ****           err = mp_add(t1, ecp->x, t1);
 11785                             		.loc 2 8779 31
 11786 0113 ED A5 08                		mov.L	32[r10], r5
 11787                             		.loc 2 8779 17
 11788 0116 ED A3 01                		mov.L	4[r10], r3
 11789 0119 EF 52                   		mov.L	r5, r2
 11790 011b ED A1 01                		mov.L	4[r10], r1
 11791 011e 05 00 00 00             		bsr	_sp_add
 11792 0122 E3 A1                   		mov.L	r1, [r10]
 11793                             	.L812:
8780:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 11794                             		.loc 2 8780 10
 11795 0124 EC A5                   		mov.L	[r10], r5
 11796 0126 61 05                   		cmp	#0, r5
 11797 0128 21 13                   		bne	.L813
8781:../src/wolfcrypt/src/ecc.c ****           err = mp_add(t1, ecp->x, t1);
 11798                             		.loc 2 8781 31
 11799 012a ED A5 08                		mov.L	32[r10], r5
 11800                             		.loc 2 8781 17
 11801 012d ED A3 01                		mov.L	4[r10], r3
 11802 0130 EF 52                   		mov.L	r5, r2
 11803 0132 ED A1 01                		mov.L	4[r10], r1
 11804 0135 05 00 00 00             		bsr	_sp_add
 11805 0139 E3 A1                   		mov.L	r1, [r10]
 11806                             	.L813:
8782:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 11807                             		.loc 2 8782 10
 11808 013b EC A5                   		mov.L	[r10], r5
 11809 013d 61 05                   		cmp	#0, r5
 11810 013f 21 13                   		bne	.L814
8783:../src/wolfcrypt/src/ecc.c ****           err = mp_add(t1, ecp->x, t1);
 11811                             		.loc 2 8783 31
 11812 0141 ED A5 08                		mov.L	32[r10], r5
 11813                             		.loc 2 8783 17
 11814 0144 ED A3 01                		mov.L	4[r10], r3
 11815 0147 EF 52                   		mov.L	r5, r2
 11816 0149 ED A1 01                		mov.L	4[r10], r1
 11817 014c 05 00 00 00             		bsr	_sp_add
 11818 0150 E3 A1                   		mov.L	r1, [r10]
 11819                             	.L814:
8784:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY)
 11820                             		.loc 2 8784 10
 11821 0152 EC A5                   		mov.L	[r10], r5
 11822 0154 61 05                   		cmp	#0, r5
 11823 0156 21 11                   		bne	.L824
8785:../src/wolfcrypt/src/ecc.c ****           err = mp_mod(t1, prime, t1);
 11824                             		.loc 2 8785 17
 11825 0158 ED A3 01                		mov.L	4[r10], r3
 11826 015b ED A2 0B                		mov.L	44[r10], r2
 11827 015e ED A1 01                		mov.L	4[r10], r1
 11828 0161 05 00 00 00             		bsr	_sp_mod
 11829 0165 E3 A1                   		mov.L	r1, [r10]
 11830                             	.L824:
8786:../src/wolfcrypt/src/ecc.c ****   }
8787:../src/wolfcrypt/src/ecc.c **** 
8788:../src/wolfcrypt/src/ecc.c ****    /* adjust range (0, prime) */
8789:../src/wolfcrypt/src/ecc.c ****    while (err == MP_OKAY && mp_isneg(t1)) {
 11831                             		.loc 2 8789 10
 11832 0167 03                      		nop
8790:../src/wolfcrypt/src/ecc.c ****       err = mp_add(t1, prime, t1);
8791:../src/wolfcrypt/src/ecc.c ****    }
8792:../src/wolfcrypt/src/ecc.c ****    while (err == MP_OKAY && mp_cmp(t1, prime) != MP_LT) {
 11833                             		.loc 2 8792 10
 11834 0168 2E 11                   		bra	.L816
 11835                             	.L818:
8793:../src/wolfcrypt/src/ecc.c ****       err = mp_sub(t1, prime, t1);
 11836                             		.loc 2 8793 13
 11837 016a ED A3 01                		mov.L	4[r10], r3
 11838 016d ED A2 0B                		mov.L	44[r10], r2
 11839 0170 ED A1 01                		mov.L	4[r10], r1
 11840 0173 05 00 00 00             		bsr	_sp_sub
 11841 0177 E3 A1                   		mov.L	r1, [r10]
 11842                             	.L816:
8792:../src/wolfcrypt/src/ecc.c ****       err = mp_sub(t1, prime, t1);
 11843                             		.loc 2 8792 10
 11844 0179 EC A5                   		mov.L	[r10], r5
 11845 017b 61 05                   		cmp	#0, r5
 11846 017d 21 13                   		bne	.L817
8792:../src/wolfcrypt/src/ecc.c ****       err = mp_sub(t1, prime, t1);
 11847                             		.loc 2 8792 29 discriminator 1
 11848 017f ED A2 0B                		mov.L	44[r10], r2
 11849 0182 ED A1 01                		mov.L	4[r10], r1
 11850 0185 05 00 00 00             		bsr	_sp_cmp
 11851 0189 EF 15                   		mov.L	r1, r5
8792:../src/wolfcrypt/src/ecc.c ****       err = mp_sub(t1, prime, t1);
 11852                             		.loc 2 8792 26 discriminator 1
 11853 018b 75 05 FF                		cmp	#-1, r5
 11854 018e 21 DC                   		bne	.L818
 11855                             	.L817:
8794:../src/wolfcrypt/src/ecc.c ****    }
8795:../src/wolfcrypt/src/ecc.c **** 
8796:../src/wolfcrypt/src/ecc.c ****    /* compare to b */
8797:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
 11856                             		.loc 2 8797 7
 11857 0190 EC A5                   		mov.L	[r10], r5
 11858 0192 61 05                   		cmp	#0, r5
 11859 0194 21 19                   		bne	.L819
8798:../src/wolfcrypt/src/ecc.c ****        if (mp_cmp(t1, b) != MP_EQ) {
 11860                             		.loc 2 8798 12
 11861 0196 ED A2 0A                		mov.L	40[r10], r2
 11862 0199 ED A1 01                		mov.L	4[r10], r1
 11863 019c 05 00 00 00             		bsr	_sp_cmp
 11864 01a0 EF 15                   		mov.L	r1, r5
 11865                             		.loc 2 8798 11
 11866 01a2 61 05                   		cmp	#0, r5
 11867 01a4 16                      		beq	.L820
8799:../src/wolfcrypt/src/ecc.c ****           err = IS_POINT_E;
 11868                             		.loc 2 8799 15
 11869 01a5 F8 AA 2A FF             		mov.L	#-214, [r10]
 11870 01a9 0C                      		bra	.L819
 11871                             	.L820:
8800:../src/wolfcrypt/src/ecc.c ****        } else {
8801:../src/wolfcrypt/src/ecc.c ****           err = MP_OKAY;
 11872                             		.loc 2 8801 15
 11873 01aa F8 A6 00                		mov.L	#0, [r10]
 11874                             	.L819:
8802:../src/wolfcrypt/src/ecc.c ****        }
8803:../src/wolfcrypt/src/ecc.c ****    }
8804:../src/wolfcrypt/src/ecc.c **** 
8805:../src/wolfcrypt/src/ecc.c ****    mp_clear(t1);
 11875                             		.loc 2 8805 4
 11876 01ad ED A1 01                		mov.L	4[r10], r1
 11877 01b0 05 00 00 00             		bsr	_sp_clear
8806:../src/wolfcrypt/src/ecc.c ****    mp_clear(t2);
 11878                             		.loc 2 8806 4
 11879 01b4 ED A1 02                		mov.L	8[r10], r1
 11880 01b7 05 00 00 00             		bsr	_sp_clear
 11881                             	.LBB84:
8807:../src/wolfcrypt/src/ecc.c **** 
8808:../src/wolfcrypt/src/ecc.c ****    RESTORE_VECTOR_REGISTERS();
8809:../src/wolfcrypt/src/ecc.c **** 
8810:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
8811:../src/wolfcrypt/src/ecc.c ****    XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
 11882                             		.loc 2 8811 4
 11883 01bb ED A5 02                		mov.L	8[r10], r5
 11884 01be E7 A5 06                		mov.L	r5, 24[r10]
 11885 01c1 ED A5 06                		mov.L	24[r10], r5
 11886 01c4 61 05                   		cmp	#0, r5
 11887 01c6 10                      		beq	.L821
 11888                             		.loc 2 8811 4 is_stmt 0 discriminator 1
 11889 01c7 ED A1 06                		mov.L	24[r10], r1
 11890 01ca 05 00 00 00             		bsr	_wolfSSL_Free
 11891                             	.L821:
 11892                             	.LBE84:
 11893                             	.LBB85:
8812:../src/wolfcrypt/src/ecc.c ****    XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
 11894                             		.loc 2 8812 4 is_stmt 1
 11895 01ce ED A5 01                		mov.L	4[r10], r5
 11896 01d1 E7 A5 07                		mov.L	r5, 28[r10]
 11897 01d4 ED A5 07                		mov.L	28[r10], r5
 11898 01d7 61 05                   		cmp	#0, r5
 11899 01d9 10                      		beq	.L822
 11900                             		.loc 2 8812 4 is_stmt 0 discriminator 1
 11901 01da ED A1 07                		mov.L	28[r10], r1
 11902 01dd 05 00 00 00             		bsr	_wolfSSL_Free
 11903                             	.L822:
 11904                             	.LBE85:
8813:../src/wolfcrypt/src/ecc.c **** #endif
8814:../src/wolfcrypt/src/ecc.c **** 
8815:../src/wolfcrypt/src/ecc.c ****    return err;
 11905                             		.loc 2 8815 11 is_stmt 1
 11906 01e1 EC A5                   		mov.L	[r10], r5
 11907                             		.balign 8,3,1
 11908                             	.L801:
8816:../src/wolfcrypt/src/ecc.c **** #else
8817:../src/wolfcrypt/src/ecc.c ****    (void)a;
8818:../src/wolfcrypt/src/ecc.c ****    (void)b;
8819:../src/wolfcrypt/src/ecc.c **** 
8820:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
8821:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
8822:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(prime) == 256) {
8823:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_is_point_256(ecp->x, ecp->y);
8824:../src/wolfcrypt/src/ecc.c ****    }
8825:../src/wolfcrypt/src/ecc.c **** #endif
8826:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
8827:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(prime) == 384) {
8828:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_is_point_384(ecp->x, ecp->y);
8829:../src/wolfcrypt/src/ecc.c ****    }
8830:../src/wolfcrypt/src/ecc.c **** #endif
8831:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
8832:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(prime) == 521) {
8833:../src/wolfcrypt/src/ecc.c ****        return sp_ecc_is_point_521(ecp->x, ecp->y);
8834:../src/wolfcrypt/src/ecc.c ****    }
8835:../src/wolfcrypt/src/ecc.c **** #endif
8836:../src/wolfcrypt/src/ecc.c **** #else
8837:../src/wolfcrypt/src/ecc.c ****    (void)ecp;
8838:../src/wolfcrypt/src/ecc.c ****    (void)prime;
8839:../src/wolfcrypt/src/ecc.c **** #endif
8840:../src/wolfcrypt/src/ecc.c ****    return WC_KEY_SIZE_E;
8841:../src/wolfcrypt/src/ecc.c **** #endif
8842:../src/wolfcrypt/src/ecc.c **** }
 11909                             		.loc 2 8842 1
 11910 01e3 EF 51                   		mov.L	r5, r1
 11911 01e5 3F AA 0F                		rtsd	#60, r10-r10
 11912                             	.LFE118:
 11914                             		.section	.text.ecc_check_pubkey_order,"ax",@progbits
 11916                             	_ecc_check_pubkey_order:
 11917                             	.LFB119:
8843:../src/wolfcrypt/src/ecc.c **** 
8844:../src/wolfcrypt/src/ecc.c **** #if (FIPS_VERSION_GE(5,0) || defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || \
8845:../src/wolfcrypt/src/ecc.c ****     (defined(WOLFSSL_VALIDATE_ECC_IMPORT) && !defined(WOLFSSL_SP_MATH))) && \
8846:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_KCAPI_ECC)
8847:../src/wolfcrypt/src/ecc.c **** /* validate privkey * generator == pubkey, 0 on success */
8848:../src/wolfcrypt/src/ecc.c **** static int ecc_check_privkey_gen(ecc_key* key, mp_int* a, mp_int* prime)
8849:../src/wolfcrypt/src/ecc.c **** {
8850:../src/wolfcrypt/src/ecc.c ****     int        err;
8851:../src/wolfcrypt/src/ecc.c ****     ecc_point* base = NULL;
8852:../src/wolfcrypt/src/ecc.c ****     ecc_point* res  = NULL;
8853:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_NO_MALLOC
8854:../src/wolfcrypt/src/ecc.c ****     ecc_point lcl_base;
8855:../src/wolfcrypt/src/ecc.c ****     ecc_point lcl_res;
8856:../src/wolfcrypt/src/ecc.c **** #endif
8857:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(3);
8858:../src/wolfcrypt/src/ecc.c **** 
8859:../src/wolfcrypt/src/ecc.c ****     if (key == NULL)
8860:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
8861:../src/wolfcrypt/src/ecc.c **** 
8862:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(3, err);
8863:../src/wolfcrypt/src/ecc.c **** 
8864:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_NO_MALLOC
8865:../src/wolfcrypt/src/ecc.c ****     res = &lcl_res;
8866:../src/wolfcrypt/src/ecc.c **** #endif
8867:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_new_point_ex(&res, key->heap);
8868:../src/wolfcrypt/src/ecc.c **** 
8869:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
8870:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
8871:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {
8872:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
8873:../src/wolfcrypt/src/ecc.c ****             err = sp_ecc_mulmod_base_256(&key->k, res, 1, key->heap);
8874:../src/wolfcrypt/src/ecc.c ****         }
8875:../src/wolfcrypt/src/ecc.c ****     }
8876:../src/wolfcrypt/src/ecc.c ****     else
8877:../src/wolfcrypt/src/ecc.c **** #endif
8878:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
8879:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP384R1) {
8880:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
8881:../src/wolfcrypt/src/ecc.c ****             err = sp_ecc_mulmod_base_384(&key->k, res, 1, key->heap);
8882:../src/wolfcrypt/src/ecc.c ****         }
8883:../src/wolfcrypt/src/ecc.c ****     }
8884:../src/wolfcrypt/src/ecc.c ****     else
8885:../src/wolfcrypt/src/ecc.c **** #endif
8886:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
8887:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP521R1) {
8888:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
8889:../src/wolfcrypt/src/ecc.c ****             err = sp_ecc_mulmod_base_521(&key->k, res, 1, key->heap);
8890:../src/wolfcrypt/src/ecc.c ****         }
8891:../src/wolfcrypt/src/ecc.c ****     }
8892:../src/wolfcrypt/src/ecc.c ****     else
8893:../src/wolfcrypt/src/ecc.c **** #endif
8894:../src/wolfcrypt/src/ecc.c **** #endif
8895:../src/wolfcrypt/src/ecc.c ****     {
8896:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
8897:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_NO_MALLOC
8898:../src/wolfcrypt/src/ecc.c ****             base = &lcl_base;
8899:../src/wolfcrypt/src/ecc.c ****         #endif
8900:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_new_point_ex(&base, key->heap);
8901:../src/wolfcrypt/src/ecc.c ****         }
8902:../src/wolfcrypt/src/ecc.c **** 
8903:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
8904:../src/wolfcrypt/src/ecc.c ****             /* load curve info */
8905:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_curve_load(key->dp, &curve, (ECC_CURVE_FIELD_GX |
8906:../src/wolfcrypt/src/ecc.c ****                                    ECC_CURVE_FIELD_GY | ECC_CURVE_FIELD_ORDER));
8907:../src/wolfcrypt/src/ecc.c ****         }
8908:../src/wolfcrypt/src/ecc.c **** 
8909:../src/wolfcrypt/src/ecc.c ****         /* set up base generator */
8910:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
8911:../src/wolfcrypt/src/ecc.c ****             err = mp_copy(curve->Gx, base->x);
8912:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
8913:../src/wolfcrypt/src/ecc.c ****             err = mp_copy(curve->Gy, base->y);
8914:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
8915:../src/wolfcrypt/src/ecc.c ****             err = mp_set(base->z, 1);
8916:../src/wolfcrypt/src/ecc.c **** 
8917:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_KCAPI_ECC
8918:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
8919:../src/wolfcrypt/src/ecc.c ****             word32 pubkey_sz = (word32)key->dp->size*2;
8920:../src/wolfcrypt/src/ecc.c ****             if (key->handle == NULL) {
8921:../src/wolfcrypt/src/ecc.c ****                 /* if handle loaded, then pubkey_raw already populated */
8922:../src/wolfcrypt/src/ecc.c ****                 err = KcapiEcc_LoadKey(key, key->pubkey_raw, &pubkey_sz, 1);
8923:../src/wolfcrypt/src/ecc.c ****             }
8924:../src/wolfcrypt/src/ecc.c ****             if (err == 0) {
8925:../src/wolfcrypt/src/ecc.c ****                 err = mp_read_unsigned_bin(res->x, key->pubkey_raw,
8926:../src/wolfcrypt/src/ecc.c ****                                            pubkey_sz/2);
8927:../src/wolfcrypt/src/ecc.c ****             }
8928:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY) {
8929:../src/wolfcrypt/src/ecc.c ****                 err = mp_read_unsigned_bin(res->y,
8930:../src/wolfcrypt/src/ecc.c ****                                            key->pubkey_raw + pubkey_sz/2,
8931:../src/wolfcrypt/src/ecc.c ****                                            pubkey_sz/2);
8932:../src/wolfcrypt/src/ecc.c ****             }
8933:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY) {
8934:../src/wolfcrypt/src/ecc.c ****                 err = mp_set(res->z, 1);
8935:../src/wolfcrypt/src/ecc.c ****             }
8936:../src/wolfcrypt/src/ecc.c ****         }
8937:../src/wolfcrypt/src/ecc.c ****         (void)a;
8938:../src/wolfcrypt/src/ecc.c ****         (void)prime;
8939:../src/wolfcrypt/src/ecc.c **** #else
8940:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
8941:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
8942:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_mulmod_ex2(&key->k, base, res, a, prime, curve->order,
8943:../src/wolfcrypt/src/ecc.c ****                                                         key->rng, 1, key->heap);
8944:../src/wolfcrypt/src/ecc.c **** #else
8945:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
8946:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_mulmod_ex2(&key->k, base, res, a, prime, curve->order,
8947:../src/wolfcrypt/src/ecc.c ****                                                             NULL, 1, key->heap);
8948:../src/wolfcrypt/src/ecc.c **** #endif
8949:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_KCAPI_ECC */
8950:../src/wolfcrypt/src/ecc.c ****     }
8951:../src/wolfcrypt/src/ecc.c **** 
8952:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
8953:../src/wolfcrypt/src/ecc.c ****         /* compare result to public key */
8954:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp(res->x, key->pubkey.x) != MP_EQ ||
8955:../src/wolfcrypt/src/ecc.c ****             mp_cmp(res->y, key->pubkey.y) != MP_EQ ||
8956:../src/wolfcrypt/src/ecc.c ****             mp_cmp(res->z, key->pubkey.z) != MP_EQ) {
8957:../src/wolfcrypt/src/ecc.c ****             /* didn't match */
8958:../src/wolfcrypt/src/ecc.c ****             err = ECC_PRIV_KEY_E;
8959:../src/wolfcrypt/src/ecc.c ****         }
8960:../src/wolfcrypt/src/ecc.c ****     }
8961:../src/wolfcrypt/src/ecc.c **** 
8962:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
8963:../src/wolfcrypt/src/ecc.c ****     wc_ecc_del_point_ex(res, key->heap);
8964:../src/wolfcrypt/src/ecc.c ****     wc_ecc_del_point_ex(base, key->heap);
8965:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
8966:../src/wolfcrypt/src/ecc.c **** 
8967:../src/wolfcrypt/src/ecc.c ****     return err;
8968:../src/wolfcrypt/src/ecc.c **** }
8969:../src/wolfcrypt/src/ecc.c **** #endif /* FIPS_VERSION_GE(5,0) || WOLFSSL_VALIDATE_ECC_KEYGEN ||
8970:../src/wolfcrypt/src/ecc.c ****         * (!WOLFSSL_SP_MATH && WOLFSSL_VALIDATE_ECC_IMPORT) */
8971:../src/wolfcrypt/src/ecc.c **** 
8972:../src/wolfcrypt/src/ecc.c **** #if (FIPS_VERSION_GE(5,0) || defined(WOLFSSL_VALIDATE_ECC_KEYGEN)) && \
8973:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_KCAPI_ECC)
8974:../src/wolfcrypt/src/ecc.c **** 
8975:../src/wolfcrypt/src/ecc.c **** /* check privkey generator helper, creates prime needed */
8976:../src/wolfcrypt/src/ecc.c **** static int ecc_check_privkey_gen_helper(ecc_key* key)
8977:../src/wolfcrypt/src/ecc.c **** {
8978:../src/wolfcrypt/src/ecc.c ****     int    err;
8979:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A)
8980:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(2);
8981:../src/wolfcrypt/src/ecc.c **** #endif
8982:../src/wolfcrypt/src/ecc.c **** 
8983:../src/wolfcrypt/src/ecc.c ****     if (key == NULL)
8984:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
8985:../src/wolfcrypt/src/ecc.c **** 
8986:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
8987:../src/wolfcrypt/src/ecc.c ****     /* Hardware based private key, so this operation is not supported */
8988:../src/wolfcrypt/src/ecc.c ****     err = MP_OKAY; /* just report success */
8989:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
8990:../src/wolfcrypt/src/ecc.c ****     /* Hardware based private key, so this operation is not supported */
8991:../src/wolfcrypt/src/ecc.c ****     err = MP_OKAY; /* just report success */
8992:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_KCAPI_ECC)
8993:../src/wolfcrypt/src/ecc.c ****     /* Hardware based private key, so this operation is not supported */
8994:../src/wolfcrypt/src/ecc.c ****     err = MP_OKAY; /* just report success */
8995:../src/wolfcrypt/src/ecc.c **** #else
8996:../src/wolfcrypt/src/ecc.c ****     err = MP_OKAY;
8997:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(2, err);
8998:../src/wolfcrypt/src/ecc.c **** 
8999:../src/wolfcrypt/src/ecc.c ****     /* load curve info */
9000:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
9001:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_curve_load(key->dp, &curve,
9002:../src/wolfcrypt/src/ecc.c ****             (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF));
9003:../src/wolfcrypt/src/ecc.c **** 
9004:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
9005:../src/wolfcrypt/src/ecc.c ****         err = ecc_check_privkey_gen(key, curve->Af, curve->prime);
9006:../src/wolfcrypt/src/ecc.c **** 
9007:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
9008:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
9009:../src/wolfcrypt/src/ecc.c **** 
9010:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ATECC508A */
9011:../src/wolfcrypt/src/ecc.c **** 
9012:../src/wolfcrypt/src/ecc.c ****     return err;
9013:../src/wolfcrypt/src/ecc.c **** }
9014:../src/wolfcrypt/src/ecc.c **** 
9015:../src/wolfcrypt/src/ecc.c **** /* Performs a Pairwise Consistency Test on an ECC key pair. */
9016:../src/wolfcrypt/src/ecc.c **** static int _ecc_pairwise_consistency_test(ecc_key* key, WC_RNG* rng)
9017:../src/wolfcrypt/src/ecc.c **** {
9018:../src/wolfcrypt/src/ecc.c ****     int err = 0;
9019:../src/wolfcrypt/src/ecc.c ****     int flags = key->flags;
9020:../src/wolfcrypt/src/ecc.c **** 
9021:../src/wolfcrypt/src/ecc.c ****     /* If flags not set default to cofactor and dec/sign */
9022:../src/wolfcrypt/src/ecc.c ****     if ((flags & (WC_ECC_FLAG_COFACTOR | WC_ECC_FLAG_DEC_SIGN)) == 0) {
9023:../src/wolfcrypt/src/ecc.c ****         flags = (WC_ECC_FLAG_COFACTOR | WC_ECC_FLAG_DEC_SIGN);
9024:../src/wolfcrypt/src/ecc.c ****     }
9025:../src/wolfcrypt/src/ecc.c **** 
9026:../src/wolfcrypt/src/ecc.c ****     if (flags & WC_ECC_FLAG_COFACTOR) {
9027:../src/wolfcrypt/src/ecc.c ****         err = ecc_check_privkey_gen_helper(key);
9028:../src/wolfcrypt/src/ecc.c ****     }
9029:../src/wolfcrypt/src/ecc.c **** 
9030:../src/wolfcrypt/src/ecc.c ****     if (!err && (flags & WC_ECC_FLAG_DEC_SIGN)) {
9031:../src/wolfcrypt/src/ecc.c ****         byte* sig;
9032:../src/wolfcrypt/src/ecc.c ****         byte* digest;
9033:../src/wolfcrypt/src/ecc.c ****         word32 sigLen, digestLen;
9034:../src/wolfcrypt/src/ecc.c ****         int dynRng = 0, res = 0;
9035:../src/wolfcrypt/src/ecc.c **** 
9036:../src/wolfcrypt/src/ecc.c ****         sigLen = wc_ecc_sig_size(key);
9037:../src/wolfcrypt/src/ecc.c ****         digestLen = WC_SHA256_DIGEST_SIZE;
9038:../src/wolfcrypt/src/ecc.c ****         sig = (byte*)XMALLOC(sigLen + digestLen, NULL, DYNAMIC_TYPE_ECC);
9039:../src/wolfcrypt/src/ecc.c ****         if (sig == NULL)
9040:../src/wolfcrypt/src/ecc.c ****             return MEMORY_E;
9041:../src/wolfcrypt/src/ecc.c ****         digest = sig + sigLen;
9042:../src/wolfcrypt/src/ecc.c **** 
9043:../src/wolfcrypt/src/ecc.c ****         if (rng == NULL) {
9044:../src/wolfcrypt/src/ecc.c ****             dynRng = 1;
9045:../src/wolfcrypt/src/ecc.c ****             rng = wc_rng_new(NULL, 0, NULL);
9046:../src/wolfcrypt/src/ecc.c ****             if (rng == NULL) {
9047:../src/wolfcrypt/src/ecc.c ****                 XFREE(sig, NULL, DYNAMIC_TYPE_ECC);
9048:../src/wolfcrypt/src/ecc.c ****                 return MEMORY_E;
9049:../src/wolfcrypt/src/ecc.c ****             }
9050:../src/wolfcrypt/src/ecc.c ****         }
9051:../src/wolfcrypt/src/ecc.c **** 
9052:../src/wolfcrypt/src/ecc.c ****         err = wc_RNG_GenerateBlock(rng, digest, digestLen);
9053:../src/wolfcrypt/src/ecc.c **** 
9054:../src/wolfcrypt/src/ecc.c ****         if (!err)
9055:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_sign_hash(digest, WC_SHA256_DIGEST_SIZE, sig, &sigLen,
9056:../src/wolfcrypt/src/ecc.c ****                     rng, key);
9057:../src/wolfcrypt/src/ecc.c ****         if (!err)
9058:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_verify_hash(sig, sigLen,
9059:../src/wolfcrypt/src/ecc.c ****                     digest, WC_SHA256_DIGEST_SIZE, &res, key);
9060:../src/wolfcrypt/src/ecc.c **** 
9061:../src/wolfcrypt/src/ecc.c ****         if (res == 0)
9062:../src/wolfcrypt/src/ecc.c ****             err = ECC_PCT_E;
9063:../src/wolfcrypt/src/ecc.c **** 
9064:../src/wolfcrypt/src/ecc.c ****         if (dynRng) {
9065:../src/wolfcrypt/src/ecc.c ****             wc_rng_free(rng);
9066:../src/wolfcrypt/src/ecc.c ****         }
9067:../src/wolfcrypt/src/ecc.c ****         ForceZero(sig, sigLen + digestLen);
9068:../src/wolfcrypt/src/ecc.c ****         XFREE(sig, NULL, DYNAMIC_TYPE_ECC);
9069:../src/wolfcrypt/src/ecc.c ****     }
9070:../src/wolfcrypt/src/ecc.c ****     (void)rng;
9071:../src/wolfcrypt/src/ecc.c **** 
9072:../src/wolfcrypt/src/ecc.c ****     if (err != 0)
9073:../src/wolfcrypt/src/ecc.c ****         err = ECC_PCT_E;
9074:../src/wolfcrypt/src/ecc.c **** 
9075:../src/wolfcrypt/src/ecc.c ****     return err;
9076:../src/wolfcrypt/src/ecc.c **** }
9077:../src/wolfcrypt/src/ecc.c **** #endif /* (FIPS v5 or later || WOLFSSL_VALIDATE_ECC_KEYGEN) &&!WOLFSSL_KCAPI_ECC */
9078:../src/wolfcrypt/src/ecc.c **** 
9079:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_MATH
9080:../src/wolfcrypt/src/ecc.c **** /* validate order * pubkey = point at infinity, 0 on success */
9081:../src/wolfcrypt/src/ecc.c **** static int ecc_check_pubkey_order(ecc_key* key, ecc_point* pubkey, mp_int* a,
9082:../src/wolfcrypt/src/ecc.c ****         mp_int* prime, mp_int* order)
9083:../src/wolfcrypt/src/ecc.c **** {
 11918                             		.loc 2 9083 1
 11919 0000 6E 6B                   		pushm	r6-r11
 11920                             	.LCFI196:
 11921 0002 71 0A E4                		add	#-28, r0, r10
 11922                             	.LCFI197:
 11923 0005 71 A0 F4                		add	#-12, r10, r0
 11924                             	.LCFI198:
 11925 0008 75 46 38                		mov.L	#56, r6
 11926 000b 4B A6                   		add	r10, r6
 11927 000d E7 A1 02                		mov.L	r1, 8[r10]
 11928 0010 E7 A2 03                		mov.L	r2, 12[r10]
 11929 0013 E7 A3 04                		mov.L	r3, 16[r10]
 11930 0016 E7 A4 05                		mov.L	r4, 20[r10]
9084:../src/wolfcrypt/src/ecc.c ****     ecc_point* inf = NULL;
 11931                             		.loc 2 9084 16
 11932 0019 F9 A6 01 00             		mov.L	#0, 4[r10]
9085:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_NO_MALLOC
9086:../src/wolfcrypt/src/ecc.c ****     ecc_point  lcl_inf;
9087:../src/wolfcrypt/src/ecc.c **** #endif
9088:../src/wolfcrypt/src/ecc.c ****     int err;
9089:../src/wolfcrypt/src/ecc.c **** 
9090:../src/wolfcrypt/src/ecc.c ****     if (key == NULL)
 11933                             		.loc 2 9090 8
 11934 001d ED A5 02                		mov.L	8[r10], r5
 11935 0020 61 05                   		cmp	#0, r5
 11936 0022 18                      		bne	.L826
9091:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 11937                             		.loc 2 9091 16
 11938 0023 FB 5A 53 FF             		mov.L	#-173, r5
 11939 0027 38 BB 00                		bra	.L831
 11940                             	.L826:
9092:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(pubkey->x) > mp_count_bits(prime) ||
 11941                             		.loc 2 9092 28
 11942 002a ED A5 03                		mov.L	12[r10], r5
 11943                             		.loc 2 9092 8
 11944 002d EF 51                   		mov.L	r5, r1
 11945 002f 05 00 00 00             		bsr	_sp_count_bits
 11946 0033 EF 1B                   		mov.L	r1, r11
 11947                             		.loc 2 9092 35
 11948 0035 ED A1 05                		mov.L	20[r10], r1
 11949 0038 05 00 00 00             		bsr	_sp_count_bits
 11950 003c EF 15                   		mov.L	r1, r5
 11951                             		.loc 2 9092 7
 11952 003e 47 5B                   		cmp	r5, r11
 11953 0040 2A 3A                   		bgt	.L828
9093:../src/wolfcrypt/src/ecc.c ****        mp_count_bits(pubkey->y) > mp_count_bits(prime) ||
 11954                             		.loc 2 9093 28 discriminator 1
 11955 0042 ED A5 03                		mov.L	12[r10], r5
 11956 0045 72 55 10 03             		add	#0x310, r5
 11957                             		.loc 2 9093 8 discriminator 1
 11958 0049 EF 51                   		mov.L	r5, r1
 11959 004b 05 00 00 00             		bsr	_sp_count_bits
 11960 004f EF 1B                   		mov.L	r1, r11
 11961                             		.loc 2 9093 35 discriminator 1
 11962 0051 ED A1 05                		mov.L	20[r10], r1
 11963 0054 05 00 00 00             		bsr	_sp_count_bits
 11964 0058 EF 15                   		mov.L	r1, r5
9092:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(pubkey->x) > mp_count_bits(prime) ||
 11965                             		.loc 2 9092 56 discriminator 1
 11966 005a 47 5B                   		cmp	r5, r11
 11967 005c 2A 1E                   		bgt	.L828
9094:../src/wolfcrypt/src/ecc.c ****        mp_count_bits(pubkey->z) > mp_count_bits(prime)) {
 11968                             		.loc 2 9094 28
 11969 005e ED A5 03                		mov.L	12[r10], r5
 11970 0061 72 55 20 06             		add	#0x620, r5
 11971                             		.loc 2 9094 8
 11972 0065 EF 51                   		mov.L	r5, r1
 11973 0067 05 00 00 00             		bsr	_sp_count_bits
 11974 006b EF 1B                   		mov.L	r1, r11
 11975                             		.loc 2 9094 35
 11976 006d ED A1 05                		mov.L	20[r10], r1
 11977 0070 05 00 00 00             		bsr	_sp_count_bits
 11978 0074 EF 15                   		mov.L	r1, r5
9093:../src/wolfcrypt/src/ecc.c ****        mp_count_bits(pubkey->y) > mp_count_bits(prime) ||
 11979                             		.loc 2 9093 56
 11980 0076 47 5B                   		cmp	r5, r11
 11981 0078 2B 08                   		ble	.L829
 11982                             	.L828:
9095:../src/wolfcrypt/src/ecc.c ****        return IS_POINT_E;
 11983                             		.loc 2 9095 15
 11984 007a FB 5A 2A FF             		mov.L	#-214, r5
 11985 007e 2E 64                   		bra	.L831
 11986                             	.L829:
9096:../src/wolfcrypt/src/ecc.c ****    }
9097:../src/wolfcrypt/src/ecc.c **** 
9098:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_NO_MALLOC
9099:../src/wolfcrypt/src/ecc.c ****     inf = &lcl_inf;
9100:../src/wolfcrypt/src/ecc.c **** #endif
9101:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_new_point_ex(&inf, key->heap);
 11987                             		.loc 2 9101 11
 11988 0080 ED A5 02                		mov.L	8[r10], r5
 11989 0083 A9 5C                   		mov.L	20[r5], r4
 11990 0085 71 A5 04                		add	#4, r10, r5
 11991 0088 EF 42                   		mov.L	r4, r2
 11992 008a EF 51                   		mov.L	r5, r1
 11993 008c 05 00 00 00             		bsr	_wc_ecc_new_point_ex
 11994 0090 E3 A1                   		mov.L	r1, [r10]
9102:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 11995                             		.loc 2 9102 8
 11996 0092 EC A5                   		mov.L	[r10], r5
 11997 0094 61 05                   		cmp	#0, r5
 11998 0096 21 3A                   		bne	.L830
9103:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
9104:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
9105:../src/wolfcrypt/src/ecc.c ****         if (key->idx != ECC_CUSTOM_IDX &&
9106:../src/wolfcrypt/src/ecc.c ****                                        ecc_sets[key->idx].id == ECC_SECP256R1) {
9107:../src/wolfcrypt/src/ecc.c ****             err = sp_ecc_mulmod_256(order, pubkey, inf, 1, key->heap);
9108:../src/wolfcrypt/src/ecc.c ****         }
9109:../src/wolfcrypt/src/ecc.c ****         else
9110:../src/wolfcrypt/src/ecc.c **** #endif
9111:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
9112:../src/wolfcrypt/src/ecc.c ****         if (key->idx != ECC_CUSTOM_IDX &&
9113:../src/wolfcrypt/src/ecc.c ****                                        ecc_sets[key->idx].id == ECC_SECP384R1) {
9114:../src/wolfcrypt/src/ecc.c ****             err = sp_ecc_mulmod_384(order, pubkey, inf, 1, key->heap);
9115:../src/wolfcrypt/src/ecc.c ****         }
9116:../src/wolfcrypt/src/ecc.c ****         else
9117:../src/wolfcrypt/src/ecc.c **** #endif
9118:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
9119:../src/wolfcrypt/src/ecc.c ****         if (key->idx != ECC_CUSTOM_IDX &&
9120:../src/wolfcrypt/src/ecc.c ****                                        ecc_sets[key->idx].id == ECC_SECP521R1) {
9121:../src/wolfcrypt/src/ecc.c ****             err = sp_ecc_mulmod_521(order, pubkey, inf, 1, key->heap);
9122:../src/wolfcrypt/src/ecc.c ****         }
9123:../src/wolfcrypt/src/ecc.c ****         else
9124:../src/wolfcrypt/src/ecc.c **** #endif
9125:../src/wolfcrypt/src/ecc.c **** #endif
9126:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
9127:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_mulmod_ex(order, pubkey, inf, a, prime, 1, key->heap);
 11999                             		.loc 2 9127 19
 12000 0098 ED A3 01                		mov.L	4[r10], r3
 12001 009b ED A5 02                		mov.L	8[r10], r5
 12002 009e A9 5D                   		mov.L	20[r5], r5
 12003 00a0 A0 85                   		mov.L	r5, 8[r0]
 12004 00a2 3E 01 01                		mov.L	#1, 4[r0]
 12005 00a5 ED A5 05                		mov.L	20[r10], r5
 12006 00a8 E3 05                   		mov.L	r5, [r0]
 12007 00aa ED A4 04                		mov.L	16[r10], r4
 12008 00ad ED A2 03                		mov.L	12[r10], r2
 12009 00b0 EC 61                   		mov.L	[r6], r1
 12010 00b2 05 00 00 00             		bsr	_wc_ecc_mulmod_ex
 12011 00b6 E3 A1                   		mov.L	r1, [r10]
9128:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY && !wc_ecc_point_is_at_infinity(inf))
 12012                             		.loc 2 9128 12
 12013 00b8 EC A5                   		mov.L	[r10], r5
 12014 00ba 61 05                   		cmp	#0, r5
 12015 00bc 21 14                   		bne	.L830
 12016                             		.loc 2 9128 32 discriminator 1
 12017 00be ED A5 01                		mov.L	4[r10], r5
 12018 00c1 EF 51                   		mov.L	r5, r1
 12019 00c3 05 00 00 00             		bsr	_wc_ecc_point_is_at_infinity
 12020 00c7 EF 15                   		mov.L	r1, r5
 12021                             		.loc 2 9128 28 discriminator 1
 12022 00c9 61 05                   		cmp	#0, r5
 12023 00cb 1D                      		bne	.L830
9129:../src/wolfcrypt/src/ecc.c ****             err = ECC_INF_E;
 12024                             		.loc 2 9129 17
 12025 00cc F8 AA 29 FF             		mov.L	#-215, [r10]
 12026                             		.balign 8,3,1
 12027                             	.L830:
9130:../src/wolfcrypt/src/ecc.c **** #else
9131:../src/wolfcrypt/src/ecc.c ****         {
9132:../src/wolfcrypt/src/ecc.c ****             (void)a;
9133:../src/wolfcrypt/src/ecc.c ****             (void)prime;
9134:../src/wolfcrypt/src/ecc.c **** 
9135:../src/wolfcrypt/src/ecc.c ****             err = WC_KEY_SIZE_E;
9136:../src/wolfcrypt/src/ecc.c ****         }
9137:../src/wolfcrypt/src/ecc.c **** #endif
9138:../src/wolfcrypt/src/ecc.c ****     }
9139:../src/wolfcrypt/src/ecc.c **** 
9140:../src/wolfcrypt/src/ecc.c ****     wc_ecc_del_point_ex(inf, key->heap);
 12028                             		.loc 2 9140 5
 12029 00d0 ED A4 01                		mov.L	4[r10], r4
 12030 00d3 ED A5 02                		mov.L	8[r10], r5
 12031 00d6 A9 5D                   		mov.L	20[r5], r5
 12032 00d8 EF 52                   		mov.L	r5, r2
 12033 00da EF 41                   		mov.L	r4, r1
 12034 00dc 05 00 00 00             		bsr	_wc_ecc_del_point_ex
9141:../src/wolfcrypt/src/ecc.c **** 
9142:../src/wolfcrypt/src/ecc.c ****     return err;
 12035                             		.loc 2 9142 12
 12036 00e0 EC A5                   		mov.L	[r10], r5
 12037                             	.L831:
9143:../src/wolfcrypt/src/ecc.c **** }
 12038                             		.loc 2 9143 1 discriminator 1
 12039 00e2 EF 51                   		mov.L	r5, r1
 12040 00e4 3F 6B 10                		rtsd	#64, r6-r11
 12041                             	.LFE119:
 12043 00e7 03                      		.section	.text._ecc_validate_public_key,"ax",@progbits
 12045                             	__ecc_validate_public_key:
 12046                             	.LFB120:
9144:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH */
9145:../src/wolfcrypt/src/ecc.c **** 
9146:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL*/
9147:../src/wolfcrypt/src/ecc.c **** 
9148:../src/wolfcrypt/src/ecc.c **** #ifdef OPENSSL_EXTRA
9149:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_generator(ecc_point* ecp, int curve_idx)
9150:../src/wolfcrypt/src/ecc.c **** {
9151:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
9152:../src/wolfcrypt/src/ecc.c ****     DECLARE_CURVE_SPECS(2);
9153:../src/wolfcrypt/src/ecc.c **** 
9154:../src/wolfcrypt/src/ecc.c ****     if (!ecp || curve_idx < 0 || curve_idx > (int)(ECC_SET_COUNT-1))
9155:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
9156:../src/wolfcrypt/src/ecc.c **** 
9157:../src/wolfcrypt/src/ecc.c ****     ALLOC_CURVE_SPECS(2, err);
9158:../src/wolfcrypt/src/ecc.c **** 
9159:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
9160:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_curve_load(&ecc_sets[curve_idx], &curve,
9161:../src/wolfcrypt/src/ecc.c ****                             (ECC_CURVE_FIELD_GX | ECC_CURVE_FIELD_GY));
9162:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
9163:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(curve->Gx, ecp->x);
9164:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
9165:../src/wolfcrypt/src/ecc.c ****         err = mp_copy(curve->Gy, ecp->y);
9166:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
9167:../src/wolfcrypt/src/ecc.c ****         err = mp_set(ecp->z, 1);
9168:../src/wolfcrypt/src/ecc.c **** 
9169:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
9170:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
9171:../src/wolfcrypt/src/ecc.c **** 
9172:../src/wolfcrypt/src/ecc.c ****     return err;
9173:../src/wolfcrypt/src/ecc.c **** }
9174:../src/wolfcrypt/src/ecc.c **** #endif /* OPENSSLALL */
9175:../src/wolfcrypt/src/ecc.c **** 
9176:../src/wolfcrypt/src/ecc.c **** 
9177:../src/wolfcrypt/src/ecc.c **** /* Validate the public key per SP 800-56Ar3 section 5.6.2.3.3,
9178:../src/wolfcrypt/src/ecc.c ****  * ECC Full Public Key Validation Routine. If the parameter
9179:../src/wolfcrypt/src/ecc.c ****  * partial is set, then it follows section 5.6.2.3.4, the ECC
9180:../src/wolfcrypt/src/ecc.c ****  * Partial Public Key Validation Routine.
9181:../src/wolfcrypt/src/ecc.c ****  * If the parameter priv is set, add in a few extra
9182:../src/wolfcrypt/src/ecc.c ****  * checks on the bounds of the private key. */
9183:../src/wolfcrypt/src/ecc.c **** static int _ecc_validate_public_key(ecc_key* key, int partial, int priv)
9184:../src/wolfcrypt/src/ecc.c **** {
 12047                             		.loc 2 9184 1
 12048 0000 7E AA                   		push.l	r10
 12049                             	.LCFI199:
 12050 0002 71 0A A8                		add	#-88, r0, r10
 12051                             	.LCFI200:
 12052 0005 71 A0 FC                		add	#-4, r10, r0
 12053                             	.LCFI201:
 12054 0008 E7 A1 13                		mov.L	r1, 76[r10]
 12055 000b E7 A2 14                		mov.L	r2, 80[r10]
 12056 000e E7 A3 15                		mov.L	r3, 84[r10]
9185:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 12057                             		.loc 2 9185 9
 12058 0011 F8 A6 00                		mov.L	#0, [r10]
9186:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_MATH
9187:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
9188:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_SILABS_SE_ACCEL) && \
9189:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_SE050) && !defined(WOLF_CRYPTO_CB_ONLY_ECC) && \
9190:../src/wolfcrypt/src/ecc.c ****     !defined(WOLF_CRYPTO_CB_ONLY_ECC)
9191:../src/wolfcrypt/src/ecc.c ****     mp_int* b = NULL;
 12059                             		.loc 2 9191 13
 12060 0014 F9 A6 01 00             		mov.L	#0, 4[r10]
9192:../src/wolfcrypt/src/ecc.c ****     #ifdef USE_ECC_B_PARAM
9193:../src/wolfcrypt/src/ecc.c ****         DECLARE_CURVE_SPECS(4);
9194:../src/wolfcrypt/src/ecc.c ****     #else
9195:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_SMALL_STACK
9196:../src/wolfcrypt/src/ecc.c ****             mp_int b_lcl;
9197:../src/wolfcrypt/src/ecc.c ****         #endif
9198:../src/wolfcrypt/src/ecc.c ****         DECLARE_CURVE_SPECS(3);
 12061                             		.loc 2 9198 9
 12062 0018 F9 A6 02 00             		mov.L	#0, 8[r10]
 12063 001c 71 A5 20                		add	#32, r10, r5
 12064 001f E7 A5 12                		mov.L	r5, 72[r10]
 12065 0022 ED A5 12                		mov.L	72[r10], r5
 12066 0025 75 43 28                		mov.L	#40, r3
 12067 0028 66 02                   		mov.L	#0, r2
 12068 002a EF 51                   		mov.L	r5, r1
 12069 002c 05 00 00 00             		bsr	_memset
 12070 0030 ED A5 12                		mov.L	72[r10], r5
 12071 0033 3E 57 03                		mov.L	#3, 28[r5]
9199:../src/wolfcrypt/src/ecc.c ****     #endif /* USE_ECC_B_PARAM */
9200:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_ATECC508A && !WOLFSSL_ATECC608A &&
9201:../src/wolfcrypt/src/ecc.c ****           !WOLFSSL_CRYPTOCELL && !WOLFSSL_SILABS_SE_ACCEL && !WOLFSSL_SE050 */
9202:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH */
9203:../src/wolfcrypt/src/ecc.c **** 
9204:../src/wolfcrypt/src/ecc.c ****     ASSERT_SAVED_VECTOR_REGISTERS();
9205:../src/wolfcrypt/src/ecc.c **** 
9206:../src/wolfcrypt/src/ecc.c ****     if (key == NULL)
 12072                             		.loc 2 9206 8
 12073 0036 ED A5 13                		mov.L	76[r10], r5
 12074 0039 61 05                   		cmp	#0, r5
 12075 003b 18                      		bne	.L833
9207:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 12076                             		.loc 2 9207 16
 12077 003c FB 5A 53 FF             		mov.L	#-173, r5
 12078 0040 38 E6 01                		bra	.L853
 12079                             	.L833:
9208:../src/wolfcrypt/src/ecc.c **** 
9209:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_HAVE_SP_ECC
9210:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
9211:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {
9212:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_check_key_256(key->pubkey.x, key->pubkey.y,
9213:../src/wolfcrypt/src/ecc.c ****             key->type == ECC_PRIVATEKEY ? &key->k : NULL, key->heap);
9214:../src/wolfcrypt/src/ecc.c ****     }
9215:../src/wolfcrypt/src/ecc.c **** #endif
9216:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
9217:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP384R1) {
9218:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_check_key_384(key->pubkey.x, key->pubkey.y,
9219:../src/wolfcrypt/src/ecc.c ****             key->type == ECC_PRIVATEKEY ? &key->k : NULL, key->heap);
9220:../src/wolfcrypt/src/ecc.c ****     }
9221:../src/wolfcrypt/src/ecc.c **** #endif
9222:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
9223:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP521R1) {
9224:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_check_key_521(key->pubkey.x, key->pubkey.y,
9225:../src/wolfcrypt/src/ecc.c ****             key->type == ECC_PRIVATEKEY ? &key->k : NULL, key->heap);
9226:../src/wolfcrypt/src/ecc.c ****     }
9227:../src/wolfcrypt/src/ecc.c **** #endif
9228:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_1024
9229:../src/wolfcrypt/src/ecc.c ****     if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SAKKE_1) {
9230:../src/wolfcrypt/src/ecc.c ****         return sp_ecc_check_key_1024(key->pubkey.x, key->pubkey.y,
9231:../src/wolfcrypt/src/ecc.c ****             key->type == ECC_PRIVATEKEY ? &key->k : NULL, key->heap);
9232:../src/wolfcrypt/src/ecc.c ****     }
9233:../src/wolfcrypt/src/ecc.c **** #endif
9234:../src/wolfcrypt/src/ecc.c **** #endif
9235:../src/wolfcrypt/src/ecc.c **** 
9236:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_MATH
9237:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A) || \
9238:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_CRYPTOCELL) || defined(WOLFSSL_SILABS_SE_ACCEL) || \
9239:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_SE050) || defined(WOLF_CRYPTO_CB_ONLY_ECC)
9240:../src/wolfcrypt/src/ecc.c **** 
9241:../src/wolfcrypt/src/ecc.c ****     /* consider key check success on HW crypto
9242:../src/wolfcrypt/src/ecc.c ****      * ex: ATECC508/608A, CryptoCell and Silabs
9243:../src/wolfcrypt/src/ecc.c ****      *
9244:../src/wolfcrypt/src/ecc.c ****      * consider key check success on Crypt Cb
9245:../src/wolfcrypt/src/ecc.c ****      */
9246:../src/wolfcrypt/src/ecc.c ****     err = MP_OKAY;
9247:../src/wolfcrypt/src/ecc.c **** 
9248:../src/wolfcrypt/src/ecc.c **** #else
9249:../src/wolfcrypt/src/ecc.c ****     #ifdef USE_ECC_B_PARAM
9250:../src/wolfcrypt/src/ecc.c ****         ALLOC_CURVE_SPECS(4, err);
9251:../src/wolfcrypt/src/ecc.c ****     #else
9252:../src/wolfcrypt/src/ecc.c ****         ALLOC_CURVE_SPECS(3, err);
 12080                             		.loc 2 9252 9
 12081 0043 FB 1A 30 09             		mov.L	#0x930, r1
 12082 0047 05 00 00 00             		bsr	_wolfSSL_Malloc
 12083 004b E7 A1 02                		mov.L	r1, 8[r10]
 12084 004e ED A5 02                		mov.L	8[r10], r5
 12085 0051 61 05                   		cmp	#0, r5
 12086 0053 1D                      		bne	.L835
 12087                             		.loc 2 9252 9 is_stmt 0 discriminator 1
 12088 0054 F8 A6 83                		mov.L	#-125, [r10]
 12089 0057 09                      		bra	.L836
 12090                             	.L835:
 12091                             		.loc 2 9252 9 discriminator 2
 12092 0058 ED A5 12                		mov.L	72[r10], r5
 12093 005b ED A4 02                		mov.L	8[r10], r4
 12094 005e A1 D4                   		mov.L	r4, 24[r5]
 12095                             	.L836:
9253:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_SMALL_STACK
9254:../src/wolfcrypt/src/ecc.c ****             b = &b_lcl;
9255:../src/wolfcrypt/src/ecc.c ****         #else
9256:../src/wolfcrypt/src/ecc.c ****             b = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 12096                             		.loc 2 9256 26 is_stmt 1
 12097 0060 FB 1A 10 03             		mov.L	#0x310, r1
 12098 0064 05 00 00 00             		bsr	_wolfSSL_Malloc
 12099 0068 E7 A1 01                		mov.L	r1, 4[r10]
9257:../src/wolfcrypt/src/ecc.c ****             if (b == NULL) {
 12100                             		.loc 2 9257 16
 12101 006b ED A5 01                		mov.L	4[r10], r5
 12102 006e 61 05                   		cmp	#0, r5
 12103 0070 21 1B                   		bne	.L837
 12104                             	.LBB86:
9258:../src/wolfcrypt/src/ecc.c ****                 FREE_CURVE_SPECS();
 12105                             		.loc 2 9258 17
 12106 0072 ED A5 02                		mov.L	8[r10], r5
 12107 0075 E7 A5 03                		mov.L	r5, 12[r10]
 12108 0078 ED A5 03                		mov.L	12[r10], r5
 12109 007b 61 05                   		cmp	#0, r5
 12110 007d 10                      		beq	.L838
 12111                             		.loc 2 9258 17 is_stmt 0 discriminator 1
 12112 007e ED A1 03                		mov.L	12[r10], r1
 12113 0081 05 00 00 00             		bsr	_wolfSSL_Free
 12114                             	.L838:
 12115                             	.LBE86:
9259:../src/wolfcrypt/src/ecc.c ****                 return MEMORY_E;
 12116                             		.loc 2 9259 24 is_stmt 1
 12117 0085 FB 56 83                		mov.L	#-125, r5
 12118 0088 38 9E 01                		bra	.L853
 12119                             	.L837:
9260:../src/wolfcrypt/src/ecc.c ****             }
9261:../src/wolfcrypt/src/ecc.c ****         #endif
9262:../src/wolfcrypt/src/ecc.c ****         XMEMSET(b, 0, sizeof(mp_int));
 12120                             		.loc 2 9262 9
 12121 008b FB 3A 10 03             		mov.L	#0x310, r3
 12122 008f 66 02                   		mov.L	#0, r2
 12123 0091 ED A1 01                		mov.L	4[r10], r1
 12124 0094 05 00 00 00             		bsr	_memset
9263:../src/wolfcrypt/src/ecc.c ****     #endif
9264:../src/wolfcrypt/src/ecc.c **** 
9265:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_CAAM
9266:../src/wolfcrypt/src/ecc.c ****     /* keys can be black encrypted ones which can not be checked like plain text
9267:../src/wolfcrypt/src/ecc.c ****      * keys */
9268:../src/wolfcrypt/src/ecc.c ****     if (key->blackKey > 0) {
9269:../src/wolfcrypt/src/ecc.c ****         /* encrypted key was used */
9270:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_SMALL_STACK
9271:../src/wolfcrypt/src/ecc.c ****         XFREE(b, key->heap, DYNAMIC_TYPE_ECC);
9272:../src/wolfcrypt/src/ecc.c ****         #endif
9273:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
9274:../src/wolfcrypt/src/ecc.c ****         return 0;
9275:../src/wolfcrypt/src/ecc.c ****     }
9276:../src/wolfcrypt/src/ecc.c ****     #endif
9277:../src/wolfcrypt/src/ecc.c **** 
9278:../src/wolfcrypt/src/ecc.c ****     /* SP 800-56Ar3, section 5.6.2.3.3, process step 1 */
9279:../src/wolfcrypt/src/ecc.c ****     /* SP 800-56Ar3, section 5.6.2.3.4, process step 1 */
9280:../src/wolfcrypt/src/ecc.c ****     /* pubkey point cannot be at infinity */
9281:../src/wolfcrypt/src/ecc.c ****     if (wc_ecc_point_is_at_infinity(&key->pubkey)) {
 12125                             		.loc 2 9281 9
 12126 0098 ED A5 13                		mov.L	76[r10], r5
 12127 009b 71 55 18                		add	#24, r5
 12128 009e EF 51                   		mov.L	r5, r1
 12129 00a0 05 00 00 00             		bsr	_wc_ecc_point_is_at_infinity
 12130 00a4 EF 15                   		mov.L	r1, r5
 12131                             		.loc 2 9281 8
 12132 00a6 61 05                   		cmp	#0, r5
 12133 00a8 20 2F                   		beq	.L839
 12134                             	.LBB87:
9282:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
9283:../src/wolfcrypt/src/ecc.c ****         XFREE(b, key->heap, DYNAMIC_TYPE_ECC);
 12135                             		.loc 2 9283 9
 12136 00aa ED A5 01                		mov.L	4[r10], r5
 12137 00ad E7 A5 04                		mov.L	r5, 16[r10]
 12138 00b0 ED A5 04                		mov.L	16[r10], r5
 12139 00b3 61 05                   		cmp	#0, r5
 12140 00b5 10                      		beq	.L840
 12141                             		.loc 2 9283 9 is_stmt 0 discriminator 1
 12142 00b6 ED A1 04                		mov.L	16[r10], r1
 12143 00b9 05 00 00 00             		bsr	_wolfSSL_Free
 12144                             	.L840:
 12145                             	.LBE87:
 12146                             	.LBB88:
9284:../src/wolfcrypt/src/ecc.c ****     #endif
9285:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
 12147                             		.loc 2 9285 9 is_stmt 1
 12148 00bd ED A5 02                		mov.L	8[r10], r5
 12149 00c0 E7 A5 05                		mov.L	r5, 20[r10]
 12150 00c3 ED A5 05                		mov.L	20[r10], r5
 12151 00c6 61 05                   		cmp	#0, r5
 12152 00c8 10                      		beq	.L841
 12153                             		.loc 2 9285 9 is_stmt 0 discriminator 1
 12154 00c9 ED A1 05                		mov.L	20[r10], r1
 12155 00cc 05 00 00 00             		bsr	_wolfSSL_Free
 12156                             	.L841:
 12157                             	.LBE88:
9286:../src/wolfcrypt/src/ecc.c ****         return ECC_INF_E;
 12158                             		.loc 2 9286 16 is_stmt 1
 12159 00d0 FB 5A 29 FF             		mov.L	#-215, r5
 12160 00d4 38 52 01                		bra	.L853
 12161                             	.L839:
9287:../src/wolfcrypt/src/ecc.c ****     }
9288:../src/wolfcrypt/src/ecc.c **** 
9289:../src/wolfcrypt/src/ecc.c ****     /* load curve info */
9290:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 12162                             		.loc 2 9290 8
 12163 00d7 EC A5                   		mov.L	[r10], r5
 12164 00d9 61 05                   		cmp	#0, r5
 12165 00db 21 16                   		bne	.L842
9291:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_curve_load(key->dp, &curve, (ECC_CURVE_FIELD_PRIME |
 12166                             		.loc 2 9291 15
 12167 00dd ED A5 13                		mov.L	76[r10], r5
 12168 00e0 A9 54                   		mov.L	16[r5], r4
 12169 00e2 71 A5 48                		add	#0x48, r10, r5
 12170 00e5 66 B3                   		mov	#11, r3
 12171 00e7 EF 52                   		mov.L	r5, r2
 12172 00e9 EF 41                   		mov.L	r4, r1
 12173 00eb 05 00 00 00             		bsr	_wc_ecc_curve_load
 12174 00ef E3 A1                   		mov.L	r1, [r10]
 12175                             	.L842:
9292:../src/wolfcrypt/src/ecc.c ****             ECC_CURVE_FIELD_AF | ECC_CURVE_FIELD_ORDER
9293:../src/wolfcrypt/src/ecc.c **** #ifdef USE_ECC_B_PARAM
9294:../src/wolfcrypt/src/ecc.c ****             | ECC_CURVE_FIELD_BF
9295:../src/wolfcrypt/src/ecc.c **** #endif
9296:../src/wolfcrypt/src/ecc.c ****     ));
9297:../src/wolfcrypt/src/ecc.c **** 
9298:../src/wolfcrypt/src/ecc.c **** #ifndef USE_ECC_B_PARAM
9299:../src/wolfcrypt/src/ecc.c ****     /* load curve b parameter */
9300:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 12176                             		.loc 2 9300 8
 12177 00f1 EC A5                   		mov.L	[r10], r5
 12178 00f3 61 05                   		cmp	#0, r5
 12179 00f5 1A                      		bne	.L843
9301:../src/wolfcrypt/src/ecc.c ****         err = mp_init(b);
 12180                             		.loc 2 9301 15
 12181 00f6 ED A1 01                		mov.L	4[r10], r1
 12182 00f9 05 00 00 00             		bsr	_sp_init
 12183 00fd E3 A1                   		mov.L	r1, [r10]
 12184                             	.L843:
9302:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 12185                             		.loc 2 9302 8
 12186 00ff EC A5                   		mov.L	[r10], r5
 12187 0101 61 05                   		cmp	#0, r5
 12188 0103 21 17                   		bne	.L844
9303:../src/wolfcrypt/src/ecc.c ****         err = mp_read_radix(b, key->dp->Bf, MP_RADIX_HEX);
 12189                             		.loc 2 9303 35
 12190 0105 ED A5 13                		mov.L	76[r10], r5
 12191 0108 A9 55                   		mov.L	16[r5], r5
 12192                             		.loc 2 9303 15
 12193 010a A9 5D                   		mov.L	20[r5], r5
 12194 010c 75 43 10                		mov.L	#16, r3
 12195 010f EF 52                   		mov.L	r5, r2
 12196 0111 ED A1 01                		mov.L	4[r10], r1
 12197 0114 05 00 00 00             		bsr	_sp_read_radix
 12198 0118 E3 A1                   		mov.L	r1, [r10]
 12199                             	.L844:
9304:../src/wolfcrypt/src/ecc.c **** #else
9305:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
9306:../src/wolfcrypt/src/ecc.c ****         b = curve->Bf;
9307:../src/wolfcrypt/src/ecc.c **** #endif
9308:../src/wolfcrypt/src/ecc.c **** 
9309:../src/wolfcrypt/src/ecc.c ****     /* SP 800-56Ar3, section 5.6.2.3.3, process step 2 */
9310:../src/wolfcrypt/src/ecc.c ****     /* SP 800-56Ar3, section 5.6.2.3.4, process step 2 */
9311:../src/wolfcrypt/src/ecc.c ****     /* Qx must be in the range [0, p-1] */
9312:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 12200                             		.loc 2 9312 8
 12201 011a EC A5                   		mov.L	[r10], r5
 12202 011c 61 05                   		cmp	#0, r5
 12203 011e 21 1F                   		bne	.L845
9313:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp(key->pubkey.x, curve->prime) != MP_LT)
 12204                             		.loc 2 9313 31
 12205 0120 ED A5 13                		mov.L	76[r10], r5
 12206 0123 71 54 18                		add	#24, r5, r4
 12207                             		.loc 2 9313 40
 12208 0126 ED A5 12                		mov.L	72[r10], r5
 12209 0129 A8 5D                   		mov.L	4[r5], r5
 12210                             		.loc 2 9313 13
 12211 012b EF 52                   		mov.L	r5, r2
 12212 012d EF 41                   		mov.L	r4, r1
 12213 012f 05 00 00 00             		bsr	_sp_cmp
 12214 0133 EF 15                   		mov.L	r1, r5
 12215                             		.loc 2 9313 12
 12216 0135 75 05 FF                		cmp	#-1, r5
 12217 0138 15                      		beq	.L845
9314:../src/wolfcrypt/src/ecc.c ****             err = ECC_OUT_OF_RANGE_E;
 12218                             		.loc 2 9314 17
 12219 0139 F8 AA 27 FF             		mov.L	#-217, [r10]
 12220                             	.L845:
9315:../src/wolfcrypt/src/ecc.c ****     }
9316:../src/wolfcrypt/src/ecc.c **** 
9317:../src/wolfcrypt/src/ecc.c ****     /* Qy must be in the range [0, p-1] */
9318:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 12221                             		.loc 2 9318 8
 12222 013d EC A5                   		mov.L	[r10], r5
 12223 013f 61 05                   		cmp	#0, r5
 12224 0141 21 20                   		bne	.L846
9319:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp(key->pubkey.y, curve->prime) != MP_LT)
 12225                             		.loc 2 9319 31
 12226 0143 ED A5 13                		mov.L	76[r10], r5
 12227 0146 72 54 28 03             		add	#0x328, r5, r4
 12228                             		.loc 2 9319 40
 12229 014a ED A5 12                		mov.L	72[r10], r5
 12230 014d A8 5D                   		mov.L	4[r5], r5
 12231                             		.loc 2 9319 13
 12232 014f EF 52                   		mov.L	r5, r2
 12233 0151 EF 41                   		mov.L	r4, r1
 12234 0153 05 00 00 00             		bsr	_sp_cmp
 12235 0157 EF 15                   		mov.L	r1, r5
 12236                             		.loc 2 9319 12
 12237 0159 75 05 FF                		cmp	#-1, r5
 12238 015c 15                      		beq	.L846
9320:../src/wolfcrypt/src/ecc.c ****             err = ECC_OUT_OF_RANGE_E;
 12239                             		.loc 2 9320 17
 12240 015d F8 AA 27 FF             		mov.L	#-217, [r10]
 12241                             	.L846:
9321:../src/wolfcrypt/src/ecc.c ****     }
9322:../src/wolfcrypt/src/ecc.c **** 
9323:../src/wolfcrypt/src/ecc.c ****     /* SP 800-56Ar3, section 5.6.2.3.3, process step 3 */
9324:../src/wolfcrypt/src/ecc.c ****     /* SP 800-56Ar3, section 5.6.2.3.4, process step 3 */
9325:../src/wolfcrypt/src/ecc.c ****     /* make sure point is actually on curve */
9326:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 12242                             		.loc 2 9326 8
 12243 0161 EC A5                   		mov.L	[r10], r5
 12244 0163 61 05                   		cmp	#0, r5
 12245 0165 21 1D                   		bne	.L847
9327:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_is_point(&key->pubkey, curve->Af, b, curve->prime);
 12246                             		.loc 2 9327 15
 12247 0167 ED A5 13                		mov.L	76[r10], r5
 12248 016a 71 51 18                		add	#24, r5, r1
 12249                             		.loc 2 9327 50
 12250 016d ED A5 12                		mov.L	72[r10], r5
 12251                             		.loc 2 9327 15
 12252 0170 A8 D2                   		mov.L	8[r5], r2
 12253                             		.loc 2 9327 64
 12254 0172 ED A5 12                		mov.L	72[r10], r5
 12255                             		.loc 2 9327 15
 12256 0175 A8 5D                   		mov.L	4[r5], r5
 12257 0177 EF 54                   		mov.L	r5, r4
 12258 0179 ED A3 01                		mov.L	4[r10], r3
 12259 017c 05 00 00 00             		bsr	_wc_ecc_is_point
 12260 0180 E3 A1                   		mov.L	r1, [r10]
 12261                             	.L847:
9328:../src/wolfcrypt/src/ecc.c **** 
9329:../src/wolfcrypt/src/ecc.c ****     if (!partial) {
 12262                             		.loc 2 9329 8
 12263 0182 ED A5 14                		mov.L	80[r10], r5
 12264 0185 61 05                   		cmp	#0, r5
 12265 0187 21 28                   		bne	.L848
9330:../src/wolfcrypt/src/ecc.c ****         /* SP 800-56Ar3, section 5.6.2.3.3, process step 4 */
9331:../src/wolfcrypt/src/ecc.c ****         /* pubkey * order must be at infinity */
9332:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
 12266                             		.loc 2 9332 12
 12267 0189 EC A5                   		mov.L	[r10], r5
 12268 018b 61 05                   		cmp	#0, r5
 12269 018d 21 22                   		bne	.L848
9333:../src/wolfcrypt/src/ecc.c ****             err = ecc_check_pubkey_order(key, &key->pubkey, curve->Af,
 12270                             		.loc 2 9333 19
 12271 018f ED A5 13                		mov.L	76[r10], r5
 12272 0192 71 52 18                		add	#24, r5, r2
 12273                             		.loc 2 9333 66
 12274 0195 ED A5 12                		mov.L	72[r10], r5
 12275                             		.loc 2 9333 19
 12276 0198 A8 D3                   		mov.L	8[r5], r3
9334:../src/wolfcrypt/src/ecc.c ****                     curve->prime, curve->order);
 12277                             		.loc 2 9334 26
 12278 019a ED A5 12                		mov.L	72[r10], r5
9333:../src/wolfcrypt/src/ecc.c ****             err = ecc_check_pubkey_order(key, &key->pubkey, curve->Af,
 12279                             		.loc 2 9333 19
 12280 019d A8 5C                   		mov.L	4[r5], r4
 12281                             		.loc 2 9334 40
 12282 019f ED A5 12                		mov.L	72[r10], r5
9333:../src/wolfcrypt/src/ecc.c ****             err = ecc_check_pubkey_order(key, &key->pubkey, curve->Af,
 12283                             		.loc 2 9333 19
 12284 01a2 A8 DD                   		mov.L	12[r5], r5
 12285 01a4 E3 05                   		mov.L	r5, [r0]
 12286 01a6 ED A1 13                		mov.L	76[r10], r1
 12287 01a9 05 00 00 00             		bsr	_ecc_check_pubkey_order
 12288 01ad E3 A1                   		mov.L	r1, [r10]
 12289                             	.L848:
9335:../src/wolfcrypt/src/ecc.c ****     }
9336:../src/wolfcrypt/src/ecc.c **** 
9337:../src/wolfcrypt/src/ecc.c ****     if (priv) {
 12290                             		.loc 2 9337 8
 12291 01af ED A5 15                		mov.L	84[r10], r5
 12292 01b2 61 05                   		cmp	#0, r5
 12293 01b4 20 3A                   		beq	.L849
9338:../src/wolfcrypt/src/ecc.c ****         /* SP 800-56Ar3, section 5.6.2.1.2 */
9339:../src/wolfcrypt/src/ecc.c ****         /* private keys must be in the range [1, n-1] */
9340:../src/wolfcrypt/src/ecc.c ****         if ((err == MP_OKAY) && (key->type == ECC_PRIVATEKEY) &&
 12294                             		.loc 2 9340 12
 12295 01b6 EC A5                   		mov.L	[r10], r5
 12296 01b8 61 05                   		cmp	#0, r5
 12297 01ba 21 34                   		bne	.L849
 12298                             		.loc 2 9340 37 discriminator 1
 12299 01bc ED A5 13                		mov.L	76[r10], r5
 12300 01bf EC 55                   		mov.L	[r5], r5
 12301                             		.loc 2 9340 30 discriminator 1
 12302 01c1 61 25                   		cmp	#2, r5
 12303 01c3 21 2B                   		bne	.L849
9341:../src/wolfcrypt/src/ecc.c ****             (mp_iszero(&key->k) || mp_isneg(&key->k) ||
 12304                             		.loc 2 9341 14 discriminator 2
 12305 01c5 ED A5 13                		mov.L	76[r10], r5
 12306 01c8 EE 55 52 02             		mov.L	2376[r5], r5
9340:../src/wolfcrypt/src/ecc.c ****             (mp_iszero(&key->k) || mp_isneg(&key->k) ||
 12307                             		.loc 2 9340 63 discriminator 2
 12308 01cc 61 05                   		cmp	#0, r5
 12309 01ce 20 1C                   		beq	.L850
9342:../src/wolfcrypt/src/ecc.c ****             (mp_cmp(&key->k, curve->order) != MP_LT))
 12310                             		.loc 2 9342 21
 12311 01d0 ED A5 13                		mov.L	76[r10], r5
 12312 01d3 72 54 48 09             		add	#0x948, r5, r4
 12313                             		.loc 2 9342 35
 12314 01d7 ED A5 12                		mov.L	72[r10], r5
 12315 01da A8 DD                   		mov.L	12[r5], r5
 12316                             		.loc 2 9342 14
 12317 01dc EF 52                   		mov.L	r5, r2
 12318 01de EF 41                   		mov.L	r4, r1
 12319 01e0 05 00 00 00             		bsr	_sp_cmp
 12320 01e4 EF 15                   		mov.L	r1, r5
9341:../src/wolfcrypt/src/ecc.c ****             (mp_iszero(&key->k) || mp_isneg(&key->k) ||
 12321                             		.loc 2 9341 54
 12322 01e6 75 05 FF                		cmp	#-1, r5
 12323 01e9 15                      		beq	.L849
 12324                             	.L850:
9343:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_KCAPI_ECC
9344:../src/wolfcrypt/src/ecc.c ****             && key->handle == NULL
9345:../src/wolfcrypt/src/ecc.c ****         #endif
9346:../src/wolfcrypt/src/ecc.c ****         ) {
9347:../src/wolfcrypt/src/ecc.c ****             err = ECC_PRIV_KEY_E;
 12325                             		.loc 2 9347 17
 12326 01ea F8 AA 28 FF             		mov.L	#-216, [r10]
 12327                             		.balign 8,3,1
 12328                             	.L849:
9348:../src/wolfcrypt/src/ecc.c ****         }
9349:../src/wolfcrypt/src/ecc.c **** 
9350:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_VALIDATE_ECC_IMPORT
9351:../src/wolfcrypt/src/ecc.c ****         /* SP 800-56Ar3, section 5.6.2.1.4, method (b) for ECC */
9352:../src/wolfcrypt/src/ecc.c ****         /* private * base generator must equal pubkey */
9353:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY && key->type == ECC_PRIVATEKEY)
9354:../src/wolfcrypt/src/ecc.c ****             err = ecc_check_privkey_gen(key, curve->Af, curve->prime);
9355:../src/wolfcrypt/src/ecc.c ****     #endif
9356:../src/wolfcrypt/src/ecc.c ****     }
9357:../src/wolfcrypt/src/ecc.c **** 
9358:../src/wolfcrypt/src/ecc.c ****     wc_ecc_curve_free(curve);
 12329                             		.loc 2 9358 5
 12330 01ee ED A5 12                		mov.L	72[r10], r5
 12331 01f1 EF 51                   		mov.L	r5, r1
 12332 01f3 05 00 00 00             		bsr	_wc_ecc_curve_free
9359:../src/wolfcrypt/src/ecc.c **** 
9360:../src/wolfcrypt/src/ecc.c **** #ifndef USE_ECC_B_PARAM
9361:../src/wolfcrypt/src/ecc.c ****     mp_clear(b);
 12333                             		.loc 2 9361 5
 12334 01f7 ED A1 01                		mov.L	4[r10], r1
 12335 01fa 05 00 00 00             		bsr	_sp_clear
 12336                             	.LBB89:
9362:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
9363:../src/wolfcrypt/src/ecc.c ****         XFREE(b, key->heap, DYNAMIC_TYPE_ECC);
 12337                             		.loc 2 9363 9
 12338 01fe ED A5 01                		mov.L	4[r10], r5
 12339 0201 E7 A5 06                		mov.L	r5, 24[r10]
 12340 0204 ED A5 06                		mov.L	24[r10], r5
 12341 0207 61 05                   		cmp	#0, r5
 12342 0209 10                      		beq	.L851
 12343                             		.loc 2 9363 9 is_stmt 0 discriminator 1
 12344 020a ED A1 06                		mov.L	24[r10], r1
 12345 020d 05 00 00 00             		bsr	_wolfSSL_Free
 12346                             	.L851:
 12347                             	.LBE89:
 12348                             	.LBB90:
9364:../src/wolfcrypt/src/ecc.c ****     #endif
9365:../src/wolfcrypt/src/ecc.c **** #endif
9366:../src/wolfcrypt/src/ecc.c **** 
9367:../src/wolfcrypt/src/ecc.c ****     FREE_CURVE_SPECS();
 12349                             		.loc 2 9367 5 is_stmt 1
 12350 0211 ED A5 02                		mov.L	8[r10], r5
 12351 0214 E7 A5 07                		mov.L	r5, 28[r10]
 12352 0217 ED A5 07                		mov.L	28[r10], r5
 12353 021a 61 05                   		cmp	#0, r5
 12354 021c 10                      		beq	.L852
 12355                             		.loc 2 9367 5 is_stmt 0 discriminator 1
 12356 021d ED A1 07                		mov.L	28[r10], r1
 12357 0220 05 00 00 00             		bsr	_wolfSSL_Free
 12358                             	.L852:
 12359                             	.LBE90:
9368:../src/wolfcrypt/src/ecc.c **** #endif /* HW Based Crypto */
9369:../src/wolfcrypt/src/ecc.c **** #else
9370:../src/wolfcrypt/src/ecc.c ****     err = WC_KEY_SIZE_E;
9371:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH */
9372:../src/wolfcrypt/src/ecc.c ****     (void)partial;
9373:../src/wolfcrypt/src/ecc.c ****     (void)priv;
9374:../src/wolfcrypt/src/ecc.c ****     return err;
 12360                             		.loc 2 9374 12 is_stmt 1
 12361 0224 EC A5                   		mov.L	[r10], r5
 12362                             		.balign 8,3,1
 12363                             	.L853:
9375:../src/wolfcrypt/src/ecc.c **** }
 12364                             		.loc 2 9375 1 discriminator 1
 12365 0226 EF 51                   		mov.L	r5, r1
 12366 0228 3F AA 18                		rtsd	#96, r10-r10
 12367                             	.LFE120:
 12369 022b 77 10 01 00 00          		.section	.text.wc_ecc_check_key,"ax",@progbits
 12370                             		.global	_wc_ecc_check_key
 12372                             	_wc_ecc_check_key:
 12373                             	.LFB121:
9376:../src/wolfcrypt/src/ecc.c **** 
9377:../src/wolfcrypt/src/ecc.c **** 
9378:../src/wolfcrypt/src/ecc.c **** /* perform sanity checks on ecc key validity, 0 on success */
9379:../src/wolfcrypt/src/ecc.c **** int wc_ecc_check_key(ecc_key* key)
9380:../src/wolfcrypt/src/ecc.c **** {
 12374                             		.loc 2 9380 1
 12375 0000 7E AA                   		push.l	r10
 12376                             	.LCFI202:
 12377 0002 71 0A F8                		add	#-8, r0, r10
 12378                             	.LCFI203:
 12379 0005 EF A0                   		mov.L	r10, r0
 12380 0007 E7 A1 01                		mov.L	r1, 4[r10]
9381:../src/wolfcrypt/src/ecc.c ****     int ret;
9382:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
9383:../src/wolfcrypt/src/ecc.c ****     ret = _ecc_validate_public_key(key, 0, 1);
 12381                             		.loc 2 9383 11
 12382 000a 66 13                   		mov.L	#1, r3
 12383 000c 66 02                   		mov.L	#0, r2
 12384 000e ED A1 01                		mov.L	4[r10], r1
 12385 0011 05 00 00 00             		bsr	__ecc_validate_public_key
 12386 0015 E3 A1                   		mov.L	r1, [r10]
9384:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
9385:../src/wolfcrypt/src/ecc.c ****     return ret;
 12387                             		.loc 2 9385 12
 12388 0017 EC A5                   		mov.L	[r10], r5
9386:../src/wolfcrypt/src/ecc.c **** }
 12389                             		.loc 2 9386 1
 12390 0019 EF 51                   		mov.L	r5, r1
 12391 001b 3F AA 03                		rtsd	#12, r10-r10
 12392                             	.LFE121:
 12394                             		.section	.text.wc_ecc_import_x963_ex,"ax",@progbits
 12395                             		.global	_wc_ecc_import_x963_ex
 12397                             	_wc_ecc_import_x963_ex:
 12398                             	.LFB122:
9387:../src/wolfcrypt/src/ecc.c **** 
9388:../src/wolfcrypt/src/ecc.c **** 
9389:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_KEY_IMPORT
9390:../src/wolfcrypt/src/ecc.c **** /* import public ECC key in ANSI X9.63 format */
9391:../src/wolfcrypt/src/ecc.c **** int wc_ecc_import_x963_ex(const byte* in, word32 inLen, ecc_key* key,
9392:../src/wolfcrypt/src/ecc.c ****                           int curve_id)
9393:../src/wolfcrypt/src/ecc.c **** {
 12399                             		.loc 2 9393 1
 12400 0000 7E AA                   		push.l	r10
 12401                             	.LCFI204:
 12402 0002 71 0A E4                		add	#-28, r0, r10
 12403                             	.LCFI205:
 12404 0005 71 A0 F8                		add	#-8, r10, r0
 12405                             	.LCFI206:
 12406 0008 E7 A1 03                		mov.L	r1, 12[r10]
 12407 000b E7 A2 04                		mov.L	r2, 16[r10]
 12408 000e E7 A3 05                		mov.L	r3, 20[r10]
 12409 0011 E7 A4 06                		mov.L	r4, 24[r10]
9394:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 12410                             		.loc 2 9394 9
 12411 0014 F8 A6 00                		mov.L	#0, [r10]
9395:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
9396:../src/wolfcrypt/src/ecc.c ****     int compressed = 0;
9397:../src/wolfcrypt/src/ecc.c **** #endif
9398:../src/wolfcrypt/src/ecc.c ****     int keysize = 0;
 12412                             		.loc 2 9398 9
 12413 0017 F9 A6 01 00             		mov.L	#0, 4[r10]
9399:../src/wolfcrypt/src/ecc.c ****     byte pointType;
9400:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CRYPTOCELL
9401:../src/wolfcrypt/src/ecc.c ****     const CRYS_ECPKI_Domain_t* pDomain;
9402:../src/wolfcrypt/src/ecc.c ****     CRYS_ECPKI_BUILD_TempData_t tempBuff;
9403:../src/wolfcrypt/src/ecc.c **** #endif
9404:../src/wolfcrypt/src/ecc.c ****     if (in == NULL || key == NULL)
 12414                             		.loc 2 9404 8
 12415 001b ED A5 03                		mov.L	12[r10], r5
 12416 001e 61 05                   		cmp	#0, r5
 12417 0020 17                      		beq	.L857
 12418                             		.loc 2 9404 20 discriminator 1
 12419 0021 ED A5 05                		mov.L	20[r10], r5
 12420 0024 61 05                   		cmp	#0, r5
 12421 0026 18                      		bne	.L858
 12422                             	.L857:
9405:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 12423                             		.loc 2 9405 16
 12424 0027 FB 5A 53 FF             		mov.L	#-173, r5
 12425 002b 38 40 01                		bra	.L859
 12426                             	.L858:
9406:../src/wolfcrypt/src/ecc.c **** 
9407:../src/wolfcrypt/src/ecc.c ****     /* must be odd */
9408:../src/wolfcrypt/src/ecc.c ****     if ((inLen & 1) == 0) {
 12427                             		.loc 2 9408 16
 12428 002e ED A5 04                		mov.L	16[r10], r5
 12429 0031 64 15                   		and	#1, r5
 12430                             		.loc 2 9408 8
 12431 0033 61 05                   		cmp	#0, r5
 12432 0035 18                      		bne	.L860
9409:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 12433                             		.loc 2 9409 16
 12434 0036 FB 5A 56 FF             		mov.L	#-170, r5
 12435 003a 38 31 01                		bra	.L859
 12436                             	.L860:
9410:../src/wolfcrypt/src/ecc.c ****     }
9411:../src/wolfcrypt/src/ecc.c **** 
9412:../src/wolfcrypt/src/ecc.c ****     /* make sure required variables are reset */
9413:../src/wolfcrypt/src/ecc.c ****     wc_ecc_reset(key);
 12437                             		.loc 2 9413 5
 12438 003d ED A1 05                		mov.L	20[r10], r1
 12439 0040 05 00 00 00             		bsr	_wc_ecc_reset
9414:../src/wolfcrypt/src/ecc.c **** 
9415:../src/wolfcrypt/src/ecc.c ****     /* init key */
9416:../src/wolfcrypt/src/ecc.c ****     #ifdef ALT_ECC_SIZE
9417:../src/wolfcrypt/src/ecc.c ****         key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
9418:../src/wolfcrypt/src/ecc.c ****         key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
9419:../src/wolfcrypt/src/ecc.c ****         key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
9420:../src/wolfcrypt/src/ecc.c ****         alt_fp_init(key->pubkey.x);
9421:../src/wolfcrypt/src/ecc.c ****         alt_fp_init(key->pubkey.y);
9422:../src/wolfcrypt/src/ecc.c ****         alt_fp_init(key->pubkey.z);
9423:../src/wolfcrypt/src/ecc.c ****         err = mp_init(&key->k);
9424:../src/wolfcrypt/src/ecc.c ****     #else
9425:../src/wolfcrypt/src/ecc.c ****         err = mp_init_multi(&key->k,
 12440                             		.loc 2 9425 29
 12441 0044 ED A5 05                		mov.L	20[r10], r5
 12442 0047 72 51 48 09             		add	#0x948, r5, r1
9426:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.x, key->pubkey.y, key->pubkey.z, NULL, NULL);
 12443                             		.loc 2 9426 32
 12444 004b ED A5 05                		mov.L	20[r10], r5
 12445 004e 71 52 18                		add	#24, r5, r2
 12446                             		.loc 2 9426 47
 12447 0051 ED A5 05                		mov.L	20[r10], r5
 12448 0054 72 53 28 03             		add	#0x328, r5, r3
 12449                             		.loc 2 9426 62
 12450 0058 ED A5 05                		mov.L	20[r10], r5
 12451 005b 72 55 38 06             		add	#0x638, r5
9425:../src/wolfcrypt/src/ecc.c ****                     key->pubkey.x, key->pubkey.y, key->pubkey.z, NULL, NULL);
 12452                             		.loc 2 9425 15
 12453 005f 3E 01 00                		mov.L	#0, 4[r0]
 12454 0062 F8 06 00                		mov.L	#0, [r0]
 12455 0065 EF 54                   		mov.L	r5, r4
 12456 0067 05 00 00 00             		bsr	_sp_init_multi
 12457 006b E3 A1                   		mov.L	r1, [r10]
9427:../src/wolfcrypt/src/ecc.c ****     #endif
9428:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY)
 12458                             		.loc 2 9428 8
 12459 006d EC A5                   		mov.L	[r10], r5
 12460 006f 61 05                   		cmp	#0, r5
 12461 0071 17                      		beq	.L861
9429:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 12462                             		.loc 2 9429 16
 12463 0072 FB 56 83                		mov.L	#-125, r5
 12464 0075 38 F6 00                		bra	.L859
 12465                             	.L861:
9430:../src/wolfcrypt/src/ecc.c **** 
9431:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
9432:../src/wolfcrypt/src/ecc.c **** 
9433:../src/wolfcrypt/src/ecc.c ****     /* check for point type (4, 2, or 3) */
9434:../src/wolfcrypt/src/ecc.c ****     pointType = in[0];
 12466                             		.loc 2 9434 15
 12467 0078 ED A5 03                		mov.L	12[r10], r5
 12468 007b CC 55                   		mov.B	[r5], r5
 12469 007d C7 A5 08                		mov.B	r5, 8[r10]
9435:../src/wolfcrypt/src/ecc.c ****     if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&
 12470                             		.loc 2 9435 8
 12471 0080 59 A5 08                		movu.B	8[r10], r5
 12472 0083 61 45                   		cmp	#4, r5
 12473 0085 20 13                   		beq	.L862
 12474                             		.loc 2 9435 39 discriminator 1
 12475 0087 59 A5 08                		movu.B	8[r10], r5
 12476 008a 61 25                   		cmp	#2, r5
 12477 008c 20 0C                   		beq	.L862
 12478                             		.loc 2 9435 75 discriminator 2
 12479 008e 59 A5 08                		movu.B	8[r10], r5
 12480 0091 61 35                   		cmp	#3, r5
 12481 0093 15                      		beq	.L862
9436:../src/wolfcrypt/src/ecc.c ****                                          pointType != ECC_POINT_COMP_ODD) {
9437:../src/wolfcrypt/src/ecc.c ****         err = ASN_PARSE_E;
 12482                             		.loc 2 9437 13
 12483 0094 F8 AA 74 FF             		mov.L	#-140, [r10]
 12484                             		.balign 8,3,3
 12485                             	.L862:
9438:../src/wolfcrypt/src/ecc.c ****     }
9439:../src/wolfcrypt/src/ecc.c **** 
9440:../src/wolfcrypt/src/ecc.c ****     if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {
 12486                             		.loc 2 9440 8
 12487 0098 59 A5 08                		movu.B	8[r10], r5
 12488 009b 61 25                   		cmp	#2, r5
 12489 009d 17                      		beq	.L863
 12490                             		.loc 2 9440 42 discriminator 1
 12491 009e 59 A5 08                		movu.B	8[r10], r5
 12492 00a1 61 35                   		cmp	#3, r5
 12493 00a3 1D                      		bne	.L864
 12494                             	.L863:
9441:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_COMP_KEY
9442:../src/wolfcrypt/src/ecc.c ****         compressed = 1;
9443:../src/wolfcrypt/src/ecc.c ****     #else
9444:../src/wolfcrypt/src/ecc.c ****         err = NOT_COMPILED_IN;
 12495                             		.loc 2 9444 13
 12496 00a4 F8 AA 52 FF             		mov.L	#-174, [r10]
 12497                             	.L864:
9445:../src/wolfcrypt/src/ecc.c ****     #endif
9446:../src/wolfcrypt/src/ecc.c ****     }
9447:../src/wolfcrypt/src/ecc.c **** 
9448:../src/wolfcrypt/src/ecc.c ****     /* adjust to skip first byte */
9449:../src/wolfcrypt/src/ecc.c ****     inLen -= 1;
 12498                             		.loc 2 9449 11
 12499 00a8 ED A5 04                		mov.L	16[r10], r5
 12500 00ab 60 15                   		sub	#1, r5
 12501 00ad E7 A5 04                		mov.L	r5, 16[r10]
9450:../src/wolfcrypt/src/ecc.c ****     in += 1;
 12502                             		.loc 2 9450 8
 12503 00b0 ED A5 03                		mov.L	12[r10], r5
 12504 00b3 62 15                   		add	#1, r5
 12505 00b5 E7 A5 03                		mov.L	r5, 12[r10]
9451:../src/wolfcrypt/src/ecc.c **** 
9452:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
9453:../src/wolfcrypt/src/ecc.c ****     /* For SECP256R1 only save raw public key for hardware */
9454:../src/wolfcrypt/src/ecc.c ****     if (curve_id == ECC_SECP256R1 && inLen <= (word32)sizeof(key->pubkey_raw)) {
9455:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_COMP_KEY
9456:../src/wolfcrypt/src/ecc.c ****         if (!compressed)
9457:../src/wolfcrypt/src/ecc.c ****     #endif
9458:../src/wolfcrypt/src/ecc.c ****             XMEMCPY(key->pubkey_raw, (byte*)in, inLen);
9459:../src/wolfcrypt/src/ecc.c ****     }
9460:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_KCAPI_ECC)
9461:../src/wolfcrypt/src/ecc.c ****     XMEMCPY(key->pubkey_raw, (byte*)in, inLen);
9462:../src/wolfcrypt/src/ecc.c **** #endif
9463:../src/wolfcrypt/src/ecc.c **** 
9464:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 12506                             		.loc 2 9464 8
 12507 00b8 EC A5                   		mov.L	[r10], r5
 12508 00ba 61 05                   		cmp	#0, r5
 12509 00bc 21 1F                   		bne	.L865
9465:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_COMP_KEY
9466:../src/wolfcrypt/src/ecc.c ****         /* adjust inLen if compressed */
9467:../src/wolfcrypt/src/ecc.c ****         if (compressed)
9468:../src/wolfcrypt/src/ecc.c ****             inLen = inLen*2 + 1;  /* used uncompressed len */
9469:../src/wolfcrypt/src/ecc.c ****     #endif
9470:../src/wolfcrypt/src/ecc.c **** 
9471:../src/wolfcrypt/src/ecc.c ****         /* determine key size */
9472:../src/wolfcrypt/src/ecc.c ****         keysize = (inLen>>1);
 12510                             		.loc 2 9472 25
 12511 00be ED A5 04                		mov.L	16[r10], r5
 12512 00c1 68 15                   		shlr	#1, r5
 12513                             		.loc 2 9472 17
 12514 00c3 E7 A5 01                		mov.L	r5, 4[r10]
9473:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_set_curve(key, keysize, curve_id);
 12515                             		.loc 2 9473 15
 12516 00c6 ED A3 06                		mov.L	24[r10], r3
 12517 00c9 ED A2 01                		mov.L	4[r10], r2
 12518 00cc ED A1 05                		mov.L	20[r10], r1
 12519 00cf 05 00 00 00             		bsr	_wc_ecc_set_curve
 12520 00d3 E3 A1                   		mov.L	r1, [r10]
9474:../src/wolfcrypt/src/ecc.c ****         key->type = ECC_PUBLICKEY;
 12521                             		.loc 2 9474 19
 12522 00d5 ED A5 05                		mov.L	20[r10], r5
 12523 00d8 F8 56 01                		mov.L	#1, [r5]
 12524                             	.L865:
9475:../src/wolfcrypt/src/ecc.c ****     }
9476:../src/wolfcrypt/src/ecc.c **** 
9477:../src/wolfcrypt/src/ecc.c ****     /* read data */
9478:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 12525                             		.loc 2 9478 8
 12526 00db EC A5                   		mov.L	[r10], r5
 12527 00dd 61 05                   		cmp	#0, r5
 12528 00df 21 18                   		bne	.L866
9479:../src/wolfcrypt/src/ecc.c ****         err = mp_read_unsigned_bin(key->pubkey.x, in, keysize);
 12529                             		.loc 2 9479 47
 12530 00e1 ED A5 05                		mov.L	20[r10], r5
 12531 00e4 71 55 18                		add	#24, r5
 12532                             		.loc 2 9479 15
 12533 00e7 ED A4 01                		mov.L	4[r10], r4
 12534 00ea EF 43                   		mov.L	r4, r3
 12535 00ec ED A2 03                		mov.L	12[r10], r2
 12536 00ef EF 51                   		mov.L	r5, r1
 12537 00f1 05 00 00 00             		bsr	_sp_read_unsigned_bin
 12538 00f5 E3 A1                   		mov.L	r1, [r10]
 12539                             	.L866:
9480:../src/wolfcrypt/src/ecc.c **** 
9481:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
9482:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY && compressed == 1) {   /* build y */
9483:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
9484:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
9485:../src/wolfcrypt/src/ecc.c ****         mp_int* t1 = NULL;
9486:../src/wolfcrypt/src/ecc.c ****         mp_int* t2 = NULL;
9487:../src/wolfcrypt/src/ecc.c ****     #else
9488:../src/wolfcrypt/src/ecc.c ****         mp_int t1[1], t2[1];
9489:../src/wolfcrypt/src/ecc.c ****     #endif
9490:../src/wolfcrypt/src/ecc.c ****         int did_init = 0;
9491:../src/wolfcrypt/src/ecc.c **** 
9492:../src/wolfcrypt/src/ecc.c ****         DECLARE_CURVE_SPECS(3);
9493:../src/wolfcrypt/src/ecc.c ****         ALLOC_CURVE_SPECS(3, err);
9494:../src/wolfcrypt/src/ecc.c **** 
9495:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_SMALL_STACK
9496:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
9497:../src/wolfcrypt/src/ecc.c ****             t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_BIGINT);
9498:../src/wolfcrypt/src/ecc.c ****             if (t1 == NULL) {
9499:../src/wolfcrypt/src/ecc.c ****                 err = MEMORY_E;
9500:../src/wolfcrypt/src/ecc.c ****             }
9501:../src/wolfcrypt/src/ecc.c ****         }
9502:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
9503:../src/wolfcrypt/src/ecc.c ****             t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_BIGINT);
9504:../src/wolfcrypt/src/ecc.c ****             if (t2 == NULL) {
9505:../src/wolfcrypt/src/ecc.c ****                 err = MEMORY_E;
9506:../src/wolfcrypt/src/ecc.c ****             }
9507:../src/wolfcrypt/src/ecc.c ****         }
9508:../src/wolfcrypt/src/ecc.c ****         #endif
9509:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
9510:../src/wolfcrypt/src/ecc.c ****             if (mp_init_multi(t1, t2, NULL, NULL, NULL, NULL) != MP_OKAY)
9511:../src/wolfcrypt/src/ecc.c ****                 err = MEMORY_E;
9512:../src/wolfcrypt/src/ecc.c ****             else
9513:../src/wolfcrypt/src/ecc.c ****                 did_init = 1;
9514:../src/wolfcrypt/src/ecc.c ****         }
9515:../src/wolfcrypt/src/ecc.c **** 
9516:../src/wolfcrypt/src/ecc.c ****         /* load curve info */
9517:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
9518:../src/wolfcrypt/src/ecc.c ****             err = wc_ecc_curve_load(key->dp, &curve,
9519:../src/wolfcrypt/src/ecc.c ****                 (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF |
9520:../src/wolfcrypt/src/ecc.c ****                  ECC_CURVE_FIELD_BF));
9521:../src/wolfcrypt/src/ecc.c **** 
9522:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_CUSTOM_CURVES) && \
9523:../src/wolfcrypt/src/ecc.c ****         defined(WOLFSSL_VALIDATE_ECC_IMPORT)
9524:../src/wolfcrypt/src/ecc.c ****         /* validate prime is prime for custom curves */
9525:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY && key->idx == ECC_CUSTOM_IDX) {
9526:../src/wolfcrypt/src/ecc.c ****             int isPrime = MP_NO;
9527:../src/wolfcrypt/src/ecc.c ****             err = mp_prime_is_prime(curve->prime, 8, &isPrime);
9528:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY && isPrime == MP_NO)
9529:../src/wolfcrypt/src/ecc.c ****                 err = MP_VAL;
9530:../src/wolfcrypt/src/ecc.c ****         }
9531:../src/wolfcrypt/src/ecc.c ****     #endif
9532:../src/wolfcrypt/src/ecc.c **** 
9533:../src/wolfcrypt/src/ecc.c ****         /* compute x^3 */
9534:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
9535:../src/wolfcrypt/src/ecc.c ****             err = mp_sqrmod(key->pubkey.x, curve->prime, t1);
9536:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
9537:../src/wolfcrypt/src/ecc.c ****             err = mp_mulmod(t1, key->pubkey.x, curve->prime, t1);
9538:../src/wolfcrypt/src/ecc.c **** 
9539:../src/wolfcrypt/src/ecc.c ****         /* compute x^3 + a*x */
9540:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
9541:../src/wolfcrypt/src/ecc.c ****             err = mp_mulmod(curve->Af, key->pubkey.x, curve->prime, t2);
9542:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
9543:../src/wolfcrypt/src/ecc.c ****             err = mp_add(t1, t2, t1);
9544:../src/wolfcrypt/src/ecc.c **** 
9545:../src/wolfcrypt/src/ecc.c ****         /* compute x^3 + a*x + b */
9546:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
9547:../src/wolfcrypt/src/ecc.c ****             err = mp_add(t1, curve->Bf, t1);
9548:../src/wolfcrypt/src/ecc.c **** 
9549:../src/wolfcrypt/src/ecc.c ****         /* compute sqrt(x^3 + a*x + b) */
9550:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
9551:../src/wolfcrypt/src/ecc.c ****             err = mp_sqrtmod_prime(t1, curve->prime, t2);
9552:../src/wolfcrypt/src/ecc.c **** 
9553:../src/wolfcrypt/src/ecc.c ****         /* adjust y */
9554:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
9555:../src/wolfcrypt/src/ecc.c ****             if ((mp_isodd(t2) == MP_YES && pointType == ECC_POINT_COMP_ODD) ||
9556:../src/wolfcrypt/src/ecc.c ****                 (mp_isodd(t2) == MP_NO &&  pointType == ECC_POINT_COMP_EVEN)) {
9557:../src/wolfcrypt/src/ecc.c ****                 err = mp_mod(t2, curve->prime, t2);
9558:../src/wolfcrypt/src/ecc.c ****             }
9559:../src/wolfcrypt/src/ecc.c ****             else {
9560:../src/wolfcrypt/src/ecc.c ****                 err = mp_submod(curve->prime, t2, curve->prime, t2);
9561:../src/wolfcrypt/src/ecc.c ****             }
9562:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
9563:../src/wolfcrypt/src/ecc.c ****                 err = mp_copy(t2, key->pubkey.y);
9564:../src/wolfcrypt/src/ecc.c ****         }
9565:../src/wolfcrypt/src/ecc.c **** 
9566:../src/wolfcrypt/src/ecc.c ****         if (did_init) {
9567:../src/wolfcrypt/src/ecc.c ****             mp_clear(t2);
9568:../src/wolfcrypt/src/ecc.c ****             mp_clear(t1);
9569:../src/wolfcrypt/src/ecc.c ****         }
9570:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
9571:../src/wolfcrypt/src/ecc.c ****         if (t1 != NULL) {
9572:../src/wolfcrypt/src/ecc.c ****             XFREE(t1, NULL, DYNAMIC_TYPE_BIGINT);
9573:../src/wolfcrypt/src/ecc.c ****         }
9574:../src/wolfcrypt/src/ecc.c ****         if (t2 != NULL) {
9575:../src/wolfcrypt/src/ecc.c ****             XFREE(t2, NULL, DYNAMIC_TYPE_BIGINT);
9576:../src/wolfcrypt/src/ecc.c ****         }
9577:../src/wolfcrypt/src/ecc.c ****     #endif
9578:../src/wolfcrypt/src/ecc.c **** 
9579:../src/wolfcrypt/src/ecc.c ****         wc_ecc_curve_free(curve);
9580:../src/wolfcrypt/src/ecc.c ****         FREE_CURVE_SPECS();
9581:../src/wolfcrypt/src/ecc.c **** #else
9582:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_SP_NO_256
9583:../src/wolfcrypt/src/ecc.c ****         if (key->dp->id == ECC_SECP256R1) {
9584:../src/wolfcrypt/src/ecc.c ****             sp_ecc_uncompress_256(key->pubkey.x, pointType, key->pubkey.y);
9585:../src/wolfcrypt/src/ecc.c ****         }
9586:../src/wolfcrypt/src/ecc.c ****         else
9587:../src/wolfcrypt/src/ecc.c ****     #endif
9588:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_384
9589:../src/wolfcrypt/src/ecc.c ****         if (key->dp->id == ECC_SECP384R1) {
9590:../src/wolfcrypt/src/ecc.c ****             sp_ecc_uncompress_384(key->pubkey.x, pointType, key->pubkey.y);
9591:../src/wolfcrypt/src/ecc.c ****         }
9592:../src/wolfcrypt/src/ecc.c ****         else
9593:../src/wolfcrypt/src/ecc.c ****     #endif
9594:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SP_521
9595:../src/wolfcrypt/src/ecc.c ****         if (key->dp->id == ECC_SECP521R1) {
9596:../src/wolfcrypt/src/ecc.c ****             sp_ecc_uncompress_521(key->pubkey.x, pointType, key->pubkey.y);
9597:../src/wolfcrypt/src/ecc.c ****         }
9598:../src/wolfcrypt/src/ecc.c ****         else
9599:../src/wolfcrypt/src/ecc.c ****     #endif
9600:../src/wolfcrypt/src/ecc.c ****         {
9601:../src/wolfcrypt/src/ecc.c ****             err = WC_KEY_SIZE_E;
9602:../src/wolfcrypt/src/ecc.c ****         }
9603:../src/wolfcrypt/src/ecc.c **** #endif
9604:../src/wolfcrypt/src/ecc.c ****     }
9605:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_COMP_KEY */
9606:../src/wolfcrypt/src/ecc.c **** 
9607:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 12540                             		.loc 2 9607 8
 12541 00f7 EC A5                   		mov.L	[r10], r5
 12542 00f9 61 05                   		cmp	#0, r5
 12543 00fb 21 1E                   		bne	.L867
9608:../src/wolfcrypt/src/ecc.c ****     #ifdef HAVE_COMP_KEY
9609:../src/wolfcrypt/src/ecc.c ****         if (compressed == 0)
9610:../src/wolfcrypt/src/ecc.c ****     #endif
9611:../src/wolfcrypt/src/ecc.c ****         {
9612:../src/wolfcrypt/src/ecc.c ****             err = mp_read_unsigned_bin(key->pubkey.y, in + keysize,
 12544                             		.loc 2 9612 51
 12545 00fd ED A5 05                		mov.L	20[r10], r5
 12546 0100 72 51 28 03             		add	#0x328, r5, r1
 12547                             		.loc 2 9612 19
 12548 0104 ED A5 01                		mov.L	4[r10], r5
 12549 0107 ED A4 03                		mov.L	12[r10], r4
 12550 010a 4B 45                   		add	r4, r5
 12551 010c ED A4 01                		mov.L	4[r10], r4
 12552 010f EF 43                   		mov.L	r4, r3
 12553 0111 EF 52                   		mov.L	r5, r2
 12554 0113 05 00 00 00             		bsr	_sp_read_unsigned_bin
 12555 0117 E3 A1                   		mov.L	r1, [r10]
 12556                             	.L867:
9613:../src/wolfcrypt/src/ecc.c ****                                                                       keysize);
9614:../src/wolfcrypt/src/ecc.c ****         }
9615:../src/wolfcrypt/src/ecc.c ****     }
9616:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 12557                             		.loc 2 9616 8
 12558 0119 EC A5                   		mov.L	[r10], r5
 12559 011b 61 05                   		cmp	#0, r5
 12560 011d 21 13                   		bne	.L868
9617:../src/wolfcrypt/src/ecc.c ****         err = mp_set(key->pubkey.z, 1);
 12561                             		.loc 2 9617 33
 12562 011f ED A5 05                		mov.L	20[r10], r5
 12563 0122 72 55 38 06             		add	#0x638, r5
 12564                             		.loc 2 9617 15
 12565 0126 66 12                   		mov.L	#1, r2
 12566 0128 EF 51                   		mov.L	r5, r1
 12567 012a 05 00 00 00             		bsr	_sp_set
 12568 012e E3 A1                   		mov.L	r1, [r10]
 12569                             	.L868:
9618:../src/wolfcrypt/src/ecc.c **** 
9619:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CRYPTOCELL
9620:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
9621:../src/wolfcrypt/src/ecc.c ****         pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(key->dp->id));
9622:../src/wolfcrypt/src/ecc.c **** 
9623:../src/wolfcrypt/src/ecc.c ****         /* create public key from external key buffer */
9624:../src/wolfcrypt/src/ecc.c ****         err = CRYS_ECPKI_BuildPublKeyFullCheck(pDomain,
9625:../src/wolfcrypt/src/ecc.c ****                                                (byte*)in-1, /* re-adjust */
9626:../src/wolfcrypt/src/ecc.c ****                                                inLen+1,     /* original input */
9627:../src/wolfcrypt/src/ecc.c ****                                                &key->ctx.pubKey,
9628:../src/wolfcrypt/src/ecc.c ****                                                &tempBuff);
9629:../src/wolfcrypt/src/ecc.c **** 
9630:../src/wolfcrypt/src/ecc.c ****         if (err != SA_SILIB_RET_OK){
9631:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("CRYS_ECPKI_BuildPublKeyFullCheck failed");
9632:../src/wolfcrypt/src/ecc.c ****         }
9633:../src/wolfcrypt/src/ecc.c ****     }
9634:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
9635:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
9636:../src/wolfcrypt/src/ecc.c ****         err = silabs_ecc_import(key, keysize);
9637:../src/wolfcrypt/src/ecc.c **** #endif
9638:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_VALIDATE_ECC_IMPORT
9639:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
9640:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_check_key(key);
9641:../src/wolfcrypt/src/ecc.c **** #endif
9642:../src/wolfcrypt/src/ecc.c **** 
9643:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY) {
 12570                             		.loc 2 9643 8
 12571 0130 EC A5                   		mov.L	[r10], r5
 12572 0132 61 05                   		cmp	#0, r5
 12573 0134 20 35                   		beq	.L869
9644:../src/wolfcrypt/src/ecc.c ****         mp_clear(key->pubkey.x);
 12574                             		.loc 2 9644 29
 12575 0136 ED A5 05                		mov.L	20[r10], r5
 12576 0139 71 55 18                		add	#24, r5
 12577                             		.loc 2 9644 9
 12578 013c EF 51                   		mov.L	r5, r1
 12579 013e 05 00 00 00             		bsr	_sp_clear
9645:../src/wolfcrypt/src/ecc.c ****         mp_clear(key->pubkey.y);
 12580                             		.loc 2 9645 29
 12581 0142 ED A5 05                		mov.L	20[r10], r5
 12582 0145 72 55 28 03             		add	#0x328, r5
 12583                             		.loc 2 9645 9
 12584 0149 EF 51                   		mov.L	r5, r1
 12585 014b 05 00 00 00             		bsr	_sp_clear
9646:../src/wolfcrypt/src/ecc.c ****         mp_clear(key->pubkey.z);
 12586                             		.loc 2 9646 29
 12587 014f ED A5 05                		mov.L	20[r10], r5
 12588 0152 72 55 38 06             		add	#0x638, r5
 12589                             		.loc 2 9646 9
 12590 0156 EF 51                   		mov.L	r5, r1
 12591 0158 05 00 00 00             		bsr	_sp_clear
9647:../src/wolfcrypt/src/ecc.c ****         mp_clear(&key->k);
 12592                             		.loc 2 9647 18
 12593 015c ED A5 05                		mov.L	20[r10], r5
 12594 015f 72 55 48 09             		add	#0x948, r5
 12595                             		.loc 2 9647 9
 12596 0163 EF 51                   		mov.L	r5, r1
 12597 0165 05 00 00 00             		bsr	_sp_clear
 12598                             	.L869:
9648:../src/wolfcrypt/src/ecc.c ****     }
9649:../src/wolfcrypt/src/ecc.c **** 
9650:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
9651:../src/wolfcrypt/src/ecc.c **** 
9652:../src/wolfcrypt/src/ecc.c ****     return err;
 12599                             		.loc 2 9652 12
 12600 0169 EC A5                   		mov.L	[r10], r5
 12601                             		.balign 8,3,1
 12602                             	.L859:
9653:../src/wolfcrypt/src/ecc.c **** }
 12603                             		.loc 2 9653 1
 12604 016b EF 51                   		mov.L	r5, r1
 12605 016d 3F AA 0A                		rtsd	#40, r10-r10
 12606                             	.LFE122:
 12608                             		.section	.text.wc_ecc_import_x963,"ax",@progbits
 12609                             		.global	_wc_ecc_import_x963
 12611                             	_wc_ecc_import_x963:
 12612                             	.LFB123:
9654:../src/wolfcrypt/src/ecc.c **** 
9655:../src/wolfcrypt/src/ecc.c **** WOLFSSL_ABI
9656:../src/wolfcrypt/src/ecc.c **** int wc_ecc_import_x963(const byte* in, word32 inLen, ecc_key* key)
9657:../src/wolfcrypt/src/ecc.c **** {
 12613                             		.loc 2 9657 1
 12614 0000 7E AA                   		push.l	r10
 12615                             	.LCFI207:
 12616 0002 71 0A F4                		add	#-12, r0, r10
 12617                             	.LCFI208:
 12618 0005 EF A0                   		mov.L	r10, r0
 12619 0007 E3 A1                   		mov.L	r1, [r10]
 12620 0009 E7 A2 01                		mov.L	r2, 4[r10]
 12621 000c E7 A3 02                		mov.L	r3, 8[r10]
9658:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_import_x963_ex(in, inLen, key, ECC_CURVE_DEF);
 12622                             		.loc 2 9658 12
 12623 000f 66 04                   		mov.L	#0, r4
 12624 0011 ED A3 02                		mov.L	8[r10], r3
 12625 0014 ED A2 01                		mov.L	4[r10], r2
 12626 0017 EC A1                   		mov.L	[r10], r1
 12627 0019 05 00 00 00             		bsr	_wc_ecc_import_x963_ex
 12628 001d EF 15                   		mov.L	r1, r5
9659:../src/wolfcrypt/src/ecc.c **** }
 12629                             		.loc 2 9659 1
 12630 001f EF 51                   		mov.L	r5, r1
 12631 0021 3F AA 04                		rtsd	#16, r10-r10
 12632                             	.LFE123:
 12634                             		.section	.text.wc_ecc_export_ex,"ax",@progbits
 12635                             		.global	_wc_ecc_export_ex
 12637                             	_wc_ecc_export_ex:
 12638                             	.LFB124:
9660:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_KEY_IMPORT */
9661:../src/wolfcrypt/src/ecc.c **** 
9662:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_KEY_EXPORT
9663:../src/wolfcrypt/src/ecc.c **** 
9664:../src/wolfcrypt/src/ecc.c **** /* export ecc key to component form, d is optional if only exporting public
9665:../src/wolfcrypt/src/ecc.c ****  * encType is WC_TYPE_UNSIGNED_BIN or WC_TYPE_HEX_STR
9666:../src/wolfcrypt/src/ecc.c ****  * return MP_OKAY on success */
9667:../src/wolfcrypt/src/ecc.c **** int wc_ecc_export_ex(ecc_key* key, byte* qx, word32* qxLen,
9668:../src/wolfcrypt/src/ecc.c ****                  byte* qy, word32* qyLen, byte* d, word32* dLen, int encType)
9669:../src/wolfcrypt/src/ecc.c **** {
 12639                             		.loc 2 9669 1
 12640 0000 7E AA                   		push.l	r10
 12641                             	.LCFI209:
 12642 0002 7E A6                   		push.l	r6
 12643                             	.LCFI210:
 12644 0004 71 0A D8                		add	#-40, r0, r10
 12645                             	.LCFI211:
 12646 0007 71 A0 FC                		add	#-4, r10, r0
 12647                             	.LCFI212:
 12648 000a 75 46 34                		mov.L	#52, r6
 12649 000d 4B A6                   		add	r10, r6
 12650 000f E7 A1 02                		mov.L	r1, 8[r10]
 12651 0012 E7 A2 03                		mov.L	r2, 12[r10]
 12652 0015 E7 A3 04                		mov.L	r3, 16[r10]
 12653 0018 E7 A4 05                		mov.L	r4, 20[r10]
9670:../src/wolfcrypt/src/ecc.c ****     int err = 0;
 12654                             		.loc 2 9670 9
 12655 001b F8 A6 00                		mov.L	#0, [r10]
9671:../src/wolfcrypt/src/ecc.c ****     word32 keySz;
9672:../src/wolfcrypt/src/ecc.c **** 
9673:../src/wolfcrypt/src/ecc.c ****     if (key == NULL) {
 12656                             		.loc 2 9673 8
 12657 001e ED A5 02                		mov.L	8[r10], r5
 12658 0021 61 05                   		cmp	#0, r5
 12659 0023 18                      		bne	.L873
9674:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 12660                             		.loc 2 9674 16
 12661 0024 FB 5A 53 FF             		mov.L	#-173, r5
 12662 0028 38 F2 00                		bra	.L874
 12663                             	.L873:
9675:../src/wolfcrypt/src/ecc.c ****     }
9676:../src/wolfcrypt/src/ecc.c **** 
9677:../src/wolfcrypt/src/ecc.c ****     if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {
 12664                             		.loc 2 9677 9
 12665 002b ED A5 02                		mov.L	8[r10], r5
 12666 002e A8 5D                   		mov.L	4[r5], r5
 12667 0030 EF 51                   		mov.L	r5, r1
 12668 0032 05 00 00 00             		bsr	_wc_ecc_is_valid_idx
 12669 0036 EF 15                   		mov.L	r1, r5
 12670                             		.loc 2 9677 8
 12671 0038 61 05                   		cmp	#0, r5
 12672 003a 11                      		beq	.L875
 12673                             		.loc 2 9677 50 discriminator 1
 12674 003b ED A5 02                		mov.L	8[r10], r5
 12675 003e A9 55                   		mov.L	16[r5], r5
 12676                             		.loc 2 9677 44 discriminator 1
 12677 0040 61 05                   		cmp	#0, r5
 12678 0042 18                      		bne	.L876
 12679                             	.L875:
9678:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 12680                             		.loc 2 9678 16
 12681 0043 FB 5A 56 FF             		mov.L	#-170, r5
 12682 0047 38 D3 00                		bra	.L874
 12683                             	.L876:
9679:../src/wolfcrypt/src/ecc.c ****     }
9680:../src/wolfcrypt/src/ecc.c ****     keySz = key->dp->size;
 12684                             		.loc 2 9680 16
 12685 004a ED A5 02                		mov.L	8[r10], r5
 12686 004d A9 55                   		mov.L	16[r5], r5
 12687                             		.loc 2 9680 20
 12688 004f EC 55                   		mov.L	[r5], r5
 12689                             		.loc 2 9680 11
 12690 0051 E7 A5 01                		mov.L	r5, 4[r10]
9681:../src/wolfcrypt/src/ecc.c **** 
9682:../src/wolfcrypt/src/ecc.c ****     /* private key, d */
9683:../src/wolfcrypt/src/ecc.c ****     if (d != NULL) {
 12691                             		.loc 2 9683 8
 12692 0054 A8 6D                   		mov.L	4[r6], r5
 12693 0056 61 05                   		cmp	#0, r5
 12694 0058 20 44                   		beq	.L877
9684:../src/wolfcrypt/src/ecc.c ****         if (dLen == NULL ||
 12695                             		.loc 2 9684 12
 12696 005a A8 E5                   		mov.L	8[r6], r5
 12697 005c 61 05                   		cmp	#0, r5
 12698 005e 20 13                   		beq	.L878
9685:../src/wolfcrypt/src/ecc.c ****             (key->type != ECC_PRIVATEKEY && key->type != ECC_PRIVATEKEY_ONLY))
 12699                             		.loc 2 9685 17 discriminator 1
 12700 0060 ED A5 02                		mov.L	8[r10], r5
 12701 0063 EC 55                   		mov.L	[r5], r5
9684:../src/wolfcrypt/src/ecc.c ****         if (dLen == NULL ||
 12702                             		.loc 2 9684 26 discriminator 1
 12703 0065 61 25                   		cmp	#2, r5
 12704 0067 20 11                   		beq	.L879
 12705                             		.loc 2 9685 48
 12706 0069 ED A5 02                		mov.L	8[r10], r5
 12707 006c EC 55                   		mov.L	[r5], r5
 12708                             		.loc 2 9685 42
 12709 006e 61 35                   		cmp	#3, r5
 12710 0070 10                      		beq	.L879
 12711                             	.L878:
9686:../src/wolfcrypt/src/ecc.c ****             return BAD_FUNC_ARG;
 12712                             		.loc 2 9686 20
 12713 0071 FB 5A 53 FF             		mov.L	#-173, r5
 12714 0075 38 A5 00                		bra	.L874
 12715                             	.L879:
9687:../src/wolfcrypt/src/ecc.c **** 
9688:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
9689:../src/wolfcrypt/src/ecc.c ****         /* Hardware cannot export private portion */
9690:../src/wolfcrypt/src/ecc.c ****         return NOT_COMPILED_IN;
9691:../src/wolfcrypt/src/ecc.c ****     #else
9692:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_SECO_CAAM)
9693:../src/wolfcrypt/src/ecc.c ****         if (key->blackKey > 0 && key->devId == WOLFSSL_SECO_DEVID) {
9694:../src/wolfcrypt/src/ecc.c ****             /* Hardware cannot export private portion */
9695:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("Can not export private key from HSM");
9696:../src/wolfcrypt/src/ecc.c ****             return NOT_COMPILED_IN;
9697:../src/wolfcrypt/src/ecc.c ****         }
9698:../src/wolfcrypt/src/ecc.c ****     #endif
9699:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_QNX_CAAM
9700:../src/wolfcrypt/src/ecc.c ****         if (key->blackKey == CAAM_BLACK_KEY_CCM) {
9701:../src/wolfcrypt/src/ecc.c ****             if (*dLen < keySz + WC_CAAM_MAC_SZ) {
9702:../src/wolfcrypt/src/ecc.c ****                 *dLen = keySz + WC_CAAM_MAC_SZ;
9703:../src/wolfcrypt/src/ecc.c ****                 return BUFFER_E;
9704:../src/wolfcrypt/src/ecc.c ****             }
9705:../src/wolfcrypt/src/ecc.c **** 
9706:../src/wolfcrypt/src/ecc.c ****             err = wc_export_int(&key->k, d, dLen, keySz + WC_CAAM_MAC_SZ,
9707:../src/wolfcrypt/src/ecc.c ****                 encType);
9708:../src/wolfcrypt/src/ecc.c ****             *dLen = keySz + WC_CAAM_MAC_SZ;
9709:../src/wolfcrypt/src/ecc.c ****         }
9710:../src/wolfcrypt/src/ecc.c ****         else if (encType == WC_TYPE_BLACK_KEY &&
9711:../src/wolfcrypt/src/ecc.c ****                 key->blackKey != CAAM_BLACK_KEY_ECB &&
9712:../src/wolfcrypt/src/ecc.c ****                 key->blackKey > 0) {
9713:../src/wolfcrypt/src/ecc.c ****             if (*dLen < keySz + WC_CAAM_MAC_SZ) {
9714:../src/wolfcrypt/src/ecc.c ****                 *dLen = keySz + WC_CAAM_MAC_SZ;
9715:../src/wolfcrypt/src/ecc.c ****                 return BUFFER_E;
9716:../src/wolfcrypt/src/ecc.c ****             }
9717:../src/wolfcrypt/src/ecc.c **** 
9718:../src/wolfcrypt/src/ecc.c ****             if (key->blackKey != CAAM_BLACK_KEY_CCM) {
9719:../src/wolfcrypt/src/ecc.c ****                 if (caamReadPartition(key->blackKey, d, keySz + WC_CAAM_MAC_SZ) != 0)
9720:../src/wolfcrypt/src/ecc.c ****                     return WC_HW_E;
9721:../src/wolfcrypt/src/ecc.c ****             }
9722:../src/wolfcrypt/src/ecc.c **** 
9723:../src/wolfcrypt/src/ecc.c ****             *dLen = keySz + WC_CAAM_MAC_SZ;
9724:../src/wolfcrypt/src/ecc.c ****         }
9725:../src/wolfcrypt/src/ecc.c ****         else
9726:../src/wolfcrypt/src/ecc.c ****     #endif
9727:../src/wolfcrypt/src/ecc.c ****         {
9728:../src/wolfcrypt/src/ecc.c ****             err = wc_export_int(&key->k, d, dLen, keySz, encType);
 12716                             		.loc 2 9728 19
 12717 0078 ED A5 02                		mov.L	8[r10], r5
 12718 007b 72 55 48 09             		add	#0x948, r5
 12719 007f A8 EC                   		mov.L	12[r6], r4
 12720 0081 E3 04                   		mov.L	r4, [r0]
 12721 0083 ED A4 01                		mov.L	4[r10], r4
 12722 0086 A8 E3                   		mov.L	8[r6], r3
 12723 0088 A8 6A                   		mov.L	4[r6], r2
 12724 008a EF 51                   		mov.L	r5, r1
 12725 008c 05 00 00 00             		bsr	_wc_export_int
 12726 0090 E3 A1                   		mov.L	r1, [r10]
9729:../src/wolfcrypt/src/ecc.c ****             if (err != MP_OKAY)
 12727                             		.loc 2 9729 16
 12728 0092 EC A5                   		mov.L	[r10], r5
 12729 0094 61 05                   		cmp	#0, r5
 12730 0096 16                      		beq	.L877
9730:../src/wolfcrypt/src/ecc.c ****                 return err;
 12731                             		.loc 2 9730 24
 12732 0097 EC A5                   		mov.L	[r10], r5
 12733 0099 38 81 00                		bra	.L874
 12734                             	.L877:
9731:../src/wolfcrypt/src/ecc.c ****         }
9732:../src/wolfcrypt/src/ecc.c ****     #endif
9733:../src/wolfcrypt/src/ecc.c ****     }
9734:../src/wolfcrypt/src/ecc.c **** 
9735:../src/wolfcrypt/src/ecc.c ****     /* public x component */
9736:../src/wolfcrypt/src/ecc.c ****     if (qx != NULL) {
 12735                             		.loc 2 9736 8
 12736 009c ED A5 03                		mov.L	12[r10], r5
 12737 009f 61 05                   		cmp	#0, r5
 12738 00a1 20 3A                   		beq	.L880
9737:../src/wolfcrypt/src/ecc.c ****         if (qxLen == NULL || key->type == ECC_PRIVATEKEY_ONLY)
 12739                             		.loc 2 9737 12
 12740 00a3 ED A5 04                		mov.L	16[r10], r5
 12741 00a6 61 05                   		cmp	#0, r5
 12742 00a8 11                      		beq	.L881
 12743                             		.loc 2 9737 33 discriminator 1
 12744 00a9 ED A5 02                		mov.L	8[r10], r5
 12745 00ac EC 55                   		mov.L	[r5], r5
 12746                             		.loc 2 9737 27 discriminator 1
 12747 00ae 61 35                   		cmp	#3, r5
 12748 00b0 1F                      		bne	.L882
 12749                             	.L881:
9738:../src/wolfcrypt/src/ecc.c ****             return BAD_FUNC_ARG;
 12750                             		.loc 2 9738 20
 12751 00b1 FB 5A 53 FF             		mov.L	#-173, r5
 12752 00b5 2E 65                   		bra	.L874
 12753                             	.L882:
9739:../src/wolfcrypt/src/ecc.c **** 
9740:../src/wolfcrypt/src/ecc.c ****         err = wc_export_int(key->pubkey.x, qx, qxLen, keySz, encType);
 12754                             		.loc 2 9740 40
 12755 00b7 ED A5 02                		mov.L	8[r10], r5
 12756 00ba 71 55 18                		add	#24, r5
 12757                             		.loc 2 9740 15
 12758 00bd A8 EC                   		mov.L	12[r6], r4
 12759 00bf E3 04                   		mov.L	r4, [r0]
 12760 00c1 ED A4 01                		mov.L	4[r10], r4
 12761 00c4 ED A3 04                		mov.L	16[r10], r3
 12762 00c7 ED A2 03                		mov.L	12[r10], r2
 12763 00ca EF 51                   		mov.L	r5, r1
 12764 00cc 05 00 00 00             		bsr	_wc_export_int
 12765 00d0 E3 A1                   		mov.L	r1, [r10]
9741:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY)
 12766                             		.loc 2 9741 12
 12767 00d2 EC A5                   		mov.L	[r10], r5
 12768 00d4 61 05                   		cmp	#0, r5
 12769 00d6 15                      		beq	.L880
9742:../src/wolfcrypt/src/ecc.c ****             return err;
 12770                             		.loc 2 9742 20
 12771 00d7 EC A5                   		mov.L	[r10], r5
 12772 00d9 2E 41                   		bra	.L874
 12773                             	.L880:
9743:../src/wolfcrypt/src/ecc.c ****     }
9744:../src/wolfcrypt/src/ecc.c **** 
9745:../src/wolfcrypt/src/ecc.c ****     /* public y component */
9746:../src/wolfcrypt/src/ecc.c ****     if (qy != NULL) {
 12774                             		.loc 2 9746 8
 12775 00db ED A5 05                		mov.L	20[r10], r5
 12776 00de 61 05                   		cmp	#0, r5
 12777 00e0 20 38                   		beq	.L883
9747:../src/wolfcrypt/src/ecc.c ****         if (qyLen == NULL || key->type == ECC_PRIVATEKEY_ONLY)
 12778                             		.loc 2 9747 12
 12779 00e2 EC 65                   		mov.L	[r6], r5
 12780 00e4 61 05                   		cmp	#0, r5
 12781 00e6 11                      		beq	.L884
 12782                             		.loc 2 9747 33 discriminator 1
 12783 00e7 ED A5 02                		mov.L	8[r10], r5
 12784 00ea EC 55                   		mov.L	[r5], r5
 12785                             		.loc 2 9747 27 discriminator 1
 12786 00ec 61 35                   		cmp	#3, r5
 12787 00ee 1F                      		bne	.L885
 12788                             	.L884:
9748:../src/wolfcrypt/src/ecc.c ****             return BAD_FUNC_ARG;
 12789                             		.loc 2 9748 20
 12790 00ef FB 5A 53 FF             		mov.L	#-173, r5
 12791 00f3 2E 27                   		bra	.L874
 12792                             	.L885:
9749:../src/wolfcrypt/src/ecc.c **** 
9750:../src/wolfcrypt/src/ecc.c ****         err = wc_export_int(key->pubkey.y, qy, qyLen, keySz, encType);
 12793                             		.loc 2 9750 40
 12794 00f5 ED A5 02                		mov.L	8[r10], r5
 12795 00f8 72 55 28 03             		add	#0x328, r5
 12796                             		.loc 2 9750 15
 12797 00fc A8 EC                   		mov.L	12[r6], r4
 12798 00fe E3 04                   		mov.L	r4, [r0]
 12799 0100 ED A4 01                		mov.L	4[r10], r4
 12800 0103 EC 63                   		mov.L	[r6], r3
 12801 0105 ED A2 05                		mov.L	20[r10], r2
 12802 0108 EF 51                   		mov.L	r5, r1
 12803 010a 05 00 00 00             		bsr	_wc_export_int
 12804 010e E3 A1                   		mov.L	r1, [r10]
9751:../src/wolfcrypt/src/ecc.c ****         if (err != MP_OKAY)
 12805                             		.loc 2 9751 12
 12806 0110 EC A5                   		mov.L	[r10], r5
 12807 0112 61 05                   		cmp	#0, r5
 12808 0114 14                      		beq	.L883
9752:../src/wolfcrypt/src/ecc.c ****             return err;
 12809                             		.loc 2 9752 20
 12810 0115 EC A5                   		mov.L	[r10], r5
 12811 0117 0B                      		bra	.L874
 12812                             	.L883:
9753:../src/wolfcrypt/src/ecc.c ****     }
9754:../src/wolfcrypt/src/ecc.c **** 
9755:../src/wolfcrypt/src/ecc.c ****     return err;
 12813                             		.loc 2 9755 12
 12814 0118 EC A5                   		mov.L	[r10], r5
 12815                             		.balign 8,3,1
 12816                             	.L874:
9756:../src/wolfcrypt/src/ecc.c **** }
 12817                             		.loc 2 9756 1
 12818 011a EF 51                   		mov.L	r5, r1
 12819 011c 71 00 2C                		add	#44, r0
 12820 011f 7E B6                   		pop	r6
 12821 0121 7E BA                   		pop	r10
 12822 0123 02                      		rts
 12823                             	.LFE124:
 12825 0124 76 10 01 00             		.section	.text.wc_ecc_export_private_only,"ax",@progbits
 12826                             		.global	_wc_ecc_export_private_only
 12828                             	_wc_ecc_export_private_only:
 12829                             	.LFB125:
9757:../src/wolfcrypt/src/ecc.c **** 
9758:../src/wolfcrypt/src/ecc.c **** 
9759:../src/wolfcrypt/src/ecc.c **** /* export ecc private key only raw, outLen is in/out size as unsigned bin
9760:../src/wolfcrypt/src/ecc.c ****    return MP_OKAY on success */
9761:../src/wolfcrypt/src/ecc.c **** int wc_ecc_export_private_only(ecc_key* key, byte* out, word32* outLen)
9762:../src/wolfcrypt/src/ecc.c **** {
 12830                             		.loc 2 9762 1
 12831 0000 7E AA                   		push.l	r10
 12832                             	.LCFI213:
 12833 0002 71 0A F4                		add	#-12, r0, r10
 12834                             	.LCFI214:
 12835 0005 71 A0 F0                		add	#-16, r10, r0
 12836                             	.LCFI215:
 12837 0008 E3 A1                   		mov.L	r1, [r10]
 12838 000a E7 A2 01                		mov.L	r2, 4[r10]
 12839 000d E7 A3 02                		mov.L	r3, 8[r10]
9763:../src/wolfcrypt/src/ecc.c ****     if (out == NULL || outLen == NULL) {
 12840                             		.loc 2 9763 8
 12841 0010 ED A5 01                		mov.L	4[r10], r5
 12842 0013 61 05                   		cmp	#0, r5
 12843 0015 17                      		beq	.L887
 12844                             		.loc 2 9763 21 discriminator 1
 12845 0016 ED A5 02                		mov.L	8[r10], r5
 12846 0019 61 05                   		cmp	#0, r5
 12847 001b 1F                      		bne	.L888
 12848                             	.L887:
9764:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 12849                             		.loc 2 9764 16
 12850 001c FB 5A 53 FF             		mov.L	#-173, r5
 12851 0020 2E 20                   		bra	.L889
 12852                             	.L888:
9765:../src/wolfcrypt/src/ecc.c ****     }
9766:../src/wolfcrypt/src/ecc.c **** 
9767:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_QNX_CAAM
9768:../src/wolfcrypt/src/ecc.c ****     /* check if black key in secure memory */
9769:../src/wolfcrypt/src/ecc.c ****     if ((key->blackKey != CAAM_BLACK_KEY_CCM &&
9770:../src/wolfcrypt/src/ecc.c ****          key->blackKey != CAAM_BLACK_KEY_ECB) && key->blackKey > 0) {
9771:../src/wolfcrypt/src/ecc.c ****         return wc_ecc_export_ex(key, NULL, NULL, NULL, NULL, out, outLen,
9772:../src/wolfcrypt/src/ecc.c ****             WC_TYPE_BLACK_KEY);
9773:../src/wolfcrypt/src/ecc.c ****     }
9774:../src/wolfcrypt/src/ecc.c **** #endif
9775:../src/wolfcrypt/src/ecc.c **** 
9776:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_export_ex(key, NULL, NULL, NULL, NULL, out, outLen,
 12853                             		.loc 2 9776 12
 12854 0022 3E 03 02                		mov.L	#2, 12[r0]
 12855 0025 ED A5 02                		mov.L	8[r10], r5
 12856 0028 A0 85                   		mov.L	r5, 8[r0]
 12857 002a ED A5 01                		mov.L	4[r10], r5
 12858 002d A0 0D                   		mov.L	r5, 4[r0]
 12859 002f F8 06 00                		mov.L	#0, [r0]
 12860 0032 66 04                   		mov.L	#0, r4
 12861 0034 66 03                   		mov.L	#0, r3
 12862 0036 66 02                   		mov.L	#0, r2
 12863 0038 EC A1                   		mov.L	[r10], r1
 12864 003a 05 00 00 00             		bsr	_wc_ecc_export_ex
 12865 003e EF 15                   		mov.L	r1, r5
 12866                             	.L889:
9777:../src/wolfcrypt/src/ecc.c ****         WC_TYPE_UNSIGNED_BIN);
9778:../src/wolfcrypt/src/ecc.c **** }
 12867                             		.loc 2 9778 1
 12868 0040 EF 51                   		mov.L	r5, r1
 12869 0042 3F AA 08                		rtsd	#32, r10-r10
 12870                             	.LFE125:
 12872                             		.section	.text.wc_ecc_export_public_raw,"ax",@progbits
 12873                             		.global	_wc_ecc_export_public_raw
 12875                             	_wc_ecc_export_public_raw:
 12876                             	.LFB126:
9779:../src/wolfcrypt/src/ecc.c **** 
9780:../src/wolfcrypt/src/ecc.c **** /* export public key to raw elements including public (Qx,Qy) as unsigned bin
9781:../src/wolfcrypt/src/ecc.c ****  * return MP_OKAY on success, negative on error */
9782:../src/wolfcrypt/src/ecc.c **** int wc_ecc_export_public_raw(ecc_key* key, byte* qx, word32* qxLen,
9783:../src/wolfcrypt/src/ecc.c ****                              byte* qy, word32* qyLen)
9784:../src/wolfcrypt/src/ecc.c **** {
 12877                             		.loc 2 9784 1
 12878 0000 7E AA                   		push.l	r10
 12879                             	.LCFI216:
 12880 0002 71 0A EC                		add	#-20, r0, r10
 12881                             	.LCFI217:
 12882 0005 71 A0 F0                		add	#-16, r10, r0
 12883                             	.LCFI218:
 12884 0008 75 45 1C                		mov.L	#28, r5
 12885 000b 4B A5                   		add	r10, r5
 12886 000d E3 A1                   		mov.L	r1, [r10]
 12887 000f E7 A2 01                		mov.L	r2, 4[r10]
 12888 0012 E7 A3 02                		mov.L	r3, 8[r10]
 12889 0015 E7 A4 03                		mov.L	r4, 12[r10]
9785:../src/wolfcrypt/src/ecc.c ****     if (qx == NULL || qxLen == NULL || qy == NULL || qyLen == NULL) {
 12890                             		.loc 2 9785 8
 12891 0018 ED A4 01                		mov.L	4[r10], r4
 12892 001b 61 04                   		cmp	#0, r4
 12893 001d 20 14                   		beq	.L891
 12894                             		.loc 2 9785 20 discriminator 1
 12895 001f ED A4 02                		mov.L	8[r10], r4
 12896 0022 61 04                   		cmp	#0, r4
 12897 0024 20 0D                   		beq	.L891
 12898                             		.loc 2 9785 37 discriminator 2
 12899 0026 ED A4 03                		mov.L	12[r10], r4
 12900 0029 61 04                   		cmp	#0, r4
 12901 002b 16                      		beq	.L891
 12902                             		.loc 2 9785 51 discriminator 3
 12903 002c EC 54                   		mov.L	[r5], r4
 12904 002e 61 04                   		cmp	#0, r4
 12905 0030 1F                      		bne	.L892
 12906                             		.balign 8,3,2
 12907                             	.L891:
9786:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 12908                             		.loc 2 9786 16
 12909 0031 FB 5A 53 FF             		mov.L	#-173, r5
 12910 0035 2E 20                   		bra	.L893
 12911                             	.L892:
9787:../src/wolfcrypt/src/ecc.c ****     }
9788:../src/wolfcrypt/src/ecc.c **** 
9789:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_export_ex(key, qx, qxLen, qy, qyLen, NULL, NULL,
 12912                             		.loc 2 9789 12
 12913 0037 3E 03 02                		mov.L	#2, 12[r0]
 12914 003a 3E 02 00                		mov.L	#0, 8[r0]
 12915 003d 3E 01 00                		mov.L	#0, 4[r0]
 12916 0040 EC 55                   		mov.L	[r5], r5
 12917 0042 E3 05                   		mov.L	r5, [r0]
 12918 0044 ED A4 03                		mov.L	12[r10], r4
 12919 0047 ED A3 02                		mov.L	8[r10], r3
 12920 004a ED A2 01                		mov.L	4[r10], r2
 12921 004d EC A1                   		mov.L	[r10], r1
 12922 004f 05 00 00 00             		bsr	_wc_ecc_export_ex
 12923 0053 EF 15                   		mov.L	r1, r5
 12924                             	.L893:
9790:../src/wolfcrypt/src/ecc.c ****         WC_TYPE_UNSIGNED_BIN);
9791:../src/wolfcrypt/src/ecc.c **** }
 12925                             		.loc 2 9791 1
 12926 0055 EF 51                   		mov.L	r5, r1
 12927 0057 3F AA 0A                		rtsd	#40, r10-r10
 12928                             	.LFE126:
 12930 005a 74 10 01 00 00 00       		.section	.text.wc_ecc_export_private_raw,"ax",@progbits
 12931                             		.global	_wc_ecc_export_private_raw
 12933                             	_wc_ecc_export_private_raw:
 12934                             	.LFB127:
9792:../src/wolfcrypt/src/ecc.c **** 
9793:../src/wolfcrypt/src/ecc.c **** /* export ecc key to raw elements including public (Qx,Qy) and
9794:../src/wolfcrypt/src/ecc.c ****  *   private (d) as unsigned bin
9795:../src/wolfcrypt/src/ecc.c ****  * return MP_OKAY on success, negative on error */
9796:../src/wolfcrypt/src/ecc.c **** int wc_ecc_export_private_raw(ecc_key* key, byte* qx, word32* qxLen,
9797:../src/wolfcrypt/src/ecc.c ****                               byte* qy, word32* qyLen, byte* d, word32* dLen)
9798:../src/wolfcrypt/src/ecc.c **** {
 12935                             		.loc 2 9798 1
 12936 0000 7E AA                   		push.l	r10
 12937                             	.LCFI219:
 12938 0002 71 0A E4                		add	#-28, r0, r10
 12939                             	.LCFI220:
 12940 0005 71 A0 F0                		add	#-16, r10, r0
 12941                             	.LCFI221:
 12942 0008 75 45 24                		mov.L	#36, r5
 12943 000b 4B A5                   		add	r10, r5
 12944 000d E3 A1                   		mov.L	r1, [r10]
 12945 000f E7 A2 01                		mov.L	r2, 4[r10]
 12946 0012 E7 A3 02                		mov.L	r3, 8[r10]
 12947 0015 E7 A4 03                		mov.L	r4, 12[r10]
9799:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_export_ex(key, qx, qxLen, qy, qyLen, d, dLen,
 12948                             		.loc 2 9799 12
 12949 0018 3E 03 02                		mov.L	#2, 12[r0]
 12950 001b A8 D4                   		mov.L	8[r5], r4
 12951 001d A0 84                   		mov.L	r4, 8[r0]
 12952 001f A8 5C                   		mov.L	4[r5], r4
 12953 0021 A0 0C                   		mov.L	r4, 4[r0]
 12954 0023 EC 55                   		mov.L	[r5], r5
 12955 0025 E3 05                   		mov.L	r5, [r0]
 12956 0027 ED A4 03                		mov.L	12[r10], r4
 12957 002a ED A3 02                		mov.L	8[r10], r3
 12958 002d ED A2 01                		mov.L	4[r10], r2
 12959 0030 EC A1                   		mov.L	[r10], r1
 12960 0032 05 00 00 00             		bsr	_wc_ecc_export_ex
 12961 0036 EF 15                   		mov.L	r1, r5
9800:../src/wolfcrypt/src/ecc.c ****         WC_TYPE_UNSIGNED_BIN);
9801:../src/wolfcrypt/src/ecc.c **** }
 12962                             		.loc 2 9801 1
 12963 0038 EF 51                   		mov.L	r5, r1
 12964 003a 3F AA 0C                		rtsd	#48, r10-r10
 12965                             	.LFE127:
 12967                             		.section	.text.wc_ecc_import_private_key_ex,"ax",@progbits
 12968                             		.global	_wc_ecc_import_private_key_ex
 12970                             	_wc_ecc_import_private_key_ex:
 12971                             	.LFB128:
9802:../src/wolfcrypt/src/ecc.c **** 
9803:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_KEY_EXPORT */
9804:../src/wolfcrypt/src/ecc.c **** 
9805:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_KEY_IMPORT
9806:../src/wolfcrypt/src/ecc.c **** /* import private key, public part optional if (pub) passed as NULL */
9807:../src/wolfcrypt/src/ecc.c **** int wc_ecc_import_private_key_ex(const byte* priv, word32 privSz,
9808:../src/wolfcrypt/src/ecc.c ****                                  const byte* pub, word32 pubSz, ecc_key* key,
9809:../src/wolfcrypt/src/ecc.c ****                                  int curve_id)
9810:../src/wolfcrypt/src/ecc.c **** {
 12972                             		.loc 2 9810 1
 12973 0000 7E AA                   		push.l	r10
 12974                             	.LCFI222:
 12975 0002 7E A6                   		push.l	r6
 12976                             	.LCFI223:
 12977 0004 71 0A E0                		add	#-32, r0, r10
 12978                             	.LCFI224:
 12979 0007 EF A0                   		mov.L	r10, r0
 12980 0009 75 46 2C                		mov.L	#44, r6
 12981 000c 4B A6                   		add	r10, r6
 12982 000e E7 A1 02                		mov.L	r1, 8[r10]
 12983 0011 E7 A2 03                		mov.L	r2, 12[r10]
 12984 0014 E7 A3 04                		mov.L	r3, 16[r10]
 12985 0017 E7 A4 05                		mov.L	r4, 20[r10]
9811:../src/wolfcrypt/src/ecc.c ****     int ret;
9812:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CRYPTOCELL
9813:../src/wolfcrypt/src/ecc.c ****     const CRYS_ECPKI_Domain_t* pDomain;
9814:../src/wolfcrypt/src/ecc.c **** #endif
9815:../src/wolfcrypt/src/ecc.c ****     if (key == NULL || priv == NULL)
 12986                             		.loc 2 9815 8
 12987 001a EC 65                   		mov.L	[r6], r5
 12988 001c 61 05                   		cmp	#0, r5
 12989 001e 17                      		beq	.L897
 12990                             		.loc 2 9815 21 discriminator 1
 12991 001f ED A5 02                		mov.L	8[r10], r5
 12992 0022 61 05                   		cmp	#0, r5
 12993 0024 1F                      		bne	.L898
 12994                             	.L897:
9816:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 12995                             		.loc 2 9816 16
 12996 0025 FB 5A 53 FF             		mov.L	#-173, r5
 12997 0029 2E 76                   		bra	.L899
 12998                             	.L898:
9817:../src/wolfcrypt/src/ecc.c **** 
9818:../src/wolfcrypt/src/ecc.c ****     /* public optional, NULL if only importing private */
9819:../src/wolfcrypt/src/ecc.c ****     if (pub != NULL) {
 12999                             		.loc 2 9819 8
 13000 002b ED A5 04                		mov.L	16[r10], r5
 13001 002e 61 05                   		cmp	#0, r5
 13002 0030 20 36                   		beq	.L900
 13003                             	.LBB91:
9820:../src/wolfcrypt/src/ecc.c ****     #ifndef NO_ASN
9821:../src/wolfcrypt/src/ecc.c ****         word32 idx = 0;
 13004                             		.loc 2 9821 16
 13005 0032 F9 A6 01 00             		mov.L	#0, 4[r10]
9822:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_import_x963_ex(pub, pubSz, key, curve_id);
 13006                             		.loc 2 9822 15
 13007 0036 A8 6C                   		mov.L	4[r6], r4
 13008 0038 EC 63                   		mov.L	[r6], r3
 13009 003a ED A2 05                		mov.L	20[r10], r2
 13010 003d ED A1 04                		mov.L	16[r10], r1
 13011 0040 05 00 00 00             		bsr	_wc_ecc_import_x963_ex
 13012 0044 E3 A1                   		mov.L	r1, [r10]
9823:../src/wolfcrypt/src/ecc.c ****         if (ret < 0)
 13013                             		.loc 2 9823 12
 13014 0046 EC A5                   		mov.L	[r10], r5
 13015 0048 61 05                   		cmp	#0, r5
 13016 004a 28 15                   		bge	.L901
9824:../src/wolfcrypt/src/ecc.c ****             ret = wc_EccPublicKeyDecode(pub, &idx, key, pubSz);
 13017                             		.loc 2 9824 19
 13018 004c 71 A5 04                		add	#4, r10, r5
 13019 004f ED A4 05                		mov.L	20[r10], r4
 13020 0052 EC 63                   		mov.L	[r6], r3
 13021 0054 EF 52                   		mov.L	r5, r2
 13022 0056 ED A1 04                		mov.L	16[r10], r1
 13023 0059 05 00 00 00             		bsr	_wc_EccPublicKeyDecode
 13024 005d E3 A1                   		mov.L	r1, [r10]
 13025                             	.L901:
9825:../src/wolfcrypt/src/ecc.c ****         key->type = ECC_PRIVATEKEY;
 13026                             		.loc 2 9825 19
 13027 005f EC 65                   		mov.L	[r6], r5
 13028 0061 F8 56 02                		mov.L	#2, [r5]
 13029                             	.LBE91:
 13030 0064 2E 1C                   		bra	.L902
 13031                             	.L900:
9826:../src/wolfcrypt/src/ecc.c ****     #else
9827:../src/wolfcrypt/src/ecc.c ****         (void)pubSz;
9828:../src/wolfcrypt/src/ecc.c ****         ret = NOT_COMPILED_IN;
9829:../src/wolfcrypt/src/ecc.c ****     #endif
9830:../src/wolfcrypt/src/ecc.c ****     }
9831:../src/wolfcrypt/src/ecc.c ****     else {
9832:../src/wolfcrypt/src/ecc.c ****         /* make sure required variables are reset */
9833:../src/wolfcrypt/src/ecc.c ****         wc_ecc_reset(key);
 13032                             		.loc 2 9833 9
 13033 0066 EC 61                   		mov.L	[r6], r1
 13034 0068 05 00 00 00             		bsr	_wc_ecc_reset
9834:../src/wolfcrypt/src/ecc.c **** 
9835:../src/wolfcrypt/src/ecc.c ****         /* set key size */
9836:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_set_curve(key, privSz, curve_id);
 13035                             		.loc 2 9836 15
 13036 006c ED A5 03                		mov.L	12[r10], r5
 13037 006f A8 6B                   		mov.L	4[r6], r3
 13038 0071 EF 52                   		mov.L	r5, r2
 13039 0073 EC 61                   		mov.L	[r6], r1
 13040 0075 05 00 00 00             		bsr	_wc_ecc_set_curve
 13041 0079 E3 A1                   		mov.L	r1, [r10]
9837:../src/wolfcrypt/src/ecc.c ****         key->type = ECC_PRIVATEKEY_ONLY;
 13042                             		.loc 2 9837 19
 13043 007b EC 65                   		mov.L	[r6], r5
 13044 007d F8 56 03                		mov.L	#3, [r5]
 13045                             	.L902:
9838:../src/wolfcrypt/src/ecc.c ****     }
9839:../src/wolfcrypt/src/ecc.c **** 
9840:../src/wolfcrypt/src/ecc.c ****     if (ret != 0)
 13046                             		.loc 2 9840 8
 13047 0080 EC A5                   		mov.L	[r10], r5
 13048 0082 61 05                   		cmp	#0, r5
 13049 0084 15                      		beq	.L903
9841:../src/wolfcrypt/src/ecc.c ****         return ret;
 13050                             		.loc 2 9841 16
 13051 0085 EC A5                   		mov.L	[r10], r5
 13052 0087 2E 18                   		bra	.L899
 13053                             	.L903:
9842:../src/wolfcrypt/src/ecc.c **** 
9843:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CRYPTOCELL
9844:../src/wolfcrypt/src/ecc.c ****     pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(key->dp->id));
9845:../src/wolfcrypt/src/ecc.c ****     /* import private key - priv checked for NULL at top */
9846:../src/wolfcrypt/src/ecc.c ****     if (priv[0] != '\0') {
9847:../src/wolfcrypt/src/ecc.c **** 
9848:../src/wolfcrypt/src/ecc.c ****         /* Create private key from external key buffer*/
9849:../src/wolfcrypt/src/ecc.c ****         ret = CRYS_ECPKI_BuildPrivKey(pDomain,
9850:../src/wolfcrypt/src/ecc.c ****                                       priv,
9851:../src/wolfcrypt/src/ecc.c ****                                       privSz,
9852:../src/wolfcrypt/src/ecc.c ****                                       &key->ctx.privKey);
9853:../src/wolfcrypt/src/ecc.c **** 
9854:../src/wolfcrypt/src/ecc.c ****         if (ret != SA_SILIB_RET_OK) {
9855:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("CRYS_ECPKI_BuildPrivKey failed");
9856:../src/wolfcrypt/src/ecc.c ****             return ret;
9857:../src/wolfcrypt/src/ecc.c ****         }
9858:../src/wolfcrypt/src/ecc.c **** 
9859:../src/wolfcrypt/src/ecc.c ****         ret = mp_read_unsigned_bin(&key->k, priv, privSz);
9860:../src/wolfcrypt/src/ecc.c ****     }
9861:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
9862:../src/wolfcrypt/src/ecc.c ****     if (ret == MP_OKAY)
9863:../src/wolfcrypt/src/ecc.c ****         ret = mp_read_unsigned_bin(&key->k, priv, privSz);
9864:../src/wolfcrypt/src/ecc.c **** 
9865:../src/wolfcrypt/src/ecc.c ****     if (ret == MP_OKAY) {
9866:../src/wolfcrypt/src/ecc.c ****         if (pub) {
9867:../src/wolfcrypt/src/ecc.c ****             ret = silabs_ecc_import(key, key->dp->size);
9868:../src/wolfcrypt/src/ecc.c ****         }
9869:../src/wolfcrypt/src/ecc.c ****         else {
9870:../src/wolfcrypt/src/ecc.c ****             ret = silabs_ecc_import_private(key, key->dp->size);
9871:../src/wolfcrypt/src/ecc.c ****         }
9872:../src/wolfcrypt/src/ecc.c ****     }
9873:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_QNX_CAAM)
9874:../src/wolfcrypt/src/ecc.c ****     if ((wc_ecc_size(key) + WC_CAAM_MAC_SZ) == (int)privSz) {
9875:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_CAAM_BLACK_KEY_SM
9876:../src/wolfcrypt/src/ecc.c ****         int part = caamFindUnusedPartition();
9877:../src/wolfcrypt/src/ecc.c ****         if (part >= 0) {
9878:../src/wolfcrypt/src/ecc.c ****             CAAM_ADDRESS vaddr = caamGetPartition(part, privSz*3);
9879:../src/wolfcrypt/src/ecc.c ****             if (vaddr == 0) {
9880:../src/wolfcrypt/src/ecc.c ****                 WOLFSSL_MSG("Unable to get partition");
9881:../src/wolfcrypt/src/ecc.c ****                 return MEMORY_E;
9882:../src/wolfcrypt/src/ecc.c ****             }
9883:../src/wolfcrypt/src/ecc.c **** 
9884:../src/wolfcrypt/src/ecc.c ****             key->partNum  = part;
9885:../src/wolfcrypt/src/ecc.c ****             key->blackKey = (word32)vaddr;
9886:../src/wolfcrypt/src/ecc.c ****             if (caamWriteToPartition(vaddr, priv, privSz) != 0)
9887:../src/wolfcrypt/src/ecc.c ****                 return WC_HW_E;
9888:../src/wolfcrypt/src/ecc.c **** 
9889:../src/wolfcrypt/src/ecc.c ****             if (pub != NULL) {
9890:../src/wolfcrypt/src/ecc.c ****                 /* +1 to account for x963 compressed bit */
9891:../src/wolfcrypt/src/ecc.c ****                 if (caamWriteToPartition(vaddr + privSz, pub + 1, pubSz - 1) != 0)
9892:../src/wolfcrypt/src/ecc.c ****                     return WC_HW_E;
9893:../src/wolfcrypt/src/ecc.c ****                 key->securePubKey = (word32)vaddr + privSz;
9894:../src/wolfcrypt/src/ecc.c ****             }
9895:../src/wolfcrypt/src/ecc.c ****         }
9896:../src/wolfcrypt/src/ecc.c ****         else {
9897:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("Unable to find an unused partition");
9898:../src/wolfcrypt/src/ecc.c ****             return MEMORY_E;
9899:../src/wolfcrypt/src/ecc.c ****         }
9900:../src/wolfcrypt/src/ecc.c ****     #else
9901:../src/wolfcrypt/src/ecc.c ****         key->blackKey = CAAM_BLACK_KEY_CCM;
9902:../src/wolfcrypt/src/ecc.c ****         ret = mp_read_unsigned_bin(&key->k, priv, privSz);
9903:../src/wolfcrypt/src/ecc.c ****     #endif
9904:../src/wolfcrypt/src/ecc.c ****     }
9905:../src/wolfcrypt/src/ecc.c ****     else {
9906:../src/wolfcrypt/src/ecc.c ****         key->blackKey = 0;
9907:../src/wolfcrypt/src/ecc.c ****         ret = mp_read_unsigned_bin(&key->k, priv, privSz);
9908:../src/wolfcrypt/src/ecc.c **** 
9909:../src/wolfcrypt/src/ecc.c ****         /* If using AES-ECB encrypted black keys check here if key is valid,
9910:../src/wolfcrypt/src/ecc.c ****          * if not valid than assume is an encrypted key. A public key is needed
9911:../src/wolfcrypt/src/ecc.c ****          * for testing validity. */
9912:../src/wolfcrypt/src/ecc.c ****         if (key->devId == WOLFSSL_CAAM_DEVID && (
9913:../src/wolfcrypt/src/ecc.c ****             wc_ecc_get_curve_id(key->idx) == ECC_SECP256R1 ||
9914:../src/wolfcrypt/src/ecc.c ****             wc_ecc_get_curve_id(key->idx) == ECC_SECP384R1)) {
9915:../src/wolfcrypt/src/ecc.c ****             if ((pub != NULL) && (ret == MP_OKAY) &&
9916:../src/wolfcrypt/src/ecc.c ****                 (_ecc_validate_public_key(key, 1, 1) != MP_OKAY)) {
9917:../src/wolfcrypt/src/ecc.c ****                 key->blackKey = CAAM_BLACK_KEY_ECB;
9918:../src/wolfcrypt/src/ecc.c ****             }
9919:../src/wolfcrypt/src/ecc.c ****             else if ((pub == NULL) && (ret == MP_OKAY)) {
9920:../src/wolfcrypt/src/ecc.c ****                 WOLFSSL_MSG("Assuming encrypted key with no public key to check");
9921:../src/wolfcrypt/src/ecc.c ****                 key->blackKey = CAAM_BLACK_KEY_ECB;
9922:../src/wolfcrypt/src/ecc.c ****             }
9923:../src/wolfcrypt/src/ecc.c ****             else {
9924:../src/wolfcrypt/src/ecc.c ****                 WOLFSSL_MSG("Importing key that is not a black key!");
9925:../src/wolfcrypt/src/ecc.c ****             }
9926:../src/wolfcrypt/src/ecc.c ****         }
9927:../src/wolfcrypt/src/ecc.c ****     }
9928:../src/wolfcrypt/src/ecc.c **** #else
9929:../src/wolfcrypt/src/ecc.c **** 
9930:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_VALIDATE_ECC_IMPORT
9931:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
9932:../src/wolfcrypt/src/ecc.c **** #endif
9933:../src/wolfcrypt/src/ecc.c **** 
9934:../src/wolfcrypt/src/ecc.c ****     ret = mp_read_unsigned_bin(&key->k, priv, privSz);
 13054                             		.loc 2 9934 32
 13055 0089 EC 65                   		mov.L	[r6], r5
 13056 008b 72 55 48 09             		add	#0x948, r5
 13057                             		.loc 2 9934 11
 13058 008f ED A3 03                		mov.L	12[r10], r3
 13059 0092 ED A2 02                		mov.L	8[r10], r2
 13060 0095 EF 51                   		mov.L	r5, r1
 13061 0097 05 00 00 00             		bsr	_sp_read_unsigned_bin
 13062 009b E3 A1                   		mov.L	r1, [r10]
9935:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_WOLF_BIGINT
9936:../src/wolfcrypt/src/ecc.c ****     if (ret == 0 &&
9937:../src/wolfcrypt/src/ecc.c ****                   wc_bigint_from_unsigned_bin(&key->k.raw, priv, privSz) != 0) {
9938:../src/wolfcrypt/src/ecc.c ****         mp_clear(&key->k);
9939:../src/wolfcrypt/src/ecc.c ****         ret = ASN_GETINT_E;
9940:../src/wolfcrypt/src/ecc.c ****     }
9941:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_WOLF_BIGINT */
9942:../src/wolfcrypt/src/ecc.c **** 
9943:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_CRYPTOCELL */
9944:../src/wolfcrypt/src/ecc.c **** 
9945:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_VALIDATE_ECC_IMPORT) && !defined(WOLFSSL_KCAPI_ECC)
9946:../src/wolfcrypt/src/ecc.c ****     if ((pub != NULL) && (ret == MP_OKAY))
9947:../src/wolfcrypt/src/ecc.c ****         /* public key needed to perform key validation */
9948:../src/wolfcrypt/src/ecc.c ****         ret = _ecc_validate_public_key(key, 1, 1);
9949:../src/wolfcrypt/src/ecc.c **** 
9950:../src/wolfcrypt/src/ecc.c **** #endif
9951:../src/wolfcrypt/src/ecc.c **** 
9952:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_VALIDATE_ECC_IMPORT
9953:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
9954:../src/wolfcrypt/src/ecc.c **** #endif
9955:../src/wolfcrypt/src/ecc.c **** 
9956:../src/wolfcrypt/src/ecc.c ****     return ret;
 13063                             		.loc 2 9956 12
 13064 009d EC A5                   		mov.L	[r10], r5
 13065                             	.L899:
9957:../src/wolfcrypt/src/ecc.c **** }
 13066                             		.loc 2 9957 1
 13067 009f EF 51                   		mov.L	r5, r1
 13068 00a1 71 00 20                		add	#32, r0
 13069 00a4 7E B6                   		pop	r6
 13070 00a6 7E BA                   		pop	r10
 13071 00a8 02                      		rts
 13072                             	.LFE128:
 13074                             		.section	.text.wc_ecc_import_private_key,"ax",@progbits
 13075                             		.global	_wc_ecc_import_private_key
 13077                             	_wc_ecc_import_private_key:
 13078                             	.LFB129:
9958:../src/wolfcrypt/src/ecc.c **** 
9959:../src/wolfcrypt/src/ecc.c **** /* ecc private key import, public key in ANSI X9.63 format, private raw */
9960:../src/wolfcrypt/src/ecc.c **** int wc_ecc_import_private_key(const byte* priv, word32 privSz, const byte* pub,
9961:../src/wolfcrypt/src/ecc.c ****                            word32 pubSz, ecc_key* key)
9962:../src/wolfcrypt/src/ecc.c **** {
 13079                             		.loc 2 9962 1
 13080 0000 7E AA                   		push.l	r10
 13081                             	.LCFI225:
 13082 0002 71 0A EC                		add	#-20, r0, r10
 13083                             	.LCFI226:
 13084 0005 71 A0 F8                		add	#-8, r10, r0
 13085                             	.LCFI227:
 13086 0008 75 45 1C                		mov.L	#28, r5
 13087 000b 4B A5                   		add	r10, r5
 13088 000d E3 A1                   		mov.L	r1, [r10]
 13089 000f E7 A2 01                		mov.L	r2, 4[r10]
 13090 0012 E7 A3 02                		mov.L	r3, 8[r10]
 13091 0015 E7 A4 03                		mov.L	r4, 12[r10]
9963:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_import_private_key_ex(priv, privSz, pub, pubSz, key,
 13092                             		.loc 2 9963 12
 13093 0018 3E 01 00                		mov.L	#0, 4[r0]
 13094 001b EC 55                   		mov.L	[r5], r5
 13095 001d E3 05                   		mov.L	r5, [r0]
 13096 001f ED A4 03                		mov.L	12[r10], r4
 13097 0022 ED A3 02                		mov.L	8[r10], r3
 13098 0025 ED A2 01                		mov.L	4[r10], r2
 13099 0028 EC A1                   		mov.L	[r10], r1
 13100 002a 05 00 00 00             		bsr	_wc_ecc_import_private_key_ex
 13101 002e EF 15                   		mov.L	r1, r5
9964:../src/wolfcrypt/src/ecc.c ****                                                                 ECC_CURVE_DEF);
9965:../src/wolfcrypt/src/ecc.c **** }
 13102                             		.loc 2 9965 1
 13103 0030 EF 51                   		mov.L	r5, r1
 13104 0032 3F AA 08                		rtsd	#32, r10-r10
 13105                             	.LFE129:
 13107                             		.section	.text.wc_ecc_rs_to_sig,"ax",@progbits
 13108                             		.global	_wc_ecc_rs_to_sig
 13110                             	_wc_ecc_rs_to_sig:
 13111                             	.LFB130:
9966:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_KEY_IMPORT */
9967:../src/wolfcrypt/src/ecc.c **** 
9968:../src/wolfcrypt/src/ecc.c **** #ifndef NO_ASN
9969:../src/wolfcrypt/src/ecc.c **** /**
9970:../src/wolfcrypt/src/ecc.c ****    Convert ECC R,S to signature
9971:../src/wolfcrypt/src/ecc.c ****    r       R component of signature
9972:../src/wolfcrypt/src/ecc.c ****    s       S component of signature
9973:../src/wolfcrypt/src/ecc.c ****    out     DER-encoded ECDSA signature
9974:../src/wolfcrypt/src/ecc.c ****    outlen  [in/out] output buffer size, output signature size
9975:../src/wolfcrypt/src/ecc.c ****    return  MP_OKAY on success
9976:../src/wolfcrypt/src/ecc.c **** */
9977:../src/wolfcrypt/src/ecc.c **** int wc_ecc_rs_to_sig(const char* r, const char* s, byte* out, word32* outlen)
9978:../src/wolfcrypt/src/ecc.c **** {
 13112                             		.loc 2 9978 1
 13113 0000 7E AA                   		push.l	r10
 13114                             	.LCFI228:
 13115 0002 71 0A D0                		add	#-48, r0, r10
 13116                             	.LCFI229:
 13117 0005 71 A0 F8                		add	#-8, r10, r0
 13118                             	.LCFI230:
 13119 0008 E7 A1 08                		mov.L	r1, 32[r10]
 13120 000b E7 A2 09                		mov.L	r2, 36[r10]
 13121 000e E7 A3 0A                		mov.L	r3, 40[r10]
 13122 0011 E7 A4 0B                		mov.L	r4, 44[r10]
9979:../src/wolfcrypt/src/ecc.c ****     int err;
9980:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
9981:../src/wolfcrypt/src/ecc.c ****     mp_int* rtmp = NULL;
 13123                             		.loc 2 9981 13
 13124 0014 F9 A6 01 00             		mov.L	#0, 4[r10]
9982:../src/wolfcrypt/src/ecc.c ****     mp_int* stmp = NULL;
 13125                             		.loc 2 9982 13
 13126 0018 F9 A6 02 00             		mov.L	#0, 8[r10]
9983:../src/wolfcrypt/src/ecc.c **** #else
9984:../src/wolfcrypt/src/ecc.c ****     mp_int  rtmp[1];
9985:../src/wolfcrypt/src/ecc.c ****     mp_int  stmp[1];
9986:../src/wolfcrypt/src/ecc.c **** #endif
9987:../src/wolfcrypt/src/ecc.c **** 
9988:../src/wolfcrypt/src/ecc.c ****     if (r == NULL || s == NULL || out == NULL || outlen == NULL)
 13127                             		.loc 2 9988 8
 13128 001c ED A5 08                		mov.L	32[r10], r5
 13129 001f 61 05                   		cmp	#0, r5
 13130 0021 20 17                   		beq	.L907
 13131                             		.loc 2 9988 19 discriminator 1
 13132 0023 ED A5 09                		mov.L	36[r10], r5
 13133 0026 61 05                   		cmp	#0, r5
 13134 0028 20 10                   		beq	.L907
 13135                             		.loc 2 9988 32 discriminator 2
 13136 002a ED A5 0A                		mov.L	40[r10], r5
 13137 002d 61 05                   		cmp	#0, r5
 13138 002f 11                      		beq	.L907
 13139                             		.loc 2 9988 47 discriminator 3
 13140 0030 ED A5 0B                		mov.L	44[r10], r5
 13141 0033 61 05                   		cmp	#0, r5
 13142 0035 1A                      		bne	.L908
 13143 0036 EF 00                   		.balign 8,3,2
 13144                             	.L907:
9989:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 13145                             		.loc 2 9989 16
 13146 0038 FB 5A 56 FF             		mov.L	#-170, r5
 13147 003c 38 17 01                		bra	.L909
 13148                             	.L908:
9990:../src/wolfcrypt/src/ecc.c **** 
9991:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
9992:../src/wolfcrypt/src/ecc.c ****     rtmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 13149                             		.loc 2 9992 21
 13150 003f FB 1A 10 03             		mov.L	#0x310, r1
 13151 0043 05 00 00 00             		bsr	_wolfSSL_Malloc
 13152 0047 E7 A1 01                		mov.L	r1, 4[r10]
9993:../src/wolfcrypt/src/ecc.c ****     if (rtmp == NULL)
 13153                             		.loc 2 9993 8
 13154 004a ED A5 01                		mov.L	4[r10], r5
 13155 004d 61 05                   		cmp	#0, r5
 13156 004f 1F                      		bne	.L910
9994:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 13157                             		.loc 2 9994 16
 13158 0050 FB 56 83                		mov.L	#-125, r5
 13159 0053 38 00 01                		bra	.L909
 13160                             	.L910:
9995:../src/wolfcrypt/src/ecc.c ****     stmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 13161                             		.loc 2 9995 21
 13162 0056 FB 1A 10 03             		mov.L	#0x310, r1
 13163 005a 05 00 00 00             		bsr	_wolfSSL_Malloc
 13164 005e E7 A1 02                		mov.L	r1, 8[r10]
9996:../src/wolfcrypt/src/ecc.c ****     if (stmp == NULL) {
 13165                             		.loc 2 9996 8
 13166 0061 ED A5 02                		mov.L	8[r10], r5
 13167 0064 61 05                   		cmp	#0, r5
 13168 0066 21 1B                   		bne	.L911
 13169                             	.LBB92:
9997:../src/wolfcrypt/src/ecc.c ****         XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);
 13170                             		.loc 2 9997 9
 13171 0068 ED A5 01                		mov.L	4[r10], r5
 13172 006b E7 A5 03                		mov.L	r5, 12[r10]
 13173 006e ED A5 03                		mov.L	12[r10], r5
 13174 0071 61 05                   		cmp	#0, r5
 13175 0073 10                      		beq	.L912
 13176                             		.loc 2 9997 9 is_stmt 0 discriminator 1
 13177 0074 ED A1 03                		mov.L	12[r10], r1
 13178 0077 05 00 00 00             		bsr	_wolfSSL_Free
 13179                             	.L912:
 13180                             	.LBE92:
9998:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 13181                             		.loc 2 9998 16 is_stmt 1
 13182 007b FB 56 83                		mov.L	#-125, r5
 13183 007e 38 D5 00                		bra	.L909
 13184                             	.L911:
9999:../src/wolfcrypt/src/ecc.c ****     }
10000:../src/wolfcrypt/src/ecc.c **** #endif
10001:../src/wolfcrypt/src/ecc.c **** 
10002:../src/wolfcrypt/src/ecc.c ****     err = mp_init_multi(rtmp, stmp, NULL, NULL, NULL, NULL);
 13185                             		.loc 2 10002 11
 13186 0081 3E 01 00                		mov.L	#0, 4[r0]
 13187 0084 F8 06 00                		mov.L	#0, [r0]
 13188 0087 66 04                   		mov.L	#0, r4
 13189 0089 66 03                   		mov.L	#0, r3
 13190 008b ED A2 02                		mov.L	8[r10], r2
 13191 008e ED A1 01                		mov.L	4[r10], r1
 13192 0091 05 00 00 00             		bsr	_sp_init_multi
 13193 0095 E3 A1                   		mov.L	r1, [r10]
10003:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY) {
 13194                             		.loc 2 10003 8
 13195 0097 EC A5                   		mov.L	[r10], r5
 13196 0099 61 05                   		cmp	#0, r5
 13197 009b 20 2D                   		beq	.L913
 13198                             	.LBB93:
10004:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_SMALL_STACK
10005:../src/wolfcrypt/src/ecc.c ****         XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);
 13199                             		.loc 2 10005 9
 13200 009d ED A5 02                		mov.L	8[r10], r5
 13201 00a0 E7 A5 04                		mov.L	r5, 16[r10]
 13202 00a3 ED A5 04                		mov.L	16[r10], r5
 13203 00a6 61 05                   		cmp	#0, r5
 13204 00a8 10                      		beq	.L914
 13205                             		.loc 2 10005 9 is_stmt 0 discriminator 1
 13206 00a9 ED A1 04                		mov.L	16[r10], r1
 13207 00ac 05 00 00 00             		bsr	_wolfSSL_Free
 13208                             	.L914:
 13209                             	.LBE93:
 13210                             	.LBB94:
10006:../src/wolfcrypt/src/ecc.c ****         XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);
 13211                             		.loc 2 10006 9 is_stmt 1
 13212 00b0 ED A5 01                		mov.L	4[r10], r5
 13213 00b3 E7 A5 05                		mov.L	r5, 20[r10]
 13214 00b6 ED A5 05                		mov.L	20[r10], r5
 13215 00b9 61 05                   		cmp	#0, r5
 13216 00bb 10                      		beq	.L915
 13217                             		.loc 2 10006 9 is_stmt 0 discriminator 1
 13218 00bc ED A1 05                		mov.L	20[r10], r1
 13219 00bf 05 00 00 00             		bsr	_wolfSSL_Free
 13220                             	.L915:
 13221                             	.LBE94:
10007:../src/wolfcrypt/src/ecc.c ****     #endif
10008:../src/wolfcrypt/src/ecc.c ****         return err;
 13222                             		.loc 2 10008 16 is_stmt 1
 13223 00c3 EC A5                   		mov.L	[r10], r5
 13224 00c5 38 8E 00                		bra	.L909
 13225                             	.L913:
10009:../src/wolfcrypt/src/ecc.c ****     }
10010:../src/wolfcrypt/src/ecc.c **** 
10011:../src/wolfcrypt/src/ecc.c ****     err = mp_read_radix(rtmp, r, MP_RADIX_HEX);
 13226                             		.loc 2 10011 11
 13227 00c8 75 43 10                		mov.L	#16, r3
 13228 00cb ED A2 08                		mov.L	32[r10], r2
 13229 00ce ED A1 01                		mov.L	4[r10], r1
 13230 00d1 05 00 00 00             		bsr	_sp_read_radix
 13231 00d5 E3 A1                   		mov.L	r1, [r10]
10012:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 13232                             		.loc 2 10012 8
 13233 00d7 EC A5                   		mov.L	[r10], r5
 13234 00d9 61 05                   		cmp	#0, r5
 13235 00db 21 11                   		bne	.L916
10013:../src/wolfcrypt/src/ecc.c ****         err = mp_read_radix(stmp, s, MP_RADIX_HEX);
 13236                             		.loc 2 10013 15
 13237 00dd 75 43 10                		mov.L	#16, r3
 13238 00e0 ED A2 09                		mov.L	36[r10], r2
 13239 00e3 ED A1 02                		mov.L	8[r10], r1
 13240 00e6 05 00 00 00             		bsr	_sp_read_radix
 13241 00ea E3 A1                   		mov.L	r1, [r10]
 13242                             	.L916:
10014:../src/wolfcrypt/src/ecc.c **** 
10015:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 13243                             		.loc 2 10015 8
 13244 00ec EC A5                   		mov.L	[r10], r5
 13245 00ee 61 05                   		cmp	#0, r5
 13246 00f0 21 15                   		bne	.L922
10016:../src/wolfcrypt/src/ecc.c ****         if (mp_iszero(rtmp) == MP_YES || mp_iszero(stmp) == MP_YES)
 13247                             		.loc 2 10016 13
 13248 00f2 ED A5 01                		mov.L	4[r10], r5
 13249 00f5 EC 55                   		mov.L	[r5], r5
 13250                             		.loc 2 10016 12
 13251 00f7 61 05                   		cmp	#0, r5
 13252 00f9 11                      		beq	.L918
 13253                             		.loc 2 10016 42 discriminator 1
 13254 00fa ED A5 02                		mov.L	8[r10], r5
 13255 00fd EC 55                   		mov.L	[r5], r5
 13256                             		.loc 2 10016 39 discriminator 1
 13257 00ff 61 05                   		cmp	#0, r5
 13258 0101 1C                      		bne	.L922
 13259                             	.L918:
10017:../src/wolfcrypt/src/ecc.c ****             err = MP_ZERO_E;
 13260                             		.loc 2 10017 17
 13261 0102 F8 A6 87                		mov.L	#-121, [r10]
 13262                             	.L922:
10018:../src/wolfcrypt/src/ecc.c ****     }
10019:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
10020:../src/wolfcrypt/src/ecc.c ****         if (mp_isneg(rtmp) == MP_YES || mp_isneg(stmp) == MP_YES) {
10021:../src/wolfcrypt/src/ecc.c ****             err = MP_READ_E;
10022:../src/wolfcrypt/src/ecc.c ****         }
10023:../src/wolfcrypt/src/ecc.c ****     }
10024:../src/wolfcrypt/src/ecc.c **** 
10025:../src/wolfcrypt/src/ecc.c ****     /* convert mp_ints to ECDSA sig, initializes rtmp and stmp internally */
10026:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 13263                             		.loc 2 10026 8
 13264 0105 EC A5                   		mov.L	[r10], r5
 13265 0107 61 05                   		cmp	#0, r5
 13266 0109 21 14                   		bne	.L919
10027:../src/wolfcrypt/src/ecc.c ****         err = StoreECC_DSA_Sig(out, outlen, rtmp, stmp);
 13267                             		.loc 2 10027 15
 13268 010b ED A4 02                		mov.L	8[r10], r4
 13269 010e ED A3 01                		mov.L	4[r10], r3
 13270 0111 ED A2 0B                		mov.L	44[r10], r2
 13271 0114 ED A1 0A                		mov.L	40[r10], r1
 13272 0117 05 00 00 00             		bsr	_StoreECC_DSA_Sig
 13273 011b E3 A1                   		mov.L	r1, [r10]
 13274                             	.L919:
10028:../src/wolfcrypt/src/ecc.c **** 
10029:../src/wolfcrypt/src/ecc.c ****     mp_clear(rtmp);
 13275                             		.loc 2 10029 5
 13276 011d ED A1 01                		mov.L	4[r10], r1
 13277 0120 05 00 00 00             		bsr	_sp_clear
10030:../src/wolfcrypt/src/ecc.c ****     mp_clear(stmp);
 13278                             		.loc 2 10030 5
 13279 0124 ED A1 02                		mov.L	8[r10], r1
 13280 0127 05 00 00 00             		bsr	_sp_clear
 13281                             	.LBB95:
10031:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
10032:../src/wolfcrypt/src/ecc.c ****     XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);
 13282                             		.loc 2 10032 5
 13283 012b ED A5 02                		mov.L	8[r10], r5
 13284 012e E7 A5 06                		mov.L	r5, 24[r10]
 13285 0131 ED A5 06                		mov.L	24[r10], r5
 13286 0134 61 05                   		cmp	#0, r5
 13287 0136 10                      		beq	.L920
 13288                             		.loc 2 10032 5 is_stmt 0 discriminator 1
 13289 0137 ED A1 06                		mov.L	24[r10], r1
 13290 013a 05 00 00 00             		bsr	_wolfSSL_Free
 13291                             	.L920:
 13292                             	.LBE95:
 13293                             	.LBB96:
10033:../src/wolfcrypt/src/ecc.c ****     XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);
 13294                             		.loc 2 10033 5 is_stmt 1
 13295 013e ED A5 01                		mov.L	4[r10], r5
 13296 0141 E7 A5 07                		mov.L	r5, 28[r10]
 13297 0144 ED A5 07                		mov.L	28[r10], r5
 13298 0147 61 05                   		cmp	#0, r5
 13299 0149 10                      		beq	.L921
 13300                             		.loc 2 10033 5 is_stmt 0 discriminator 1
 13301 014a ED A1 07                		mov.L	28[r10], r1
 13302 014d 05 00 00 00             		bsr	_wolfSSL_Free
 13303                             	.L921:
 13304                             	.LBE96:
10034:../src/wolfcrypt/src/ecc.c **** #endif
10035:../src/wolfcrypt/src/ecc.c **** 
10036:../src/wolfcrypt/src/ecc.c ****     return err;
 13305                             		.loc 2 10036 12 is_stmt 1
 13306 0151 EC A5                   		mov.L	[r10], r5
 13307                             		.balign 8,3,1
 13308                             	.L909:
10037:../src/wolfcrypt/src/ecc.c **** }
 13309                             		.loc 2 10037 1
 13310 0153 EF 51                   		mov.L	r5, r1
 13311 0155 3F AA 0F                		rtsd	#60, r10-r10
 13312                             	.LFE130:
 13314                             		.section	.text.wc_ecc_rs_raw_to_sig,"ax",@progbits
 13315                             		.global	_wc_ecc_rs_raw_to_sig
 13317                             	_wc_ecc_rs_raw_to_sig:
 13318                             	.LFB131:
10038:../src/wolfcrypt/src/ecc.c **** 
10039:../src/wolfcrypt/src/ecc.c **** /**
10040:../src/wolfcrypt/src/ecc.c ****    Convert ECC R,S raw unsigned bin to signature
10041:../src/wolfcrypt/src/ecc.c ****    r       R component of signature
10042:../src/wolfcrypt/src/ecc.c ****    rSz     R size
10043:../src/wolfcrypt/src/ecc.c ****    s       S component of signature
10044:../src/wolfcrypt/src/ecc.c ****    sSz     S size
10045:../src/wolfcrypt/src/ecc.c ****    out     DER-encoded ECDSA signature
10046:../src/wolfcrypt/src/ecc.c ****    outlen  [in/out] output buffer size, output signature size
10047:../src/wolfcrypt/src/ecc.c ****    return  MP_OKAY on success
10048:../src/wolfcrypt/src/ecc.c **** */
10049:../src/wolfcrypt/src/ecc.c **** int wc_ecc_rs_raw_to_sig(const byte* r, word32 rSz, const byte* s, word32 sSz,
10050:../src/wolfcrypt/src/ecc.c ****     byte* out, word32* outlen)
10051:../src/wolfcrypt/src/ecc.c **** {
 13319                             		.loc 2 10051 1
 13320 0000 7E AA                   		push.l	r10
 13321                             	.LCFI231:
 13322 0002 71 0A E8                		add	#-24, r0, r10
 13323                             	.LCFI232:
 13324 0005 71 A0 F8                		add	#-8, r10, r0
 13325                             	.LCFI233:
 13326 0008 75 45 20                		mov.L	#32, r5
 13327 000b 4B A5                   		add	r10, r5
 13328 000d E3 A1                   		mov.L	r1, [r10]
 13329 000f E7 A2 01                		mov.L	r2, 4[r10]
 13330 0012 E7 A3 02                		mov.L	r3, 8[r10]
 13331 0015 E7 A4 03                		mov.L	r4, 12[r10]
10052:../src/wolfcrypt/src/ecc.c ****     if (r == NULL || s == NULL || out == NULL || outlen == NULL)
 13332                             		.loc 2 10052 8
 13333 0018 EC A4                   		mov.L	[r10], r4
 13334 001a 61 04                   		cmp	#0, r4
 13335 001c 20 14                   		beq	.L924
 13336                             		.loc 2 10052 19 discriminator 1
 13337 001e ED A4 02                		mov.L	8[r10], r4
 13338 0021 61 04                   		cmp	#0, r4
 13339 0023 20 0D                   		beq	.L924
 13340                             		.loc 2 10052 32 discriminator 2
 13341 0025 EC 54                   		mov.L	[r5], r4
 13342 0027 61 04                   		cmp	#0, r4
 13343 0029 17                      		beq	.L924
 13344                             		.loc 2 10052 47 discriminator 3
 13345 002a A8 5C                   		mov.L	4[r5], r4
 13346 002c 61 04                   		cmp	#0, r4
 13347 002e 18                      		bne	.L925
 13348 002f 03                      		.balign 8,3,2
 13349                             	.L924:
10053:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 13350                             		.loc 2 10053 16
 13351 0030 FB 5A 56 FF             		mov.L	#-170, r5
 13352 0034 2E 1B                   		bra	.L926
 13353                             	.L925:
10054:../src/wolfcrypt/src/ecc.c **** 
10055:../src/wolfcrypt/src/ecc.c ****     /* convert mp_ints to ECDSA sig, initializes rtmp and stmp internally */
10056:../src/wolfcrypt/src/ecc.c ****     return StoreECC_DSA_Sig_Bin(out, outlen, r, rSz, s, sSz);
 13354                             		.loc 2 10056 12
 13355 0036 ED A4 03                		mov.L	12[r10], r4
 13356 0039 A0 0C                   		mov.L	r4, 4[r0]
 13357 003b ED A4 02                		mov.L	8[r10], r4
 13358 003e E3 04                   		mov.L	r4, [r0]
 13359 0040 ED A4 01                		mov.L	4[r10], r4
 13360 0043 EC A3                   		mov.L	[r10], r3
 13361 0045 A8 5A                   		mov.L	4[r5], r2
 13362 0047 EC 51                   		mov.L	[r5], r1
 13363 0049 05 00 00 00             		bsr	_StoreECC_DSA_Sig_Bin
 13364 004d EF 15                   		mov.L	r1, r5
 13365                             	.L926:
10057:../src/wolfcrypt/src/ecc.c **** }
 13366                             		.loc 2 10057 1
 13367 004f EF 51                   		mov.L	r5, r1
 13368 0051 3F AA 09                		rtsd	#36, r10-r10
 13369                             	.LFE131:
 13371 0054 76 10 01 00             		.section	.text.wc_ecc_sig_to_rs,"ax",@progbits
 13372                             		.global	_wc_ecc_sig_to_rs
 13374                             	_wc_ecc_sig_to_rs:
 13375                             	.LFB132:
10058:../src/wolfcrypt/src/ecc.c **** 
10059:../src/wolfcrypt/src/ecc.c **** /**
10060:../src/wolfcrypt/src/ecc.c ****    Convert ECC signature to R,S
10061:../src/wolfcrypt/src/ecc.c ****    sig     DER-encoded ECDSA signature
10062:../src/wolfcrypt/src/ecc.c ****    sigLen  length of signature in octets
10063:../src/wolfcrypt/src/ecc.c ****    r       R component of signature
10064:../src/wolfcrypt/src/ecc.c ****    rLen    [in/out] output "r" buffer size, output "r" size
10065:../src/wolfcrypt/src/ecc.c ****    s       S component of signature
10066:../src/wolfcrypt/src/ecc.c ****    sLen    [in/out] output "s" buffer size, output "s" size
10067:../src/wolfcrypt/src/ecc.c ****    return  MP_OKAY on success, negative on error
10068:../src/wolfcrypt/src/ecc.c **** */
10069:../src/wolfcrypt/src/ecc.c **** int wc_ecc_sig_to_rs(const byte* sig, word32 sigLen, byte* r, word32* rLen,
10070:../src/wolfcrypt/src/ecc.c ****                      byte* s, word32* sLen)
10071:../src/wolfcrypt/src/ecc.c **** {
 13376                             		.loc 2 10071 1
 13377 0000 7E AA                   		push.l	r10
 13378                             	.LCFI234:
 13379 0002 71 0A E8                		add	#-24, r0, r10
 13380                             	.LCFI235:
 13381 0005 71 A0 F8                		add	#-8, r10, r0
 13382                             	.LCFI236:
 13383 0008 75 45 20                		mov.L	#32, r5
 13384 000b 4B A5                   		add	r10, r5
 13385 000d E3 A1                   		mov.L	r1, [r10]
 13386 000f E7 A2 01                		mov.L	r2, 4[r10]
 13387 0012 E7 A3 02                		mov.L	r3, 8[r10]
 13388 0015 E7 A4 03                		mov.L	r4, 12[r10]
10072:../src/wolfcrypt/src/ecc.c ****     if (sig == NULL || r == NULL || rLen == NULL || s == NULL || sLen == NULL)
 13389                             		.loc 2 10072 8
 13390 0018 EC A4                   		mov.L	[r10], r4
 13391 001a 61 04                   		cmp	#0, r4
 13392 001c 20 1C                   		beq	.L928
 13393                             		.loc 2 10072 21 discriminator 1
 13394 001e ED A4 02                		mov.L	8[r10], r4
 13395 0021 61 04                   		cmp	#0, r4
 13396 0023 20 15                   		beq	.L928
 13397                             		.loc 2 10072 34 discriminator 2
 13398 0025 ED A4 03                		mov.L	12[r10], r4
 13399 0028 61 04                   		cmp	#0, r4
 13400 002a 20 0E                   		beq	.L928
 13401                             		.loc 2 10072 50 discriminator 3
 13402 002c EC 54                   		mov.L	[r5], r4
 13403 002e 61 04                   		cmp	#0, r4
 13404 0030 10                      		beq	.L928
 13405                             		.loc 2 10072 63 discriminator 4
 13406 0031 A8 5C                   		mov.L	4[r5], r4
 13407 0033 61 04                   		cmp	#0, r4
 13408 0035 19                      		bne	.L929
 13409 0036 EF 00                   		.balign 8,3,2
 13410                             	.L928:
10073:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
 13411                             		.loc 2 10073 16
 13412 0038 FB 5A 56 FF             		mov.L	#-170, r5
 13413 003c 2E 1B                   		bra	.L930
 13414                             	.L929:
10074:../src/wolfcrypt/src/ecc.c **** 
10075:../src/wolfcrypt/src/ecc.c ****     return DecodeECC_DSA_Sig_Bin(sig, sigLen, r, rLen, s, sLen);
 13415                             		.loc 2 10075 12
 13416 003e A8 5C                   		mov.L	4[r5], r4
 13417 0040 A0 0C                   		mov.L	r4, 4[r0]
 13418 0042 EC 55                   		mov.L	[r5], r5
 13419 0044 E3 05                   		mov.L	r5, [r0]
 13420 0046 ED A4 03                		mov.L	12[r10], r4
 13421 0049 ED A3 02                		mov.L	8[r10], r3
 13422 004c ED A2 01                		mov.L	4[r10], r2
 13423 004f EC A1                   		mov.L	[r10], r1
 13424 0051 05 00 00 00             		bsr	_DecodeECC_DSA_Sig_Bin
 13425 0055 EF 15                   		mov.L	r1, r5
 13426                             	.L930:
10076:../src/wolfcrypt/src/ecc.c **** }
 13427                             		.loc 2 10076 1
 13428 0057 EF 51                   		mov.L	r5, r1
 13429 0059 3F AA 09                		rtsd	#36, r10-r10
 13430                             	.LFE132:
 13432 005c 76 10 01 00             		.section C,"a",@progbits
 13433                             		.p2align 2
 13434                             	.LC45:
 13435 0af4 49 6E 76 61 6C 69 64 20 		.string	"Invalid Qx and Qy"
 13435      51 78 20 61 6E 64 20 51 
 13435      79 00 
 13436                             	.LC46:
 13437 0b06 49 6E 76 61 6C 69 64 20 		.string	"Invalid private key"
 13437      70 72 69 76 61 74 65 20 
 13437      6B 65 79 00 
 13438 0b1a 00 00                   		.section	.text.wc_ecc_import_raw_private,"ax",@progbits
 13440                             	_wc_ecc_import_raw_private:
 13441                             	.LFB133:
10077:../src/wolfcrypt/src/ecc.c **** #endif /* !NO_ASN */
10078:../src/wolfcrypt/src/ecc.c **** 
10079:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_KEY_IMPORT
10080:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_import_raw_private(ecc_key* key, const char* qx,
10081:../src/wolfcrypt/src/ecc.c ****           const char* qy, const char* d, int curve_id, int encType)
10082:../src/wolfcrypt/src/ecc.c **** {
 13442                             		.loc 2 10082 1
 13443 0000 7E AA                   		push.l	r10
 13444                             	.LCFI237:
 13445 0002 7E A6                   		push.l	r6
 13446                             	.LCFI238:
 13447 0004 71 0A E4                		add	#-28, r0, r10
 13448                             	.LCFI239:
 13449 0007 71 A0 F8                		add	#-8, r10, r0
 13450                             	.LCFI240:
 13451 000a 75 46 28                		mov.L	#40, r6
 13452 000d 4B A6                   		add	r10, r6
 13453 000f E7 A1 01                		mov.L	r1, 4[r10]
 13454 0012 E7 A2 02                		mov.L	r2, 8[r10]
 13455 0015 E7 A3 03                		mov.L	r3, 12[r10]
 13456 0018 E7 A4 04                		mov.L	r4, 16[r10]
10083:../src/wolfcrypt/src/ecc.c ****     int err = MP_OKAY;
 13457                             		.loc 2 10083 9
 13458 001b F8 A6 00                		mov.L	#0, [r10]
10084:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_ATECC508A) && \
10085:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_ATECC608A)
10086:../src/wolfcrypt/src/ecc.c ****     const CRYS_ECPKI_Domain_t* pDomain;
10087:../src/wolfcrypt/src/ecc.c ****     CRYS_ECPKI_BUILD_TempData_t tempBuff;
10088:../src/wolfcrypt/src/ecc.c ****     byte key_raw[ECC_MAX_CRYPTO_HW_SIZE*2 + 1];
10089:../src/wolfcrypt/src/ecc.c **** #endif
10090:../src/wolfcrypt/src/ecc.c **** 
10091:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A) || \
10092:../src/wolfcrypt/src/ecc.c ****     defined(WOLFSSL_SILABS_SE_ACCEL) || defined(WOLFSSL_CRYPTOCELL)
10093:../src/wolfcrypt/src/ecc.c ****     word32 keySz = 0;
10094:../src/wolfcrypt/src/ecc.c **** #endif
10095:../src/wolfcrypt/src/ecc.c **** 
10096:../src/wolfcrypt/src/ecc.c ****     /* if d is NULL, only import as public key using Qx,Qy */
10097:../src/wolfcrypt/src/ecc.c ****     if (key == NULL || qx == NULL || qy == NULL) {
 13459                             		.loc 2 10097 8
 13460 001e ED A5 01                		mov.L	4[r10], r5
 13461 0021 61 05                   		cmp	#0, r5
 13462 0023 20 0E                   		beq	.L932
 13463                             		.loc 2 10097 21 discriminator 1
 13464 0025 ED A5 02                		mov.L	8[r10], r5
 13465 0028 61 05                   		cmp	#0, r5
 13466 002a 17                      		beq	.L932
 13467                             		.loc 2 10097 35 discriminator 2
 13468 002b ED A5 03                		mov.L	12[r10], r5
 13469 002e 61 05                   		cmp	#0, r5
 13470 0030 18                      		bne	.L933
 13471                             	.L932:
10098:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 13472                             		.loc 2 10098 16
 13473 0031 FB 5A 53 FF             		mov.L	#-173, r5
 13474 0035 38 F1 01                		bra	.L934
 13475                             	.L933:
10099:../src/wolfcrypt/src/ecc.c ****     }
10100:../src/wolfcrypt/src/ecc.c **** 
10101:../src/wolfcrypt/src/ecc.c ****     /* make sure required variables are reset */
10102:../src/wolfcrypt/src/ecc.c ****     wc_ecc_reset(key);
 13476                             		.loc 2 10102 5
 13477 0038 ED A1 01                		mov.L	4[r10], r1
 13478 003b 05 00 00 00             		bsr	_wc_ecc_reset
10103:../src/wolfcrypt/src/ecc.c **** 
10104:../src/wolfcrypt/src/ecc.c ****     /* set curve type and index */
10105:../src/wolfcrypt/src/ecc.c ****     err = wc_ecc_set_curve(key, 0, curve_id);
 13479                             		.loc 2 10105 11
 13480 003f EC 63                   		mov.L	[r6], r3
 13481 0041 66 02                   		mov.L	#0, r2
 13482 0043 ED A1 01                		mov.L	4[r10], r1
 13483 0046 05 00 00 00             		bsr	_wc_ecc_set_curve
 13484 004a E3 A1                   		mov.L	r1, [r10]
10106:../src/wolfcrypt/src/ecc.c ****     if (err != 0) {
 13485                             		.loc 2 10106 8
 13486 004c EC A5                   		mov.L	[r10], r5
 13487 004e 61 05                   		cmp	#0, r5
 13488 0050 16                      		beq	.L935
10107:../src/wolfcrypt/src/ecc.c ****         return err;
 13489                             		.loc 2 10107 16
 13490 0051 EC A5                   		mov.L	[r10], r5
 13491 0053 38 D3 01                		bra	.L934
 13492                             	.L935:
10108:../src/wolfcrypt/src/ecc.c ****     }
10109:../src/wolfcrypt/src/ecc.c **** 
10110:../src/wolfcrypt/src/ecc.c ****     /* init key */
10111:../src/wolfcrypt/src/ecc.c **** #ifdef ALT_ECC_SIZE
10112:../src/wolfcrypt/src/ecc.c ****     key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
10113:../src/wolfcrypt/src/ecc.c ****     key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
10114:../src/wolfcrypt/src/ecc.c ****     key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
10115:../src/wolfcrypt/src/ecc.c ****     alt_fp_init(key->pubkey.x);
10116:../src/wolfcrypt/src/ecc.c ****     alt_fp_init(key->pubkey.y);
10117:../src/wolfcrypt/src/ecc.c ****     alt_fp_init(key->pubkey.z);
10118:../src/wolfcrypt/src/ecc.c ****     err = mp_init(&key->k);
10119:../src/wolfcrypt/src/ecc.c **** #else
10120:../src/wolfcrypt/src/ecc.c ****     err = mp_init_multi(&key->k, key->pubkey.x, key->pubkey.y, key->pubkey.z,
 13493                             		.loc 2 10120 25
 13494 0056 ED A5 01                		mov.L	4[r10], r5
 13495 0059 72 51 48 09             		add	#0x948, r5, r1
 13496                             		.loc 2 10120 45
 13497 005d ED A5 01                		mov.L	4[r10], r5
 13498 0060 71 52 18                		add	#24, r5, r2
 13499                             		.loc 2 10120 60
 13500 0063 ED A5 01                		mov.L	4[r10], r5
 13501 0066 72 53 28 03             		add	#0x328, r5, r3
 13502                             		.loc 2 10120 75
 13503 006a ED A5 01                		mov.L	4[r10], r5
 13504 006d 72 55 38 06             		add	#0x638, r5
 13505                             		.loc 2 10120 11
 13506 0071 3E 01 00                		mov.L	#0, 4[r0]
 13507 0074 F8 06 00                		mov.L	#0, [r0]
 13508 0077 EF 54                   		mov.L	r5, r4
 13509 0079 05 00 00 00             		bsr	_sp_init_multi
 13510 007d E3 A1                   		mov.L	r1, [r10]
10121:../src/wolfcrypt/src/ecc.c ****                                                                   NULL, NULL);
10122:../src/wolfcrypt/src/ecc.c **** #endif
10123:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY)
 13511                             		.loc 2 10123 8
 13512 007f EC A5                   		mov.L	[r10], r5
 13513 0081 61 05                   		cmp	#0, r5
 13514 0083 17                      		beq	.L936
10124:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
 13515                             		.loc 2 10124 16
 13516 0084 FB 56 83                		mov.L	#-125, r5
 13517 0087 38 9F 01                		bra	.L934
 13518                             	.L936:
10125:../src/wolfcrypt/src/ecc.c **** 
10126:../src/wolfcrypt/src/ecc.c ****     /* read Qx */
10127:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 13519                             		.loc 2 10127 8
 13520 008a EC A5                   		mov.L	[r10], r5
 13521 008c 61 05                   		cmp	#0, r5
 13522 008e 21 56                   		bne	.L937
10128:../src/wolfcrypt/src/ecc.c ****         if (encType == WC_TYPE_HEX_STR)
 13523                             		.loc 2 10128 12
 13524 0090 A8 6D                   		mov.L	4[r6], r5
 13525 0092 61 15                   		cmp	#1, r5
 13526 0094 21 18                   		bne	.L938
10129:../src/wolfcrypt/src/ecc.c ****             err = mp_read_radix(key->pubkey.x, qx, MP_RADIX_HEX);
 13527                             		.loc 2 10129 44
 13528 0096 ED A5 01                		mov.L	4[r10], r5
 13529 0099 71 55 18                		add	#24, r5
 13530                             		.loc 2 10129 19
 13531 009c 75 43 10                		mov.L	#16, r3
 13532 009f ED A2 02                		mov.L	8[r10], r2
 13533 00a2 EF 51                   		mov.L	r5, r1
 13534 00a4 05 00 00 00             		bsr	_sp_read_radix
 13535 00a8 E3 A1                   		mov.L	r1, [r10]
 13536 00aa 2E 1C                   		bra	.L950
 13537                             	.L938:
10130:../src/wolfcrypt/src/ecc.c ****         else
10131:../src/wolfcrypt/src/ecc.c ****             err = mp_read_unsigned_bin(key->pubkey.x, (const byte*)qx,
 13538                             		.loc 2 10131 51
 13539 00ac ED A5 01                		mov.L	4[r10], r5
 13540 00af 71 54 18                		add	#24, r5, r4
10132:../src/wolfcrypt/src/ecc.c ****                 key->dp->size);
 13541                             		.loc 2 10132 20
 13542 00b2 ED A5 01                		mov.L	4[r10], r5
 13543 00b5 A9 55                   		mov.L	16[r5], r5
 13544                             		.loc 2 10132 24
 13545 00b7 EC 55                   		mov.L	[r5], r5
10131:../src/wolfcrypt/src/ecc.c ****                 key->dp->size);
 13546                             		.loc 2 10131 19
 13547 00b9 EF 53                   		mov.L	r5, r3
 13548 00bb ED A2 02                		mov.L	8[r10], r2
 13549 00be EF 41                   		mov.L	r4, r1
 13550 00c0 05 00 00 00             		bsr	_sp_read_unsigned_bin
 13551 00c4 E3 A1                   		mov.L	r1, [r10]
 13552                             	.L950:
10133:../src/wolfcrypt/src/ecc.c **** 
10134:../src/wolfcrypt/src/ecc.c ****         if (mp_isneg(key->pubkey.x)) {
10135:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("Invalid Qx");
10136:../src/wolfcrypt/src/ecc.c ****             err = BAD_FUNC_ARG;
10137:../src/wolfcrypt/src/ecc.c ****         }
10138:../src/wolfcrypt/src/ecc.c ****         if (mp_unsigned_bin_size(key->pubkey.y) > key->dp->size) {
 13553                             		.loc 2 10138 45
 13554 00c6 ED A5 01                		mov.L	4[r10], r5
 13555 00c9 72 55 28 03             		add	#0x328, r5
 13556                             		.loc 2 10138 13
 13557 00cd EF 51                   		mov.L	r5, r1
 13558 00cf 05 00 00 00             		bsr	_sp_unsigned_bin_size
 13559 00d3 EF 14                   		mov.L	r1, r4
 13560                             		.loc 2 10138 54
 13561 00d5 ED A5 01                		mov.L	4[r10], r5
 13562 00d8 A9 55                   		mov.L	16[r5], r5
 13563                             		.loc 2 10138 58
 13564 00da EC 55                   		mov.L	[r5], r5
 13565                             		.loc 2 10138 12
 13566 00dc 47 54                   		cmp	r5, r4
 13567 00de 2B 06                   		ble	.L937
10139:../src/wolfcrypt/src/ecc.c ****             err = BAD_FUNC_ARG;
 13568                             		.loc 2 10139 17
 13569 00e0 F8 AA 53 FF             		mov.L	#-173, [r10]
 13570                             	.L937:
10140:../src/wolfcrypt/src/ecc.c ****         }
10141:../src/wolfcrypt/src/ecc.c ****     }
10142:../src/wolfcrypt/src/ecc.c **** 
10143:../src/wolfcrypt/src/ecc.c ****     /* read Qy */
10144:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 13571                             		.loc 2 10144 8
 13572 00e4 EC A5                   		mov.L	[r10], r5
 13573 00e6 61 05                   		cmp	#0, r5
 13574 00e8 21 58                   		bne	.L940
10145:../src/wolfcrypt/src/ecc.c ****         if (encType == WC_TYPE_HEX_STR)
 13575                             		.loc 2 10145 12
 13576 00ea A8 6D                   		mov.L	4[r6], r5
 13577 00ec 61 15                   		cmp	#1, r5
 13578 00ee 21 19                   		bne	.L941
10146:../src/wolfcrypt/src/ecc.c ****             err = mp_read_radix(key->pubkey.y, qy, MP_RADIX_HEX);
 13579                             		.loc 2 10146 44
 13580 00f0 ED A5 01                		mov.L	4[r10], r5
 13581 00f3 72 55 28 03             		add	#0x328, r5
 13582                             		.loc 2 10146 19
 13583 00f7 75 43 10                		mov.L	#16, r3
 13584 00fa ED A2 03                		mov.L	12[r10], r2
 13585 00fd EF 51                   		mov.L	r5, r1
 13586 00ff 05 00 00 00             		bsr	_sp_read_radix
 13587 0103 E3 A1                   		mov.L	r1, [r10]
 13588 0105 2E 1D                   		bra	.L951
 13589                             	.L941:
10147:../src/wolfcrypt/src/ecc.c ****         else
10148:../src/wolfcrypt/src/ecc.c ****             err = mp_read_unsigned_bin(key->pubkey.y, (const byte*)qy,
 13590                             		.loc 2 10148 51
 13591 0107 ED A5 01                		mov.L	4[r10], r5
 13592 010a 72 54 28 03             		add	#0x328, r5, r4
10149:../src/wolfcrypt/src/ecc.c ****                 key->dp->size);
 13593                             		.loc 2 10149 20
 13594 010e ED A5 01                		mov.L	4[r10], r5
 13595 0111 A9 55                   		mov.L	16[r5], r5
 13596                             		.loc 2 10149 24
 13597 0113 EC 55                   		mov.L	[r5], r5
10148:../src/wolfcrypt/src/ecc.c ****                 key->dp->size);
 13598                             		.loc 2 10148 19
 13599 0115 EF 53                   		mov.L	r5, r3
 13600 0117 ED A2 03                		mov.L	12[r10], r2
 13601 011a EF 41                   		mov.L	r4, r1
 13602 011c 05 00 00 00             		bsr	_sp_read_unsigned_bin
 13603 0120 E3 A1                   		mov.L	r1, [r10]
 13604                             	.L951:
10150:../src/wolfcrypt/src/ecc.c **** 
10151:../src/wolfcrypt/src/ecc.c ****         if (mp_isneg(key->pubkey.y)) {
10152:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("Invalid Qy");
10153:../src/wolfcrypt/src/ecc.c ****             err = BAD_FUNC_ARG;
10154:../src/wolfcrypt/src/ecc.c ****         }
10155:../src/wolfcrypt/src/ecc.c ****         if (mp_unsigned_bin_size(key->pubkey.y) > key->dp->size) {
 13605                             		.loc 2 10155 45
 13606 0122 ED A5 01                		mov.L	4[r10], r5
 13607 0125 72 55 28 03             		add	#0x328, r5
 13608                             		.loc 2 10155 13
 13609 0129 EF 51                   		mov.L	r5, r1
 13610 012b 05 00 00 00             		bsr	_sp_unsigned_bin_size
 13611 012f EF 14                   		mov.L	r1, r4
 13612                             		.loc 2 10155 54
 13613 0131 ED A5 01                		mov.L	4[r10], r5
 13614 0134 A9 55                   		mov.L	16[r5], r5
 13615                             		.loc 2 10155 58
 13616 0136 EC 55                   		mov.L	[r5], r5
 13617                             		.loc 2 10155 12
 13618 0138 47 54                   		cmp	r5, r4
 13619 013a 2B 06                   		ble	.L940
10156:../src/wolfcrypt/src/ecc.c ****             err = BAD_FUNC_ARG;
 13620                             		.loc 2 10156 17
 13621 013c F8 AA 53 FF             		mov.L	#-173, [r10]
 13622                             	.L940:
10157:../src/wolfcrypt/src/ecc.c ****         }
10158:../src/wolfcrypt/src/ecc.c ****     }
10159:../src/wolfcrypt/src/ecc.c **** 
10160:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 13623                             		.loc 2 10160 8
 13624 0140 EC A5                   		mov.L	[r10], r5
 13625 0142 61 05                   		cmp	#0, r5
 13626 0144 21 24                   		bne	.L943
10161:../src/wolfcrypt/src/ecc.c ****         if (mp_iszero(key->pubkey.x) && mp_iszero(key->pubkey.y)) {
 13627                             		.loc 2 10161 13
 13628 0146 ED A5 01                		mov.L	4[r10], r5
 13629 0149 A9 D5                   		mov.L	24[r5], r5
 13630                             		.loc 2 10161 12
 13631 014b 61 05                   		cmp	#0, r5
 13632 014d 21 1B                   		bne	.L943
 13633                             		.loc 2 10161 41 discriminator 1
 13634 014f ED A5 01                		mov.L	4[r10], r5
 13635 0152 ED 55 CA                		mov.L	808[r5], r5
 13636                             		.loc 2 10161 38 discriminator 1
 13637 0155 61 05                   		cmp	#0, r5
 13638 0157 21 11                   		bne	.L943
10162:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("Invalid Qx and Qy");
 13639                             		.loc 2 10162 13
 13640 0159 FB 12 F4 0A 00 00       		mov.L	#.LC45, r1
 13641 015f 05 00 00 00             		bsr	_WOLFSSL_MSG
10163:../src/wolfcrypt/src/ecc.c ****             err = ECC_INF_E;
 13642                             		.loc 2 10163 17
 13643 0163 F8 AA 29 FF             		mov.L	#-215, [r10]
 13644 0167 03                      		.balign 8,3,1
 13645                             	.L943:
10164:../src/wolfcrypt/src/ecc.c ****         }
10165:../src/wolfcrypt/src/ecc.c ****     }
10166:../src/wolfcrypt/src/ecc.c **** 
10167:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY)
 13646                             		.loc 2 10167 8
 13647 0168 EC A5                   		mov.L	[r10], r5
 13648 016a 61 05                   		cmp	#0, r5
 13649 016c 21 13                   		bne	.L944
10168:../src/wolfcrypt/src/ecc.c ****         err = mp_set(key->pubkey.z, 1);
 13650                             		.loc 2 10168 33
 13651 016e ED A5 01                		mov.L	4[r10], r5
 13652 0171 72 55 38 06             		add	#0x638, r5
 13653                             		.loc 2 10168 15
 13654 0175 66 12                   		mov.L	#1, r2
 13655 0177 EF 51                   		mov.L	r5, r1
 13656 0179 05 00 00 00             		bsr	_sp_set
 13657 017d E3 A1                   		mov.L	r1, [r10]
 13658                             	.L944:
10169:../src/wolfcrypt/src/ecc.c **** 
10170:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
10171:../src/wolfcrypt/src/ecc.c ****     /* For SECP256R1 only save raw public key for hardware */
10172:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY && curve_id == ECC_SECP256R1) {
10173:../src/wolfcrypt/src/ecc.c ****         keySz = key->dp->size;
10174:../src/wolfcrypt/src/ecc.c ****         err = wc_export_int(key->pubkey.x, key->pubkey_raw,
10175:../src/wolfcrypt/src/ecc.c ****             &keySz, keySz, WC_TYPE_UNSIGNED_BIN);
10176:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY)
10177:../src/wolfcrypt/src/ecc.c ****             err = wc_export_int(key->pubkey.y, &key->pubkey_raw[keySz],
10178:../src/wolfcrypt/src/ecc.c ****                 &keySz, keySz, WC_TYPE_UNSIGNED_BIN);
10179:../src/wolfcrypt/src/ecc.c ****     }
10180:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_SILABS_SE_ACCEL)
10181:../src/wolfcrypt/src/ecc.c ****     keySz = key->dp->size;
10182:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
10183:../src/wolfcrypt/src/ecc.c ****         err = silabs_ecc_sig_to_rs(key, keySz);
10184:../src/wolfcrypt/src/ecc.c ****     }
10185:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CRYPTOCELL)
10186:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
10187:../src/wolfcrypt/src/ecc.c ****         key_raw[0] = ECC_POINT_UNCOMP;
10188:../src/wolfcrypt/src/ecc.c ****         keySz = (word32)key->dp->size;
10189:../src/wolfcrypt/src/ecc.c ****         err = wc_export_int(key->pubkey.x, &key_raw[1], &keySz, keySz,
10190:../src/wolfcrypt/src/ecc.c ****             WC_TYPE_UNSIGNED_BIN);
10191:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
10192:../src/wolfcrypt/src/ecc.c ****             err = wc_export_int(key->pubkey.y, &key_raw[1+keySz],
10193:../src/wolfcrypt/src/ecc.c ****                 &keySz, keySz, WC_TYPE_UNSIGNED_BIN);
10194:../src/wolfcrypt/src/ecc.c ****         }
10195:../src/wolfcrypt/src/ecc.c **** 
10196:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
10197:../src/wolfcrypt/src/ecc.c ****             pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(key->dp->id));
10198:../src/wolfcrypt/src/ecc.c **** 
10199:../src/wolfcrypt/src/ecc.c ****             /* create public key from external key buffer */
10200:../src/wolfcrypt/src/ecc.c ****             err = CRYS_ECPKI_BuildPublKeyFullCheck(pDomain,
10201:../src/wolfcrypt/src/ecc.c ****                                                    key_raw,
10202:../src/wolfcrypt/src/ecc.c ****                                                    keySz*2 + 1,
10203:../src/wolfcrypt/src/ecc.c ****                                                    &key->ctx.pubKey,
10204:../src/wolfcrypt/src/ecc.c ****                                                    &tempBuff);
10205:../src/wolfcrypt/src/ecc.c ****         }
10206:../src/wolfcrypt/src/ecc.c **** 
10207:../src/wolfcrypt/src/ecc.c ****         if (err != SA_SILIB_RET_OK){
10208:../src/wolfcrypt/src/ecc.c ****             WOLFSSL_MSG("CRYS_ECPKI_BuildPublKeyFullCheck failed");
10209:../src/wolfcrypt/src/ecc.c ****             return err;
10210:../src/wolfcrypt/src/ecc.c ****         }
10211:../src/wolfcrypt/src/ecc.c ****     }
10212:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_KCAPI_ECC)
10213:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
10214:../src/wolfcrypt/src/ecc.c ****         word32 keySz = key->dp->size;
10215:../src/wolfcrypt/src/ecc.c ****         err = wc_export_int(key->pubkey.x, key->pubkey_raw,
10216:../src/wolfcrypt/src/ecc.c ****             &keySz, keySz, WC_TYPE_UNSIGNED_BIN);
10217:../src/wolfcrypt/src/ecc.c ****         if (err == MP_OKAY) {
10218:../src/wolfcrypt/src/ecc.c ****             err = wc_export_int(key->pubkey.y,
10219:../src/wolfcrypt/src/ecc.c ****                 &key->pubkey_raw[keySz], &keySz, keySz,
10220:../src/wolfcrypt/src/ecc.c ****                 WC_TYPE_UNSIGNED_BIN);
10221:../src/wolfcrypt/src/ecc.c ****         }
10222:../src/wolfcrypt/src/ecc.c ****     }
10223:../src/wolfcrypt/src/ecc.c **** #endif
10224:../src/wolfcrypt/src/ecc.c **** 
10225:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_VALIDATE_ECC_IMPORT
10226:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
10227:../src/wolfcrypt/src/ecc.c **** #endif
10228:../src/wolfcrypt/src/ecc.c **** 
10229:../src/wolfcrypt/src/ecc.c ****     /* import private key */
10230:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
 13659                             		.loc 2 10230 8
 13660 017f EC A5                   		mov.L	[r10], r5
 13661 0181 61 05                   		cmp	#0, r5
 13662 0183 21 68                   		bne	.L945
10231:../src/wolfcrypt/src/ecc.c ****         if (d != NULL) {
 13663                             		.loc 2 10231 12
 13664 0185 ED A5 04                		mov.L	16[r10], r5
 13665 0188 61 05                   		cmp	#0, r5
 13666 018a 20 5B                   		beq	.L946
10232:../src/wolfcrypt/src/ecc.c ****         #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
10233:../src/wolfcrypt/src/ecc.c ****             /* Hardware doesn't support loading private key */
10234:../src/wolfcrypt/src/ecc.c ****             err = NOT_COMPILED_IN;
10235:../src/wolfcrypt/src/ecc.c **** 
10236:../src/wolfcrypt/src/ecc.c ****         #elif defined(WOLFSSL_SILABS_SE_ACCEL)
10237:../src/wolfcrypt/src/ecc.c ****             err = silabs_ecc_import_private_raw(key, keySz, d, encType);
10238:../src/wolfcrypt/src/ecc.c **** 
10239:../src/wolfcrypt/src/ecc.c ****         #elif defined(WOLFSSL_CRYPTOCELL)
10240:../src/wolfcrypt/src/ecc.c ****             key->type = ECC_PRIVATEKEY;
10241:../src/wolfcrypt/src/ecc.c **** 
10242:../src/wolfcrypt/src/ecc.c ****             if (encType == WC_TYPE_HEX_STR)
10243:../src/wolfcrypt/src/ecc.c ****                 err = mp_read_radix(&key->k, d, MP_RADIX_HEX);
10244:../src/wolfcrypt/src/ecc.c ****             else
10245:../src/wolfcrypt/src/ecc.c ****                 err = mp_read_unsigned_bin(&key->k, (const byte*)d,
10246:../src/wolfcrypt/src/ecc.c ****                     key->dp->size);
10247:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY) {
10248:../src/wolfcrypt/src/ecc.c ****                 err = wc_export_int(&key->k, &key_raw[0], &keySz, keySz,
10249:../src/wolfcrypt/src/ecc.c ****                     WC_TYPE_UNSIGNED_BIN);
10250:../src/wolfcrypt/src/ecc.c ****             }
10251:../src/wolfcrypt/src/ecc.c **** 
10252:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY) {
10253:../src/wolfcrypt/src/ecc.c ****                 /* Create private key from external key buffer*/
10254:../src/wolfcrypt/src/ecc.c ****                 err = CRYS_ECPKI_BuildPrivKey(pDomain,
10255:../src/wolfcrypt/src/ecc.c ****                                               key_raw,
10256:../src/wolfcrypt/src/ecc.c ****                                               keySz,
10257:../src/wolfcrypt/src/ecc.c ****                                               &key->ctx.privKey);
10258:../src/wolfcrypt/src/ecc.c **** 
10259:../src/wolfcrypt/src/ecc.c ****                 if (err != SA_SILIB_RET_OK){
10260:../src/wolfcrypt/src/ecc.c ****                     WOLFSSL_MSG("CRYS_ECPKI_BuildPrivKey failed");
10261:../src/wolfcrypt/src/ecc.c ****                     return err;
10262:../src/wolfcrypt/src/ecc.c ****                 }
10263:../src/wolfcrypt/src/ecc.c ****             }
10264:../src/wolfcrypt/src/ecc.c **** 
10265:../src/wolfcrypt/src/ecc.c ****         #else
10266:../src/wolfcrypt/src/ecc.c ****             key->type = ECC_PRIVATEKEY;
 13667                             		.loc 2 10266 23
 13668 018c ED A5 01                		mov.L	4[r10], r5
 13669 018f F8 56 02                		mov.L	#2, [r5]
10267:../src/wolfcrypt/src/ecc.c ****             if (encType == WC_TYPE_HEX_STR)
 13670                             		.loc 2 10267 16
 13671 0192 A8 6D                   		mov.L	4[r6], r5
 13672 0194 61 15                   		cmp	#1, r5
 13673 0196 21 19                   		bne	.L947
10268:../src/wolfcrypt/src/ecc.c ****                 err = mp_read_radix(&key->k, d, MP_RADIX_HEX);
 13674                             		.loc 2 10268 37
 13675 0198 ED A5 01                		mov.L	4[r10], r5
 13676 019b 72 55 48 09             		add	#0x948, r5
 13677                             		.loc 2 10268 23
 13678 019f 75 43 10                		mov.L	#16, r3
 13679 01a2 ED A2 04                		mov.L	16[r10], r2
 13680 01a5 EF 51                   		mov.L	r5, r1
 13681 01a7 05 00 00 00             		bsr	_sp_read_radix
 13682 01ab E3 A1                   		mov.L	r1, [r10]
 13683 01ad 2E 1D                   		bra	.L948
 13684                             	.L947:
10269:../src/wolfcrypt/src/ecc.c ****             else {
10270:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_QNX_CAAM
10271:../src/wolfcrypt/src/ecc.c ****                 if (key->blackKey == CAAM_BLACK_KEY_CCM) {
10272:../src/wolfcrypt/src/ecc.c ****                     err = mp_read_unsigned_bin(&key->k, (const byte*)d,
10273:../src/wolfcrypt/src/ecc.c ****                     key->dp->size + WC_CAAM_MAC_SZ);
10274:../src/wolfcrypt/src/ecc.c ****                 }
10275:../src/wolfcrypt/src/ecc.c ****                 else
10276:../src/wolfcrypt/src/ecc.c ****             #endif /* WOLFSSL_QNX_CAAM */
10277:../src/wolfcrypt/src/ecc.c ****                 {
10278:../src/wolfcrypt/src/ecc.c ****                     err = mp_read_unsigned_bin(&key->k, (const byte*)d,
 13685                             		.loc 2 10278 48
 13686 01af ED A5 01                		mov.L	4[r10], r5
 13687 01b2 72 54 48 09             		add	#0x948, r5, r4
10279:../src/wolfcrypt/src/ecc.c ****                     key->dp->size);
 13688                             		.loc 2 10279 24
 13689 01b6 ED A5 01                		mov.L	4[r10], r5
 13690 01b9 A9 55                   		mov.L	16[r5], r5
 13691                             		.loc 2 10279 28
 13692 01bb EC 55                   		mov.L	[r5], r5
10278:../src/wolfcrypt/src/ecc.c ****                     key->dp->size);
 13693                             		.loc 2 10278 27
 13694 01bd EF 53                   		mov.L	r5, r3
 13695 01bf ED A2 04                		mov.L	16[r10], r2
 13696 01c2 EF 41                   		mov.L	r4, r1
 13697 01c4 05 00 00 00             		bsr	_sp_read_unsigned_bin
 13698 01c8 E3 A1                   		mov.L	r1, [r10]
 13699                             	.L948:
10280:../src/wolfcrypt/src/ecc.c ****                 }
10281:../src/wolfcrypt/src/ecc.c ****             }
10282:../src/wolfcrypt/src/ecc.c ****         #endif /* WOLFSSL_ATECC508A */
10283:../src/wolfcrypt/src/ecc.c ****             if (mp_iszero(&key->k) || mp_isneg(&key->k)) {
 13700                             		.loc 2 10283 17
 13701 01ca ED A5 01                		mov.L	4[r10], r5
 13702 01cd EE 55 52 02             		mov.L	2376[r5], r5
 13703                             		.loc 2 10283 16
 13704 01d1 61 05                   		cmp	#0, r5
 13705 01d3 21 18                   		bne	.L945
10284:../src/wolfcrypt/src/ecc.c ****                 WOLFSSL_MSG("Invalid private key");
 13706                             		.loc 2 10284 17
 13707 01d5 FB 12 06 0B 00 00       		mov.L	#.LC46, r1
 13708 01db 05 00 00 00             		bsr	_WOLFSSL_MSG
10285:../src/wolfcrypt/src/ecc.c ****                 return BAD_FUNC_ARG;
 13709                             		.loc 2 10285 24
 13710 01df FB 5A 53 FF             		mov.L	#-173, r5
 13711 01e3 2E 43                   		bra	.L934
 13712                             	.L946:
10286:../src/wolfcrypt/src/ecc.c ****             }
10287:../src/wolfcrypt/src/ecc.c ****         } else {
10288:../src/wolfcrypt/src/ecc.c ****             key->type = ECC_PUBLICKEY;
 13713                             		.loc 2 10288 23
 13714 01e5 ED A5 01                		mov.L	4[r10], r5
 13715 01e8 F8 56 01                		mov.L	#1, [r5]
 13716                             	.L945:
10289:../src/wolfcrypt/src/ecc.c ****         }
10290:../src/wolfcrypt/src/ecc.c ****     }
10291:../src/wolfcrypt/src/ecc.c **** 
10292:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_VALIDATE_ECC_IMPORT
10293:../src/wolfcrypt/src/ecc.c ****     if (err == MP_OKAY) {
10294:../src/wolfcrypt/src/ecc.c ****         err = wc_ecc_check_key(key);
10295:../src/wolfcrypt/src/ecc.c ****         if (err == IS_POINT_E && (mp_iszero(key->pubkey.x) ||
10296:../src/wolfcrypt/src/ecc.c ****                                   mp_iszero(key->pubkey.y))) {
10297:../src/wolfcrypt/src/ecc.c ****             err = BAD_FUNC_ARG;
10298:../src/wolfcrypt/src/ecc.c ****         }
10299:../src/wolfcrypt/src/ecc.c ****     }
10300:../src/wolfcrypt/src/ecc.c **** #endif
10301:../src/wolfcrypt/src/ecc.c **** 
10302:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_VALIDATE_ECC_IMPORT
10303:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
10304:../src/wolfcrypt/src/ecc.c **** #endif
10305:../src/wolfcrypt/src/ecc.c **** 
10306:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY) {
 13717                             		.loc 2 10306 8
 13718 01eb EC A5                   		mov.L	[r10], r5
 13719 01ed 61 05                   		cmp	#0, r5
 13720 01ef 20 35                   		beq	.L949
10307:../src/wolfcrypt/src/ecc.c ****         mp_clear(key->pubkey.x);
 13721                             		.loc 2 10307 29
 13722 01f1 ED A5 01                		mov.L	4[r10], r5
 13723 01f4 71 55 18                		add	#24, r5
 13724                             		.loc 2 10307 9
 13725 01f7 EF 51                   		mov.L	r5, r1
 13726 01f9 05 00 00 00             		bsr	_sp_clear
10308:../src/wolfcrypt/src/ecc.c ****         mp_clear(key->pubkey.y);
 13727                             		.loc 2 10308 29
 13728 01fd ED A5 01                		mov.L	4[r10], r5
 13729 0200 72 55 28 03             		add	#0x328, r5
 13730                             		.loc 2 10308 9
 13731 0204 EF 51                   		mov.L	r5, r1
 13732 0206 05 00 00 00             		bsr	_sp_clear
10309:../src/wolfcrypt/src/ecc.c ****         mp_clear(key->pubkey.z);
 13733                             		.loc 2 10309 29
 13734 020a ED A5 01                		mov.L	4[r10], r5
 13735 020d 72 55 38 06             		add	#0x638, r5
 13736                             		.loc 2 10309 9
 13737 0211 EF 51                   		mov.L	r5, r1
 13738 0213 05 00 00 00             		bsr	_sp_clear
10310:../src/wolfcrypt/src/ecc.c ****         mp_clear(&key->k);
 13739                             		.loc 2 10310 18
 13740 0217 ED A5 01                		mov.L	4[r10], r5
 13741 021a 72 55 48 09             		add	#0x948, r5
 13742                             		.loc 2 10310 9
 13743 021e EF 51                   		mov.L	r5, r1
 13744 0220 05 00 00 00             		bsr	_sp_clear
 13745                             	.L949:
10311:../src/wolfcrypt/src/ecc.c ****     }
10312:../src/wolfcrypt/src/ecc.c **** 
10313:../src/wolfcrypt/src/ecc.c ****     return err;
 13746                             		.loc 2 10313 12
 13747 0224 EC A5                   		mov.L	[r10], r5
 13748                             		.balign 8,3,1
 13749                             	.L934:
10314:../src/wolfcrypt/src/ecc.c **** }
 13750                             		.loc 2 10314 1
 13751 0226 EF 51                   		mov.L	r5, r1
 13752 0228 71 00 24                		add	#36, r0
 13753 022b 7E B6                   		pop	r6
 13754 022d 7E BA                   		pop	r10
 13755 022f 02                      		rts
 13756                             	.LFE133:
 13758                             		.section	.text.wc_ecc_import_raw_ex,"ax",@progbits
 13759                             		.global	_wc_ecc_import_raw_ex
 13761                             	_wc_ecc_import_raw_ex:
 13762                             	.LFB134:
10315:../src/wolfcrypt/src/ecc.c **** 
10316:../src/wolfcrypt/src/ecc.c **** /**
10317:../src/wolfcrypt/src/ecc.c ****    Import raw ECC key
10318:../src/wolfcrypt/src/ecc.c ****    key       The destination ecc_key structure
10319:../src/wolfcrypt/src/ecc.c ****    qx        x component of the public key, as ASCII hex string
10320:../src/wolfcrypt/src/ecc.c ****    qy        y component of the public key, as ASCII hex string
10321:../src/wolfcrypt/src/ecc.c ****    d         private key, as ASCII hex string, optional if importing public
10322:../src/wolfcrypt/src/ecc.c ****              key only
10323:../src/wolfcrypt/src/ecc.c ****    dp        Custom ecc_set_type
10324:../src/wolfcrypt/src/ecc.c ****    return    MP_OKAY on success
10325:../src/wolfcrypt/src/ecc.c **** */
10326:../src/wolfcrypt/src/ecc.c **** int wc_ecc_import_raw_ex(ecc_key* key, const char* qx, const char* qy,
10327:../src/wolfcrypt/src/ecc.c ****                    const char* d, int curve_id)
10328:../src/wolfcrypt/src/ecc.c **** {
 13763                             		.loc 2 10328 1
 13764 0000 7E AA                   		push.l	r10
 13765                             	.LCFI241:
 13766 0002 71 0A EC                		add	#-20, r0, r10
 13767                             	.LCFI242:
 13768 0005 71 A0 F8                		add	#-8, r10, r0
 13769                             	.LCFI243:
 13770 0008 75 45 1C                		mov.L	#28, r5
 13771 000b 4B A5                   		add	r10, r5
 13772 000d E3 A1                   		mov.L	r1, [r10]
 13773 000f E7 A2 01                		mov.L	r2, 4[r10]
 13774 0012 E7 A3 02                		mov.L	r3, 8[r10]
 13775 0015 E7 A4 03                		mov.L	r4, 12[r10]
10329:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_import_raw_private(key, qx, qy, d, curve_id,
 13776                             		.loc 2 10329 12
 13777 0018 3E 01 01                		mov.L	#1, 4[r0]
 13778 001b EC 55                   		mov.L	[r5], r5
 13779 001d E3 05                   		mov.L	r5, [r0]
 13780 001f ED A4 03                		mov.L	12[r10], r4
 13781 0022 ED A3 02                		mov.L	8[r10], r3
 13782 0025 ED A2 01                		mov.L	4[r10], r2
 13783 0028 EC A1                   		mov.L	[r10], r1
 13784 002a 05 00 00 00             		bsr	_wc_ecc_import_raw_private
 13785 002e EF 15                   		mov.L	r1, r5
10330:../src/wolfcrypt/src/ecc.c ****         WC_TYPE_HEX_STR);
10331:../src/wolfcrypt/src/ecc.c **** 
10332:../src/wolfcrypt/src/ecc.c **** }
 13786                             		.loc 2 10332 1
 13787 0030 EF 51                   		mov.L	r5, r1
 13788 0032 3F AA 08                		rtsd	#32, r10-r10
 13789                             	.LFE134:
 13791                             		.section	.text.wc_ecc_import_unsigned,"ax",@progbits
 13792                             		.global	_wc_ecc_import_unsigned
 13794                             	_wc_ecc_import_unsigned:
 13795                             	.LFB135:
10333:../src/wolfcrypt/src/ecc.c **** 
10334:../src/wolfcrypt/src/ecc.c **** /* Import x, y and optional private (d) as unsigned binary */
10335:../src/wolfcrypt/src/ecc.c **** int wc_ecc_import_unsigned(ecc_key* key, const byte* qx, const byte* qy,
10336:../src/wolfcrypt/src/ecc.c ****                    const byte* d, int curve_id)
10337:../src/wolfcrypt/src/ecc.c **** {
 13796                             		.loc 2 10337 1
 13797 0000 7E AA                   		push.l	r10
 13798                             	.LCFI244:
 13799 0002 71 0A EC                		add	#-20, r0, r10
 13800                             	.LCFI245:
 13801 0005 71 A0 F8                		add	#-8, r10, r0
 13802                             	.LCFI246:
 13803 0008 75 45 1C                		mov.L	#28, r5
 13804 000b 4B A5                   		add	r10, r5
 13805 000d E3 A1                   		mov.L	r1, [r10]
 13806 000f E7 A2 01                		mov.L	r2, 4[r10]
 13807 0012 E7 A3 02                		mov.L	r3, 8[r10]
 13808 0015 E7 A4 03                		mov.L	r4, 12[r10]
10338:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_import_raw_private(key, (const char*)qx, (const char*)qy,
 13809                             		.loc 2 10338 12
 13810 0018 3E 01 02                		mov.L	#2, 4[r0]
 13811 001b EC 55                   		mov.L	[r5], r5
 13812 001d E3 05                   		mov.L	r5, [r0]
 13813 001f ED A4 03                		mov.L	12[r10], r4
 13814 0022 ED A3 02                		mov.L	8[r10], r3
 13815 0025 ED A2 01                		mov.L	4[r10], r2
 13816 0028 EC A1                   		mov.L	[r10], r1
 13817 002a 05 00 00 00             		bsr	_wc_ecc_import_raw_private
 13818 002e EF 15                   		mov.L	r1, r5
10339:../src/wolfcrypt/src/ecc.c ****         (const char*)d, curve_id, WC_TYPE_UNSIGNED_BIN);
10340:../src/wolfcrypt/src/ecc.c **** }
 13819                             		.loc 2 10340 1
 13820 0030 EF 51                   		mov.L	r5, r1
 13821 0032 3F AA 08                		rtsd	#32, r10-r10
 13822                             	.LFE135:
 13824                             		.section	.text.wc_ecc_import_raw,"ax",@progbits
 13825                             		.global	_wc_ecc_import_raw
 13827                             	_wc_ecc_import_raw:
 13828                             	.LFB136:
10341:../src/wolfcrypt/src/ecc.c **** 
10342:../src/wolfcrypt/src/ecc.c **** /**
10343:../src/wolfcrypt/src/ecc.c ****    Import raw ECC key
10344:../src/wolfcrypt/src/ecc.c ****    key       The destination ecc_key structure
10345:../src/wolfcrypt/src/ecc.c ****    qx        x component of the public key, as ASCII hex string
10346:../src/wolfcrypt/src/ecc.c ****    qy        y component of the public key, as ASCII hex string
10347:../src/wolfcrypt/src/ecc.c ****    d         private key, as ASCII hex string, optional if importing public
10348:../src/wolfcrypt/src/ecc.c ****              key only
10349:../src/wolfcrypt/src/ecc.c ****    curveName ECC curve name, from ecc_sets[]
10350:../src/wolfcrypt/src/ecc.c ****    return    MP_OKAY on success
10351:../src/wolfcrypt/src/ecc.c **** */
10352:../src/wolfcrypt/src/ecc.c **** int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
10353:../src/wolfcrypt/src/ecc.c ****                    const char* d, const char* curveName)
10354:../src/wolfcrypt/src/ecc.c **** {
 13829                             		.loc 2 10354 1
 13830 0000 6E 6B                   		pushm	r6-r11
 13831                             	.LCFI247:
 13832 0002 71 0A E4                		add	#-28, r0, r10
 13833                             	.LCFI248:
 13834 0005 71 A0 F8                		add	#-8, r10, r0
 13835                             	.LCFI249:
 13836 0008 75 46 38                		mov.L	#56, r6
 13837 000b 4B A6                   		add	r10, r6
 13838 000d E7 A1 02                		mov.L	r1, 8[r10]
 13839 0010 E7 A2 03                		mov.L	r2, 12[r10]
 13840 0013 E7 A3 04                		mov.L	r3, 16[r10]
 13841 0016 E7 A4 05                		mov.L	r4, 20[r10]
10355:../src/wolfcrypt/src/ecc.c ****     int err, x;
10356:../src/wolfcrypt/src/ecc.c **** 
10357:../src/wolfcrypt/src/ecc.c ****     /* if d is NULL, only import as public key using Qx,Qy */
10358:../src/wolfcrypt/src/ecc.c ****     if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
 13842                             		.loc 2 10358 8
 13843 0019 ED A5 02                		mov.L	8[r10], r5
 13844 001c 61 05                   		cmp	#0, r5
 13845 001e 20 14                   		beq	.L957
 13846                             		.loc 2 10358 21 discriminator 1
 13847 0020 ED A5 03                		mov.L	12[r10], r5
 13848 0023 61 05                   		cmp	#0, r5
 13849 0025 20 0D                   		beq	.L957
 13850                             		.loc 2 10358 35 discriminator 2
 13851 0027 ED A5 04                		mov.L	16[r10], r5
 13852 002a 61 05                   		cmp	#0, r5
 13853 002c 16                      		beq	.L957
 13854                             		.loc 2 10358 49 discriminator 3
 13855 002d EC 65                   		mov.L	[r6], r5
 13856 002f 61 05                   		cmp	#0, r5
 13857 0031 18                      		bne	.L958
 13858                             		.balign 8,3,2
 13859                             	.L957:
10359:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 13860                             		.loc 2 10359 16
 13861 0032 FB 5A 53 FF             		mov.L	#-173, r5
 13862 0036 38 9C 00                		bra	.L959
 13863                             	.L958:
10360:../src/wolfcrypt/src/ecc.c ****     }
10361:../src/wolfcrypt/src/ecc.c **** 
10362:../src/wolfcrypt/src/ecc.c ****     /* set curve type and index */
10363:../src/wolfcrypt/src/ecc.c ****     for (x = 0; ecc_sets[x].size != 0; x++) {
 13864                             		.loc 2 10363 12
 13865 0039 F8 A6 00                		mov.L	#0, [r10]
 13866                             		.loc 2 10363 5
 13867 003c 2E 31                   		bra	.L960
 13868                             	.L963:
10364:../src/wolfcrypt/src/ecc.c ****         if (XSTRNCMP(ecc_sets[x].name, curveName,
 13869                             		.loc 2 10364 13
 13870 003e FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 13871 0044 EC A5                   		mov.L	[r10], r5
 13872 0046 75 15 34                		mul	#52, r5
 13873 0049 4B 45                   		add	r4, r5
 13874 004b 62 85                   		add	#8, r5
 13875 004d EC 5B                   		mov.L	[r5], r11
 13876 004f EC 61                   		mov.L	[r6], r1
 13877 0051 05 00 00 00             		bsr	_strlen
 13878 0055 EF 15                   		mov.L	r1, r5
 13879 0057 EF 53                   		mov.L	r5, r3
 13880 0059 EC 62                   		mov.L	[r6], r2
 13881 005b EF B1                   		mov.L	r11, r1
 13882 005d 05 00 00 00             		bsr	_strncmp
 13883 0061 EF 15                   		mov.L	r1, r5
 13884                             		.loc 2 10364 12
 13885 0063 61 05                   		cmp	#0, r5
 13886 0065 20 1D                   		beq	.L966
10363:../src/wolfcrypt/src/ecc.c ****         if (XSTRNCMP(ecc_sets[x].name, curveName,
 13887                             		.loc 2 10363 41 discriminator 2
 13888 0067 EC A5                   		mov.L	[r10], r5
 13889 0069 62 15                   		add	#1, r5
 13890 006b E3 A5                   		mov.L	r5, [r10]
 13891                             	.L960:
10363:../src/wolfcrypt/src/ecc.c ****         if (XSTRNCMP(ecc_sets[x].name, curveName,
 13892                             		.loc 2 10363 28 discriminator 1
 13893 006d FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 13894 0073 EC A5                   		mov.L	[r10], r5
 13895 0075 75 15 34                		mul	#52, r5
 13896 0078 4B 45                   		add	r4, r5
 13897 007a EC 55                   		mov.L	[r5], r5
10363:../src/wolfcrypt/src/ecc.c ****         if (XSTRNCMP(ecc_sets[x].name, curveName,
 13898                             		.loc 2 10363 5 discriminator 1
 13899 007c 61 05                   		cmp	#0, r5
 13900 007e 21 C0                   		bne	.L963
 13901 0080 2E 03                   		bra	.L962
 13902                             	.L966:
10365:../src/wolfcrypt/src/ecc.c ****                      XSTRLEN(curveName)) == 0) {
10366:../src/wolfcrypt/src/ecc.c ****             break;
 13903                             		.loc 2 10366 13
 13904 0082 03                      		nop
 13905                             	.L962:
10367:../src/wolfcrypt/src/ecc.c ****         }
10368:../src/wolfcrypt/src/ecc.c ****     }
10369:../src/wolfcrypt/src/ecc.c **** 
10370:../src/wolfcrypt/src/ecc.c ****     if (ecc_sets[x].size == 0) {
 13906                             		.loc 2 10370 20
 13907 0083 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 13908 0089 EC A5                   		mov.L	[r10], r5
 13909 008b 75 15 34                		mul	#52, r5
 13910 008e 4B 45                   		add	r4, r5
 13911 0090 EC 55                   		mov.L	[r5], r5
 13912                             		.loc 2 10370 8
 13913 0092 61 05                   		cmp	#0, r5
 13914 0094 21 16                   		bne	.L964
10371:../src/wolfcrypt/src/ecc.c ****         WOLFSSL_MSG("ecc_set curve name not found");
 13915                             		.loc 2 10371 9
 13916 0096 FB 12 14 0A 00 00       		mov.L	#.LC37, r1
 13917 009c 05 00 00 00             		bsr	_WOLFSSL_MSG
10372:../src/wolfcrypt/src/ecc.c ****         err = ASN_PARSE_E;
 13918                             		.loc 2 10372 13
 13919 00a0 F9 AA 01 74 FF          		mov.L	#-140, 4[r10]
10373:../src/wolfcrypt/src/ecc.c ****     } else {
10374:../src/wolfcrypt/src/ecc.c ****         return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
10375:../src/wolfcrypt/src/ecc.c ****             WC_TYPE_HEX_STR);
10376:../src/wolfcrypt/src/ecc.c ****     }
10377:../src/wolfcrypt/src/ecc.c **** 
10378:../src/wolfcrypt/src/ecc.c ****     return err;
 13920                             		.loc 2 10378 12
 13921 00a5 ED A5 01                		mov.L	4[r10], r5
 13922 00a8 2E 2A                   		bra	.L959
 13923                             	.L964:
10374:../src/wolfcrypt/src/ecc.c ****             WC_TYPE_HEX_STR);
 13924                             		.loc 2 10374 16
 13925 00aa FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 13926 00b0 EC A5                   		mov.L	[r10], r5
 13927 00b2 75 15 34                		mul	#52, r5
 13928 00b5 4B 45                   		add	r4, r5
 13929 00b7 62 45                   		add	#4, r5
 13930 00b9 EC 55                   		mov.L	[r5], r5
 13931 00bb 3E 01 01                		mov.L	#1, 4[r0]
 13932 00be E3 05                   		mov.L	r5, [r0]
 13933 00c0 ED A4 05                		mov.L	20[r10], r4
 13934 00c3 ED A3 04                		mov.L	16[r10], r3
 13935 00c6 ED A2 03                		mov.L	12[r10], r2
 13936 00c9 ED A1 02                		mov.L	8[r10], r1
 13937 00cc 05 00 00 00             		bsr	_wc_ecc_import_raw_private
 13938 00d0 EF 15                   		mov.L	r1, r5
 13939                             	.L959:
10379:../src/wolfcrypt/src/ecc.c **** }
 13940                             		.loc 2 10379 1
 13941 00d2 EF 51                   		mov.L	r5, r1
 13942 00d4 3F 6B 0F                		rtsd	#60, r6-r11
 13943                             	.LFE136:
 13945 00d7 03                      		.section	.text.wc_ecc_size,"ax",@progbits
 13946                             		.global	_wc_ecc_size
 13948                             	_wc_ecc_size:
 13949                             	.LFB137:
10380:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_KEY_IMPORT */
10381:../src/wolfcrypt/src/ecc.c **** 
10382:../src/wolfcrypt/src/ecc.c **** #if defined(HAVE_ECC_ENCRYPT) && !defined(WOLFSSL_ECIES_OLD)
10383:../src/wolfcrypt/src/ecc.c **** /* public key size in octets */
10384:../src/wolfcrypt/src/ecc.c **** static int ecc_public_key_size(ecc_key* key, word32* sz)
10385:../src/wolfcrypt/src/ecc.c **** {
10386:../src/wolfcrypt/src/ecc.c ****     if (key == NULL || key->dp == NULL)
10387:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
10388:../src/wolfcrypt/src/ecc.c **** 
10389:../src/wolfcrypt/src/ecc.c ****     /* 'Uncompressed' | x | y */
10390:../src/wolfcrypt/src/ecc.c ****     *sz = 1 + 2 * key->dp->size;
10391:../src/wolfcrypt/src/ecc.c **** 
10392:../src/wolfcrypt/src/ecc.c ****     return 0;
10393:../src/wolfcrypt/src/ecc.c **** }
10394:../src/wolfcrypt/src/ecc.c **** #endif
10395:../src/wolfcrypt/src/ecc.c **** 
10396:../src/wolfcrypt/src/ecc.c **** /* key size in octets */
10397:../src/wolfcrypt/src/ecc.c **** int wc_ecc_size(ecc_key* key)
10398:../src/wolfcrypt/src/ecc.c **** {
 13950                             		.loc 2 10398 1
 13951 0000 7E AA                   		push.l	r10
 13952                             	.LCFI250:
 13953 0002 71 0A FC                		add	#-4, r0, r10
 13954                             	.LCFI251:
 13955 0005 EF A0                   		mov.L	r10, r0
 13956 0007 E3 A1                   		mov.L	r1, [r10]
10399:../src/wolfcrypt/src/ecc.c ****     if (key == NULL || key->dp == NULL)
 13957                             		.loc 2 10399 8
 13958 0009 EC A5                   		mov.L	[r10], r5
 13959 000b 61 05                   		cmp	#0, r5
 13960 000d 10                      		beq	.L968
 13961                             		.loc 2 10399 27 discriminator 1
 13962 000e EC A5                   		mov.L	[r10], r5
 13963 0010 A9 55                   		mov.L	16[r5], r5
 13964                             		.loc 2 10399 21 discriminator 1
 13965 0012 61 05                   		cmp	#0, r5
 13966 0014 1C                      		bne	.L969
 13967                             	.L968:
10400:../src/wolfcrypt/src/ecc.c ****         return 0;
 13968                             		.loc 2 10400 16
 13969 0015 66 05                   		mov.L	#0, r5
 13970 0017 0F                      		bra	.L970
 13971                             	.L969:
10401:../src/wolfcrypt/src/ecc.c **** 
10402:../src/wolfcrypt/src/ecc.c ****     return key->dp->size;
 13972                             		.loc 2 10402 15
 13973 0018 EC A5                   		mov.L	[r10], r5
 13974 001a A9 55                   		mov.L	16[r5], r5
 13975                             		.loc 2 10402 19
 13976 001c EC 55                   		mov.L	[r5], r5
 13977                             	.L970:
10403:../src/wolfcrypt/src/ecc.c **** }
 13978                             		.loc 2 10403 1
 13979 001e EF 51                   		mov.L	r5, r1
 13980 0020 3F AA 02                		rtsd	#8, r10-r10
 13981                             	.LFE137:
 13983                             		.section	.text.wc_ecc_sig_size_calc,"ax",@progbits
 13984                             		.global	_wc_ecc_sig_size_calc
 13986                             	_wc_ecc_sig_size_calc:
 13987                             	.LFB138:
10404:../src/wolfcrypt/src/ecc.c **** 
10405:../src/wolfcrypt/src/ecc.c **** /* maximum signature size based on key size */
10406:../src/wolfcrypt/src/ecc.c **** int wc_ecc_sig_size_calc(int sz)
10407:../src/wolfcrypt/src/ecc.c **** {
 13988                             		.loc 2 10407 1
 13989 0000 7E AA                   		push.l	r10
 13990                             	.LCFI252:
 13991 0002 71 0A F8                		add	#-8, r0, r10
 13992                             	.LCFI253:
 13993 0005 EF A0                   		mov.L	r10, r0
 13994 0007 E7 A1 01                		mov.L	r1, 4[r10]
10408:../src/wolfcrypt/src/ecc.c ****     int maxSigSz = 0;
 13995                             		.loc 2 10408 9
 13996 000a F8 A6 00                		mov.L	#0, [r10]
10409:../src/wolfcrypt/src/ecc.c **** 
10410:../src/wolfcrypt/src/ecc.c ****     /* calculate based on key bits */
10411:../src/wolfcrypt/src/ecc.c ****     /* maximum possible signature header size is 7 bytes plus 2 bytes padding */
10412:../src/wolfcrypt/src/ecc.c ****     maxSigSz = (sz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ;
 13997                             		.loc 2 10412 20
 13998 000d ED A5 01                		mov.L	4[r10], r5
 13999 0010 4B 55                   		add	r5, r5
 14000                             		.loc 2 10412 14
 14001 0012 62 95                   		add	#9, r5
 14002 0014 E3 A5                   		mov.L	r5, [r10]
10413:../src/wolfcrypt/src/ecc.c **** 
10414:../src/wolfcrypt/src/ecc.c ****     /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */
10415:../src/wolfcrypt/src/ecc.c ****     if (maxSigSz < (128 + 2)) {
 14003                             		.loc 2 10415 8
 14004 0016 EC A5                   		mov.L	[r10], r5
 14005 0018 75 55 81                		cmp	#0x81, r5
 14006 001b 2A 08                   		bgt	.L972
10416:../src/wolfcrypt/src/ecc.c ****         maxSigSz -= 1;
 14007                             		.loc 2 10416 18
 14008 001d EC A5                   		mov.L	[r10], r5
 14009 001f 60 15                   		sub	#1, r5
 14010 0021 E3 A5                   		mov.L	r5, [r10]
 14011                             	.L972:
10417:../src/wolfcrypt/src/ecc.c ****     }
10418:../src/wolfcrypt/src/ecc.c **** 
10419:../src/wolfcrypt/src/ecc.c ****     return maxSigSz;
 14012                             		.loc 2 10419 12
 14013 0023 EC A5                   		mov.L	[r10], r5
10420:../src/wolfcrypt/src/ecc.c **** }
 14014                             		.loc 2 10420 1
 14015 0025 EF 51                   		mov.L	r5, r1
 14016 0027 3F AA 03                		rtsd	#12, r10-r10
 14017                             	.LFE138:
 14019                             		.section	.text.wc_ecc_sig_size,"ax",@progbits
 14020                             		.global	_wc_ecc_sig_size
 14022                             	_wc_ecc_sig_size:
 14023                             	.LFB139:
10421:../src/wolfcrypt/src/ecc.c **** 
10422:../src/wolfcrypt/src/ecc.c **** /* maximum signature size based on actual key curve */
10423:../src/wolfcrypt/src/ecc.c **** int wc_ecc_sig_size(const ecc_key* key)
10424:../src/wolfcrypt/src/ecc.c **** {
 14024                             		.loc 2 10424 1
 14025 0000 7E AA                   		push.l	r10
 14026                             	.LCFI254:
 14027 0002 71 0A F0                		add	#-16, r0, r10
 14028                             	.LCFI255:
 14029 0005 EF A0                   		mov.L	r10, r0
 14030 0007 E7 A1 03                		mov.L	r1, 12[r10]
10425:../src/wolfcrypt/src/ecc.c ****     int maxSigSz;
10426:../src/wolfcrypt/src/ecc.c ****     int orderBits, keySz;
10427:../src/wolfcrypt/src/ecc.c **** 
10428:../src/wolfcrypt/src/ecc.c ****     if (key == NULL || key->dp == NULL)
 14031                             		.loc 2 10428 8
 14032 000a ED A5 03                		mov.L	12[r10], r5
 14033 000d 61 05                   		cmp	#0, r5
 14034 000f 11                      		beq	.L975
 14035                             		.loc 2 10428 27 discriminator 1
 14036 0010 ED A5 03                		mov.L	12[r10], r5
 14037 0013 A9 55                   		mov.L	16[r5], r5
 14038                             		.loc 2 10428 21 discriminator 1
 14039 0015 61 05                   		cmp	#0, r5
 14040 0017 1D                      		bne	.L976
 14041                             	.L975:
10429:../src/wolfcrypt/src/ecc.c ****         return 0;
 14042                             		.loc 2 10429 16
 14043 0018 66 05                   		mov.L	#0, r5
 14044 001a 2E 5C                   		bra	.L977
 14045                             	.L976:
10430:../src/wolfcrypt/src/ecc.c **** 
10431:../src/wolfcrypt/src/ecc.c ****     /* the signature r and s will always be less than order */
10432:../src/wolfcrypt/src/ecc.c ****     /* if the order MSB (top bit of byte) is set then ASN encoding needs
10433:../src/wolfcrypt/src/ecc.c ****         extra byte for r and s, so add 2 */
10434:../src/wolfcrypt/src/ecc.c ****     keySz = key->dp->size;
 14046                             		.loc 2 10434 16
 14047 001c ED A5 03                		mov.L	12[r10], r5
 14048 001f A9 55                   		mov.L	16[r5], r5
 14049                             		.loc 2 10434 11
 14050 0021 EC 55                   		mov.L	[r5], r5
 14051 0023 E7 A5 01                		mov.L	r5, 4[r10]
10435:../src/wolfcrypt/src/ecc.c ****     orderBits = wc_ecc_get_curve_order_bit_count(key->dp);
 14052                             		.loc 2 10435 17
 14053 0026 ED A5 03                		mov.L	12[r10], r5
 14054 0029 A9 55                   		mov.L	16[r5], r5
 14055 002b EF 51                   		mov.L	r5, r1
 14056 002d 05 00 00 00             		bsr	_wc_ecc_get_curve_order_bit_count
 14057 0031 E7 A1 02                		mov.L	r1, 8[r10]
10436:../src/wolfcrypt/src/ecc.c ****     if (orderBits > keySz * 8) {
 14058                             		.loc 2 10436 27
 14059 0034 ED A5 01                		mov.L	4[r10], r5
 14060 0037 6C 35                   		shll	#3, r5
 14061                             		.loc 2 10436 8
 14062 0039 ED A4 02                		mov.L	8[r10], r4
 14063 003c 47 54                   		cmp	r5, r4
 14064 003e 2B 12                   		ble	.L978
10437:../src/wolfcrypt/src/ecc.c ****         keySz = (orderBits + 7) / 8;
 14065                             		.loc 2 10437 28
 14066 0040 ED A5 02                		mov.L	8[r10], r5
 14067 0043 62 75                   		add	#7, r5
 14068                             		.loc 2 10437 15
 14069 0045 61 05                   		cmp	#0, r5
 14070 0047 28 04                   		bge	.L979
 14071 0049 62 75                   		add	#7, r5
 14072                             	.L979:
 14073 004b 6A 35                   		shar	#3, r5
 14074 004d E7 A5 01                		mov.L	r5, 4[r10]
 14075                             	.L978:
10438:../src/wolfcrypt/src/ecc.c ****     }
10439:../src/wolfcrypt/src/ecc.c ****     /* maximum possible signature header size is 7 bytes */
10440:../src/wolfcrypt/src/ecc.c ****     maxSigSz = (keySz * 2) + SIG_HEADER_SZ;
 14076                             		.loc 2 10440 23
 14077 0050 ED A5 01                		mov.L	4[r10], r5
 14078 0053 4B 55                   		add	r5, r5
 14079                             		.loc 2 10440 14
 14080 0055 62 75                   		add	#7, r5
 14081 0057 E3 A5                   		mov.L	r5, [r10]
10441:../src/wolfcrypt/src/ecc.c ****     if ((orderBits % 8) == 0) {
 14082                             		.loc 2 10441 25
 14083 0059 ED A5 02                		mov.L	8[r10], r5
 14084 005c 64 75                   		and	#7, r5
 14085                             		.loc 2 10441 8
 14086 005e 61 05                   		cmp	#0, r5
 14087 0060 1F                      		bne	.L980
10442:../src/wolfcrypt/src/ecc.c ****         /* MSB can be set, so add 2 */
10443:../src/wolfcrypt/src/ecc.c ****         maxSigSz += ECC_MAX_PAD_SZ;
 14088                             		.loc 2 10443 18
 14089 0061 EC A5                   		mov.L	[r10], r5
 14090 0063 62 25                   		add	#2, r5
 14091 0065 E3 A5                   		mov.L	r5, [r10]
 14092                             	.L980:
10444:../src/wolfcrypt/src/ecc.c ****     }
10445:../src/wolfcrypt/src/ecc.c ****     /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */
10446:../src/wolfcrypt/src/ecc.c ****     if (maxSigSz < (128 + 2)) {
 14093                             		.loc 2 10446 8
 14094 0067 EC A5                   		mov.L	[r10], r5
 14095 0069 75 55 81                		cmp	#0x81, r5
 14096 006c 2A 08                   		bgt	.L981
10447:../src/wolfcrypt/src/ecc.c ****         maxSigSz -= 1;
 14097                             		.loc 2 10447 18
 14098 006e EC A5                   		mov.L	[r10], r5
 14099 0070 60 15                   		sub	#1, r5
 14100 0072 E3 A5                   		mov.L	r5, [r10]
 14101                             	.L981:
10448:../src/wolfcrypt/src/ecc.c ****     }
10449:../src/wolfcrypt/src/ecc.c **** 
10450:../src/wolfcrypt/src/ecc.c ****     return maxSigSz;
 14102                             		.loc 2 10450 12
 14103 0074 EC A5                   		mov.L	[r10], r5
 14104                             	.L977:
10451:../src/wolfcrypt/src/ecc.c **** }
 14105                             		.loc 2 10451 1
 14106 0076 EF 51                   		mov.L	r5, r1
 14107 0078 3F AA 05                		rtsd	#20, r10-r10
 14108                             	.LFE139:
 14110                             		.section	.text.wc_ecc_set_rng,"ax",@progbits
 14111                             		.global	_wc_ecc_set_rng
 14113                             	_wc_ecc_set_rng:
 14114                             	.LFB140:
10452:../src/wolfcrypt/src/ecc.c **** 
10453:../src/wolfcrypt/src/ecc.c **** 
10454:../src/wolfcrypt/src/ecc.c **** #ifdef FP_ECC
10455:../src/wolfcrypt/src/ecc.c **** 
10456:../src/wolfcrypt/src/ecc.c **** /* fixed point ECC cache */
10457:../src/wolfcrypt/src/ecc.c **** /* number of entries in the cache */
10458:../src/wolfcrypt/src/ecc.c **** #ifndef FP_ENTRIES
10459:../src/wolfcrypt/src/ecc.c ****     #define FP_ENTRIES 15
10460:../src/wolfcrypt/src/ecc.c **** #endif
10461:../src/wolfcrypt/src/ecc.c **** 
10462:../src/wolfcrypt/src/ecc.c **** /* number of bits in LUT */
10463:../src/wolfcrypt/src/ecc.c **** #ifndef FP_LUT
10464:../src/wolfcrypt/src/ecc.c ****     #define FP_LUT     8U
10465:../src/wolfcrypt/src/ecc.c **** #endif
10466:../src/wolfcrypt/src/ecc.c **** 
10467:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_SHAMIR
10468:../src/wolfcrypt/src/ecc.c ****     /* Sharmir requires a bigger LUT, TAO */
10469:../src/wolfcrypt/src/ecc.c ****     #if (FP_LUT > 12) || (FP_LUT < 4)
10470:../src/wolfcrypt/src/ecc.c ****         #error FP_LUT must be between 4 and 12 inclusively
10471:../src/wolfcrypt/src/ecc.c ****     #endif
10472:../src/wolfcrypt/src/ecc.c **** #else
10473:../src/wolfcrypt/src/ecc.c ****     #if (FP_LUT > 12) || (FP_LUT < 2)
10474:../src/wolfcrypt/src/ecc.c ****         #error FP_LUT must be between 2 and 12 inclusively
10475:../src/wolfcrypt/src/ecc.c ****     #endif
10476:../src/wolfcrypt/src/ecc.c **** #endif
10477:../src/wolfcrypt/src/ecc.c **** 
10478:../src/wolfcrypt/src/ecc.c **** 
10479:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
10480:../src/wolfcrypt/src/ecc.c **** 
10481:../src/wolfcrypt/src/ecc.c **** /** Our FP cache */
10482:../src/wolfcrypt/src/ecc.c **** typedef struct {
10483:../src/wolfcrypt/src/ecc.c ****    ecc_point* g;               /* cached COPY of base point */
10484:../src/wolfcrypt/src/ecc.c ****    ecc_point* LUT[1U<<FP_LUT]; /* fixed point lookup */
10485:../src/wolfcrypt/src/ecc.c ****    int        LUT_set;         /* flag to determine if the LUT has been computed */
10486:../src/wolfcrypt/src/ecc.c ****    mp_int     mu;              /* copy of the montgomery constant */
10487:../src/wolfcrypt/src/ecc.c ****    int        lru_count;       /* amount of times this entry has been used */
10488:../src/wolfcrypt/src/ecc.c ****    int        lock;            /* flag to indicate cache eviction */
10489:../src/wolfcrypt/src/ecc.c ****                                /* permitted (0) or not (1) */
10490:../src/wolfcrypt/src/ecc.c **** } fp_cache_t;
10491:../src/wolfcrypt/src/ecc.c **** 
10492:../src/wolfcrypt/src/ecc.c **** /* if HAVE_THREAD_LS this cache is per thread, no locking needed */
10493:../src/wolfcrypt/src/ecc.c **** static THREAD_LS_T fp_cache_t fp_cache[FP_ENTRIES];
10494:../src/wolfcrypt/src/ecc.c **** 
10495:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
10496:../src/wolfcrypt/src/ecc.c ****     static volatile int initMutex = 0;  /* prevent multiple mutex inits */
10497:../src/wolfcrypt/src/ecc.c ****     static wolfSSL_Mutex ecc_fp_lock;
10498:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_THREAD_LS */
10499:../src/wolfcrypt/src/ecc.c **** 
10500:../src/wolfcrypt/src/ecc.c **** /* simple table to help direct the generation of the LUT */
10501:../src/wolfcrypt/src/ecc.c **** static const struct {
10502:../src/wolfcrypt/src/ecc.c ****    int ham, terma, termb;
10503:../src/wolfcrypt/src/ecc.c **** } lut_orders[] = {
10504:../src/wolfcrypt/src/ecc.c ****    { 0, 0, 0 }, { 1, 0, 0 }, { 1, 0, 0 }, { 2, 1, 2 }, { 1, 0, 0 }, { 2, 1, 4 }, { 2, 2, 4 }, { 3, 
10505:../src/wolfcrypt/src/ecc.c ****    { 1, 0, 0 }, { 2, 1, 8 }, { 2, 2, 8 }, { 3, 3, 8 }, { 2, 4, 8 }, { 3, 5, 8 }, { 3, 6, 8 }, { 4, 
10506:../src/wolfcrypt/src/ecc.c ****    { 1, 0, 0 }, { 2, 1, 16 }, { 2, 2, 16 }, { 3, 3, 16 }, { 2, 4, 16 }, { 3, 5, 16 }, { 3, 6, 16 },
10507:../src/wolfcrypt/src/ecc.c ****    { 2, 8, 16 }, { 3, 9, 16 }, { 3, 10, 16 }, { 4, 11, 16 }, { 3, 12, 16 }, { 4, 13, 16 }, { 4, 14,
10508:../src/wolfcrypt/src/ecc.c ****    { 1, 0, 0 }, { 2, 1, 32 }, { 2, 2, 32 }, { 3, 3, 32 }, { 2, 4, 32 }, { 3, 5, 32 }, { 3, 6, 32 },
10509:../src/wolfcrypt/src/ecc.c ****    { 2, 8, 32 }, { 3, 9, 32 }, { 3, 10, 32 }, { 4, 11, 32 }, { 3, 12, 32 }, { 4, 13, 32 }, { 4, 14,
10510:../src/wolfcrypt/src/ecc.c ****    { 2, 16, 32 }, { 3, 17, 32 }, { 3, 18, 32 }, { 4, 19, 32 }, { 3, 20, 32 }, { 4, 21, 32 }, { 4, 2
10511:../src/wolfcrypt/src/ecc.c ****    { 3, 24, 32 }, { 4, 25, 32 }, { 4, 26, 32 }, { 5, 27, 32 }, { 4, 28, 32 }, { 5, 29, 32 }, { 5, 3
10512:../src/wolfcrypt/src/ecc.c **** #if FP_LUT > 6
10513:../src/wolfcrypt/src/ecc.c ****    { 1, 0, 0 }, { 2, 1, 64 }, { 2, 2, 64 }, { 3, 3, 64 }, { 2, 4, 64 }, { 3, 5, 64 }, { 3, 6, 64 },
10514:../src/wolfcrypt/src/ecc.c ****    { 2, 8, 64 }, { 3, 9, 64 }, { 3, 10, 64 }, { 4, 11, 64 }, { 3, 12, 64 }, { 4, 13, 64 }, { 4, 14,
10515:../src/wolfcrypt/src/ecc.c ****    { 2, 16, 64 }, { 3, 17, 64 }, { 3, 18, 64 }, { 4, 19, 64 }, { 3, 20, 64 }, { 4, 21, 64 }, { 4, 2
10516:../src/wolfcrypt/src/ecc.c ****    { 3, 24, 64 }, { 4, 25, 64 }, { 4, 26, 64 }, { 5, 27, 64 }, { 4, 28, 64 }, { 5, 29, 64 }, { 5, 3
10517:../src/wolfcrypt/src/ecc.c ****    { 2, 32, 64 }, { 3, 33, 64 }, { 3, 34, 64 }, { 4, 35, 64 }, { 3, 36, 64 }, { 4, 37, 64 }, { 4, 3
10518:../src/wolfcrypt/src/ecc.c ****    { 3, 40, 64 }, { 4, 41, 64 }, { 4, 42, 64 }, { 5, 43, 64 }, { 4, 44, 64 }, { 5, 45, 64 }, { 5, 4
10519:../src/wolfcrypt/src/ecc.c ****    { 3, 48, 64 }, { 4, 49, 64 }, { 4, 50, 64 }, { 5, 51, 64 }, { 4, 52, 64 }, { 5, 53, 64 }, { 5, 5
10520:../src/wolfcrypt/src/ecc.c ****    { 4, 56, 64 }, { 5, 57, 64 }, { 5, 58, 64 }, { 6, 59, 64 }, { 5, 60, 64 }, { 6, 61, 64 }, { 6, 6
10521:../src/wolfcrypt/src/ecc.c **** #if FP_LUT > 7
10522:../src/wolfcrypt/src/ecc.c ****    { 1, 0, 0 }, { 2, 1, 128 }, { 2, 2, 128 }, { 3, 3, 128 }, { 2, 4, 128 }, { 3, 5, 128 }, { 3, 6, 
10523:../src/wolfcrypt/src/ecc.c ****    { 2, 8, 128 }, { 3, 9, 128 }, { 3, 10, 128 }, { 4, 11, 128 }, { 3, 12, 128 }, { 4, 13, 128 }, { 
10524:../src/wolfcrypt/src/ecc.c ****    { 2, 16, 128 }, { 3, 17, 128 }, { 3, 18, 128 }, { 4, 19, 128 }, { 3, 20, 128 }, { 4, 21, 128 }, 
10525:../src/wolfcrypt/src/ecc.c ****    { 3, 24, 128 }, { 4, 25, 128 }, { 4, 26, 128 }, { 5, 27, 128 }, { 4, 28, 128 }, { 5, 29, 128 }, 
10526:../src/wolfcrypt/src/ecc.c ****    { 2, 32, 128 }, { 3, 33, 128 }, { 3, 34, 128 }, { 4, 35, 128 }, { 3, 36, 128 }, { 4, 37, 128 }, 
10527:../src/wolfcrypt/src/ecc.c ****    { 3, 40, 128 }, { 4, 41, 128 }, { 4, 42, 128 }, { 5, 43, 128 }, { 4, 44, 128 }, { 5, 45, 128 }, 
10528:../src/wolfcrypt/src/ecc.c ****    { 3, 48, 128 }, { 4, 49, 128 }, { 4, 50, 128 }, { 5, 51, 128 }, { 4, 52, 128 }, { 5, 53, 128 }, 
10529:../src/wolfcrypt/src/ecc.c ****    { 4, 56, 128 }, { 5, 57, 128 }, { 5, 58, 128 }, { 6, 59, 128 }, { 5, 60, 128 }, { 6, 61, 128 }, 
10530:../src/wolfcrypt/src/ecc.c ****    { 2, 64, 128 }, { 3, 65, 128 }, { 3, 66, 128 }, { 4, 67, 128 }, { 3, 68, 128 }, { 4, 69, 128 }, 
10531:../src/wolfcrypt/src/ecc.c ****    { 3, 72, 128 }, { 4, 73, 128 }, { 4, 74, 128 }, { 5, 75, 128 }, { 4, 76, 128 }, { 5, 77, 128 }, 
10532:../src/wolfcrypt/src/ecc.c ****    { 3, 80, 128 }, { 4, 81, 128 }, { 4, 82, 128 }, { 5, 83, 128 }, { 4, 84, 128 }, { 5, 85, 128 }, 
10533:../src/wolfcrypt/src/ecc.c ****    { 4, 88, 128 }, { 5, 89, 128 }, { 5, 90, 128 }, { 6, 91, 128 }, { 5, 92, 128 }, { 6, 93, 128 }, 
10534:../src/wolfcrypt/src/ecc.c ****    { 3, 96, 128 }, { 4, 97, 128 }, { 4, 98, 128 }, { 5, 99, 128 }, { 4, 100, 128 }, { 5, 101, 128 }
10535:../src/wolfcrypt/src/ecc.c ****    { 4, 104, 128 }, { 5, 105, 128 }, { 5, 106, 128 }, { 6, 107, 128 }, { 5, 108, 128 }, { 6, 109, 1
10536:../src/wolfcrypt/src/ecc.c ****    { 4, 112, 128 }, { 5, 113, 128 }, { 5, 114, 128 }, { 6, 115, 128 }, { 5, 116, 128 }, { 6, 117, 1
10537:../src/wolfcrypt/src/ecc.c ****    { 5, 120, 128 }, { 6, 121, 128 }, { 6, 122, 128 }, { 7, 123, 128 }, { 6, 124, 128 }, { 7, 125, 1
10538:../src/wolfcrypt/src/ecc.c **** #if FP_LUT > 8
10539:../src/wolfcrypt/src/ecc.c ****    { 1, 0, 0 }, { 2, 1, 256 }, { 2, 2, 256 }, { 3, 3, 256 }, { 2, 4, 256 }, { 3, 5, 256 }, { 3, 6, 
10540:../src/wolfcrypt/src/ecc.c ****    { 2, 8, 256 }, { 3, 9, 256 }, { 3, 10, 256 }, { 4, 11, 256 }, { 3, 12, 256 }, { 4, 13, 256 }, { 
10541:../src/wolfcrypt/src/ecc.c ****    { 2, 16, 256 }, { 3, 17, 256 }, { 3, 18, 256 }, { 4, 19, 256 }, { 3, 20, 256 }, { 4, 21, 256 }, 
10542:../src/wolfcrypt/src/ecc.c ****    { 3, 24, 256 }, { 4, 25, 256 }, { 4, 26, 256 }, { 5, 27, 256 }, { 4, 28, 256 }, { 5, 29, 256 }, 
10543:../src/wolfcrypt/src/ecc.c ****    { 2, 32, 256 }, { 3, 33, 256 }, { 3, 34, 256 }, { 4, 35, 256 }, { 3, 36, 256 }, { 4, 37, 256 }, 
10544:../src/wolfcrypt/src/ecc.c ****    { 3, 40, 256 }, { 4, 41, 256 }, { 4, 42, 256 }, { 5, 43, 256 }, { 4, 44, 256 }, { 5, 45, 256 }, 
10545:../src/wolfcrypt/src/ecc.c ****    { 3, 48, 256 }, { 4, 49, 256 }, { 4, 50, 256 }, { 5, 51, 256 }, { 4, 52, 256 }, { 5, 53, 256 }, 
10546:../src/wolfcrypt/src/ecc.c ****    { 4, 56, 256 }, { 5, 57, 256 }, { 5, 58, 256 }, { 6, 59, 256 }, { 5, 60, 256 }, { 6, 61, 256 }, 
10547:../src/wolfcrypt/src/ecc.c ****    { 2, 64, 256 }, { 3, 65, 256 }, { 3, 66, 256 }, { 4, 67, 256 }, { 3, 68, 256 }, { 4, 69, 256 }, 
10548:../src/wolfcrypt/src/ecc.c ****    { 3, 72, 256 }, { 4, 73, 256 }, { 4, 74, 256 }, { 5, 75, 256 }, { 4, 76, 256 }, { 5, 77, 256 }, 
10549:../src/wolfcrypt/src/ecc.c ****    { 3, 80, 256 }, { 4, 81, 256 }, { 4, 82, 256 }, { 5, 83, 256 }, { 4, 84, 256 }, { 5, 85, 256 }, 
10550:../src/wolfcrypt/src/ecc.c ****    { 4, 88, 256 }, { 5, 89, 256 }, { 5, 90, 256 }, { 6, 91, 256 }, { 5, 92, 256 }, { 6, 93, 256 }, 
10551:../src/wolfcrypt/src/ecc.c ****    { 3, 96, 256 }, { 4, 97, 256 }, { 4, 98, 256 }, { 5, 99, 256 }, { 4, 100, 256 }, { 5, 101, 256 }
10552:../src/wolfcrypt/src/ecc.c ****    { 4, 104, 256 }, { 5, 105, 256 }, { 5, 106, 256 }, { 6, 107, 256 }, { 5, 108, 256 }, { 6, 109, 2
10553:../src/wolfcrypt/src/ecc.c ****    { 4, 112, 256 }, { 5, 113, 256 }, { 5, 114, 256 }, { 6, 115, 256 }, { 5, 116, 256 }, { 6, 117, 2
10554:../src/wolfcrypt/src/ecc.c ****    { 5, 120, 256 }, { 6, 121, 256 }, { 6, 122, 256 }, { 7, 123, 256 }, { 6, 124, 256 }, { 7, 125, 2
10555:../src/wolfcrypt/src/ecc.c ****    { 2, 128, 256 }, { 3, 129, 256 }, { 3, 130, 256 }, { 4, 131, 256 }, { 3, 132, 256 }, { 4, 133, 2
10556:../src/wolfcrypt/src/ecc.c ****    { 3, 136, 256 }, { 4, 137, 256 }, { 4, 138, 256 }, { 5, 139, 256 }, { 4, 140, 256 }, { 5, 141, 2
10557:../src/wolfcrypt/src/ecc.c ****    { 3, 144, 256 }, { 4, 145, 256 }, { 4, 146, 256 }, { 5, 147, 256 }, { 4, 148, 256 }, { 5, 149, 2
10558:../src/wolfcrypt/src/ecc.c ****    { 4, 152, 256 }, { 5, 153, 256 }, { 5, 154, 256 }, { 6, 155, 256 }, { 5, 156, 256 }, { 6, 157, 2
10559:../src/wolfcrypt/src/ecc.c ****    { 3, 160, 256 }, { 4, 161, 256 }, { 4, 162, 256 }, { 5, 163, 256 }, { 4, 164, 256 }, { 5, 165, 2
10560:../src/wolfcrypt/src/ecc.c ****    { 4, 168, 256 }, { 5, 169, 256 }, { 5, 170, 256 }, { 6, 171, 256 }, { 5, 172, 256 }, { 6, 173, 2
10561:../src/wolfcrypt/src/ecc.c ****    { 4, 176, 256 }, { 5, 177, 256 }, { 5, 178, 256 }, { 6, 179, 256 }, { 5, 180, 256 }, { 6, 181, 2
10562:../src/wolfcrypt/src/ecc.c ****    { 5, 184, 256 }, { 6, 185, 256 }, { 6, 186, 256 }, { 7, 187, 256 }, { 6, 188, 256 }, { 7, 189, 2
10563:../src/wolfcrypt/src/ecc.c ****    { 3, 192, 256 }, { 4, 193, 256 }, { 4, 194, 256 }, { 5, 195, 256 }, { 4, 196, 256 }, { 5, 197, 2
10564:../src/wolfcrypt/src/ecc.c ****    { 4, 200, 256 }, { 5, 201, 256 }, { 5, 202, 256 }, { 6, 203, 256 }, { 5, 204, 256 }, { 6, 205, 2
10565:../src/wolfcrypt/src/ecc.c ****    { 4, 208, 256 }, { 5, 209, 256 }, { 5, 210, 256 }, { 6, 211, 256 }, { 5, 212, 256 }, { 6, 213, 2
10566:../src/wolfcrypt/src/ecc.c ****    { 5, 216, 256 }, { 6, 217, 256 }, { 6, 218, 256 }, { 7, 219, 256 }, { 6, 220, 256 }, { 7, 221, 2
10567:../src/wolfcrypt/src/ecc.c ****    { 4, 224, 256 }, { 5, 225, 256 }, { 5, 226, 256 }, { 6, 227, 256 }, { 5, 228, 256 }, { 6, 229, 2
10568:../src/wolfcrypt/src/ecc.c ****    { 5, 232, 256 }, { 6, 233, 256 }, { 6, 234, 256 }, { 7, 235, 256 }, { 6, 236, 256 }, { 7, 237, 2
10569:../src/wolfcrypt/src/ecc.c ****    { 5, 240, 256 }, { 6, 241, 256 }, { 6, 242, 256 }, { 7, 243, 256 }, { 6, 244, 256 }, { 7, 245, 2
10570:../src/wolfcrypt/src/ecc.c ****    { 6, 248, 256 }, { 7, 249, 256 }, { 7, 250, 256 }, { 8, 251, 256 }, { 7, 252, 256 }, { 8, 253, 2
10571:../src/wolfcrypt/src/ecc.c **** #if FP_LUT > 9
10572:../src/wolfcrypt/src/ecc.c ****    { 1, 0, 0 }, { 2, 1, 512 }, { 2, 2, 512 }, { 3, 3, 512 }, { 2, 4, 512 }, { 3, 5, 512 }, { 3, 6, 
10573:../src/wolfcrypt/src/ecc.c ****    { 2, 8, 512 }, { 3, 9, 512 }, { 3, 10, 512 }, { 4, 11, 512 }, { 3, 12, 512 }, { 4, 13, 512 }, { 
10574:../src/wolfcrypt/src/ecc.c ****    { 2, 16, 512 }, { 3, 17, 512 }, { 3, 18, 512 }, { 4, 19, 512 }, { 3, 20, 512 }, { 4, 21, 512 }, 
10575:../src/wolfcrypt/src/ecc.c ****    { 3, 24, 512 }, { 4, 25, 512 }, { 4, 26, 512 }, { 5, 27, 512 }, { 4, 28, 512 }, { 5, 29, 512 }, 
10576:../src/wolfcrypt/src/ecc.c ****    { 2, 32, 512 }, { 3, 33, 512 }, { 3, 34, 512 }, { 4, 35, 512 }, { 3, 36, 512 }, { 4, 37, 512 }, 
10577:../src/wolfcrypt/src/ecc.c ****    { 3, 40, 512 }, { 4, 41, 512 }, { 4, 42, 512 }, { 5, 43, 512 }, { 4, 44, 512 }, { 5, 45, 512 }, 
10578:../src/wolfcrypt/src/ecc.c ****    { 3, 48, 512 }, { 4, 49, 512 }, { 4, 50, 512 }, { 5, 51, 512 }, { 4, 52, 512 }, { 5, 53, 512 }, 
10579:../src/wolfcrypt/src/ecc.c ****    { 4, 56, 512 }, { 5, 57, 512 }, { 5, 58, 512 }, { 6, 59, 512 }, { 5, 60, 512 }, { 6, 61, 512 }, 
10580:../src/wolfcrypt/src/ecc.c ****    { 2, 64, 512 }, { 3, 65, 512 }, { 3, 66, 512 }, { 4, 67, 512 }, { 3, 68, 512 }, { 4, 69, 512 }, 
10581:../src/wolfcrypt/src/ecc.c ****    { 3, 72, 512 }, { 4, 73, 512 }, { 4, 74, 512 }, { 5, 75, 512 }, { 4, 76, 512 }, { 5, 77, 512 }, 
10582:../src/wolfcrypt/src/ecc.c ****    { 3, 80, 512 }, { 4, 81, 512 }, { 4, 82, 512 }, { 5, 83, 512 }, { 4, 84, 512 }, { 5, 85, 512 }, 
10583:../src/wolfcrypt/src/ecc.c ****    { 4, 88, 512 }, { 5, 89, 512 }, { 5, 90, 512 }, { 6, 91, 512 }, { 5, 92, 512 }, { 6, 93, 512 }, 
10584:../src/wolfcrypt/src/ecc.c ****    { 3, 96, 512 }, { 4, 97, 512 }, { 4, 98, 512 }, { 5, 99, 512 }, { 4, 100, 512 }, { 5, 101, 512 }
10585:../src/wolfcrypt/src/ecc.c ****    { 4, 104, 512 }, { 5, 105, 512 }, { 5, 106, 512 }, { 6, 107, 512 }, { 5, 108, 512 }, { 6, 109, 5
10586:../src/wolfcrypt/src/ecc.c ****    { 4, 112, 512 }, { 5, 113, 512 }, { 5, 114, 512 }, { 6, 115, 512 }, { 5, 116, 512 }, { 6, 117, 5
10587:../src/wolfcrypt/src/ecc.c ****    { 5, 120, 512 }, { 6, 121, 512 }, { 6, 122, 512 }, { 7, 123, 512 }, { 6, 124, 512 }, { 7, 125, 5
10588:../src/wolfcrypt/src/ecc.c ****    { 2, 128, 512 }, { 3, 129, 512 }, { 3, 130, 512 }, { 4, 131, 512 }, { 3, 132, 512 }, { 4, 133, 5
10589:../src/wolfcrypt/src/ecc.c ****    { 3, 136, 512 }, { 4, 137, 512 }, { 4, 138, 512 }, { 5, 139, 512 }, { 4, 140, 512 }, { 5, 141, 5
10590:../src/wolfcrypt/src/ecc.c ****    { 3, 144, 512 }, { 4, 145, 512 }, { 4, 146, 512 }, { 5, 147, 512 }, { 4, 148, 512 }, { 5, 149, 5
10591:../src/wolfcrypt/src/ecc.c ****    { 4, 152, 512 }, { 5, 153, 512 }, { 5, 154, 512 }, { 6, 155, 512 }, { 5, 156, 512 }, { 6, 157, 5
10592:../src/wolfcrypt/src/ecc.c ****    { 3, 160, 512 }, { 4, 161, 512 }, { 4, 162, 512 }, { 5, 163, 512 }, { 4, 164, 512 }, { 5, 165, 5
10593:../src/wolfcrypt/src/ecc.c ****    { 4, 168, 512 }, { 5, 169, 512 }, { 5, 170, 512 }, { 6, 171, 512 }, { 5, 172, 512 }, { 6, 173, 5
10594:../src/wolfcrypt/src/ecc.c ****    { 4, 176, 512 }, { 5, 177, 512 }, { 5, 178, 512 }, { 6, 179, 512 }, { 5, 180, 512 }, { 6, 181, 5
10595:../src/wolfcrypt/src/ecc.c ****    { 5, 184, 512 }, { 6, 185, 512 }, { 6, 186, 512 }, { 7, 187, 512 }, { 6, 188, 512 }, { 7, 189, 5
10596:../src/wolfcrypt/src/ecc.c ****    { 3, 192, 512 }, { 4, 193, 512 }, { 4, 194, 512 }, { 5, 195, 512 }, { 4, 196, 512 }, { 5, 197, 5
10597:../src/wolfcrypt/src/ecc.c ****    { 4, 200, 512 }, { 5, 201, 512 }, { 5, 202, 512 }, { 6, 203, 512 }, { 5, 204, 512 }, { 6, 205, 5
10598:../src/wolfcrypt/src/ecc.c ****    { 4, 208, 512 }, { 5, 209, 512 }, { 5, 210, 512 }, { 6, 211, 512 }, { 5, 212, 512 }, { 6, 213, 5
10599:../src/wolfcrypt/src/ecc.c ****    { 5, 216, 512 }, { 6, 217, 512 }, { 6, 218, 512 }, { 7, 219, 512 }, { 6, 220, 512 }, { 7, 221, 5
10600:../src/wolfcrypt/src/ecc.c ****    { 4, 224, 512 }, { 5, 225, 512 }, { 5, 226, 512 }, { 6, 227, 512 }, { 5, 228, 512 }, { 6, 229, 5
10601:../src/wolfcrypt/src/ecc.c ****    { 5, 232, 512 }, { 6, 233, 512 }, { 6, 234, 512 }, { 7, 235, 512 }, { 6, 236, 512 }, { 7, 237, 5
10602:../src/wolfcrypt/src/ecc.c ****    { 5, 240, 512 }, { 6, 241, 512 }, { 6, 242, 512 }, { 7, 243, 512 }, { 6, 244, 512 }, { 7, 245, 5
10603:../src/wolfcrypt/src/ecc.c ****    { 6, 248, 512 }, { 7, 249, 512 }, { 7, 250, 512 }, { 8, 251, 512 }, { 7, 252, 512 }, { 8, 253, 5
10604:../src/wolfcrypt/src/ecc.c ****    { 2, 256, 512 }, { 3, 257, 512 }, { 3, 258, 512 }, { 4, 259, 512 }, { 3, 260, 512 }, { 4, 261, 5
10605:../src/wolfcrypt/src/ecc.c ****    { 3, 264, 512 }, { 4, 265, 512 }, { 4, 266, 512 }, { 5, 267, 512 }, { 4, 268, 512 }, { 5, 269, 5
10606:../src/wolfcrypt/src/ecc.c ****    { 3, 272, 512 }, { 4, 273, 512 }, { 4, 274, 512 }, { 5, 275, 512 }, { 4, 276, 512 }, { 5, 277, 5
10607:../src/wolfcrypt/src/ecc.c ****    { 4, 280, 512 }, { 5, 281, 512 }, { 5, 282, 512 }, { 6, 283, 512 }, { 5, 284, 512 }, { 6, 285, 5
10608:../src/wolfcrypt/src/ecc.c ****    { 3, 288, 512 }, { 4, 289, 512 }, { 4, 290, 512 }, { 5, 291, 512 }, { 4, 292, 512 }, { 5, 293, 5
10609:../src/wolfcrypt/src/ecc.c ****    { 4, 296, 512 }, { 5, 297, 512 }, { 5, 298, 512 }, { 6, 299, 512 }, { 5, 300, 512 }, { 6, 301, 5
10610:../src/wolfcrypt/src/ecc.c ****    { 4, 304, 512 }, { 5, 305, 512 }, { 5, 306, 512 }, { 6, 307, 512 }, { 5, 308, 512 }, { 6, 309, 5
10611:../src/wolfcrypt/src/ecc.c ****    { 5, 312, 512 }, { 6, 313, 512 }, { 6, 314, 512 }, { 7, 315, 512 }, { 6, 316, 512 }, { 7, 317, 5
10612:../src/wolfcrypt/src/ecc.c ****    { 3, 320, 512 }, { 4, 321, 512 }, { 4, 322, 512 }, { 5, 323, 512 }, { 4, 324, 512 }, { 5, 325, 5
10613:../src/wolfcrypt/src/ecc.c ****    { 4, 328, 512 }, { 5, 329, 512 }, { 5, 330, 512 }, { 6, 331, 512 }, { 5, 332, 512 }, { 6, 333, 5
10614:../src/wolfcrypt/src/ecc.c ****    { 4, 336, 512 }, { 5, 337, 512 }, { 5, 338, 512 }, { 6, 339, 512 }, { 5, 340, 512 }, { 6, 341, 5
10615:../src/wolfcrypt/src/ecc.c ****    { 5, 344, 512 }, { 6, 345, 512 }, { 6, 346, 512 }, { 7, 347, 512 }, { 6, 348, 512 }, { 7, 349, 5
10616:../src/wolfcrypt/src/ecc.c ****    { 4, 352, 512 }, { 5, 353, 512 }, { 5, 354, 512 }, { 6, 355, 512 }, { 5, 356, 512 }, { 6, 357, 5
10617:../src/wolfcrypt/src/ecc.c ****    { 5, 360, 512 }, { 6, 361, 512 }, { 6, 362, 512 }, { 7, 363, 512 }, { 6, 364, 512 }, { 7, 365, 5
10618:../src/wolfcrypt/src/ecc.c ****    { 5, 368, 512 }, { 6, 369, 512 }, { 6, 370, 512 }, { 7, 371, 512 }, { 6, 372, 512 }, { 7, 373, 5
10619:../src/wolfcrypt/src/ecc.c ****    { 6, 376, 512 }, { 7, 377, 512 }, { 7, 378, 512 }, { 8, 379, 512 }, { 7, 380, 512 }, { 8, 381, 5
10620:../src/wolfcrypt/src/ecc.c ****    { 3, 384, 512 }, { 4, 385, 512 }, { 4, 386, 512 }, { 5, 387, 512 }, { 4, 388, 512 }, { 5, 389, 5
10621:../src/wolfcrypt/src/ecc.c ****    { 4, 392, 512 }, { 5, 393, 512 }, { 5, 394, 512 }, { 6, 395, 512 }, { 5, 396, 512 }, { 6, 397, 5
10622:../src/wolfcrypt/src/ecc.c ****    { 4, 400, 512 }, { 5, 401, 512 }, { 5, 402, 512 }, { 6, 403, 512 }, { 5, 404, 512 }, { 6, 405, 5
10623:../src/wolfcrypt/src/ecc.c ****    { 5, 408, 512 }, { 6, 409, 512 }, { 6, 410, 512 }, { 7, 411, 512 }, { 6, 412, 512 }, { 7, 413, 5
10624:../src/wolfcrypt/src/ecc.c ****    { 4, 416, 512 }, { 5, 417, 512 }, { 5, 418, 512 }, { 6, 419, 512 }, { 5, 420, 512 }, { 6, 421, 5
10625:../src/wolfcrypt/src/ecc.c ****    { 5, 424, 512 }, { 6, 425, 512 }, { 6, 426, 512 }, { 7, 427, 512 }, { 6, 428, 512 }, { 7, 429, 5
10626:../src/wolfcrypt/src/ecc.c ****    { 5, 432, 512 }, { 6, 433, 512 }, { 6, 434, 512 }, { 7, 435, 512 }, { 6, 436, 512 }, { 7, 437, 5
10627:../src/wolfcrypt/src/ecc.c ****    { 6, 440, 512 }, { 7, 441, 512 }, { 7, 442, 512 }, { 8, 443, 512 }, { 7, 444, 512 }, { 8, 445, 5
10628:../src/wolfcrypt/src/ecc.c ****    { 4, 448, 512 }, { 5, 449, 512 }, { 5, 450, 512 }, { 6, 451, 512 }, { 5, 452, 512 }, { 6, 453, 5
10629:../src/wolfcrypt/src/ecc.c ****    { 5, 456, 512 }, { 6, 457, 512 }, { 6, 458, 512 }, { 7, 459, 512 }, { 6, 460, 512 }, { 7, 461, 5
10630:../src/wolfcrypt/src/ecc.c ****    { 5, 464, 512 }, { 6, 465, 512 }, { 6, 466, 512 }, { 7, 467, 512 }, { 6, 468, 512 }, { 7, 469, 5
10631:../src/wolfcrypt/src/ecc.c ****    { 6, 472, 512 }, { 7, 473, 512 }, { 7, 474, 512 }, { 8, 475, 512 }, { 7, 476, 512 }, { 8, 477, 5
10632:../src/wolfcrypt/src/ecc.c ****    { 5, 480, 512 }, { 6, 481, 512 }, { 6, 482, 512 }, { 7, 483, 512 }, { 6, 484, 512 }, { 7, 485, 5
10633:../src/wolfcrypt/src/ecc.c ****    { 6, 488, 512 }, { 7, 489, 512 }, { 7, 490, 512 }, { 8, 491, 512 }, { 7, 492, 512 }, { 8, 493, 5
10634:../src/wolfcrypt/src/ecc.c ****    { 6, 496, 512 }, { 7, 497, 512 }, { 7, 498, 512 }, { 8, 499, 512 }, { 7, 500, 512 }, { 8, 501, 5
10635:../src/wolfcrypt/src/ecc.c ****    { 7, 504, 512 }, { 8, 505, 512 }, { 8, 506, 512 }, { 9, 507, 512 }, { 8, 508, 512 }, { 9, 509, 5
10636:../src/wolfcrypt/src/ecc.c **** #if FP_LUT > 10
10637:../src/wolfcrypt/src/ecc.c ****    { 1, 0, 0 }, { 2, 1, 1024 }, { 2, 2, 1024 }, { 3, 3, 1024 }, { 2, 4, 1024 }, { 3, 5, 1024 }, { 3
10638:../src/wolfcrypt/src/ecc.c ****    { 2, 8, 1024 }, { 3, 9, 1024 }, { 3, 10, 1024 }, { 4, 11, 1024 }, { 3, 12, 1024 }, { 4, 13, 1024
10639:../src/wolfcrypt/src/ecc.c ****    { 2, 16, 1024 }, { 3, 17, 1024 }, { 3, 18, 1024 }, { 4, 19, 1024 }, { 3, 20, 1024 }, { 4, 21, 10
10640:../src/wolfcrypt/src/ecc.c ****    { 3, 24, 1024 }, { 4, 25, 1024 }, { 4, 26, 1024 }, { 5, 27, 1024 }, { 4, 28, 1024 }, { 5, 29, 10
10641:../src/wolfcrypt/src/ecc.c ****    { 2, 32, 1024 }, { 3, 33, 1024 }, { 3, 34, 1024 }, { 4, 35, 1024 }, { 3, 36, 1024 }, { 4, 37, 10
10642:../src/wolfcrypt/src/ecc.c ****    { 3, 40, 1024 }, { 4, 41, 1024 }, { 4, 42, 1024 }, { 5, 43, 1024 }, { 4, 44, 1024 }, { 5, 45, 10
10643:../src/wolfcrypt/src/ecc.c ****    { 3, 48, 1024 }, { 4, 49, 1024 }, { 4, 50, 1024 }, { 5, 51, 1024 }, { 4, 52, 1024 }, { 5, 53, 10
10644:../src/wolfcrypt/src/ecc.c ****    { 4, 56, 1024 }, { 5, 57, 1024 }, { 5, 58, 1024 }, { 6, 59, 1024 }, { 5, 60, 1024 }, { 6, 61, 10
10645:../src/wolfcrypt/src/ecc.c ****    { 2, 64, 1024 }, { 3, 65, 1024 }, { 3, 66, 1024 }, { 4, 67, 1024 }, { 3, 68, 1024 }, { 4, 69, 10
10646:../src/wolfcrypt/src/ecc.c ****    { 3, 72, 1024 }, { 4, 73, 1024 }, { 4, 74, 1024 }, { 5, 75, 1024 }, { 4, 76, 1024 }, { 5, 77, 10
10647:../src/wolfcrypt/src/ecc.c ****    { 3, 80, 1024 }, { 4, 81, 1024 }, { 4, 82, 1024 }, { 5, 83, 1024 }, { 4, 84, 1024 }, { 5, 85, 10
10648:../src/wolfcrypt/src/ecc.c ****    { 4, 88, 1024 }, { 5, 89, 1024 }, { 5, 90, 1024 }, { 6, 91, 1024 }, { 5, 92, 1024 }, { 6, 93, 10
10649:../src/wolfcrypt/src/ecc.c ****    { 3, 96, 1024 }, { 4, 97, 1024 }, { 4, 98, 1024 }, { 5, 99, 1024 }, { 4, 100, 1024 }, { 5, 101, 
10650:../src/wolfcrypt/src/ecc.c ****    { 4, 104, 1024 }, { 5, 105, 1024 }, { 5, 106, 1024 }, { 6, 107, 1024 }, { 5, 108, 1024 }, { 6, 1
10651:../src/wolfcrypt/src/ecc.c ****    { 4, 112, 1024 }, { 5, 113, 1024 }, { 5, 114, 1024 }, { 6, 115, 1024 }, { 5, 116, 1024 }, { 6, 1
10652:../src/wolfcrypt/src/ecc.c ****    { 5, 120, 1024 }, { 6, 121, 1024 }, { 6, 122, 1024 }, { 7, 123, 1024 }, { 6, 124, 1024 }, { 7, 1
10653:../src/wolfcrypt/src/ecc.c ****    { 2, 128, 1024 }, { 3, 129, 1024 }, { 3, 130, 1024 }, { 4, 131, 1024 }, { 3, 132, 1024 }, { 4, 1
10654:../src/wolfcrypt/src/ecc.c ****    { 3, 136, 1024 }, { 4, 137, 1024 }, { 4, 138, 1024 }, { 5, 139, 1024 }, { 4, 140, 1024 }, { 5, 1
10655:../src/wolfcrypt/src/ecc.c ****    { 3, 144, 1024 }, { 4, 145, 1024 }, { 4, 146, 1024 }, { 5, 147, 1024 }, { 4, 148, 1024 }, { 5, 1
10656:../src/wolfcrypt/src/ecc.c ****    { 4, 152, 1024 }, { 5, 153, 1024 }, { 5, 154, 1024 }, { 6, 155, 1024 }, { 5, 156, 1024 }, { 6, 1
10657:../src/wolfcrypt/src/ecc.c ****    { 3, 160, 1024 }, { 4, 161, 1024 }, { 4, 162, 1024 }, { 5, 163, 1024 }, { 4, 164, 1024 }, { 5, 1
10658:../src/wolfcrypt/src/ecc.c ****    { 4, 168, 1024 }, { 5, 169, 1024 }, { 5, 170, 1024 }, { 6, 171, 1024 }, { 5, 172, 1024 }, { 6, 1
10659:../src/wolfcrypt/src/ecc.c ****    { 4, 176, 1024 }, { 5, 177, 1024 }, { 5, 178, 1024 }, { 6, 179, 1024 }, { 5, 180, 1024 }, { 6, 1
10660:../src/wolfcrypt/src/ecc.c ****    { 5, 184, 1024 }, { 6, 185, 1024 }, { 6, 186, 1024 }, { 7, 187, 1024 }, { 6, 188, 1024 }, { 7, 1
10661:../src/wolfcrypt/src/ecc.c ****    { 3, 192, 1024 }, { 4, 193, 1024 }, { 4, 194, 1024 }, { 5, 195, 1024 }, { 4, 196, 1024 }, { 5, 1
10662:../src/wolfcrypt/src/ecc.c ****    { 4, 200, 1024 }, { 5, 201, 1024 }, { 5, 202, 1024 }, { 6, 203, 1024 }, { 5, 204, 1024 }, { 6, 2
10663:../src/wolfcrypt/src/ecc.c ****    { 4, 208, 1024 }, { 5, 209, 1024 }, { 5, 210, 1024 }, { 6, 211, 1024 }, { 5, 212, 1024 }, { 6, 2
10664:../src/wolfcrypt/src/ecc.c ****    { 5, 216, 1024 }, { 6, 217, 1024 }, { 6, 218, 1024 }, { 7, 219, 1024 }, { 6, 220, 1024 }, { 7, 2
10665:../src/wolfcrypt/src/ecc.c ****    { 4, 224, 1024 }, { 5, 225, 1024 }, { 5, 226, 1024 }, { 6, 227, 1024 }, { 5, 228, 1024 }, { 6, 2
10666:../src/wolfcrypt/src/ecc.c ****    { 5, 232, 1024 }, { 6, 233, 1024 }, { 6, 234, 1024 }, { 7, 235, 1024 }, { 6, 236, 1024 }, { 7, 2
10667:../src/wolfcrypt/src/ecc.c ****    { 5, 240, 1024 }, { 6, 241, 1024 }, { 6, 242, 1024 }, { 7, 243, 1024 }, { 6, 244, 1024 }, { 7, 2
10668:../src/wolfcrypt/src/ecc.c ****    { 6, 248, 1024 }, { 7, 249, 1024 }, { 7, 250, 1024 }, { 8, 251, 1024 }, { 7, 252, 1024 }, { 8, 2
10669:../src/wolfcrypt/src/ecc.c ****    { 2, 256, 1024 }, { 3, 257, 1024 }, { 3, 258, 1024 }, { 4, 259, 1024 }, { 3, 260, 1024 }, { 4, 2
10670:../src/wolfcrypt/src/ecc.c ****    { 3, 264, 1024 }, { 4, 265, 1024 }, { 4, 266, 1024 }, { 5, 267, 1024 }, { 4, 268, 1024 }, { 5, 2
10671:../src/wolfcrypt/src/ecc.c ****    { 3, 272, 1024 }, { 4, 273, 1024 }, { 4, 274, 1024 }, { 5, 275, 1024 }, { 4, 276, 1024 }, { 5, 2
10672:../src/wolfcrypt/src/ecc.c ****    { 4, 280, 1024 }, { 5, 281, 1024 }, { 5, 282, 1024 }, { 6, 283, 1024 }, { 5, 284, 1024 }, { 6, 2
10673:../src/wolfcrypt/src/ecc.c ****    { 3, 288, 1024 }, { 4, 289, 1024 }, { 4, 290, 1024 }, { 5, 291, 1024 }, { 4, 292, 1024 }, { 5, 2
10674:../src/wolfcrypt/src/ecc.c ****    { 4, 296, 1024 }, { 5, 297, 1024 }, { 5, 298, 1024 }, { 6, 299, 1024 }, { 5, 300, 1024 }, { 6, 3
10675:../src/wolfcrypt/src/ecc.c ****    { 4, 304, 1024 }, { 5, 305, 1024 }, { 5, 306, 1024 }, { 6, 307, 1024 }, { 5, 308, 1024 }, { 6, 3
10676:../src/wolfcrypt/src/ecc.c ****    { 5, 312, 1024 }, { 6, 313, 1024 }, { 6, 314, 1024 }, { 7, 315, 1024 }, { 6, 316, 1024 }, { 7, 3
10677:../src/wolfcrypt/src/ecc.c ****    { 3, 320, 1024 }, { 4, 321, 1024 }, { 4, 322, 1024 }, { 5, 323, 1024 }, { 4, 324, 1024 }, { 5, 3
10678:../src/wolfcrypt/src/ecc.c ****    { 4, 328, 1024 }, { 5, 329, 1024 }, { 5, 330, 1024 }, { 6, 331, 1024 }, { 5, 332, 1024 }, { 6, 3
10679:../src/wolfcrypt/src/ecc.c ****    { 4, 336, 1024 }, { 5, 337, 1024 }, { 5, 338, 1024 }, { 6, 339, 1024 }, { 5, 340, 1024 }, { 6, 3
10680:../src/wolfcrypt/src/ecc.c ****    { 5, 344, 1024 }, { 6, 345, 1024 }, { 6, 346, 1024 }, { 7, 347, 1024 }, { 6, 348, 1024 }, { 7, 3
10681:../src/wolfcrypt/src/ecc.c ****    { 4, 352, 1024 }, { 5, 353, 1024 }, { 5, 354, 1024 }, { 6, 355, 1024 }, { 5, 356, 1024 }, { 6, 3
10682:../src/wolfcrypt/src/ecc.c ****    { 5, 360, 1024 }, { 6, 361, 1024 }, { 6, 362, 1024 }, { 7, 363, 1024 }, { 6, 364, 1024 }, { 7, 3
10683:../src/wolfcrypt/src/ecc.c ****    { 5, 368, 1024 }, { 6, 369, 1024 }, { 6, 370, 1024 }, { 7, 371, 1024 }, { 6, 372, 1024 }, { 7, 3
10684:../src/wolfcrypt/src/ecc.c ****    { 6, 376, 1024 }, { 7, 377, 1024 }, { 7, 378, 1024 }, { 8, 379, 1024 }, { 7, 380, 1024 }, { 8, 3
10685:../src/wolfcrypt/src/ecc.c ****    { 3, 384, 1024 }, { 4, 385, 1024 }, { 4, 386, 1024 }, { 5, 387, 1024 }, { 4, 388, 1024 }, { 5, 3
10686:../src/wolfcrypt/src/ecc.c ****    { 4, 392, 1024 }, { 5, 393, 1024 }, { 5, 394, 1024 }, { 6, 395, 1024 }, { 5, 396, 1024 }, { 6, 3
10687:../src/wolfcrypt/src/ecc.c ****    { 4, 400, 1024 }, { 5, 401, 1024 }, { 5, 402, 1024 }, { 6, 403, 1024 }, { 5, 404, 1024 }, { 6, 4
10688:../src/wolfcrypt/src/ecc.c ****    { 5, 408, 1024 }, { 6, 409, 1024 }, { 6, 410, 1024 }, { 7, 411, 1024 }, { 6, 412, 1024 }, { 7, 4
10689:../src/wolfcrypt/src/ecc.c ****    { 4, 416, 1024 }, { 5, 417, 1024 }, { 5, 418, 1024 }, { 6, 419, 1024 }, { 5, 420, 1024 }, { 6, 4
10690:../src/wolfcrypt/src/ecc.c ****    { 5, 424, 1024 }, { 6, 425, 1024 }, { 6, 426, 1024 }, { 7, 427, 1024 }, { 6, 428, 1024 }, { 7, 4
10691:../src/wolfcrypt/src/ecc.c ****    { 5, 432, 1024 }, { 6, 433, 1024 }, { 6, 434, 1024 }, { 7, 435, 1024 }, { 6, 436, 1024 }, { 7, 4
10692:../src/wolfcrypt/src/ecc.c ****    { 6, 440, 1024 }, { 7, 441, 1024 }, { 7, 442, 1024 }, { 8, 443, 1024 }, { 7, 444, 1024 }, { 8, 4
10693:../src/wolfcrypt/src/ecc.c ****    { 4, 448, 1024 }, { 5, 449, 1024 }, { 5, 450, 1024 }, { 6, 451, 1024 }, { 5, 452, 1024 }, { 6, 4
10694:../src/wolfcrypt/src/ecc.c ****    { 5, 456, 1024 }, { 6, 457, 1024 }, { 6, 458, 1024 }, { 7, 459, 1024 }, { 6, 460, 1024 }, { 7, 4
10695:../src/wolfcrypt/src/ecc.c ****    { 5, 464, 1024 }, { 6, 465, 1024 }, { 6, 466, 1024 }, { 7, 467, 1024 }, { 6, 468, 1024 }, { 7, 4
10696:../src/wolfcrypt/src/ecc.c ****    { 6, 472, 1024 }, { 7, 473, 1024 }, { 7, 474, 1024 }, { 8, 475, 1024 }, { 7, 476, 1024 }, { 8, 4
10697:../src/wolfcrypt/src/ecc.c ****    { 5, 480, 1024 }, { 6, 481, 1024 }, { 6, 482, 1024 }, { 7, 483, 1024 }, { 6, 484, 1024 }, { 7, 4
10698:../src/wolfcrypt/src/ecc.c ****    { 6, 488, 1024 }, { 7, 489, 1024 }, { 7, 490, 1024 }, { 8, 491, 1024 }, { 7, 492, 1024 }, { 8, 4
10699:../src/wolfcrypt/src/ecc.c ****    { 6, 496, 1024 }, { 7, 497, 1024 }, { 7, 498, 1024 }, { 8, 499, 1024 }, { 7, 500, 1024 }, { 8, 5
10700:../src/wolfcrypt/src/ecc.c ****    { 7, 504, 1024 }, { 8, 505, 1024 }, { 8, 506, 1024 }, { 9, 507, 1024 }, { 8, 508, 1024 }, { 9, 5
10701:../src/wolfcrypt/src/ecc.c ****    { 2, 512, 1024 }, { 3, 513, 1024 }, { 3, 514, 1024 }, { 4, 515, 1024 }, { 3, 516, 1024 }, { 4, 5
10702:../src/wolfcrypt/src/ecc.c ****    { 3, 520, 1024 }, { 4, 521, 1024 }, { 4, 522, 1024 }, { 5, 523, 1024 }, { 4, 524, 1024 }, { 5, 5
10703:../src/wolfcrypt/src/ecc.c ****    { 3, 528, 1024 }, { 4, 529, 1024 }, { 4, 530, 1024 }, { 5, 531, 1024 }, { 4, 532, 1024 }, { 5, 5
10704:../src/wolfcrypt/src/ecc.c ****    { 4, 536, 1024 }, { 5, 537, 1024 }, { 5, 538, 1024 }, { 6, 539, 1024 }, { 5, 540, 1024 }, { 6, 5
10705:../src/wolfcrypt/src/ecc.c ****    { 3, 544, 1024 }, { 4, 545, 1024 }, { 4, 546, 1024 }, { 5, 547, 1024 }, { 4, 548, 1024 }, { 5, 5
10706:../src/wolfcrypt/src/ecc.c ****    { 4, 552, 1024 }, { 5, 553, 1024 }, { 5, 554, 1024 }, { 6, 555, 1024 }, { 5, 556, 1024 }, { 6, 5
10707:../src/wolfcrypt/src/ecc.c ****    { 4, 560, 1024 }, { 5, 561, 1024 }, { 5, 562, 1024 }, { 6, 563, 1024 }, { 5, 564, 1024 }, { 6, 5
10708:../src/wolfcrypt/src/ecc.c ****    { 5, 568, 1024 }, { 6, 569, 1024 }, { 6, 570, 1024 }, { 7, 571, 1024 }, { 6, 572, 1024 }, { 7, 5
10709:../src/wolfcrypt/src/ecc.c ****    { 3, 576, 1024 }, { 4, 577, 1024 }, { 4, 578, 1024 }, { 5, 579, 1024 }, { 4, 580, 1024 }, { 5, 5
10710:../src/wolfcrypt/src/ecc.c ****    { 4, 584, 1024 }, { 5, 585, 1024 }, { 5, 586, 1024 }, { 6, 587, 1024 }, { 5, 588, 1024 }, { 6, 5
10711:../src/wolfcrypt/src/ecc.c ****    { 4, 592, 1024 }, { 5, 593, 1024 }, { 5, 594, 1024 }, { 6, 595, 1024 }, { 5, 596, 1024 }, { 6, 5
10712:../src/wolfcrypt/src/ecc.c ****    { 5, 600, 1024 }, { 6, 601, 1024 }, { 6, 602, 1024 }, { 7, 603, 1024 }, { 6, 604, 1024 }, { 7, 6
10713:../src/wolfcrypt/src/ecc.c ****    { 4, 608, 1024 }, { 5, 609, 1024 }, { 5, 610, 1024 }, { 6, 611, 1024 }, { 5, 612, 1024 }, { 6, 6
10714:../src/wolfcrypt/src/ecc.c ****    { 5, 616, 1024 }, { 6, 617, 1024 }, { 6, 618, 1024 }, { 7, 619, 1024 }, { 6, 620, 1024 }, { 7, 6
10715:../src/wolfcrypt/src/ecc.c ****    { 5, 624, 1024 }, { 6, 625, 1024 }, { 6, 626, 1024 }, { 7, 627, 1024 }, { 6, 628, 1024 }, { 7, 6
10716:../src/wolfcrypt/src/ecc.c ****    { 6, 632, 1024 }, { 7, 633, 1024 }, { 7, 634, 1024 }, { 8, 635, 1024 }, { 7, 636, 1024 }, { 8, 6
10717:../src/wolfcrypt/src/ecc.c ****    { 3, 640, 1024 }, { 4, 641, 1024 }, { 4, 642, 1024 }, { 5, 643, 1024 }, { 4, 644, 1024 }, { 5, 6
10718:../src/wolfcrypt/src/ecc.c ****    { 4, 648, 1024 }, { 5, 649, 1024 }, { 5, 650, 1024 }, { 6, 651, 1024 }, { 5, 652, 1024 }, { 6, 6
10719:../src/wolfcrypt/src/ecc.c ****    { 4, 656, 1024 }, { 5, 657, 1024 }, { 5, 658, 1024 }, { 6, 659, 1024 }, { 5, 660, 1024 }, { 6, 6
10720:../src/wolfcrypt/src/ecc.c ****    { 5, 664, 1024 }, { 6, 665, 1024 }, { 6, 666, 1024 }, { 7, 667, 1024 }, { 6, 668, 1024 }, { 7, 6
10721:../src/wolfcrypt/src/ecc.c ****    { 4, 672, 1024 }, { 5, 673, 1024 }, { 5, 674, 1024 }, { 6, 675, 1024 }, { 5, 676, 1024 }, { 6, 6
10722:../src/wolfcrypt/src/ecc.c ****    { 5, 680, 1024 }, { 6, 681, 1024 }, { 6, 682, 1024 }, { 7, 683, 1024 }, { 6, 684, 1024 }, { 7, 6
10723:../src/wolfcrypt/src/ecc.c ****    { 5, 688, 1024 }, { 6, 689, 1024 }, { 6, 690, 1024 }, { 7, 691, 1024 }, { 6, 692, 1024 }, { 7, 6
10724:../src/wolfcrypt/src/ecc.c ****    { 6, 696, 1024 }, { 7, 697, 1024 }, { 7, 698, 1024 }, { 8, 699, 1024 }, { 7, 700, 1024 }, { 8, 7
10725:../src/wolfcrypt/src/ecc.c ****    { 4, 704, 1024 }, { 5, 705, 1024 }, { 5, 706, 1024 }, { 6, 707, 1024 }, { 5, 708, 1024 }, { 6, 7
10726:../src/wolfcrypt/src/ecc.c ****    { 5, 712, 1024 }, { 6, 713, 1024 }, { 6, 714, 1024 }, { 7, 715, 1024 }, { 6, 716, 1024 }, { 7, 7
10727:../src/wolfcrypt/src/ecc.c ****    { 5, 720, 1024 }, { 6, 721, 1024 }, { 6, 722, 1024 }, { 7, 723, 1024 }, { 6, 724, 1024 }, { 7, 7
10728:../src/wolfcrypt/src/ecc.c ****    { 6, 728, 1024 }, { 7, 729, 1024 }, { 7, 730, 1024 }, { 8, 731, 1024 }, { 7, 732, 1024 }, { 8, 7
10729:../src/wolfcrypt/src/ecc.c ****    { 5, 736, 1024 }, { 6, 737, 1024 }, { 6, 738, 1024 }, { 7, 739, 1024 }, { 6, 740, 1024 }, { 7, 7
10730:../src/wolfcrypt/src/ecc.c ****    { 6, 744, 1024 }, { 7, 745, 1024 }, { 7, 746, 1024 }, { 8, 747, 1024 }, { 7, 748, 1024 }, { 8, 7
10731:../src/wolfcrypt/src/ecc.c ****    { 6, 752, 1024 }, { 7, 753, 1024 }, { 7, 754, 1024 }, { 8, 755, 1024 }, { 7, 756, 1024 }, { 8, 7
10732:../src/wolfcrypt/src/ecc.c ****    { 7, 760, 1024 }, { 8, 761, 1024 }, { 8, 762, 1024 }, { 9, 763, 1024 }, { 8, 764, 1024 }, { 9, 7
10733:../src/wolfcrypt/src/ecc.c ****    { 3, 768, 1024 }, { 4, 769, 1024 }, { 4, 770, 1024 }, { 5, 771, 1024 }, { 4, 772, 1024 }, { 5, 7
10734:../src/wolfcrypt/src/ecc.c ****    { 4, 776, 1024 }, { 5, 777, 1024 }, { 5, 778, 1024 }, { 6, 779, 1024 }, { 5, 780, 1024 }, { 6, 7
10735:../src/wolfcrypt/src/ecc.c ****    { 4, 784, 1024 }, { 5, 785, 1024 }, { 5, 786, 1024 }, { 6, 787, 1024 }, { 5, 788, 1024 }, { 6, 7
10736:../src/wolfcrypt/src/ecc.c ****    { 5, 792, 1024 }, { 6, 793, 1024 }, { 6, 794, 1024 }, { 7, 795, 1024 }, { 6, 796, 1024 }, { 7, 7
10737:../src/wolfcrypt/src/ecc.c ****    { 4, 800, 1024 }, { 5, 801, 1024 }, { 5, 802, 1024 }, { 6, 803, 1024 }, { 5, 804, 1024 }, { 6, 8
10738:../src/wolfcrypt/src/ecc.c ****    { 5, 808, 1024 }, { 6, 809, 1024 }, { 6, 810, 1024 }, { 7, 811, 1024 }, { 6, 812, 1024 }, { 7, 8
10739:../src/wolfcrypt/src/ecc.c ****    { 5, 816, 1024 }, { 6, 817, 1024 }, { 6, 818, 1024 }, { 7, 819, 1024 }, { 6, 820, 1024 }, { 7, 8
10740:../src/wolfcrypt/src/ecc.c ****    { 6, 824, 1024 }, { 7, 825, 1024 }, { 7, 826, 1024 }, { 8, 827, 1024 }, { 7, 828, 1024 }, { 8, 8
10741:../src/wolfcrypt/src/ecc.c ****    { 4, 832, 1024 }, { 5, 833, 1024 }, { 5, 834, 1024 }, { 6, 835, 1024 }, { 5, 836, 1024 }, { 6, 8
10742:../src/wolfcrypt/src/ecc.c ****    { 5, 840, 1024 }, { 6, 841, 1024 }, { 6, 842, 1024 }, { 7, 843, 1024 }, { 6, 844, 1024 }, { 7, 8
10743:../src/wolfcrypt/src/ecc.c ****    { 5, 848, 1024 }, { 6, 849, 1024 }, { 6, 850, 1024 }, { 7, 851, 1024 }, { 6, 852, 1024 }, { 7, 8
10744:../src/wolfcrypt/src/ecc.c ****    { 6, 856, 1024 }, { 7, 857, 1024 }, { 7, 858, 1024 }, { 8, 859, 1024 }, { 7, 860, 1024 }, { 8, 8
10745:../src/wolfcrypt/src/ecc.c ****    { 5, 864, 1024 }, { 6, 865, 1024 }, { 6, 866, 1024 }, { 7, 867, 1024 }, { 6, 868, 1024 }, { 7, 8
10746:../src/wolfcrypt/src/ecc.c ****    { 6, 872, 1024 }, { 7, 873, 1024 }, { 7, 874, 1024 }, { 8, 875, 1024 }, { 7, 876, 1024 }, { 8, 8
10747:../src/wolfcrypt/src/ecc.c ****    { 6, 880, 1024 }, { 7, 881, 1024 }, { 7, 882, 1024 }, { 8, 883, 1024 }, { 7, 884, 1024 }, { 8, 8
10748:../src/wolfcrypt/src/ecc.c ****    { 7, 888, 1024 }, { 8, 889, 1024 }, { 8, 890, 1024 }, { 9, 891, 1024 }, { 8, 892, 1024 }, { 9, 8
10749:../src/wolfcrypt/src/ecc.c ****    { 4, 896, 1024 }, { 5, 897, 1024 }, { 5, 898, 1024 }, { 6, 899, 1024 }, { 5, 900, 1024 }, { 6, 9
10750:../src/wolfcrypt/src/ecc.c ****    { 5, 904, 1024 }, { 6, 905, 1024 }, { 6, 906, 1024 }, { 7, 907, 1024 }, { 6, 908, 1024 }, { 7, 9
10751:../src/wolfcrypt/src/ecc.c ****    { 5, 912, 1024 }, { 6, 913, 1024 }, { 6, 914, 1024 }, { 7, 915, 1024 }, { 6, 916, 1024 }, { 7, 9
10752:../src/wolfcrypt/src/ecc.c ****    { 6, 920, 1024 }, { 7, 921, 1024 }, { 7, 922, 1024 }, { 8, 923, 1024 }, { 7, 924, 1024 }, { 8, 9
10753:../src/wolfcrypt/src/ecc.c ****    { 5, 928, 1024 }, { 6, 929, 1024 }, { 6, 930, 1024 }, { 7, 931, 1024 }, { 6, 932, 1024 }, { 7, 9
10754:../src/wolfcrypt/src/ecc.c ****    { 6, 936, 1024 }, { 7, 937, 1024 }, { 7, 938, 1024 }, { 8, 939, 1024 }, { 7, 940, 1024 }, { 8, 9
10755:../src/wolfcrypt/src/ecc.c ****    { 6, 944, 1024 }, { 7, 945, 1024 }, { 7, 946, 1024 }, { 8, 947, 1024 }, { 7, 948, 1024 }, { 8, 9
10756:../src/wolfcrypt/src/ecc.c ****    { 7, 952, 1024 }, { 8, 953, 1024 }, { 8, 954, 1024 }, { 9, 955, 1024 }, { 8, 956, 1024 }, { 9, 9
10757:../src/wolfcrypt/src/ecc.c ****    { 5, 960, 1024 }, { 6, 961, 1024 }, { 6, 962, 1024 }, { 7, 963, 1024 }, { 6, 964, 1024 }, { 7, 9
10758:../src/wolfcrypt/src/ecc.c ****    { 6, 968, 1024 }, { 7, 969, 1024 }, { 7, 970, 1024 }, { 8, 971, 1024 }, { 7, 972, 1024 }, { 8, 9
10759:../src/wolfcrypt/src/ecc.c ****    { 6, 976, 1024 }, { 7, 977, 1024 }, { 7, 978, 1024 }, { 8, 979, 1024 }, { 7, 980, 1024 }, { 8, 9
10760:../src/wolfcrypt/src/ecc.c ****    { 7, 984, 1024 }, { 8, 985, 1024 }, { 8, 986, 1024 }, { 9, 987, 1024 }, { 8, 988, 1024 }, { 9, 9
10761:../src/wolfcrypt/src/ecc.c ****    { 6, 992, 1024 }, { 7, 993, 1024 }, { 7, 994, 1024 }, { 8, 995, 1024 }, { 7, 996, 1024 }, { 8, 9
10762:../src/wolfcrypt/src/ecc.c ****    { 7, 1000, 1024 }, { 8, 1001, 1024 }, { 8, 1002, 1024 }, { 9, 1003, 1024 }, { 8, 1004, 1024 }, {
10763:../src/wolfcrypt/src/ecc.c ****    { 7, 1008, 1024 }, { 8, 1009, 1024 }, { 8, 1010, 1024 }, { 9, 1011, 1024 }, { 8, 1012, 1024 }, {
10764:../src/wolfcrypt/src/ecc.c ****    { 8, 1016, 1024 }, { 9, 1017, 1024 }, { 9, 1018, 1024 }, { 10, 1019, 1024 }, { 9, 1020, 1024 }, 
10765:../src/wolfcrypt/src/ecc.c **** #if FP_LUT > 11
10766:../src/wolfcrypt/src/ecc.c ****    { 1, 0, 0 }, { 2, 1, 2048 }, { 2, 2, 2048 }, { 3, 3, 2048 }, { 2, 4, 2048 }, { 3, 5, 2048 }, { 3
10767:../src/wolfcrypt/src/ecc.c ****    { 2, 8, 2048 }, { 3, 9, 2048 }, { 3, 10, 2048 }, { 4, 11, 2048 }, { 3, 12, 2048 }, { 4, 13, 2048
10768:../src/wolfcrypt/src/ecc.c ****    { 2, 16, 2048 }, { 3, 17, 2048 }, { 3, 18, 2048 }, { 4, 19, 2048 }, { 3, 20, 2048 }, { 4, 21, 20
10769:../src/wolfcrypt/src/ecc.c ****    { 3, 24, 2048 }, { 4, 25, 2048 }, { 4, 26, 2048 }, { 5, 27, 2048 }, { 4, 28, 2048 }, { 5, 29, 20
10770:../src/wolfcrypt/src/ecc.c ****    { 2, 32, 2048 }, { 3, 33, 2048 }, { 3, 34, 2048 }, { 4, 35, 2048 }, { 3, 36, 2048 }, { 4, 37, 20
10771:../src/wolfcrypt/src/ecc.c ****    { 3, 40, 2048 }, { 4, 41, 2048 }, { 4, 42, 2048 }, { 5, 43, 2048 }, { 4, 44, 2048 }, { 5, 45, 20
10772:../src/wolfcrypt/src/ecc.c ****    { 3, 48, 2048 }, { 4, 49, 2048 }, { 4, 50, 2048 }, { 5, 51, 2048 }, { 4, 52, 2048 }, { 5, 53, 20
10773:../src/wolfcrypt/src/ecc.c ****    { 4, 56, 2048 }, { 5, 57, 2048 }, { 5, 58, 2048 }, { 6, 59, 2048 }, { 5, 60, 2048 }, { 6, 61, 20
10774:../src/wolfcrypt/src/ecc.c ****    { 2, 64, 2048 }, { 3, 65, 2048 }, { 3, 66, 2048 }, { 4, 67, 2048 }, { 3, 68, 2048 }, { 4, 69, 20
10775:../src/wolfcrypt/src/ecc.c ****    { 3, 72, 2048 }, { 4, 73, 2048 }, { 4, 74, 2048 }, { 5, 75, 2048 }, { 4, 76, 2048 }, { 5, 77, 20
10776:../src/wolfcrypt/src/ecc.c ****    { 3, 80, 2048 }, { 4, 81, 2048 }, { 4, 82, 2048 }, { 5, 83, 2048 }, { 4, 84, 2048 }, { 5, 85, 20
10777:../src/wolfcrypt/src/ecc.c ****    { 4, 88, 2048 }, { 5, 89, 2048 }, { 5, 90, 2048 }, { 6, 91, 2048 }, { 5, 92, 2048 }, { 6, 93, 20
10778:../src/wolfcrypt/src/ecc.c ****    { 3, 96, 2048 }, { 4, 97, 2048 }, { 4, 98, 2048 }, { 5, 99, 2048 }, { 4, 100, 2048 }, { 5, 101, 
10779:../src/wolfcrypt/src/ecc.c ****    { 4, 104, 2048 }, { 5, 105, 2048 }, { 5, 106, 2048 }, { 6, 107, 2048 }, { 5, 108, 2048 }, { 6, 1
10780:../src/wolfcrypt/src/ecc.c ****    { 4, 112, 2048 }, { 5, 113, 2048 }, { 5, 114, 2048 }, { 6, 115, 2048 }, { 5, 116, 2048 }, { 6, 1
10781:../src/wolfcrypt/src/ecc.c ****    { 5, 120, 2048 }, { 6, 121, 2048 }, { 6, 122, 2048 }, { 7, 123, 2048 }, { 6, 124, 2048 }, { 7, 1
10782:../src/wolfcrypt/src/ecc.c ****    { 2, 128, 2048 }, { 3, 129, 2048 }, { 3, 130, 2048 }, { 4, 131, 2048 }, { 3, 132, 2048 }, { 4, 1
10783:../src/wolfcrypt/src/ecc.c ****    { 3, 136, 2048 }, { 4, 137, 2048 }, { 4, 138, 2048 }, { 5, 139, 2048 }, { 4, 140, 2048 }, { 5, 1
10784:../src/wolfcrypt/src/ecc.c ****    { 3, 144, 2048 }, { 4, 145, 2048 }, { 4, 146, 2048 }, { 5, 147, 2048 }, { 4, 148, 2048 }, { 5, 1
10785:../src/wolfcrypt/src/ecc.c ****    { 4, 152, 2048 }, { 5, 153, 2048 }, { 5, 154, 2048 }, { 6, 155, 2048 }, { 5, 156, 2048 }, { 6, 1
10786:../src/wolfcrypt/src/ecc.c ****    { 3, 160, 2048 }, { 4, 161, 2048 }, { 4, 162, 2048 }, { 5, 163, 2048 }, { 4, 164, 2048 }, { 5, 1
10787:../src/wolfcrypt/src/ecc.c ****    { 4, 168, 2048 }, { 5, 169, 2048 }, { 5, 170, 2048 }, { 6, 171, 2048 }, { 5, 172, 2048 }, { 6, 1
10788:../src/wolfcrypt/src/ecc.c ****    { 4, 176, 2048 }, { 5, 177, 2048 }, { 5, 178, 2048 }, { 6, 179, 2048 }, { 5, 180, 2048 }, { 6, 1
10789:../src/wolfcrypt/src/ecc.c ****    { 5, 184, 2048 }, { 6, 185, 2048 }, { 6, 186, 2048 }, { 7, 187, 2048 }, { 6, 188, 2048 }, { 7, 1
10790:../src/wolfcrypt/src/ecc.c ****    { 3, 192, 2048 }, { 4, 193, 2048 }, { 4, 194, 2048 }, { 5, 195, 2048 }, { 4, 196, 2048 }, { 5, 1
10791:../src/wolfcrypt/src/ecc.c ****    { 4, 200, 2048 }, { 5, 201, 2048 }, { 5, 202, 2048 }, { 6, 203, 2048 }, { 5, 204, 2048 }, { 6, 2
10792:../src/wolfcrypt/src/ecc.c ****    { 4, 208, 2048 }, { 5, 209, 2048 }, { 5, 210, 2048 }, { 6, 211, 2048 }, { 5, 212, 2048 }, { 6, 2
10793:../src/wolfcrypt/src/ecc.c ****    { 5, 216, 2048 }, { 6, 217, 2048 }, { 6, 218, 2048 }, { 7, 219, 2048 }, { 6, 220, 2048 }, { 7, 2
10794:../src/wolfcrypt/src/ecc.c ****    { 4, 224, 2048 }, { 5, 225, 2048 }, { 5, 226, 2048 }, { 6, 227, 2048 }, { 5, 228, 2048 }, { 6, 2
10795:../src/wolfcrypt/src/ecc.c ****    { 5, 232, 2048 }, { 6, 233, 2048 }, { 6, 234, 2048 }, { 7, 235, 2048 }, { 6, 236, 2048 }, { 7, 2
10796:../src/wolfcrypt/src/ecc.c ****    { 5, 240, 2048 }, { 6, 241, 2048 }, { 6, 242, 2048 }, { 7, 243, 2048 }, { 6, 244, 2048 }, { 7, 2
10797:../src/wolfcrypt/src/ecc.c ****    { 6, 248, 2048 }, { 7, 249, 2048 }, { 7, 250, 2048 }, { 8, 251, 2048 }, { 7, 252, 2048 }, { 8, 2
10798:../src/wolfcrypt/src/ecc.c ****    { 2, 256, 2048 }, { 3, 257, 2048 }, { 3, 258, 2048 }, { 4, 259, 2048 }, { 3, 260, 2048 }, { 4, 2
10799:../src/wolfcrypt/src/ecc.c ****    { 3, 264, 2048 }, { 4, 265, 2048 }, { 4, 266, 2048 }, { 5, 267, 2048 }, { 4, 268, 2048 }, { 5, 2
10800:../src/wolfcrypt/src/ecc.c ****    { 3, 272, 2048 }, { 4, 273, 2048 }, { 4, 274, 2048 }, { 5, 275, 2048 }, { 4, 276, 2048 }, { 5, 2
10801:../src/wolfcrypt/src/ecc.c ****    { 4, 280, 2048 }, { 5, 281, 2048 }, { 5, 282, 2048 }, { 6, 283, 2048 }, { 5, 284, 2048 }, { 6, 2
10802:../src/wolfcrypt/src/ecc.c ****    { 3, 288, 2048 }, { 4, 289, 2048 }, { 4, 290, 2048 }, { 5, 291, 2048 }, { 4, 292, 2048 }, { 5, 2
10803:../src/wolfcrypt/src/ecc.c ****    { 4, 296, 2048 }, { 5, 297, 2048 }, { 5, 298, 2048 }, { 6, 299, 2048 }, { 5, 300, 2048 }, { 6, 3
10804:../src/wolfcrypt/src/ecc.c ****    { 4, 304, 2048 }, { 5, 305, 2048 }, { 5, 306, 2048 }, { 6, 307, 2048 }, { 5, 308, 2048 }, { 6, 3
10805:../src/wolfcrypt/src/ecc.c ****    { 5, 312, 2048 }, { 6, 313, 2048 }, { 6, 314, 2048 }, { 7, 315, 2048 }, { 6, 316, 2048 }, { 7, 3
10806:../src/wolfcrypt/src/ecc.c ****    { 3, 320, 2048 }, { 4, 321, 2048 }, { 4, 322, 2048 }, { 5, 323, 2048 }, { 4, 324, 2048 }, { 5, 3
10807:../src/wolfcrypt/src/ecc.c ****    { 4, 328, 2048 }, { 5, 329, 2048 }, { 5, 330, 2048 }, { 6, 331, 2048 }, { 5, 332, 2048 }, { 6, 3
10808:../src/wolfcrypt/src/ecc.c ****    { 4, 336, 2048 }, { 5, 337, 2048 }, { 5, 338, 2048 }, { 6, 339, 2048 }, { 5, 340, 2048 }, { 6, 3
10809:../src/wolfcrypt/src/ecc.c ****    { 5, 344, 2048 }, { 6, 345, 2048 }, { 6, 346, 2048 }, { 7, 347, 2048 }, { 6, 348, 2048 }, { 7, 3
10810:../src/wolfcrypt/src/ecc.c ****    { 4, 352, 2048 }, { 5, 353, 2048 }, { 5, 354, 2048 }, { 6, 355, 2048 }, { 5, 356, 2048 }, { 6, 3
10811:../src/wolfcrypt/src/ecc.c ****    { 5, 360, 2048 }, { 6, 361, 2048 }, { 6, 362, 2048 }, { 7, 363, 2048 }, { 6, 364, 2048 }, { 7, 3
10812:../src/wolfcrypt/src/ecc.c ****    { 5, 368, 2048 }, { 6, 369, 2048 }, { 6, 370, 2048 }, { 7, 371, 2048 }, { 6, 372, 2048 }, { 7, 3
10813:../src/wolfcrypt/src/ecc.c ****    { 6, 376, 2048 }, { 7, 377, 2048 }, { 7, 378, 2048 }, { 8, 379, 2048 }, { 7, 380, 2048 }, { 8, 3
10814:../src/wolfcrypt/src/ecc.c ****    { 3, 384, 2048 }, { 4, 385, 2048 }, { 4, 386, 2048 }, { 5, 387, 2048 }, { 4, 388, 2048 }, { 5, 3
10815:../src/wolfcrypt/src/ecc.c ****    { 4, 392, 2048 }, { 5, 393, 2048 }, { 5, 394, 2048 }, { 6, 395, 2048 }, { 5, 396, 2048 }, { 6, 3
10816:../src/wolfcrypt/src/ecc.c ****    { 4, 400, 2048 }, { 5, 401, 2048 }, { 5, 402, 2048 }, { 6, 403, 2048 }, { 5, 404, 2048 }, { 6, 4
10817:../src/wolfcrypt/src/ecc.c ****    { 5, 408, 2048 }, { 6, 409, 2048 }, { 6, 410, 2048 }, { 7, 411, 2048 }, { 6, 412, 2048 }, { 7, 4
10818:../src/wolfcrypt/src/ecc.c ****    { 4, 416, 2048 }, { 5, 417, 2048 }, { 5, 418, 2048 }, { 6, 419, 2048 }, { 5, 420, 2048 }, { 6, 4
10819:../src/wolfcrypt/src/ecc.c ****    { 5, 424, 2048 }, { 6, 425, 2048 }, { 6, 426, 2048 }, { 7, 427, 2048 }, { 6, 428, 2048 }, { 7, 4
10820:../src/wolfcrypt/src/ecc.c ****    { 5, 432, 2048 }, { 6, 433, 2048 }, { 6, 434, 2048 }, { 7, 435, 2048 }, { 6, 436, 2048 }, { 7, 4
10821:../src/wolfcrypt/src/ecc.c ****    { 6, 440, 2048 }, { 7, 441, 2048 }, { 7, 442, 2048 }, { 8, 443, 2048 }, { 7, 444, 2048 }, { 8, 4
10822:../src/wolfcrypt/src/ecc.c ****    { 4, 448, 2048 }, { 5, 449, 2048 }, { 5, 450, 2048 }, { 6, 451, 2048 }, { 5, 452, 2048 }, { 6, 4
10823:../src/wolfcrypt/src/ecc.c ****    { 5, 456, 2048 }, { 6, 457, 2048 }, { 6, 458, 2048 }, { 7, 459, 2048 }, { 6, 460, 2048 }, { 7, 4
10824:../src/wolfcrypt/src/ecc.c ****    { 5, 464, 2048 }, { 6, 465, 2048 }, { 6, 466, 2048 }, { 7, 467, 2048 }, { 6, 468, 2048 }, { 7, 4
10825:../src/wolfcrypt/src/ecc.c ****    { 6, 472, 2048 }, { 7, 473, 2048 }, { 7, 474, 2048 }, { 8, 475, 2048 }, { 7, 476, 2048 }, { 8, 4
10826:../src/wolfcrypt/src/ecc.c ****    { 5, 480, 2048 }, { 6, 481, 2048 }, { 6, 482, 2048 }, { 7, 483, 2048 }, { 6, 484, 2048 }, { 7, 4
10827:../src/wolfcrypt/src/ecc.c ****    { 6, 488, 2048 }, { 7, 489, 2048 }, { 7, 490, 2048 }, { 8, 491, 2048 }, { 7, 492, 2048 }, { 8, 4
10828:../src/wolfcrypt/src/ecc.c ****    { 6, 496, 2048 }, { 7, 497, 2048 }, { 7, 498, 2048 }, { 8, 499, 2048 }, { 7, 500, 2048 }, { 8, 5
10829:../src/wolfcrypt/src/ecc.c ****    { 7, 504, 2048 }, { 8, 505, 2048 }, { 8, 506, 2048 }, { 9, 507, 2048 }, { 8, 508, 2048 }, { 9, 5
10830:../src/wolfcrypt/src/ecc.c ****    { 2, 512, 2048 }, { 3, 513, 2048 }, { 3, 514, 2048 }, { 4, 515, 2048 }, { 3, 516, 2048 }, { 4, 5
10831:../src/wolfcrypt/src/ecc.c ****    { 3, 520, 2048 }, { 4, 521, 2048 }, { 4, 522, 2048 }, { 5, 523, 2048 }, { 4, 524, 2048 }, { 5, 5
10832:../src/wolfcrypt/src/ecc.c ****    { 3, 528, 2048 }, { 4, 529, 2048 }, { 4, 530, 2048 }, { 5, 531, 2048 }, { 4, 532, 2048 }, { 5, 5
10833:../src/wolfcrypt/src/ecc.c ****    { 4, 536, 2048 }, { 5, 537, 2048 }, { 5, 538, 2048 }, { 6, 539, 2048 }, { 5, 540, 2048 }, { 6, 5
10834:../src/wolfcrypt/src/ecc.c ****    { 3, 544, 2048 }, { 4, 545, 2048 }, { 4, 546, 2048 }, { 5, 547, 2048 }, { 4, 548, 2048 }, { 5, 5
10835:../src/wolfcrypt/src/ecc.c ****    { 4, 552, 2048 }, { 5, 553, 2048 }, { 5, 554, 2048 }, { 6, 555, 2048 }, { 5, 556, 2048 }, { 6, 5
10836:../src/wolfcrypt/src/ecc.c ****    { 4, 560, 2048 }, { 5, 561, 2048 }, { 5, 562, 2048 }, { 6, 563, 2048 }, { 5, 564, 2048 }, { 6, 5
10837:../src/wolfcrypt/src/ecc.c ****    { 5, 568, 2048 }, { 6, 569, 2048 }, { 6, 570, 2048 }, { 7, 571, 2048 }, { 6, 572, 2048 }, { 7, 5
10838:../src/wolfcrypt/src/ecc.c ****    { 3, 576, 2048 }, { 4, 577, 2048 }, { 4, 578, 2048 }, { 5, 579, 2048 }, { 4, 580, 2048 }, { 5, 5
10839:../src/wolfcrypt/src/ecc.c ****    { 4, 584, 2048 }, { 5, 585, 2048 }, { 5, 586, 2048 }, { 6, 587, 2048 }, { 5, 588, 2048 }, { 6, 5
10840:../src/wolfcrypt/src/ecc.c ****    { 4, 592, 2048 }, { 5, 593, 2048 }, { 5, 594, 2048 }, { 6, 595, 2048 }, { 5, 596, 2048 }, { 6, 5
10841:../src/wolfcrypt/src/ecc.c ****    { 5, 600, 2048 }, { 6, 601, 2048 }, { 6, 602, 2048 }, { 7, 603, 2048 }, { 6, 604, 2048 }, { 7, 6
10842:../src/wolfcrypt/src/ecc.c ****    { 4, 608, 2048 }, { 5, 609, 2048 }, { 5, 610, 2048 }, { 6, 611, 2048 }, { 5, 612, 2048 }, { 6, 6
10843:../src/wolfcrypt/src/ecc.c ****    { 5, 616, 2048 }, { 6, 617, 2048 }, { 6, 618, 2048 }, { 7, 619, 2048 }, { 6, 620, 2048 }, { 7, 6
10844:../src/wolfcrypt/src/ecc.c ****    { 5, 624, 2048 }, { 6, 625, 2048 }, { 6, 626, 2048 }, { 7, 627, 2048 }, { 6, 628, 2048 }, { 7, 6
10845:../src/wolfcrypt/src/ecc.c ****    { 6, 632, 2048 }, { 7, 633, 2048 }, { 7, 634, 2048 }, { 8, 635, 2048 }, { 7, 636, 2048 }, { 8, 6
10846:../src/wolfcrypt/src/ecc.c ****    { 3, 640, 2048 }, { 4, 641, 2048 }, { 4, 642, 2048 }, { 5, 643, 2048 }, { 4, 644, 2048 }, { 5, 6
10847:../src/wolfcrypt/src/ecc.c ****    { 4, 648, 2048 }, { 5, 649, 2048 }, { 5, 650, 2048 }, { 6, 651, 2048 }, { 5, 652, 2048 }, { 6, 6
10848:../src/wolfcrypt/src/ecc.c ****    { 4, 656, 2048 }, { 5, 657, 2048 }, { 5, 658, 2048 }, { 6, 659, 2048 }, { 5, 660, 2048 }, { 6, 6
10849:../src/wolfcrypt/src/ecc.c ****    { 5, 664, 2048 }, { 6, 665, 2048 }, { 6, 666, 2048 }, { 7, 667, 2048 }, { 6, 668, 2048 }, { 7, 6
10850:../src/wolfcrypt/src/ecc.c ****    { 4, 672, 2048 }, { 5, 673, 2048 }, { 5, 674, 2048 }, { 6, 675, 2048 }, { 5, 676, 2048 }, { 6, 6
10851:../src/wolfcrypt/src/ecc.c ****    { 5, 680, 2048 }, { 6, 681, 2048 }, { 6, 682, 2048 }, { 7, 683, 2048 }, { 6, 684, 2048 }, { 7, 6
10852:../src/wolfcrypt/src/ecc.c ****    { 5, 688, 2048 }, { 6, 689, 2048 }, { 6, 690, 2048 }, { 7, 691, 2048 }, { 6, 692, 2048 }, { 7, 6
10853:../src/wolfcrypt/src/ecc.c ****    { 6, 696, 2048 }, { 7, 697, 2048 }, { 7, 698, 2048 }, { 8, 699, 2048 }, { 7, 700, 2048 }, { 8, 7
10854:../src/wolfcrypt/src/ecc.c ****    { 4, 704, 2048 }, { 5, 705, 2048 }, { 5, 706, 2048 }, { 6, 707, 2048 }, { 5, 708, 2048 }, { 6, 7
10855:../src/wolfcrypt/src/ecc.c ****    { 5, 712, 2048 }, { 6, 713, 2048 }, { 6, 714, 2048 }, { 7, 715, 2048 }, { 6, 716, 2048 }, { 7, 7
10856:../src/wolfcrypt/src/ecc.c ****    { 5, 720, 2048 }, { 6, 721, 2048 }, { 6, 722, 2048 }, { 7, 723, 2048 }, { 6, 724, 2048 }, { 7, 7
10857:../src/wolfcrypt/src/ecc.c ****    { 6, 728, 2048 }, { 7, 729, 2048 }, { 7, 730, 2048 }, { 8, 731, 2048 }, { 7, 732, 2048 }, { 8, 7
10858:../src/wolfcrypt/src/ecc.c ****    { 5, 736, 2048 }, { 6, 737, 2048 }, { 6, 738, 2048 }, { 7, 739, 2048 }, { 6, 740, 2048 }, { 7, 7
10859:../src/wolfcrypt/src/ecc.c ****    { 6, 744, 2048 }, { 7, 745, 2048 }, { 7, 746, 2048 }, { 8, 747, 2048 }, { 7, 748, 2048 }, { 8, 7
10860:../src/wolfcrypt/src/ecc.c ****    { 6, 752, 2048 }, { 7, 753, 2048 }, { 7, 754, 2048 }, { 8, 755, 2048 }, { 7, 756, 2048 }, { 8, 7
10861:../src/wolfcrypt/src/ecc.c ****    { 7, 760, 2048 }, { 8, 761, 2048 }, { 8, 762, 2048 }, { 9, 763, 2048 }, { 8, 764, 2048 }, { 9, 7
10862:../src/wolfcrypt/src/ecc.c ****    { 3, 768, 2048 }, { 4, 769, 2048 }, { 4, 770, 2048 }, { 5, 771, 2048 }, { 4, 772, 2048 }, { 5, 7
10863:../src/wolfcrypt/src/ecc.c ****    { 4, 776, 2048 }, { 5, 777, 2048 }, { 5, 778, 2048 }, { 6, 779, 2048 }, { 5, 780, 2048 }, { 6, 7
10864:../src/wolfcrypt/src/ecc.c ****    { 4, 784, 2048 }, { 5, 785, 2048 }, { 5, 786, 2048 }, { 6, 787, 2048 }, { 5, 788, 2048 }, { 6, 7
10865:../src/wolfcrypt/src/ecc.c ****    { 5, 792, 2048 }, { 6, 793, 2048 }, { 6, 794, 2048 }, { 7, 795, 2048 }, { 6, 796, 2048 }, { 7, 7
10866:../src/wolfcrypt/src/ecc.c ****    { 4, 800, 2048 }, { 5, 801, 2048 }, { 5, 802, 2048 }, { 6, 803, 2048 }, { 5, 804, 2048 }, { 6, 8
10867:../src/wolfcrypt/src/ecc.c ****    { 5, 808, 2048 }, { 6, 809, 2048 }, { 6, 810, 2048 }, { 7, 811, 2048 }, { 6, 812, 2048 }, { 7, 8
10868:../src/wolfcrypt/src/ecc.c ****    { 5, 816, 2048 }, { 6, 817, 2048 }, { 6, 818, 2048 }, { 7, 819, 2048 }, { 6, 820, 2048 }, { 7, 8
10869:../src/wolfcrypt/src/ecc.c ****    { 6, 824, 2048 }, { 7, 825, 2048 }, { 7, 826, 2048 }, { 8, 827, 2048 }, { 7, 828, 2048 }, { 8, 8
10870:../src/wolfcrypt/src/ecc.c ****    { 4, 832, 2048 }, { 5, 833, 2048 }, { 5, 834, 2048 }, { 6, 835, 2048 }, { 5, 836, 2048 }, { 6, 8
10871:../src/wolfcrypt/src/ecc.c ****    { 5, 840, 2048 }, { 6, 841, 2048 }, { 6, 842, 2048 }, { 7, 843, 2048 }, { 6, 844, 2048 }, { 7, 8
10872:../src/wolfcrypt/src/ecc.c ****    { 5, 848, 2048 }, { 6, 849, 2048 }, { 6, 850, 2048 }, { 7, 851, 2048 }, { 6, 852, 2048 }, { 7, 8
10873:../src/wolfcrypt/src/ecc.c ****    { 6, 856, 2048 }, { 7, 857, 2048 }, { 7, 858, 2048 }, { 8, 859, 2048 }, { 7, 860, 2048 }, { 8, 8
10874:../src/wolfcrypt/src/ecc.c ****    { 5, 864, 2048 }, { 6, 865, 2048 }, { 6, 866, 2048 }, { 7, 867, 2048 }, { 6, 868, 2048 }, { 7, 8
10875:../src/wolfcrypt/src/ecc.c ****    { 6, 872, 2048 }, { 7, 873, 2048 }, { 7, 874, 2048 }, { 8, 875, 2048 }, { 7, 876, 2048 }, { 8, 8
10876:../src/wolfcrypt/src/ecc.c ****    { 6, 880, 2048 }, { 7, 881, 2048 }, { 7, 882, 2048 }, { 8, 883, 2048 }, { 7, 884, 2048 }, { 8, 8
10877:../src/wolfcrypt/src/ecc.c ****    { 7, 888, 2048 }, { 8, 889, 2048 }, { 8, 890, 2048 }, { 9, 891, 2048 }, { 8, 892, 2048 }, { 9, 8
10878:../src/wolfcrypt/src/ecc.c ****    { 4, 896, 2048 }, { 5, 897, 2048 }, { 5, 898, 2048 }, { 6, 899, 2048 }, { 5, 900, 2048 }, { 6, 9
10879:../src/wolfcrypt/src/ecc.c ****    { 5, 904, 2048 }, { 6, 905, 2048 }, { 6, 906, 2048 }, { 7, 907, 2048 }, { 6, 908, 2048 }, { 7, 9
10880:../src/wolfcrypt/src/ecc.c ****    { 5, 912, 2048 }, { 6, 913, 2048 }, { 6, 914, 2048 }, { 7, 915, 2048 }, { 6, 916, 2048 }, { 7, 9
10881:../src/wolfcrypt/src/ecc.c ****    { 6, 920, 2048 }, { 7, 921, 2048 }, { 7, 922, 2048 }, { 8, 923, 2048 }, { 7, 924, 2048 }, { 8, 9
10882:../src/wolfcrypt/src/ecc.c ****    { 5, 928, 2048 }, { 6, 929, 2048 }, { 6, 930, 2048 }, { 7, 931, 2048 }, { 6, 932, 2048 }, { 7, 9
10883:../src/wolfcrypt/src/ecc.c ****    { 6, 936, 2048 }, { 7, 937, 2048 }, { 7, 938, 2048 }, { 8, 939, 2048 }, { 7, 940, 2048 }, { 8, 9
10884:../src/wolfcrypt/src/ecc.c ****    { 6, 944, 2048 }, { 7, 945, 2048 }, { 7, 946, 2048 }, { 8, 947, 2048 }, { 7, 948, 2048 }, { 8, 9
10885:../src/wolfcrypt/src/ecc.c ****    { 7, 952, 2048 }, { 8, 953, 2048 }, { 8, 954, 2048 }, { 9, 955, 2048 }, { 8, 956, 2048 }, { 9, 9
10886:../src/wolfcrypt/src/ecc.c ****    { 5, 960, 2048 }, { 6, 961, 2048 }, { 6, 962, 2048 }, { 7, 963, 2048 }, { 6, 964, 2048 }, { 7, 9
10887:../src/wolfcrypt/src/ecc.c ****    { 6, 968, 2048 }, { 7, 969, 2048 }, { 7, 970, 2048 }, { 8, 971, 2048 }, { 7, 972, 2048 }, { 8, 9
10888:../src/wolfcrypt/src/ecc.c ****    { 6, 976, 2048 }, { 7, 977, 2048 }, { 7, 978, 2048 }, { 8, 979, 2048 }, { 7, 980, 2048 }, { 8, 9
10889:../src/wolfcrypt/src/ecc.c ****    { 7, 984, 2048 }, { 8, 985, 2048 }, { 8, 986, 2048 }, { 9, 987, 2048 }, { 8, 988, 2048 }, { 9, 9
10890:../src/wolfcrypt/src/ecc.c ****    { 6, 992, 2048 }, { 7, 993, 2048 }, { 7, 994, 2048 }, { 8, 995, 2048 }, { 7, 996, 2048 }, { 8, 9
10891:../src/wolfcrypt/src/ecc.c ****    { 7, 1000, 2048 }, { 8, 1001, 2048 }, { 8, 1002, 2048 }, { 9, 1003, 2048 }, { 8, 1004, 2048 }, {
10892:../src/wolfcrypt/src/ecc.c ****    { 7, 1008, 2048 }, { 8, 1009, 2048 }, { 8, 1010, 2048 }, { 9, 1011, 2048 }, { 8, 1012, 2048 }, {
10893:../src/wolfcrypt/src/ecc.c ****    { 8, 1016, 2048 }, { 9, 1017, 2048 }, { 9, 1018, 2048 }, { 10, 1019, 2048 }, { 9, 1020, 2048 }, 
10894:../src/wolfcrypt/src/ecc.c ****    { 2, 1024, 2048 }, { 3, 1025, 2048 }, { 3, 1026, 2048 }, { 4, 1027, 2048 }, { 3, 1028, 2048 }, {
10895:../src/wolfcrypt/src/ecc.c ****    { 3, 1032, 2048 }, { 4, 1033, 2048 }, { 4, 1034, 2048 }, { 5, 1035, 2048 }, { 4, 1036, 2048 }, {
10896:../src/wolfcrypt/src/ecc.c ****    { 3, 1040, 2048 }, { 4, 1041, 2048 }, { 4, 1042, 2048 }, { 5, 1043, 2048 }, { 4, 1044, 2048 }, {
10897:../src/wolfcrypt/src/ecc.c ****    { 4, 1048, 2048 }, { 5, 1049, 2048 }, { 5, 1050, 2048 }, { 6, 1051, 2048 }, { 5, 1052, 2048 }, {
10898:../src/wolfcrypt/src/ecc.c ****    { 3, 1056, 2048 }, { 4, 1057, 2048 }, { 4, 1058, 2048 }, { 5, 1059, 2048 }, { 4, 1060, 2048 }, {
10899:../src/wolfcrypt/src/ecc.c ****    { 4, 1064, 2048 }, { 5, 1065, 2048 }, { 5, 1066, 2048 }, { 6, 1067, 2048 }, { 5, 1068, 2048 }, {
10900:../src/wolfcrypt/src/ecc.c ****    { 4, 1072, 2048 }, { 5, 1073, 2048 }, { 5, 1074, 2048 }, { 6, 1075, 2048 }, { 5, 1076, 2048 }, {
10901:../src/wolfcrypt/src/ecc.c ****    { 5, 1080, 2048 }, { 6, 1081, 2048 }, { 6, 1082, 2048 }, { 7, 1083, 2048 }, { 6, 1084, 2048 }, {
10902:../src/wolfcrypt/src/ecc.c ****    { 3, 1088, 2048 }, { 4, 1089, 2048 }, { 4, 1090, 2048 }, { 5, 1091, 2048 }, { 4, 1092, 2048 }, {
10903:../src/wolfcrypt/src/ecc.c ****    { 4, 1096, 2048 }, { 5, 1097, 2048 }, { 5, 1098, 2048 }, { 6, 1099, 2048 }, { 5, 1100, 2048 }, {
10904:../src/wolfcrypt/src/ecc.c ****    { 4, 1104, 2048 }, { 5, 1105, 2048 }, { 5, 1106, 2048 }, { 6, 1107, 2048 }, { 5, 1108, 2048 }, {
10905:../src/wolfcrypt/src/ecc.c ****    { 5, 1112, 2048 }, { 6, 1113, 2048 }, { 6, 1114, 2048 }, { 7, 1115, 2048 }, { 6, 1116, 2048 }, {
10906:../src/wolfcrypt/src/ecc.c ****    { 4, 1120, 2048 }, { 5, 1121, 2048 }, { 5, 1122, 2048 }, { 6, 1123, 2048 }, { 5, 1124, 2048 }, {
10907:../src/wolfcrypt/src/ecc.c ****    { 5, 1128, 2048 }, { 6, 1129, 2048 }, { 6, 1130, 2048 }, { 7, 1131, 2048 }, { 6, 1132, 2048 }, {
10908:../src/wolfcrypt/src/ecc.c ****    { 5, 1136, 2048 }, { 6, 1137, 2048 }, { 6, 1138, 2048 }, { 7, 1139, 2048 }, { 6, 1140, 2048 }, {
10909:../src/wolfcrypt/src/ecc.c ****    { 6, 1144, 2048 }, { 7, 1145, 2048 }, { 7, 1146, 2048 }, { 8, 1147, 2048 }, { 7, 1148, 2048 }, {
10910:../src/wolfcrypt/src/ecc.c ****    { 3, 1152, 2048 }, { 4, 1153, 2048 }, { 4, 1154, 2048 }, { 5, 1155, 2048 }, { 4, 1156, 2048 }, {
10911:../src/wolfcrypt/src/ecc.c ****    { 4, 1160, 2048 }, { 5, 1161, 2048 }, { 5, 1162, 2048 }, { 6, 1163, 2048 }, { 5, 1164, 2048 }, {
10912:../src/wolfcrypt/src/ecc.c ****    { 4, 1168, 2048 }, { 5, 1169, 2048 }, { 5, 1170, 2048 }, { 6, 1171, 2048 }, { 5, 1172, 2048 }, {
10913:../src/wolfcrypt/src/ecc.c ****    { 5, 1176, 2048 }, { 6, 1177, 2048 }, { 6, 1178, 2048 }, { 7, 1179, 2048 }, { 6, 1180, 2048 }, {
10914:../src/wolfcrypt/src/ecc.c ****    { 4, 1184, 2048 }, { 5, 1185, 2048 }, { 5, 1186, 2048 }, { 6, 1187, 2048 }, { 5, 1188, 2048 }, {
10915:../src/wolfcrypt/src/ecc.c ****    { 5, 1192, 2048 }, { 6, 1193, 2048 }, { 6, 1194, 2048 }, { 7, 1195, 2048 }, { 6, 1196, 2048 }, {
10916:../src/wolfcrypt/src/ecc.c ****    { 5, 1200, 2048 }, { 6, 1201, 2048 }, { 6, 1202, 2048 }, { 7, 1203, 2048 }, { 6, 1204, 2048 }, {
10917:../src/wolfcrypt/src/ecc.c ****    { 6, 1208, 2048 }, { 7, 1209, 2048 }, { 7, 1210, 2048 }, { 8, 1211, 2048 }, { 7, 1212, 2048 }, {
10918:../src/wolfcrypt/src/ecc.c ****    { 4, 1216, 2048 }, { 5, 1217, 2048 }, { 5, 1218, 2048 }, { 6, 1219, 2048 }, { 5, 1220, 2048 }, {
10919:../src/wolfcrypt/src/ecc.c ****    { 5, 1224, 2048 }, { 6, 1225, 2048 }, { 6, 1226, 2048 }, { 7, 1227, 2048 }, { 6, 1228, 2048 }, {
10920:../src/wolfcrypt/src/ecc.c ****    { 5, 1232, 2048 }, { 6, 1233, 2048 }, { 6, 1234, 2048 }, { 7, 1235, 2048 }, { 6, 1236, 2048 }, {
10921:../src/wolfcrypt/src/ecc.c ****    { 6, 1240, 2048 }, { 7, 1241, 2048 }, { 7, 1242, 2048 }, { 8, 1243, 2048 }, { 7, 1244, 2048 }, {
10922:../src/wolfcrypt/src/ecc.c ****    { 5, 1248, 2048 }, { 6, 1249, 2048 }, { 6, 1250, 2048 }, { 7, 1251, 2048 }, { 6, 1252, 2048 }, {
10923:../src/wolfcrypt/src/ecc.c ****    { 6, 1256, 2048 }, { 7, 1257, 2048 }, { 7, 1258, 2048 }, { 8, 1259, 2048 }, { 7, 1260, 2048 }, {
10924:../src/wolfcrypt/src/ecc.c ****    { 6, 1264, 2048 }, { 7, 1265, 2048 }, { 7, 1266, 2048 }, { 8, 1267, 2048 }, { 7, 1268, 2048 }, {
10925:../src/wolfcrypt/src/ecc.c ****    { 7, 1272, 2048 }, { 8, 1273, 2048 }, { 8, 1274, 2048 }, { 9, 1275, 2048 }, { 8, 1276, 2048 }, {
10926:../src/wolfcrypt/src/ecc.c ****    { 3, 1280, 2048 }, { 4, 1281, 2048 }, { 4, 1282, 2048 }, { 5, 1283, 2048 }, { 4, 1284, 2048 }, {
10927:../src/wolfcrypt/src/ecc.c ****    { 4, 1288, 2048 }, { 5, 1289, 2048 }, { 5, 1290, 2048 }, { 6, 1291, 2048 }, { 5, 1292, 2048 }, {
10928:../src/wolfcrypt/src/ecc.c ****    { 4, 1296, 2048 }, { 5, 1297, 2048 }, { 5, 1298, 2048 }, { 6, 1299, 2048 }, { 5, 1300, 2048 }, {
10929:../src/wolfcrypt/src/ecc.c ****    { 5, 1304, 2048 }, { 6, 1305, 2048 }, { 6, 1306, 2048 }, { 7, 1307, 2048 }, { 6, 1308, 2048 }, {
10930:../src/wolfcrypt/src/ecc.c ****    { 4, 1312, 2048 }, { 5, 1313, 2048 }, { 5, 1314, 2048 }, { 6, 1315, 2048 }, { 5, 1316, 2048 }, {
10931:../src/wolfcrypt/src/ecc.c ****    { 5, 1320, 2048 }, { 6, 1321, 2048 }, { 6, 1322, 2048 }, { 7, 1323, 2048 }, { 6, 1324, 2048 }, {
10932:../src/wolfcrypt/src/ecc.c ****    { 5, 1328, 2048 }, { 6, 1329, 2048 }, { 6, 1330, 2048 }, { 7, 1331, 2048 }, { 6, 1332, 2048 }, {
10933:../src/wolfcrypt/src/ecc.c ****    { 6, 1336, 2048 }, { 7, 1337, 2048 }, { 7, 1338, 2048 }, { 8, 1339, 2048 }, { 7, 1340, 2048 }, {
10934:../src/wolfcrypt/src/ecc.c ****    { 4, 1344, 2048 }, { 5, 1345, 2048 }, { 5, 1346, 2048 }, { 6, 1347, 2048 }, { 5, 1348, 2048 }, {
10935:../src/wolfcrypt/src/ecc.c ****    { 5, 1352, 2048 }, { 6, 1353, 2048 }, { 6, 1354, 2048 }, { 7, 1355, 2048 }, { 6, 1356, 2048 }, {
10936:../src/wolfcrypt/src/ecc.c ****    { 5, 1360, 2048 }, { 6, 1361, 2048 }, { 6, 1362, 2048 }, { 7, 1363, 2048 }, { 6, 1364, 2048 }, {
10937:../src/wolfcrypt/src/ecc.c ****    { 6, 1368, 2048 }, { 7, 1369, 2048 }, { 7, 1370, 2048 }, { 8, 1371, 2048 }, { 7, 1372, 2048 }, {
10938:../src/wolfcrypt/src/ecc.c ****    { 5, 1376, 2048 }, { 6, 1377, 2048 }, { 6, 1378, 2048 }, { 7, 1379, 2048 }, { 6, 1380, 2048 }, {
10939:../src/wolfcrypt/src/ecc.c ****    { 6, 1384, 2048 }, { 7, 1385, 2048 }, { 7, 1386, 2048 }, { 8, 1387, 2048 }, { 7, 1388, 2048 }, {
10940:../src/wolfcrypt/src/ecc.c ****    { 6, 1392, 2048 }, { 7, 1393, 2048 }, { 7, 1394, 2048 }, { 8, 1395, 2048 }, { 7, 1396, 2048 }, {
10941:../src/wolfcrypt/src/ecc.c ****    { 7, 1400, 2048 }, { 8, 1401, 2048 }, { 8, 1402, 2048 }, { 9, 1403, 2048 }, { 8, 1404, 2048 }, {
10942:../src/wolfcrypt/src/ecc.c ****    { 4, 1408, 2048 }, { 5, 1409, 2048 }, { 5, 1410, 2048 }, { 6, 1411, 2048 }, { 5, 1412, 2048 }, {
10943:../src/wolfcrypt/src/ecc.c ****    { 5, 1416, 2048 }, { 6, 1417, 2048 }, { 6, 1418, 2048 }, { 7, 1419, 2048 }, { 6, 1420, 2048 }, {
10944:../src/wolfcrypt/src/ecc.c ****    { 5, 1424, 2048 }, { 6, 1425, 2048 }, { 6, 1426, 2048 }, { 7, 1427, 2048 }, { 6, 1428, 2048 }, {
10945:../src/wolfcrypt/src/ecc.c ****    { 6, 1432, 2048 }, { 7, 1433, 2048 }, { 7, 1434, 2048 }, { 8, 1435, 2048 }, { 7, 1436, 2048 }, {
10946:../src/wolfcrypt/src/ecc.c ****    { 5, 1440, 2048 }, { 6, 1441, 2048 }, { 6, 1442, 2048 }, { 7, 1443, 2048 }, { 6, 1444, 2048 }, {
10947:../src/wolfcrypt/src/ecc.c ****    { 6, 1448, 2048 }, { 7, 1449, 2048 }, { 7, 1450, 2048 }, { 8, 1451, 2048 }, { 7, 1452, 2048 }, {
10948:../src/wolfcrypt/src/ecc.c ****    { 6, 1456, 2048 }, { 7, 1457, 2048 }, { 7, 1458, 2048 }, { 8, 1459, 2048 }, { 7, 1460, 2048 }, {
10949:../src/wolfcrypt/src/ecc.c ****    { 7, 1464, 2048 }, { 8, 1465, 2048 }, { 8, 1466, 2048 }, { 9, 1467, 2048 }, { 8, 1468, 2048 }, {
10950:../src/wolfcrypt/src/ecc.c ****    { 5, 1472, 2048 }, { 6, 1473, 2048 }, { 6, 1474, 2048 }, { 7, 1475, 2048 }, { 6, 1476, 2048 }, {
10951:../src/wolfcrypt/src/ecc.c ****    { 6, 1480, 2048 }, { 7, 1481, 2048 }, { 7, 1482, 2048 }, { 8, 1483, 2048 }, { 7, 1484, 2048 }, {
10952:../src/wolfcrypt/src/ecc.c ****    { 6, 1488, 2048 }, { 7, 1489, 2048 }, { 7, 1490, 2048 }, { 8, 1491, 2048 }, { 7, 1492, 2048 }, {
10953:../src/wolfcrypt/src/ecc.c ****    { 7, 1496, 2048 }, { 8, 1497, 2048 }, { 8, 1498, 2048 }, { 9, 1499, 2048 }, { 8, 1500, 2048 }, {
10954:../src/wolfcrypt/src/ecc.c ****    { 6, 1504, 2048 }, { 7, 1505, 2048 }, { 7, 1506, 2048 }, { 8, 1507, 2048 }, { 7, 1508, 2048 }, {
10955:../src/wolfcrypt/src/ecc.c ****    { 7, 1512, 2048 }, { 8, 1513, 2048 }, { 8, 1514, 2048 }, { 9, 1515, 2048 }, { 8, 1516, 2048 }, {
10956:../src/wolfcrypt/src/ecc.c ****    { 7, 1520, 2048 }, { 8, 1521, 2048 }, { 8, 1522, 2048 }, { 9, 1523, 2048 }, { 8, 1524, 2048 }, {
10957:../src/wolfcrypt/src/ecc.c ****    { 8, 1528, 2048 }, { 9, 1529, 2048 }, { 9, 1530, 2048 }, { 10, 1531, 2048 }, { 9, 1532, 2048 }, 
10958:../src/wolfcrypt/src/ecc.c ****    { 3, 1536, 2048 }, { 4, 1537, 2048 }, { 4, 1538, 2048 }, { 5, 1539, 2048 }, { 4, 1540, 2048 }, {
10959:../src/wolfcrypt/src/ecc.c ****    { 4, 1544, 2048 }, { 5, 1545, 2048 }, { 5, 1546, 2048 }, { 6, 1547, 2048 }, { 5, 1548, 2048 }, {
10960:../src/wolfcrypt/src/ecc.c ****    { 4, 1552, 2048 }, { 5, 1553, 2048 }, { 5, 1554, 2048 }, { 6, 1555, 2048 }, { 5, 1556, 2048 }, {
10961:../src/wolfcrypt/src/ecc.c ****    { 5, 1560, 2048 }, { 6, 1561, 2048 }, { 6, 1562, 2048 }, { 7, 1563, 2048 }, { 6, 1564, 2048 }, {
10962:../src/wolfcrypt/src/ecc.c ****    { 4, 1568, 2048 }, { 5, 1569, 2048 }, { 5, 1570, 2048 }, { 6, 1571, 2048 }, { 5, 1572, 2048 }, {
10963:../src/wolfcrypt/src/ecc.c ****    { 5, 1576, 2048 }, { 6, 1577, 2048 }, { 6, 1578, 2048 }, { 7, 1579, 2048 }, { 6, 1580, 2048 }, {
10964:../src/wolfcrypt/src/ecc.c ****    { 5, 1584, 2048 }, { 6, 1585, 2048 }, { 6, 1586, 2048 }, { 7, 1587, 2048 }, { 6, 1588, 2048 }, {
10965:../src/wolfcrypt/src/ecc.c ****    { 6, 1592, 2048 }, { 7, 1593, 2048 }, { 7, 1594, 2048 }, { 8, 1595, 2048 }, { 7, 1596, 2048 }, {
10966:../src/wolfcrypt/src/ecc.c ****    { 4, 1600, 2048 }, { 5, 1601, 2048 }, { 5, 1602, 2048 }, { 6, 1603, 2048 }, { 5, 1604, 2048 }, {
10967:../src/wolfcrypt/src/ecc.c ****    { 5, 1608, 2048 }, { 6, 1609, 2048 }, { 6, 1610, 2048 }, { 7, 1611, 2048 }, { 6, 1612, 2048 }, {
10968:../src/wolfcrypt/src/ecc.c ****    { 5, 1616, 2048 }, { 6, 1617, 2048 }, { 6, 1618, 2048 }, { 7, 1619, 2048 }, { 6, 1620, 2048 }, {
10969:../src/wolfcrypt/src/ecc.c ****    { 6, 1624, 2048 }, { 7, 1625, 2048 }, { 7, 1626, 2048 }, { 8, 1627, 2048 }, { 7, 1628, 2048 }, {
10970:../src/wolfcrypt/src/ecc.c ****    { 5, 1632, 2048 }, { 6, 1633, 2048 }, { 6, 1634, 2048 }, { 7, 1635, 2048 }, { 6, 1636, 2048 }, {
10971:../src/wolfcrypt/src/ecc.c ****    { 6, 1640, 2048 }, { 7, 1641, 2048 }, { 7, 1642, 2048 }, { 8, 1643, 2048 }, { 7, 1644, 2048 }, {
10972:../src/wolfcrypt/src/ecc.c ****    { 6, 1648, 2048 }, { 7, 1649, 2048 }, { 7, 1650, 2048 }, { 8, 1651, 2048 }, { 7, 1652, 2048 }, {
10973:../src/wolfcrypt/src/ecc.c ****    { 7, 1656, 2048 }, { 8, 1657, 2048 }, { 8, 1658, 2048 }, { 9, 1659, 2048 }, { 8, 1660, 2048 }, {
10974:../src/wolfcrypt/src/ecc.c ****    { 4, 1664, 2048 }, { 5, 1665, 2048 }, { 5, 1666, 2048 }, { 6, 1667, 2048 }, { 5, 1668, 2048 }, {
10975:../src/wolfcrypt/src/ecc.c ****    { 5, 1672, 2048 }, { 6, 1673, 2048 }, { 6, 1674, 2048 }, { 7, 1675, 2048 }, { 6, 1676, 2048 }, {
10976:../src/wolfcrypt/src/ecc.c ****    { 5, 1680, 2048 }, { 6, 1681, 2048 }, { 6, 1682, 2048 }, { 7, 1683, 2048 }, { 6, 1684, 2048 }, {
10977:../src/wolfcrypt/src/ecc.c ****    { 6, 1688, 2048 }, { 7, 1689, 2048 }, { 7, 1690, 2048 }, { 8, 1691, 2048 }, { 7, 1692, 2048 }, {
10978:../src/wolfcrypt/src/ecc.c ****    { 5, 1696, 2048 }, { 6, 1697, 2048 }, { 6, 1698, 2048 }, { 7, 1699, 2048 }, { 6, 1700, 2048 }, {
10979:../src/wolfcrypt/src/ecc.c ****    { 6, 1704, 2048 }, { 7, 1705, 2048 }, { 7, 1706, 2048 }, { 8, 1707, 2048 }, { 7, 1708, 2048 }, {
10980:../src/wolfcrypt/src/ecc.c ****    { 6, 1712, 2048 }, { 7, 1713, 2048 }, { 7, 1714, 2048 }, { 8, 1715, 2048 }, { 7, 1716, 2048 }, {
10981:../src/wolfcrypt/src/ecc.c ****    { 7, 1720, 2048 }, { 8, 1721, 2048 }, { 8, 1722, 2048 }, { 9, 1723, 2048 }, { 8, 1724, 2048 }, {
10982:../src/wolfcrypt/src/ecc.c ****    { 5, 1728, 2048 }, { 6, 1729, 2048 }, { 6, 1730, 2048 }, { 7, 1731, 2048 }, { 6, 1732, 2048 }, {
10983:../src/wolfcrypt/src/ecc.c ****    { 6, 1736, 2048 }, { 7, 1737, 2048 }, { 7, 1738, 2048 }, { 8, 1739, 2048 }, { 7, 1740, 2048 }, {
10984:../src/wolfcrypt/src/ecc.c ****    { 6, 1744, 2048 }, { 7, 1745, 2048 }, { 7, 1746, 2048 }, { 8, 1747, 2048 }, { 7, 1748, 2048 }, {
10985:../src/wolfcrypt/src/ecc.c ****    { 7, 1752, 2048 }, { 8, 1753, 2048 }, { 8, 1754, 2048 }, { 9, 1755, 2048 }, { 8, 1756, 2048 }, {
10986:../src/wolfcrypt/src/ecc.c ****    { 6, 1760, 2048 }, { 7, 1761, 2048 }, { 7, 1762, 2048 }, { 8, 1763, 2048 }, { 7, 1764, 2048 }, {
10987:../src/wolfcrypt/src/ecc.c ****    { 7, 1768, 2048 }, { 8, 1769, 2048 }, { 8, 1770, 2048 }, { 9, 1771, 2048 }, { 8, 1772, 2048 }, {
10988:../src/wolfcrypt/src/ecc.c ****    { 7, 1776, 2048 }, { 8, 1777, 2048 }, { 8, 1778, 2048 }, { 9, 1779, 2048 }, { 8, 1780, 2048 }, {
10989:../src/wolfcrypt/src/ecc.c ****    { 8, 1784, 2048 }, { 9, 1785, 2048 }, { 9, 1786, 2048 }, { 10, 1787, 2048 }, { 9, 1788, 2048 }, 
10990:../src/wolfcrypt/src/ecc.c ****    { 4, 1792, 2048 }, { 5, 1793, 2048 }, { 5, 1794, 2048 }, { 6, 1795, 2048 }, { 5, 1796, 2048 }, {
10991:../src/wolfcrypt/src/ecc.c ****    { 5, 1800, 2048 }, { 6, 1801, 2048 }, { 6, 1802, 2048 }, { 7, 1803, 2048 }, { 6, 1804, 2048 }, {
10992:../src/wolfcrypt/src/ecc.c ****    { 5, 1808, 2048 }, { 6, 1809, 2048 }, { 6, 1810, 2048 }, { 7, 1811, 2048 }, { 6, 1812, 2048 }, {
10993:../src/wolfcrypt/src/ecc.c ****    { 6, 1816, 2048 }, { 7, 1817, 2048 }, { 7, 1818, 2048 }, { 8, 1819, 2048 }, { 7, 1820, 2048 }, {
10994:../src/wolfcrypt/src/ecc.c ****    { 5, 1824, 2048 }, { 6, 1825, 2048 }, { 6, 1826, 2048 }, { 7, 1827, 2048 }, { 6, 1828, 2048 }, {
10995:../src/wolfcrypt/src/ecc.c ****    { 6, 1832, 2048 }, { 7, 1833, 2048 }, { 7, 1834, 2048 }, { 8, 1835, 2048 }, { 7, 1836, 2048 }, {
10996:../src/wolfcrypt/src/ecc.c ****    { 6, 1840, 2048 }, { 7, 1841, 2048 }, { 7, 1842, 2048 }, { 8, 1843, 2048 }, { 7, 1844, 2048 }, {
10997:../src/wolfcrypt/src/ecc.c ****    { 7, 1848, 2048 }, { 8, 1849, 2048 }, { 8, 1850, 2048 }, { 9, 1851, 2048 }, { 8, 1852, 2048 }, {
10998:../src/wolfcrypt/src/ecc.c ****    { 5, 1856, 2048 }, { 6, 1857, 2048 }, { 6, 1858, 2048 }, { 7, 1859, 2048 }, { 6, 1860, 2048 }, {
10999:../src/wolfcrypt/src/ecc.c ****    { 6, 1864, 2048 }, { 7, 1865, 2048 }, { 7, 1866, 2048 }, { 8, 1867, 2048 }, { 7, 1868, 2048 }, {
11000:../src/wolfcrypt/src/ecc.c ****    { 6, 1872, 2048 }, { 7, 1873, 2048 }, { 7, 1874, 2048 }, { 8, 1875, 2048 }, { 7, 1876, 2048 }, {
11001:../src/wolfcrypt/src/ecc.c ****    { 7, 1880, 2048 }, { 8, 1881, 2048 }, { 8, 1882, 2048 }, { 9, 1883, 2048 }, { 8, 1884, 2048 }, {
11002:../src/wolfcrypt/src/ecc.c ****    { 6, 1888, 2048 }, { 7, 1889, 2048 }, { 7, 1890, 2048 }, { 8, 1891, 2048 }, { 7, 1892, 2048 }, {
11003:../src/wolfcrypt/src/ecc.c ****    { 7, 1896, 2048 }, { 8, 1897, 2048 }, { 8, 1898, 2048 }, { 9, 1899, 2048 }, { 8, 1900, 2048 }, {
11004:../src/wolfcrypt/src/ecc.c ****    { 7, 1904, 2048 }, { 8, 1905, 2048 }, { 8, 1906, 2048 }, { 9, 1907, 2048 }, { 8, 1908, 2048 }, {
11005:../src/wolfcrypt/src/ecc.c ****    { 8, 1912, 2048 }, { 9, 1913, 2048 }, { 9, 1914, 2048 }, { 10, 1915, 2048 }, { 9, 1916, 2048 }, 
11006:../src/wolfcrypt/src/ecc.c ****    { 5, 1920, 2048 }, { 6, 1921, 2048 }, { 6, 1922, 2048 }, { 7, 1923, 2048 }, { 6, 1924, 2048 }, {
11007:../src/wolfcrypt/src/ecc.c ****    { 6, 1928, 2048 }, { 7, 1929, 2048 }, { 7, 1930, 2048 }, { 8, 1931, 2048 }, { 7, 1932, 2048 }, {
11008:../src/wolfcrypt/src/ecc.c ****    { 6, 1936, 2048 }, { 7, 1937, 2048 }, { 7, 1938, 2048 }, { 8, 1939, 2048 }, { 7, 1940, 2048 }, {
11009:../src/wolfcrypt/src/ecc.c ****    { 7, 1944, 2048 }, { 8, 1945, 2048 }, { 8, 1946, 2048 }, { 9, 1947, 2048 }, { 8, 1948, 2048 }, {
11010:../src/wolfcrypt/src/ecc.c ****    { 6, 1952, 2048 }, { 7, 1953, 2048 }, { 7, 1954, 2048 }, { 8, 1955, 2048 }, { 7, 1956, 2048 }, {
11011:../src/wolfcrypt/src/ecc.c ****    { 7, 1960, 2048 }, { 8, 1961, 2048 }, { 8, 1962, 2048 }, { 9, 1963, 2048 }, { 8, 1964, 2048 }, {
11012:../src/wolfcrypt/src/ecc.c ****    { 7, 1968, 2048 }, { 8, 1969, 2048 }, { 8, 1970, 2048 }, { 9, 1971, 2048 }, { 8, 1972, 2048 }, {
11013:../src/wolfcrypt/src/ecc.c ****    { 8, 1976, 2048 }, { 9, 1977, 2048 }, { 9, 1978, 2048 }, { 10, 1979, 2048 }, { 9, 1980, 2048 }, 
11014:../src/wolfcrypt/src/ecc.c ****    { 6, 1984, 2048 }, { 7, 1985, 2048 }, { 7, 1986, 2048 }, { 8, 1987, 2048 }, { 7, 1988, 2048 }, {
11015:../src/wolfcrypt/src/ecc.c ****    { 7, 1992, 2048 }, { 8, 1993, 2048 }, { 8, 1994, 2048 }, { 9, 1995, 2048 }, { 8, 1996, 2048 }, {
11016:../src/wolfcrypt/src/ecc.c ****    { 7, 2000, 2048 }, { 8, 2001, 2048 }, { 8, 2002, 2048 }, { 9, 2003, 2048 }, { 8, 2004, 2048 }, {
11017:../src/wolfcrypt/src/ecc.c ****    { 8, 2008, 2048 }, { 9, 2009, 2048 }, { 9, 2010, 2048 }, { 10, 2011, 2048 }, { 9, 2012, 2048 }, 
11018:../src/wolfcrypt/src/ecc.c ****    { 7, 2016, 2048 }, { 8, 2017, 2048 }, { 8, 2018, 2048 }, { 9, 2019, 2048 }, { 8, 2020, 2048 }, {
11019:../src/wolfcrypt/src/ecc.c ****    { 8, 2024, 2048 }, { 9, 2025, 2048 }, { 9, 2026, 2048 }, { 10, 2027, 2048 }, { 9, 2028, 2048 }, 
11020:../src/wolfcrypt/src/ecc.c ****    { 8, 2032, 2048 }, { 9, 2033, 2048 }, { 9, 2034, 2048 }, { 10, 2035, 2048 }, { 9, 2036, 2048 }, 
11021:../src/wolfcrypt/src/ecc.c ****    { 9, 2040, 2048 }, { 10, 2041, 2048 }, { 10, 2042, 2048 }, { 11, 2043, 2048 }, { 10, 2044, 2048 
11022:../src/wolfcrypt/src/ecc.c **** #endif
11023:../src/wolfcrypt/src/ecc.c **** #endif
11024:../src/wolfcrypt/src/ecc.c **** #endif
11025:../src/wolfcrypt/src/ecc.c **** #endif
11026:../src/wolfcrypt/src/ecc.c **** #endif
11027:../src/wolfcrypt/src/ecc.c **** #endif
11028:../src/wolfcrypt/src/ecc.c **** };
11029:../src/wolfcrypt/src/ecc.c **** 
11030:../src/wolfcrypt/src/ecc.c **** 
11031:../src/wolfcrypt/src/ecc.c **** /* find a hole and free as required, return -1 if no hole found */
11032:../src/wolfcrypt/src/ecc.c **** static int find_hole(void)
11033:../src/wolfcrypt/src/ecc.c **** {
11034:../src/wolfcrypt/src/ecc.c ****    unsigned x;
11035:../src/wolfcrypt/src/ecc.c ****    int      y, z;
11036:../src/wolfcrypt/src/ecc.c ****    for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
11037:../src/wolfcrypt/src/ecc.c ****        if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
11038:../src/wolfcrypt/src/ecc.c ****           z = x;
11039:../src/wolfcrypt/src/ecc.c ****           y = fp_cache[x].lru_count;
11040:../src/wolfcrypt/src/ecc.c ****        }
11041:../src/wolfcrypt/src/ecc.c ****    }
11042:../src/wolfcrypt/src/ecc.c **** 
11043:../src/wolfcrypt/src/ecc.c ****    /* decrease all */
11044:../src/wolfcrypt/src/ecc.c ****    for (x = 0; x < FP_ENTRIES; x++) {
11045:../src/wolfcrypt/src/ecc.c ****       if (fp_cache[x].lru_count > 3) {
11046:../src/wolfcrypt/src/ecc.c ****          --(fp_cache[x].lru_count);
11047:../src/wolfcrypt/src/ecc.c ****       }
11048:../src/wolfcrypt/src/ecc.c ****    }
11049:../src/wolfcrypt/src/ecc.c **** 
11050:../src/wolfcrypt/src/ecc.c ****    /* free entry z */
11051:../src/wolfcrypt/src/ecc.c ****    if (z >= 0 && fp_cache[z].g) {
11052:../src/wolfcrypt/src/ecc.c ****       mp_clear(&fp_cache[z].mu);
11053:../src/wolfcrypt/src/ecc.c ****       wc_ecc_del_point(fp_cache[z].g);
11054:../src/wolfcrypt/src/ecc.c ****       fp_cache[z].g  = NULL;
11055:../src/wolfcrypt/src/ecc.c ****       for (x = 0; x < (1U<<FP_LUT); x++) {
11056:../src/wolfcrypt/src/ecc.c ****          wc_ecc_del_point(fp_cache[z].LUT[x]);
11057:../src/wolfcrypt/src/ecc.c ****          fp_cache[z].LUT[x] = NULL;
11058:../src/wolfcrypt/src/ecc.c ****       }
11059:../src/wolfcrypt/src/ecc.c ****       fp_cache[z].LUT_set = 0;
11060:../src/wolfcrypt/src/ecc.c ****       fp_cache[z].lru_count = 0;
11061:../src/wolfcrypt/src/ecc.c ****    }
11062:../src/wolfcrypt/src/ecc.c ****    return z;
11063:../src/wolfcrypt/src/ecc.c **** }
11064:../src/wolfcrypt/src/ecc.c **** 
11065:../src/wolfcrypt/src/ecc.c **** /* determine if a base is already in the cache and if so, where */
11066:../src/wolfcrypt/src/ecc.c **** static int find_base(ecc_point* g)
11067:../src/wolfcrypt/src/ecc.c **** {
11068:../src/wolfcrypt/src/ecc.c ****    int x;
11069:../src/wolfcrypt/src/ecc.c ****    for (x = 0; x < FP_ENTRIES; x++) {
11070:../src/wolfcrypt/src/ecc.c ****       if (fp_cache[x].g != NULL &&
11071:../src/wolfcrypt/src/ecc.c ****           mp_cmp(fp_cache[x].g->x, g->x) == MP_EQ &&
11072:../src/wolfcrypt/src/ecc.c ****           mp_cmp(fp_cache[x].g->y, g->y) == MP_EQ &&
11073:../src/wolfcrypt/src/ecc.c ****           mp_cmp(fp_cache[x].g->z, g->z) == MP_EQ) {
11074:../src/wolfcrypt/src/ecc.c ****          break;
11075:../src/wolfcrypt/src/ecc.c ****       }
11076:../src/wolfcrypt/src/ecc.c ****    }
11077:../src/wolfcrypt/src/ecc.c ****    if (x == FP_ENTRIES) {
11078:../src/wolfcrypt/src/ecc.c ****       x = -1;
11079:../src/wolfcrypt/src/ecc.c ****    }
11080:../src/wolfcrypt/src/ecc.c ****    return x;
11081:../src/wolfcrypt/src/ecc.c **** }
11082:../src/wolfcrypt/src/ecc.c **** 
11083:../src/wolfcrypt/src/ecc.c **** /* add a new base to the cache */
11084:../src/wolfcrypt/src/ecc.c **** static int add_entry(int idx, ecc_point *g)
11085:../src/wolfcrypt/src/ecc.c **** {
11086:../src/wolfcrypt/src/ecc.c ****    unsigned x, y;
11087:../src/wolfcrypt/src/ecc.c **** 
11088:../src/wolfcrypt/src/ecc.c ****    /* allocate base and LUT */
11089:../src/wolfcrypt/src/ecc.c ****    fp_cache[idx].g = wc_ecc_new_point();
11090:../src/wolfcrypt/src/ecc.c ****    if (fp_cache[idx].g == NULL) {
11091:../src/wolfcrypt/src/ecc.c ****       return GEN_MEM_ERR;
11092:../src/wolfcrypt/src/ecc.c ****    }
11093:../src/wolfcrypt/src/ecc.c **** 
11094:../src/wolfcrypt/src/ecc.c ****    /* copy x and y */
11095:../src/wolfcrypt/src/ecc.c ****    if ((mp_copy(g->x, fp_cache[idx].g->x) != MP_OKAY) ||
11096:../src/wolfcrypt/src/ecc.c ****        (mp_copy(g->y, fp_cache[idx].g->y) != MP_OKAY) ||
11097:../src/wolfcrypt/src/ecc.c ****        (mp_copy(g->z, fp_cache[idx].g->z) != MP_OKAY)) {
11098:../src/wolfcrypt/src/ecc.c ****       wc_ecc_del_point(fp_cache[idx].g);
11099:../src/wolfcrypt/src/ecc.c ****       fp_cache[idx].g = NULL;
11100:../src/wolfcrypt/src/ecc.c ****       return GEN_MEM_ERR;
11101:../src/wolfcrypt/src/ecc.c ****    }
11102:../src/wolfcrypt/src/ecc.c **** 
11103:../src/wolfcrypt/src/ecc.c ****    for (x = 0; x < (1U<<FP_LUT); x++) {
11104:../src/wolfcrypt/src/ecc.c ****       fp_cache[idx].LUT[x] = wc_ecc_new_point();
11105:../src/wolfcrypt/src/ecc.c ****       if (fp_cache[idx].LUT[x] == NULL) {
11106:../src/wolfcrypt/src/ecc.c ****          for (y = 0; y < x; y++) {
11107:../src/wolfcrypt/src/ecc.c ****             wc_ecc_del_point(fp_cache[idx].LUT[y]);
11108:../src/wolfcrypt/src/ecc.c ****             fp_cache[idx].LUT[y] = NULL;
11109:../src/wolfcrypt/src/ecc.c ****          }
11110:../src/wolfcrypt/src/ecc.c ****          wc_ecc_del_point(fp_cache[idx].g);
11111:../src/wolfcrypt/src/ecc.c ****          fp_cache[idx].g         = NULL;
11112:../src/wolfcrypt/src/ecc.c ****          fp_cache[idx].lru_count = 0;
11113:../src/wolfcrypt/src/ecc.c ****          return GEN_MEM_ERR;
11114:../src/wolfcrypt/src/ecc.c ****       }
11115:../src/wolfcrypt/src/ecc.c ****    }
11116:../src/wolfcrypt/src/ecc.c **** 
11117:../src/wolfcrypt/src/ecc.c ****    fp_cache[idx].LUT_set   = 0;
11118:../src/wolfcrypt/src/ecc.c ****    fp_cache[idx].lru_count = 0;
11119:../src/wolfcrypt/src/ecc.c **** 
11120:../src/wolfcrypt/src/ecc.c ****    return MP_OKAY;
11121:../src/wolfcrypt/src/ecc.c **** }
11122:../src/wolfcrypt/src/ecc.c **** #endif
11123:../src/wolfcrypt/src/ecc.c **** 
11124:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
11125:../src/wolfcrypt/src/ecc.c **** /* build the LUT by spacing the bits of the input by #modulus/FP_LUT bits apart
11126:../src/wolfcrypt/src/ecc.c ****  *
11127:../src/wolfcrypt/src/ecc.c ****  * The algorithm builds patterns in increasing bit order by first making all
11128:../src/wolfcrypt/src/ecc.c ****  * single bit input patterns, then all two bit input patterns and so on
11129:../src/wolfcrypt/src/ecc.c ****  */
11130:../src/wolfcrypt/src/ecc.c **** static int build_lut(int idx, mp_int* a, mp_int* modulus, mp_digit mp,
11131:../src/wolfcrypt/src/ecc.c ****     mp_int* mu)
11132:../src/wolfcrypt/src/ecc.c **** {
11133:../src/wolfcrypt/src/ecc.c ****    int err;
11134:../src/wolfcrypt/src/ecc.c ****    unsigned x, y, bitlen, lut_gap;
11135:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11136:../src/wolfcrypt/src/ecc.c ****    mp_int *tmp = NULL;
11137:../src/wolfcrypt/src/ecc.c **** #else
11138:../src/wolfcrypt/src/ecc.c ****    mp_int tmp[1];
11139:../src/wolfcrypt/src/ecc.c **** #endif
11140:../src/wolfcrypt/src/ecc.c ****    int infinity;
11141:../src/wolfcrypt/src/ecc.c **** 
11142:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11143:../src/wolfcrypt/src/ecc.c ****    if ((tmp = (mp_int *)XMALLOC(sizeof(*tmp), NULL, DYNAMIC_TYPE_ECC_BUFFER)) == NULL)
11144:../src/wolfcrypt/src/ecc.c ****        return MEMORY_E;
11145:../src/wolfcrypt/src/ecc.c **** #endif
11146:../src/wolfcrypt/src/ecc.c **** 
11147:../src/wolfcrypt/src/ecc.c ****    err = mp_init(tmp);
11148:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY) {
11149:../src/wolfcrypt/src/ecc.c ****        err = GEN_MEM_ERR;
11150:../src/wolfcrypt/src/ecc.c ****        goto errout;
11151:../src/wolfcrypt/src/ecc.c ****    }
11152:../src/wolfcrypt/src/ecc.c **** 
11153:../src/wolfcrypt/src/ecc.c ****    /* sanity check to make sure lut_order table is of correct size,
11154:../src/wolfcrypt/src/ecc.c ****       should compile out to a NOP if true */
11155:../src/wolfcrypt/src/ecc.c ****    if ((sizeof(lut_orders) / sizeof(lut_orders[0])) < (1U<<FP_LUT)) {
11156:../src/wolfcrypt/src/ecc.c ****        err = BAD_FUNC_ARG;
11157:../src/wolfcrypt/src/ecc.c ****        goto errout;
11158:../src/wolfcrypt/src/ecc.c ****    }
11159:../src/wolfcrypt/src/ecc.c **** 
11160:../src/wolfcrypt/src/ecc.c ****    /* get bitlen and round up to next multiple of FP_LUT */
11161:../src/wolfcrypt/src/ecc.c ****    bitlen  = mp_unsigned_bin_size(modulus) << 3;
11162:../src/wolfcrypt/src/ecc.c ****    x       = bitlen % FP_LUT;
11163:../src/wolfcrypt/src/ecc.c ****    if (x) {
11164:../src/wolfcrypt/src/ecc.c ****        bitlen += FP_LUT - x;
11165:../src/wolfcrypt/src/ecc.c ****    }
11166:../src/wolfcrypt/src/ecc.c ****    lut_gap = bitlen / FP_LUT;
11167:../src/wolfcrypt/src/ecc.c **** 
11168:../src/wolfcrypt/src/ecc.c ****    /* init the mu */
11169:../src/wolfcrypt/src/ecc.c ****    err = mp_init_copy(&fp_cache[idx].mu, mu);
11170:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY)
11171:../src/wolfcrypt/src/ecc.c ****        goto errout;
11172:../src/wolfcrypt/src/ecc.c **** 
11173:../src/wolfcrypt/src/ecc.c ****    /* copy base */
11174:../src/wolfcrypt/src/ecc.c ****    if ((mp_mulmod(fp_cache[idx].g->x, mu, modulus,
11175:../src/wolfcrypt/src/ecc.c ****                   fp_cache[idx].LUT[1]->x) != MP_OKAY) ||
11176:../src/wolfcrypt/src/ecc.c ****        (mp_mulmod(fp_cache[idx].g->y, mu, modulus,
11177:../src/wolfcrypt/src/ecc.c ****                   fp_cache[idx].LUT[1]->y) != MP_OKAY) ||
11178:../src/wolfcrypt/src/ecc.c ****        (mp_mulmod(fp_cache[idx].g->z, mu, modulus,
11179:../src/wolfcrypt/src/ecc.c ****                   fp_cache[idx].LUT[1]->z) != MP_OKAY)) {
11180:../src/wolfcrypt/src/ecc.c ****        err = MP_MULMOD_E;
11181:../src/wolfcrypt/src/ecc.c ****        goto errout;
11182:../src/wolfcrypt/src/ecc.c ****    }
11183:../src/wolfcrypt/src/ecc.c **** 
11184:../src/wolfcrypt/src/ecc.c ****    /* make all single bit entries */
11185:../src/wolfcrypt/src/ecc.c ****    for (x = 1; x < FP_LUT; x++) {
11186:../src/wolfcrypt/src/ecc.c ****       if ((mp_copy(fp_cache[idx].LUT[1<<(x-1)]->x,
11187:../src/wolfcrypt/src/ecc.c ****                    fp_cache[idx].LUT[1<<x]->x) != MP_OKAY) ||
11188:../src/wolfcrypt/src/ecc.c ****           (mp_copy(fp_cache[idx].LUT[1<<(x-1)]->y,
11189:../src/wolfcrypt/src/ecc.c ****                    fp_cache[idx].LUT[1<<x]->y) != MP_OKAY) ||
11190:../src/wolfcrypt/src/ecc.c ****           (mp_copy(fp_cache[idx].LUT[1<<(x-1)]->z,
11191:../src/wolfcrypt/src/ecc.c ****                    fp_cache[idx].LUT[1<<x]->z) != MP_OKAY)){
11192:../src/wolfcrypt/src/ecc.c ****           err = MP_INIT_E;
11193:../src/wolfcrypt/src/ecc.c ****           goto errout;
11194:../src/wolfcrypt/src/ecc.c ****       } else {
11195:../src/wolfcrypt/src/ecc.c **** 
11196:../src/wolfcrypt/src/ecc.c ****          /* now double it bitlen/FP_LUT times */
11197:../src/wolfcrypt/src/ecc.c ****          for (y = 0; y < lut_gap; y++) {
11198:../src/wolfcrypt/src/ecc.c ****              if ((err = ecc_projective_dbl_point_safe(fp_cache[idx].LUT[1<<x],
11199:../src/wolfcrypt/src/ecc.c ****                             fp_cache[idx].LUT[1<<x], a, modulus, mp)) != MP_OKAY) {
11200:../src/wolfcrypt/src/ecc.c ****                  goto errout;
11201:../src/wolfcrypt/src/ecc.c ****              }
11202:../src/wolfcrypt/src/ecc.c ****          }
11203:../src/wolfcrypt/src/ecc.c ****      }
11204:../src/wolfcrypt/src/ecc.c ****   }
11205:../src/wolfcrypt/src/ecc.c **** 
11206:../src/wolfcrypt/src/ecc.c ****    /* now make all entries in increase order of hamming weight */
11207:../src/wolfcrypt/src/ecc.c ****    for (x = 2; x <= FP_LUT; x++) {
11208:../src/wolfcrypt/src/ecc.c ****        if (err != MP_OKAY)
11209:../src/wolfcrypt/src/ecc.c ****            goto errout;
11210:../src/wolfcrypt/src/ecc.c ****        for (y = 0; y < (1UL<<FP_LUT); y++) {
11211:../src/wolfcrypt/src/ecc.c ****            if (lut_orders[y].ham != (int)x) continue;
11212:../src/wolfcrypt/src/ecc.c **** 
11213:../src/wolfcrypt/src/ecc.c ****            /* perform the add */
11214:../src/wolfcrypt/src/ecc.c ****            if ((err = ecc_projective_add_point_safe(
11215:../src/wolfcrypt/src/ecc.c ****                            fp_cache[idx].LUT[lut_orders[y].terma],
11216:../src/wolfcrypt/src/ecc.c ****                            fp_cache[idx].LUT[lut_orders[y].termb],
11217:../src/wolfcrypt/src/ecc.c ****                            fp_cache[idx].LUT[y], a, modulus, mp,
11218:../src/wolfcrypt/src/ecc.c ****                            &infinity)) != MP_OKAY) {
11219:../src/wolfcrypt/src/ecc.c ****                goto errout;
11220:../src/wolfcrypt/src/ecc.c ****            }
11221:../src/wolfcrypt/src/ecc.c ****        }
11222:../src/wolfcrypt/src/ecc.c ****    }
11223:../src/wolfcrypt/src/ecc.c **** 
11224:../src/wolfcrypt/src/ecc.c ****    /* now map all entries back to affine space to make point addition faster */
11225:../src/wolfcrypt/src/ecc.c ****    for (x = 1; x < (1UL<<FP_LUT); x++) {
11226:../src/wolfcrypt/src/ecc.c ****        if (err != MP_OKAY)
11227:../src/wolfcrypt/src/ecc.c ****            break;
11228:../src/wolfcrypt/src/ecc.c **** 
11229:../src/wolfcrypt/src/ecc.c ****        /* convert z to normal from montgomery */
11230:../src/wolfcrypt/src/ecc.c ****        err = mp_montgomery_reduce(fp_cache[idx].LUT[x]->z, modulus, mp);
11231:../src/wolfcrypt/src/ecc.c **** 
11232:../src/wolfcrypt/src/ecc.c ****        /* invert it */
11233:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY)
11234:../src/wolfcrypt/src/ecc.c ****          err = mp_invmod(fp_cache[idx].LUT[x]->z, modulus,
11235:../src/wolfcrypt/src/ecc.c ****                          fp_cache[idx].LUT[x]->z);
11236:../src/wolfcrypt/src/ecc.c **** 
11237:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY)
11238:../src/wolfcrypt/src/ecc.c ****          /* now square it */
11239:../src/wolfcrypt/src/ecc.c ****          err = mp_sqrmod(fp_cache[idx].LUT[x]->z, modulus, tmp);
11240:../src/wolfcrypt/src/ecc.c **** 
11241:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY)
11242:../src/wolfcrypt/src/ecc.c ****          /* fix x */
11243:../src/wolfcrypt/src/ecc.c ****          err = mp_mulmod(fp_cache[idx].LUT[x]->x, tmp, modulus,
11244:../src/wolfcrypt/src/ecc.c ****                          fp_cache[idx].LUT[x]->x);
11245:../src/wolfcrypt/src/ecc.c **** 
11246:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY)
11247:../src/wolfcrypt/src/ecc.c ****          /* get 1/z^3 */
11248:../src/wolfcrypt/src/ecc.c ****          err = mp_mulmod(tmp, fp_cache[idx].LUT[x]->z, modulus, tmp);
11249:../src/wolfcrypt/src/ecc.c **** 
11250:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY)
11251:../src/wolfcrypt/src/ecc.c ****          /* fix y */
11252:../src/wolfcrypt/src/ecc.c ****          err = mp_mulmod(fp_cache[idx].LUT[x]->y, tmp, modulus,
11253:../src/wolfcrypt/src/ecc.c ****                          fp_cache[idx].LUT[x]->y);
11254:../src/wolfcrypt/src/ecc.c **** 
11255:../src/wolfcrypt/src/ecc.c ****        if (err == MP_OKAY)
11256:../src/wolfcrypt/src/ecc.c ****          /* free z */
11257:../src/wolfcrypt/src/ecc.c ****          mp_clear(fp_cache[idx].LUT[x]->z);
11258:../src/wolfcrypt/src/ecc.c ****    }
11259:../src/wolfcrypt/src/ecc.c **** 
11260:../src/wolfcrypt/src/ecc.c ****   errout:
11261:../src/wolfcrypt/src/ecc.c **** 
11262:../src/wolfcrypt/src/ecc.c ****    mp_clear(tmp);
11263:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11264:../src/wolfcrypt/src/ecc.c ****    XFREE(tmp, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11265:../src/wolfcrypt/src/ecc.c **** #endif
11266:../src/wolfcrypt/src/ecc.c **** 
11267:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
11268:../src/wolfcrypt/src/ecc.c ****        fp_cache[idx].LUT_set = 1;
11269:../src/wolfcrypt/src/ecc.c ****        return MP_OKAY;
11270:../src/wolfcrypt/src/ecc.c ****    }
11271:../src/wolfcrypt/src/ecc.c **** 
11272:../src/wolfcrypt/src/ecc.c ****    /* err cleanup */
11273:../src/wolfcrypt/src/ecc.c ****    for (y = 0; y < (1U<<FP_LUT); y++) {
11274:../src/wolfcrypt/src/ecc.c ****       wc_ecc_del_point(fp_cache[idx].LUT[y]);
11275:../src/wolfcrypt/src/ecc.c ****       fp_cache[idx].LUT[y] = NULL;
11276:../src/wolfcrypt/src/ecc.c ****    }
11277:../src/wolfcrypt/src/ecc.c ****    wc_ecc_del_point(fp_cache[idx].g);
11278:../src/wolfcrypt/src/ecc.c ****    fp_cache[idx].g         = NULL;
11279:../src/wolfcrypt/src/ecc.c ****    fp_cache[idx].LUT_set   = 0;
11280:../src/wolfcrypt/src/ecc.c ****    fp_cache[idx].lru_count = 0;
11281:../src/wolfcrypt/src/ecc.c ****    mp_clear(&fp_cache[idx].mu);
11282:../src/wolfcrypt/src/ecc.c **** 
11283:../src/wolfcrypt/src/ecc.c ****    return err;
11284:../src/wolfcrypt/src/ecc.c **** }
11285:../src/wolfcrypt/src/ecc.c **** 
11286:../src/wolfcrypt/src/ecc.c **** /* perform a fixed point ECC mulmod */
11287:../src/wolfcrypt/src/ecc.c **** static int accel_fp_mul(int idx, const mp_int* k, ecc_point *R, mp_int* a,
11288:../src/wolfcrypt/src/ecc.c ****                         mp_int* modulus, mp_digit mp, int map)
11289:../src/wolfcrypt/src/ecc.c **** {
11290:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFCRYPT_HAVE_SAKKE
11291:../src/wolfcrypt/src/ecc.c ****     #define KB_SIZE 256
11292:../src/wolfcrypt/src/ecc.c **** #else
11293:../src/wolfcrypt/src/ecc.c ****     #define KB_SIZE 128
11294:../src/wolfcrypt/src/ecc.c **** #endif
11295:../src/wolfcrypt/src/ecc.c **** 
11296:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11297:../src/wolfcrypt/src/ecc.c ****    unsigned char* kb = NULL;
11298:../src/wolfcrypt/src/ecc.c ****    mp_int*        tk = NULL;
11299:../src/wolfcrypt/src/ecc.c ****    mp_int*        order = NULL;
11300:../src/wolfcrypt/src/ecc.c **** #else
11301:../src/wolfcrypt/src/ecc.c ****    unsigned char kb[KB_SIZE];
11302:../src/wolfcrypt/src/ecc.c ****    mp_int        tk[1];
11303:../src/wolfcrypt/src/ecc.c ****    mp_int        order[1];
11304:../src/wolfcrypt/src/ecc.c **** #endif
11305:../src/wolfcrypt/src/ecc.c ****    int      x, err;
11306:../src/wolfcrypt/src/ecc.c ****    unsigned y, z = 0, bitlen, bitpos, lut_gap;
11307:../src/wolfcrypt/src/ecc.c ****    int first;
11308:../src/wolfcrypt/src/ecc.c **** 
11309:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11310:../src/wolfcrypt/src/ecc.c ****    tk = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
11311:../src/wolfcrypt/src/ecc.c ****    if (tk == NULL) {
11312:../src/wolfcrypt/src/ecc.c ****       err = MEMORY_E; goto done;
11313:../src/wolfcrypt/src/ecc.c ****    }
11314:../src/wolfcrypt/src/ecc.c ****    order = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
11315:../src/wolfcrypt/src/ecc.c ****    if (order == NULL) {
11316:../src/wolfcrypt/src/ecc.c ****       err = MEMORY_E; goto done;
11317:../src/wolfcrypt/src/ecc.c ****    }
11318:../src/wolfcrypt/src/ecc.c **** #endif
11319:../src/wolfcrypt/src/ecc.c **** 
11320:../src/wolfcrypt/src/ecc.c ****    if (mp_init_multi(tk, order, NULL, NULL, NULL, NULL) != MP_OKAY) {
11321:../src/wolfcrypt/src/ecc.c ****        err = MP_INIT_E; goto done;
11322:../src/wolfcrypt/src/ecc.c ****    }
11323:../src/wolfcrypt/src/ecc.c **** 
11324:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_copy(k, tk)) != MP_OKAY)
11325:../src/wolfcrypt/src/ecc.c ****        goto done;
11326:../src/wolfcrypt/src/ecc.c **** 
11327:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
11328:../src/wolfcrypt/src/ecc.c ****    mp_memzero_add("accel_fp_mul tk", tk);
11329:../src/wolfcrypt/src/ecc.c **** #endif
11330:../src/wolfcrypt/src/ecc.c **** 
11331:../src/wolfcrypt/src/ecc.c ****    /* if it's smaller than modulus we fine */
11332:../src/wolfcrypt/src/ecc.c ****    if (mp_unsigned_bin_size(k) > mp_unsigned_bin_size(modulus)) {
11333:../src/wolfcrypt/src/ecc.c ****       /* find order */
11334:../src/wolfcrypt/src/ecc.c ****       y = mp_unsigned_bin_size(modulus);
11335:../src/wolfcrypt/src/ecc.c ****       for (x = 0; ecc_sets[x].size; x++) {
11336:../src/wolfcrypt/src/ecc.c ****          if (y <= (unsigned)ecc_sets[x].size) break;
11337:../src/wolfcrypt/src/ecc.c ****       }
11338:../src/wolfcrypt/src/ecc.c **** 
11339:../src/wolfcrypt/src/ecc.c ****       /* back off if we are on the 521 bit curve */
11340:../src/wolfcrypt/src/ecc.c ****       if (y == 66) --x;
11341:../src/wolfcrypt/src/ecc.c **** 
11342:../src/wolfcrypt/src/ecc.c ****       if ((err = mp_read_radix(order, ecc_sets[x].order,
11343:../src/wolfcrypt/src/ecc.c ****                                                 MP_RADIX_HEX)) != MP_OKAY) {
11344:../src/wolfcrypt/src/ecc.c ****          goto done;
11345:../src/wolfcrypt/src/ecc.c ****       }
11346:../src/wolfcrypt/src/ecc.c **** 
11347:../src/wolfcrypt/src/ecc.c ****       /* k must be less than modulus */
11348:../src/wolfcrypt/src/ecc.c ****       if (mp_cmp(tk, order) != MP_LT) {
11349:../src/wolfcrypt/src/ecc.c ****          if ((err = mp_mod(tk, order, tk)) != MP_OKAY) {
11350:../src/wolfcrypt/src/ecc.c ****             goto done;
11351:../src/wolfcrypt/src/ecc.c ****          }
11352:../src/wolfcrypt/src/ecc.c ****       }
11353:../src/wolfcrypt/src/ecc.c ****    }
11354:../src/wolfcrypt/src/ecc.c **** 
11355:../src/wolfcrypt/src/ecc.c ****    /* get bitlen and round up to next multiple of FP_LUT */
11356:../src/wolfcrypt/src/ecc.c ****    bitlen  = mp_unsigned_bin_size(modulus) << 3;
11357:../src/wolfcrypt/src/ecc.c ****    x       = bitlen % FP_LUT;
11358:../src/wolfcrypt/src/ecc.c ****    if (x) {
11359:../src/wolfcrypt/src/ecc.c ****       bitlen += FP_LUT - x;
11360:../src/wolfcrypt/src/ecc.c ****    }
11361:../src/wolfcrypt/src/ecc.c ****    lut_gap = bitlen / FP_LUT;
11362:../src/wolfcrypt/src/ecc.c **** 
11363:../src/wolfcrypt/src/ecc.c ****    /* get the k value */
11364:../src/wolfcrypt/src/ecc.c ****    if (mp_unsigned_bin_size(tk) > (int)(KB_SIZE - 2)) {
11365:../src/wolfcrypt/src/ecc.c ****       err = BUFFER_E; goto done;
11366:../src/wolfcrypt/src/ecc.c ****    }
11367:../src/wolfcrypt/src/ecc.c **** 
11368:../src/wolfcrypt/src/ecc.c ****    /* store k */
11369:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11370:../src/wolfcrypt/src/ecc.c ****    kb = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11371:../src/wolfcrypt/src/ecc.c ****    if (kb == NULL) {
11372:../src/wolfcrypt/src/ecc.c ****       err = MEMORY_E; goto done;
11373:../src/wolfcrypt/src/ecc.c ****    }
11374:../src/wolfcrypt/src/ecc.c **** #endif
11375:../src/wolfcrypt/src/ecc.c **** 
11376:../src/wolfcrypt/src/ecc.c ****    XMEMSET(kb, 0, KB_SIZE);
11377:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_to_unsigned_bin(tk, kb)) == MP_OKAY) {
11378:../src/wolfcrypt/src/ecc.c ****    #ifdef WOLFSSL_CHECK_MEM_ZERO
11379:../src/wolfcrypt/src/ecc.c ****       wc_MemZero_Add("accel_fp_mul kb", kb, KB_SIZE);
11380:../src/wolfcrypt/src/ecc.c ****    #endif
11381:../src/wolfcrypt/src/ecc.c ****       /* let's reverse kb so it's little endian */
11382:../src/wolfcrypt/src/ecc.c ****       x = 0;
11383:../src/wolfcrypt/src/ecc.c ****       y = mp_unsigned_bin_size(tk);
11384:../src/wolfcrypt/src/ecc.c ****       if (y > 0) {
11385:../src/wolfcrypt/src/ecc.c ****           y -= 1;
11386:../src/wolfcrypt/src/ecc.c ****       }
11387:../src/wolfcrypt/src/ecc.c **** 
11388:../src/wolfcrypt/src/ecc.c ****       while ((unsigned)x < y) {
11389:../src/wolfcrypt/src/ecc.c ****          z = kb[x]; kb[x] = kb[y]; kb[y] = (byte)z;
11390:../src/wolfcrypt/src/ecc.c ****          ++x; --y;
11391:../src/wolfcrypt/src/ecc.c ****       }
11392:../src/wolfcrypt/src/ecc.c **** 
11393:../src/wolfcrypt/src/ecc.c ****       /* at this point we can start, yipee */
11394:../src/wolfcrypt/src/ecc.c ****       first = 1;
11395:../src/wolfcrypt/src/ecc.c ****       for (x = lut_gap-1; x >= 0; x--) {
11396:../src/wolfcrypt/src/ecc.c ****           /* extract FP_LUT bits from kb spread out by lut_gap bits and offset
11397:../src/wolfcrypt/src/ecc.c ****              by x bits from the start */
11398:../src/wolfcrypt/src/ecc.c ****           bitpos = x;
11399:../src/wolfcrypt/src/ecc.c ****           for (y = z = 0; y < FP_LUT; y++) {
11400:../src/wolfcrypt/src/ecc.c ****              z |= ((kb[bitpos>>3] >> (bitpos&7)) & 1) << y;
11401:../src/wolfcrypt/src/ecc.c ****              bitpos += lut_gap;  /* it's y*lut_gap + x, but here we can avoid
11402:../src/wolfcrypt/src/ecc.c ****                                     the mult in each loop */
11403:../src/wolfcrypt/src/ecc.c ****           }
11404:../src/wolfcrypt/src/ecc.c **** 
11405:../src/wolfcrypt/src/ecc.c ****           /* double if not first */
11406:../src/wolfcrypt/src/ecc.c ****           if (!first) {
11407:../src/wolfcrypt/src/ecc.c ****              if ((err = ecc_projective_dbl_point_safe(R, R, a, modulus,
11408:../src/wolfcrypt/src/ecc.c ****                                                               mp)) != MP_OKAY) {
11409:../src/wolfcrypt/src/ecc.c ****                 break;
11410:../src/wolfcrypt/src/ecc.c ****              }
11411:../src/wolfcrypt/src/ecc.c ****           }
11412:../src/wolfcrypt/src/ecc.c **** 
11413:../src/wolfcrypt/src/ecc.c ****           /* add if not first, otherwise copy */
11414:../src/wolfcrypt/src/ecc.c ****           if (!first && z) {
11415:../src/wolfcrypt/src/ecc.c ****              if ((err = ecc_projective_add_point_safe(R, fp_cache[idx].LUT[z],
11416:../src/wolfcrypt/src/ecc.c ****                                        R, a, modulus, mp, &first)) != MP_OKAY) {
11417:../src/wolfcrypt/src/ecc.c ****                 break;
11418:../src/wolfcrypt/src/ecc.c ****              }
11419:../src/wolfcrypt/src/ecc.c ****           } else if (z) {
11420:../src/wolfcrypt/src/ecc.c ****              if ((mp_copy(fp_cache[idx].LUT[z]->x, R->x) != MP_OKAY) ||
11421:../src/wolfcrypt/src/ecc.c ****                  (mp_copy(fp_cache[idx].LUT[z]->y, R->y) != MP_OKAY) ||
11422:../src/wolfcrypt/src/ecc.c ****                  (mp_copy(&fp_cache[idx].mu,       R->z) != MP_OKAY)) {
11423:../src/wolfcrypt/src/ecc.c ****                  err = GEN_MEM_ERR;
11424:../src/wolfcrypt/src/ecc.c ****                  break;
11425:../src/wolfcrypt/src/ecc.c ****              }
11426:../src/wolfcrypt/src/ecc.c ****              first = 0;
11427:../src/wolfcrypt/src/ecc.c ****           }
11428:../src/wolfcrypt/src/ecc.c ****       }
11429:../src/wolfcrypt/src/ecc.c ****    }
11430:../src/wolfcrypt/src/ecc.c **** 
11431:../src/wolfcrypt/src/ecc.c ****    if (err == MP_OKAY) {
11432:../src/wolfcrypt/src/ecc.c ****       (void) z; /* Acknowledge the unused assignment */
11433:../src/wolfcrypt/src/ecc.c ****       ForceZero(kb, KB_SIZE);
11434:../src/wolfcrypt/src/ecc.c **** 
11435:../src/wolfcrypt/src/ecc.c ****       /* map R back from projective space */
11436:../src/wolfcrypt/src/ecc.c ****       if (map) {
11437:../src/wolfcrypt/src/ecc.c ****          err = ecc_map(R, modulus, mp);
11438:../src/wolfcrypt/src/ecc.c ****       } else {
11439:../src/wolfcrypt/src/ecc.c ****          err = MP_OKAY;
11440:../src/wolfcrypt/src/ecc.c ****       }
11441:../src/wolfcrypt/src/ecc.c ****    }
11442:../src/wolfcrypt/src/ecc.c **** 
11443:../src/wolfcrypt/src/ecc.c **** done:
11444:../src/wolfcrypt/src/ecc.c ****    /* cleanup */
11445:../src/wolfcrypt/src/ecc.c ****    mp_clear(order);
11446:../src/wolfcrypt/src/ecc.c ****    mp_forcezero(tk);
11447:../src/wolfcrypt/src/ecc.c **** 
11448:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11449:../src/wolfcrypt/src/ecc.c ****    XFREE(kb, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11450:../src/wolfcrypt/src/ecc.c ****    XFREE(order, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11451:../src/wolfcrypt/src/ecc.c ****    XFREE(tk, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11452:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
11453:../src/wolfcrypt/src/ecc.c ****    wc_MemZero_Check(kb, KB_SIZE);
11454:../src/wolfcrypt/src/ecc.c ****    mp_memzero_check(tk);
11455:../src/wolfcrypt/src/ecc.c **** #endif
11456:../src/wolfcrypt/src/ecc.c **** 
11457:../src/wolfcrypt/src/ecc.c **** #undef KB_SIZE
11458:../src/wolfcrypt/src/ecc.c **** 
11459:../src/wolfcrypt/src/ecc.c ****    return err;
11460:../src/wolfcrypt/src/ecc.c **** }
11461:../src/wolfcrypt/src/ecc.c **** #endif
11462:../src/wolfcrypt/src/ecc.c **** 
11463:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_SHAMIR
11464:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
11465:../src/wolfcrypt/src/ecc.c **** /* perform a fixed point ECC mulmod */
11466:../src/wolfcrypt/src/ecc.c **** static int accel_fp_mul2add(int idx1, int idx2,
11467:../src/wolfcrypt/src/ecc.c ****                             mp_int* kA, mp_int* kB,
11468:../src/wolfcrypt/src/ecc.c ****                             ecc_point *R, mp_int* a,
11469:../src/wolfcrypt/src/ecc.c ****                             mp_int* modulus, mp_digit mp)
11470:../src/wolfcrypt/src/ecc.c **** {
11471:../src/wolfcrypt/src/ecc.c **** #define KB_SIZE 128
11472:../src/wolfcrypt/src/ecc.c **** 
11473:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11474:../src/wolfcrypt/src/ecc.c ****    unsigned char* kb[2] = {NULL, NULL};
11475:../src/wolfcrypt/src/ecc.c ****    mp_int*        tka = NULL;
11476:../src/wolfcrypt/src/ecc.c ****    mp_int*        tkb = NULL;
11477:../src/wolfcrypt/src/ecc.c ****    mp_int*        order = NULL;
11478:../src/wolfcrypt/src/ecc.c **** #else
11479:../src/wolfcrypt/src/ecc.c ****    unsigned char kb[2][KB_SIZE];
11480:../src/wolfcrypt/src/ecc.c ****    mp_int        tka[1];
11481:../src/wolfcrypt/src/ecc.c ****    mp_int        tkb[1];
11482:../src/wolfcrypt/src/ecc.c ****    mp_int        order[1];
11483:../src/wolfcrypt/src/ecc.c **** #endif
11484:../src/wolfcrypt/src/ecc.c ****    int      x, err;
11485:../src/wolfcrypt/src/ecc.c ****    unsigned y, z, bitlen, bitpos, lut_gap, zA, zB;
11486:../src/wolfcrypt/src/ecc.c ****    int first;
11487:../src/wolfcrypt/src/ecc.c **** 
11488:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11489:../src/wolfcrypt/src/ecc.c ****    tka = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
11490:../src/wolfcrypt/src/ecc.c ****    if (tka == NULL) {
11491:../src/wolfcrypt/src/ecc.c ****       err = MEMORY_E; goto done;
11492:../src/wolfcrypt/src/ecc.c ****    }
11493:../src/wolfcrypt/src/ecc.c ****    tkb = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
11494:../src/wolfcrypt/src/ecc.c ****    if (tkb == NULL) {
11495:../src/wolfcrypt/src/ecc.c ****       err = MEMORY_E; goto done;
11496:../src/wolfcrypt/src/ecc.c ****    }
11497:../src/wolfcrypt/src/ecc.c ****    order = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
11498:../src/wolfcrypt/src/ecc.c ****    if (order == NULL) {
11499:../src/wolfcrypt/src/ecc.c ****       err = MEMORY_E; goto done;
11500:../src/wolfcrypt/src/ecc.c ****    }
11501:../src/wolfcrypt/src/ecc.c **** #endif
11502:../src/wolfcrypt/src/ecc.c **** 
11503:../src/wolfcrypt/src/ecc.c ****    if (mp_init_multi(tka, tkb, order, NULL, NULL, NULL) != MP_OKAY) {
11504:../src/wolfcrypt/src/ecc.c ****       err = MP_INIT_E; goto done;
11505:../src/wolfcrypt/src/ecc.c ****    }
11506:../src/wolfcrypt/src/ecc.c **** 
11507:../src/wolfcrypt/src/ecc.c ****    /* if it's smaller than modulus we fine */
11508:../src/wolfcrypt/src/ecc.c ****    if (mp_unsigned_bin_size(kA) > mp_unsigned_bin_size(modulus)) {
11509:../src/wolfcrypt/src/ecc.c ****       /* find order */
11510:../src/wolfcrypt/src/ecc.c ****       y = mp_unsigned_bin_size(modulus);
11511:../src/wolfcrypt/src/ecc.c ****       for (x = 0; ecc_sets[x].size; x++) {
11512:../src/wolfcrypt/src/ecc.c ****          if (y <= (unsigned)ecc_sets[x].size) break;
11513:../src/wolfcrypt/src/ecc.c ****       }
11514:../src/wolfcrypt/src/ecc.c **** 
11515:../src/wolfcrypt/src/ecc.c ****       /* back off if we are on the 521 bit curve */
11516:../src/wolfcrypt/src/ecc.c ****       if (y == 66) --x;
11517:../src/wolfcrypt/src/ecc.c **** 
11518:../src/wolfcrypt/src/ecc.c ****       if ((err = mp_read_radix(order, ecc_sets[x].order,
11519:../src/wolfcrypt/src/ecc.c ****                                                 MP_RADIX_HEX)) != MP_OKAY) {
11520:../src/wolfcrypt/src/ecc.c ****          goto done;
11521:../src/wolfcrypt/src/ecc.c ****       }
11522:../src/wolfcrypt/src/ecc.c **** 
11523:../src/wolfcrypt/src/ecc.c ****       /* kA must be less than modulus */
11524:../src/wolfcrypt/src/ecc.c ****       if (mp_cmp(kA, order) != MP_LT) {
11525:../src/wolfcrypt/src/ecc.c ****          if ((err = mp_mod(kA, order, tka)) != MP_OKAY) {
11526:../src/wolfcrypt/src/ecc.c ****             goto done;
11527:../src/wolfcrypt/src/ecc.c ****          }
11528:../src/wolfcrypt/src/ecc.c ****       } else {
11529:../src/wolfcrypt/src/ecc.c ****          if ((err = mp_copy(kA, tka)) != MP_OKAY) {
11530:../src/wolfcrypt/src/ecc.c ****             goto done;
11531:../src/wolfcrypt/src/ecc.c ****          }
11532:../src/wolfcrypt/src/ecc.c ****       }
11533:../src/wolfcrypt/src/ecc.c ****    } else {
11534:../src/wolfcrypt/src/ecc.c ****       if ((err = mp_copy(kA, tka)) != MP_OKAY) {
11535:../src/wolfcrypt/src/ecc.c ****          goto done;
11536:../src/wolfcrypt/src/ecc.c ****       }
11537:../src/wolfcrypt/src/ecc.c ****    }
11538:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
11539:../src/wolfcrypt/src/ecc.c ****    mp_memzero_add("accel_fp_mul2add tka", tka);
11540:../src/wolfcrypt/src/ecc.c **** #endif
11541:../src/wolfcrypt/src/ecc.c **** 
11542:../src/wolfcrypt/src/ecc.c ****    /* if it's smaller than modulus we fine */
11543:../src/wolfcrypt/src/ecc.c ****    if (mp_unsigned_bin_size(kB) > mp_unsigned_bin_size(modulus)) {
11544:../src/wolfcrypt/src/ecc.c ****       /* find order */
11545:../src/wolfcrypt/src/ecc.c ****       y = mp_unsigned_bin_size(modulus);
11546:../src/wolfcrypt/src/ecc.c ****       for (x = 0; ecc_sets[x].size; x++) {
11547:../src/wolfcrypt/src/ecc.c ****          if (y <= (unsigned)ecc_sets[x].size) break;
11548:../src/wolfcrypt/src/ecc.c ****       }
11549:../src/wolfcrypt/src/ecc.c **** 
11550:../src/wolfcrypt/src/ecc.c ****       /* back off if we are on the 521 bit curve */
11551:../src/wolfcrypt/src/ecc.c ****       if (y == 66) --x;
11552:../src/wolfcrypt/src/ecc.c **** 
11553:../src/wolfcrypt/src/ecc.c ****       if ((err = mp_read_radix(order, ecc_sets[x].order,
11554:../src/wolfcrypt/src/ecc.c ****                                                 MP_RADIX_HEX)) != MP_OKAY) {
11555:../src/wolfcrypt/src/ecc.c ****          goto done;
11556:../src/wolfcrypt/src/ecc.c ****       }
11557:../src/wolfcrypt/src/ecc.c **** 
11558:../src/wolfcrypt/src/ecc.c ****       /* kB must be less than modulus */
11559:../src/wolfcrypt/src/ecc.c ****       if (mp_cmp(kB, order) != MP_LT) {
11560:../src/wolfcrypt/src/ecc.c ****          if ((err = mp_mod(kB, order, tkb)) != MP_OKAY) {
11561:../src/wolfcrypt/src/ecc.c ****             goto done;
11562:../src/wolfcrypt/src/ecc.c ****          }
11563:../src/wolfcrypt/src/ecc.c ****       } else {
11564:../src/wolfcrypt/src/ecc.c ****          if ((err = mp_copy(kB, tkb)) != MP_OKAY) {
11565:../src/wolfcrypt/src/ecc.c ****             goto done;
11566:../src/wolfcrypt/src/ecc.c ****          }
11567:../src/wolfcrypt/src/ecc.c ****       }
11568:../src/wolfcrypt/src/ecc.c ****    } else {
11569:../src/wolfcrypt/src/ecc.c ****       if ((err = mp_copy(kB, tkb)) != MP_OKAY) {
11570:../src/wolfcrypt/src/ecc.c ****          goto done;
11571:../src/wolfcrypt/src/ecc.c ****       }
11572:../src/wolfcrypt/src/ecc.c ****    }
11573:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
11574:../src/wolfcrypt/src/ecc.c ****    mp_memzero_add("accel_fp_mul2add tkb", tkb);
11575:../src/wolfcrypt/src/ecc.c **** #endif
11576:../src/wolfcrypt/src/ecc.c **** 
11577:../src/wolfcrypt/src/ecc.c ****    /* get bitlen and round up to next multiple of FP_LUT */
11578:../src/wolfcrypt/src/ecc.c ****    bitlen  = mp_unsigned_bin_size(modulus) << 3;
11579:../src/wolfcrypt/src/ecc.c ****    x       = bitlen % FP_LUT;
11580:../src/wolfcrypt/src/ecc.c ****    if (x) {
11581:../src/wolfcrypt/src/ecc.c ****       bitlen += FP_LUT - x;
11582:../src/wolfcrypt/src/ecc.c ****    }
11583:../src/wolfcrypt/src/ecc.c ****    lut_gap = bitlen / FP_LUT;
11584:../src/wolfcrypt/src/ecc.c **** 
11585:../src/wolfcrypt/src/ecc.c ****    /* get the k value */
11586:../src/wolfcrypt/src/ecc.c ****    if ((mp_unsigned_bin_size(tka) > (int)(KB_SIZE - 2)) ||
11587:../src/wolfcrypt/src/ecc.c ****        (mp_unsigned_bin_size(tkb) > (int)(KB_SIZE - 2))  ) {
11588:../src/wolfcrypt/src/ecc.c ****       err = BUFFER_E; goto done;
11589:../src/wolfcrypt/src/ecc.c ****    }
11590:../src/wolfcrypt/src/ecc.c **** 
11591:../src/wolfcrypt/src/ecc.c ****    /* store k */
11592:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11593:../src/wolfcrypt/src/ecc.c ****    kb[0] = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11594:../src/wolfcrypt/src/ecc.c ****    if (kb[0] == NULL) {
11595:../src/wolfcrypt/src/ecc.c ****       err = MEMORY_E; goto done;
11596:../src/wolfcrypt/src/ecc.c ****    }
11597:../src/wolfcrypt/src/ecc.c **** #endif
11598:../src/wolfcrypt/src/ecc.c **** 
11599:../src/wolfcrypt/src/ecc.c ****    XMEMSET(kb[0], 0, KB_SIZE);
11600:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_to_unsigned_bin(tka, kb[0])) != MP_OKAY) {
11601:../src/wolfcrypt/src/ecc.c ****       goto done;
11602:../src/wolfcrypt/src/ecc.c ****    }
11603:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
11604:../src/wolfcrypt/src/ecc.c ****    wc_MemZero_Add("accel_fp_mul2add kb[0]", kb[0], KB_SIZE);
11605:../src/wolfcrypt/src/ecc.c **** #endif
11606:../src/wolfcrypt/src/ecc.c **** 
11607:../src/wolfcrypt/src/ecc.c ****    /* let's reverse kb so it's little endian */
11608:../src/wolfcrypt/src/ecc.c ****    x = 0;
11609:../src/wolfcrypt/src/ecc.c ****    y = mp_unsigned_bin_size(tka);
11610:../src/wolfcrypt/src/ecc.c ****    if (y > 0) {
11611:../src/wolfcrypt/src/ecc.c ****        y -= 1;
11612:../src/wolfcrypt/src/ecc.c ****    }
11613:../src/wolfcrypt/src/ecc.c ****    mp_clear(tka);
11614:../src/wolfcrypt/src/ecc.c ****    while ((unsigned)x < y) {
11615:../src/wolfcrypt/src/ecc.c ****       z = kb[0][x]; kb[0][x] = kb[0][y]; kb[0][y] = (byte)z;
11616:../src/wolfcrypt/src/ecc.c ****       ++x; --y;
11617:../src/wolfcrypt/src/ecc.c ****    }
11618:../src/wolfcrypt/src/ecc.c **** 
11619:../src/wolfcrypt/src/ecc.c ****    /* store b */
11620:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11621:../src/wolfcrypt/src/ecc.c ****    kb[1] = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11622:../src/wolfcrypt/src/ecc.c ****    if (kb[1] == NULL) {
11623:../src/wolfcrypt/src/ecc.c ****       err = MEMORY_E; goto done;
11624:../src/wolfcrypt/src/ecc.c ****    }
11625:../src/wolfcrypt/src/ecc.c **** #endif
11626:../src/wolfcrypt/src/ecc.c **** 
11627:../src/wolfcrypt/src/ecc.c ****    XMEMSET(kb[1], 0, KB_SIZE);
11628:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_CHECK_MEM_ZERO
11629:../src/wolfcrypt/src/ecc.c ****    wc_MemZero_Add("accel_fp_mul2add kb[1]", kb[1], KB_SIZE);
11630:../src/wolfcrypt/src/ecc.c **** #endif
11631:../src/wolfcrypt/src/ecc.c ****    if ((err = mp_to_unsigned_bin(tkb, kb[1])) == MP_OKAY) {
11632:../src/wolfcrypt/src/ecc.c ****       x = 0;
11633:../src/wolfcrypt/src/ecc.c ****       y = mp_unsigned_bin_size(tkb);
11634:../src/wolfcrypt/src/ecc.c ****       if (y > 0) {
11635:../src/wolfcrypt/src/ecc.c ****           y -= 1;
11636:../src/wolfcrypt/src/ecc.c ****       }
11637:../src/wolfcrypt/src/ecc.c **** 
11638:../src/wolfcrypt/src/ecc.c ****       while ((unsigned)x < y) {
11639:../src/wolfcrypt/src/ecc.c ****          z = kb[1][x]; kb[1][x] = kb[1][y]; kb[1][y] = (byte)z;
11640:../src/wolfcrypt/src/ecc.c ****          ++x; --y;
11641:../src/wolfcrypt/src/ecc.c ****       }
11642:../src/wolfcrypt/src/ecc.c **** 
11643:../src/wolfcrypt/src/ecc.c ****       /* at this point we can start, yipee */
11644:../src/wolfcrypt/src/ecc.c ****       first = 1;
11645:../src/wolfcrypt/src/ecc.c ****       for (x = lut_gap-1; x >= 0; x--) {
11646:../src/wolfcrypt/src/ecc.c ****           /* extract FP_LUT bits from kb spread out by lut_gap bits and
11647:../src/wolfcrypt/src/ecc.c ****              offset by x bits from the start */
11648:../src/wolfcrypt/src/ecc.c ****           bitpos = x;
11649:../src/wolfcrypt/src/ecc.c ****           for (y = zA = zB = 0; y < FP_LUT; y++) {
11650:../src/wolfcrypt/src/ecc.c ****              zA |= ((kb[0][bitpos>>3] >> (bitpos&7)) & 1) << y;
11651:../src/wolfcrypt/src/ecc.c ****              zB |= ((kb[1][bitpos>>3] >> (bitpos&7)) & 1) << y;
11652:../src/wolfcrypt/src/ecc.c ****              bitpos += lut_gap;    /* it's y*lut_gap + x, but here we can avoid
11653:../src/wolfcrypt/src/ecc.c ****                                       the mult in each loop */
11654:../src/wolfcrypt/src/ecc.c ****           }
11655:../src/wolfcrypt/src/ecc.c **** 
11656:../src/wolfcrypt/src/ecc.c ****           /* double if not first */
11657:../src/wolfcrypt/src/ecc.c ****           if (!first) {
11658:../src/wolfcrypt/src/ecc.c ****              if ((err = ecc_projective_dbl_point_safe(R, R, a, modulus,
11659:../src/wolfcrypt/src/ecc.c ****                                                               mp)) != MP_OKAY) {
11660:../src/wolfcrypt/src/ecc.c ****                 break;
11661:../src/wolfcrypt/src/ecc.c ****              }
11662:../src/wolfcrypt/src/ecc.c **** 
11663:../src/wolfcrypt/src/ecc.c ****              /* add if not first, otherwise copy */
11664:../src/wolfcrypt/src/ecc.c ****              if (zA) {
11665:../src/wolfcrypt/src/ecc.c ****                 if ((err = ecc_projective_add_point_safe(R,
11666:../src/wolfcrypt/src/ecc.c ****                                              fp_cache[idx1].LUT[zA], R, a,
11667:../src/wolfcrypt/src/ecc.c ****                                              modulus, mp, &first)) != MP_OKAY) {
11668:../src/wolfcrypt/src/ecc.c ****                    break;
11669:../src/wolfcrypt/src/ecc.c ****                 }
11670:../src/wolfcrypt/src/ecc.c ****              }
11671:../src/wolfcrypt/src/ecc.c **** 
11672:../src/wolfcrypt/src/ecc.c ****              if (zB) {
11673:../src/wolfcrypt/src/ecc.c ****                 if ((err = ecc_projective_add_point_safe(R,
11674:../src/wolfcrypt/src/ecc.c ****                                              fp_cache[idx2].LUT[zB], R, a,
11675:../src/wolfcrypt/src/ecc.c ****                                              modulus, mp, &first)) != MP_OKAY) {
11676:../src/wolfcrypt/src/ecc.c ****                    break;
11677:../src/wolfcrypt/src/ecc.c ****                 }
11678:../src/wolfcrypt/src/ecc.c ****              }
11679:../src/wolfcrypt/src/ecc.c ****           } else {
11680:../src/wolfcrypt/src/ecc.c ****              if (zA) {
11681:../src/wolfcrypt/src/ecc.c ****                  if ((mp_copy(fp_cache[idx1].LUT[zA]->x, R->x) != MP_OKAY) ||
11682:../src/wolfcrypt/src/ecc.c ****                      (mp_copy(fp_cache[idx1].LUT[zA]->y, R->y) != MP_OKAY) ||
11683:../src/wolfcrypt/src/ecc.c ****                      (mp_copy(&fp_cache[idx1].mu,        R->z) != MP_OKAY)) {
11684:../src/wolfcrypt/src/ecc.c ****                      err = GEN_MEM_ERR;
11685:../src/wolfcrypt/src/ecc.c ****                      break;
11686:../src/wolfcrypt/src/ecc.c ****                  }
11687:../src/wolfcrypt/src/ecc.c ****                     first = 0;
11688:../src/wolfcrypt/src/ecc.c ****              }
11689:../src/wolfcrypt/src/ecc.c ****              if (zB && first == 0) {
11690:../src/wolfcrypt/src/ecc.c ****                 if ((err = ecc_projective_add_point_safe(R,
11691:../src/wolfcrypt/src/ecc.c ****                                         fp_cache[idx2].LUT[zB], R, a,
11692:../src/wolfcrypt/src/ecc.c ****                                         modulus, mp, &first)) != MP_OKAY){
11693:../src/wolfcrypt/src/ecc.c ****                    break;
11694:../src/wolfcrypt/src/ecc.c ****                 }
11695:../src/wolfcrypt/src/ecc.c ****              } else if (zB && first == 1) {
11696:../src/wolfcrypt/src/ecc.c ****                  if ((mp_copy(fp_cache[idx2].LUT[zB]->x, R->x) != MP_OKAY) ||
11697:../src/wolfcrypt/src/ecc.c ****                      (mp_copy(fp_cache[idx2].LUT[zB]->y, R->y) != MP_OKAY) ||
11698:../src/wolfcrypt/src/ecc.c ****                      (mp_copy(&fp_cache[idx2].mu,        R->z) != MP_OKAY)) {
11699:../src/wolfcrypt/src/ecc.c ****                      err = GEN_MEM_ERR;
11700:../src/wolfcrypt/src/ecc.c ****                      break;
11701:../src/wolfcrypt/src/ecc.c ****                  }
11702:../src/wolfcrypt/src/ecc.c ****                     first = 0;
11703:../src/wolfcrypt/src/ecc.c ****              }
11704:../src/wolfcrypt/src/ecc.c ****           }
11705:../src/wolfcrypt/src/ecc.c ****       }
11706:../src/wolfcrypt/src/ecc.c ****    }
11707:../src/wolfcrypt/src/ecc.c **** 
11708:../src/wolfcrypt/src/ecc.c **** done:
11709:../src/wolfcrypt/src/ecc.c ****    /* cleanup */
11710:../src/wolfcrypt/src/ecc.c ****    mp_forcezero(tkb);
11711:../src/wolfcrypt/src/ecc.c ****    mp_forcezero(tka);
11712:../src/wolfcrypt/src/ecc.c ****    mp_clear(order);
11713:../src/wolfcrypt/src/ecc.c **** 
11714:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11715:../src/wolfcrypt/src/ecc.c ****    if (kb[0])
11716:../src/wolfcrypt/src/ecc.c **** #endif
11717:../src/wolfcrypt/src/ecc.c ****       ForceZero(kb[0], KB_SIZE);
11718:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11719:../src/wolfcrypt/src/ecc.c ****    if (kb[1])
11720:../src/wolfcrypt/src/ecc.c **** #endif
11721:../src/wolfcrypt/src/ecc.c ****       ForceZero(kb[1], KB_SIZE);
11722:../src/wolfcrypt/src/ecc.c **** 
11723:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11724:../src/wolfcrypt/src/ecc.c ****    XFREE(kb[1], NULL, DYNAMIC_TYPE_ECC_BUFFER);
11725:../src/wolfcrypt/src/ecc.c ****    XFREE(kb[0], NULL, DYNAMIC_TYPE_ECC_BUFFER);
11726:../src/wolfcrypt/src/ecc.c ****    XFREE(order, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11727:../src/wolfcrypt/src/ecc.c ****    XFREE(tkb, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11728:../src/wolfcrypt/src/ecc.c ****    XFREE(tka, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11729:../src/wolfcrypt/src/ecc.c **** #elif defined(WOLFSSL_CHECK_MEM_ZERO)
11730:../src/wolfcrypt/src/ecc.c ****    wc_MemZero_Check(kb[1], KB_SIZE);
11731:../src/wolfcrypt/src/ecc.c ****    wc_MemZero_Check(kb[0], KB_SIZE);
11732:../src/wolfcrypt/src/ecc.c ****    mp_memzero_check(tkb);
11733:../src/wolfcrypt/src/ecc.c ****    mp_memzero_check(tka);
11734:../src/wolfcrypt/src/ecc.c **** #endif
11735:../src/wolfcrypt/src/ecc.c **** 
11736:../src/wolfcrypt/src/ecc.c **** #undef KB_SIZE
11737:../src/wolfcrypt/src/ecc.c **** 
11738:../src/wolfcrypt/src/ecc.c ****     if (err != MP_OKAY)
11739:../src/wolfcrypt/src/ecc.c ****         return err;
11740:../src/wolfcrypt/src/ecc.c **** 
11741:../src/wolfcrypt/src/ecc.c ****    return ecc_map(R, modulus, mp);
11742:../src/wolfcrypt/src/ecc.c **** }
11743:../src/wolfcrypt/src/ecc.c **** 
11744:../src/wolfcrypt/src/ecc.c **** 
11745:../src/wolfcrypt/src/ecc.c **** /** ECC Fixed Point mulmod global with heap hint used
11746:../src/wolfcrypt/src/ecc.c ****   Computes kA*A + kB*B = C using Shamir's Trick
11747:../src/wolfcrypt/src/ecc.c ****   A        First point to multiply
11748:../src/wolfcrypt/src/ecc.c ****   kA       What to multiple A by
11749:../src/wolfcrypt/src/ecc.c ****   B        Second point to multiply
11750:../src/wolfcrypt/src/ecc.c ****   kB       What to multiple B by
11751:../src/wolfcrypt/src/ecc.c ****   C        [out] Destination point (can overlap with A or B)
11752:../src/wolfcrypt/src/ecc.c ****   a        ECC curve parameter a
11753:../src/wolfcrypt/src/ecc.c ****   modulus  Modulus for curve
11754:../src/wolfcrypt/src/ecc.c ****   return MP_OKAY on success
11755:../src/wolfcrypt/src/ecc.c **** */
11756:../src/wolfcrypt/src/ecc.c **** int ecc_mul2add(ecc_point* A, mp_int* kA,
11757:../src/wolfcrypt/src/ecc.c ****                 ecc_point* B, mp_int* kB,
11758:../src/wolfcrypt/src/ecc.c ****                 ecc_point* C, mp_int* a, mp_int* modulus, void* heap)
11759:../src/wolfcrypt/src/ecc.c **** {
11760:../src/wolfcrypt/src/ecc.c ****    int  idx1 = -1, idx2 = -1, err, mpInit = 0;
11761:../src/wolfcrypt/src/ecc.c ****    mp_digit mp;
11762:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11763:../src/wolfcrypt/src/ecc.c ****    mp_int   *mu = (mp_int *)XMALLOC(sizeof *mu, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11764:../src/wolfcrypt/src/ecc.c **** 
11765:../src/wolfcrypt/src/ecc.c ****    if (mu == NULL)
11766:../src/wolfcrypt/src/ecc.c ****        return MP_MEM;
11767:../src/wolfcrypt/src/ecc.c **** #else
11768:../src/wolfcrypt/src/ecc.c ****    mp_int   mu[1];
11769:../src/wolfcrypt/src/ecc.c **** #endif
11770:../src/wolfcrypt/src/ecc.c **** 
11771:../src/wolfcrypt/src/ecc.c ****    err = mp_init(mu);
11772:../src/wolfcrypt/src/ecc.c ****    if (err != MP_OKAY) {
11773:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11774:../src/wolfcrypt/src/ecc.c ****        XFREE(mu, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11775:../src/wolfcrypt/src/ecc.c **** #endif
11776:../src/wolfcrypt/src/ecc.c ****        return err;
11777:../src/wolfcrypt/src/ecc.c ****    }
11778:../src/wolfcrypt/src/ecc.c **** 
11779:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
11780:../src/wolfcrypt/src/ecc.c ****    if (initMutex == 0) { /* extra sanity check if wolfCrypt_Init not called */
11781:../src/wolfcrypt/src/ecc.c ****         wc_InitMutex(&ecc_fp_lock);
11782:../src/wolfcrypt/src/ecc.c ****         initMutex = 1;
11783:../src/wolfcrypt/src/ecc.c ****    }
11784:../src/wolfcrypt/src/ecc.c **** 
11785:../src/wolfcrypt/src/ecc.c ****    if (wc_LockMutex(&ecc_fp_lock) != 0) {
11786:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11787:../src/wolfcrypt/src/ecc.c ****        XFREE(mu, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11788:../src/wolfcrypt/src/ecc.c **** #endif
11789:../src/wolfcrypt/src/ecc.c ****       return BAD_MUTEX_E;
11790:../src/wolfcrypt/src/ecc.c ****    }
11791:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_THREAD_LS */
11792:../src/wolfcrypt/src/ecc.c **** 
11793:../src/wolfcrypt/src/ecc.c ****       SAVE_VECTOR_REGISTERS(err = _svr_ret;);
11794:../src/wolfcrypt/src/ecc.c **** 
11795:../src/wolfcrypt/src/ecc.c ****       /* find point */
11796:../src/wolfcrypt/src/ecc.c ****       idx1 = find_base(A);
11797:../src/wolfcrypt/src/ecc.c **** 
11798:../src/wolfcrypt/src/ecc.c ****       /* no entry? */
11799:../src/wolfcrypt/src/ecc.c ****       if (idx1 == -1) {
11800:../src/wolfcrypt/src/ecc.c ****          /* find hole and add it */
11801:../src/wolfcrypt/src/ecc.c ****          if ((idx1 = find_hole()) >= 0) {
11802:../src/wolfcrypt/src/ecc.c ****             err = add_entry(idx1, A);
11803:../src/wolfcrypt/src/ecc.c ****          }
11804:../src/wolfcrypt/src/ecc.c ****       }
11805:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY && idx1 != -1) {
11806:../src/wolfcrypt/src/ecc.c ****          /* increment LRU */
11807:../src/wolfcrypt/src/ecc.c ****          ++(fp_cache[idx1].lru_count);
11808:../src/wolfcrypt/src/ecc.c ****       }
11809:../src/wolfcrypt/src/ecc.c **** 
11810:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
11811:../src/wolfcrypt/src/ecc.c ****         /* find point */
11812:../src/wolfcrypt/src/ecc.c ****         idx2 = find_base(B);
11813:../src/wolfcrypt/src/ecc.c **** 
11814:../src/wolfcrypt/src/ecc.c ****         /* no entry? */
11815:../src/wolfcrypt/src/ecc.c ****         if (idx2 == -1) {
11816:../src/wolfcrypt/src/ecc.c ****            /* find hole and add it */
11817:../src/wolfcrypt/src/ecc.c ****            if ((idx2 = find_hole()) >= 0)
11818:../src/wolfcrypt/src/ecc.c ****               err = add_entry(idx2, B);
11819:../src/wolfcrypt/src/ecc.c ****          }
11820:../src/wolfcrypt/src/ecc.c ****       }
11821:../src/wolfcrypt/src/ecc.c **** 
11822:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY && idx2 != -1) {
11823:../src/wolfcrypt/src/ecc.c ****          /* increment LRU */
11824:../src/wolfcrypt/src/ecc.c ****          ++(fp_cache[idx2].lru_count);
11825:../src/wolfcrypt/src/ecc.c ****       }
11826:../src/wolfcrypt/src/ecc.c **** 
11827:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
11828:../src/wolfcrypt/src/ecc.c ****         /* if it's >= 2 AND the LUT is not set build the LUT */
11829:../src/wolfcrypt/src/ecc.c ****         if (idx1 >= 0 && fp_cache[idx1].lru_count >= 2 && !fp_cache[idx1].LUT_set) {
11830:../src/wolfcrypt/src/ecc.c ****            /* compute mp */
11831:../src/wolfcrypt/src/ecc.c ****            err = mp_montgomery_setup(modulus, &mp);
11832:../src/wolfcrypt/src/ecc.c **** 
11833:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY) {
11834:../src/wolfcrypt/src/ecc.c ****              mpInit = 1;
11835:../src/wolfcrypt/src/ecc.c ****              err = mp_montgomery_calc_normalization(mu, modulus);
11836:../src/wolfcrypt/src/ecc.c ****            }
11837:../src/wolfcrypt/src/ecc.c **** 
11838:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
11839:../src/wolfcrypt/src/ecc.c ****              /* build the LUT */
11840:../src/wolfcrypt/src/ecc.c ****              err = build_lut(idx1, a, modulus, mp, mu);
11841:../src/wolfcrypt/src/ecc.c ****         }
11842:../src/wolfcrypt/src/ecc.c ****       }
11843:../src/wolfcrypt/src/ecc.c **** 
11844:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
11845:../src/wolfcrypt/src/ecc.c ****         /* if it's >= 2 AND the LUT is not set build the LUT */
11846:../src/wolfcrypt/src/ecc.c ****         if (idx2 >= 0 && fp_cache[idx2].lru_count >= 2 && !fp_cache[idx2].LUT_set) {
11847:../src/wolfcrypt/src/ecc.c ****            if (mpInit == 0) {
11848:../src/wolfcrypt/src/ecc.c ****                 /* compute mp */
11849:../src/wolfcrypt/src/ecc.c ****                 err = mp_montgomery_setup(modulus, &mp);
11850:../src/wolfcrypt/src/ecc.c ****                 if (err == MP_OKAY) {
11851:../src/wolfcrypt/src/ecc.c ****                     mpInit = 1;
11852:../src/wolfcrypt/src/ecc.c ****                     err = mp_montgomery_calc_normalization(mu, modulus);
11853:../src/wolfcrypt/src/ecc.c ****                 }
11854:../src/wolfcrypt/src/ecc.c ****             }
11855:../src/wolfcrypt/src/ecc.c **** 
11856:../src/wolfcrypt/src/ecc.c ****             if (err == MP_OKAY)
11857:../src/wolfcrypt/src/ecc.c ****               /* build the LUT */
11858:../src/wolfcrypt/src/ecc.c ****               err = build_lut(idx2, a, modulus, mp, mu);
11859:../src/wolfcrypt/src/ecc.c ****         }
11860:../src/wolfcrypt/src/ecc.c ****       }
11861:../src/wolfcrypt/src/ecc.c **** 
11862:../src/wolfcrypt/src/ecc.c **** 
11863:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
11864:../src/wolfcrypt/src/ecc.c ****         if (idx1 >=0 && idx2 >= 0 && fp_cache[idx1].LUT_set &&
11865:../src/wolfcrypt/src/ecc.c ****                                      fp_cache[idx2].LUT_set) {
11866:../src/wolfcrypt/src/ecc.c ****            if (mpInit == 0) {
11867:../src/wolfcrypt/src/ecc.c ****               /* compute mp */
11868:../src/wolfcrypt/src/ecc.c ****               err = mp_montgomery_setup(modulus, &mp);
11869:../src/wolfcrypt/src/ecc.c ****            }
11870:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
11871:../src/wolfcrypt/src/ecc.c ****              err = accel_fp_mul2add(idx1, idx2, kA, kB, C, a, modulus, mp);
11872:../src/wolfcrypt/src/ecc.c ****         } else {
11873:../src/wolfcrypt/src/ecc.c ****            err = normal_ecc_mul2add(A, kA, B, kB, C, a, modulus, heap);
11874:../src/wolfcrypt/src/ecc.c ****         }
11875:../src/wolfcrypt/src/ecc.c ****       }
11876:../src/wolfcrypt/src/ecc.c **** 
11877:../src/wolfcrypt/src/ecc.c ****       RESTORE_VECTOR_REGISTERS();
11878:../src/wolfcrypt/src/ecc.c **** 
11879:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
11880:../src/wolfcrypt/src/ecc.c ****     wc_UnLockMutex(&ecc_fp_lock);
11881:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_THREAD_LS */
11882:../src/wolfcrypt/src/ecc.c ****     mp_clear(mu);
11883:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11884:../src/wolfcrypt/src/ecc.c ****     XFREE(mu, NULL, DYNAMIC_TYPE_ECC_BUFFER);
11885:../src/wolfcrypt/src/ecc.c **** #endif
11886:../src/wolfcrypt/src/ecc.c **** 
11887:../src/wolfcrypt/src/ecc.c ****     return err;
11888:../src/wolfcrypt/src/ecc.c **** }
11889:../src/wolfcrypt/src/ecc.c **** #endif
11890:../src/wolfcrypt/src/ecc.c **** #endif /* ECC_SHAMIR */
11891:../src/wolfcrypt/src/ecc.c **** 
11892:../src/wolfcrypt/src/ecc.c **** /** ECC Fixed Point mulmod global
11893:../src/wolfcrypt/src/ecc.c ****     k        The multiplicand
11894:../src/wolfcrypt/src/ecc.c ****     G        Base point to multiply
11895:../src/wolfcrypt/src/ecc.c ****     R        [out] Destination of product
11896:../src/wolfcrypt/src/ecc.c ****     a        ECC curve parameter a
11897:../src/wolfcrypt/src/ecc.c ****     modulus  The modulus for the curve
11898:../src/wolfcrypt/src/ecc.c ****     map      [boolean] If non-zero maps the point back to affine coordinates,
11899:../src/wolfcrypt/src/ecc.c ****              otherwise it's left in jacobian-montgomery form
11900:../src/wolfcrypt/src/ecc.c ****     return MP_OKAY if successful
11901:../src/wolfcrypt/src/ecc.c **** */
11902:../src/wolfcrypt/src/ecc.c **** int wc_ecc_mulmod_ex(const mp_int* k, ecc_point *G, ecc_point *R, mp_int* a,
11903:../src/wolfcrypt/src/ecc.c ****     mp_int* modulus, int map, void* heap)
11904:../src/wolfcrypt/src/ecc.c **** {
11905:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
11906:../src/wolfcrypt/src/ecc.c ****    int   idx, err = MP_OKAY;
11907:../src/wolfcrypt/src/ecc.c ****    mp_digit mp;
11908:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11909:../src/wolfcrypt/src/ecc.c ****    mp_int   *mu = NULL;
11910:../src/wolfcrypt/src/ecc.c **** #else
11911:../src/wolfcrypt/src/ecc.c ****    mp_int   mu[1];
11912:../src/wolfcrypt/src/ecc.c **** #endif
11913:../src/wolfcrypt/src/ecc.c ****    int      mpSetup = 0;
11914:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
11915:../src/wolfcrypt/src/ecc.c ****    int got_ecc_fp_lock = 0;
11916:../src/wolfcrypt/src/ecc.c **** #endif
11917:../src/wolfcrypt/src/ecc.c **** 
11918:../src/wolfcrypt/src/ecc.c ****    if (k == NULL || G == NULL || R == NULL || a == NULL || modulus == NULL) {
11919:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
11920:../src/wolfcrypt/src/ecc.c ****    }
11921:../src/wolfcrypt/src/ecc.c **** 
11922:../src/wolfcrypt/src/ecc.c ****    /* k can't have more bits than modulus count plus 1 */
11923:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(k) > mp_count_bits(modulus) + 1) {
11924:../src/wolfcrypt/src/ecc.c ****       return ECC_OUT_OF_RANGE_E;
11925:../src/wolfcrypt/src/ecc.c ****    }
11926:../src/wolfcrypt/src/ecc.c **** 
11927:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
11928:../src/wolfcrypt/src/ecc.c ****    if ((mu = (mp_int *)XMALLOC(sizeof(*mu), NULL, DYNAMIC_TYPE_ECC_BUFFER)) == NULL)
11929:../src/wolfcrypt/src/ecc.c ****        return MP_MEM;
11930:../src/wolfcrypt/src/ecc.c **** #endif
11931:../src/wolfcrypt/src/ecc.c **** 
11932:../src/wolfcrypt/src/ecc.c ****    if (mp_init(mu) != MP_OKAY) {
11933:../src/wolfcrypt/src/ecc.c ****        err = MP_INIT_E;
11934:../src/wolfcrypt/src/ecc.c ****        goto out;
11935:../src/wolfcrypt/src/ecc.c ****    }
11936:../src/wolfcrypt/src/ecc.c **** 
11937:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
11938:../src/wolfcrypt/src/ecc.c ****    if (initMutex == 0) { /* extra sanity check if wolfCrypt_Init not called */
11939:../src/wolfcrypt/src/ecc.c ****         wc_InitMutex(&ecc_fp_lock);
11940:../src/wolfcrypt/src/ecc.c ****         initMutex = 1;
11941:../src/wolfcrypt/src/ecc.c ****    }
11942:../src/wolfcrypt/src/ecc.c **** 
11943:../src/wolfcrypt/src/ecc.c ****    if (wc_LockMutex(&ecc_fp_lock) != 0) {
11944:../src/wolfcrypt/src/ecc.c ****       err = BAD_MUTEX_E;
11945:../src/wolfcrypt/src/ecc.c ****       goto out;
11946:../src/wolfcrypt/src/ecc.c ****    }
11947:../src/wolfcrypt/src/ecc.c ****    got_ecc_fp_lock = 1;
11948:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_THREAD_LS */
11949:../src/wolfcrypt/src/ecc.c **** 
11950:../src/wolfcrypt/src/ecc.c ****       SAVE_VECTOR_REGISTERS(err = _svr_ret; goto out;);
11951:../src/wolfcrypt/src/ecc.c **** 
11952:../src/wolfcrypt/src/ecc.c ****       /* find point */
11953:../src/wolfcrypt/src/ecc.c ****       idx = find_base(G);
11954:../src/wolfcrypt/src/ecc.c **** 
11955:../src/wolfcrypt/src/ecc.c ****       /* no entry? */
11956:../src/wolfcrypt/src/ecc.c ****       if (idx == -1) {
11957:../src/wolfcrypt/src/ecc.c ****          /* find hole and add it */
11958:../src/wolfcrypt/src/ecc.c ****          idx = find_hole();
11959:../src/wolfcrypt/src/ecc.c **** 
11960:../src/wolfcrypt/src/ecc.c ****          if (idx >= 0)
11961:../src/wolfcrypt/src/ecc.c ****             err = add_entry(idx, G);
11962:../src/wolfcrypt/src/ecc.c ****       }
11963:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY && idx >= 0) {
11964:../src/wolfcrypt/src/ecc.c ****          /* increment LRU */
11965:../src/wolfcrypt/src/ecc.c ****          ++(fp_cache[idx].lru_count);
11966:../src/wolfcrypt/src/ecc.c ****       }
11967:../src/wolfcrypt/src/ecc.c **** 
11968:../src/wolfcrypt/src/ecc.c **** 
11969:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
11970:../src/wolfcrypt/src/ecc.c ****         /* if it's 2 build the LUT, if it's higher just use the LUT */
11971:../src/wolfcrypt/src/ecc.c ****         if (idx >= 0 && fp_cache[idx].lru_count >= 2 && !fp_cache[idx].LUT_set) {
11972:../src/wolfcrypt/src/ecc.c ****            /* compute mp */
11973:../src/wolfcrypt/src/ecc.c ****            err = mp_montgomery_setup(modulus, &mp);
11974:../src/wolfcrypt/src/ecc.c **** 
11975:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY) {
11976:../src/wolfcrypt/src/ecc.c ****              /* compute mu */
11977:../src/wolfcrypt/src/ecc.c ****              mpSetup = 1;
11978:../src/wolfcrypt/src/ecc.c ****              err = mp_montgomery_calc_normalization(mu, modulus);
11979:../src/wolfcrypt/src/ecc.c ****            }
11980:../src/wolfcrypt/src/ecc.c **** 
11981:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
11982:../src/wolfcrypt/src/ecc.c ****              /* build the LUT */
11983:../src/wolfcrypt/src/ecc.c ****              err = build_lut(idx, a, modulus, mp, mu);
11984:../src/wolfcrypt/src/ecc.c ****         }
11985:../src/wolfcrypt/src/ecc.c ****       }
11986:../src/wolfcrypt/src/ecc.c **** 
11987:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
11988:../src/wolfcrypt/src/ecc.c ****         if (idx >= 0 && fp_cache[idx].LUT_set) {
11989:../src/wolfcrypt/src/ecc.c ****            if (mpSetup == 0) {
11990:../src/wolfcrypt/src/ecc.c ****               /* compute mp */
11991:../src/wolfcrypt/src/ecc.c ****               err = mp_montgomery_setup(modulus, &mp);
11992:../src/wolfcrypt/src/ecc.c ****            }
11993:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
11994:../src/wolfcrypt/src/ecc.c ****              err = accel_fp_mul(idx, k, R, a, modulus, mp, map);
11995:../src/wolfcrypt/src/ecc.c ****         } else {
11996:../src/wolfcrypt/src/ecc.c ****            err = normal_ecc_mulmod(k, G, R, a, modulus, NULL, map, heap);
11997:../src/wolfcrypt/src/ecc.c ****         }
11998:../src/wolfcrypt/src/ecc.c ****       }
11999:../src/wolfcrypt/src/ecc.c **** 
12000:../src/wolfcrypt/src/ecc.c ****       RESTORE_VECTOR_REGISTERS();
12001:../src/wolfcrypt/src/ecc.c **** 
12002:../src/wolfcrypt/src/ecc.c ****   out:
12003:../src/wolfcrypt/src/ecc.c **** 
12004:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
12005:../src/wolfcrypt/src/ecc.c ****     if (got_ecc_fp_lock)
12006:../src/wolfcrypt/src/ecc.c ****         wc_UnLockMutex(&ecc_fp_lock);
12007:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_THREAD_LS */
12008:../src/wolfcrypt/src/ecc.c ****     mp_clear(mu);
12009:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
12010:../src/wolfcrypt/src/ecc.c ****     XFREE(mu, NULL, DYNAMIC_TYPE_ECC_BUFFER);
12011:../src/wolfcrypt/src/ecc.c **** #endif
12012:../src/wolfcrypt/src/ecc.c **** 
12013:../src/wolfcrypt/src/ecc.c ****     return err;
12014:../src/wolfcrypt/src/ecc.c **** 
12015:../src/wolfcrypt/src/ecc.c **** #else /* WOLFSSL_SP_MATH */
12016:../src/wolfcrypt/src/ecc.c **** 
12017:../src/wolfcrypt/src/ecc.c ****     if (k == NULL || G == NULL || R == NULL || a == NULL || modulus == NULL) {
12018:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
12019:../src/wolfcrypt/src/ecc.c ****     }
12020:../src/wolfcrypt/src/ecc.c ****     if (mp_count_bits(G->x) > mp_count_bits(modulus) ||
12021:../src/wolfcrypt/src/ecc.c ****         mp_count_bits(G->y) > mp_count_bits(modulus) ||
12022:../src/wolfcrypt/src/ecc.c ****         mp_count_bits(G->z) > mp_count_bits(modulus)) {
12023:../src/wolfcrypt/src/ecc.c ****         return IS_POINT_E;
12024:../src/wolfcrypt/src/ecc.c ****     }
12025:../src/wolfcrypt/src/ecc.c **** 
12026:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
12027:../src/wolfcrypt/src/ecc.c ****     if (mp_count_bits(modulus) == 256) {
12028:../src/wolfcrypt/src/ecc.c ****         int ret;
12029:../src/wolfcrypt/src/ecc.c ****         SAVE_VECTOR_REGISTERS(return _svr_ret);
12030:../src/wolfcrypt/src/ecc.c ****         ret = sp_ecc_mulmod_256(k, G, R, map, heap);
12031:../src/wolfcrypt/src/ecc.c ****         RESTORE_VECTOR_REGISTERS();
12032:../src/wolfcrypt/src/ecc.c ****         return ret;
12033:../src/wolfcrypt/src/ecc.c ****     }
12034:../src/wolfcrypt/src/ecc.c **** #endif
12035:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
12036:../src/wolfcrypt/src/ecc.c ****     if (mp_count_bits(modulus) == 384) {
12037:../src/wolfcrypt/src/ecc.c ****         int ret;
12038:../src/wolfcrypt/src/ecc.c ****         SAVE_VECTOR_REGISTERS(return _svr_ret);
12039:../src/wolfcrypt/src/ecc.c ****         ret = sp_ecc_mulmod_384(k, G, R, map, heap);
12040:../src/wolfcrypt/src/ecc.c ****         RESTORE_VECTOR_REGISTERS();
12041:../src/wolfcrypt/src/ecc.c ****         return ret;
12042:../src/wolfcrypt/src/ecc.c ****     }
12043:../src/wolfcrypt/src/ecc.c **** #endif
12044:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
12045:../src/wolfcrypt/src/ecc.c ****     if (mp_count_bits(modulus) == 521) {
12046:../src/wolfcrypt/src/ecc.c ****         int ret;
12047:../src/wolfcrypt/src/ecc.c ****         SAVE_VECTOR_REGISTERS(return _svr_ret);
12048:../src/wolfcrypt/src/ecc.c ****         ret = sp_ecc_mulmod_521(k, G, R, map, heap);
12049:../src/wolfcrypt/src/ecc.c ****         RESTORE_VECTOR_REGISTERS();
12050:../src/wolfcrypt/src/ecc.c ****         return ret;
12051:../src/wolfcrypt/src/ecc.c ****     }
12052:../src/wolfcrypt/src/ecc.c **** #endif
12053:../src/wolfcrypt/src/ecc.c ****     return WC_KEY_SIZE_E;
12054:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SP_MATH */
12055:../src/wolfcrypt/src/ecc.c **** }
12056:../src/wolfcrypt/src/ecc.c **** 
12057:../src/wolfcrypt/src/ecc.c **** /** ECC Fixed Point mulmod global
12058:../src/wolfcrypt/src/ecc.c ****     k        The multiplicand
12059:../src/wolfcrypt/src/ecc.c ****     G        Base point to multiply
12060:../src/wolfcrypt/src/ecc.c ****     R        [out] Destination of product
12061:../src/wolfcrypt/src/ecc.c ****     a        ECC curve parameter a
12062:../src/wolfcrypt/src/ecc.c ****     modulus  The modulus for the curve
12063:../src/wolfcrypt/src/ecc.c ****     map      [boolean] If non-zero maps the point back to affine coordinates,
12064:../src/wolfcrypt/src/ecc.c ****              otherwise it's left in jacobian-montgomery form
12065:../src/wolfcrypt/src/ecc.c ****     return MP_OKAY if successful
12066:../src/wolfcrypt/src/ecc.c **** */
12067:../src/wolfcrypt/src/ecc.c **** int wc_ecc_mulmod_ex2(const mp_int* k, ecc_point *G, ecc_point *R, mp_int* a,
12068:../src/wolfcrypt/src/ecc.c ****     mp_int* modulus, mp_int* order, WC_RNG* rng, int map, void* heap)
12069:../src/wolfcrypt/src/ecc.c **** {
12070:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
12071:../src/wolfcrypt/src/ecc.c ****    int   idx, err = MP_OKAY;
12072:../src/wolfcrypt/src/ecc.c ****    mp_digit mp;
12073:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
12074:../src/wolfcrypt/src/ecc.c ****    mp_int   *mu = NULL;
12075:../src/wolfcrypt/src/ecc.c **** #else
12076:../src/wolfcrypt/src/ecc.c ****    mp_int   mu[1];
12077:../src/wolfcrypt/src/ecc.c **** #endif
12078:../src/wolfcrypt/src/ecc.c ****    int      mpSetup = 0;
12079:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
12080:../src/wolfcrypt/src/ecc.c ****    int got_ecc_fp_lock = 0;
12081:../src/wolfcrypt/src/ecc.c **** #endif
12082:../src/wolfcrypt/src/ecc.c **** 
12083:../src/wolfcrypt/src/ecc.c ****    if (k == NULL || G == NULL || R == NULL || a == NULL || modulus == NULL ||
12084:../src/wolfcrypt/src/ecc.c ****                                                                 order == NULL) {
12085:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
12086:../src/wolfcrypt/src/ecc.c ****    }
12087:../src/wolfcrypt/src/ecc.c **** 
12088:../src/wolfcrypt/src/ecc.c ****    /* k can't have more bits than order */
12089:../src/wolfcrypt/src/ecc.c ****    if (mp_count_bits(k) > mp_count_bits(order)) {
12090:../src/wolfcrypt/src/ecc.c ****       return ECC_OUT_OF_RANGE_E;
12091:../src/wolfcrypt/src/ecc.c ****    }
12092:../src/wolfcrypt/src/ecc.c **** 
12093:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
12094:../src/wolfcrypt/src/ecc.c ****    if ((mu = (mp_int *)XMALLOC(sizeof(*mu), NULL, DYNAMIC_TYPE_ECC_BUFFER)) == NULL)
12095:../src/wolfcrypt/src/ecc.c ****        return MP_MEM;
12096:../src/wolfcrypt/src/ecc.c **** #endif
12097:../src/wolfcrypt/src/ecc.c **** 
12098:../src/wolfcrypt/src/ecc.c ****    if (mp_init(mu) != MP_OKAY) {
12099:../src/wolfcrypt/src/ecc.c ****        err = MP_INIT_E;
12100:../src/wolfcrypt/src/ecc.c ****        goto out;
12101:../src/wolfcrypt/src/ecc.c ****    }
12102:../src/wolfcrypt/src/ecc.c **** 
12103:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
12104:../src/wolfcrypt/src/ecc.c ****    if (initMutex == 0) { /* extra sanity check if wolfCrypt_Init not called */
12105:../src/wolfcrypt/src/ecc.c ****         wc_InitMutex(&ecc_fp_lock);
12106:../src/wolfcrypt/src/ecc.c ****         initMutex = 1;
12107:../src/wolfcrypt/src/ecc.c ****    }
12108:../src/wolfcrypt/src/ecc.c **** 
12109:../src/wolfcrypt/src/ecc.c ****    if (wc_LockMutex(&ecc_fp_lock) != 0) {
12110:../src/wolfcrypt/src/ecc.c ****       err = BAD_MUTEX_E;
12111:../src/wolfcrypt/src/ecc.c ****       goto out;
12112:../src/wolfcrypt/src/ecc.c ****    }
12113:../src/wolfcrypt/src/ecc.c ****    got_ecc_fp_lock = 1;
12114:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_THREAD_LS */
12115:../src/wolfcrypt/src/ecc.c **** 
12116:../src/wolfcrypt/src/ecc.c ****       SAVE_VECTOR_REGISTERS(err = _svr_ret; goto out;);
12117:../src/wolfcrypt/src/ecc.c **** 
12118:../src/wolfcrypt/src/ecc.c ****       /* find point */
12119:../src/wolfcrypt/src/ecc.c ****       idx = find_base(G);
12120:../src/wolfcrypt/src/ecc.c **** 
12121:../src/wolfcrypt/src/ecc.c ****       /* no entry? */
12122:../src/wolfcrypt/src/ecc.c ****       if (idx == -1) {
12123:../src/wolfcrypt/src/ecc.c ****          /* find hole and add it */
12124:../src/wolfcrypt/src/ecc.c ****          idx = find_hole();
12125:../src/wolfcrypt/src/ecc.c **** 
12126:../src/wolfcrypt/src/ecc.c ****          if (idx >= 0)
12127:../src/wolfcrypt/src/ecc.c ****             err = add_entry(idx, G);
12128:../src/wolfcrypt/src/ecc.c ****       }
12129:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY && idx >= 0) {
12130:../src/wolfcrypt/src/ecc.c ****          /* increment LRU */
12131:../src/wolfcrypt/src/ecc.c ****          ++(fp_cache[idx].lru_count);
12132:../src/wolfcrypt/src/ecc.c ****       }
12133:../src/wolfcrypt/src/ecc.c **** 
12134:../src/wolfcrypt/src/ecc.c **** 
12135:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
12136:../src/wolfcrypt/src/ecc.c ****         /* if it's 2 build the LUT, if it's higher just use the LUT */
12137:../src/wolfcrypt/src/ecc.c ****         if (idx >= 0 && fp_cache[idx].lru_count >= 2 && !fp_cache[idx].LUT_set) {
12138:../src/wolfcrypt/src/ecc.c ****            /* compute mp */
12139:../src/wolfcrypt/src/ecc.c ****            err = mp_montgomery_setup(modulus, &mp);
12140:../src/wolfcrypt/src/ecc.c **** 
12141:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY) {
12142:../src/wolfcrypt/src/ecc.c ****              /* compute mu */
12143:../src/wolfcrypt/src/ecc.c ****              mpSetup = 1;
12144:../src/wolfcrypt/src/ecc.c ****              err = mp_montgomery_calc_normalization(mu, modulus);
12145:../src/wolfcrypt/src/ecc.c ****            }
12146:../src/wolfcrypt/src/ecc.c **** 
12147:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
12148:../src/wolfcrypt/src/ecc.c ****              /* build the LUT */
12149:../src/wolfcrypt/src/ecc.c ****              err = build_lut(idx, a, modulus, mp, mu);
12150:../src/wolfcrypt/src/ecc.c ****         }
12151:../src/wolfcrypt/src/ecc.c ****       }
12152:../src/wolfcrypt/src/ecc.c **** 
12153:../src/wolfcrypt/src/ecc.c ****       if (err == MP_OKAY) {
12154:../src/wolfcrypt/src/ecc.c ****         if (idx >= 0 && fp_cache[idx].LUT_set) {
12155:../src/wolfcrypt/src/ecc.c ****            if (mpSetup == 0) {
12156:../src/wolfcrypt/src/ecc.c ****               /* compute mp */
12157:../src/wolfcrypt/src/ecc.c ****               err = mp_montgomery_setup(modulus, &mp);
12158:../src/wolfcrypt/src/ecc.c ****            }
12159:../src/wolfcrypt/src/ecc.c ****            if (err == MP_OKAY)
12160:../src/wolfcrypt/src/ecc.c ****              err = accel_fp_mul(idx, k, R, a, modulus, mp, map);
12161:../src/wolfcrypt/src/ecc.c ****         } else {
12162:../src/wolfcrypt/src/ecc.c ****           err = normal_ecc_mulmod(k, G, R, a, modulus, rng, map, heap);
12163:../src/wolfcrypt/src/ecc.c ****         }
12164:../src/wolfcrypt/src/ecc.c ****       }
12165:../src/wolfcrypt/src/ecc.c **** 
12166:../src/wolfcrypt/src/ecc.c ****       RESTORE_VECTOR_REGISTERS();
12167:../src/wolfcrypt/src/ecc.c **** 
12168:../src/wolfcrypt/src/ecc.c ****   out:
12169:../src/wolfcrypt/src/ecc.c **** 
12170:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
12171:../src/wolfcrypt/src/ecc.c ****     if (got_ecc_fp_lock)
12172:../src/wolfcrypt/src/ecc.c ****         wc_UnLockMutex(&ecc_fp_lock);
12173:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_THREAD_LS */
12174:../src/wolfcrypt/src/ecc.c ****     mp_clear(mu);
12175:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
12176:../src/wolfcrypt/src/ecc.c ****     XFREE(mu, NULL, DYNAMIC_TYPE_ECC_BUFFER);
12177:../src/wolfcrypt/src/ecc.c **** #endif
12178:../src/wolfcrypt/src/ecc.c **** 
12179:../src/wolfcrypt/src/ecc.c ****     return err;
12180:../src/wolfcrypt/src/ecc.c **** 
12181:../src/wolfcrypt/src/ecc.c **** #else /* WOLFSSL_SP_MATH */
12182:../src/wolfcrypt/src/ecc.c **** 
12183:../src/wolfcrypt/src/ecc.c ****     (void)rng;
12184:../src/wolfcrypt/src/ecc.c **** 
12185:../src/wolfcrypt/src/ecc.c ****     if (k == NULL || G == NULL || R == NULL || a == NULL || modulus == NULL ||
12186:../src/wolfcrypt/src/ecc.c ****                                                                 order == NULL) {
12187:../src/wolfcrypt/src/ecc.c ****         return ECC_BAD_ARG_E;
12188:../src/wolfcrypt/src/ecc.c ****     }
12189:../src/wolfcrypt/src/ecc.c ****     if (mp_count_bits(G->x) > mp_count_bits(modulus) ||
12190:../src/wolfcrypt/src/ecc.c ****         mp_count_bits(G->y) > mp_count_bits(modulus) ||
12191:../src/wolfcrypt/src/ecc.c ****         mp_count_bits(G->z) > mp_count_bits(modulus)) {
12192:../src/wolfcrypt/src/ecc.c ****         return IS_POINT_E;
12193:../src/wolfcrypt/src/ecc.c ****     }
12194:../src/wolfcrypt/src/ecc.c **** 
12195:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_NO_256
12196:../src/wolfcrypt/src/ecc.c ****     if (mp_count_bits(modulus) == 256) {
12197:../src/wolfcrypt/src/ecc.c ****         int ret;
12198:../src/wolfcrypt/src/ecc.c ****         SAVE_VECTOR_REGISTERS(return _svr_ret);
12199:../src/wolfcrypt/src/ecc.c ****         ret = sp_ecc_mulmod_256(k, G, R, map, heap);
12200:../src/wolfcrypt/src/ecc.c ****         RESTORE_VECTOR_REGISTERS();
12201:../src/wolfcrypt/src/ecc.c ****         return ret;
12202:../src/wolfcrypt/src/ecc.c ****     }
12203:../src/wolfcrypt/src/ecc.c **** #endif
12204:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_384
12205:../src/wolfcrypt/src/ecc.c ****     if (mp_count_bits(modulus) == 384) {
12206:../src/wolfcrypt/src/ecc.c ****         int ret;
12207:../src/wolfcrypt/src/ecc.c ****         SAVE_VECTOR_REGISTERS(return _svr_ret);
12208:../src/wolfcrypt/src/ecc.c ****         ret = sp_ecc_mulmod_384(k, G, R, map, heap);
12209:../src/wolfcrypt/src/ecc.c ****         RESTORE_VECTOR_REGISTERS();
12210:../src/wolfcrypt/src/ecc.c ****         return ret;
12211:../src/wolfcrypt/src/ecc.c ****     }
12212:../src/wolfcrypt/src/ecc.c **** #endif
12213:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SP_521
12214:../src/wolfcrypt/src/ecc.c ****     if (mp_count_bits(modulus) == 521) {
12215:../src/wolfcrypt/src/ecc.c ****         int ret;
12216:../src/wolfcrypt/src/ecc.c ****         SAVE_VECTOR_REGISTERS(return _svr_ret);
12217:../src/wolfcrypt/src/ecc.c ****         ret = sp_ecc_mulmod_521(k, G, R, map, heap);
12218:../src/wolfcrypt/src/ecc.c ****         RESTORE_VECTOR_REGISTERS();
12219:../src/wolfcrypt/src/ecc.c ****         return ret;
12220:../src/wolfcrypt/src/ecc.c ****     }
12221:../src/wolfcrypt/src/ecc.c **** #endif
12222:../src/wolfcrypt/src/ecc.c ****     return WC_KEY_SIZE_E;
12223:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_SP_MATH */
12224:../src/wolfcrypt/src/ecc.c **** }
12225:../src/wolfcrypt/src/ecc.c **** 
12226:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
12227:../src/wolfcrypt/src/ecc.c **** /* helper function for freeing the cache ...
12228:../src/wolfcrypt/src/ecc.c ****    must be called with the cache mutex locked */
12229:../src/wolfcrypt/src/ecc.c **** static void wc_ecc_fp_free_cache(void)
12230:../src/wolfcrypt/src/ecc.c **** {
12231:../src/wolfcrypt/src/ecc.c ****    unsigned x, y;
12232:../src/wolfcrypt/src/ecc.c ****    for (x = 0; x < FP_ENTRIES; x++) {
12233:../src/wolfcrypt/src/ecc.c ****       if (fp_cache[x].g != NULL) {
12234:../src/wolfcrypt/src/ecc.c ****          for (y = 0; y < (1U<<FP_LUT); y++) {
12235:../src/wolfcrypt/src/ecc.c ****             wc_ecc_del_point(fp_cache[x].LUT[y]);
12236:../src/wolfcrypt/src/ecc.c ****             fp_cache[x].LUT[y] = NULL;
12237:../src/wolfcrypt/src/ecc.c ****          }
12238:../src/wolfcrypt/src/ecc.c ****          wc_ecc_del_point(fp_cache[x].g);
12239:../src/wolfcrypt/src/ecc.c ****          fp_cache[x].g         = NULL;
12240:../src/wolfcrypt/src/ecc.c ****          mp_clear(&fp_cache[x].mu);
12241:../src/wolfcrypt/src/ecc.c ****          fp_cache[x].LUT_set   = 0;
12242:../src/wolfcrypt/src/ecc.c ****          fp_cache[x].lru_count = 0;
12243:../src/wolfcrypt/src/ecc.c ****          fp_cache[x].lock = 0;
12244:../src/wolfcrypt/src/ecc.c ****       }
12245:../src/wolfcrypt/src/ecc.c ****    }
12246:../src/wolfcrypt/src/ecc.c **** }
12247:../src/wolfcrypt/src/ecc.c **** #endif
12248:../src/wolfcrypt/src/ecc.c **** 
12249:../src/wolfcrypt/src/ecc.c **** 
12250:../src/wolfcrypt/src/ecc.c **** /** Init the Fixed Point cache */
12251:../src/wolfcrypt/src/ecc.c **** void wc_ecc_fp_init(void)
12252:../src/wolfcrypt/src/ecc.c **** {
12253:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_MATH
12254:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
12255:../src/wolfcrypt/src/ecc.c ****    if (initMutex == 0) {
12256:../src/wolfcrypt/src/ecc.c ****         wc_InitMutex(&ecc_fp_lock);
12257:../src/wolfcrypt/src/ecc.c ****         initMutex = 1;
12258:../src/wolfcrypt/src/ecc.c ****    }
12259:../src/wolfcrypt/src/ecc.c **** #endif
12260:../src/wolfcrypt/src/ecc.c **** #endif
12261:../src/wolfcrypt/src/ecc.c **** }
12262:../src/wolfcrypt/src/ecc.c **** 
12263:../src/wolfcrypt/src/ecc.c **** 
12264:../src/wolfcrypt/src/ecc.c **** /** Free the Fixed Point cache */
12265:../src/wolfcrypt/src/ecc.c **** void wc_ecc_fp_free(void)
12266:../src/wolfcrypt/src/ecc.c **** {
12267:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_SP_MATH)
12268:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
12269:../src/wolfcrypt/src/ecc.c ****    if (initMutex == 0) { /* extra sanity check if wolfCrypt_Init not called */
12270:../src/wolfcrypt/src/ecc.c ****         wc_InitMutex(&ecc_fp_lock);
12271:../src/wolfcrypt/src/ecc.c ****         initMutex = 1;
12272:../src/wolfcrypt/src/ecc.c ****    }
12273:../src/wolfcrypt/src/ecc.c **** 
12274:../src/wolfcrypt/src/ecc.c ****    if (wc_LockMutex(&ecc_fp_lock) == 0) {
12275:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_THREAD_LS */
12276:../src/wolfcrypt/src/ecc.c **** 
12277:../src/wolfcrypt/src/ecc.c ****        wc_ecc_fp_free_cache();
12278:../src/wolfcrypt/src/ecc.c **** 
12279:../src/wolfcrypt/src/ecc.c **** #ifndef HAVE_THREAD_LS
12280:../src/wolfcrypt/src/ecc.c ****        wc_UnLockMutex(&ecc_fp_lock);
12281:../src/wolfcrypt/src/ecc.c ****        wc_FreeMutex(&ecc_fp_lock);
12282:../src/wolfcrypt/src/ecc.c ****        initMutex = 0;
12283:../src/wolfcrypt/src/ecc.c ****    }
12284:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_THREAD_LS */
12285:../src/wolfcrypt/src/ecc.c **** #endif
12286:../src/wolfcrypt/src/ecc.c **** }
12287:../src/wolfcrypt/src/ecc.c **** 
12288:../src/wolfcrypt/src/ecc.c **** 
12289:../src/wolfcrypt/src/ecc.c **** #endif /* FP_ECC */
12290:../src/wolfcrypt/src/ecc.c **** 
12291:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
12292:../src/wolfcrypt/src/ecc.c **** int wc_ecc_set_rng(ecc_key* key, WC_RNG* rng)
12293:../src/wolfcrypt/src/ecc.c **** {
 14115                             		.loc 2 12293 1
 14116 0000 7E AA                   		push.l	r10
 14117                             	.LCFI256:
 14118 0002 71 0A F4                		add	#-12, r0, r10
 14119                             	.LCFI257:
 14120 0005 EF A0                   		mov.L	r10, r0
 14121 0007 E7 A1 01                		mov.L	r1, 4[r10]
 14122 000a E7 A2 02                		mov.L	r2, 8[r10]
12294:../src/wolfcrypt/src/ecc.c ****     int err = 0;
 14123                             		.loc 2 12294 9
 14124 000d F8 A6 00                		mov.L	#0, [r10]
12295:../src/wolfcrypt/src/ecc.c **** 
12296:../src/wolfcrypt/src/ecc.c ****     if (key == NULL) {
 14125                             		.loc 2 12296 8
 14126 0010 ED A5 01                		mov.L	4[r10], r5
 14127 0013 61 05                   		cmp	#0, r5
 14128 0015 1F                      		bne	.L983
12297:../src/wolfcrypt/src/ecc.c ****         err = BAD_FUNC_ARG;
 14129                             		.loc 2 12297 13
 14130 0016 F8 AA 53 FF             		mov.L	#-173, [r10]
 14131 001a 2E 0C                   		bra	.L984
 14132                             	.L983:
12298:../src/wolfcrypt/src/ecc.c ****     }
12299:../src/wolfcrypt/src/ecc.c ****     else {
12300:../src/wolfcrypt/src/ecc.c ****         key->rng = rng;
 14133                             		.loc 2 12300 18
 14134 001c ED A5 01                		mov.L	4[r10], r5
 14135 001f ED A4 02                		mov.L	8[r10], r4
 14136 0022 EB 54 16 03             		mov.L	r4, 3160[r5]
 14137                             	.L984:
12301:../src/wolfcrypt/src/ecc.c ****     }
12302:../src/wolfcrypt/src/ecc.c **** 
12303:../src/wolfcrypt/src/ecc.c ****     return err;
 14138                             		.loc 2 12303 12
 14139 0026 EC A5                   		mov.L	[r10], r5
12304:../src/wolfcrypt/src/ecc.c **** }
 14140                             		.loc 2 12304 1
 14141 0028 EF 51                   		mov.L	r5, r1
 14142 002a 3F AA 04                		rtsd	#16, r10-r10
 14143                             	.LFE140:
 14145                             		.section	.text.wc_ecc_get_oid,"ax",@progbits
 14146                             		.global	_wc_ecc_get_oid
 14148                             	_wc_ecc_get_oid:
 14149                             	.LFB141:
12305:../src/wolfcrypt/src/ecc.c **** #endif
12306:../src/wolfcrypt/src/ecc.c **** 
12307:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_ECC_ENCRYPT
12308:../src/wolfcrypt/src/ecc.c **** 
12309:../src/wolfcrypt/src/ecc.c **** 
12310:../src/wolfcrypt/src/ecc.c **** enum ecCliState {
12311:../src/wolfcrypt/src/ecc.c ****     ecCLI_INIT      = 1,
12312:../src/wolfcrypt/src/ecc.c ****     ecCLI_SALT_GET  = 2,
12313:../src/wolfcrypt/src/ecc.c ****     ecCLI_SALT_SET  = 3,
12314:../src/wolfcrypt/src/ecc.c ****     ecCLI_SENT_REQ  = 4,
12315:../src/wolfcrypt/src/ecc.c ****     ecCLI_RECV_RESP = 5,
12316:../src/wolfcrypt/src/ecc.c ****     ecCLI_BAD_STATE = 99
12317:../src/wolfcrypt/src/ecc.c **** };
12318:../src/wolfcrypt/src/ecc.c **** 
12319:../src/wolfcrypt/src/ecc.c **** enum ecSrvState {
12320:../src/wolfcrypt/src/ecc.c ****     ecSRV_INIT      = 1,
12321:../src/wolfcrypt/src/ecc.c ****     ecSRV_SALT_GET  = 2,
12322:../src/wolfcrypt/src/ecc.c ****     ecSRV_SALT_SET  = 3,
12323:../src/wolfcrypt/src/ecc.c ****     ecSRV_RECV_REQ  = 4,
12324:../src/wolfcrypt/src/ecc.c ****     ecSRV_SENT_RESP = 5,
12325:../src/wolfcrypt/src/ecc.c ****     ecSRV_BAD_STATE = 99
12326:../src/wolfcrypt/src/ecc.c **** };
12327:../src/wolfcrypt/src/ecc.c **** 
12328:../src/wolfcrypt/src/ecc.c **** 
12329:../src/wolfcrypt/src/ecc.c **** struct ecEncCtx {
12330:../src/wolfcrypt/src/ecc.c ****     const byte* kdfSalt;   /* optional salt for kdf */
12331:../src/wolfcrypt/src/ecc.c ****     const byte* kdfInfo;   /* optional info for kdf */
12332:../src/wolfcrypt/src/ecc.c ****     const byte* macSalt;   /* optional salt for mac */
12333:../src/wolfcrypt/src/ecc.c ****     word32    kdfSaltSz;   /* size of kdfSalt */
12334:../src/wolfcrypt/src/ecc.c ****     word32    kdfInfoSz;   /* size of kdfInfo */
12335:../src/wolfcrypt/src/ecc.c ****     word32    macSaltSz;   /* size of macSalt */
12336:../src/wolfcrypt/src/ecc.c ****     void*     heap;        /* heap hint for memory used */
12337:../src/wolfcrypt/src/ecc.c ****     byte      clientSalt[EXCHANGE_SALT_SZ];  /* for msg exchange */
12338:../src/wolfcrypt/src/ecc.c ****     byte      serverSalt[EXCHANGE_SALT_SZ];  /* for msg exchange */
12339:../src/wolfcrypt/src/ecc.c ****     byte      encAlgo;     /* which encryption type */
12340:../src/wolfcrypt/src/ecc.c ****     byte      kdfAlgo;     /* which key derivation function type */
12341:../src/wolfcrypt/src/ecc.c ****     byte      macAlgo;     /* which mac function type */
12342:../src/wolfcrypt/src/ecc.c ****     byte      protocol;    /* are we REQ_RESP client or server ? */
12343:../src/wolfcrypt/src/ecc.c ****     byte      cliSt;       /* protocol state, for sanity checks */
12344:../src/wolfcrypt/src/ecc.c ****     byte      srvSt;       /* protocol state, for sanity checks */
12345:../src/wolfcrypt/src/ecc.c ****     WC_RNG*   rng;
12346:../src/wolfcrypt/src/ecc.c **** };
12347:../src/wolfcrypt/src/ecc.c **** 
12348:../src/wolfcrypt/src/ecc.c **** /* optional set info, can be called before or after set_peer_salt */
12349:../src/wolfcrypt/src/ecc.c **** int wc_ecc_ctx_set_algo(ecEncCtx* ctx, byte encAlgo, byte kdfAlgo, byte macAlgo)
12350:../src/wolfcrypt/src/ecc.c **** {
12351:../src/wolfcrypt/src/ecc.c ****     if (ctx == NULL)
12352:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
12353:../src/wolfcrypt/src/ecc.c **** 
12354:../src/wolfcrypt/src/ecc.c ****     ctx->encAlgo = encAlgo;
12355:../src/wolfcrypt/src/ecc.c ****     ctx->kdfAlgo = kdfAlgo;
12356:../src/wolfcrypt/src/ecc.c ****     ctx->macAlgo = macAlgo;
12357:../src/wolfcrypt/src/ecc.c **** 
12358:../src/wolfcrypt/src/ecc.c ****     return 0;
12359:../src/wolfcrypt/src/ecc.c **** }
12360:../src/wolfcrypt/src/ecc.c **** 
12361:../src/wolfcrypt/src/ecc.c **** 
12362:../src/wolfcrypt/src/ecc.c **** const byte* wc_ecc_ctx_get_own_salt(ecEncCtx* ctx)
12363:../src/wolfcrypt/src/ecc.c **** {
12364:../src/wolfcrypt/src/ecc.c ****     if (ctx == NULL || ctx->protocol == 0)
12365:../src/wolfcrypt/src/ecc.c ****         return NULL;
12366:../src/wolfcrypt/src/ecc.c **** 
12367:../src/wolfcrypt/src/ecc.c ****     if (ctx->protocol == REQ_RESP_CLIENT) {
12368:../src/wolfcrypt/src/ecc.c ****         if (ctx->cliSt == ecCLI_INIT) {
12369:../src/wolfcrypt/src/ecc.c ****             ctx->cliSt =  ecCLI_SALT_GET;
12370:../src/wolfcrypt/src/ecc.c ****             return ctx->clientSalt;
12371:../src/wolfcrypt/src/ecc.c ****         }
12372:../src/wolfcrypt/src/ecc.c ****         else {
12373:../src/wolfcrypt/src/ecc.c ****             ctx->cliSt = ecCLI_BAD_STATE;
12374:../src/wolfcrypt/src/ecc.c ****             return NULL;
12375:../src/wolfcrypt/src/ecc.c ****         }
12376:../src/wolfcrypt/src/ecc.c ****     }
12377:../src/wolfcrypt/src/ecc.c ****     else if (ctx->protocol == REQ_RESP_SERVER) {
12378:../src/wolfcrypt/src/ecc.c ****         if (ctx->srvSt == ecSRV_INIT) {
12379:../src/wolfcrypt/src/ecc.c ****             ctx->srvSt =  ecSRV_SALT_GET;
12380:../src/wolfcrypt/src/ecc.c ****             return ctx->serverSalt;
12381:../src/wolfcrypt/src/ecc.c ****         }
12382:../src/wolfcrypt/src/ecc.c ****         else {
12383:../src/wolfcrypt/src/ecc.c ****             ctx->srvSt = ecSRV_BAD_STATE;
12384:../src/wolfcrypt/src/ecc.c ****             return NULL;
12385:../src/wolfcrypt/src/ecc.c ****         }
12386:../src/wolfcrypt/src/ecc.c ****     }
12387:../src/wolfcrypt/src/ecc.c **** 
12388:../src/wolfcrypt/src/ecc.c ****     return NULL;
12389:../src/wolfcrypt/src/ecc.c **** }
12390:../src/wolfcrypt/src/ecc.c **** 
12391:../src/wolfcrypt/src/ecc.c **** 
12392:../src/wolfcrypt/src/ecc.c **** /* optional set info, can be called before or after set_peer_salt */
12393:../src/wolfcrypt/src/ecc.c **** int wc_ecc_ctx_set_info(ecEncCtx* ctx, const byte* info, int sz)
12394:../src/wolfcrypt/src/ecc.c **** {
12395:../src/wolfcrypt/src/ecc.c ****     if (ctx == NULL || info == 0 || sz < 0)
12396:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
12397:../src/wolfcrypt/src/ecc.c **** 
12398:../src/wolfcrypt/src/ecc.c ****     ctx->kdfInfo   = info;
12399:../src/wolfcrypt/src/ecc.c ****     ctx->kdfInfoSz = sz;
12400:../src/wolfcrypt/src/ecc.c **** 
12401:../src/wolfcrypt/src/ecc.c ****     return 0;
12402:../src/wolfcrypt/src/ecc.c **** }
12403:../src/wolfcrypt/src/ecc.c **** 
12404:../src/wolfcrypt/src/ecc.c **** 
12405:../src/wolfcrypt/src/ecc.c **** static const char* exchange_info = "Secure Message Exchange";
12406:../src/wolfcrypt/src/ecc.c **** 
12407:../src/wolfcrypt/src/ecc.c **** int wc_ecc_ctx_set_peer_salt(ecEncCtx* ctx, const byte* salt)
12408:../src/wolfcrypt/src/ecc.c **** {
12409:../src/wolfcrypt/src/ecc.c ****     byte tmp[EXCHANGE_SALT_SZ/2];
12410:../src/wolfcrypt/src/ecc.c ****     int  halfSz = EXCHANGE_SALT_SZ/2;
12411:../src/wolfcrypt/src/ecc.c **** 
12412:../src/wolfcrypt/src/ecc.c ****     if (ctx == NULL || ctx->protocol == 0 || salt == NULL)
12413:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
12414:../src/wolfcrypt/src/ecc.c **** 
12415:../src/wolfcrypt/src/ecc.c ****     if (ctx->protocol == REQ_RESP_CLIENT) {
12416:../src/wolfcrypt/src/ecc.c ****         XMEMCPY(ctx->serverSalt, salt, EXCHANGE_SALT_SZ);
12417:../src/wolfcrypt/src/ecc.c ****         if (ctx->cliSt == ecCLI_SALT_GET)
12418:../src/wolfcrypt/src/ecc.c ****             ctx->cliSt =  ecCLI_SALT_SET;
12419:../src/wolfcrypt/src/ecc.c ****         else {
12420:../src/wolfcrypt/src/ecc.c ****             ctx->cliSt =  ecCLI_BAD_STATE;
12421:../src/wolfcrypt/src/ecc.c ****             return BAD_STATE_E;
12422:../src/wolfcrypt/src/ecc.c ****         }
12423:../src/wolfcrypt/src/ecc.c ****     }
12424:../src/wolfcrypt/src/ecc.c ****     else {
12425:../src/wolfcrypt/src/ecc.c ****         XMEMCPY(ctx->clientSalt, salt, EXCHANGE_SALT_SZ);
12426:../src/wolfcrypt/src/ecc.c ****         if (ctx->srvSt == ecSRV_SALT_GET)
12427:../src/wolfcrypt/src/ecc.c ****             ctx->srvSt =  ecSRV_SALT_SET;
12428:../src/wolfcrypt/src/ecc.c ****         else {
12429:../src/wolfcrypt/src/ecc.c ****             ctx->srvSt =  ecSRV_BAD_STATE;
12430:../src/wolfcrypt/src/ecc.c ****             return BAD_STATE_E;
12431:../src/wolfcrypt/src/ecc.c ****         }
12432:../src/wolfcrypt/src/ecc.c ****     }
12433:../src/wolfcrypt/src/ecc.c **** 
12434:../src/wolfcrypt/src/ecc.c ****     /* mix half and half */
12435:../src/wolfcrypt/src/ecc.c ****     /* tmp stores 2nd half of client before overwrite */
12436:../src/wolfcrypt/src/ecc.c ****     XMEMCPY(tmp, ctx->clientSalt + halfSz, halfSz);
12437:../src/wolfcrypt/src/ecc.c ****     XMEMCPY(ctx->clientSalt + halfSz, ctx->serverSalt, halfSz);
12438:../src/wolfcrypt/src/ecc.c ****     XMEMCPY(ctx->serverSalt, tmp, halfSz);
12439:../src/wolfcrypt/src/ecc.c **** 
12440:../src/wolfcrypt/src/ecc.c ****     ctx->kdfSalt   = ctx->clientSalt;
12441:../src/wolfcrypt/src/ecc.c ****     ctx->kdfSaltSz = EXCHANGE_SALT_SZ;
12442:../src/wolfcrypt/src/ecc.c **** 
12443:../src/wolfcrypt/src/ecc.c ****     ctx->macSalt   = ctx->serverSalt;
12444:../src/wolfcrypt/src/ecc.c ****     ctx->macSaltSz = EXCHANGE_SALT_SZ;
12445:../src/wolfcrypt/src/ecc.c **** 
12446:../src/wolfcrypt/src/ecc.c ****     if (ctx->kdfInfo == NULL) {
12447:../src/wolfcrypt/src/ecc.c ****         /* default info */
12448:../src/wolfcrypt/src/ecc.c ****         ctx->kdfInfo   = (const byte*)exchange_info;
12449:../src/wolfcrypt/src/ecc.c ****         ctx->kdfInfoSz = EXCHANGE_INFO_SZ;
12450:../src/wolfcrypt/src/ecc.c ****     }
12451:../src/wolfcrypt/src/ecc.c **** 
12452:../src/wolfcrypt/src/ecc.c ****     return 0;
12453:../src/wolfcrypt/src/ecc.c **** }
12454:../src/wolfcrypt/src/ecc.c **** 
12455:../src/wolfcrypt/src/ecc.c **** 
12456:../src/wolfcrypt/src/ecc.c **** static int ecc_ctx_set_salt(ecEncCtx* ctx, int flags)
12457:../src/wolfcrypt/src/ecc.c **** {
12458:../src/wolfcrypt/src/ecc.c ****     byte* saltBuffer = NULL;
12459:../src/wolfcrypt/src/ecc.c **** 
12460:../src/wolfcrypt/src/ecc.c ****     if (ctx == NULL || flags == 0)
12461:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
12462:../src/wolfcrypt/src/ecc.c **** 
12463:../src/wolfcrypt/src/ecc.c ****     saltBuffer = (flags == REQ_RESP_CLIENT) ? ctx->clientSalt : ctx->serverSalt;
12464:../src/wolfcrypt/src/ecc.c **** 
12465:../src/wolfcrypt/src/ecc.c ****     return wc_RNG_GenerateBlock(ctx->rng, saltBuffer, EXCHANGE_SALT_SZ);
12466:../src/wolfcrypt/src/ecc.c **** }
12467:../src/wolfcrypt/src/ecc.c **** 
12468:../src/wolfcrypt/src/ecc.c **** 
12469:../src/wolfcrypt/src/ecc.c **** static void ecc_ctx_init(ecEncCtx* ctx, int flags, WC_RNG* rng)
12470:../src/wolfcrypt/src/ecc.c **** {
12471:../src/wolfcrypt/src/ecc.c ****     if (ctx) {
12472:../src/wolfcrypt/src/ecc.c ****         XMEMSET(ctx, 0, sizeof(ecEncCtx));
12473:../src/wolfcrypt/src/ecc.c **** 
12474:../src/wolfcrypt/src/ecc.c ****     #if !defined(NO_AES) && defined(HAVE_AES_CBC)
12475:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_AES_128
12476:../src/wolfcrypt/src/ecc.c ****             ctx->encAlgo  = ecAES_128_CBC;
12477:../src/wolfcrypt/src/ecc.c ****         #else
12478:../src/wolfcrypt/src/ecc.c ****             ctx->encAlgo  = ecAES_256_CBC;
12479:../src/wolfcrypt/src/ecc.c ****         #endif
12480:../src/wolfcrypt/src/ecc.c ****     #elif !defined(NO_AES) && defined(WOLFSSL_AES_COUNTER)
12481:../src/wolfcrypt/src/ecc.c ****         #ifdef WOLFSSL_AES_256
12482:../src/wolfcrypt/src/ecc.c ****             ctx->encAlgo  = ecAES_256_CTR;
12483:../src/wolfcrypt/src/ecc.c ****         #else
12484:../src/wolfcrypt/src/ecc.c ****             ctx->encAlgo  = ecAES_128_CTR;
12485:../src/wolfcrypt/src/ecc.c ****         #endif
12486:../src/wolfcrypt/src/ecc.c ****     #else
12487:../src/wolfcrypt/src/ecc.c ****         #error "No valid encryption algorithm for ECIES configured."
12488:../src/wolfcrypt/src/ecc.c ****     #endif
12489:../src/wolfcrypt/src/ecc.c ****         ctx->kdfAlgo  = ecHKDF_SHA256;
12490:../src/wolfcrypt/src/ecc.c ****         ctx->macAlgo  = ecHMAC_SHA256;
12491:../src/wolfcrypt/src/ecc.c ****         ctx->protocol = (byte)flags;
12492:../src/wolfcrypt/src/ecc.c ****         ctx->rng      = rng;
12493:../src/wolfcrypt/src/ecc.c **** 
12494:../src/wolfcrypt/src/ecc.c ****         if (flags == REQ_RESP_CLIENT)
12495:../src/wolfcrypt/src/ecc.c ****             ctx->cliSt = ecCLI_INIT;
12496:../src/wolfcrypt/src/ecc.c ****         if (flags == REQ_RESP_SERVER)
12497:../src/wolfcrypt/src/ecc.c ****             ctx->srvSt = ecSRV_INIT;
12498:../src/wolfcrypt/src/ecc.c ****     }
12499:../src/wolfcrypt/src/ecc.c **** }
12500:../src/wolfcrypt/src/ecc.c **** 
12501:../src/wolfcrypt/src/ecc.c **** 
12502:../src/wolfcrypt/src/ecc.c **** /* allow ecc context reset so user doesn't have to init/free for reuse */
12503:../src/wolfcrypt/src/ecc.c **** int wc_ecc_ctx_reset(ecEncCtx* ctx, WC_RNG* rng)
12504:../src/wolfcrypt/src/ecc.c **** {
12505:../src/wolfcrypt/src/ecc.c ****     if (ctx == NULL || rng == NULL)
12506:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
12507:../src/wolfcrypt/src/ecc.c **** 
12508:../src/wolfcrypt/src/ecc.c ****     ecc_ctx_init(ctx, ctx->protocol, rng);
12509:../src/wolfcrypt/src/ecc.c ****     return ecc_ctx_set_salt(ctx, ctx->protocol);
12510:../src/wolfcrypt/src/ecc.c **** }
12511:../src/wolfcrypt/src/ecc.c **** 
12512:../src/wolfcrypt/src/ecc.c **** 
12513:../src/wolfcrypt/src/ecc.c **** ecEncCtx* wc_ecc_ctx_new_ex(int flags, WC_RNG* rng, void* heap)
12514:../src/wolfcrypt/src/ecc.c **** {
12515:../src/wolfcrypt/src/ecc.c ****     int       ret = 0;
12516:../src/wolfcrypt/src/ecc.c ****     ecEncCtx* ctx = (ecEncCtx*)XMALLOC(sizeof(ecEncCtx), heap,
12517:../src/wolfcrypt/src/ecc.c ****                                                               DYNAMIC_TYPE_ECC);
12518:../src/wolfcrypt/src/ecc.c **** 
12519:../src/wolfcrypt/src/ecc.c ****     if (ctx) {
12520:../src/wolfcrypt/src/ecc.c ****         ctx->protocol = (byte)flags;
12521:../src/wolfcrypt/src/ecc.c ****         ctx->heap     = heap;
12522:../src/wolfcrypt/src/ecc.c ****     }
12523:../src/wolfcrypt/src/ecc.c **** 
12524:../src/wolfcrypt/src/ecc.c ****     ret = wc_ecc_ctx_reset(ctx, rng);
12525:../src/wolfcrypt/src/ecc.c ****     if (ret != 0) {
12526:../src/wolfcrypt/src/ecc.c ****         wc_ecc_ctx_free(ctx);
12527:../src/wolfcrypt/src/ecc.c ****         ctx = NULL;
12528:../src/wolfcrypt/src/ecc.c ****     }
12529:../src/wolfcrypt/src/ecc.c **** 
12530:../src/wolfcrypt/src/ecc.c ****     return ctx;
12531:../src/wolfcrypt/src/ecc.c **** }
12532:../src/wolfcrypt/src/ecc.c **** 
12533:../src/wolfcrypt/src/ecc.c **** 
12534:../src/wolfcrypt/src/ecc.c **** /* alloc/init and set defaults, return new Context  */
12535:../src/wolfcrypt/src/ecc.c **** ecEncCtx* wc_ecc_ctx_new(int flags, WC_RNG* rng)
12536:../src/wolfcrypt/src/ecc.c **** {
12537:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_ctx_new_ex(flags, rng, NULL);
12538:../src/wolfcrypt/src/ecc.c **** }
12539:../src/wolfcrypt/src/ecc.c **** 
12540:../src/wolfcrypt/src/ecc.c **** 
12541:../src/wolfcrypt/src/ecc.c **** /* free any resources, clear any keys */
12542:../src/wolfcrypt/src/ecc.c **** void wc_ecc_ctx_free(ecEncCtx* ctx)
12543:../src/wolfcrypt/src/ecc.c **** {
12544:../src/wolfcrypt/src/ecc.c ****     if (ctx) {
12545:../src/wolfcrypt/src/ecc.c ****         void* heap = ctx->heap;
12546:../src/wolfcrypt/src/ecc.c ****         ForceZero(ctx, sizeof(ecEncCtx));
12547:../src/wolfcrypt/src/ecc.c ****         XFREE(ctx, heap, DYNAMIC_TYPE_ECC);
12548:../src/wolfcrypt/src/ecc.c ****         (void)heap;
12549:../src/wolfcrypt/src/ecc.c ****     }
12550:../src/wolfcrypt/src/ecc.c **** }
12551:../src/wolfcrypt/src/ecc.c **** 
12552:../src/wolfcrypt/src/ecc.c **** static int ecc_get_key_sizes(ecEncCtx* ctx, int* encKeySz, int* ivSz,
12553:../src/wolfcrypt/src/ecc.c ****                              int* keysLen, word32* digestSz, word32* blockSz)
12554:../src/wolfcrypt/src/ecc.c **** {
12555:../src/wolfcrypt/src/ecc.c ****     if (ctx) {
12556:../src/wolfcrypt/src/ecc.c ****         switch (ctx->encAlgo) {
12557:../src/wolfcrypt/src/ecc.c ****         #if !defined(NO_AES) && defined(HAVE_AES_CBC)
12558:../src/wolfcrypt/src/ecc.c ****             case ecAES_128_CBC:
12559:../src/wolfcrypt/src/ecc.c ****                 *encKeySz = KEY_SIZE_128;
12560:../src/wolfcrypt/src/ecc.c ****                 *ivSz     = IV_SIZE_128;
12561:../src/wolfcrypt/src/ecc.c ****                 *blockSz  = AES_BLOCK_SIZE;
12562:../src/wolfcrypt/src/ecc.c ****                 break;
12563:../src/wolfcrypt/src/ecc.c ****             case ecAES_256_CBC:
12564:../src/wolfcrypt/src/ecc.c ****                 *encKeySz = KEY_SIZE_256;
12565:../src/wolfcrypt/src/ecc.c ****                 *ivSz     = IV_SIZE_128;
12566:../src/wolfcrypt/src/ecc.c ****                 *blockSz  = AES_BLOCK_SIZE;
12567:../src/wolfcrypt/src/ecc.c ****                 break;
12568:../src/wolfcrypt/src/ecc.c ****         #endif
12569:../src/wolfcrypt/src/ecc.c ****         #if !defined(NO_AES) && defined(WOLFSSL_AES_COUNTER)
12570:../src/wolfcrypt/src/ecc.c ****             case ecAES_128_CTR:
12571:../src/wolfcrypt/src/ecc.c ****                 *encKeySz = KEY_SIZE_128;
12572:../src/wolfcrypt/src/ecc.c ****                 *ivSz     = IV_SIZE_128;
12573:../src/wolfcrypt/src/ecc.c ****                 *blockSz  = 1;
12574:../src/wolfcrypt/src/ecc.c ****                 break;
12575:../src/wolfcrypt/src/ecc.c ****             case ecAES_256_CTR:
12576:../src/wolfcrypt/src/ecc.c ****                 *encKeySz = KEY_SIZE_256;
12577:../src/wolfcrypt/src/ecc.c ****                 *ivSz     = IV_SIZE_128;
12578:../src/wolfcrypt/src/ecc.c ****                 *blockSz  = 1;
12579:../src/wolfcrypt/src/ecc.c ****                 break;
12580:../src/wolfcrypt/src/ecc.c ****         #endif
12581:../src/wolfcrypt/src/ecc.c ****             default:
12582:../src/wolfcrypt/src/ecc.c ****                 return BAD_FUNC_ARG;
12583:../src/wolfcrypt/src/ecc.c ****         }
12584:../src/wolfcrypt/src/ecc.c **** 
12585:../src/wolfcrypt/src/ecc.c ****         switch (ctx->macAlgo) {
12586:../src/wolfcrypt/src/ecc.c ****             case ecHMAC_SHA256:
12587:../src/wolfcrypt/src/ecc.c ****                 *digestSz = WC_SHA256_DIGEST_SIZE;
12588:../src/wolfcrypt/src/ecc.c ****                 break;
12589:../src/wolfcrypt/src/ecc.c ****             default:
12590:../src/wolfcrypt/src/ecc.c ****                 return BAD_FUNC_ARG;
12591:../src/wolfcrypt/src/ecc.c ****         }
12592:../src/wolfcrypt/src/ecc.c ****     } else
12593:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
12594:../src/wolfcrypt/src/ecc.c **** 
12595:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_ECIES_OLD
12596:../src/wolfcrypt/src/ecc.c ****     *keysLen  = *encKeySz + *ivSz + *digestSz;
12597:../src/wolfcrypt/src/ecc.c **** #else
12598:../src/wolfcrypt/src/ecc.c ****     *keysLen  = *encKeySz + *digestSz;
12599:../src/wolfcrypt/src/ecc.c **** #endif
12600:../src/wolfcrypt/src/ecc.c **** 
12601:../src/wolfcrypt/src/ecc.c ****     return 0;
12602:../src/wolfcrypt/src/ecc.c **** }
12603:../src/wolfcrypt/src/ecc.c **** 
12604:../src/wolfcrypt/src/ecc.c **** 
12605:../src/wolfcrypt/src/ecc.c **** /* ecc encrypt with shared secret run through kdf
12606:../src/wolfcrypt/src/ecc.c ****    ctx holds non default algos and inputs
12607:../src/wolfcrypt/src/ecc.c ****    msgSz should be the right size for encAlgo, i.e., already padded
12608:../src/wolfcrypt/src/ecc.c ****    return 0 on success */
12609:../src/wolfcrypt/src/ecc.c **** int wc_ecc_encrypt_ex(ecc_key* privKey, ecc_key* pubKey, const byte* msg,
12610:../src/wolfcrypt/src/ecc.c ****     word32 msgSz, byte* out, word32* outSz, ecEncCtx* ctx, int compressed)
12611:../src/wolfcrypt/src/ecc.c **** {
12612:../src/wolfcrypt/src/ecc.c ****     int          ret = 0;
12613:../src/wolfcrypt/src/ecc.c ****     word32       blockSz = 0;
12614:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_ECIES_OLD
12615:../src/wolfcrypt/src/ecc.c ****     byte         iv[ECC_MAX_IV_SIZE];
12616:../src/wolfcrypt/src/ecc.c ****     word32       pubKeySz = 0;
12617:../src/wolfcrypt/src/ecc.c **** #endif
12618:../src/wolfcrypt/src/ecc.c ****     word32       digestSz = 0;
12619:../src/wolfcrypt/src/ecc.c ****     ecEncCtx     localCtx;
12620:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
12621:../src/wolfcrypt/src/ecc.c ****     byte*        sharedSecret;
12622:../src/wolfcrypt/src/ecc.c ****     byte*        keys;
12623:../src/wolfcrypt/src/ecc.c **** #else
12624:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECIES_OLD) || !defined(WOLFSSL_ECIES_ISO18033)
12625:../src/wolfcrypt/src/ecc.c ****     byte         sharedSecret[ECC_MAXSIZE];  /* 521 max size */
12626:../src/wolfcrypt/src/ecc.c **** #else
12627:../src/wolfcrypt/src/ecc.c ****     byte         sharedSecret[ECC_MAXSIZE * 3 + 1]; /* Public key too */
12628:../src/wolfcrypt/src/ecc.c **** #endif
12629:../src/wolfcrypt/src/ecc.c ****     byte         keys[ECC_BUFSIZE];         /* max size */
12630:../src/wolfcrypt/src/ecc.c **** #endif
12631:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECIES_OLD) || !defined(WOLFSSL_ECIES_ISO18033)
12632:../src/wolfcrypt/src/ecc.c ****     word32       sharedSz = ECC_MAXSIZE;
12633:../src/wolfcrypt/src/ecc.c **** #else
12634:../src/wolfcrypt/src/ecc.c ****     /* 'Uncompressed' byte | public key x | public key y | secret */
12635:../src/wolfcrypt/src/ecc.c ****     word32       sharedSz = 1 + ECC_MAXSIZE * 3;
12636:../src/wolfcrypt/src/ecc.c **** #endif
12637:../src/wolfcrypt/src/ecc.c ****     int          keysLen = 0;
12638:../src/wolfcrypt/src/ecc.c ****     int          encKeySz = 0;
12639:../src/wolfcrypt/src/ecc.c ****     int          ivSz = 0;
12640:../src/wolfcrypt/src/ecc.c ****     int          offset = 0;         /* keys offset if doing msg exchange */
12641:../src/wolfcrypt/src/ecc.c ****     byte*        encKey = NULL;
12642:../src/wolfcrypt/src/ecc.c ****     byte*        encIv = NULL;
12643:../src/wolfcrypt/src/ecc.c ****     byte*        macKey = NULL;
12644:../src/wolfcrypt/src/ecc.c **** 
12645:../src/wolfcrypt/src/ecc.c ****     if (privKey == NULL || pubKey == NULL || msg == NULL || out == NULL ||
12646:../src/wolfcrypt/src/ecc.c ****                            outSz  == NULL)
12647:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
12648:../src/wolfcrypt/src/ecc.c **** 
12649:../src/wolfcrypt/src/ecc.c ****     if (ctx == NULL) {  /* use defaults */
12650:../src/wolfcrypt/src/ecc.c ****         ecc_ctx_init(&localCtx, 0, NULL);
12651:../src/wolfcrypt/src/ecc.c ****         ctx = &localCtx;
12652:../src/wolfcrypt/src/ecc.c ****     }
12653:../src/wolfcrypt/src/ecc.c **** 
12654:../src/wolfcrypt/src/ecc.c ****     ret = ecc_get_key_sizes(ctx, &encKeySz, &ivSz, &keysLen, &digestSz,
12655:../src/wolfcrypt/src/ecc.c ****                             &blockSz);
12656:../src/wolfcrypt/src/ecc.c ****     if (ret != 0)
12657:../src/wolfcrypt/src/ecc.c ****         return ret;
12658:../src/wolfcrypt/src/ecc.c **** 
12659:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_ECIES_OLD
12660:../src/wolfcrypt/src/ecc.c ****     if (!compressed) {
12661:../src/wolfcrypt/src/ecc.c ****         pubKeySz = 1 + wc_ecc_size(privKey) * 2;
12662:../src/wolfcrypt/src/ecc.c ****     }
12663:../src/wolfcrypt/src/ecc.c ****     else {
12664:../src/wolfcrypt/src/ecc.c ****         pubKeySz = 1 + wc_ecc_size(privKey);
12665:../src/wolfcrypt/src/ecc.c ****     }
12666:../src/wolfcrypt/src/ecc.c **** #else
12667:../src/wolfcrypt/src/ecc.c ****     (void) compressed; /* avoid unused parameter if WOLFSSL_ECIES_OLD is defined */
12668:../src/wolfcrypt/src/ecc.c **** #endif
12669:../src/wolfcrypt/src/ecc.c **** 
12670:../src/wolfcrypt/src/ecc.c ****     if (ctx->protocol == REQ_RESP_SERVER) {
12671:../src/wolfcrypt/src/ecc.c ****         offset = keysLen;
12672:../src/wolfcrypt/src/ecc.c ****         keysLen *= 2;
12673:../src/wolfcrypt/src/ecc.c **** 
12674:../src/wolfcrypt/src/ecc.c ****         if (ctx->srvSt != ecSRV_RECV_REQ)
12675:../src/wolfcrypt/src/ecc.c ****             return BAD_STATE_E;
12676:../src/wolfcrypt/src/ecc.c **** 
12677:../src/wolfcrypt/src/ecc.c ****         ctx->srvSt = ecSRV_BAD_STATE; /* we're done no more ops allowed */
12678:../src/wolfcrypt/src/ecc.c ****     }
12679:../src/wolfcrypt/src/ecc.c ****     else if (ctx->protocol == REQ_RESP_CLIENT) {
12680:../src/wolfcrypt/src/ecc.c ****         if (ctx->cliSt != ecCLI_SALT_SET)
12681:../src/wolfcrypt/src/ecc.c ****             return BAD_STATE_E;
12682:../src/wolfcrypt/src/ecc.c **** 
12683:../src/wolfcrypt/src/ecc.c ****         ctx->cliSt = ecCLI_SENT_REQ; /* only do this once */
12684:../src/wolfcrypt/src/ecc.c ****     }
12685:../src/wolfcrypt/src/ecc.c **** 
12686:../src/wolfcrypt/src/ecc.c ****     if (keysLen > ECC_BUFSIZE) /* keys size */
12687:../src/wolfcrypt/src/ecc.c ****         return BUFFER_E;
12688:../src/wolfcrypt/src/ecc.c **** 
12689:../src/wolfcrypt/src/ecc.c ****     if ((msgSz % blockSz) != 0)
12690:../src/wolfcrypt/src/ecc.c ****         return BAD_PADDING_E;
12691:../src/wolfcrypt/src/ecc.c **** 
12692:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_ECIES_OLD
12693:../src/wolfcrypt/src/ecc.c ****     if (*outSz < (msgSz + digestSz))
12694:../src/wolfcrypt/src/ecc.c ****         return BUFFER_E;
12695:../src/wolfcrypt/src/ecc.c **** #else
12696:../src/wolfcrypt/src/ecc.c ****     if (*outSz < (pubKeySz + msgSz + digestSz))
12697:../src/wolfcrypt/src/ecc.c ****         return BUFFER_E;
12698:../src/wolfcrypt/src/ecc.c **** #endif
12699:../src/wolfcrypt/src/ecc.c **** 
12700:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
12701:../src/wolfcrypt/src/ecc.c ****     if (ctx->rng != NULL && privKey->rng == NULL)
12702:../src/wolfcrypt/src/ecc.c ****         privKey->rng = ctx->rng;
12703:../src/wolfcrypt/src/ecc.c **** #endif
12704:../src/wolfcrypt/src/ecc.c **** 
12705:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_ECIES_OLD
12706:../src/wolfcrypt/src/ecc.c ****     if (privKey->type == ECC_PRIVATEKEY_ONLY) {
12707:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
12708:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_make_pub_ex(privKey, NULL, privKey->rng);
12709:../src/wolfcrypt/src/ecc.c **** #else
12710:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_make_pub_ex(privKey, NULL, NULL);
12711:../src/wolfcrypt/src/ecc.c **** #endif
12712:../src/wolfcrypt/src/ecc.c ****         if (ret != 0)
12713:../src/wolfcrypt/src/ecc.c ****             return ret;
12714:../src/wolfcrypt/src/ecc.c ****     }
12715:../src/wolfcrypt/src/ecc.c ****     ret = wc_ecc_export_x963_ex(privKey, out, &pubKeySz, compressed);
12716:../src/wolfcrypt/src/ecc.c ****     if (ret != 0)
12717:../src/wolfcrypt/src/ecc.c ****         return ret;
12718:../src/wolfcrypt/src/ecc.c ****     out += pubKeySz;
12719:../src/wolfcrypt/src/ecc.c **** #endif
12720:../src/wolfcrypt/src/ecc.c **** 
12721:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
12722:../src/wolfcrypt/src/ecc.c ****     sharedSecret = (byte*)XMALLOC(sharedSz, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
12723:../src/wolfcrypt/src/ecc.c ****     if (sharedSecret == NULL)
12724:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
12725:../src/wolfcrypt/src/ecc.c **** 
12726:../src/wolfcrypt/src/ecc.c ****     keys = (byte*)XMALLOC(ECC_BUFSIZE, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
12727:../src/wolfcrypt/src/ecc.c ****     if (keys == NULL) {
12728:../src/wolfcrypt/src/ecc.c ****         XFREE(sharedSecret, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
12729:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
12730:../src/wolfcrypt/src/ecc.c ****     }
12731:../src/wolfcrypt/src/ecc.c **** #endif
12732:../src/wolfcrypt/src/ecc.c **** 
12733:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(ret = _svr_ret;);
12734:../src/wolfcrypt/src/ecc.c **** 
12735:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_ECIES_ISO18033
12736:../src/wolfcrypt/src/ecc.c ****     XMEMCPY(sharedSecret, out - pubKeySz, pubKeySz);
12737:../src/wolfcrypt/src/ecc.c ****     sharedSz -= pubKeySz;
12738:../src/wolfcrypt/src/ecc.c **** #endif
12739:../src/wolfcrypt/src/ecc.c **** 
12740:../src/wolfcrypt/src/ecc.c ****     do {
12741:../src/wolfcrypt/src/ecc.c ****     #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
12742:../src/wolfcrypt/src/ecc.c ****         ret = wc_AsyncWait(ret, &privKey->asyncDev, WC_ASYNC_FLAG_CALL_AGAIN);
12743:../src/wolfcrypt/src/ecc.c ****         if (ret != 0)
12744:../src/wolfcrypt/src/ecc.c ****             break;
12745:../src/wolfcrypt/src/ecc.c ****     #endif
12746:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_ECIES_ISO18033
12747:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_shared_secret(privKey, pubKey, sharedSecret, &sharedSz);
12748:../src/wolfcrypt/src/ecc.c ****     #else
12749:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_shared_secret(privKey, pubKey, sharedSecret + pubKeySz,
12750:../src/wolfcrypt/src/ecc.c ****                                                                      &sharedSz);
12751:../src/wolfcrypt/src/ecc.c ****     #endif
12752:../src/wolfcrypt/src/ecc.c ****     } while (ret == WC_PENDING_E);
12753:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
12754:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_ECIES_ISO18033
12755:../src/wolfcrypt/src/ecc.c ****         /* KDF data is encoded public key and secret. */
12756:../src/wolfcrypt/src/ecc.c ****         sharedSz += pubKeySz;
12757:../src/wolfcrypt/src/ecc.c ****     #endif
12758:../src/wolfcrypt/src/ecc.c ****         switch (ctx->kdfAlgo) {
12759:../src/wolfcrypt/src/ecc.c ****             case ecHKDF_SHA256 :
12760:../src/wolfcrypt/src/ecc.c ****                 ret = wc_HKDF(WC_SHA256, sharedSecret, sharedSz, ctx->kdfSalt,
12761:../src/wolfcrypt/src/ecc.c ****                            ctx->kdfSaltSz, ctx->kdfInfo, ctx->kdfInfoSz,
12762:../src/wolfcrypt/src/ecc.c ****                            keys, keysLen);
12763:../src/wolfcrypt/src/ecc.c ****                 break;
12764:../src/wolfcrypt/src/ecc.c **** 
12765:../src/wolfcrypt/src/ecc.c ****             default:
12766:../src/wolfcrypt/src/ecc.c ****                 ret = BAD_FUNC_ARG;
12767:../src/wolfcrypt/src/ecc.c ****                 break;
12768:../src/wolfcrypt/src/ecc.c ****         }
12769:../src/wolfcrypt/src/ecc.c ****     }
12770:../src/wolfcrypt/src/ecc.c **** 
12771:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
12772:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_ECIES_OLD
12773:../src/wolfcrypt/src/ecc.c ****         encKey = keys + offset;
12774:../src/wolfcrypt/src/ecc.c ****         encIv  = encKey + encKeySz;
12775:../src/wolfcrypt/src/ecc.c ****         macKey = encKey + encKeySz + ivSz;
12776:../src/wolfcrypt/src/ecc.c ****     #else
12777:../src/wolfcrypt/src/ecc.c ****         XMEMSET(iv, 0, ivSz);
12778:../src/wolfcrypt/src/ecc.c ****         encKey = keys + offset;
12779:../src/wolfcrypt/src/ecc.c ****         encIv  = iv;
12780:../src/wolfcrypt/src/ecc.c ****         macKey = encKey + encKeySz;
12781:../src/wolfcrypt/src/ecc.c ****     #endif
12782:../src/wolfcrypt/src/ecc.c **** 
12783:../src/wolfcrypt/src/ecc.c ****        switch (ctx->encAlgo) {
12784:../src/wolfcrypt/src/ecc.c ****             case ecAES_128_CBC:
12785:../src/wolfcrypt/src/ecc.c ****             case ecAES_256_CBC:
12786:../src/wolfcrypt/src/ecc.c ****             {
12787:../src/wolfcrypt/src/ecc.c ****         #if !defined(NO_AES) && defined(HAVE_AES_CBC)
12788:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
12789:../src/wolfcrypt/src/ecc.c ****                 Aes *aes = (Aes *)XMALLOC(sizeof *aes, ctx->heap,
12790:../src/wolfcrypt/src/ecc.c ****                                           DYNAMIC_TYPE_AES);
12791:../src/wolfcrypt/src/ecc.c ****                 if (aes == NULL) {
12792:../src/wolfcrypt/src/ecc.c ****                     ret = MEMORY_E;
12793:../src/wolfcrypt/src/ecc.c ****                     break;
12794:../src/wolfcrypt/src/ecc.c ****                 }
12795:../src/wolfcrypt/src/ecc.c ****             #else
12796:../src/wolfcrypt/src/ecc.c ****                 Aes aes[1];
12797:../src/wolfcrypt/src/ecc.c ****             #endif
12798:../src/wolfcrypt/src/ecc.c ****                 ret = wc_AesInit(aes, NULL, INVALID_DEVID);
12799:../src/wolfcrypt/src/ecc.c ****                 if (ret == 0) {
12800:../src/wolfcrypt/src/ecc.c ****                     ret = wc_AesSetKey(aes, encKey, encKeySz, encIv,
12801:../src/wolfcrypt/src/ecc.c ****                                                                 AES_ENCRYPTION);
12802:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0) {
12803:../src/wolfcrypt/src/ecc.c ****                         ret = wc_AesCbcEncrypt(aes, out, msg, msgSz);
12804:../src/wolfcrypt/src/ecc.c ****                     #if defined(WOLFSSL_ASYNC_CRYPT) && \
12805:../src/wolfcrypt/src/ecc.c ****                                                     defined(WC_ASYNC_ENABLE_AES)
12806:../src/wolfcrypt/src/ecc.c ****                         ret = wc_AsyncWait(ret, &aes->asyncDev,
12807:../src/wolfcrypt/src/ecc.c ****                                             WC_ASYNC_FLAG_NONE);
12808:../src/wolfcrypt/src/ecc.c ****                     #endif
12809:../src/wolfcrypt/src/ecc.c ****                     }
12810:../src/wolfcrypt/src/ecc.c ****                     wc_AesFree(aes);
12811:../src/wolfcrypt/src/ecc.c ****                 }
12812:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
12813:../src/wolfcrypt/src/ecc.c ****                 XFREE(aes, ctx->heap, DYNAMIC_TYPE_AES);
12814:../src/wolfcrypt/src/ecc.c ****             #endif
12815:../src/wolfcrypt/src/ecc.c ****         #else
12816:../src/wolfcrypt/src/ecc.c ****                 ret = NOT_COMPILED_IN;
12817:../src/wolfcrypt/src/ecc.c ****         #endif
12818:../src/wolfcrypt/src/ecc.c ****                 break;
12819:../src/wolfcrypt/src/ecc.c ****             }
12820:../src/wolfcrypt/src/ecc.c ****             case ecAES_128_CTR:
12821:../src/wolfcrypt/src/ecc.c ****             case ecAES_256_CTR:
12822:../src/wolfcrypt/src/ecc.c ****             {
12823:../src/wolfcrypt/src/ecc.c ****         #if !defined(NO_AES) && defined(WOLFSSL_AES_COUNTER)
12824:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
12825:../src/wolfcrypt/src/ecc.c ****                 Aes *aes = (Aes *)XMALLOC(sizeof *aes, ctx->heap,
12826:../src/wolfcrypt/src/ecc.c ****                                             DYNAMIC_TYPE_AES);
12827:../src/wolfcrypt/src/ecc.c ****                 if (aes == NULL) {
12828:../src/wolfcrypt/src/ecc.c ****                     ret = MEMORY_E;
12829:../src/wolfcrypt/src/ecc.c ****                     break;
12830:../src/wolfcrypt/src/ecc.c ****                 }
12831:../src/wolfcrypt/src/ecc.c ****             #else
12832:../src/wolfcrypt/src/ecc.c ****                 Aes aes[1];
12833:../src/wolfcrypt/src/ecc.c ****             #endif
12834:../src/wolfcrypt/src/ecc.c ****                 ret = wc_AesInit(aes, NULL, INVALID_DEVID);
12835:../src/wolfcrypt/src/ecc.c ****                 if (ret == 0) {
12836:../src/wolfcrypt/src/ecc.c ****                     ret = wc_AesSetKey(aes, encKey, encKeySz, encIv,
12837:../src/wolfcrypt/src/ecc.c ****                                                                 AES_ENCRYPTION);
12838:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0) {
12839:../src/wolfcrypt/src/ecc.c ****                         ret = wc_AesCtrEncrypt(aes, out, msg, msgSz);
12840:../src/wolfcrypt/src/ecc.c ****                     #if defined(WOLFSSL_ASYNC_CRYPT) && \
12841:../src/wolfcrypt/src/ecc.c ****                                                     defined(WC_ASYNC_ENABLE_AES)
12842:../src/wolfcrypt/src/ecc.c ****                         ret = wc_AsyncWait(ret, &aes->asyncDev,
12843:../src/wolfcrypt/src/ecc.c ****                                             WC_ASYNC_FLAG_NONE);
12844:../src/wolfcrypt/src/ecc.c ****                     #endif
12845:../src/wolfcrypt/src/ecc.c ****                     }
12846:../src/wolfcrypt/src/ecc.c ****                     wc_AesFree(aes);
12847:../src/wolfcrypt/src/ecc.c ****                 }
12848:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
12849:../src/wolfcrypt/src/ecc.c ****                 XFREE(aes, ctx->heap, DYNAMIC_TYPE_AES);
12850:../src/wolfcrypt/src/ecc.c ****             #endif
12851:../src/wolfcrypt/src/ecc.c ****         #else
12852:../src/wolfcrypt/src/ecc.c ****                 ret = NOT_COMPILED_IN;
12853:../src/wolfcrypt/src/ecc.c ****         #endif
12854:../src/wolfcrypt/src/ecc.c ****                 break;
12855:../src/wolfcrypt/src/ecc.c ****             }
12856:../src/wolfcrypt/src/ecc.c ****             default:
12857:../src/wolfcrypt/src/ecc.c ****                 ret = BAD_FUNC_ARG;
12858:../src/wolfcrypt/src/ecc.c ****                 break;
12859:../src/wolfcrypt/src/ecc.c ****         }
12860:../src/wolfcrypt/src/ecc.c ****     }
12861:../src/wolfcrypt/src/ecc.c **** 
12862:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
12863:../src/wolfcrypt/src/ecc.c ****         switch (ctx->macAlgo) {
12864:../src/wolfcrypt/src/ecc.c ****             case ecHMAC_SHA256:
12865:../src/wolfcrypt/src/ecc.c ****             {
12866:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
12867:../src/wolfcrypt/src/ecc.c ****                 Hmac *hmac = (Hmac *)XMALLOC(sizeof *hmac, ctx->heap,
12868:../src/wolfcrypt/src/ecc.c ****                                              DYNAMIC_TYPE_HMAC);
12869:../src/wolfcrypt/src/ecc.c ****                 if (hmac == NULL) {
12870:../src/wolfcrypt/src/ecc.c ****                     ret = MEMORY_E;
12871:../src/wolfcrypt/src/ecc.c ****                     break;
12872:../src/wolfcrypt/src/ecc.c ****                 }
12873:../src/wolfcrypt/src/ecc.c ****             #else
12874:../src/wolfcrypt/src/ecc.c ****                 Hmac hmac[1];
12875:../src/wolfcrypt/src/ecc.c ****             #endif
12876:../src/wolfcrypt/src/ecc.c ****                 ret = wc_HmacInit(hmac, NULL, INVALID_DEVID);
12877:../src/wolfcrypt/src/ecc.c ****                 if (ret == 0) {
12878:../src/wolfcrypt/src/ecc.c ****                     ret = wc_HmacSetKey(hmac, WC_SHA256, macKey,
12879:../src/wolfcrypt/src/ecc.c ****                                                          WC_SHA256_DIGEST_SIZE);
12880:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0)
12881:../src/wolfcrypt/src/ecc.c ****                         ret = wc_HmacUpdate(hmac, out, msgSz);
12882:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0)
12883:../src/wolfcrypt/src/ecc.c ****                         ret = wc_HmacUpdate(hmac, ctx->macSalt, ctx->macSaltSz);
12884:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0)
12885:../src/wolfcrypt/src/ecc.c ****                         ret = wc_HmacFinal(hmac, out+msgSz);
12886:../src/wolfcrypt/src/ecc.c ****                     wc_HmacFree(hmac);
12887:../src/wolfcrypt/src/ecc.c ****                 }
12888:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
12889:../src/wolfcrypt/src/ecc.c ****                 XFREE(hmac, ctx->heap, DYNAMIC_TYPE_HMAC);
12890:../src/wolfcrypt/src/ecc.c ****             #endif
12891:../src/wolfcrypt/src/ecc.c ****                 break;
12892:../src/wolfcrypt/src/ecc.c ****             }
12893:../src/wolfcrypt/src/ecc.c **** 
12894:../src/wolfcrypt/src/ecc.c ****             default:
12895:../src/wolfcrypt/src/ecc.c ****                 ret = BAD_FUNC_ARG;
12896:../src/wolfcrypt/src/ecc.c ****                 break;
12897:../src/wolfcrypt/src/ecc.c ****         }
12898:../src/wolfcrypt/src/ecc.c ****     }
12899:../src/wolfcrypt/src/ecc.c **** 
12900:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
12901:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_ECIES_OLD
12902:../src/wolfcrypt/src/ecc.c ****         *outSz = msgSz + digestSz;
12903:../src/wolfcrypt/src/ecc.c **** #else
12904:../src/wolfcrypt/src/ecc.c ****         *outSz = pubKeySz + msgSz + digestSz;
12905:../src/wolfcrypt/src/ecc.c **** #endif
12906:../src/wolfcrypt/src/ecc.c ****     }
12907:../src/wolfcrypt/src/ecc.c **** 
12908:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
12909:../src/wolfcrypt/src/ecc.c **** 
12910:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
12911:../src/wolfcrypt/src/ecc.c ****     XFREE(sharedSecret, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
12912:../src/wolfcrypt/src/ecc.c ****     XFREE(keys, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
12913:../src/wolfcrypt/src/ecc.c **** #endif
12914:../src/wolfcrypt/src/ecc.c **** 
12915:../src/wolfcrypt/src/ecc.c ****     return ret;
12916:../src/wolfcrypt/src/ecc.c **** }
12917:../src/wolfcrypt/src/ecc.c **** 
12918:../src/wolfcrypt/src/ecc.c **** /* ecc encrypt with shared secret run through kdf
12919:../src/wolfcrypt/src/ecc.c ****    ctx holds non default algos and inputs
12920:../src/wolfcrypt/src/ecc.c ****    msgSz should be the right size for encAlgo, i.e., already padded
12921:../src/wolfcrypt/src/ecc.c ****    return 0 on success */
12922:../src/wolfcrypt/src/ecc.c **** int wc_ecc_encrypt(ecc_key* privKey, ecc_key* pubKey, const byte* msg,
12923:../src/wolfcrypt/src/ecc.c ****                 word32 msgSz, byte* out, word32* outSz, ecEncCtx* ctx)
12924:../src/wolfcrypt/src/ecc.c **** {
12925:../src/wolfcrypt/src/ecc.c ****     return wc_ecc_encrypt_ex(privKey, pubKey, msg, msgSz, out, outSz, ctx, 0);
12926:../src/wolfcrypt/src/ecc.c **** }
12927:../src/wolfcrypt/src/ecc.c **** 
12928:../src/wolfcrypt/src/ecc.c **** /* ecc decrypt with shared secret run through kdf
12929:../src/wolfcrypt/src/ecc.c ****    ctx holds non default algos and inputs
12930:../src/wolfcrypt/src/ecc.c ****    return 0 on success */
12931:../src/wolfcrypt/src/ecc.c **** int wc_ecc_decrypt(ecc_key* privKey, ecc_key* pubKey, const byte* msg,
12932:../src/wolfcrypt/src/ecc.c ****                 word32 msgSz, byte* out, word32* outSz, ecEncCtx* ctx)
12933:../src/wolfcrypt/src/ecc.c **** {
12934:../src/wolfcrypt/src/ecc.c ****     int          ret = 0;
12935:../src/wolfcrypt/src/ecc.c ****     word32       blockSz = 0;
12936:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_ECIES_OLD
12937:../src/wolfcrypt/src/ecc.c ****     byte         iv[ECC_MAX_IV_SIZE];
12938:../src/wolfcrypt/src/ecc.c ****     word32       pubKeySz = 0;
12939:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
12940:../src/wolfcrypt/src/ecc.c ****     ecc_key*     peerKey = NULL;
12941:../src/wolfcrypt/src/ecc.c **** #else
12942:../src/wolfcrypt/src/ecc.c ****     ecc_key      peerKey[1];
12943:../src/wolfcrypt/src/ecc.c **** #endif
12944:../src/wolfcrypt/src/ecc.c **** #endif
12945:../src/wolfcrypt/src/ecc.c ****     word32       digestSz = 0;
12946:../src/wolfcrypt/src/ecc.c ****     ecEncCtx     localCtx;
12947:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
12948:../src/wolfcrypt/src/ecc.c ****     byte*        sharedSecret;
12949:../src/wolfcrypt/src/ecc.c ****     byte*        keys;
12950:../src/wolfcrypt/src/ecc.c **** #else
12951:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECIES_OLD) || !defined(WOLFSSL_ECIES_ISO18033)
12952:../src/wolfcrypt/src/ecc.c ****     byte         sharedSecret[ECC_MAXSIZE];  /* 521 max size */
12953:../src/wolfcrypt/src/ecc.c **** #else
12954:../src/wolfcrypt/src/ecc.c ****     byte         sharedSecret[ECC_MAXSIZE * 3 + 1]; /* Public key too */
12955:../src/wolfcrypt/src/ecc.c **** #endif
12956:../src/wolfcrypt/src/ecc.c ****     byte         keys[ECC_BUFSIZE];         /* max size */
12957:../src/wolfcrypt/src/ecc.c **** #endif
12958:../src/wolfcrypt/src/ecc.c **** #if defined(WOLFSSL_ECIES_OLD) || !defined(WOLFSSL_ECIES_ISO18033)
12959:../src/wolfcrypt/src/ecc.c ****     word32       sharedSz = ECC_MAXSIZE;
12960:../src/wolfcrypt/src/ecc.c **** #else
12961:../src/wolfcrypt/src/ecc.c ****     word32       sharedSz = ECC_MAXSIZE * 3 + 1;
12962:../src/wolfcrypt/src/ecc.c **** #endif
12963:../src/wolfcrypt/src/ecc.c ****     int          keysLen = 0;
12964:../src/wolfcrypt/src/ecc.c ****     int          encKeySz = 0;
12965:../src/wolfcrypt/src/ecc.c ****     int          ivSz = 0;
12966:../src/wolfcrypt/src/ecc.c ****     int          offset = 0;       /* in case using msg exchange */
12967:../src/wolfcrypt/src/ecc.c ****     byte*        encKey = NULL;
12968:../src/wolfcrypt/src/ecc.c ****     byte*        encIv = NULL;
12969:../src/wolfcrypt/src/ecc.c ****     byte*        macKey = NULL;
12970:../src/wolfcrypt/src/ecc.c **** 
12971:../src/wolfcrypt/src/ecc.c **** 
12972:../src/wolfcrypt/src/ecc.c ****     if (privKey == NULL || msg == NULL || out == NULL || outSz  == NULL)
12973:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
12974:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_ECIES_OLD
12975:../src/wolfcrypt/src/ecc.c ****     if (pubKey == NULL)
12976:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
12977:../src/wolfcrypt/src/ecc.c **** #endif
12978:../src/wolfcrypt/src/ecc.c **** 
12979:../src/wolfcrypt/src/ecc.c ****     if (ctx == NULL) {  /* use defaults */
12980:../src/wolfcrypt/src/ecc.c ****         ecc_ctx_init(&localCtx, 0, NULL);
12981:../src/wolfcrypt/src/ecc.c ****         ctx = &localCtx;
12982:../src/wolfcrypt/src/ecc.c ****     }
12983:../src/wolfcrypt/src/ecc.c **** 
12984:../src/wolfcrypt/src/ecc.c ****     ret = ecc_get_key_sizes(ctx, &encKeySz, &ivSz, &keysLen, &digestSz,
12985:../src/wolfcrypt/src/ecc.c ****                             &blockSz);
12986:../src/wolfcrypt/src/ecc.c ****     if (ret != 0)
12987:../src/wolfcrypt/src/ecc.c ****         return ret;
12988:../src/wolfcrypt/src/ecc.c **** 
12989:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_ECIES_OLD
12990:../src/wolfcrypt/src/ecc.c ****     ret = ecc_public_key_size(privKey, &pubKeySz);
12991:../src/wolfcrypt/src/ecc.c ****     if (ret != 0)
12992:../src/wolfcrypt/src/ecc.c ****         return ret;
12993:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
12994:../src/wolfcrypt/src/ecc.c ****     if ((msgSz > 1) && ((msg[0] == 0x02) || (msg[0] == 0x03))) {
12995:../src/wolfcrypt/src/ecc.c ****         pubKeySz = (pubKeySz / 2) + 1;
12996:../src/wolfcrypt/src/ecc.c ****     }
12997:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_COMP_KEY */
12998:../src/wolfcrypt/src/ecc.c **** #endif /* WOLFSSL_ECIES_OLD */
12999:../src/wolfcrypt/src/ecc.c **** 
13000:../src/wolfcrypt/src/ecc.c ****     if (ctx->protocol == REQ_RESP_CLIENT) {
13001:../src/wolfcrypt/src/ecc.c ****         offset = keysLen;
13002:../src/wolfcrypt/src/ecc.c ****         keysLen *= 2;
13003:../src/wolfcrypt/src/ecc.c **** 
13004:../src/wolfcrypt/src/ecc.c ****         if (ctx->cliSt != ecCLI_SENT_REQ)
13005:../src/wolfcrypt/src/ecc.c ****             return BAD_STATE_E;
13006:../src/wolfcrypt/src/ecc.c **** 
13007:../src/wolfcrypt/src/ecc.c ****         ctx->cliSt = ecSRV_BAD_STATE; /* we're done no more ops allowed */
13008:../src/wolfcrypt/src/ecc.c ****     }
13009:../src/wolfcrypt/src/ecc.c ****     else if (ctx->protocol == REQ_RESP_SERVER) {
13010:../src/wolfcrypt/src/ecc.c ****         if (ctx->srvSt != ecSRV_SALT_SET)
13011:../src/wolfcrypt/src/ecc.c ****             return BAD_STATE_E;
13012:../src/wolfcrypt/src/ecc.c **** 
13013:../src/wolfcrypt/src/ecc.c ****         ctx->srvSt = ecSRV_RECV_REQ; /* only do this once */
13014:../src/wolfcrypt/src/ecc.c ****     }
13015:../src/wolfcrypt/src/ecc.c **** 
13016:../src/wolfcrypt/src/ecc.c ****     if (keysLen > ECC_BUFSIZE) /* keys size */
13017:../src/wolfcrypt/src/ecc.c ****         return BUFFER_E;
13018:../src/wolfcrypt/src/ecc.c **** 
13019:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_ECIES_OLD
13020:../src/wolfcrypt/src/ecc.c ****     if (((msgSz - digestSz) % blockSz) != 0)
13021:../src/wolfcrypt/src/ecc.c ****         return BAD_PADDING_E;
13022:../src/wolfcrypt/src/ecc.c **** 
13023:../src/wolfcrypt/src/ecc.c ****     if (*outSz < (msgSz - digestSz))
13024:../src/wolfcrypt/src/ecc.c ****         return BUFFER_E;
13025:../src/wolfcrypt/src/ecc.c **** #else
13026:../src/wolfcrypt/src/ecc.c ****     if (((msgSz - digestSz - pubKeySz) % blockSz) != 0)
13027:../src/wolfcrypt/src/ecc.c ****         return BAD_PADDING_E;
13028:../src/wolfcrypt/src/ecc.c **** 
13029:../src/wolfcrypt/src/ecc.c ****     if (msgSz < pubKeySz + blockSz + digestSz)
13030:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
13031:../src/wolfcrypt/src/ecc.c ****     if (*outSz < (msgSz - digestSz - pubKeySz))
13032:../src/wolfcrypt/src/ecc.c ****         return BUFFER_E;
13033:../src/wolfcrypt/src/ecc.c **** #endif
13034:../src/wolfcrypt/src/ecc.c **** 
13035:../src/wolfcrypt/src/ecc.c **** #ifdef ECC_TIMING_RESISTANT
13036:../src/wolfcrypt/src/ecc.c ****     if (ctx->rng != NULL && privKey->rng == NULL)
13037:../src/wolfcrypt/src/ecc.c ****         privKey->rng = ctx->rng;
13038:../src/wolfcrypt/src/ecc.c **** #endif
13039:../src/wolfcrypt/src/ecc.c **** 
13040:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13041:../src/wolfcrypt/src/ecc.c ****     sharedSecret = (byte*)XMALLOC(sharedSz, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
13042:../src/wolfcrypt/src/ecc.c ****     if (sharedSecret == NULL) {
13043:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_ECIES_OLD
13044:../src/wolfcrypt/src/ecc.c ****         if (pubKey == peerKey)
13045:../src/wolfcrypt/src/ecc.c ****             wc_ecc_free(peerKey);
13046:../src/wolfcrypt/src/ecc.c ****     #endif
13047:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
13048:../src/wolfcrypt/src/ecc.c ****     }
13049:../src/wolfcrypt/src/ecc.c **** 
13050:../src/wolfcrypt/src/ecc.c ****     keys = (byte*)XMALLOC(ECC_BUFSIZE, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
13051:../src/wolfcrypt/src/ecc.c ****     if (keys == NULL) {
13052:../src/wolfcrypt/src/ecc.c ****         XFREE(sharedSecret, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
13053:../src/wolfcrypt/src/ecc.c ****     #ifndef WOLFSSL_ECIES_OLD
13054:../src/wolfcrypt/src/ecc.c ****         if (pubKey == peerKey)
13055:../src/wolfcrypt/src/ecc.c ****             wc_ecc_free(peerKey);
13056:../src/wolfcrypt/src/ecc.c ****     #endif
13057:../src/wolfcrypt/src/ecc.c ****         return MEMORY_E;
13058:../src/wolfcrypt/src/ecc.c ****     }
13059:../src/wolfcrypt/src/ecc.c **** #endif
13060:../src/wolfcrypt/src/ecc.c **** 
13061:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(ret = _svr_ret;);
13062:../src/wolfcrypt/src/ecc.c **** 
13063:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_ECIES_OLD
13064:../src/wolfcrypt/src/ecc.c ****     if (pubKey == NULL) {
13065:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13066:../src/wolfcrypt/src/ecc.c ****         peerKey = (ecc_key*)XMALLOC(sizeof(*peerKey), ctx->heap,
13067:../src/wolfcrypt/src/ecc.c ****                                                        DYNAMIC_TYPE_ECC_BUFFER);
13068:../src/wolfcrypt/src/ecc.c ****         if (peerKey == NULL)
13069:../src/wolfcrypt/src/ecc.c ****             ret = MEMORY_E;
13070:../src/wolfcrypt/src/ecc.c **** #endif
13071:../src/wolfcrypt/src/ecc.c ****         pubKey = peerKey;
13072:../src/wolfcrypt/src/ecc.c ****     }
13073:../src/wolfcrypt/src/ecc.c ****     else {
13074:../src/wolfcrypt/src/ecc.c ****         /* if a public key was passed in we should free it here before init
13075:../src/wolfcrypt/src/ecc.c ****          * and import */
13076:../src/wolfcrypt/src/ecc.c ****         wc_ecc_free(pubKey);
13077:../src/wolfcrypt/src/ecc.c ****     }
13078:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
13079:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_init_ex(pubKey, privKey->heap, INVALID_DEVID);
13080:../src/wolfcrypt/src/ecc.c ****     }
13081:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
13082:../src/wolfcrypt/src/ecc.c ****         ret = wc_ecc_import_x963_ex(msg, pubKeySz, pubKey, privKey->dp->id);
13083:../src/wolfcrypt/src/ecc.c ****     }
13084:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
13085:../src/wolfcrypt/src/ecc.c ****         /* Point is not MACed. */
13086:../src/wolfcrypt/src/ecc.c ****         msg += pubKeySz;
13087:../src/wolfcrypt/src/ecc.c ****         msgSz -= pubKeySz;
13088:../src/wolfcrypt/src/ecc.c ****     }
13089:../src/wolfcrypt/src/ecc.c **** #endif
13090:../src/wolfcrypt/src/ecc.c **** 
13091:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
13092:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_ECIES_ISO18033
13093:../src/wolfcrypt/src/ecc.c ****         XMEMCPY(sharedSecret, msg - pubKeySz, pubKeySz);
13094:../src/wolfcrypt/src/ecc.c ****         sharedSz -= pubKeySz;
13095:../src/wolfcrypt/src/ecc.c ****     #endif
13096:../src/wolfcrypt/src/ecc.c **** 
13097:../src/wolfcrypt/src/ecc.c ****         do {
13098:../src/wolfcrypt/src/ecc.c ****         #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
13099:../src/wolfcrypt/src/ecc.c ****             ret = wc_AsyncWait(ret, &privKey->asyncDev,
13100:../src/wolfcrypt/src/ecc.c ****                                                      WC_ASYNC_FLAG_CALL_AGAIN);
13101:../src/wolfcrypt/src/ecc.c ****             if (ret != 0)
13102:../src/wolfcrypt/src/ecc.c ****                 break;
13103:../src/wolfcrypt/src/ecc.c ****         #endif
13104:../src/wolfcrypt/src/ecc.c ****         #ifndef WOLFSSL_ECIES_ISO18033
13105:../src/wolfcrypt/src/ecc.c ****             ret = wc_ecc_shared_secret(privKey, pubKey, sharedSecret,
13106:../src/wolfcrypt/src/ecc.c ****                                                                     &sharedSz);
13107:../src/wolfcrypt/src/ecc.c ****         #else
13108:../src/wolfcrypt/src/ecc.c ****             ret = wc_ecc_shared_secret(privKey, pubKey, sharedSecret +
13109:../src/wolfcrypt/src/ecc.c ****                                                           pubKeySz, &sharedSz);
13110:../src/wolfcrypt/src/ecc.c ****         #endif
13111:../src/wolfcrypt/src/ecc.c ****         } while (ret == WC_PENDING_E);
13112:../src/wolfcrypt/src/ecc.c ****     }
13113:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
13114:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_ECIES_ISO18033
13115:../src/wolfcrypt/src/ecc.c ****         /* KDF data is encoded public key and secret. */
13116:../src/wolfcrypt/src/ecc.c ****         sharedSz += pubKeySz;
13117:../src/wolfcrypt/src/ecc.c ****     #endif
13118:../src/wolfcrypt/src/ecc.c ****         switch (ctx->kdfAlgo) {
13119:../src/wolfcrypt/src/ecc.c ****             case ecHKDF_SHA256 :
13120:../src/wolfcrypt/src/ecc.c ****                 ret = wc_HKDF(WC_SHA256, sharedSecret, sharedSz, ctx->kdfSalt,
13121:../src/wolfcrypt/src/ecc.c ****                            ctx->kdfSaltSz, ctx->kdfInfo, ctx->kdfInfoSz,
13122:../src/wolfcrypt/src/ecc.c ****                            keys, keysLen);
13123:../src/wolfcrypt/src/ecc.c ****                 break;
13124:../src/wolfcrypt/src/ecc.c **** 
13125:../src/wolfcrypt/src/ecc.c ****             default:
13126:../src/wolfcrypt/src/ecc.c ****                 ret = BAD_FUNC_ARG;
13127:../src/wolfcrypt/src/ecc.c ****                 break;
13128:../src/wolfcrypt/src/ecc.c ****          }
13129:../src/wolfcrypt/src/ecc.c ****     }
13130:../src/wolfcrypt/src/ecc.c **** 
13131:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
13132:../src/wolfcrypt/src/ecc.c ****     #ifdef WOLFSSL_ECIES_OLD
13133:../src/wolfcrypt/src/ecc.c ****         encKey = keys + offset;
13134:../src/wolfcrypt/src/ecc.c ****         encIv  = encKey + encKeySz;
13135:../src/wolfcrypt/src/ecc.c ****         macKey = encKey + encKeySz + ivSz;
13136:../src/wolfcrypt/src/ecc.c ****     #else
13137:../src/wolfcrypt/src/ecc.c ****         XMEMSET(iv, 0, ivSz);
13138:../src/wolfcrypt/src/ecc.c ****         encKey = keys + offset;
13139:../src/wolfcrypt/src/ecc.c ****         encIv  = iv;
13140:../src/wolfcrypt/src/ecc.c ****         macKey = encKey + encKeySz;
13141:../src/wolfcrypt/src/ecc.c ****     #endif
13142:../src/wolfcrypt/src/ecc.c **** 
13143:../src/wolfcrypt/src/ecc.c ****         switch (ctx->macAlgo) {
13144:../src/wolfcrypt/src/ecc.c ****             case ecHMAC_SHA256:
13145:../src/wolfcrypt/src/ecc.c ****             {
13146:../src/wolfcrypt/src/ecc.c ****                 byte verify[WC_SHA256_DIGEST_SIZE];
13147:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
13148:../src/wolfcrypt/src/ecc.c ****                 Hmac *hmac = (Hmac *)XMALLOC(sizeof *hmac, ctx->heap,
13149:../src/wolfcrypt/src/ecc.c ****                                              DYNAMIC_TYPE_HMAC);
13150:../src/wolfcrypt/src/ecc.c ****                 if (hmac == NULL) {
13151:../src/wolfcrypt/src/ecc.c ****                     ret = MEMORY_E;
13152:../src/wolfcrypt/src/ecc.c ****                     break;
13153:../src/wolfcrypt/src/ecc.c ****                 }
13154:../src/wolfcrypt/src/ecc.c ****             #else
13155:../src/wolfcrypt/src/ecc.c ****                 Hmac hmac[1];
13156:../src/wolfcrypt/src/ecc.c ****             #endif
13157:../src/wolfcrypt/src/ecc.c ****                 ret = wc_HmacInit(hmac, NULL, INVALID_DEVID);
13158:../src/wolfcrypt/src/ecc.c ****                 if (ret == 0) {
13159:../src/wolfcrypt/src/ecc.c ****                     ret = wc_HmacSetKey(hmac, WC_SHA256, macKey,
13160:../src/wolfcrypt/src/ecc.c ****                                                          WC_SHA256_DIGEST_SIZE);
13161:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0)
13162:../src/wolfcrypt/src/ecc.c ****                         ret = wc_HmacUpdate(hmac, msg, msgSz-digestSz);
13163:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0)
13164:../src/wolfcrypt/src/ecc.c ****                         ret = wc_HmacUpdate(hmac, ctx->macSalt, ctx->macSaltSz);
13165:../src/wolfcrypt/src/ecc.c **** 
13166:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0)
13167:../src/wolfcrypt/src/ecc.c ****                         ret = wc_HmacFinal(hmac, verify);
13168:../src/wolfcrypt/src/ecc.c ****                     if ((ret == 0) && (XMEMCMP(verify, msg + msgSz - digestSz,
13169:../src/wolfcrypt/src/ecc.c ****                                                               digestSz) != 0)) {
13170:../src/wolfcrypt/src/ecc.c ****                         ret = -1;
13171:../src/wolfcrypt/src/ecc.c ****                     }
13172:../src/wolfcrypt/src/ecc.c **** 
13173:../src/wolfcrypt/src/ecc.c ****                     wc_HmacFree(hmac);
13174:../src/wolfcrypt/src/ecc.c ****                 }
13175:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
13176:../src/wolfcrypt/src/ecc.c ****                 XFREE(hmac, ctx->heap, DYNAMIC_TYPE_HMAC);
13177:../src/wolfcrypt/src/ecc.c ****             #endif
13178:../src/wolfcrypt/src/ecc.c ****                 break;
13179:../src/wolfcrypt/src/ecc.c ****             }
13180:../src/wolfcrypt/src/ecc.c **** 
13181:../src/wolfcrypt/src/ecc.c ****             default:
13182:../src/wolfcrypt/src/ecc.c ****                 ret = BAD_FUNC_ARG;
13183:../src/wolfcrypt/src/ecc.c ****                 break;
13184:../src/wolfcrypt/src/ecc.c ****         }
13185:../src/wolfcrypt/src/ecc.c ****     }
13186:../src/wolfcrypt/src/ecc.c **** 
13187:../src/wolfcrypt/src/ecc.c ****     if (ret == 0) {
13188:../src/wolfcrypt/src/ecc.c ****         switch (ctx->encAlgo) {
13189:../src/wolfcrypt/src/ecc.c ****         #if !defined(NO_AES) && defined(HAVE_AES_CBC)
13190:../src/wolfcrypt/src/ecc.c ****             case ecAES_128_CBC:
13191:../src/wolfcrypt/src/ecc.c ****             case ecAES_256_CBC:
13192:../src/wolfcrypt/src/ecc.c ****             {
13193:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
13194:../src/wolfcrypt/src/ecc.c ****                 Aes *aes = (Aes *)XMALLOC(sizeof *aes, ctx->heap,
13195:../src/wolfcrypt/src/ecc.c ****                                           DYNAMIC_TYPE_AES);
13196:../src/wolfcrypt/src/ecc.c ****                 if (aes == NULL) {
13197:../src/wolfcrypt/src/ecc.c ****                     ret = MEMORY_E;
13198:../src/wolfcrypt/src/ecc.c ****                     break;
13199:../src/wolfcrypt/src/ecc.c ****                 }
13200:../src/wolfcrypt/src/ecc.c ****             #else
13201:../src/wolfcrypt/src/ecc.c ****                 Aes aes[1];
13202:../src/wolfcrypt/src/ecc.c ****             #endif
13203:../src/wolfcrypt/src/ecc.c ****                 ret = wc_AesInit(aes, NULL, INVALID_DEVID);
13204:../src/wolfcrypt/src/ecc.c ****                 if (ret == 0) {
13205:../src/wolfcrypt/src/ecc.c ****                     ret = wc_AesSetKey(aes, encKey, encKeySz, encIv,
13206:../src/wolfcrypt/src/ecc.c ****                                                                 AES_DECRYPTION);
13207:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0) {
13208:../src/wolfcrypt/src/ecc.c ****                         ret = wc_AesCbcDecrypt(aes, out, msg, msgSz-digestSz);
13209:../src/wolfcrypt/src/ecc.c ****                     #if defined(WOLFSSL_ASYNC_CRYPT) && \
13210:../src/wolfcrypt/src/ecc.c ****                                                     defined(WC_ASYNC_ENABLE_AES)
13211:../src/wolfcrypt/src/ecc.c ****                         ret = wc_AsyncWait(ret, &aes->asyncDev,
13212:../src/wolfcrypt/src/ecc.c ****                                                             WC_ASYNC_FLAG_NONE);
13213:../src/wolfcrypt/src/ecc.c ****                     #endif
13214:../src/wolfcrypt/src/ecc.c ****                     }
13215:../src/wolfcrypt/src/ecc.c ****                     wc_AesFree(aes);
13216:../src/wolfcrypt/src/ecc.c ****                 }
13217:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
13218:../src/wolfcrypt/src/ecc.c ****                 XFREE(aes, ctx->heap, DYNAMIC_TYPE_AES);
13219:../src/wolfcrypt/src/ecc.c ****             #endif
13220:../src/wolfcrypt/src/ecc.c ****                 break;
13221:../src/wolfcrypt/src/ecc.c ****             }
13222:../src/wolfcrypt/src/ecc.c ****         #endif
13223:../src/wolfcrypt/src/ecc.c ****         #if !defined(NO_AES) && defined(WOLFSSL_AES_COUNTER)
13224:../src/wolfcrypt/src/ecc.c ****             case ecAES_128_CTR:
13225:../src/wolfcrypt/src/ecc.c ****             case ecAES_256_CTR:
13226:../src/wolfcrypt/src/ecc.c ****             {
13227:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
13228:../src/wolfcrypt/src/ecc.c ****                 Aes *aes = (Aes *)XMALLOC(sizeof *aes, ctx->heap,
13229:../src/wolfcrypt/src/ecc.c ****                                           DYNAMIC_TYPE_AES);
13230:../src/wolfcrypt/src/ecc.c ****                 if (aes == NULL) {
13231:../src/wolfcrypt/src/ecc.c ****                     ret = MEMORY_E;
13232:../src/wolfcrypt/src/ecc.c ****                     break;
13233:../src/wolfcrypt/src/ecc.c ****                 }
13234:../src/wolfcrypt/src/ecc.c ****              #else
13235:../src/wolfcrypt/src/ecc.c ****                 Aes aes[1];
13236:../src/wolfcrypt/src/ecc.c ****              #endif
13237:../src/wolfcrypt/src/ecc.c ****                 ret = wc_AesInit(aes, NULL, INVALID_DEVID);
13238:../src/wolfcrypt/src/ecc.c ****                 if (ret == 0) {
13239:../src/wolfcrypt/src/ecc.c ****                     ret = wc_AesSetKey(aes, encKey, encKeySz, encIv,
13240:../src/wolfcrypt/src/ecc.c ****                                                                 AES_ENCRYPTION);
13241:../src/wolfcrypt/src/ecc.c ****                     if (ret == 0) {
13242:../src/wolfcrypt/src/ecc.c ****                         ret = wc_AesCtrEncrypt(aes, out, msg, msgSz-digestSz);
13243:../src/wolfcrypt/src/ecc.c ****                     #if defined(WOLFSSL_ASYNC_CRYPT) && \
13244:../src/wolfcrypt/src/ecc.c ****                                                     defined(WC_ASYNC_ENABLE_AES)
13245:../src/wolfcrypt/src/ecc.c ****                         ret = wc_AsyncWait(ret, &aes->asyncDev,
13246:../src/wolfcrypt/src/ecc.c ****                                                             WC_ASYNC_FLAG_NONE);
13247:../src/wolfcrypt/src/ecc.c ****                     #endif
13248:../src/wolfcrypt/src/ecc.c ****                     }
13249:../src/wolfcrypt/src/ecc.c ****                     wc_AesFree(aes);
13250:../src/wolfcrypt/src/ecc.c ****                 }
13251:../src/wolfcrypt/src/ecc.c ****             #ifdef WOLFSSL_SMALL_STACK
13252:../src/wolfcrypt/src/ecc.c ****                 XFREE(aes, ctx->heap, DYNAMIC_TYPE_AES);
13253:../src/wolfcrypt/src/ecc.c ****             #endif
13254:../src/wolfcrypt/src/ecc.c ****                 break;
13255:../src/wolfcrypt/src/ecc.c ****             }
13256:../src/wolfcrypt/src/ecc.c ****         #endif
13257:../src/wolfcrypt/src/ecc.c ****             default:
13258:../src/wolfcrypt/src/ecc.c ****                 ret = BAD_FUNC_ARG;
13259:../src/wolfcrypt/src/ecc.c ****                 break;
13260:../src/wolfcrypt/src/ecc.c ****         }
13261:../src/wolfcrypt/src/ecc.c ****     }
13262:../src/wolfcrypt/src/ecc.c **** 
13263:../src/wolfcrypt/src/ecc.c ****     if (ret == 0)
13264:../src/wolfcrypt/src/ecc.c ****        *outSz = msgSz - digestSz;
13265:../src/wolfcrypt/src/ecc.c **** 
13266:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
13267:../src/wolfcrypt/src/ecc.c **** 
13268:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_ECIES_OLD
13269:../src/wolfcrypt/src/ecc.c ****     if (pubKey == peerKey)
13270:../src/wolfcrypt/src/ecc.c ****         wc_ecc_free(peerKey);
13271:../src/wolfcrypt/src/ecc.c **** #endif
13272:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13273:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_ECIES_OLD
13274:../src/wolfcrypt/src/ecc.c ****     if (peerKey != NULL) {
13275:../src/wolfcrypt/src/ecc.c ****         XFREE(peerKey, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
13276:../src/wolfcrypt/src/ecc.c ****     }
13277:../src/wolfcrypt/src/ecc.c **** #endif
13278:../src/wolfcrypt/src/ecc.c ****     XFREE(sharedSecret, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
13279:../src/wolfcrypt/src/ecc.c ****     XFREE(keys, ctx->heap, DYNAMIC_TYPE_ECC_BUFFER);
13280:../src/wolfcrypt/src/ecc.c **** #endif
13281:../src/wolfcrypt/src/ecc.c **** 
13282:../src/wolfcrypt/src/ecc.c ****     return ret;
13283:../src/wolfcrypt/src/ecc.c **** }
13284:../src/wolfcrypt/src/ecc.c **** 
13285:../src/wolfcrypt/src/ecc.c **** 
13286:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_ECC_ENCRYPT */
13287:../src/wolfcrypt/src/ecc.c **** 
13288:../src/wolfcrypt/src/ecc.c **** 
13289:../src/wolfcrypt/src/ecc.c **** #ifdef HAVE_COMP_KEY
13290:../src/wolfcrypt/src/ecc.c **** #if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
13291:../src/wolfcrypt/src/ecc.c ****     !defined(WOLFSSL_CRYPTOCELL)
13292:../src/wolfcrypt/src/ecc.c **** 
13293:../src/wolfcrypt/src/ecc.c **** #ifndef WOLFSSL_SP_MATH
13294:../src/wolfcrypt/src/ecc.c **** /* computes the jacobi c = (a | n) (or Legendre if n is prime)
13295:../src/wolfcrypt/src/ecc.c ****  */
13296:../src/wolfcrypt/src/ecc.c **** int mp_jacobi(mp_int* a, mp_int* n, int* c)
13297:../src/wolfcrypt/src/ecc.c **** {
13298:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13299:../src/wolfcrypt/src/ecc.c ****     mp_int*  a1 = NULL;
13300:../src/wolfcrypt/src/ecc.c ****     mp_int*  n1 = NULL;
13301:../src/wolfcrypt/src/ecc.c **** #else
13302:../src/wolfcrypt/src/ecc.c ****     mp_int   a1[1], n1[1];
13303:../src/wolfcrypt/src/ecc.c **** #endif
13304:../src/wolfcrypt/src/ecc.c ****     int      res;
13305:../src/wolfcrypt/src/ecc.c ****     int      s = 1;
13306:../src/wolfcrypt/src/ecc.c ****     int      k;
13307:../src/wolfcrypt/src/ecc.c ****     mp_int*  t[2];
13308:../src/wolfcrypt/src/ecc.c ****     mp_int*  ts;
13309:../src/wolfcrypt/src/ecc.c ****     mp_digit residue;
13310:../src/wolfcrypt/src/ecc.c **** 
13311:../src/wolfcrypt/src/ecc.c ****     if (mp_isneg(a) == MP_YES) {
13312:../src/wolfcrypt/src/ecc.c ****         return MP_VAL;
13313:../src/wolfcrypt/src/ecc.c ****     }
13314:../src/wolfcrypt/src/ecc.c ****     if (mp_isneg(n) == MP_YES) {
13315:../src/wolfcrypt/src/ecc.c ****         return MP_VAL;
13316:../src/wolfcrypt/src/ecc.c ****     }
13317:../src/wolfcrypt/src/ecc.c ****     if (mp_iseven(n) == MP_YES) {
13318:../src/wolfcrypt/src/ecc.c ****         return MP_VAL;
13319:../src/wolfcrypt/src/ecc.c ****     }
13320:../src/wolfcrypt/src/ecc.c **** 
13321:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13322:../src/wolfcrypt/src/ecc.c ****     a1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_BIGINT);
13323:../src/wolfcrypt/src/ecc.c ****     if (a1 == NULL) {
13324:../src/wolfcrypt/src/ecc.c ****         return MP_MEM;
13325:../src/wolfcrypt/src/ecc.c ****     }
13326:../src/wolfcrypt/src/ecc.c ****     n1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_BIGINT);
13327:../src/wolfcrypt/src/ecc.c ****     if (n1 == NULL) {
13328:../src/wolfcrypt/src/ecc.c ****         XFREE(a1, NULL, DYNAMIC_TYPE_BIGINT);
13329:../src/wolfcrypt/src/ecc.c ****         return MP_MEM;
13330:../src/wolfcrypt/src/ecc.c ****     }
13331:../src/wolfcrypt/src/ecc.c **** #endif
13332:../src/wolfcrypt/src/ecc.c **** 
13333:../src/wolfcrypt/src/ecc.c ****     if ((res = mp_init_multi(a1, n1, NULL, NULL, NULL, NULL)) != MP_OKAY) {
13334:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13335:../src/wolfcrypt/src/ecc.c ****         XFREE(a1, NULL, DYNAMIC_TYPE_BIGINT);
13336:../src/wolfcrypt/src/ecc.c ****         XFREE(n1, NULL, DYNAMIC_TYPE_BIGINT);
13337:../src/wolfcrypt/src/ecc.c **** #endif
13338:../src/wolfcrypt/src/ecc.c ****         return res;
13339:../src/wolfcrypt/src/ecc.c ****     }
13340:../src/wolfcrypt/src/ecc.c **** 
13341:../src/wolfcrypt/src/ecc.c ****     SAVE_VECTOR_REGISTERS(return _svr_ret;);
13342:../src/wolfcrypt/src/ecc.c **** 
13343:../src/wolfcrypt/src/ecc.c ****     if ((res = mp_mod(a, n, a1)) != MP_OKAY) {
13344:../src/wolfcrypt/src/ecc.c ****         goto done;
13345:../src/wolfcrypt/src/ecc.c ****     }
13346:../src/wolfcrypt/src/ecc.c **** 
13347:../src/wolfcrypt/src/ecc.c ****     if ((res = mp_copy(n, n1)) != MP_OKAY) {
13348:../src/wolfcrypt/src/ecc.c ****         goto done;
13349:../src/wolfcrypt/src/ecc.c ****     }
13350:../src/wolfcrypt/src/ecc.c **** 
13351:../src/wolfcrypt/src/ecc.c ****     t[0] = a1;
13352:../src/wolfcrypt/src/ecc.c ****     t[1] = n1;
13353:../src/wolfcrypt/src/ecc.c **** 
13354:../src/wolfcrypt/src/ecc.c ****     /* Keep reducing until first number is 0. */
13355:../src/wolfcrypt/src/ecc.c ****     while (!mp_iszero(t[0])) {
13356:../src/wolfcrypt/src/ecc.c ****         /* Divide by 2 until odd. */
13357:../src/wolfcrypt/src/ecc.c ****         k = mp_cnt_lsb(t[0]);
13358:../src/wolfcrypt/src/ecc.c ****         if (k > 0) {
13359:../src/wolfcrypt/src/ecc.c ****             mp_rshb(t[0], k);
13360:../src/wolfcrypt/src/ecc.c **** 
13361:../src/wolfcrypt/src/ecc.c ****             /* Negate s each time we divide by 2 if t[1] mod 8 == 3 or 5.
13362:../src/wolfcrypt/src/ecc.c ****              * Odd number of divides results in a negate.
13363:../src/wolfcrypt/src/ecc.c ****              */
13364:../src/wolfcrypt/src/ecc.c ****             residue = t[1]->dp[0] & 7;
13365:../src/wolfcrypt/src/ecc.c ****             if ((k & 1) && ((residue == 3) || (residue == 5))) {
13366:../src/wolfcrypt/src/ecc.c ****                 s = -s;
13367:../src/wolfcrypt/src/ecc.c ****             }
13368:../src/wolfcrypt/src/ecc.c ****         }
13369:../src/wolfcrypt/src/ecc.c **** 
13370:../src/wolfcrypt/src/ecc.c ****         /* Swap t[0] and t[1]. */
13371:../src/wolfcrypt/src/ecc.c ****         ts   = t[0];
13372:../src/wolfcrypt/src/ecc.c ****         t[0] = t[1];
13373:../src/wolfcrypt/src/ecc.c ****         t[1] = ts;
13374:../src/wolfcrypt/src/ecc.c **** 
13375:../src/wolfcrypt/src/ecc.c ****         /* Negate s if both numbers == 3 mod 4. */
13376:../src/wolfcrypt/src/ecc.c ****         if (((t[0]->dp[0] & 3) == 3) && ((t[1]->dp[0] & 3) == 3)) {
13377:../src/wolfcrypt/src/ecc.c ****              s = -s;
13378:../src/wolfcrypt/src/ecc.c ****         }
13379:../src/wolfcrypt/src/ecc.c **** 
13380:../src/wolfcrypt/src/ecc.c ****         /* Reduce first number modulo second. */
13381:../src/wolfcrypt/src/ecc.c ****         if ((k == 0) && (mp_count_bits(t[0]) == mp_count_bits(t[1]))) {
13382:../src/wolfcrypt/src/ecc.c ****             res = mp_sub(t[0], t[1], t[0]);
13383:../src/wolfcrypt/src/ecc.c ****         }
13384:../src/wolfcrypt/src/ecc.c ****         else {
13385:../src/wolfcrypt/src/ecc.c ****             res = mp_mod(t[0], t[1], t[0]);
13386:../src/wolfcrypt/src/ecc.c ****         }
13387:../src/wolfcrypt/src/ecc.c ****         if (res != MP_OKAY) {
13388:../src/wolfcrypt/src/ecc.c ****             goto done;
13389:../src/wolfcrypt/src/ecc.c ****         }
13390:../src/wolfcrypt/src/ecc.c ****     }
13391:../src/wolfcrypt/src/ecc.c **** 
13392:../src/wolfcrypt/src/ecc.c ****     /* When the two numbers have divisors in common. */
13393:../src/wolfcrypt/src/ecc.c ****     if (!mp_isone(t[1])) {
13394:../src/wolfcrypt/src/ecc.c ****         s = 0;
13395:../src/wolfcrypt/src/ecc.c ****     }
13396:../src/wolfcrypt/src/ecc.c ****     *c = s;
13397:../src/wolfcrypt/src/ecc.c **** 
13398:../src/wolfcrypt/src/ecc.c **** done:
13399:../src/wolfcrypt/src/ecc.c **** 
13400:../src/wolfcrypt/src/ecc.c ****     RESTORE_VECTOR_REGISTERS();
13401:../src/wolfcrypt/src/ecc.c **** 
13402:../src/wolfcrypt/src/ecc.c ****     /* cleanup */
13403:../src/wolfcrypt/src/ecc.c ****     mp_clear(n1);
13404:../src/wolfcrypt/src/ecc.c ****     mp_clear(a1);
13405:../src/wolfcrypt/src/ecc.c **** 
13406:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13407:../src/wolfcrypt/src/ecc.c ****     XFREE(a1, NULL, DYNAMIC_TYPE_BIGINT);
13408:../src/wolfcrypt/src/ecc.c ****     XFREE(n1, NULL, DYNAMIC_TYPE_BIGINT);
13409:../src/wolfcrypt/src/ecc.c **** #endif
13410:../src/wolfcrypt/src/ecc.c **** 
13411:../src/wolfcrypt/src/ecc.c ****   return res;
13412:../src/wolfcrypt/src/ecc.c **** }
13413:../src/wolfcrypt/src/ecc.c **** 
13414:../src/wolfcrypt/src/ecc.c **** 
13415:../src/wolfcrypt/src/ecc.c **** /* Solves the modular equation x^2 = n (mod p)
13416:../src/wolfcrypt/src/ecc.c ****  * where prime number is greater than 2 (odd prime).
13417:../src/wolfcrypt/src/ecc.c ****  * The result is returned in the third argument x
13418:../src/wolfcrypt/src/ecc.c ****  * the function returns MP_OKAY on success, MP_VAL or another error on failure
13419:../src/wolfcrypt/src/ecc.c ****  */
13420:../src/wolfcrypt/src/ecc.c **** int mp_sqrtmod_prime(mp_int* n, mp_int* prime, mp_int* ret)
13421:../src/wolfcrypt/src/ecc.c **** {
13422:../src/wolfcrypt/src/ecc.c **** #ifdef SQRTMOD_USE_MOD_EXP
13423:../src/wolfcrypt/src/ecc.c ****   int res;
13424:../src/wolfcrypt/src/ecc.c **** 
13425:../src/wolfcrypt/src/ecc.c ****   mp_int e;
13426:../src/wolfcrypt/src/ecc.c **** 
13427:../src/wolfcrypt/src/ecc.c ****   SAVE_VECTOR_REGISTERS(return _svr_ret;);
13428:../src/wolfcrypt/src/ecc.c **** 
13429:../src/wolfcrypt/src/ecc.c ****   res = mp_init(&e);
13430:../src/wolfcrypt/src/ecc.c ****   if (res == MP_OKAY)
13431:../src/wolfcrypt/src/ecc.c ****       res = mp_add_d(prime, 1, &e);
13432:../src/wolfcrypt/src/ecc.c ****   if (res == MP_OKAY)
13433:../src/wolfcrypt/src/ecc.c ****       res = mp_div_2d(&e, 2, &e, NULL);
13434:../src/wolfcrypt/src/ecc.c ****   if (res == MP_OKAY)
13435:../src/wolfcrypt/src/ecc.c ****       res = mp_exptmod(n, &e, prime, ret);
13436:../src/wolfcrypt/src/ecc.c **** 
13437:../src/wolfcrypt/src/ecc.c ****   mp_clear(&e);
13438:../src/wolfcrypt/src/ecc.c **** 
13439:../src/wolfcrypt/src/ecc.c ****   RESTORE_VECTOR_REGISTERS();
13440:../src/wolfcrypt/src/ecc.c **** 
13441:../src/wolfcrypt/src/ecc.c ****   return res;
13442:../src/wolfcrypt/src/ecc.c **** #else
13443:../src/wolfcrypt/src/ecc.c ****   int res, legendre, done = 0;
13444:../src/wolfcrypt/src/ecc.c ****   mp_digit i;
13445:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13446:../src/wolfcrypt/src/ecc.c ****   mp_int *t1 = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13447:../src/wolfcrypt/src/ecc.c ****   mp_int *C = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13448:../src/wolfcrypt/src/ecc.c ****   mp_int *Q = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13449:../src/wolfcrypt/src/ecc.c ****   mp_int *S = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13450:../src/wolfcrypt/src/ecc.c ****   mp_int *Z = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13451:../src/wolfcrypt/src/ecc.c ****   mp_int *M = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13452:../src/wolfcrypt/src/ecc.c ****   mp_int *T = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13453:../src/wolfcrypt/src/ecc.c ****   mp_int *R = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13454:../src/wolfcrypt/src/ecc.c ****   mp_int *N = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13455:../src/wolfcrypt/src/ecc.c ****   mp_int *two = (mp_int *)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC_BUFFER);
13456:../src/wolfcrypt/src/ecc.c **** #else
13457:../src/wolfcrypt/src/ecc.c ****   mp_int t1[1], C[1], Q[1], S[1], Z[1], M[1], T[1], R[1], N[1], two[1];
13458:../src/wolfcrypt/src/ecc.c **** #endif
13459:../src/wolfcrypt/src/ecc.c **** 
13460:../src/wolfcrypt/src/ecc.c ****   SAVE_VECTOR_REGISTERS(res = _svr_ret; goto out;);
13461:../src/wolfcrypt/src/ecc.c **** 
13462:../src/wolfcrypt/src/ecc.c ****   if ((mp_init_multi(t1, C, Q, S, Z, M) != MP_OKAY) ||
13463:../src/wolfcrypt/src/ecc.c ****       (mp_init_multi(T, R, N, two, NULL, NULL) != MP_OKAY)) {
13464:../src/wolfcrypt/src/ecc.c ****     res = MP_INIT_E;
13465:../src/wolfcrypt/src/ecc.c ****     goto out;
13466:../src/wolfcrypt/src/ecc.c ****   }
13467:../src/wolfcrypt/src/ecc.c **** 
13468:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13469:../src/wolfcrypt/src/ecc.c ****   if ((t1 == NULL) ||
13470:../src/wolfcrypt/src/ecc.c ****       (C == NULL) ||
13471:../src/wolfcrypt/src/ecc.c ****       (Q == NULL) ||
13472:../src/wolfcrypt/src/ecc.c ****       (S == NULL) ||
13473:../src/wolfcrypt/src/ecc.c ****       (Z == NULL) ||
13474:../src/wolfcrypt/src/ecc.c ****       (M == NULL) ||
13475:../src/wolfcrypt/src/ecc.c ****       (T == NULL) ||
13476:../src/wolfcrypt/src/ecc.c ****       (R == NULL) ||
13477:../src/wolfcrypt/src/ecc.c ****       (N == NULL) ||
13478:../src/wolfcrypt/src/ecc.c ****       (two == NULL)) {
13479:../src/wolfcrypt/src/ecc.c ****     res = MP_MEM;
13480:../src/wolfcrypt/src/ecc.c ****     goto out;
13481:../src/wolfcrypt/src/ecc.c ****   }
13482:../src/wolfcrypt/src/ecc.c **** #endif
13483:../src/wolfcrypt/src/ecc.c **** 
13484:../src/wolfcrypt/src/ecc.c ****   /* first handle the simple cases n = 0 or n = 1 */
13485:../src/wolfcrypt/src/ecc.c ****   if (mp_cmp_d(n, 0) == MP_EQ) {
13486:../src/wolfcrypt/src/ecc.c ****     mp_zero(ret);
13487:../src/wolfcrypt/src/ecc.c ****     res = MP_OKAY;
13488:../src/wolfcrypt/src/ecc.c ****     goto out;
13489:../src/wolfcrypt/src/ecc.c ****   }
13490:../src/wolfcrypt/src/ecc.c ****   if (mp_cmp_d(n, 1) == MP_EQ) {
13491:../src/wolfcrypt/src/ecc.c ****     res = mp_set(ret, 1);
13492:../src/wolfcrypt/src/ecc.c ****     goto out;
13493:../src/wolfcrypt/src/ecc.c ****   }
13494:../src/wolfcrypt/src/ecc.c **** 
13495:../src/wolfcrypt/src/ecc.c ****   /* prime must be odd */
13496:../src/wolfcrypt/src/ecc.c ****   if (mp_cmp_d(prime, 2) == MP_EQ) {
13497:../src/wolfcrypt/src/ecc.c ****     res = MP_VAL;
13498:../src/wolfcrypt/src/ecc.c ****     goto out;
13499:../src/wolfcrypt/src/ecc.c ****   }
13500:../src/wolfcrypt/src/ecc.c **** 
13501:../src/wolfcrypt/src/ecc.c ****   /* reduce n to less than prime */
13502:../src/wolfcrypt/src/ecc.c ****   res = mp_mod(n, prime, N);
13503:../src/wolfcrypt/src/ecc.c ****   if (res != MP_OKAY) {
13504:../src/wolfcrypt/src/ecc.c ****     goto out;
13505:../src/wolfcrypt/src/ecc.c ****   }
13506:../src/wolfcrypt/src/ecc.c ****   /* when N is zero, sqrt is zero */
13507:../src/wolfcrypt/src/ecc.c ****   if (mp_iszero(N)) {
13508:../src/wolfcrypt/src/ecc.c ****     mp_set(ret, 0);
13509:../src/wolfcrypt/src/ecc.c ****     goto out;
13510:../src/wolfcrypt/src/ecc.c ****   }
13511:../src/wolfcrypt/src/ecc.c **** 
13512:../src/wolfcrypt/src/ecc.c ****   /* is quadratic non-residue mod prime */
13513:../src/wolfcrypt/src/ecc.c ****   if ((res = mp_jacobi(N, prime, &legendre)) != MP_OKAY) {
13514:../src/wolfcrypt/src/ecc.c ****     goto out;
13515:../src/wolfcrypt/src/ecc.c ****   }
13516:../src/wolfcrypt/src/ecc.c ****   if (legendre == -1) {
13517:../src/wolfcrypt/src/ecc.c ****     res = MP_VAL;
13518:../src/wolfcrypt/src/ecc.c ****     goto out;
13519:../src/wolfcrypt/src/ecc.c ****   }
13520:../src/wolfcrypt/src/ecc.c **** 
13521:../src/wolfcrypt/src/ecc.c ****   /* SPECIAL CASE: if prime mod 4 == 3
13522:../src/wolfcrypt/src/ecc.c ****    * compute directly: res = n^(prime+1)/4 mod prime
13523:../src/wolfcrypt/src/ecc.c ****    * Handbook of Applied Cryptography algorithm 3.36
13524:../src/wolfcrypt/src/ecc.c ****    */
13525:../src/wolfcrypt/src/ecc.c ****   res = mp_mod_d(prime, 4, &i);
13526:../src/wolfcrypt/src/ecc.c ****   if (res == MP_OKAY && i == 3) {
13527:../src/wolfcrypt/src/ecc.c ****     res = mp_add_d(prime, 1, t1);
13528:../src/wolfcrypt/src/ecc.c **** 
13529:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13530:../src/wolfcrypt/src/ecc.c ****       res = mp_div_2(t1, t1);
13531:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13532:../src/wolfcrypt/src/ecc.c ****       res = mp_div_2(t1, t1);
13533:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13534:../src/wolfcrypt/src/ecc.c ****       res = mp_exptmod(N, t1, prime, ret);
13535:../src/wolfcrypt/src/ecc.c **** 
13536:../src/wolfcrypt/src/ecc.c ****     done = 1;
13537:../src/wolfcrypt/src/ecc.c ****   }
13538:../src/wolfcrypt/src/ecc.c **** 
13539:../src/wolfcrypt/src/ecc.c ****   /* NOW: TonelliShanks algorithm */
13540:../src/wolfcrypt/src/ecc.c ****   if (res == MP_OKAY && done == 0) {
13541:../src/wolfcrypt/src/ecc.c **** 
13542:../src/wolfcrypt/src/ecc.c ****     /* factor out powers of 2 from prime-1, defining Q and S
13543:../src/wolfcrypt/src/ecc.c ****     *                                      as: prime-1 = Q*2^S */
13544:../src/wolfcrypt/src/ecc.c ****     /* Q = prime - 1 */
13545:../src/wolfcrypt/src/ecc.c ****     res = mp_copy(prime, Q);
13546:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13547:../src/wolfcrypt/src/ecc.c ****       res = mp_sub_d(Q, 1, Q);
13548:../src/wolfcrypt/src/ecc.c **** 
13549:../src/wolfcrypt/src/ecc.c ****     /* S = 0 */
13550:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13551:../src/wolfcrypt/src/ecc.c ****       mp_zero(S);
13552:../src/wolfcrypt/src/ecc.c **** 
13553:../src/wolfcrypt/src/ecc.c ****     while (res == MP_OKAY && mp_iseven(Q) == MP_YES) {
13554:../src/wolfcrypt/src/ecc.c ****       /* Q = Q / 2 */
13555:../src/wolfcrypt/src/ecc.c ****       res = mp_div_2(Q, Q);
13556:../src/wolfcrypt/src/ecc.c **** 
13557:../src/wolfcrypt/src/ecc.c ****       /* S = S + 1 */
13558:../src/wolfcrypt/src/ecc.c ****       if (res == MP_OKAY)
13559:../src/wolfcrypt/src/ecc.c ****         res = mp_add_d(S, 1, S);
13560:../src/wolfcrypt/src/ecc.c ****     }
13561:../src/wolfcrypt/src/ecc.c **** 
13562:../src/wolfcrypt/src/ecc.c ****     /* find a Z such that the Legendre symbol (Z|prime) == -1 */
13563:../src/wolfcrypt/src/ecc.c ****     /* Z = 2 */
13564:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13565:../src/wolfcrypt/src/ecc.c ****       res = mp_set_int(Z, 2);
13566:../src/wolfcrypt/src/ecc.c **** 
13567:../src/wolfcrypt/src/ecc.c ****     while (res == MP_OKAY) {
13568:../src/wolfcrypt/src/ecc.c ****       res = mp_jacobi(Z, prime, &legendre);
13569:../src/wolfcrypt/src/ecc.c ****       if (res == MP_OKAY && legendre == -1)
13570:../src/wolfcrypt/src/ecc.c ****         break;
13571:../src/wolfcrypt/src/ecc.c **** 
13572:../src/wolfcrypt/src/ecc.c ****       /* Z = Z + 1 */
13573:../src/wolfcrypt/src/ecc.c ****       if (res == MP_OKAY)
13574:../src/wolfcrypt/src/ecc.c ****         res = mp_add_d(Z, 1, Z);
13575:../src/wolfcrypt/src/ecc.c ****     }
13576:../src/wolfcrypt/src/ecc.c **** 
13577:../src/wolfcrypt/src/ecc.c ****     /* C = Z ^ Q mod prime */
13578:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13579:../src/wolfcrypt/src/ecc.c ****       res = mp_exptmod(Z, Q, prime, C);
13580:../src/wolfcrypt/src/ecc.c **** 
13581:../src/wolfcrypt/src/ecc.c ****     /* t1 = (Q + 1) / 2 */
13582:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13583:../src/wolfcrypt/src/ecc.c ****       res = mp_add_d(Q, 1, t1);
13584:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13585:../src/wolfcrypt/src/ecc.c ****       res = mp_div_2(t1, t1);
13586:../src/wolfcrypt/src/ecc.c **** 
13587:../src/wolfcrypt/src/ecc.c ****     /* R = n ^ ((Q + 1) / 2) mod prime */
13588:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13589:../src/wolfcrypt/src/ecc.c ****       res = mp_exptmod(N, t1, prime, R);
13590:../src/wolfcrypt/src/ecc.c **** 
13591:../src/wolfcrypt/src/ecc.c ****     /* T = n ^ Q mod prime */
13592:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13593:../src/wolfcrypt/src/ecc.c ****       res = mp_exptmod(N, Q, prime, T);
13594:../src/wolfcrypt/src/ecc.c **** 
13595:../src/wolfcrypt/src/ecc.c ****     /* M = S */
13596:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13597:../src/wolfcrypt/src/ecc.c ****       res = mp_copy(S, M);
13598:../src/wolfcrypt/src/ecc.c **** 
13599:../src/wolfcrypt/src/ecc.c ****     if (res == MP_OKAY)
13600:../src/wolfcrypt/src/ecc.c ****       res = mp_set_int(two, 2);
13601:../src/wolfcrypt/src/ecc.c **** 
13602:../src/wolfcrypt/src/ecc.c ****     while (res == MP_OKAY && done == 0) {
13603:../src/wolfcrypt/src/ecc.c ****       res = mp_copy(T, t1);
13604:../src/wolfcrypt/src/ecc.c **** 
13605:../src/wolfcrypt/src/ecc.c ****       /* reduce to 1 and count */
13606:../src/wolfcrypt/src/ecc.c ****       i = 0;
13607:../src/wolfcrypt/src/ecc.c ****       while (res == MP_OKAY) {
13608:../src/wolfcrypt/src/ecc.c ****         if (mp_cmp_d(t1, 1) == MP_EQ)
13609:../src/wolfcrypt/src/ecc.c ****             break;
13610:../src/wolfcrypt/src/ecc.c ****         res = mp_exptmod(t1, two, prime, t1);
13611:../src/wolfcrypt/src/ecc.c ****         if (res == MP_OKAY)
13612:../src/wolfcrypt/src/ecc.c ****           i++;
13613:../src/wolfcrypt/src/ecc.c ****       }
13614:../src/wolfcrypt/src/ecc.c ****       if (res == MP_OKAY && i == 0) {
13615:../src/wolfcrypt/src/ecc.c ****         res = mp_copy(R, ret);
13616:../src/wolfcrypt/src/ecc.c ****         done = 1;
13617:../src/wolfcrypt/src/ecc.c ****       }
13618:../src/wolfcrypt/src/ecc.c **** 
13619:../src/wolfcrypt/src/ecc.c ****       if (done == 0) {
13620:../src/wolfcrypt/src/ecc.c ****         /* t1 = 2 ^ (M - i - 1) */
13621:../src/wolfcrypt/src/ecc.c ****         if (res == MP_OKAY)
13622:../src/wolfcrypt/src/ecc.c ****           res = mp_sub_d(M, i, t1);
13623:../src/wolfcrypt/src/ecc.c ****         if (res == MP_OKAY)
13624:../src/wolfcrypt/src/ecc.c ****           res = mp_sub_d(t1, 1, t1);
13625:../src/wolfcrypt/src/ecc.c ****         if (res == MP_OKAY)
13626:../src/wolfcrypt/src/ecc.c ****           res = mp_exptmod(two, t1, prime, t1);
13627:../src/wolfcrypt/src/ecc.c **** 
13628:../src/wolfcrypt/src/ecc.c ****         /* t1 = C ^ (2 ^ (M - i - 1)) mod prime */
13629:../src/wolfcrypt/src/ecc.c ****         if (res == MP_OKAY)
13630:../src/wolfcrypt/src/ecc.c ****           res = mp_exptmod(C, t1, prime, t1);
13631:../src/wolfcrypt/src/ecc.c **** 
13632:../src/wolfcrypt/src/ecc.c ****         /* C = (t1 * t1) mod prime */
13633:../src/wolfcrypt/src/ecc.c ****         if (res == MP_OKAY)
13634:../src/wolfcrypt/src/ecc.c ****           res = mp_sqrmod(t1, prime, C);
13635:../src/wolfcrypt/src/ecc.c **** 
13636:../src/wolfcrypt/src/ecc.c ****         /* R = (R * t1) mod prime */
13637:../src/wolfcrypt/src/ecc.c ****         if (res == MP_OKAY)
13638:../src/wolfcrypt/src/ecc.c ****           res = mp_mulmod(R, t1, prime, R);
13639:../src/wolfcrypt/src/ecc.c **** 
13640:../src/wolfcrypt/src/ecc.c ****         /* T = (T * C) mod prime */
13641:../src/wolfcrypt/src/ecc.c ****         if (res == MP_OKAY)
13642:../src/wolfcrypt/src/ecc.c ****           res = mp_mulmod(T, C, prime, T);
13643:../src/wolfcrypt/src/ecc.c **** 
13644:../src/wolfcrypt/src/ecc.c ****         /* M = i */
13645:../src/wolfcrypt/src/ecc.c ****         if (res == MP_OKAY)
13646:../src/wolfcrypt/src/ecc.c ****           res = mp_set(M, i);
13647:../src/wolfcrypt/src/ecc.c ****       }
13648:../src/wolfcrypt/src/ecc.c ****     }
13649:../src/wolfcrypt/src/ecc.c ****   }
13650:../src/wolfcrypt/src/ecc.c **** 
13651:../src/wolfcrypt/src/ecc.c ****   out:
13652:../src/wolfcrypt/src/ecc.c **** 
13653:../src/wolfcrypt/src/ecc.c ****   RESTORE_VECTOR_REGISTERS();
13654:../src/wolfcrypt/src/ecc.c **** 
13655:../src/wolfcrypt/src/ecc.c **** #ifdef WOLFSSL_SMALL_STACK
13656:../src/wolfcrypt/src/ecc.c ****   if (t1) {
13657:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13658:../src/wolfcrypt/src/ecc.c ****       mp_clear(t1);
13659:../src/wolfcrypt/src/ecc.c ****     XFREE(t1, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13660:../src/wolfcrypt/src/ecc.c ****   }
13661:../src/wolfcrypt/src/ecc.c ****   if (C) {
13662:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13663:../src/wolfcrypt/src/ecc.c ****       mp_clear(C);
13664:../src/wolfcrypt/src/ecc.c ****     XFREE(C, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13665:../src/wolfcrypt/src/ecc.c ****   }
13666:../src/wolfcrypt/src/ecc.c ****   if (Q) {
13667:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13668:../src/wolfcrypt/src/ecc.c ****       mp_clear(Q);
13669:../src/wolfcrypt/src/ecc.c ****     XFREE(Q, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13670:../src/wolfcrypt/src/ecc.c ****   }
13671:../src/wolfcrypt/src/ecc.c ****   if (S) {
13672:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13673:../src/wolfcrypt/src/ecc.c ****       mp_clear(S);
13674:../src/wolfcrypt/src/ecc.c ****     XFREE(S, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13675:../src/wolfcrypt/src/ecc.c ****   }
13676:../src/wolfcrypt/src/ecc.c ****   if (Z) {
13677:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13678:../src/wolfcrypt/src/ecc.c ****       mp_clear(Z);
13679:../src/wolfcrypt/src/ecc.c ****     XFREE(Z, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13680:../src/wolfcrypt/src/ecc.c ****   }
13681:../src/wolfcrypt/src/ecc.c ****   if (M) {
13682:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13683:../src/wolfcrypt/src/ecc.c ****       mp_clear(M);
13684:../src/wolfcrypt/src/ecc.c ****     XFREE(M, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13685:../src/wolfcrypt/src/ecc.c ****   }
13686:../src/wolfcrypt/src/ecc.c ****   if (T) {
13687:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13688:../src/wolfcrypt/src/ecc.c ****       mp_clear(T);
13689:../src/wolfcrypt/src/ecc.c ****     XFREE(T, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13690:../src/wolfcrypt/src/ecc.c ****   }
13691:../src/wolfcrypt/src/ecc.c ****   if (R) {
13692:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13693:../src/wolfcrypt/src/ecc.c ****       mp_clear(R);
13694:../src/wolfcrypt/src/ecc.c ****     XFREE(R, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13695:../src/wolfcrypt/src/ecc.c ****   }
13696:../src/wolfcrypt/src/ecc.c ****   if (N) {
13697:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13698:../src/wolfcrypt/src/ecc.c ****       mp_clear(N);
13699:../src/wolfcrypt/src/ecc.c ****     XFREE(N, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13700:../src/wolfcrypt/src/ecc.c ****   }
13701:../src/wolfcrypt/src/ecc.c ****   if (two) {
13702:../src/wolfcrypt/src/ecc.c ****     if (res != MP_INIT_E)
13703:../src/wolfcrypt/src/ecc.c ****       mp_clear(two);
13704:../src/wolfcrypt/src/ecc.c ****     XFREE(two, NULL, DYNAMIC_TYPE_ECC_BUFFER);
13705:../src/wolfcrypt/src/ecc.c ****   }
13706:../src/wolfcrypt/src/ecc.c **** #else
13707:../src/wolfcrypt/src/ecc.c ****   if (res != MP_INIT_E) {
13708:../src/wolfcrypt/src/ecc.c ****     mp_clear(t1);
13709:../src/wolfcrypt/src/ecc.c ****     mp_clear(C);
13710:../src/wolfcrypt/src/ecc.c ****     mp_clear(Q);
13711:../src/wolfcrypt/src/ecc.c ****     mp_clear(S);
13712:../src/wolfcrypt/src/ecc.c ****     mp_clear(Z);
13713:../src/wolfcrypt/src/ecc.c ****     mp_clear(M);
13714:../src/wolfcrypt/src/ecc.c ****     mp_clear(T);
13715:../src/wolfcrypt/src/ecc.c ****     mp_clear(R);
13716:../src/wolfcrypt/src/ecc.c ****     mp_clear(N);
13717:../src/wolfcrypt/src/ecc.c ****     mp_clear(two);
13718:../src/wolfcrypt/src/ecc.c ****   }
13719:../src/wolfcrypt/src/ecc.c **** #endif
13720:../src/wolfcrypt/src/ecc.c **** 
13721:../src/wolfcrypt/src/ecc.c ****   return res;
13722:../src/wolfcrypt/src/ecc.c **** #endif
13723:../src/wolfcrypt/src/ecc.c **** }
13724:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_SP_MATH */
13725:../src/wolfcrypt/src/ecc.c **** #endif /* !WOLFSSL_ATECC508A && !WOLFSSL_ATECC608A && !WOLFSSL_CRYPTOCELL */
13726:../src/wolfcrypt/src/ecc.c **** 
13727:../src/wolfcrypt/src/ecc.c **** 
13728:../src/wolfcrypt/src/ecc.c **** /* export public ECC key in ANSI X9.63 format compressed */
13729:../src/wolfcrypt/src/ecc.c **** static int wc_ecc_export_x963_compressed(ecc_key* key, byte* out, word32* outLen)
13730:../src/wolfcrypt/src/ecc.c **** {
13731:../src/wolfcrypt/src/ecc.c ****    word32 numlen;
13732:../src/wolfcrypt/src/ecc.c ****    int    ret = MP_OKAY;
13733:../src/wolfcrypt/src/ecc.c **** 
13734:../src/wolfcrypt/src/ecc.c ****    if (key == NULL || outLen == NULL)
13735:../src/wolfcrypt/src/ecc.c ****        return BAD_FUNC_ARG;
13736:../src/wolfcrypt/src/ecc.c **** 
13737:../src/wolfcrypt/src/ecc.c ****    if (key->type == ECC_PRIVATEKEY_ONLY)
13738:../src/wolfcrypt/src/ecc.c ****        return ECC_PRIVATEONLY_E;
13739:../src/wolfcrypt/src/ecc.c **** 
13740:../src/wolfcrypt/src/ecc.c ****    if (key->type == 0 || wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL){
13741:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
13742:../src/wolfcrypt/src/ecc.c ****    }
13743:../src/wolfcrypt/src/ecc.c **** 
13744:../src/wolfcrypt/src/ecc.c ****    numlen = key->dp->size;
13745:../src/wolfcrypt/src/ecc.c **** 
13746:../src/wolfcrypt/src/ecc.c ****    if (*outLen < (1 + numlen)) {
13747:../src/wolfcrypt/src/ecc.c ****       *outLen = 1 + numlen;
13748:../src/wolfcrypt/src/ecc.c ****       return LENGTH_ONLY_E;
13749:../src/wolfcrypt/src/ecc.c ****    }
13750:../src/wolfcrypt/src/ecc.c **** 
13751:../src/wolfcrypt/src/ecc.c ****    if (out == NULL)
13752:../src/wolfcrypt/src/ecc.c ****        return BAD_FUNC_ARG;
13753:../src/wolfcrypt/src/ecc.c **** 
13754:../src/wolfcrypt/src/ecc.c ****    if (mp_unsigned_bin_size(key->pubkey.x) > (int)numlen)
13755:../src/wolfcrypt/src/ecc.c ****        return ECC_BAD_ARG_E;
13756:../src/wolfcrypt/src/ecc.c **** 
13757:../src/wolfcrypt/src/ecc.c ****    /* store first byte */
13758:../src/wolfcrypt/src/ecc.c ****    out[0] = mp_isodd(key->pubkey.y) == MP_YES ? ECC_POINT_COMP_ODD : ECC_POINT_COMP_EVEN;
13759:../src/wolfcrypt/src/ecc.c **** 
13760:../src/wolfcrypt/src/ecc.c ****    /* pad and store x */
13761:../src/wolfcrypt/src/ecc.c ****    XMEMSET(out+1, 0, numlen);
13762:../src/wolfcrypt/src/ecc.c ****    ret = mp_to_unsigned_bin(key->pubkey.x,
13763:../src/wolfcrypt/src/ecc.c ****                        out+1 + (numlen - mp_unsigned_bin_size(key->pubkey.x)));
13764:../src/wolfcrypt/src/ecc.c ****    *outLen = 1 + numlen;
13765:../src/wolfcrypt/src/ecc.c **** 
13766:../src/wolfcrypt/src/ecc.c ****    return ret;
13767:../src/wolfcrypt/src/ecc.c **** }
13768:../src/wolfcrypt/src/ecc.c **** 
13769:../src/wolfcrypt/src/ecc.c **** #endif /* HAVE_COMP_KEY */
13770:../src/wolfcrypt/src/ecc.c **** 
13771:../src/wolfcrypt/src/ecc.c **** 
13772:../src/wolfcrypt/src/ecc.c **** int wc_ecc_get_oid(word32 oidSum, const byte** oid, word32* oidSz)
13773:../src/wolfcrypt/src/ecc.c **** {
 14150                             		.loc 2 13773 1
 14151 0000 7E AA                   		push.l	r10
 14152                             	.LCFI258:
 14153 0002 71 0A EC                		add	#-20, r0, r10
 14154                             	.LCFI259:
 14155 0005 EF A0                   		mov.L	r10, r0
 14156 0007 E7 A1 02                		mov.L	r1, 8[r10]
 14157 000a E7 A2 03                		mov.L	r2, 12[r10]
 14158 000d E7 A3 04                		mov.L	r3, 16[r10]
13774:../src/wolfcrypt/src/ecc.c ****     int x;
13775:../src/wolfcrypt/src/ecc.c **** 
13776:../src/wolfcrypt/src/ecc.c ****     if (oidSum == 0) {
 14159                             		.loc 2 13776 8
 14160 0010 ED A5 02                		mov.L	8[r10], r5
 14161 0013 61 05                   		cmp	#0, r5
 14162 0015 18                      		bne	.L987
13777:../src/wolfcrypt/src/ecc.c ****         return BAD_FUNC_ARG;
 14163                             		.loc 2 13777 16
 14164 0016 FB 5A 53 FF             		mov.L	#-173, r5
 14165 001a 38 94 00                		bra	.L988
 14166                             	.L987:
13778:../src/wolfcrypt/src/ecc.c ****     }
13779:../src/wolfcrypt/src/ecc.c **** 
13780:../src/wolfcrypt/src/ecc.c ****     /* find matching OID sum (based on encoded value) */
13781:../src/wolfcrypt/src/ecc.c ****     for (x = 0; ecc_sets[x].size != 0; x++) {
 14167                             		.loc 2 13781 12
 14168 001d F8 A6 00                		mov.L	#0, [r10]
 14169                             		.loc 2 13781 5
 14170 0020 2E 76                   		bra	.L989
 14171                             	.L993:
13782:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[x].oidSum == oidSum) {
 14172                             		.loc 2 13782 24
 14173 0022 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 14174 0028 EC A5                   		mov.L	[r10], r5
 14175 002a 75 15 34                		mul	#52, r5
 14176 002d 4B 45                   		add	r4, r5
 14177 002f 71 55 2C                		add	#44, r5
 14178 0032 EC 55                   		mov.L	[r5], r5
 14179                             		.loc 2 13782 12
 14180 0034 ED A4 02                		mov.L	8[r10], r4
 14181 0037 47 54                   		cmp	r5, r4
 14182 0039 21 57                   		bne	.L990
 14183                             	.LBB97:
13783:../src/wolfcrypt/src/ecc.c ****             int ret;
13784:../src/wolfcrypt/src/ecc.c ****         #ifdef HAVE_OID_ENCODING
13785:../src/wolfcrypt/src/ecc.c ****             ret = 0;
13786:../src/wolfcrypt/src/ecc.c ****             /* check cache */
13787:../src/wolfcrypt/src/ecc.c ****             oid_cache_t* o = &ecc_oid_cache[x];
13788:../src/wolfcrypt/src/ecc.c ****             if (o->oidSz == 0) {
13789:../src/wolfcrypt/src/ecc.c ****                 o->oidSz = sizeof(o->oid);
13790:../src/wolfcrypt/src/ecc.c ****                 ret = EncodeObjectId(ecc_sets[x].oid, ecc_sets[x].oidSz,
13791:../src/wolfcrypt/src/ecc.c ****                                                             o->oid, &o->oidSz);
13792:../src/wolfcrypt/src/ecc.c ****             }
13793:../src/wolfcrypt/src/ecc.c ****             if (oidSz) {
13794:../src/wolfcrypt/src/ecc.c ****                 *oidSz = o->oidSz;
13795:../src/wolfcrypt/src/ecc.c ****             }
13796:../src/wolfcrypt/src/ecc.c ****             if (oid) {
13797:../src/wolfcrypt/src/ecc.c ****                 *oid = o->oid;
13798:../src/wolfcrypt/src/ecc.c ****             }
13799:../src/wolfcrypt/src/ecc.c ****             /* on success return curve id */
13800:../src/wolfcrypt/src/ecc.c ****             if (ret == 0) {
13801:../src/wolfcrypt/src/ecc.c ****                 ret = ecc_sets[x].id;
13802:../src/wolfcrypt/src/ecc.c ****             }
13803:../src/wolfcrypt/src/ecc.c ****         #else
13804:../src/wolfcrypt/src/ecc.c ****             if (oidSz) {
 14184                             		.loc 2 13804 16
 14185 003b ED A5 04                		mov.L	16[r10], r5
 14186 003e 61 05                   		cmp	#0, r5
 14187 0040 20 19                   		beq	.L991
13805:../src/wolfcrypt/src/ecc.c ****                 *oidSz = ecc_sets[x].oidSz;
 14188                             		.loc 2 13805 37
 14189 0042 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 14190 0048 EC A5                   		mov.L	[r10], r5
 14191 004a 75 15 34                		mul	#52, r5
 14192 004d 4B 45                   		add	r4, r5
 14193 004f 71 55 28                		add	#40, r5
 14194 0052 EC 54                   		mov.L	[r5], r4
 14195                             		.loc 2 13805 24
 14196 0054 ED A5 04                		mov.L	16[r10], r5
 14197 0057 E3 54                   		mov.L	r4, [r5]
 14198                             	.L991:
13806:../src/wolfcrypt/src/ecc.c ****             }
13807:../src/wolfcrypt/src/ecc.c ****             if (oid) {
 14199                             		.loc 2 13807 16
 14200 0059 ED A5 03                		mov.L	12[r10], r5
 14201 005c 61 05                   		cmp	#0, r5
 14202 005e 20 19                   		beq	.L992
13808:../src/wolfcrypt/src/ecc.c ****                 *oid = ecc_sets[x].oid;
 14203                             		.loc 2 13808 35
 14204 0060 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 14205 0066 EC A5                   		mov.L	[r10], r5
 14206 0068 75 15 34                		mul	#52, r5
 14207 006b 4B 45                   		add	r4, r5
 14208 006d 71 55 24                		add	#36, r5
 14209 0070 EC 54                   		mov.L	[r5], r4
 14210                             		.loc 2 13808 22
 14211 0072 ED A5 03                		mov.L	12[r10], r5
 14212 0075 E3 54                   		mov.L	r4, [r5]
 14213                             	.L992:
13809:../src/wolfcrypt/src/ecc.c ****             }
13810:../src/wolfcrypt/src/ecc.c ****             ret = ecc_sets[x].id;
 14214                             		.loc 2 13810 17
 14215 0077 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 14216 007d EC A5                   		mov.L	[r10], r5
 14217 007f 75 15 34                		mul	#52, r5
 14218 0082 4B 45                   		add	r4, r5
 14219 0084 62 45                   		add	#4, r5
 14220 0086 EC 55                   		mov.L	[r5], r5
 14221 0088 E7 A5 01                		mov.L	r5, 4[r10]
13811:../src/wolfcrypt/src/ecc.c ****         #endif
13812:../src/wolfcrypt/src/ecc.c ****             return ret;
 14222                             		.loc 2 13812 20
 14223 008b ED A5 01                		mov.L	4[r10], r5
 14224 008e 2E 20                   		bra	.L988
 14225                             	.L990:
 14226                             	.LBE97:
13781:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[x].oidSum == oidSum) {
 14227                             		.loc 2 13781 41 discriminator 2
 14228 0090 EC A5                   		mov.L	[r10], r5
 14229 0092 62 15                   		add	#1, r5
 14230 0094 E3 A5                   		mov.L	r5, [r10]
 14231                             	.L989:
13781:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[x].oidSum == oidSum) {
 14232                             		.loc 2 13781 28 discriminator 1
 14233 0096 FB 42 00 00 00 00       		mov.L	#_ecc_sets, r4
 14234 009c EC A5                   		mov.L	[r10], r5
 14235 009e 75 15 34                		mul	#52, r5
 14236 00a1 4B 45                   		add	r4, r5
 14237 00a3 EC 55                   		mov.L	[r5], r5
13781:../src/wolfcrypt/src/ecc.c ****         if (ecc_sets[x].oidSum == oidSum) {
 14238                             		.loc 2 13781 5 discriminator 1
 14239 00a5 61 05                   		cmp	#0, r5
 14240 00a7 3B 7B FF                		bne	.L993
13813:../src/wolfcrypt/src/ecc.c ****         }
13814:../src/wolfcrypt/src/ecc.c ****     }
13815:../src/wolfcrypt/src/ecc.c **** 
13816:../src/wolfcrypt/src/ecc.c ****     return NOT_COMPILED_IN;
 14241                             		.loc 2 13816 12
 14242 00aa FB 5A 52 FF             		mov.L	#-174, r5
 14243                             	.L988:
13817:../src/wolfcrypt/src/ecc.c **** }
 14244                             		.loc 2 13817 1
 14245 00ae EF 51                   		mov.L	r5, r1
 14246 00b0 3F AA 06                		rtsd	#24, r10-r10
 14247                             	.LFE141:
 16546                             	.Letext0:
 16547                             		.file 3 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\lib\\gcc\\rx-
 16548                             		.file 4 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 16549                             		.file 5 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 16550                             		.file 6 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 16551                             		.file 7 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 16552                             		.file 8 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/types.h"
 16553                             		.file 9 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 16554                             		.file 10 "c:\\programdata\\gcc for renesas rx 8.3.0.202202-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\incl
 16555                             		.file 11 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sp_int.h"
 16556                             		.file 12 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha256.h"
 16557                             		.file 13 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/random.h"
 16558                             		.file 14 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/wolfmath.h"
 16559                             		.file 15 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/asn_public.h"
 16560                             		.file 16 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/ecc.h"
 16561                             		.file 17 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/sha.h"
 16562                             		.file 18 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/md5.h"
 16563                             		.file 19 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/asn.h"
 16564                             		.file 20 "C:\\Users\\nekom\\e2_studio\\e2sss_proj\\wolflib\\src/wolfssl/wolfcrypt/error-crypt.h"
